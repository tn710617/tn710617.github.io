{"pages":[{"title":"關於我","text":"你好, 這是我的部落格, 我是 Ray, 一個後端開發者, 喜歡 Dev, 也熱愛 Ops。 喜歡語言, 機器語言或人類語言, 語言是通往資訊的門。 樂於分享, 想在能力所及範圍內幫助到別人。 迷戀成長, 已對每天一點一滴成長的感覺成癮。","link":"/zh-tw/about/index.html"},{"title":"archives","text":"","link":"/zh-tw/archives/index.html"},{"title":"categories","text":"","link":"/zh-tw/categories/index.html"},{"title":"Japanese","text":"2020-5-22郵便局で切手を買いました 彼女 夕食には何を食べたいですか 彼女は三人の子供の母親だ 話すのを止めてください このコートはとても暖かい 手紙が届くのに三日かかりました 輸入 そのデモについて政府は何もしなかった 生活 全てのシステムが停止した 合格者が発表された ほとんど 計算 この建物の構造は複雑です 技術 提供 まあ今回は許してあげよう 駅の前に新しいコンビニができました、それから、駅の後ろにもコンビニができました カレーライスのほうが美味しいです お釣をください 彼は中国語と英語ができます 私は彼に使い捨ての箸をあげます 私は茶碗蒸しがあまり嫌いではありません 新しいパソコンを買いましたけれども、キーボードがありません 私の妹は飴をくれましたね、ありがとう どうして遅刻した 役所の人は私たちに道を案内してくれます 知り合い 湖 タプレット 芸能人 大人 芸能人 2020-5-20見つける 見せる 今日は日本語の授業があります 肩 感じる 彼女はイタリア語ができます 九つ 近所で盗難事件が起こりました 手伝う ため 辛い 力 生活 音楽は彼の得意な分野です 技術 塩、こしょうを加えてください 増える 輸入 資金 会社 この建物の構造は複雑です 集める 私は四つの会社に投資しています 販売 変化 料理がたくさん残りました お金をたくさん振り込んだくせに、商品が全く来ません 広い部屋をください 役所の人は私たちに道を案内してくだます 何で学校に行くのですか 弟は父の性格がわかります ベッドの下にゴキブリがいます それで？ これからどうします 台北駅はどこですか 水族館 こんにちは 美術館 竹 スーツケースに詰める 技術 輸入 この建物の構造は複雑です 役所の人は私たちに道を案内してくれます 2020-5-19妹は平仮名を全部覚えました 今日 兄は水泳が得意です 安い 数 考える 私には友達がたくさんいます 死ぬ 歩く 冷たい 見える 黄色い 米 八つ 違う 段階 この段階では決断するのはまだ早い もう 二十キロのダイエットは可能だと思いますか その事件の犯人はまだ捕まっていない この商品はよく売れている 以上 方針 今夜は大いに語りましょう 存在 昨日財布をなくしました。それに、傘も電車に忘れました それから、南投の有名な牧場に行きました 台北駅はどこですか クラスを静かにする 日本、ヨーロッパ、そしてアメリカを旅行しました お金を振り込んだくせに、商品が全く来ません 台北駅はどこですか お釣をください 道を迷いました。それで、交番に道を尋ねに聞きました もう25歳なのに、両親からお小遣いをもらいます 北川三亜はたくさん食べましたけれども、全然太りません ニュースで道の状況がわかります 何で学校に行くのですか 有名 フライドチキン 名詞 レンタサイクル 親切 スーツケースに詰める 腹部は、肋とお尻の間の部分です カニが浜辺を歩いている 男性は顎髭がたくさん生えているが、頭の毛が少ないです お金を振り込んだくせに、商品が全く来ません 何で学校に行くのですか スーツケースに詰める 2020-5-18楽しむ 結婚 彼はまだ若いです 約束を忘れないでください 弱い 一緒に 冷たい飲み物をください 彼は私の方を見ました 八つ 乾く 曲がる 五 円 暖かい 決定 生まれる 全体の80%が完成しました 分野 原因 試合の相手は誰ですか 表現 制度 発生 ジーンズを買いましょうか もう25歳なのに、両親からお小遣いをもらいます 昨日財布をなくしました。それに、傘も電車に忘れました いつが暇ですか 土曜日か日曜日 氷山が小さくなる タバコを吸ってはいけません 買いてくれますか 私は弟と妹と実家に帰りました 法律を破ってはいけません 本棚に小説と雑誌があります 昨日何処かに行きますか いいえ、どこも行きませんでした 私は飛行機で日本に行きます コーヒーを飲みましょうか お釣をください あのバカは二本の鉛筆を箸にして、ご飯を食べる 課長 期末レポート 乗客 昨日 牛 木製の化粧ダンス もう25歳なのに、両親からお小遣いをもらいます お釣をください 2020-5-17そこ 飛行機 次 私たちのチームはその試合で負けた まだ学校へ行くには早い時間です 開ける 彼は時々遅刻します 近所で盗難事件が起こりました お腹 お母さんによろしくを伝えください 米 答えが違います そこには私一人しかいなかった 八つ 時計を見たらちょうど3時だった 彼女はアメリカの企業で働いています 比べる 外国 対象 今回 そのデモについて政府は何もしなかった 建設 生産 私達は今結婚資金を貯めています この商品はよく売れている 信号が青に変わりました 部屋を綺麗にする 飛行機か二時間遅れました。なので、到着時間も遅くなります 国中さんはあなたにギターをもらいましたね 引き出しにハムスターが一匹います それで？ これからどうします これはノートです ペットを買いましょうか まず 次に そして それから 最後に クラスを静かにする 私の部屋は狭くて、暗くて、汚いです ピザを買いました、パスタも買いました 浅い川 見てくれますか あの日本料理の店は広くて、美味しくて、安いです 美術館 使い捨て 水族館 てん 果物 引き出し 炒める 2020-5-16使う 出る 違う ななつ お手洗い 皿にケーキを載せました 髪の毛が伸びたね 終わり 治る 悪い 腰 私が手伝いましょう 八つ 災害に備えて大量の水を買い込んだ 彼は選挙に出るつもりだ この商品はよく売れている 八つ 頃 影響 建設 姿 評価 現在 特徴 彼は小学校の先生ですから、子供の親からのプレシャーが大きでしょう あの喫茶店は静かなので、あそこで勉強する人が多いでしょう 旅行会社の人は家族に海外旅行のビザを申し込んでくれました 私は鉛筆で字を書く インターネットで新幹線の時刻表がわかります 和食と言えば、寿司や味噌汁や天ぷらなどです 私は日本語がまあまあできます 最近雨の日が多いです。それに、台風もにこ来ました クラスを静かにする この商品はよく売れている いつが暇ですか どうして？これからどうします クラスを静かにする 焼き鳥 火曜日 会議 明日 水族館 美術館 それで、ここからどうします 水族館 フロント め 美術館 2020-5-15この服はとても安かった 彼は荷物を網棚にあげた 彼の日本語のレベルは私の同じくらいだ 弱い 持つ 質問 その子は体が少し弱い 八日からイギリスに行きます 新学期は来月の四日からです この葡萄は酸っぱいです 今晩のパーティーは何時からですか 話すのを止めてください 七日 姿 段階 それは最近話題の本ですね 調べる 販売 初めに、会長が挨拶した 我が社の経営はうまくいっています 中村さんは昨日10時まで仕事をしましたので、残業代はたくさんもらえるでしょう 王さんは彼女とギターを弾いあげます ベッドの下にゴキブリがいます 夏なのに、陽明山で雪が降りました 簡単な質問 彼は運動場で倒れました。そして、3分後救急車がきました 静かな教室 いつが暇ですか 今日は何曜日ですか なぜ台湾の会社は大学生を雇いたくないのですか 電気屋の人は私に新しいテレビを運んでくれました 餌 キャベツ ワンピース 文房具 知り合い 葉が落ちます 茶髪 腹部は、肋とお尻の間の部分です 炒める いつが暇ですか 2020-5-14京都にはお寺が多い 学校は8時半に始まります 払う 今朝は早く家を出ました 弱い 月 時の経つのは早い 水を一杯ください 彼はシートベルト締めた 辺 クーラーはまだ直りません 食べ物 今夜は大いに語りましょう 予定 彼女は自分の立場をわかっていない 二社は互いに競争している トラブルがやっと解決した 年 発生 集める そのデモについて政府は何もしなかった 対象 これら 構造 すみません、今は何時ですか 絵を描く 授業をしている教師 弱い 飲み物を買いませんでした なんで台湾の会社は大学生を雇いたくないのですか 先生はクラスメートに綺麗な絵本を貸してあげます どうして今日遅刻した 明後日 看板 タプレット 木製のロッキングチェア フクロウ ㎝ 2020-5-13髪 一番 私は朝シャワーを浴びます 町で大事件が起こりました 彼は医者になりました 寝る 閉まる 予約は要りません 彼はこの辺に住んでいます 小さい 閉める 彼は神を信じている 一日 決定 現在、スペシャルキャンペーンを実施じゅです 政治 対象 彼女の大きな帽子はとても目立つ そのデモについて政府は何もしなかった 表現 販売 外国 先生はクラスメートに綺麗な絵本を貸してあげます そっか、今度早く家を出る 弟は父の性格がわかります ペットと言えば、犬や猫や兎やネズミなどです 私の苦手なことは料理を作ることです 楽しい一日 私はご飯を食べて、テレビを見て、宿題をする 合格点 ゴキブリ 空港 対象 ビザ 乗客 腹部は、あばらとお尻の間の部分です 教授が図を説明する そのデモについて政府は何もしなかった 2020-5-12少し 見せる 妹は平仮名を全部覚えました 言葉 今日は日本語の授業があります 寒い 私は腕時計を四つ持っています わからない場合は私に聞いて下さい 生産 競争 いずれ 計画を一部変更しましょう 建設 対する 情報 示す それは世界最大の船です 彼は一人旅の計画を立てた 普及 計算 今夜は大いに語りましょう 販売 私は彼から大きな影響受けました 今回 彼は運動場で倒れました。そして、3分後救急車がきました 机の上にペンが二本あります ベッドの下にゴキブリがいます コンピューターを買いましたけれども、キーボードがありません 部屋を綺麗にする 私は新しいゲームソフトを買いました。なので、バイト代が全部なくなりました シャワーを浴びる象 私の部屋は狭くて、暗くて、汚いです 大きくて 小さくて 広くて 狭くて 私は親友と遊びたいです 犬が大きくありません この車はとんでもなく高いくせに、すぐ故障します 販売 私はサラリーマンです。彼もサラリーマンです えっと、電車が遅れたので、遅刻しました 目覚まし時計をかけたのに、なかなかなりません 私は歌を歌うことごできます 一眼レフカメラ 小学生 数字の17 腹部は、あばらとお尻の間の部分です 腹部は、肋とお尻の間の部分です 2020-5-11まだ これは医者のためのサイトです 二つ 三日 乾く 動かないで 話すのを止めてください 東京に来るのは初めてです 消える ドル 加える 従来 制度 集める この携帯電話が使えるのは国内だけです 与える 規模 今夜は大いに語りましょう その問題に関する記事を読みました 交差点で事故が発生した 中心 表現 対策 一緒に対策を考えましょう 私は非常に懐石料理が好きです どうして今日遅刻した 鉛筆は短くありません ここの公務員は暇なくせに、文句を言います 昨日、彼は財布をなくしました。それに、傘も電車に忘れました 彼女は朱さんに中間テストのノートをもらいました コーヒーを飲みましょう あの歌手は有名だけれども、歌が下手です 夜中にギターを弾いてはいけません 私は書店で本を買って、開いて、読む 鶏肉 生まれる 博物館 中華料理 果物 焼き鳥 虎 世界 フロント 2020-5-10負ける 美しい この中でどれが好きですか カナダの冬はとても寒いです 直ぐ 郵便局で切手を買いました 四月に大学に入学しました 話すのを止めてください 財布は机の下にあった お先にどうぞ 彼女は眠いようです 特徴 関する 外国 彼は行政を改革したいと思っている 部長を除く全員が土曜日も働いた 相手 表現 構成 国は国語教育を強化しています 状態 彼は事故で怪我をしました この地域は雨が多い 受ける 全てのシステムが停止した 生活 今夜は大いに語りましょう 彼は小学校の先生ですから、子供の親からのプレシャーが大きでしょう シャワーを浴びる象 最近雨の日が多いです。それに、台風もにこきました 話すのを止めてください 彼は運動場で倒れました。そして、3分後救急車がきました 私の部屋は狭くて、暗くて、汚いです して きて 私は学校にバスで行きます 何も要りません ご飯と食べいる人 なぜ大体のお店は試食を置きますか 表現 スーパーは賑やかです どうして今日遅刻した くありません ゴミ箱にペットボトルがあります この本借りでもいいですか ベッドの下にゴキブリがいます 台湾は日本より暑いです 今夜は大いに語りましょう インターネットで新幹線の時刻表がわかります 私は鉛筆で字を書く ノートパソコン 知り合い 質問する どうして今日遅刻した 2020-5-9緑 私たちのチームはその試合で負けた 質問 冷たい 宿題は自分でやりなさい 出す 私は父が大好きです 彼女はよく喋るね お腹 原因 外国 ここは道の状態がとても悪いです 世界 集める 遠くに彼女の姿が見えた 関係 なお 建設 彼は小さな会社に勤めています 合格者が発表された あの塾はパートにチラシを配ってもらいます 私の部屋は狭くて、暗くて、汚いです 先生は難しい本を読むことができます お釣をください 私は懐石料理がとても好きです 浅い川 鉛筆は短いです 彼は運動場で倒れました。そして、3分後救急車がきました ベッドの下にゴキブリがいます ペットと言えば、犬や猫や兎やネズミなどです 布団 外国 焼き鳥 メロン 来年 下手 18 買い物カート 私は物理の基礎は知っています 私の部屋は狭くて、暗くて、汚いです 彼は運動場で倒れました。そして、3分後救急車がきました ベッドの下にゴキブリがいます 2020-5-8日曜日は図書館に行きます 起きる 見つける 二十日 花 黄色い 八日からイギリスに行きます 前 地域 今後ともよろしくお願いします 集める ほとんど 病院 それは全て事実ですか 信号が青に変わりました 私は茶碗蒸しがあまり嫌いではありません 部屋を綺麗にする ボタンを押す 学生ではありません 日曜日が暇です 彼は学校に来ませんでした 引き出しにハムスターが一匹います 私はもっと頑張りたかったです パソコンを買いましたけれども、キーボードがありません 給料をたくさんもらうくせに、全然仕事をしません ペットの言えば、犬や猫や兎やネズミなどです 今日は何曜日ですか 焼き鳥 フライドチキン 自動車 橋 実家 栓抜きありますか 私は物理の基礎は知っています 集める フルート フロント ペットと言えば、犬や猫や兎や鼠などです 焼き鳥 2020-5-7あげる たつ 少し 7つ 近く 私は二日待った 曜日を間違えました 強い 喋る よう 喉が乾きました ソフトクリームを二つください 我が社の経営はうまくいっています 彼は非常に高い技術を持っている 減る 建設 それは最近話題の本ですね 増える 社会 必要 計算 重要 あの人たちは皆、同じ方向を見ている 用いる 分野 夜中に、ギターを弾いてはいけません 私は鉛筆で字を書く このパソコン、使ってもいいですか はい、使ってもいいですよ パソコンを買いましたけれども、キーボードがありません インターネットで新幹線の時刻表がわかります リビングのソファで寝ました。それで、風邪をひきました あそこはコーヒーショップです 私は懐石料理が非常に好きです 昨日はテレビを見ました。それから、テストの勉強をしました 弟は父の性格がわかります 彼は小学校の先生ですから、子供の親からのプレシャーが大きでしょう あのノートは私のです 昨日、何処かに行きましたか いいえ、どこも行きませんでした 昨日、財布をなくしました。それに、傘も電車に忘れました なぜ大体のお店は試食を置きますか あの絵は美しいだけれども、誰も買いません フットボール ましょうか フロント あ フロント 2020-5-6少し疲れました 待つ 買う 見せる 彼はステージに立った 私は毎日日記をつけています 数 一日 クーラーはまだ直りません 彼は神を信じている 手紙が届くのに三日かかりました 見つかる 綺麗 来月の二十日は弟の誕生日です 彼はカバンから教科書を出した 辛い 投資 彼は選挙に出るつもりだ 昨年 事実 建設 報告 政権 先生はクラスメートに綺麗な絵本を貸してあげます 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです あなたは私にこのデジタルカメラをくれました 上野さんは彼女で映画と見ました 宮澤さんは課長のことを、どう思いますか あなたは国仲さんにゲームソフトをもらいましたね 授業をする教師 私は刺身があまり好きではありません 彼女は朱さんに中間テストのノートをもらいました 昨日、財布を無くしました。それに、傘も電車に忘れました インターネットで新幹線の時刻表がわかります 建設 テレビをつけましたけれども、画面がなかなか出ません 明日からは夏休みです。でも、宿題がいっぱいあります 昨日、財布をなくなりました。それに、傘も電車に忘れました インターネットで新幹線の時刻表がわかります 最近、雨の日が多いです。それに、台風もにこ来ました 旅行会社の人は家族に海外旅行のびざを申し込んでくれました 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 宝石 解答 知り合い 果物 テスクトップパソコン コンビニ弁当 葉が落ちます 茶髪 2020-5-5グラスの数が足りません 買う 続く 一番 今日は日本語の授業があります 親の愛は有難い 男の人は私たちに話しかけた 日 これはかなり金がかかった 開ける 風邪 制度 システムの構成を変えてみました 計算 それはどいう意味ですか 女性 ほぼ 彼は文章がとてもうまい 増える トラブルがやっと解決した 彼は新製品に興味を示している 管理 のち なお、雨の場合は中止です そっか、今度早く家を出ろ 広い部屋をください パソコンを買いましたけれども、キーボードがありません 部屋を綺麗にする 向日葵は草より綺麗です 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私は鉛筆で字を書く 夜中にギターを弾くいてはいけません 飛行機が二時間遅れました。なので、到着時間も遅くなります 電気屋の人は私に新しいテレビを運んでくれました あの車はとんでもたく高いくせに、すぐ故障します それで？ これからどうします いつが暇ですか 土曜日か日曜日です 彼は小学校の先生ですから、子供の親からのプレシャーが大きでしょう 車の乗客 知り合い 記憶 こんにちは 夜市 コーヒーショップ 布 羊 雄鶏 蝉 知り合い 2020-5-4大学 私には友達がたくさんいます 一つ 彼はカバンに手帳を入れた 質問 引く あなたはどう思いますか 彼に手紙を書きました 終わり 十日後に帰ります 時計を見たらちょうど3時だった 千円貸してください 分からない場合は私に聞いてください 入る その会社は来月キャンペンを行う お金はまだ十分あります その質問に対する答えが見つからなかった 商品 彼は選挙に出るつもりだ 引越しを業者に頼んだ 対する 計算 原因 激しい 写真はいい思い出になります 計算 国会 彼は事故で怪我をしました 部屋を綺麗にする 彼は小学校の先生ですから、子供の親からのプレシャーが大きでしょう 九份は賑やかです 電気屋の人は私に新しいテレビを運んでくれます 私は鉛筆で字を書く 浅い川 最近、雨の日が多いです。それに、台風もにこ来ました 二月に日本を旅行しました。それから、韓国と中国にも行きました 和食と言えば、寿司や味噌汁や天ぷらなどです 母は私に飴を買ってくれました みんなは運動会の予定がわかります 今日は何曜日ですか 彼女は朱さんに中間テストのノートをもらいました 床に蟻がいます デザートは美味しくありません 今日、何か買いますか はい、オレンジを買いました 私はサラリーマンで、父親です コンピューターを買いましたけれども、キーボードがありません タワー 顎髭 鶏肉 鳴いている雄鶏 部屋を綺麗にする 彼は小学校の先生ですから、子供の親からのプレシャーが大きでしょう 私は鉛筆で字を書く パソコンを買いましたけれども、キーボードがありません 2020-5-3短い 起こす 怒る 私は絵を見るのが好きです 美しい 冷たい 八日からイギリスに行きます 八日 茶色 起きる お腹 辛い 五日 私が手伝いましょう 引越しを業者に頼んだ 昨日の会議について報告があります 代表 調べる 生活 ドル 全てのシステムが停止した 分野 信号が青に変わりました 彼は就職試験を受けた 先生はクラスメートに綺麗な絵本を貸してあげます ご飯を食べる時に、テレビを見てはいけません シャワーを浴びる象 コーヒーを飲みましょう 道を迷いました。それで、交番に道を尋ねに行きました 机の上にペンが二本あります 今日は何曜日ですか 彼は小学校の先生ですから、子供の親からのプレシャーが多いでしょう 友達が朝9時に家に来ました。そして、夜6時にみんな帰りました タバコを吸ってはいけませんか いいえ、吸ってもいいですよ この絵がきれいいです。なのに、誰も買いません 猫の方が好きです こ 彼女は朱さんに中間テストのノートをもらいました 最近、雨の日が多いです。それに、台風もにこ来ました 九份は賑やかでした 今日は何曜日ですか 数字の17 体育館 竹 無料 質問する 蟹 帰る 走る 切る タンス 彼は小学校の先生ですから、子供の親からのプレシャーが多いでしょう 彼女は朱さんに中間テストのノートをもらいました 最近、雨の日が多いです。それに、台風もにこ来ました 2020-5-2会う 見せる 郵便局で切手を買いました こう 感じる 彼女は耳がよく聞こえません 私たちのチームはその試合で負けた 直ぐ カナダの冬はとても寒いです 赤いバラを買いました どこ 店 彼女はよく喋るね 彼に会えて嬉しかった 6 この道を真っ直ぐ行くと駅です 結果 会議で重要な決定がありました 変化 状態 なお 党の代表が質問に答えました 評価 仕事がほぼ終わりました 与える この店は高いですが、全然美味しくありません 昨日何処かに行きましたか いいえ、どこも行きませんでした 授業をしている教師 引き出しがハムスターが一匹います 先生はクラスメートに綺麗な絵本を貸してあげます 私の趣味は映画を見ることです もう25歳なのに、両親からお小遣いをもらいます 私は世界一周をしたくありませんでした これをください 弟は父の性格がわかります 今夜は蒸し暑いから、明日は雨が降るでしょう 夜中にギターを弾いてはいけません 浅い川 どこも行きません えっと、電車が遅れたので、遅刻しました 先生はクラスメートに綺麗な絵本を貸してあげました 行って 私はご飯を食べている 台風の時に、海辺で遊んではいけません 雨 鳥 猿 ハエ 2020-5-1姉は大学生です 一番 娘 取る 彼は足が短い 彼は荷物を網棚にあげた 見せる 質問 座る 低い お酒は大人になってから あなたが本当に好きです 髪の毛が伸びたね 四月に大学に入学しました 一杯 時 五人で旅行に行きました 最近株を始めたした 対策 期待 彼は事故で怪我をしました 我が社の経営はうまくいっています 分野 あの喫茶店は静かですから、あそこでテストの勉強しましょう 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 見せる お釣をください 私は宿題をします ジーンズを買いましょうか 日本の神社に参拝しましたよ。あ、それから、お守りも買いました 私は日本語があまりできません お金持ちのくせに、スーパーで散々値切りをしました 浅い川 彼女は彼氏に食事代を払ってもらいます 授業をしている教師 浅い川 私は茶碗蒸しがあまり嫌いではありません 果物 ツアーガイド 葉が落ちます 木製の化粧ダンス ぢ 授業をする教師 History","link":"/zh-tw/japanese/index.html"},{"title":"tags","text":"","link":"/zh-tw/tags/index.html"},{"title":"Schedule","text":"It would be a pleasure to be conscious of what I have done every day, which might always reminds me of what I’d done in the past, what I’m doing at the present, and what I want to achieve in the future. The target and result daily # Learning Log before April 2021 (2021 年 4 月前的每日目標與結果)","link":"/zh-tw/schedule/index.html"},{"title":"History","text":"2020AprilMarchFebruaryJanuary 2019DecemberNovemberOctoberSeptember","link":"/zh-tw/japanese/History/index.html"},{"title":"History","text":"# 2021MarchFebruaryJanuary # 2020DecemberNovemberOctoberSeptemberAugustJulyJuneMayAprilMarchFebruaryJanuary # 2019DecemberNovemberOctoberSeptemberAugustJulyJuneMayAprilMarchFebruaryJanuary # 2018DecemberNovember","link":"/zh-tw/schedule/History/index.html"},{"title":"December 2019","text":"2019-12-31私は朝シャワーを浴びます 座る 同じ 速い 家に帰ろう 兄は水泳が得意です 工事は3月まで続きます 漢字 彼は意外に気が小さい 新しい年が始まりました そう 近い 細い 腰 五日 私が手伝いましょう 手紙が届くのに三日かかりました 多分 採用 政府 建設 会談 彼は選挙に出るつもりだ 治る のち それは最近話題の本ですね 国会 写真はいい思い出になります 対策 一緒に対策を考えましょう 段階 生まれる 島の人口は年は年々増加しています 塩、こしょうを加えてください この携帯電話が使えるのは国内だけです ガソリンの価格がどんどん上がっている 留学してから私の世界が広がった 目的 事実 ゴミ箱にペットボトルがあります 何で学校に行くのですか 誰もいません お釣りをください あなたは小西さんに映画のチケットをもらいましたよね どうして今日遅刻した 私は日本語はあまりできません みんなは運動会の予定がわかります のち 母は日本料理ができます 中学生 翻訳する 炊飯器 隣人 フクロウが頭を上下に動かしている 医者は、患者の脈をとっている この携帯電話が使えるのは国内だけです 留学してから私の世界が広がった 2019-12-30彼は足が長い 遅い 近い 駅の近くで食事をした 家 私は朝シャワーを浴びます 彼の腕は太い 広い でる 軽い 他に方法がありません これは医者のためのサイトです 火曜日 お腹が空きました 昨日 かける 休む お腹 工場 強調 計画を一部変更しましょう ここは静かな住宅地だ 建設 資金 彼は小さな会社に勤めています 多く 電気がついたままですよ 意見 明らか 引越しを業者に頼んだ 私達は今結婚資金を貯めています 石原さんは彼に防虫スプレーをもらいました 役所の人はおばあちゃんに綺麗なカレンダーをくれました 私は朝シャワーを浴びます 学食の料理はまずいです。このレストランの料理もまずいです あの服のほうが可愛いです コンビニに電子レンジがあります 雑誌は辞書ほど厚くありません 中村さんは昨日夜十時まで仕事しましたので、残業代が沢山もらえるでしょう 犬は大きくありませんでした 国内旅行 建設 博物館 文房具 親戚 病院に入る ナイフ 妹 サイ 2019-12-29髪 姉 全部 赤いバラを買いました 次 美しい 生きる 目 彼女は眠いよです 夜 弟 晴れる 太い 私はパンよりご飯が好きだ その仕事は危険を伴う 計算 事故 いずれ この本を内容説明してください 変化 そのデモについて政府は何のしなかった 残る 増加 初めに、会長が挨拶した 姿 示す 商品 運動会は9時開始です 社長 毎年多くの人が海外へ旅行する まず相手の動きを見ましょう 彼女はマイカーを買いたがります 私は先生と職員室に行きました ペットを飼いましょう 飲み物を買いませんでした 雑誌は辞書ほと厚くありません 鉛筆は短くありません 飛行機が二時間遅れました。なので、到着時間も遅くなります 授業をした教師 小テストと中間テストと期末テスト、どれが難しいですか あの服のほうが可愛いです 簡単の質問 日本語が上手になる 私の苦手なことは料理を作ることです あそれはカーテンです 彼女を幸せにする 小林さんは中国語を話すことができます 一眼レフカメラ ゴミ箱 餌 広告 博物館 故郷 浅い 葉が落ちます かっこいい 茶髪 私は物理の基礎はしています あの服のほうが可愛ですか 博物館 2019-12-28建てる 電車 親の愛は有り難い 教える 駅の近くで食事をした 彼は数学を教えています そう 赤いバラを買いました 起こす 五月五日は祝日です 十日後に帰ります そこには私一人しかいなかった 八日からイギリスに行きます 辺 私たちはビデオゲームをした 触る 喋る 彼はこの辺に住んでいます 冷たい飲み物ください 細い ちゃんとドアを閉めてよ 二社は互い競争している もう やる ガソリンの価格がどんどん上がっている 今後どもよろしくお願いします 現在 情報 システムの構成を変えてみました 私は世界一周をしたくありません 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう 飛行機は二時間遅れました。なので、到着時間も遅くなります 私は納豆が全然好きではありません お客さんは家に来ました テレビをつけません 私は冬が嫌いです 水が熱くなる 暖かい手 上野さんは彼女と映画を見ました 旅行はいつですか 明日か明後日です 何も食べません 鳥 皿 カレーライス 来週 フライドチキン ㎝ 調味料 腹部は、肋とお尻の間の部分です フクロウが頭を上下に動かしている 私は物理の基礎は知っています かっこいい男 私は物理の基礎は知っています 2019-12-27置く 払う 帰国することに決めました かた そう 彼に手紙を書きました 授業 彼は荷物を網棚にあげた 今年 どうして泣いているの 私はパンよりご飯が好きだ 店員は若い女の人でした 辺 喉が乾きました 時の経つのは早い これは重要な書類です うちは五人家族です 重要 参加 なお、雨の場合は中止です 交差点で事故が発生した 全体の80%が完成しました 文章 交渉 ころ 彼は新製品に興味を示している 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう そう クラスを静かにする 向日葵は草より綺麗です 日本語が上手になる 辺 あれはジュースです 昨日、どこに行きましたか。昨日、コンサートに行きました ソファで寝ます 飲み物を買う 弟は父の性格がわかります 学校の先生は数学ができます 私は味噌汁が全然嫌いではありません 水が熱くなる なんでこんな時間に学校にいないのですか 石原さんは彼に防虫スプレーをもらいました あのバカは二本の鉛筆を箸にして、ご飯を食べる 苺 ハンバーガー 楓 冷蔵庫 布団 虎 蜘蛛 梅 ず 中村さんは昨日夜十時まで仕事しましたから、残業代がたくさんもらえるでしょう 2019-12-26明日、六時に起こしてください 安い 次はいつ会いましょうか 起きる 今朝は早く家を出ました 消す 彼はかなり英語が上手です 軽い 日 二十日 彼女は三人の子供の母親だ 違う お店はもう閉まっていました お母さんによろしくを伝えください 時 お腹が空きました ちゃんとドアを閉めてよ 宿題は自分でやりなさい 予約は要りません 曇る 上る 私はパンよりご飯が好きだ 後ろを向いて 絵に触らないでください 私は昼のドラマを毎日見ます 九日に荷物が届きます 政権 その仕事が危険を伴う 調べる ガソリンの価格がどんどん上がっている 加える 企業 まず相手の動きを見ましょう それはどういう意味ですか システムの構成を変えてみました 増える 今日の新聞どこに置いた 治る この服は三百ドルしました 彼は行政を改革したいと思っている 引っ越しを業者に頼んだ 私はパンよりご飯が好きだ 示す 一部 備える 信号が青に変わるました 川の岸に桜の木があります 小林さんの妻は小林さんに愛妻弁当をあげました 先生は私に100点をくれました 私の嫌いなことはバスケットをすることです ゴミ箱にペットボトルがあります それは正方形です 宮沢さんは課長のことをどう思いますか 狭い部屋 あの喫茶店は静かなので、あそこで勉強する人が多いでしょう あの屋敷に幽霊がいますよう 私はあの記憶を忘れたいです どうして今日遅刻した 私は納豆が全然好きではありません テストはいつですか 社員食堂 魔法瓶 生徒 校長 着物 フクロウが頭を上下に動かしている 2019-12-25また会いましょう 歌う 低い 楽しむ 兄は水泳が得意です 親の愛は有り難い 起こす 今週 お腹が空きました 火曜日 三つ 六日前に日本に帰っていました 彼は時々遅刻します 腰 昨日、あなたのお姉さんに会ったよ 酸っぱい 彼はシートベルト締めた 多分 辛い 生活 導入 彼女の大きな帽子はとても目立つ 首相 まず相手の動きを見ましょう ガソリンの価格がどんどん上がっている そのデモについて政府は何もしなかった 住宅 システムの構成を変えてみました 必要 株 より 方向 生産 それは最近話題の本ですね 私たちは二階に上がった その仕事は危険を伴う 社長は部長と出かけました 私はバスで学校に行きます 石原さんは彼に防虫スプレーをもらいました どうして大体のお店は試食を置きますか お腹が空きました 私は世界一周をしてくありません ニュースで道の状況がわかります 綺麗な公園 どうして台湾の会社は大学生を雇いたくないのですか 小林さんは中国語が話すことができます どうしてキリンは首が長いですか 飛行機が二時間遅れました。なので、到着時間も遅くなりました まず相手の動きを見ましょう ガソリンの価格がどんどん上がっている ピザを買いました、パスタも買いました ベッドの下にゴキブリがいます システムの構成を変えてみました 今夜は蒸し暑いので、蚊が多くなりました 解答 乗客 翻訳する フクロウが頭を上下に動かしている その仕事は危険を伴う ぶ ぬ 2019-12-24もっと近くに来てください 起こす 彼の腕は太い 聞く 軽い 一つ 乾く 夏 息子は六つになりました 予約入りません あそこ 四月に大学に入学しました お腹 上を向いて お名前をカタカナで書いてください 書き直す 何が飲み物が欲しいな 消える 構造 もう 現在 比べる 従来 結果 そのデモについて政府は何もしなかった 治る 開発 一般の方はこちらの席へどうぞ なお、雨の場合は中止です 国は国語教育を強化しています プログラム 部長除く全員が土曜日も働いた あの屋敷に幽霊がいますよう 小林さんは中国語を話すことができます 石原さんは彼に防虫スプレーをもらいました 向日葵は草より綺麗です 私の嫌いなことはバスケットをすることです 何曜日が暇ですか 上野さんは彼女と映画を見ました 飛行機が二時間遅れました。なので、到着時間も遅くなります 氷山が小さくなる 弟は父の性格がわかります 夜市が賑やかです 今夜は蒸し暑いですから、明日は雨が降るでしょう 私は世界一周をしたくありません 私は先生と職員室に行きました 彼は中国語と英語ができます スーツケースに詰める 小林さんは中国語を話すことができます 石原さんは彼に防虫スプレーをもらいました 飛行機が二時間遅れました。なので、到着時間も遅くなりました 私は世界一周をしたくありません 2019-12-23浴びる 郵便局で切手を買いました 親の愛は有り難い 少し疲れました 遠い 起こす 四月に大学に入学しました 夏休みももう終わりだ 彼は昼過ぎにきます 天気 火曜日 柿の木に実がたくさんなっています 五月五日は祝日です 起きる 起きる 来る 腰 そばにいて下さい 奇麗 時計を見たらちょうど三時だった 起こす 治る 一緒に対策を考えましょう 毎年多くの人が海外へ旅行する その問題に関する記事を読みました 販売 自由 今夜は大いに語りましょう それは最近話題の本ですね 彼は非常に高い技術を持っている 現在 重要 全体の80%が完成しました お相撲さんはみんな力持ちだ ほとんど もう なお、雨の場合は中止です 政権が交代した 力 どうして今日遅刻した 私はおばあちゃんのことが好きです 床に蟻がいます あの人は木を登ることができます 私は風邪をひきました。だから、学校に行きたくありません 治る 弟は父の性格がわかります 私はもっと頑張りたかったです 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 台北駅はどこですか 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 現在 今夜は蒸し暑いから、明日は雨が降るでしょう 私の友達は野球とサッカーができます 授業をしている教師 もう 私の得意なことはギターを弾くことです なお、雨の場合は中止です どこが賑やかですか 宮沢さんは課長のことを、どう思いますか 私は紙粘土でドラゴンを作ります 上野さんは彼女と映画を見ました ゴミ箱にペットボトルがあります 向日葵は草より綺麗です レシートください 私は苦手なことは料理を作ることです 弟は父の性格がわかります 和食と言えば寿司や味噌汁や天ぷらなどです 上野さんは彼女と映画を見ました 向日葵は草より綺麗です 期末テスト オフィス 質問する 女性がモモの太さが計っている づ 2019-12-22大学に行って、もっと勉強したいです 重い 親の愛は有り難い 知る 負ける 肩 使う 火曜日 大人 彼女は眠いようです ちゃんとドアを閉めてよ 八日後に帰ります 口 時の経つのは早い まあ今回は許してあげよう 電話 体重がかなり減りました 増える 特徴 私は四つの会社に投資しています 全体の80パーセントが完成しました 住宅 関する 彼が来た目的がわかりません 改革 そのデモについて政府は何もしなかった この段階では決断するのはまだ早い それは最近話題の本ですね ガソリンの価格がどんどん上がっている 宮沢さんは課長のことを、どう思いますか 中村さんは昨日夜十時まで仕事をしましたから、今日は来ませんよね 親の愛は有り難い 飛行機が二時間遅れました。だから、それで起こっている人が多いでしょう 火曜日 ご飯を食べましょう 授業をしている教師 私は討論を始めたいです 新しいソフトを買いました。なので、バイト代が全部なくなりました 私は納豆が全然好きではありません 何も買いません どうして今日は遅刻した ゴミ箱にペットボトルがあります 全体の80%が完成しました 庭の松が高くありません お客さんは家に来ました 私は先生と職員室に行きました てん 体育館 浅い これはなんですか ロッキングチェア 動詞 布 だれ 宮沢さんは課長のことを、どう思いますか ゴミ箱にペットボトルがあります 2019-12-21どう 兄は水泳が得意です 一緒に帰りましょう 今朝は早く家を出ました 持つ 私の夫はサラリーマンです 親 言う 男の人は私たちに話しかけた 多分 美味しい 違う 近所で盗難事件が起こりました め これは医者のためのサイトです 弟 強い 愛する 掛ける 昨日、あなたのお姉さんに会ったよう これはかなり金がかかった 時 可能 それは最近話題の本ですね 目的 実現 そのデモについて政府は何もしなかった 建設 事実 増える ガソリンの価格がどんどん上がっている 語る ドル どうして今日遅刻した 引き出しにハムスターが一匹います 私は納豆が全然好きではありません 大学の先輩は商売ができます ペットを飼いましょう 私は日本語はできます なぜ大体のお店は試食を置きますか 彼女はボーリングができます 私は先生と職員室に行きました 私は親友と遊びたいです 授業をする教師 浅い川 ゴキビリ ポスター それは最近話題の本ですね 水曜日 涼しい 田舎 そのデモについて政府は何もしなかった 卵 増える ガソリンの価格がどんどん上がっている どうして今日遅刻した 私は納豆が全然好きではありません 予備校生 雄鶏 帰る 走る 切る サイ 私は先生と職員室に行きました 増える 2019-12-20帰る この言葉の意味がわかりません 待つ 乗る どこ 日曜日は海に行きました こっち 妹 夏 九日に荷物が届きます 六日前に日本に帰ってきました 教科書を閉じてください お腹 朝九時からミーテイングが始まった 休む 道 千円貸してください 昨日、あなたのお姉さんにあったよ 会社 毎年多くの人が海外へ旅行する 決定 十分 帰ったら、まず手を洗いましょう 音楽は彼の得意な分野です これから、より一緒努力します 処理 報告 今日の新聞、どこに置いた ほぼ 特徴 テレビをつける 教室に学生と先生がいます 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう 私はあなたにデジタルカメラをもらいました なぜ大体のお店は試食を置きますか ご飯を食べる人 なんで台湾の会社は大学生を雇いたく無いのですか 夜市はスーパーよりうるさいです 私は先生と職員室に行きました 私は苦手なことはバスケットをすることです 昨日、どこかに行きましたか いいえ、どこも行きませんでした 昨日、あなたのお姉さんに会ったよ ペットを飼いましょう 自転車とバイクと車、どれが便利ですか 教室は静かではありません 夜市はどこですか 私は日本語が大体できます 陽傘 餌 栓抜き 調味料 ㎝ ロブスターが岩の上にいる なぜ大体のお店は試食を置きますか 私は先生と職員室に行きました 2019-12-19飛行機 カナダの冬はとても寒いです おかげさまで元気です わかる その次の週は空いていますか 息子 ちゃんとドアを閉めてよ 何 この紙を半分に切ってください 大丈夫ですか お腹 時 今日は妻の誕生日だ 五月五日は祝日です 無い 毎年多くの人が海外へ旅行する 今後 方法 研究 私はよく図書館を利用します のち 商品 強調 私は日本語がまあまあできます 私は部長のことが嫌いです なぜ台湾の会社は大学生を雇いたく無いのですか レシートをくださ お客さんは家に来ました 飛行機は二時間遅れました。だから、それで怒って人が多いでしょう 私は中国語と英語がわかります あの喫茶店は静かですから、あそこでテストを勉強しましょう 私の嫌いなことはバスケットすることです 今日、何か買いますか いいえ、何も買いません 私はノートパスコンをテレビにする 私の苦手なことは料理を作ることです 緑茶 圖 おばあさん 夕食 描く 嫌い ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろう 毎年多くの人が海外へ旅行する 栓抜きありますか 虹 カニが浜辺を歩いている 私の嫌いなことはバスケットをすることです 2019-12-18色 のち 彼女の髪はとても長い 負ける 笑う 私たちのチームはその試合で負けた 質問 兄は水泳が得意です 乗る 小さい花が咲いています ちゃんとドアを閉めてよ 違う お母さんによろしくを伝えください 時 動く 五日 閉まる お腹 お手洗い 多分 ただ 解決 管理 彼は就職試験を受けた 必要 計画 ほぼ 島の人口は年々増加しています 今日はこれらの問題について話し合います 中心 政権が交代した これはイタリアから輸入した服です 関係 私は風邪をひきました。なので、映画館に行きませんでした 私の趣味は映画を見ることです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 正方形はどれですか ちゃんとドアを閉めてよ あなたのカバンはこれです 私はアメリカに行きました 何で学校に行くのですか 時 えっと、電車が遅れたので、遅刻しました どうして麒麟は首が長いですか 浅い川 私の趣味は料理を作ることです どこも行きません お客さんは家に来ました お腹 年齢 デジタルカメラ 腹部 こ う お客さんは家行きました 2019-12-17兄は水泳が得意です 日記 会議は四時に終わります 去年 皆 言葉 今朝は早く家を出ました 彼女 肩 六日前に日本に帰ってきました 金 五月五日は祝日です 上 十日後に帰ります このコートはとても暖かい 直る 多分 喋る お父さん 側 土地 計算 昨日の会議について報告があります 二者は互いに競争している 兄は水泳が得意です 可能 会議で重要な決定がありました 経営 開始 今回 これは重要な書類です 採用 検討 事実 より 対する 命令 計画を一部変更しましょう 問題 工場 目的 続ける 選挙 業者 問題が一つあります 私は世界一周をしたくありませんでした 夜市はどこですか 私は苦手なことは料理を作ることです あなたのカバンはこれです 私は果然をひきました。だから、明日学校に行きたくありません 私は冬が嫌いです お元気な子供 私は日本語ができます バカ！言い訳するな ペットを飼いましょうよ 和食 広告 楓 てん 机 調味料 多分 栓抜きありますか 2019-12-16直ぐ 彼は足が長い 消す 家に帰ろ いつ 鳥が飛んでいます いつも 彼の気持ちが分からない 私たちは大きな声で歌いました 引く 出来る 毎日駅まで自転車で行きます 入れす 今朝は早く家をてました 親の愛は有り難い 書く 起きる 勝つ 重い 六日前に日本に帰ってきました 辛い 細い 曜日 掛ける 今日はいい天気ですね 来月の一日は空いていますか 違う よう どうして 九日 彼は時々遅刻します くらわ 六日前に日本に帰ってきました 鼻 その子は指で十数えました 風邪 この道をまっすぐ行くと駅です 五月五日は祝日です 嫌い 閉まる クーラーはまだ治りません お店はもう閉まっていました 彼女は眠いようです 目 手紙が届くのに三日かかりました 柿の木に身がたくさんなっています 夏休みももう終わりだ 8 どうして泣いているの 曜日を間違えました 開ける 米 予約入りません 泊まる 五月五日は祝日です これは医者のためのサイトです 合格者が発表された 犬に餌をやった 生活 一緒に対策を考えましょう 彼は行政を改革したいと思っている そのデモについて政府は何もしなかった ほとんど 国会 お金がほとんどありません 電話 交差点で事故が発生した 評価 事務的な処理に1週間かかります 彼は事故で怪我をしました 対する やる それはどういう意味ですか 来年から新しい制度が始まります 電気がついたままですよ いずれ 方針 会談 予定 写真はいい思い出になります 作業 構造 昨日 伴う 集める お金はまだ十分あります 社会 よく答えがわかりましたね 事実 今日はこれらの問題について話し合います 変化 今日の新聞どこに置いた 状態 目的 彼は選挙に出るつもりだ 事実 中心 今日中にこの問題を検討してください 彼は食品工場で働いています 島の人口は年々増加しています ロボット 明らか 影響 私は自分の力で仕事を探します 大学の先輩は商売ができます 先生はテストの答えがわかります おおき 大学の先生は数学ができます 目的 部屋を綺麗にする 私の趣味は本を読むことです バカ！言い訳するな 飲み物を買いませんでした ご飯を食べている人 なぜ台湾の会社は大学生を雇いたく何のですか 授業をする教師 目的 私の趣味は野球をすることです 佐々木さんはサラリーマンです 私は懐石料理が一番好きです 明日の食券をください ゲームをしません 本棚に小説と雑誌があります 教師の隣に父と母がいます 彼は会長でした 綺麗な公園 コンビニに電子レンジがあります 新しいゲームソフトを買いました。なので、バイト代が全部ななくなりました 私は日本語ができます 昨日、何処かに行きますか はい、コンサートに行きました えっと電車が遅れましたから遅刻しました どうして台湾の会社か大学生を雇いなくないのですか どれが綺麗ですか 彼は会長ではありませんでした テストはいつですか 明日と明後日と来週ですね 私の苦手なことは料理を作ることです あの屋敷に幽霊がいますよう ご飯を食べる人 父は台湾料理を作ることができます あの喫茶店は静かなので、あそこに勉強する人が多いでしょう 机の上に雑誌があります なんで台湾の会社は大学生を雇いたくないのですか ペットをかいましょうよ 彼は小学校の先生ですから、子供の親のプレッシャーが多いでしょう 冷蔵庫 水曜日 大きな竜巻 香水 親戚 社員食堂 私の苦手なことは料理を作ることです 17 隣人 動詞 下手 ビジネスマン 液晶テレビ 学長 キャベツ 屋上 レタス 買い物カートはからです 鳴いている雄鶏 ペットを飼いましょうよう 蝉 葉が落ちます 顎髭 サイ 男性は、顎髭がたくさん生えているが、頭の毛が少ないです スーツケース フクロウ 2019-12-13テストで良い点を取った 次はいつ会いましょうか 春 見える 彼は時々遅刻します 違う 来月の一日は空いていますか 十日後に帰ります これは医者のためのサイトです 酸っぱい 土曜日の夜はクラブに行きます 私が手伝いましょう 窓を開けてください 髪 ほぼ 相手 塩、胡椒加えてください 比べる 従来 株 試合の相手は誰ですか 宇宙人は存在すると思いますか 彼は非常に高い技術を持っている 生産 そのデモについて、政府は何もしなかった 存在 私はあの人のことが嫌いです 私は部長のことが嫌いです 私は懐石料理が非常に好きです うそ 弟は父の性格がわかります なんでこんな時間に学校にいないのですか 昨日、どこに行きましまたか コンサートに行きました どこが賑やかですか 庭に松があります 違う 鈴木さんは大学生です。私も大学生です なぜ台湾の会社は大学生を雇いたくないのですか ニュースで道の状況がわかります 楽しい一日 動物園にライオンがいます 私は弟と妹実家に帰りました 布 ストップウオッチ 金曜日 オレンジ 御犬 化粧品 梅 水曜日 調味料 雨の後、虹が見られるかもしれません 教授が図を説明する 2019-12-12兄 緑 私 旅行の日程を変えました 顔 宿題はまだ終わっていません 軽い テーブル 治る 明日昼頃から曇るでしょう これは医者のためのサイトです 近く 十日後に帰ります 手紙が届くのに三日かかりました 彼には子供が六人います 大丈夫ですか お名前をカタカナで書いてください 閉める 来年一緒に旅行しましょう 近所で盗難事件が起きました 答える 黄色い 休む 工場 会長 島の人口は年々増加しています 目立つ 分野 写真 方向 文章 のち 消える 電気がついたままですよ 新聞 そのについて政府は何もしなかった ほぼ 二社は互い競争している 代表 これは医者のためのサイトです 家から学校まで 運動場で走ります 十日後に帰ります 母はペットと海外旅行をしました 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 日本語を上手にする 授業をする教師 私は彼に使い捨ての箸をあげました そのデモについて政府は何もしなかった どうして台湾の会社は大学生を雇いたくないのですか 簡単な質問 電車は自転車より速いです 今夜は蒸し暑いですから、明日は雨が降るでしょう 大学の先輩は商売ができます 彼女はあの野良犬をペットにする 机の上に2本のペンがあります 飛行機が二時間遅れました。だたら、それで怒っている人が多いでしょう 犬は大きくありません 原稿改訂する 数字の17 昨日 鶏 水曜日 苺 雑誌 餌 乗客 中学生 クロサイが草原を歩いている ロブスターが岩の上にいる 水曜日 2019-12-11重い 車 帰る 肉と魚とどちらが好きですか する 約束を忘れないでください 立つ 肩 国 読む 覚える 彼女は眠いようです 八日からイギリスに行きます お母さんによろしくを伝えください どうして泣いているの 今日は頭が痛いです 目 教科書を閉じてください 時計を見たら、ちょうど三時だった ただ 評価 建設 今日の新聞どこに置いた 対策 選挙 前売券ハマド口で販売しています 構造 種類 これは世界最大の船です 企業 トラブルがやっど解決した 強化 部長除く全員が土曜日も働いた 問題が一つあります お相撲さんはみんな力もつだ 彼は小学校の先生ですから、子供の親のプレッシャーが多いでしょう あの屋敷に幽霊がいますよ あの喫茶店は静かなので、そこで勉強する人が多いでしょう 私はアメリカに行きました 大学の先輩が商売ができます 庭に松があります 授業をする教師 年齢 私はもっと頑張りたいです 自転車は電車ほぼ早くありません 新しいゲームソフトを買いました。なので、バイト代が全部をなくなりました なぜ大体のお店は試食を置きますか 大学の先輩は商売ができます 授業をする教師 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 引き出しにハムスターが一匹います いつが暇ですか 私はあなたにデジタルカメラをもらいました 使い捨て 記憶 楓 社員食堂 おやつ 数字の17 動詞 夜市 どれ 2019-12-10また会いましょう どつら 私もそう思います 重い 親の愛は有り難い 彼は毎晩3キロ走っています 彼は昼過ぎに来ます め 夏休みももう終わりだ 大人 腰 彼は私の方を見ました 彼女に黄色いバラを買いました この部屋は寒いです 掛ける 財布は机の下にあった 二社は互いに競争している 商品 今日の新聞どこに置いた 選ぶ 種類 特徴 報告 命令 もつ 提供 ほとんど 党 私は懐石料理がとても好きです なんで台湾の会社は学生を雇いたくないのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 病人が元気になる 彼は学校の先生ですから、子供の親のプレッシャーが多いでしょう 寝ぬ猫 夜市が賑やかです 重い なんで今日私の家に来ましたか 私のカバンはどれですか め 私は茶碗蒸しがあまり嫌いではありません 自転車とバークと車、どれが便利ですか 私は紙粘土でドラゴンを作りました 一眼レフカメラ 課長 親戚 高層ビル 雄鶏 ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろ 今日の新聞どこに置いた 彼は学校の先生ですから、子供の親のプレッシャーが多いでしょう 2019-12-9病気 親の愛は有難い おかげさまで元気です 質問のある方はどうぞ 彼はシートベルト締めた 五日 晴れる 夕食には何を食べたいですか 触る 今の首相はあまり力がない 行う ここが建物の中心です 島の人口は年々増加しています 段階 強調 のち 宇宙人は存在すると思いますか 私は四つの会社に投資しています これは重要な書類です 信号が青に変わりました 二者は互いに競争しています 隣の人は私の猫に餌をくれました まず、次に、そして、それから、最後に ハンバーガーとコーラ 宮沢さんは課長のことを、どう思いますか どうして台湾の会社は大学生を雇いたくないのですか 親の愛は有り難い あの喫茶店は静かなので、そこで勉強することが多いでしょう 掛ける 新しいゲームソフトを買いました。だから、古いソフトを売りました 引き出しにハムスターが一匹います 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう あの屋敷に幽霊がいますよう ドアを開けませんでした 私は彼女のことが好きです 期末レポート 動詞 空港 バイク 説明する アリクイ 茶髪 サイ 二社は互いに競争してういます どうして台湾の会社は大学生を雇いたくないのですか 2019-12-8授業 電車で子供が騒いでいた 生きる しる 戻る その次の週は空いていますか 止める 暑い 上る 後ろを向いて 細い 場合 どうして泣いているの 冷たい飲み物をください 近所で盗難事件が起きました つける 方向 輸入 内容 やる 立場 一緒に対策を考えましょう 強調 その計算は間違っている 原因 最近、彼の評価が上がった 最大 島の人口は年々増加しています まま 会談お内容が発表されました 私はゲームが好きです 私はもっと頑張りたかったです 彼女を幸せにする 飛行機が二時間遅れました。なので、到着時間も遅くなります なんで今日私の家に来ましたか 台北駅はあそこです あの喫茶店は静かなので、あそこで勉強する人が多いでしょう ドアを開けません そっか、今度早くいえをでろ 何で学校に行くのですか 私の好きなことは音楽です あの屋敷に幽霊いますよう 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう えっと、電車が遅れましたから遅刻しました コンビニに電子レンジがあります 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう 島の人口は年々増加しています 冷蔵庫 楓 パスタ 動詞 社員食堂 フットボール 18年前 ロブスターが岩の上にいる 調味料 あの喫茶店は静かなので、あそこで勉強する人が多いでしょう あの屋敷に幽霊がいますよ 飛行機が二時間遅れました。だから、それで起こっている人がおおいでしょう 動詞 2019-12-7彼はタオルで顔を拭きました 冬 新しい 郵便局で切手を買いました 思う 息子 探す 彼女は眠いようです お母さんによろしくを伝えください 酸っぱい どうして泣いているの 予約は要りません 夏休みももう終わりだ 一杯 晩 辛い 計画を一部変更しましょう 設計 必要 ほぼ 姿 病院 それはどういう意味ですか 処理 構造 変わる 電気がついたままですよう ほとんど 国は国語教育を強化しています 強調 実現 彼は中国語と英語ができます テーブルと椅子 弟は父の性格がわかります 今夜は蒸し暑いので、蚊が多くなりました テレビをつけませんでした 彼女はボウリングができます 私は味噌汁が全然嫌いではありません 暇は何曜日ですか あなたにデジタルカメラをもらいました 国仲さんはあなたにギターをもらいましたよ 私は懐石料理がとても好きです ゲームをしましょう どうして泣いているの 兎 部屋 社員食堂 ドア 隣人 皿 ロブスターが岩の上にいる ざ 社員食堂 ロブスターが岩の上にいる 2019-12-6弱い 鳥が飛んでいます うちに遊びに来てください 出る 変える 早く 取る この服はとても安かった かた 見つける 膝に痛みを感じます 漢字は中国から来ました 息子は六つになりました お母さんによろしくを伝えください 私は腕時計を4つ持っています 千円貸してください 近所で盗難事件が起きました 休む 夏休みももう終わりた 彼女は眠いようです 強い 彼がクラスの代表だ 彼は新製品に興味を示している 株 私にはたくさんのお金が必要だ お母さんによろしくを伝えください 昨年 お相撲さんはみんな力持ちだ 運動会は9時開始です 示す 構成 部分 自由 普及 交差点で事故が発生した 交渉 おリーグをください 私のノートはどれですか 夏休みももう終わりだ 佐々木さんはサラリーマンです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 彼女は眠いようです 自転車とバイクと車、どれが便利ですか ニュースで道の状況がわかります 明日の食券をください 私の趣味は料理を作ることです 刺身をください 今夜は蒸し暑いですから、明日は雨が降るでしょう おばあちゃんのことが好きです どうして台湾の会社は大学生を雇いたくないのですか なんぜこんな時間に学校にいないのですか 何も買いません 和食と言えば、寿司屋味噌汁や天婦羅などです 私の妹に飴をくれましたね、ありがとう バカ！ 言い訳するな 広告 楓 竹 賑やか 文房具 暖かい 海 サイ 2019-12-5頭 あげる 午前 昨日タイカレーを食べました そこに座ってください 彼は時々遅刻します 近所で盗難事件を起こりました 小さい花が咲いています どうして わからない場合は私に聞いてください 宿題は自分でやりなさい こっち 冷たい システムの構成を変えてみました 彼は就職試験を受けた ほとんど これら 中心 いずれ 変化 発生 対立 以上 対象 やる 彼女の大きな帽子はとても目立つ 全国 住宅 まず 私は懐石料理がかなり好きです 何を食べますか 定食やうどんやラーメンなどですね 私は風邪をひきました。なので、映画館に行きませんでした コンビニに電子レンジがあります 近所で盗難事件が起こりました えっと、電車が遅れましたので、遅刻しました 先生は討論を始めたがります 何で学校に行くのですか 私の好きなことは音楽を聴くことです 今日、何か買いますか いいえ、何も買いません 自転車とバイクと車、どれが便利ですか 中村さんは昨日夜十時まで仕事しましたので、残業代が沢山もらえるでしょう 新しいゲームソフトをあげました。だから、古いソフトを売りました 辞書 楓 便利 えさ かっこいい男 サイ 調味料 ほ 自転車とバイクと車、どれが便利ですか 楓 サイ 2019-12-4遊ぶ 次はいつ会いましょうか 彼はまだ若いです 肩が凝りました 学校は八時半に始まります 一つ 広い 少ない あなたのお兄さんは何歳 細い 悪い これはかなり金がかかった 閉める 喉が乾きました 五日 答えが違います 違う 教科書を閉じてください 服 彼に会えて嬉しかった お名前をカタカナで書いてください 百 外国 代表 報告 重要 お相撲さんはみんな力を持つだ 彼は非常に高い技術を持っている 競争 この この曲線がこの車の特徴です やる 比べる 計算 話 一緒に対策を考えましょう 留学してから、私の世界が広がった 帰ったら、まず手を洗いましょう 姿 消える 従来 国会 彼は就職試験を受けた 生産 構造 政権が交代した 今夜は大いに語りましょう 今後の方針が決まった 発生 ほとんど 商品 地域 完成 彼は選挙に出るつもりだ 増える 会談 そっか、今度早く家を出ろ どこが賑やかですか 私はあなたにデジタルカメラをもらいましょた やる 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 上手なコック コンビニに電子レンジがあります 先生は難しい本を読むことができます 私の嫌いなことは部屋を掃除することです あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 何で学校に行くのですか 私はあの人のことが嫌いです 氷山が小さくなる あなたは教師です なんでこんな時間に学校にいないのですか 陽傘 苺 烏龍茶 調味料 ほとんど 葉が落ちます フクロウ ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろう 蟹が浜辺を歩いている コンビニに電子レンジがあります 調味料 2019-12-3軽い 言葉 彼は足が長い 時計を見たらちょうど三時だった 口 ある 細い 汚い 彼女は3人の子供の母親だ 酸っぱい お願い ほぼ ここは一方通行です 関する お相撲さんはみんな力持ちだ 今、値段を交渉しています 計画 細い お相撲さんはみんな力持ちだ 一緒に対策を考えましょう 彼は選挙にですつもりだ 構造 その問題に関する記事を読みました 状態 仕事がほぼ終わりました 自由 建設 政権 彼は行政を改革したいと思っている このプリンターは従来のものより速い これは重要な書類です 株 なんでこんな時間に学校にいないのですか 犬と猫、どちらが好きですか 私は親友と遊びたいです どこも行きません 動物園のパンダは小さいです どれも要りません 彼は中国語と英語ができます 飛行機が二時間遅れました。なので、到着時間も遅くなります 一緒に対策を考えましょう 構造 川の岸に桜の木があります 私はあなたにデジタルカメラをもらいました 何で学校に行くのですか 宮沢さんは課長のことを、どう思いますか 私は学業を続けたいです ご飯を食べた人 私は日本語が大体できます 私の好きなことは音楽を聴くことです あなたの会社は私の会社に統計ソフトウエアをくれました 私のカバンはどれですか おやつ 原稿改訂する 冷蔵庫 親戚 栓抜き フルート め 私はあなたにデジタルカメラをもらいました 何で学校に行くのですか 私はあなたにデジタルカメラをもらいました 2019-12-2消す かた どれ 飛行機 私たちのチームはその試合で負けた 次 休む 五つ お願い 辛い 見つかる 違い 暖かい 時の経つのは早い 愛する 採用 決定 与える 電気がついたままですよう 株 まあ今回は許してあげよう なお 利用 会談 制度 部長を除く全員が土曜日の働いた 構成 受ける 事件 生まれす 文章 対する 行う 特徴 今夜は大いに語りましょう なんでこんな時間に学校にいないのですか 明日の食券がください 今日、何か買いますか はい、オレンジを買います 株 机の上に雑誌があります 今夜は蒸し暑いですから、明日は雨が降るでしょう 私の趣味は本を読むことです 期末レポートは中間レポートほど大変ではありません 台北駅はどこですか テレビをつけません 図書館はスーパーより静かです 大きくなかった 弟は父の性格がわかります 昨日、何処かに行きましたか はい、コンサートに行きました 私は彼女のことが好きです 木曜日 プール 隣人 梅 タンス なんでこんな時間に学校にいないのですか 2019-12-1理事長 餌 果物 兎 冷蔵庫 呼ぶ 直ぐ また会いましょう 彼に手紙を書きました いつも 肉と魚とどちらが好きですか たっかたです 何も食べますか 定食やうどんやラーメンなどですね 深い湖 あの子供は親友と遊びたがります 私はもっと頑張りたかったです これをください 明日の食券をください かた 部長は仕事ができます 私は刺身があまり好きではありません 宮沢さんは課長のことを、どう思いますか 今日は何曜日ですか 今夜は蒸し暑いから、明日は雨が降るでしょう どうして今日遅刻しましたか ばか！言い訳するな 私は風邪をひきました。だから、明日は学校にいきたくありません あの歌手は有名です 熱い 彼は神を信じている 来る 五日 酸っぱい 口 私は夏が大好き 休む 企業 開く どる それはどういう意味ですか 増える 処理 解決 価格 コーヒーをもう一杯ください 先ず 我が社の経営はうまくいっています 彼女は同じ間違いを繰り返した 加える 商品 ツアーガイドはあなたの旅行を楽しくする興味深い情報知っているだろう 虹 今夜は蒸し暑いですから、明日は雨が降るでしょう 明日の食券をください どうして麒麟の首は長いですか","link":"/zh-tw/japanese/2019/December/index.html"},{"title":"October 2019","text":"2019-10-31肩 赤いバラを買いました 郵便局で切手を買いました 彼の日本語のレベルは私と同じくらいだ あげる 工事は3月まで続きます 今日 別 千円貸してください 上を向いて 十日後に帰ります 私が手伝いましょう そば 登る 一杯 後ろを向いて 九日 お願い どうして 触る 交差点で事故が発生した この本の内容を説明してください 引っ越しを業者に頼んだ 残る それは最近話題の本ですね 夜市はどこですか 私たちは今結婚資金を貯めています 採用 夜市はどこですか 中心 ただ 計画 続ける 千円貸してください 全国 これは重要な書類です より 文章 どこが賑やかですか 何曜日が暇ですか 台北駅はあそこです 私は書いた原稿を本にする 私の趣味は野球をすることです 後ろを向いて 私は彼女のことが好きです 私の苦手がことは料理を作ることです 昨日、どこにいきましたか。 昨日、コンサトートに行きました 私の趣味は料理を作ることです 私のカバンはどれですか ゴミ箱にペットボトルがあります 石原さんは彼に防虫スプレーをもらいました 上手なコック 自転車は電車ほど早くありません 採用 夜市はどこですか うそ 昨日、何処かに行きましたか。 はい、コンサートに行きました 夜市はどこですか 台北駅はどこですか 私は父と食事をしました 私の趣味は映画を見ることです どこが賑やかです まずい料理 夜市が賑やかです 今日は何曜日ですか 日曜日が暇ですい どこが賑やかですか 私の嫌いのことはバスゲットをすることです 私の苦手なことは料理を作ることです あなたのカバンはこれです どれが綺麗ですか テストはいつですか 明日や、明後日さ、らいしゅうなどですね 昨日、どこに行きましたか。 昨日、コンサートに行きました ゴミ箱にペットボトルがあります 昨日、どこに行きましたか。 昨日、コンサートに行きました 私は日本語が少しできます 私は日本語がよくできます 私は日本料理を作ることが大体できます どこが賑やかですか あれはカーテンです ドアをあげる 昨日、何処かに行きましたか。 はい、コンサートに行きました 私は日本語が大体できます 鼠 魔法瓶 キャベツ どこが賑やかですか テストはいつですか 明日や、明後日や、来週などですね 昨日、どこに行きましたか 昨日、コンサートに行きました ノートパスコン 中学生 故郷 博物館 フルート フットボール 18年前 タンス 質問する 私は物理の基礎は知っています せみ 昨日、何処かに行きましたか はい、コンサートに行きました 中学生 何処かに行きましたか はい、コンサートに行きました 2019-10-30生きる 旅行の日程変えました あげる 私の部屋は二階にあります 始める 昨日タイカレーを食べました 郵便局で切手を買いました 彼は昼過ぎにきます 何曜日が暇ですか 上を向いて お願い 手紙が届くのに三日かかりました 百 し 開ける こっち 何曜日が暇ですか お手洗い 動き 計算 帰ったら、まず手を洗いましょう 社会 その問題に関する記事を読みました 写真はいい思い出になります あなたのカバンはこれです 続ける 方針 一般の方はこちらの席へどうぞ 中心 姿 首相 検討 台北駅はあそこです 郵便局で切手を買いました 彼は非常に高い技術を持っている 上を向いて 内容 全国 お願い 文章 あなたのカバンはこれです 事故 昨年 計画 目立つ 先生は私に百点をくれました 何曜日が暇ですか 私のカバンはどれですか 何曜日が暇ですか 私は日本語がよくできます どこが賑やかですか 私は日本料理を作ることがまあまあできます うそ 今日は何曜日ですか どれが綺麗ですか ゲームをする 台北駅はあそこです 続ける 私はノートパソコンをテレビにする 私は自分の力で仕事を探します あなたのカバンはこれです 中心 授業をした教師 台北駅はどこですか 夜市が賑やかです 台北駅はあそこです 全国 文章 私の趣味は本を読むことです 私はサラリーマンです、けれもサラリーマンです あなたのカバンはこれです 計画 日曜日が暇です 月曜日 水曜日 火曜日 木曜日 金曜日 土曜日 日曜日 あなたの会社は私の会社に統計ソフトウエアをくれました うそ 絵を描く ご飯を食べる人 私の嫌いなことは部屋を掃除することです 私はあの人のことが嫌いです わたしはおばあちゃんのことが好きです 台北駅はあそこです お釣りをください 田舎 ガスコンロ 土曜日 クロサイが草原を歩いている 夜市は賑やかです 日曜日が暇です に の 日曜日が暇です 夜市が賑やかです 日曜日が暇です 2019-10-29親の愛は有難い 彼の家に荷物を送りました 肩 緑 うちに帰ろ 売る 持つ 私のカバンはどれですか これはかなり金がかかった １つ ２つ ３つ ４つ ５つ ６つ 7つ ８つ ９つ 10つ そこには私一人しかいなかった 口 時計を見たらちょうど3時だった 予約入りません 台北駅はどこですか 細い 私のカバンはどれですか 渇く 柿の木に実が沢山なっています 私が手伝いましょう 教科書を閉じてください かれる ソフト 比べる 台北駅はどこですか 採用 目立つ 実現 この単語の意味を辞書で調べましょう 選ぶ 中心 彼がクラスの代表だ 今日は何曜日ですか 私のカバンはどれですか 加える 計算 今日は何曜日ですか この段階では決断するのはまだ早い全体 帰ったらまず手を洗いましょう どれが綺麗ですか 政権が交代した 台北駅はどとですか 私のカバンはどれですか 作業 銀行は3時まで開いています これは世界最大の船です 目立つ 台北駅はどこですか 影響 どこが賑やかですか 中心 写真はいい思い出になります 彼は就職試験を受けた 姿 計算 今日は何曜日ですか 一部 これは重要な書類です 計画 どれが綺麗ですか 今日は何曜日ですか 変わる 検討 宮沢さんは課長のことを、どう思いますか 帰ったら、まず手を洗いましょう どれが綺麗ですか 私はあの人のことが嫌いです 私は日本語が全然できません 私の嫌いなことは部屋を掃除することです どこが賑やかですか 私は得意なことはギターを弾くことです あれはカーテンです 私は日本語料理を作ることが大体できます 授業をする教師 あの屋敷に幽霊がいますよ 写真はいい思い出になります 私は魚が嫌いです ペットを飼いましょうか どこが賑やかですか ご飯を食べた人 私は日本料理が好きです 日本語を上手にする お釣りをください あの人は木を登ることができます ソファで寝る 姿 十七 翻訳する 原稿を改訂する 計画 どれが綺麗ですか 計算 カレーライス 期末レポート 陽傘 かっこいい 走る 切る 帰る どこが賑やかですか お釣りをください お釣りをください 2019-10-28大学に行って、もっと勉強したいです 彼の家に荷物を送りました 安い 約束を忘れないてください 遠い 仕事の後、映画を見た 午前 近く 難しい こう 生きる 質問のある方はどうぞ 彼の車は新しい 少し疲れました 彼は真面目な学生です 彼は走るのが早い 私が手伝いましょう 腰 私は腕時計を４つ持っています 女 大人 教科書を閉じてください プル くる 服 東京は日本一大きな都市です 採用 信号が青に変わりました 管理 この事故の原因は何ですか この曲線がこの車の特徴です テレビ 構造 国内 状態 与える 彼は就職試験を受けた 立場 輸入 解決 国会 可能 加える 種類 私が手伝いましょう 交差点で事故が発生した 計画 実現 あの屋敷に幽霊がいましすよう 私は日本語があまりできません 私は懐石料理が一番好きです 教科書を閉じてください 私は寿司が好きです 宮沢さんは課長のことを、どう思いましか 採用 犬は大きくありません ご飯を食べる人 上手なコック 私の趣味は本を読むことです 私は日本語が少しできます 私は懐石料理がすごく好きです ご飯を食べている人 私は討論を始めたいです 彼は就職試験を受けた 自転車とバイク、どちらが便利ですか 私の好きなことはお音楽を聴くことです あなたは私にあのDVDをくれましか 計画 実現 採用 教科書を閉じてください コーヒーショップで教科書を読みます 本棚に小説と雑誌があります 私の好きなことは音楽です 私は彼女のことが好きです 私はおばあちゃんのことが好きです 私は部長のことが嫌いです 佐々木さんはサラリーマンでした 嫌いな店員 私は日本語が大体できます ボタンを押す 大きくない あれはカーテンです みんなは運動会の予定がわかります 私は日本料理を作ることが全然できません 私は苦手なことは料理を作ることです 私はあなたに誕生日プレゼントをもらいましたようね プール 中学生 牛 レタス 火曜日 コンビニ 高層ビル 海外旅行 茶髪 蝉 かっこいい 栓抜き 教科書を閉じてください あれはカーテンです かっこいい 2019-10-27１つ 直ぐ 買う 軽い 私には友達が沢山います 座る いつも 生きる 足 お母さんによろしくを伝えください 木曜日は仕事が休みです クーラーはまだ直りません 店員は若い女の人でした 金曜日の夜は友達と出かけます 休む お酒は大人になってから 教科書を閉じてください 左 要る 彼女は眠いようです 解決 上がる 弟は切手を集めています 兄は船を設計をしています 方向 残る 彼は食品工場で働いています 生きる あまり 後 トラブルがやっと解決した 彼は就職試験を受けた 交差点で事故が発生した テストはいつですか 明日や、明後日や、来週などですね 図書館はスーパーより静かです 図書館に本とコンピューターがあります 大人 私は好きなことは音楽を聴くことです 解決 私は日本語が大体できます 私は彼女のことが好きです 私は冬が嫌いです ご飯を食べましょう 私は日本料理が好きです 彼は就職試験を受けた 私は茶碗蒸しが嫌いではありません 交差点で事故が発生した 私の苦手なことは料理を作ることです 簡単な質問 私は懐石料理を非常に好きです 夏は涼しいです 小林さんは中国語を話すことができます 私は日本料理を作ることが少しできます 私の趣味は野球をすることです 私は自分の力で仕事を探します 川の岸に桜の木があります 私はピーマンが嫌いです 私は部長のことが嫌いです 日本は台湾より寒いです 私の嫌いなことはバスケットをすることです 教科書を閉じてください 私は日本語が大体できます インターネットで新幹線の時刻表が分かります 私は日本料理を作ることがあまりできません 定食 水族館 液晶テレビ 文房具 布団 猿 一眼レフカメラ 教授が図を説明する 蝉 雨の後、虹が見られるかもしれません 蝉 2019-10-26会う 言う 知る 緑 質問 見つける 聞く 手紙が届くのに三日かかりました 今日はこのホテルに泊まります テープル いい 百 この子は今年7つになります 腰 こっち 今週 付ける 妹 お手洗い これはかなり金がかかった 場合 生まれる 語る 建設 一般の方はこちらの席へどうぞ 彼は行政を改革したいと思っている 我が社の経営はうまく言っています 問題 消える 比べる 変わる 集める 導入 彼がクラスの代表だ 姿 普及 作業 私は味噌汁が全然嫌いではありません テストはいつですか 明日や、明後日や、来週などですね 私はノートパソコンをテレビにする 授業をしている教師 私はおばあちゃんのことが好きです 私は嫌いなことはバスケットをすることです 私の趣味は映画を見ることです 授業をした教師 先生は学生の気持ちがわかります テストはいつですか 明日や明後日や来週などですね 私は魚が嫌いです 私は懐石料理がすごく好きです 私の趣味は野球をすることです 私は日本料理を作ることが少しできます みんなは運動会の予定がわかります 私は鉛筆で字を書く 私の苦手なことは料理を作ることです 小林さんの妻は小林さんに愛妻弁当あげました 私の趣味は料理を作ることです 私は親友と遊びたいです 私はピーマンが嫌いです ご飯を食べた人 彼は私にノートパソコンをくれました 私の好きなことは音楽です 私は日本語が少しできます 私は部長のことが嫌いです 私はあの人のことが嫌いです 私の得意なことはギターを弾くことです 私は自分の力で仕事を探します 上手なコック ご飯を食べている人 シャワーを浴びる象 私の嫌いなことは部屋を掃除することです 宮沢さんは課長のことを、どう思いましか 寝る猫 深い湖 彼女を幸せにする 楽しい一日 プール 中学生 着物 医者は、患者の脈を取っている 私は自分の力で仕事を探します 2019-10-25また会いましょう 授業 よく いつも 笑う 終わる 飛行機 緑 あなたはどう思いましか 今朝は早く家を出ました 寝ぬ 昨日タイカレーを食べました 見せる 一緒に宿題をやろう 彼はシートベルト締めた 食べ物 私は夏が大好き 閉める 手紙が届くのに三日かかりました 百 お手洗い 神 腰 そこ左に曲がってください これはかなり金がかかだ 昼 始まる お店はもう閉まっていました 甘い 掛ける 米 した 触る 運動会は9時開始です 状態 可能 伴う 力 緑 比べる 兄は船を設計をしています 段階 多く 構造 これは大きな社会問題になっている いずれ 残る 大統領 まあ今回は許してあげよう 生活 私たちは二階に上がった 十分 一緒に対策を考えましょう 手紙が届くのに三日かかりました 百 お手洗い 腰 家族 私は懐石料理がとても好きです ハンバーガーとコーラ 私の趣味は料理を作ることです 私の趣味は映画を見ることです これはかなり金がかかった 父は台湾料理を作ることできます みんなは運動会の予定がわかります 授業をする教師 背が高くなる 比べる 私はおばあちゃんのことが好きです 私は部長のことが嫌いです 上手なコック コーヒーを飲みましょうか 宮沢さんは課長のことを、どう思いましか 授業をしている教師 小テストと中間テストと期末テスト、どれが難しですか 私は刺身があまり好きではありません 私の得意なことはギターを弾くことです 私の苦手なことは料理を作ることです インターネットで新幹線の時刻表が分かります 私はあの人のことが嫌いです 私はノートパソコンをテレビにする 私は世界一周をしたくありません みんなは、運動会の予定がわかります 絵を描く シャワーを浴びる象 私は納豆が全然好きではありません 私の嫌いなことは部屋を掃除することです 午後1時から四時までです 上手なコック 私は彼女のことが好きです ご飯を食べた人 犬は大きくありません 私はゲームが好きです 私は妹と弟と実家に帰りました 私は彼と彼女に誕生日カードをもらいました まず、次に、そして、それから、最後に 私の趣味は本を読むことです 私は日本語が少しできます 無料 コーヒーショップ 私は苦手なことは料理を作ることです 予備校生 ライブ フローリング 貯金箱 プール 私はノートパスコンをテレビにする サツマイモは、焼いても揚げても美味しい 虹 スーツケースに詰める 私は日本語が少しできます プール 中学生 2019-10-24駅の近くで食事をした 赤いバラを買いました 漢字 酒 短い 感じる まだ学校へ行くには早い時間です いつも 直ぐ お米 彼は私の方を見ました 明日は晴れるといいですね 明日は昼頃から曇るでしょう こっち 私は部長のことは嫌いです 口 店 ここから富士山がよく見えます 左 見える そこには私一人しかいなかった 状態 この曲線がこの車の特徴です 事務的な処理に1週間かかります 一般の方はこちらの席へどうぞ 交渉 開く 一般 私はおばあちゃんのことが好きです これら 残る 構造 いつも 実施 この本の内容説明してください 技術 決定 十分 存在 彼は行政を改革したいと思っている このプリンターは従来のものより早い 土地 宮さわさんは課長のことを、どう思いますか？ 島の人口は年々増加しています 彼はパソコンを二台持っています 私にはたくさんのお彼が必要だ 宮沢さんは課長のことを、どう思いましか 状態 私の好きなことは音楽を聴くことです ご飯を食べる人 私は部長のことが嫌いです 宮沢さんは課長のことを、どう思いましか？ 私の嫌いなことはバスケットをすることです あの歌手は有名でした 私の嫌いなことは部屋を掃除することです 私はおばあちゃんのことが好きです 私は部長のことが嫌いです 私の好きなことは音楽です 浅い川 私は味噌汁が全然嫌いではありません 私はあの人のことが嫌いです 私は彼女のことが好きです 授業をした教師 私は寿司が好きです 寝ぬ猫 ベッドの下にゴキブリがいます 私の趣味は本を読むことです 周りが静かになる 私の苦手なことは料理を作ることです 私の得意なことはギターを弾くことです 私はおばあちゃんのことが好きです あの服のほうが可愛いです インターネットで新幹線の時刻表が分かります 宮沢さんは課長のことを、どう思いましか 私の嫌いなことは部屋を掃除することです 私は課長のことが嫌いです 私の苦手なことは料理を作ることです 私はおばあちゃんのことが好きです インターネットで新幹線の時刻表が分かります 私の趣味は野球のすることです 車の後ろに子猫と子犬がいます 私は日本料理を作ることがあまり好きではありません 宮沢さんは課長のことを、どう思いましか 社員食堂 どちら フロント 雨の後、虹が見られるかもしれません 宮沢さんは課長のことを、どう思いましか 2019-10-23教える あに 取る 見つける 難しい 同じ わかる 私の嫌いなことは部屋を掃除することです 直ぐ この本は難しいですね 次 午前 寝ぬ 口 分からない場合は私に聞いてください 私の嫌いなことは部屋を掃除することです 私の嫌いなことは部屋を掃除することです 左 こっち 自分 場合 彼に会えて嬉しかった 上手 もう 事実 私の得意なことはギターを弾くことです 重要 代表 彼は小さな会社に勤めています 機能 その問題に関する記事を読みました 私の得意なことはギターを弾くことです 一般の方は此方席へどうぞ 直ぐ 会社 存在 自由 私の得意なことはギターを弾くことです 増える 利用 よく答えが分かりましたね 彼は非常に高い技術を持っている 私の嫌いなことは部屋を掃除することです 左 こっち 私の苦手なことは料理を作ることです 私の嫌いなことは部屋を掃除することです ガソリンの価格がどんどん上がっている 開発 私の苦手なことは料理を作ることです 以上 私の日本語が少しできます 私は懐石料理をとても好きです 私は彼女のことが好きです 私の趣味は野球をすることです 私の趣味は映画を見ることです 私の得意なことはギターを弾くことです 私は彼に使い捨て箸をあげます 私は納豆が全然好きではありません 私は好きなことは音楽です 一般の方は此方の席へどうぞ 私はあの人のことが嫌いです 私の得意なとこはギターを弾くことです 私のノートはどれですか 教室は静かではありません 図書館に本とパソコンがあります 犬は大きくありません ご飯を食べる人 授業をした教師 私の苦手なことは料理を作ることです 私の苦手なことは料理を作ることです 私は彼女のことが好きです 私はあの人のことが嫌いです 新聞で道の状況がわかります 私の嫌いなことはバスケットをすることです 私の趣味は本を読むとこです ご飯を食べた人 ピザを買いました、パスタも買いました 私は泳ぐことができます 私の苦手なことは料理を作ることです 私の好きなことは音楽を聴くことです 私は茶碗蒸しが嫌いではありません 私の趣味は料理を作ることです 私は学生です 佐々木さんはサラリーマンです 授業をする教師 テストはいつですか 明日か明後日か来週ですね ご飯を食べている人 私は彼女のことが好きです 授業をしている教師 彼女は朱さんに中間テストのノートをもらいました 社員食堂 会議 陽傘 虹 センチメートル 雨の後、虹が見られるかもしれません 私はあの人のことが嫌いです 私の苦手なことは料理を作ることです 私は彼女のことが好きです 雨の後、虹が見られるかも知れません 私はあの人のことが嫌いです 2019-10-22歩く 肩が凝りました 立つ 呼ぶ 死ぬ 寝る 帰る 右のボケットにハンカチが入っています 私の趣味は本を読むことです あげる 置く それ 彼はまだ若いです 私は二日待った 悪い 渇く 私の趣味は野球をすることです 喉が渇きました 駅 宿題は自分でやりなさい 彼女は眠いようです 冷たい 近く 柿の木に実が沢山なっています 私の好きなことは音楽です これは医者のためのサイトです 触る かれる 作業するにはもっと広いスペースが必要だ 彼女は自分の立場をわかっていない 私の趣味は本を読むことです 今後ともよろしくお願いします 私の趣味は野球をすることです 話 今日はこれらの問題について話し合います 交差点で事故が発生した 商品 開発 行う命令 私の好きなことは音楽です 結果 彼は新製品に興味を示している 強化 今回 電話 機能 期待 私の好きなことは音楽を聴くことです 政権が交代した 建設 私は彼から大きな影響受けました 残る 加える 作業 私は懐石料理が一番好きです 私の嫌いなことはバスケットをすることです ご飯を食べた人 彼女を幸せにする テレビをつける ご飯を食べている人 私の趣味は映画を見ることです 私の趣味は料理を作ることです ご飯を食べる人 私の趣味は本を読むことです 寝る猫 授業をする教師 シャワーを浴びる象 引き出しにハムスターが一匹います 授業をしている教師 本棚に小説と雑誌があります ください 私の趣味は野球をすることです 私は世界一周をしたくありません 私は懐石料理がとても好きです 授業をした教師 犬は大きくありません 記憶 魔法瓶 腹部 私の好きなことは音楽を聴くことです 私の好きなことは音楽を聴くことです 私の嫌いなことはバスケットをすることです 私の趣味は本を読むことです 私の趣味はバスケットをすることです 犬は大きくありません 私の好きなことは音楽を聴くことです 茶髪 アリクイが行ったり来たりしている 私の好きなことは音楽を聴くことです 私の嫌いなことはバスケットです 私の嫌いなことはバスケットをすることです 私の好きなことは音楽を聴くことです 2019-10-21学校は8時半に始まります 遅い 若い 昨日タイカレーを食べました 授業をしている教師 郵便局で切手を買いました 広い 建てる 日本人はお米が大好きです 十日 32ページを開いてください ご飯を食べた人 かれる 触る 彼はシートベルト締めた 一杯 答えが違います 開く 授業をした教師 多分 必要 残る 信号が青に変わりました 重要 塩、胡椒、加えてください 私の趣味は映画を見ることです 評価 いい方法思いつきました 国は国語教育を強化しています 私の趣味は映画を見ることです 強化 この本の内容説明してください 私の趣味は料理を作ることです 彼は食品工場で働いている 授業をしている教師 動き より 日本語を上手にする ご飯を食べている人 授業をしている教師 ご飯を食べた人 かれる 私はゲームが好きです 触る 私は懐石料理がかなり好きです 私は懐石料理が非常に好きです 授業をしている教師 寝ぬ猫 あの服のほうが可愛いです 授業をした教師 残る 私は日本料理を作ることができます シャワーを浴びる象 私の趣味は映画を見ることです あの歌手は有名ではありません 私は頑張りたくありません ご飯を食べている人 あのバカは二本の鉛筆を箸にして、ご飯を食べる 私はあなたにデジタルカメラをもらいました 授業をする教師です 私の趣味は料理を作ることです 私の趣味は料理を作ることです 私の趣味は映画を見ることです 私は世界一周をしたくありません 私は刺身があまり好きではありません 運動場で走ります ご飯を食べている人 ご飯を食べた人 隣人 コーヒーショップ 下手 お爺さん 使い捨て ビジネスマン 授業をした教師 ライプ 台風 授業をしている教師 質問する 栓抜き 私の趣味は映画を見ることです 私の趣味は料理を作ることです 私は世界一周をしたくありません ご飯を食べた人 授業をした教師 2019-10-20飲む 赤いバラを買いました 帰国することに決めました 彼は今勉強しています 昨日タイカレーを食べました 起こす ご飯を食べる人 狭い また会いましょう 引く 使う 来月の一日は空いていましか 授業をする教師 四月に大学に入学しました 晴れる 彼はシートベルト締めた 授業をする教師 彼女は眠いようです 寝る猫 私の質問に答えてください 風邪 メガネが見つかりません 昨日タイカレーを食べました 男の人は私たちに話しかれた ご飯を食べる人 一人 愛する なお トラブルがやっと解決した 彼はシートベルト締めた シャワーを浴びる象 明らかに彼が悪い 授業をする教師 寝る猫 シャワーを浴びる象 システムの構成を変えてみました ご飯を食べている人 彼は選挙に出るつもりだ 後に 完成 選挙 検討 ご飯を食べる人 党の代表が質問に答えました 提供 女性 この本の内容説明してください 授業をする教師 仕事がほぼ終わりました 調べる あの人は木に登ることができます 上野さんは彼女と映画を見ました 何を食べますか 定食かうどんかラーメンです 寝る猫 大きくありません出した 台湾は暑いです 私は冬が嫌いです 文房具 隣人 シャワーを浴びる象 ノートパソコン 課長 布 綺麗 嫌い 有名 ご飯を食べている人 シャワーを浴びる象 ご飯を食べる人 ぬ ご飯を食べている人 この本の内容を説明してください 授業をする教師 寝る猫 シャワーを浴びる象 ご飯を食べている人 2019-10-19膝に痛みを感じます 出来る 入れる 午前 彼に手紙を書きました 私が払いましょう 彼は歯が白い 時の経つのは早い 動く 九日に荷物が届きます 辛い 口 彼女は眠いようです ハワイは4回目です 答える 口を大きく開けてください 生活 決定 今日の新聞どこに置いた 集める 生産 交差点で事故が発生した トラブルがやっと解決した 激しい 写真はいい思い出になります 対する 病院 工場 相手 対立 外国 会長 夏は涼しかったです 鉛筆は短くありません 両親は日本に行きます、私も行きます カレーライスとオムライス、どちらが美味しいですか 私は茶碗蒸しがあまり嫌いではありません 母はペットと海外旅行しました スピーチが何時まででしか 彼女は眠いようです 私は冬が嫌いです 彼女はマイカーを買いたがります お客さんは家に来ました 学長 予備校生 本棚 ベッド 可愛い女の子 生まれる 年齢 乗客 原稿を改訂する 皿 ツアーガイド フットボール 2019-10-18私には友達が沢山います 元気 勝つ 言う 弱い 乗る もう寝よう 何か飲み物が欲しいな 細い 三日 晩ご飯は食べましたか 店員は若い女の人でした 欲しい この道を真っ直ぐ行くと駅です 口 対策 彼女は同じ間違いを繰り返した 生産 まあ今回は許してあげよう 交差点で事故が発生した 階段 研究 いつれまだお会いしましょう 交差点で事故が発生した いつれまたお会いしましょう 党の代表が質問に答えました 関する ロボット 経済 彼は食品工業で働いています 業者 試合の結果を早く知りたい その計算は間違っている 受ける 投資 情報 私は懐石料理がかなり好きです 私は刺身があまり好きではありません 父は台湾料理ができます 夏は涼しかったです インターネットで新幹線の時刻表が分かります 有名な歌手 私はピーマンが嫌いです 彼女はマイカーを買いたがります 私は納豆が全然好きではありません 私は懐石料理が一番好きです 私は懐石料理がすごく好きです 床に蟻がいます 私は味噌汁が全然嫌いではありません 私は茶碗蒸しがあまり嫌いではありません 本棚に小説と雑誌があります まず、次に、そして、それから、最後に カレンダー マイカー 陽傘 中間レポート 高層ブル 小テスト 布団 雄鶏 虹 茶髪 カニが浜辺を歩いている 肉食妻帯 2019-10-17赤いバラを買いました 乗る １つ 胸に少し痛いがあります 病気 次はいつ会いましょうか 彼女は耳がよく聞こえません もう寝よう 決める どれ 十日後に帰ります 時計を見たらちょうど3時だった 愛する 二日 手紙が届くるに三日かかりました 口 ご主人 つける ため 彼にはこ子供が6人います 関係 それはどういう意味ですか 報告 彼は食品工場で働いています 始めに、会長が挨拶した 制度 その問題に関する記事を読みました 技術 彼はその詩を用いて自分の気持ちを伝えた これから、より一層努力します 計画 遠くに彼女の姿が見えた 作業 彼は非常に高い技術を持っている 文章 輸入 販売 私は味噌汁が全然好きではありません 彼は学校に来ませんでした ボタンを押す 私は日本料理が好きです 私は寿司が好きです 私は懐石料理がとても好きです 母はペットと海外旅行しました 私は魚が嫌いです 佐々木さんはサラリーマンではありません 日本語が上手になる これは小説です 私は懐石料理がすごく好きです 彼は食品工場で働いています 台北の夜市は賑やかです、九份も賑やかです 私はピーマンが嫌いです 彼女はボーリングができます 私は納豆が全然好きではありません 私は懐石料理がとても好きです 彼は彼のお父さんに新しい腕時計をあげました 体育館 ペット 違います 中間テスト 魔法瓶 看板 一眼レフカメラ センチメートル あごひげ 栓抜きありました 茶髪 医者は、患者の脈を取っている び 茶髪 2019-10-16やる 今日は日本語の授業があります 漢字は中国から来ました また会いましょう 兄は水泳が得意です 電車で子供が騒いでいた 赤いバラを買いました まつ とても 軽い 後ろ向いて 二日 休む 来る 彼 野球は9人で人チームです 彼には子供が6人います 上手 この部屋は寒いです その子は指で十数えました そば 曜日 口 彼はこの辺に住んでいます 学生たちはインターネットでいろいろな情報集めた 後に 予定 発生 帰ったらまず手を洗いましょう 政権が交代した 昭和 方針 方向 普及 調べる 犬に餌をやった トラブルがやっと解決した 仕事を続けてください 会談の内容は発表されました 変わる 私はゲームを好きです 私は懐石料理がかなり好きです 私は刺身があまり好きではありません 部屋でご飯を食べます 赤いバラを買いました 私は日本料理が好きです 私は頑張りたくありませんでした 私は懐石料理がかなり好きです 私は魚が嫌いです 私は懐石料理が一番好きです 何を食べましか？ 定食かうどんかラーメンです 口 予備校生 キャベツ 鶏 文房具 乗客 あごひげ 18年前 2019-10-15飛行機 書く 質問 会議は四時に終わります 少し疲れました 彼は意外に気が小さい また会いましょう どう 私は絵を見るのが好きです 授業 お願い 要る 治る 泊まる 鼻 このスープはとても熱い 先月の七日に孫か産まれました 息子は６つになりました 彼に会えて嬉しかった 私が手伝いましょう 夜 後で電話します また会いましょう 後で電話します これはイタリアから輸入した服です 加える 資金 強調 存在 後には 消える 内容 新聞 問題 弟は切手を集めています 方針 可能 信号が青に変わりました 対する 今夜は大いに語りましょう 運動会は9時開始です 株 比べる 試合の会えは誰ですか ほとんど 私は４つの会社に投資しています 力 作業 前売券は窓口で販売しています 私はゲームが好きです 後に お爺さんは昔の記憶を忘れたがります 私は日本語がまあまあできます 机の上にペンが二本あります 私は寿司が好きです 絵を描く インターネットで新幹線の時刻表が分かります 向日葵は草より綺麗です 私は懐石料理がかなり好きです 私は冬が嫌いです 父は台湾料理ができます 私は茶碗蒸しがあまり嫌いです 私は刺身があまり好きではありません 本棚に小説と雑誌があります 私は懐石料理が日非常に好きです 私はあの記憶を忘れたいです 私は納豆が全然好きではありません 私は両親の支えでアパートを買いました 私は味噌汁が全然嫌いです レタス 文房具 記憶 予備校生 レンタサイクル 蚊 ノートパソコン 消しゴム 校長 ポルトガル 炒める 女性がももの太さを計っている サイ 文房具 予備校生 2019-10-14約束を忘れないてください 後 言葉 出る 彼の日本語のレベルは私の同じくらいだ 工事は3月まで続きまし いつ 私たちのチームはその試合で負けた 肉と魚とどちらが好きですか 彼は荷物を網棚に上げだ 彼は歯が白い 見つかる つよい 渇く そこには私に一人しかいなかった 晴れる 有る 方 悪い 会長 まあ今回は許してあげよう 彼は小さな会社に勤めています 原因 その会社は来月、キャンペーンを行う もう 作業 彼はその事件に関係がない 種類 昨年 なお、雨の場合は中止です 決定 受ける まま 結果 検討 段階 音楽は彼の得意な分野です 重要 対立 彼がクラスの代表だ 問題が１つあります 競争 私は納豆が全然好きではありません 私は冬が嫌いです 嫌いな店員 あれはカーテンです 私は刺身があまり好きではありません 私は懐石料理が一番好きです まずい料理 私は王建民ほど有名ではありません 私は懐石料理がかなり好きです 川の岸に桜の木があります 作業 私は懐石料理がすごくできます インターネットで新幹線の 私は味噌汁が全然嫌いではありません 私は茶碗蒸しが全然嫌いではありません 私は懐石料理がかなり好きです 私は懐石料理がすごく好きです 便利な所 コーヒーを飲みましょう 日本語を上手にする 私はピーマンが嫌いです 私は日本に行きます 高層ビル 魔法瓶 焼き鳥 陽傘 台風 ビジネスマン 翻訳する 調味料 虹 アリクイ インターネットで新幹線の時刻表が分かります 2019-10-13今年 知る 郵便局で切手を買いました 持つ 親の愛は有難い 落ちる 質問のある方はどうぞ 神 私は懐石料理がかなり好きです 勝つ 夫の服をハンガーに掛けた 強い お腹 ２つ 千円貸してください 私は腕時計を４つ持っています 私は刺身があまり好きではありません 二十日 7つ 閉まる 柿の木に実が沢山なっています 明日は昼頃から曇るでしょう 五日 腰 私は茶碗蒸しがあまり嫌いではありません 喉が渇きました 彼は新製品に興味を示している まあ今回は許してあげよう 私は茶碗蒸しがあまり嫌いではありません 新しいビルの建設が始まった 銀行は30まで開いていまし ここが建物の中心です 私は懐石料理がかなり好きです 姿 交渉 トラブルがやっと解決した 増える 輸入 今日の新聞、どこに置いた 住宅 私は懐石料理がかなり好きです 実現 私はゲームが好きです 私はピーマンが嫌いです 私は冬が嫌いです 母は日本料理ができます 私は魚が嫌いです 私は刺身があまり好きではありません 私は茶碗蒸しがあまり嫌いではありません 私は懐石料理が一番好きです 私は懐石料理が非常に好きです 私は懐石料理が非常に好きです 本棚に小説と雑誌があります 机のうえにのほんのえんぴつがあります 冬は暖かいです 父は台湾料理ができます 私は納豆が全然好きではありません まあ今回は許してあげよう 私は日本料理が好きです 私は納豆が全然好きではありません 私は懐石料理がとても好きです あのバカは二本の鉛筆を箸にして、ご飯を食べる 私は茶碗蒸しがあまり嫌いでがありません 私は刺身があまり好きではありません 何を食べますか？ 定食かうどんかラーメンですね 私は寿司が好きです 鉛筆は短くありません あなたの会社は私の会社に統計ソフトウエアをくれました 私は懐石料理がとても好きです 私は茶碗蒸しあまり嫌いではありません 私は納豆が全然好きではありません 私の妹に飴をくれましたね、ありがとう あの人は木を登ることができます コーヒー 高層ブル 期末レポート ノートパソコン 私は味噌汁が全然嫌いではありません レタスの葉 とり 小学生 陽傘 形容詞 ライブ 私は味噌汁が全然嫌いではありません 布団 魔法瓶 私は物理の基礎はしていまし 虹 私は納豆が全然好きではありません スーツケースに詰める 医者は、患者の脈を取っている 私は刺身があまり好きではありません 高層ビル 私は納豆が全然好きではありません 陽傘 私は味噌汁が全然嫌いではありません 魔法瓶 私は味噌汁が全然嫌いではありません 虹 2019-10-12とる かなり 肩 国 言う 私はピーマンが嫌いです 秋 楽しむ 美しい ご主人 私はピーマンが嫌いです 私はピーマンが嫌いです 彼は私の上司です お店はもう閉まっていました ８ 彼は神を信じている 止める これはかなり金がかかった １００ 他に方法がありません 私はピーマンが嫌いです 手紙が届くのに三日かかりました その道を真っ直ぐ行くと駅です 近く そばにいてください ８つ 私の祖母は100歳です 話すのを止めてください 政権が交代した 示す 私は懐石料理が一番好きです トラブルがやっと解決した 私は懐石料理が一番好きです 私はピーマンが嫌いです 彼は就職試験を受けた ここは一方通行です 社会 提供 生まれる 交渉 私は懐石料理をすごく好きです 一緒に対策を考えましょう 対象 開発 報告 株 普及 従来 ボラブルがやっと解決した 私は懐石料理が一番好きです 私は懐石料理がすごく好きです 写真はいい思い出になります 全体の80%が完成しました 部長除く全員が土曜日も働いた 私達は二階上がった 開く 彼は非常に高い技術を持っている 必要 この段階では決断するのはまだ早い その問題に関する記事を読みました 私は懐石料理が非常に好きです 相手 信号が青に変わりました 私の両親は昭和生まれです 投資 私は寿司が好きです 九份は賑やかではありませんでした 私は弟と妹と実家に帰りました 彼は社長ではありません ボタンを押す 私は懐石料理がとても好きです 弟は学業を続けたがります 私は魚が嫌いです 母はペットと海外旅行しました 私は懐石料理が一番好きです 父は台湾料理ができます 忙しい会社員 先生は親切です うそ あの人は木に登ることができます 私は冬が嫌いです 私は日本料理が好きです 私は懐石料理が非常に好きです 私はゲームを好きです コーヒーを飲みましょうか まず 次に そして それから 最後に あなたは国仲さんにゲームソフトをもらいましたよね 本棚に小説と雑誌があります 私は懐石料理が非常に好きです ノートパソコン 液晶テレビ 私は懐石料理が非常に好きです 私は懐石料理がとても好きです 私は懐石料理が一番好きです 母は台湾料理ができます あの人は木に登ることができます 私は懐石料理がすごく好きです 本棚に小説と雑誌があります ノートパソコン もり 烏龍茶 虎 日本料理 解答 センチメートル 私は懐石料理がとても好きです 教授が図を説明する 医者は、患者の脈を取っている フクロウ かっこいい サツマイモは、焼いても揚げても美味しい 私は懐石料理がすごく好きです 私は懐石料理がとても好きです 医者は、患者の脈を取っている 2019-10-11数 これ 一つ 一番 今会社に戻ります 覚える 私は寿司が好きです 立つ 昼間は電気を消してください 手伝う 汚い 私は日本料理が好きです 冷たい 締める 私は腕ん時計を四つ持っています 乾く 時々 私はゲームが好きです 彼は選挙に出るつもりだ 影響 国内 建設 一部 私は魚が嫌いです 激しい 構成 実施 私は寿司が好きです 私は日本料理が好きです 私はゲームが好きです 私は魚が嫌いです 調べる 政権が交代した 塩、胡椒加えてください 中心 私は寿司が好きです 土地 強化 管理 お金がまだ十分あります 私は日本料理が好きです 十分 電車が自電車より早いです 長い傘 冬は暖かくありませんでした 私はゲームが好きです クラスを静かにする 浅い川 絵を描く 弟は母の性格がわかります 私は魚が嫌いです 彼女は朱さんに中間テストのノートをもらいました あの屋敷に幽霊がいます 私の友達は野球とサッカーができます ドアを開ける 私は冬が嫌いです 松 原稿改訂する 私は寿司が好きです 私は冬が嫌いです 私は日本料理が好きです 竜巻 フライドポテト フルート 私はゲームが好きです フットボール む 私は魚が嫌いです 私は冬が嫌いです 私は冬が嫌いです 2019-10-10あの歌手は有名です 家に帰ろう 日記 ひく 飛ぶ 始める 彼は足が長い 大学に行ってもうと勉強したいです 彼は数学を教えています さらにケーキを載せました クーラーはまだ直りません 動かないで 終わり 宿題は自分でやりなさい 付ける 直る 大人 これは医者のためのサイトです 窓開けてください 彼は昼過ぎに来ます 導入 彼は非常に高い技術を持っていある 部分 いずれ それはどういう意味ですか 存在 彼は大きな声で話した 引越しを業者に頼んだ 彼はパーティー会場を提供してくれました 結果 計画を一部変更しましょう 選挙 多く 首相 より 検討 変化 今回 動き 政府 信号が青に変わりました 自由 私達は今、結婚資金を貯めています 犬は大きくありません 中間レポートは中間レポートほど大変ではありません 絵を描く 日本語を上手にする 弟は家に帰りました 私は世界一周をしたかったです 飲み物を買いませんでした ピン 記憶 年齢 竹 木製の化粧ダンス 買い物カートは空です 腹部 づ 2019-10-9九份は賑やかです こう 午前 見つける 起きる 耳 はな 今週 手紙が届くのに三日かかりました 曇る 喋る 悲し 柿の木に実が沢山なっています 易しい 酸っぱい １０ 太い 暖かい そこには私一人しかいなかった ドル 変化 方向 私は彼から多いな影響受けました 以上 この建物の構造は複雑です 今後ともよろしくお願いします 規模 事務的な処理に1週間かかります 彼は小さな会社に勤めています それは全て事実ですか 治る 計画 彼は非常に高い技術を持っている 検討 今後の方針が決まった 国は国語教育を強化しています システムの構成を変えてみました 商品 進める 信号が青に変わりました 評価 母はペットと海外旅行をしました あなたは国仲さんにゲームソフトをもらいましたね 川の岸に桜の木があります ペットと言えば、犬や猫や兎や鼠などです 彼女を幸せにする 彼は中国語と英語がわかります 運動場で走ります 引き出しにハムスターが一匹います 彼は非常に高い技術を持っている 冬は暖かくありません ボタンを押す 彼は中国語と英語ができます 彼女はボーリングができます 机 コアラ 台風 アパート ビジネスマン 信号が青に変わりました 布 レタス さら 竹 嫌い 下手 一眼レフカメラ クロサイが草原を歩いている スーツケース 18年前 2019-10-8彼はまだ若いです いう 友達とお酒を飲んでいます 鳥が飛んでいます 今朝は早く家を出ました 胸に少し痛みがあります 一つ 使う 手紙が届くのに三日かかりました 道 教科書を閉じてください 左 7つ 金 空く 時の経つのは早い 細い 時計を見たらちょうど三時だった 体重がかなり減りました 運動会は九時開始す 残る 計算 企業 写真はいい思い出になります 決定 ボルドーはワインの生産で有名だ もう 比べる 国会 生活 話 よく答えが分かりましたね 与える その問題関する記事を読みます 重要 テーブルと椅子 手紙が届くのに三日かかりました いつが暇ですか ボタンを押す 私は頑張りたくありません 彼女はマイカーを買いたがります 一個、ニコ、三個、4個、ごこ、六個、7個、８個、9個、10個 私は日本語ができます まず、次に、そして、それから、最後に すみません、今は何時ですか 私は鉛筆で字を書く 周りが静かになる 学校の先生は数学をできます 彼女は私に新しい手帳くれました する くる 社長は部長と出掛けました ドアを開けませんでした 私は日本語があまりできません テレビを付けません 母はペットと海外旅行しました ボタンを押す 私は日本語ができます 部屋が綺麗になる 日本語を上手にする あれはカーテンです ライブ 一眼レフカメラ 傘 乗客 ツアーガイド フロント 質問する 母はペットと海外旅行しました 2019-10-7軽い 少ない 家に帰ろう 次 入れる 狭い 郵便局で切手を買いました 一つ いろ 答えが違います 私の妹は小学生です 米 閉める 明日は昼頃から曇るでしょう 載せる 彼に会えて嬉しかった 近く 喉が渇きました 大きい 二十日 分からない場合は私に聞いてください 悪い 激しい 示す 政権が交代した 彼は選挙に出るつもりだ 変わる 彼は小さいな会社に勤めています 工場 外国 仕事を続けてください 写真はいい思い出になります 原因 問題 決定 生産 可能 写真はいい思い出になります 激しい雨が降っています 今の首相はあまり力がない ここは静かな住宅地だ 競争 写真 庭の松は高かったです 私の友達は野球とサッカーができます バイクのほうが便利です 私はバスで学校に行きます 深い湖 スーパーは賑やかです 日本語を上手にする まず 次に そして それから 最後に 狭い部屋 教室は静かではありません あなたは私にデジタルカメラをくれました 猫のほうが好きです 学校の先生は数学ができます 私は世界一周をしたいです 緑茶 原稿改訂する 海 地震 スマホ 雄鶏 ７.９センチメートル あごひげ 腹部は、肋とお尻の間の部分です 日本語を上手にする まず、次に、そして、それから、最後に 2019-10-6それ、全部ください 腕 電車で子供が騒いでいた なる どう 飛行機 笑う 授業 膝に痛みを感じます 覚える 去年 帰国することに決めました くる 閉じる 彼女は茶色の靴を履いています 私は二日待った 一杯 そこには私一人しかいなかった 後ろ向いて 百 九日に荷物が届きます 彼がクラスの代表だ 方針 関係 段階 私にはたくさんのお金を必要だ ほとんど その問題に関する記事を読みました 行う それはどういう意味ですか 存在 彼は歌で自分の気持ちを表現した 与える 備える 塩、胡椒加えてください 計画 飛行機が一時間以上遅れた 彼は行政を改革したいと思っている 試合の相手は誰ですか 彼は小さいな会社に勤めています 私達がその問題を調査しています 彼は小さな会社に勤めています 広がる 建設 この部分は問題ないです 床に蟻がいます 先生はテストの解答がわかります 料理をおいしくする 私は日本語ができます 彼女はあの野良犬をペットにする あなたは教師ですか あのバカは二本の鉛筆を箸にしてご飯を食べる 病人が元気になる あの歌手は有名ではありませんでした うそ 石原さんは彼に防虫スプレーをもらいました 美味しいデザート 犬と猫と兎、どれが好きですか ハンバーガーとコーラ 原稿改訂する 幽霊 台風 ビジネスマン 記憶 銀のフルート 18年前 栓抜きありますか ゴリラ ぢ ドゥ ディ 2019-10-5秋 起こす 言う わかる 質問 春 彼はもう帰りました 四つ 昨日友達にあった 晴れる 彼女は眠いようです 月 曜日 駄目 彼は行政を改革したいと思っている 母はまだ外国に行ったここがありません 昨年 これは重要な書類です その事件の犯人はまだ捕まっていない なお 対する 会社 都市 我が社の経営はうまく行っています まま ただ 塩、胡椒、加えてください 世界 完成 特徴 コンピューター その問題に関する記事を読みました 彼は新製品に興味を示している この事故の原因は何ですか ここは私の家です 経済 集める ほぼ より これから、より一層努力します 株 検討 もう 文章 私は彼に使い捨ての箸をあげました 役所の人はおばあちゃんに綺麗なカレンダーをくれました くありません 私は王建民ほど有名ではありません 大学の先輩は商売ができます 彼は彼の父に新しい腕時計をあげました 眠くなる あれはカーテンです 犬は大きくありません 私は世界一周をしたくありません 机の上に二本の鉛筆があります 彼女は社長ですか 先生は難しい本を読むことができます 深い湖 その問題に関する記事を読みました 私は飛行機で日本に行きます 記憶 ビジネスマン 台風 深い 宝石 鶏 ゲームソフト レタス ライブ 香水 18年前 栓抜き かっこいい 記憶 ビジネスマン 台風 18年前 2019-10-4彼の日本語のレベルは私同じくらいだ 近い ご主人 おっと 酒 生きる 冬 学校は八時半に始まります 聞く 午後 あげる 彼は意外に気が小さい 言う 終わり 後ろ 店員は若い女の人でした この道を真っ直ぐ行くと駅です 場合 明日は昼頃から曇るでしょう その人には二回あった そこには私一人しかいなかった 多分 九つ 掛ける 十日後に帰ります 大丈夫 彼はシートベルト締めた 他 夏休みももう終わりだ だめ 冷たい 開発 ソフト 銀行 もう 早く授業進めましょう 病院 言う 部分 一般 仕事はほぼ終わりました 帰ったら、まず手を洗いましょう 運動会九時開始です 販売 加える 良い方法思いつきました 政権が交代した 全体 中心 私は政治に関心がある 彼は良いところだけを強調した 採用 彼は一人旅の計画を立てた 会談 増える 日本語が上手になる 国仲さんはあなたにギターをもらいましたね 彼は中国語と英語ができます 先生はテストの解答がわかります 森に熊がいます 大学の先輩は商売ができます 私はプレゼントをあげましたよね コーヒーを飲みましょうよ スーパーは夜市ほどうるさくありません 先生は私に100点をくれました あの屋敷に幽霊がいましよ あれはカーテンです 夜市 キャベツ 翻訳する 蚊 レタス コンビニ弁当 知り合い ライブ フットボール サツマイモ スーツケースに詰める サツマイモは、焼いても揚げても美味しい あれはカーテンです レタス ライブ 2019-10-3行く 白い 少し疲れました 彼に手紙を書きました 京都にはお寺が多い 一緒に宿題をやろう 続く 午前 そう 買う 広い 私には友達が沢山います 質問のある方がどうぞ 弱い 私たちはビデオゲームをした 百 あそこ 六日前に日本に帰ってきました 後ろ 近く 時計を見たら、ちょうど三時だた 泊まる そこには私一人しかいなかった 私が手伝いましょう 明日は昼頃から曇るでしょう タバコは体に悪い 重要 強化 最近株を始めました 方向 一緒に対策を考えましょう 私は彼から大きな影響受けました もう 外国 状態 報告 彼女は同じ間違いを繰り返した 選挙 開発 写真は良い思い出になります 実現 会談 対立 お金がほとんどありません そこには私一人しかいなかった 明日は昼頃から曇るでしょう 引っ越しを業者に頼んだ 土地 消える 存在 政権が交代した 比べる ドアを開けました 音量を大きくする 彼女はマイカーを買いたがります そこは病院ですね 彼は学校に来ませんでした 彼は中国語と英語ができます このノートは私のノートです ニュースで道の状況がわかります あの屋敷に幽霊がいますよ フライドチキン 楓 麒麟 美術館 着物 女性がももの太さを計っている 政権が交代した 2019-10-2あと たつ 持つ 低い 郵便局で切手を買いました 宿題はまだ終わっていません 戻る 学校は八時半に始まります 見せる 午前 座る 知る 軽い 約束をわしれないでください 彼はこの辺に住んでいます うえ 着る 十 日 宿題は自分でやりなさい 近く 愛する 喉が渇きました 腰 百 答える 存在 開始 対する 交渉 遠くに彼女の姿が見えた 運動会は九時開始です 全体 計画 種類 社会 予定 参加 彼は食品工場で働いています 国会 塩、胡椒加えてください トラブルがやっと解決した 内容 土地 文章 国内 多く 私たちは二階に上がった 会長 なお、雨の場合は中止です 今日の新聞、何処に置いた まず 近く 百 前売券は窓口で販売しています 存在 生活 可能 もう 私は弟と妹と実家に帰りました 川の岸に桜の木があります あの馬鹿は二本の鉛筆を箸にして、ご飯を食べる 向日葵は草より綺麗です ご飯を食べましょう ジーンズを買いましょう 犬は大きくありません もう 私は石原さんに防虫スプレーをあげました あなたの会社は私の会社に統計ソフトウエアをくれました 私のノートはどれですか 夏は涼しくありません 皆は運動会の予定をわかります 犬は大きくありません 私は討論を始めたいです 原稿改訂する 猿 期末テスト 社員食堂 レタスの葉 文房具 中学生 レタス ツアーガイド 走る する センチメートル ドゥ 2019-10-1今月 彼女はイタリア語ができます 待つ 会議は四時に終わります 勝つ 上司が、一杯、飲もうと言った 建てる もらう 引く 電車で子供が騒いでいた 帰る 七日 四月に大学に入学しました 動き 何か飲み物が欲しいな 起きる 左 段階 塩、胡椒加えてください 決定 彼は就職試験を受けた 生活 計画を一部変更しましょう 残る 目たつ 彼がクラスの代表だ 特徴 あまり 姿 十分 運動会は九時開始です 試合の相手は誰ですか 事実 相手 生まれる 提供 弟は父の性格がわかります あなたの会社は私の会社に統計ソフトウエアをくれました コーヒーを飲みましょうよ 佐々木さんはサラリーマンです 塩、胡椒加えてください 机の上に雑誌があります あのバカは二本の箸を鉛筆にして、ご飯を食べる 彼女はマイカーを買いたがります 楽しい一日 冷蔵庫に三つのリンゴとオレンジがあります 運動会は九時開始です 彼は学校に来ませんでした 氷山が小さくなる 犬は大きくありません 私は歌を歌うことができます 浅い川 皿 ゲームソフト 液晶テレビ 原稿改訂する あのバカはに二本の鉛筆を箸にして、ご飯を食べる コーラ 期末レポート かっこいい あごひげ 私は物理の基礎は知っています 教授が図を説明する ドゥ 犬は大きくありません 原稿改訂する ドゥ","link":"/zh-tw/japanese/2019/October/index.html"},{"title":"November 2019","text":"2019-11-30赤いバラを買いました 短い 鳥が飛んでいます 落ちる 狭い ご主人 茶色 予約入りません 起きる 大学生 強い 大人 よう 休む 曜日を間違いました 野球は9人で人チームです ほぼ これは重要な書類です 彼はその事件に関係がない 経済 この三百ドルしました なお、雨の場合は中止です 私は四つの会社に投資しています 強調 料理がたくさん残りました 変化 後 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう ニュースで道の状況がわかります 森にクマがあります 休む どうして麒麟は首が長いですか あの歌手は有名でした 新しいゲームソフト買いました。なので、バイト代が全部無くなります 私はおああちゃんのことが好きです みんなは運動会の予定がわかります えっと、電車が遅れましたので、遅刻しました 今夜は蒸し暑いですから、明日は雨が降るでしょう 今日は何曜日ですか どこが賑やかですか あの喫茶店は静かですから、あそこでテストの勉強をしましょう 授業をした教師 あれはカーテンです 私の苦手なことは料理を作ることです 私は日本料理が好きです 私はマイカーを買いたいです 傘をさす なぜ大体のお店は試食を置きますか 今夜は蒸し暑いですから、明日は雨が降るでしょう どうして今日遅刻した なんで台湾の会社は大学生を雇いたくないのですか か 紙粘土 予備校生 腕時計 苺 サツマイモ 2019-11-29カナダの冬はとても寒いです 低い 私の夫はサラリーマンです 送る そこに大きな円を書いて 彼の日本語のレベルは私の同じくらいだ 決める その次の週は空いていますか 弱い 私には友達がたくさんいます 開く 財布は机の下にあった 晴れる いる 酸っぱい 八日からイギリスに行きます 教科書を閉じてください 私が手伝いましょう 違う 七日 今日はとても暑い 冷蔵庫に三つのリンゴーとオレンジがあります 宮沢さんは課長のことを、どう思いますか あの喫茶店は静かですから、あそこでテストの勉強をしましょう これは重要な書類です 私の苦手なことは料理を作ることです 弟は父の性格がわかります バカ！言い訳するな お釣りをください 苺 広告 校長 紅茶 社員 ペット 牛 フライト ポルトガル 蝉 スーツケースに詰める ツアガードはあなたの旅行を楽しくする興味深い情報を知っているだろう ツアーガイド 苺 2019-11-28買う 起こす 変える 少し疲れました 彼は荷物を網棚にあげた 始める 探す 黄色い 手紙が届くのに三日かかりました 彼はシートベルト締めた 酸っぱい 辛い 八日からイギリスに行きます 店員は若い女の人でした あの大き建物はなんですか 決まる 五日 腰 冷たい飲み物ください お手洗い 線 ほとんど 私たちは二階に上がった 国内 電気がついたままですよう 私たちは今、結婚資金を貯めています へる 建設 計画を一部変更しましょう 商品 この町は人口が増えた 合格者が発表された ほぼ 会談 上がる レシートをください 弟は学業を続けたがります 夏は涼しくありませんでした 昨日、何処かに行きましたか いいえ、どこも行きませんでした 酸っぱい 弟は父の性格がわかります バカ！言い訳するな ご飯を食べた人 なぜ台湾の会社は大学生を雇いたくないのですか 和食と言えば、寿司や味噌汁や天ぷらなどです なんで台湾の会社は大学生を雇いたくないのですか 日本語が上手になる 飛行機が二時間遅れました。なので、到着時間も遅くなります 引き出しにハムスターが一匹います 私は風邪をひきました。なので、映画館に行きませんでした 今夜は蒸し暑いので、蚊が多くなりました 私は魚が嫌いです 隣人 冷蔵庫 マイカー フクロウ ツアーガイドはあなたの旅行を楽しくする興味深い情報知っているだろう ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろう 2019-11-27体 帰国することに決めました 軽い 昨日、友達にあった 小さい花が咲いています 書き直す 強い 昨日 左 お名前をカタカナで書いてください いつか ほぼ 引越しを業者に頼んだ 今後ともよろしくお願いします 交渉 生産 進める 作業 ソフト 国会 特徴 商品 利用 可能 消える 銀行 処理 宮沢さんは課長のことを、どう思いますか 机の上に雑誌があります 私の得意なことはギターを弾くことです 五日 ほぼ 私は実家に帰りたいです ご飯を食べている人 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 商品 飛行機が二時間遅れました。なので、到着時間も遅くなります 傘は長いです 床にアリがいます テストはいつですか 明日や明後日再来週などですね 彼は会長でした どれが綺麗ですか なぜ台湾の会社は大学生を雇いたくないのですか ニュースで道の状況がわかります 弟は父の性格がわかります 私は風邪をひきました。だから、明日学校に行きたくありません 私は歌を歌うことができます なんで台湾の会社大学生を雇いたくないのですか 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 部長は仕事ができます レンタサイクル 隣人 大きな竜巻 冷蔵庫 美術館 乗客 葉が落ちます 調味料 弟は父の性格がわかります 隣人 冷蔵庫 2019-11-26今日は日本語の授業があります 髪 次はいつ会いましょうか 上げる 古い 上司が一杯、飲もう。と言った 使う 軽い 彼女はイタリア語ができます 体 彼はタオルで顔を拭きました 座る 九日荷物が届きます 上を向いて 辛い 時計を見たらちょうど三時だった 細い 違う 息子は六つになりました 汚い 方 いずれ 彼女の大きな帽子はとても目立つ 調べる 国会 彼は非常に高い技術を持っている 女性 開発 比べる 電車のドアが開きました 十分 残る 今月と先月の売り上げを比べた 従来 彼は行政を改革したいと思っている 変化 処理 それはどういう意味ですか 中心 一般 これは世界最大の船です 消える バカ、言い訳するな 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう ゴミ箱にペットボトルがあります 向日葵は草より綺麗です 夏は涼しかったです 誰もいません 学生だはなかった どれも要りません ニュースで道の状況がわかります 病人が元気になる 日曜日が暇です 部屋にベッドがあります 私は鉛筆で字を書く 自転車とバイク、どちらが便利ですか 処理 私はもっと頑張りたいです 宮沢さんは課長のことを、どう思いますか 猿 キリン 中学生 日本 おやつ ガスコンロ えさ 果物 その男性は使い捨て髭剃りで顎鬚を剃っている ニュースで道の状況がわかります センチメートル 綺麗 嫌い 有名 処理 宮沢さんは課長のことを、どう思いますか 2019-11-25家に帰ろう 鳥が飛んでいます 工事は3月まで続きます 若い 郵便局で切手を買いました 触る 千円貸してください 始まる 教科書を閉じてください お先にどうぞ 後ろを向いて 予約要りません 辛い 違う 私は平仮名を全部読めます 上る 方針 いずれ 日本での生活は楽しいです 残る 問題 実現 料理がたくさん残りました まず相手の動きを見ましょう 電気がついたままですよう 今回 ほとんど 私は四つの会社に投資しています 国は国語教育を強化しています もう 報告 情報 強調 代表 より 良い家を選ぶのは難しい 宇宙人は存在すると思いますか 台北駅はどこですか 誰もいません 森に熊がいます 飛行機が二時間遅れました。なので、到着時間も遅くなります 広い部屋 明日の食券をください なんで今日私の家に来ましたか 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 辛い 違う 授業をする教師 私は日本語が少しできます 彼は実家に帰りたがります えっと、電車が遅れました、だから、遅刻しました バカ、言い訳するな 私は日本語が大体できます どうして台湾の会社は大学生を雇いたくないのですか 田舎は都市ほど便利ではありません 私はおばあちゃんのことが好きです 温かい手 飲み物を買います 私の嫌いのことは部屋を掃除することです なぜ大体のお店は試食を置きますか 原稿を改訂する 友達がコーヒーショップで集まっている 茶髪 かっこいい男 フクロウ 私は物理の基礎はしています 質問する 違う ばか！言い訳するな 違う 2019-11-24言う こう おかげさまで元気です 行く 近い 腕 その次の週は空いていますか 消す 耳 軽い 教科書を閉じてください お店はもう閉まっていました 財布は机の下にあった 平仮名 三日 彼は時々遅刻します 違う こっち 曜日を間違いました 野球は9人で人チームです 昨日から腰が痛い このコートはとても暖かい 彼はその詩を用いて自分の気持ちを伝えた 部長を除く全員が土曜日も働いた 信号が青に変わりました 電気がついたままですよう 工場 この動物園は日本一の規模です 株 会談 特徴 評価 来年から新しい制度が始まります ほとんど 目立つ 交差点で事故が発生した 続ける 対立 方向 土地 建設 和食と言えば、寿司や味噌汁や天ぷらなどです 教科書を閉じてください 違う 長い傘 なんで今日私の家に来ましたか 机の上に雑誌があります 私はおばあちゃんのことが好きです なんでこんな時間に学校にいないのですか 新しいゲームソフトを買いました。だから、古いソフトを売りました 電気がついたままですよう 今日、何か買いますか はい、オレンジを買います あの喫茶店は静かなので、あそこで勉強する人が多いでしょう ほとんど 今夜は暑いです。なので、蚊が多くなりました 私はもっと頑張りたかったです 飛行機は二時間遅れました。なので、到着時間も遅くなります 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 違う 彼は学校の先生ですから、子供の親からのプレッシャーが多いでしょう 私はおばあちゃんのことが好きです 寝る猫 中村さんは昨日夜十時まで仕事をしましたから、残業代がたくさんもらえる多いでしょう ベッド 布団 屋上 子犬 脈を取る かっこいい 飛行機が二時間遅れました。なので、到着時間も遅くなります 2019-11-233月は仕事が忙しい 見せる 生きる 言葉 書く 彼は足が長い 待つ 郵便局で切手を買いました 鳥が飛んでいます 軽い 悲し 大人 掛ける 彼女は眠いようです 彼は昼過ぎに来ます 強い お願い 曜日 柿の木に身がたくさんなっています 特徴 方向 彼は就職試験を受けた 生産 導入 住宅 文章 後 開発 部分 強調 コンピューター 輸入 仕事がほぼ終わりました 多く この段階では決断するのはまだ早い 除く 新しいコンピューターを買った 彼は選挙に出るつもりだ 力 報告 私は四つの会社に投資しています 企業 一般 下手な選手 中村さんは昨日10時まで仕事しましたので、残業代がたくさんもらえるでしょう 軽い 飛行機が二時間遅れました。なので、到着時間も遅くなります 明日の食券をください 和食といえば、寿司屋、味噌汁や、天ぷらなどです 母は料理の方法がわかります 学食の料理はまずいです。このレストランの料理もまずいです 日本語を上手にする 貯金箱40個のコインがあります 私は日本語がわかります 何も食べません どうして台湾の会社は大学生を雇いたくないのですか えっと、電車が遅れましたので、遅刻しました そっか、今度早く家を出ろ 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります ボタンをおっす あのバカは2本の鉛筆を箸にして、ご飯を食べます 飛行機が二時間遅れました。なので、到着時間も遅くなります 和食と言えば、寿司屋、味噌汁や、天ぷらなどです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 机の上に雑誌があります 台風 晩御飯 一眼レフカメラ ノートパソコン うめ 広告 親戚 雨の後、虹が見られるかもしれません め 机の上に雑誌があります 2019-11-22もらう 私たちのチームはその試合で負けた 入れる また会いましょう 会議は四時に終わります 鳥が飛んています 駅まで歩きましょう 同じ 午後 直ぐ 私は毎日、日記を付けています 教える 黄色い 私は二日待った 鳥が飛んでいます これはかなり金がかかった 八つ 予約入りません 火曜日に会議があります これは医者のためのサイトです 眼鏡が見つかりません 眼鏡が見つかりません 他 方向 報告 いい方法思いつきました 特徴 種類 彼は事故で怪我をしました 関係 状態 帰ったら、まず手を洗いましょう 今夜は大いに語りましょう 彼は行政を改革したいと思っている 一般の方はこちらの席へどうぞ それはどういう意味ですか 会談 建設 計算 住宅 存在 販売 解決 生活 消える 与える 新しいゲームを買いました。なので、バイト代が全部なくなりました 何で学校に行くのですか 下手な選手 新しいゲームソフトを買いました。だから、古いゲームを売りました どうして台湾の会社は学生を雇いたくないのですか 報告 私は風邪をひきました。だから、映画館に行きませんでした 母は料理を作ることができます 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は泳ぐことができます そっか、今度早く家を出ろ 昨日、何処かに行きましたか いいえ、どこも行きませんでした 彼は会長ではありませんでした えっと、電車が遅れたので、遅刻しました シャワーを浴びる象 どうして麒麟は首が長いですか 氷山が小さくなる なぜ大体のお店は試食を置きますか 彼女は社長です 私は日本語が大体できます ジュースはコーヒーほど高くありません えっと、電車が遅れたから遅刻しました コーヒーショップ 消しゴム 陽傘 えさ おやつ 栓抜きありますか サツマイモ 調味料 フロント 2019-11-21テストでいい点を取った その次の週は空いてますか 今月 使う 彼はタオルで顔を拭きました 授業 大学に行ってもっと勉強したいです 引く 次はいつ会いましょうか 柿の木に実がたくさんなっています 曜日を間違えました 強い お名前をカタカナで書いてください 夜 予約入りません 八日からイギリスに行きます 二つ 100 夏 財布は机の下にあった 32パージを開いてください 生産 従来 建設 トラブルがやっと解決した 彼女は大きな帽子はとても目立つ 対する 比べる 政府 彼は非常に高い技術を持っている 計画 目立つ 方向 事務的な処理に1週間かかります 討論 会談 対策 決定 特徴 段階 これからより一層努力します 交差点で事故が発生した 強化 私はマイカーを買いたいです 私は好きなことは音楽です 予約は要りません 彼女を幸せにする ゴミ箱に猫がいます どうして台湾の会社は大学生を雇いたくないのですか 彼は社員です 私は日本語が大体できます どうして今日遅刻した 刺身をください 梅と桜 私の趣味はバスケットをすることです 方向 飛行機は二時間遅れました。なので、到着時間も遅くなります 会談 特徴 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 犬と猫と兎、どれが好きですか 私は寿司が好きです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 何も買いません なんでこんな時間に学校にいないのですか 何で学校に行くのですか 私は日本料理が好きです なんで台湾の会社は大学生を雇いたくないのですか どうして台湾の会社は大学生を雇いたくないのですか 昨日、どこに行きまhしたか。昨日、コンサートに行きました スーパー えさ おやつ 布 高層ビル キャベツ 芸人 ライブ ボルトがる 下手 炒める 飛行機が二時間遅れました。なので、到着時間も遅くなります かっこいい男 葉が落ちます 新しいゲームソフトを買いました。なので、バイト代が全部無くなります えさ おやつ 2019-11-20遠い 持つ 赤ん坊が笑っています 一つ 遅い きく 彼はもう帰りました 今 置く 変える 彼に手紙を書きました 強い 時計を見たら、ちょうど3時だった 彼女は三人の子供の母親だ 32ページを開いてください 小さい花が咲いています 側 水 ミーティング 私は犬が大好きです よう 今週 曜日を間違いました 財布は机の下にあった 彼は時々遅刻します 彼は行政を改革したいと思っている 強い 建設 作業 ほとんど 交差点で事故が発生した 全国 国内 生活 語る 病院 生産 計画を一部変更しましょう システム 強化 いずれ 午後四時までです なんで台湾の会社は大学生を雇いたくないのですか 私はピーマンが嫌いです 学生ではない どうして今日遅刻しましたか 曜日を間違えました どこが賑やかですか お爺さんは昔の記憶を忘れたがります 財布は机の下にあった 父は台湾料理ができます すみません、今は何時ですか どこも行きません 彼女は飛行機を運転することができます 私はもっと頑張りたかったです 建設 弟は父の性格がわかります ドアを開ける 私はノートパソコンをテレビにする 交差点で事故が発生した 生産 シャワーを浴びる象 先生の隣に父と母がいます なぜ台湾の会社は大学生を雇いたくないのですか 私の苦手なことは料理を作ることです 傘は長くありません 私の趣味は映画を見ることです 先生は難し本を読むことができます 広い部屋をください 今夜は蒸し暑いですから、明日は雨が降るでしょう なんでこんな時間に学校にいないのですか あの喫茶店が静かなので、あそこで勉強する人が多いでしょう インターネットで新幹線の時刻表が分かります 私は日本語が大体できます 夜市が賑やかです バカ！言い訳するな 私は風邪をひきました。なので、映画館に行きませんでした 何曜日が暇ですか どこが賑やかですか 夜市はどこですか 私は世界一周をしたくありませんでした キャベツ 烏龍茶 レタス ゴミ箱 鶏 着物 ロブスター 雄鶏 かっこいい男 18 ち 私は日本語が大体できます かっこいい男 2019-11-19その次の週は空いていますか 彼はタオルで顔を拭きました 建てる 立つ 私が行きましょう 切る つぎはいつ会いましょうか 載せる かれは時々遅刻します こっち 私が手伝いましょう 息子は六つになりました 宿題は自分でやりなさい クーラーはまだ治りません 腰 口 黄色い 影響 強調 社会 残る 運動会は9時開始です 集める 合格者が発表された 方針 対策 採用 コンピューター 消える 比べる その問題に関する記事を読みました 彼女は大きな帽子はとても目立つ これは世界最大の船です それはどういう意味ですか 管理 部分 ほとんど 彼は行政を改革したいと思っている 国会 予定 この服は三百ドルしました 彼は時々遅刻します なぜ台湾の会社は大学生を雇いたくないのですか 音量を大きくする 台北駅はあそこです 弟さんにゲームをあげました なんで今日私の家に来ましたか 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 明日の食券をください 本棚に小説と雑誌があります 私は風邪をひきました。だから、明日は学校に行きたくありません あの喫茶店は静かですから、あそこでテストの勉強をしましょう 今夜は蒸し暑いですから、明日は雨が降るでしょう 今日、何か買いますか いいえ、何も買いません ほとんど まず、次に、そして、それから、最後に 私はピーマンが嫌いです 私は懐石料理を一番好きです 母は日本料理を作るできます 母はペットと海外旅行をしました 中村さんは昨日10時まで仕事しましたので、残業代がたくさんもらえるでしょう 私は日本語ができます 病人が元気になる 私は懐石料理がすごく好きです 私は魚が嫌いです スーパーは夜市ほどうるさくありません なぜ大体のお店は試食を置きますか どうして麒麟は首が長いですか 私は頑張りたかったです どうして台湾の会社は大学生を雇いたくないのですか ビジネスマン 生まれる 本棚 サツマイモは、焼いてもあげても美味しい 調味料 蝉 クロサイが草原を歩いている れ 2019-11-18九份は賑やかです 彼はタオルで顔を拭きました 私の夫はサラリーマンです いつも 緑 子供 遊ぶ 今朝は早く家を出ました 首 消す 酒 その次の週は空いてますか 次はいつ会いましょうか 黄色い 多分 お願い 昼 冷たい 彼はシートベルトを締めた 彼女は茶色の靴を履いています 男の人が私たちに話しかけた 解決 彼は食品工場で働いています 会社 私は彼から大きな影響受けました 変化 彼は新製品に興味を示している 決定 遠くに彼女の姿が見えた それはどういう 彼はタオルで顔を拭きました 検討 備える 彼女は大きな帽子はとても目立つ その次の週は空いていますか 次はいつ会いましょうか 政権が交代した 部分 中心 黄色い 彼は行政を改革したいと思っている 我が社の経営はうまくいっています 消える 比べる 選挙 交渉 何で学校に行くのですか 夜市はスーパーよりうるさいです どうして麒麟は首が長いですか なんでこんな時間に学校にいないのですか 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう それはどういう意味ですか 彼はタオルで顔を拭きました 飛行機が二時間遅れました。なので、到着時間も遅くなります 彼女は大きな帽子はとても目立つ うそ 今夜は蒸し暑いので、蚊が多くなります 上手なコック 先生はテストの解答がわかります 彼は行政を改革したいと思っている なぜ大体のお店は試食を置きますか どうして台湾の会社は大学生を雇いたくないのですか 消える 比べる 彼は学校に来ませんでした 新しいゲームソフトを買いました。だから、古いソフトを売りました 明日の食券をください 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は風邪をひきました。だから、明日学校に行きたくありません なんで今日私の家に来ましたか 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 私の嫌いなことはバスケットをすることです 引き出しにハムスターが一匹います えっと、電車が遅れたので、遅刻しました あなたのカバンはこれです あの喫茶店は静かですから、あそこでテストの勉強をしましょう お爺さんは昔の記憶を忘れたがります 私は寿司が好きです 中村さんは昨日よる十時まで仕事しましたので、残業がたくさんもらえるでしょう 私は懐石料理がとても好きです あの喫茶店は静かので、あそこで勉強をする人が多いでしょう 明日の食券をください 魔法瓶 広告 大きな竜巻 宝石 味噌汁 皿 文房具 記憶 定食 愛妻弁当 フクロウ 調味料 7点9センチメートル 中村さんは昨日よる十時まで仕事しましたので、残業代がたくさんもらえるでしょう 調味料 2019-11-17見る 午前 飛行機 出来る 今、朝ご飯を作っています 朝から頭が痛い それ 赤い 行く 帰る 親の愛は有難い 笑う 約束を忘れないてください 遅い カナダの冬はとても寒いです 言葉 年 昨日タイカレーを食べました 彼は足が長い 数 会う 後ろ しめる 大人 その人には二回に会った 彼女は茶色の靴を履いています お手洗い 十日後に帰ります お名前をカタカナで書いてください 喉が渇きました 後ろ向いて 私は世界旅行をしたい 重要 システムの構成を変えてみました この本を内容を説明してうください 今夜は大いに語りましょう 彼は非常に高い技術を持っている 商品 企業 処理 みんな私たちに期待しています 災害に備えて大量の水を買い込んだ 私は四つの会社に投資しています 国は国語教育を強化しています 強調 従来 備える 写真はいい思い出になります 全国 内容 まあ今回は許してあげよう 部長を除く全員が土曜日も働いた 種類 のち なんで今日私の家に来ましたか 絵を描く 彼は小学校の先生なので、毎日四時ちょうどに家に変えます 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね どうして台湾の会社は大学生を雇いたくないのですか あの人は木を登ることができます 何で学校に行くのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 母は実家に帰りました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 夜市はどこですか あなたのカバンはこれです なぜ大体のお店は試食を置きますか バカ！言い訳するな 私は王建民ほど有名ではありません なんでこんな時間に学校にいないのですか 今夜は蒸し暑いので、蚊が多くなりました えっと、電車は遅れましたので、遅刻しました 私は風邪をひきました。なので、映画館に行きませんでした 中村さんは昨日夜十時まで仕事をしましたので、残業代がたくさんもらえるでしょう 私は料理を作ることができます 私のカバンはどれですか 彼は社長でした どうして台湾の会社は大学生を雇いたくないのですか 教室は静かではありません 私は自分の力で仕事を探します なんで台湾の会社は大学生を雇いたくないのですか 広い部屋をください そっか、今度早く家を出ろ なぜ台湾の会社は大学生を雇いたくないのですか 新しいゲームソフトを買いました。だから、古いソフトを売りました えっと、電車が遅れましたから、遅刻しました 授業をしている教師 飛行機が二時間遅れました。だから、それで怒って売る人が多いでしょう 私は世界一周をしたくありません カバンに香水があります 私は頑張りたかったです 新しいゲームソフトを買いました。なので、バイト代が全部なくないました 昨日、どこに行きましたか 昨日、コンサートに行きました 私は茶碗蒸しがあまり嫌いではありません 姉 液晶テレビ 携帯ゲーム 医者は、患者の脈を取っている アリクイ フットボール センチメートル 葉が落ちます 緑色の蝉 め 2019-11-16わかる 今年 取る 戻る 直ぐ行きます この靴はとても軽い 彼は私にノートパソコンをくれました 二つ 米 八つ 愛する 後ろ向いて 悲し お名前をカタカナで書いてください 僕は新しい靴が欲しいです 六つ 千円貸してください 大丈夫 上る 目 なんでこんな時間に学校にいなにのですか 八日からイギリスに行きます なんでこんな時間に学校にいないのですか なんでこんな時間に学校いいないのですか 終わり 経営 経済 採用 宇宙人は存在すると思いまうか 報告 彼は非常に高い技術を持っている お名前をカタカナで書いてください 何で学校に行くのですか これは世界最大の船です 従来 いずれ 結果 飛行機が二時間遅れました。なので、到着時間を遅くなります 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は風邪をひきました。なので、映画館に行きませんでした どれが綺麗ですか たいです 飲み物を買いました 今夜は蒸し暑いですから、明日は雨が降るでしょう なぜ台湾の会社は大学生を雇いたくないのですか なんでこんな時間に学校にいないのですか なぜ大体のお店は試食を置きますか 犬は大きくありません なんでこんな時間に学校にいないのですか なんで今日私の家行きましたか？ 私は日本料理を作ることが全然できません なんで台湾の会社は大学生を雇いたくないのですか 彼は非常に高い技術を持っている どうして今日遅刻した 何で学校に行くのですか 従来 眠くなる どうして麒麟は首が長いですか どうして台湾の会社は大学生を雇いたくないのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 病人が元気になる えっと、電車が遅れたから遅刻しました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 部屋が綺麗になる 何で学校に行くのですか 私はもっと頑張りたかったです 夜市は賑やかです 佐々木さんはサラリーマンではありませんでした 何で学校に行くのですか 私の苦手なことは料理を作ることです バカ、言い訳するな 昨日、何処かに行きましたか はい、コンサートに行きました 氷山が小さくなる レシートください 佐々木さんはサラリーマンでした そっか、今度早く家をてろ どれも要りません 飛行機が二時間遅れました。なので、到着時間も遅くなります 私はもっと頑張りたかったです 何で学校に行くのですか 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 書店 期末レポート 引き出し 虹 教授が図を説明する 葉が落ちます 医者は患者の脈を取っている 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 葉が落ちます 2019-11-15私は電車で通学しています 質問のある方はどうぞ 郵便局で切手を買いました 払う また会いましょう 私たちのチームはその試合で負けた 息子は六つになりました 曇る 手紙が届くのに三日かかりいました 教科書を閉じてください なぜ大体のお店は試食を置きますか 多分 六つ 四月に大学に入学しました なぜ大体のお店は試食を置きますか 付ける 時計を見たらちょうど三時だっあ 何 100 時の経つのは早い なんで今日私の家に来ましたか 触る 見つかる 他 報告 制度 語る 増える プログラム 銀行は三時まで開いています どうして台湾の会社は大学生を雇いたくないのですか なぜ大体のお店は試食を置きますか いずれ 作業 資金 行う 動き 変わる 実現 部分 なぜ大体のお店は試食を置きますか これは世界最大の船です なんで今日私の家に来ましたか 文章 姿 十分 私は風邪をひきました。だから、映画館に行きませんでした 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 授業をした教師 飛行機が二時間遅れました。なので、到着時間も遅くなります いずれ なぜ大体台湾のお店は試食を置きますか これは世界最大の船です どうして台湾の会社は大学生を雇いたくないのですか 私の得意なことはギターを弾くことです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました あの喫茶店は静かなので、あそこで勉強する人が多いでしょう いいえ、違います なので、到着時間も遅くなります いずれ どうして台湾の会社は大学生を雇いたくないのですか どこが賑やかですか 私はゲームが好きです 私は世界一周をしたくありませんでした そっか、今度早く家を出ろ お釣りをください なんで今日家に来ましたか 何曜日が暇ですか 私は日本に行きます 今日、何か買いますか いいえ、何も買いません バカ、言い訳するな 新しいゲームソフトを買いました。だから、古いソフトを売りました 授業をしている教師 どうして今日遅刻しました 飛行機は二時間遅れました。だから、それで怒っている人が多いでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります なんで台湾の会社は大学生を雇いたくないのですか どうして麒麟は首が長いですか ニュースで道の状況がわかります なんで今日私の家に来ましたか えっと、電車が遅れたので、遅刻しました バカ、言い訳するな なぜ台湾の会社は大学生を雇いたくないのですか 私は風邪をひきました。だから、明日学校に行きたくありません 日本は台湾ほど暑くありません あの喫茶店は静かですかあ、あそこでテストの勉強をしましょう 上手なコック 私は学生であはりませんでした なんで台湾の会社は大学生を雇いたくないのですか 今夜は蒸し暑いですから、明日は雨が降るでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります ペットを飼いましょうよ どうして台湾の会社は大学生を雇いたくないのですか 音量を大きくする なぜ台湾の会社は大学生を雇いたくないのですか どこも行きません 九份は賑やかです 私は部長のことが嫌いです なぜ台湾の会社は大学生を雇いたくないのですか 弟は父の性格がわかります なんで台湾の会社は大学生を雇いたくないのですか 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 役所の人はおばちゃんに綺麗なカレンダーをくれました なんで台湾の会社は大学生を雇いたくないのですか 今夜は蒸し暑いですから、明日は雨が降るでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります コンサート 親戚 トラ 梅 書店 中学生 なぜ台湾の会社は大学生を雇いたくないのですか 屋上 なんで台湾の会社は大学生を雇いたくないのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 2019-11-14みんなにお菓子をあげましょう 私の夫はサラリーマンです おかげさまで元気です 楽しむ 忘れる 美し 彼は数学を教えています 新しい仕事を見つけました 帰る 日記 彼は足が長い 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 帰国することに決めました 7つ よう お手洗い 息子は六つになりました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 欲しい 9 六つ 決まる 私は風邪をひきました。なので、映画館に行きませんでした ここの料理はまずい 下 彼女は眠いようです 楽しい 小さい花が咲いています このコートはとても暖かい そこには私一人しかいなかった 私は腕時計を4つ持っています 風邪 こっち 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 息子は六つになりました 普及 飛行機が二時間遅れました。なので、あそこで怒っている人が多いでしょう 飛行機が二時間遅れました。だから、あそこで怒っている人が多いでしょう 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は風邪をひきました。なので、映画館に行きませんでした 飛行機が二時間遅れました。だから、あそこで怒っている人が多いでしょう 政権 状態 この商品はよく売れている 次は全国のお天気です 体重がかなり減りました 彼は選挙にですつもりだ 信号が青に変わりました 合格者が発表された 今夜は大いに語りましょう この服は三百ドルしました 消える 私は風邪をひきました。なので、映画館に行きませんでした 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 飛行機が二時間遅れました。だから、あそこで怒っている人が多いでしょう 帰ったら、まず手を洗いましょう 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 部分 彼はその詩を用いて自分の気持ちを伝えた 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 国会 変わる 強調 事務的な処理に1週間かかります 用いる より 研究 彼はパーティー会場を提供してくれました 私は風邪をひきました。だから、映画館に行きませんでした 明らか 住宅 バカ！言い訳するな ご飯を食べる人 あの喫茶店が静かあので、あそこで勉強する人が多いでしょう 部分 えっと、電車が遅れたので、遅刻しました 今夜は蒸し暑いから、明日は雨が降るでしょう あの喫茶店は静かですから、あそこでテストの勉強をしましょう 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 病人が元気になる 私は風邪をひきました。なので、明日は学校に行きたくありません 私は部長のことが嫌いです 佐々木さんはサラリーマンではありませんでした 私はゲームソフトを買いました。だから、古いソフトを売りました 今日は何曜日ですか 日本は台湾より寒いです そっか、今度早く家を出ろ 私の趣味は料理を作ることです 台北駅はあそこです 私の趣味は映画を見ることです 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は世界一周をしたくありませんでした 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 飛行機が二時間遅れました。なので、到着時間も遅くなります どうして今日遅刻した 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 飛行機が二時間遅れました。なので、到着時間も遅くないrます 浅い川 何も買いません 飛行機が二時間遅れました。なので、到着時間も遅くなります 飛行機が二時間遅れました。なので、到着時間も遅くなります それはカーテンです 飛行機が二時間遅れました。なので、到着時間も遅くなります 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は味噌汁が全然嫌いではありません 飛行機が二時間遅れました。なので、到着時間も遅くなります 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう 彼は小学校の先生なから、子供の親からのプレッシャーが大きでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります 宮沢さんは課長のことを、どう思いますか どうして麒麟は首が長いですか えっと、電車が送れっましたから、遅刻しました 今夜は蒸し暑いので、蚊が多くなります 広告 烏龍茶 解答 プル レストラン 向日葵 学長 予備校生 どうして麒麟は首が長いですか ボールペン 18 さい どうして麒麟は首が長いですか どうして麒麟は首が長いですか 2019-11-13難しい 彼は足が長い 質問 大学 生きる 送る 知る 私の夫はサラリーマンです 私は去年、フランスへ行った バカ！言い訳するな 消す 来る 場合 何か飲み物が欲しいな バカ、言い訳するな！ 千円貸してください 私はタバコが嫌いです その店の前で会いましょう バカ、言い訳するな 時計を見たら、ちょうど3時だった 彼女は三人の子供の母親だ 多い 彼女は命令に従わなかった 改革 計画を一部変更しましょう 今夜は多い語りましょう 彼は足が長い えっと、電車が遅れたので、遅刻しました 私の夫はサラリーマンです 夢を実現するには、努力が必要です えっと、電車が遅れたので、遅刻しました 消える 私にはたくさんのお金が必要だ よく答えがわかりましたね バカ、言い訳するな バカ、言い訳するな そっか、今度早く家を出ろ 今夜は大いに語りましょう そっか、今度早く家を出ろ 消える えっと、電車が遅れたので、遅刻しました 彼は事故で怪我をしました 試合の相手は誰ですか 目立つ 国会 示す えっと、電車が遅れたので、遅刻しました 彼は就職試験を受けた 彼はロボットの研究をしています そっか、今度早く家を出ろ 対策 先生は討論を始めたがります あの喫茶店は静かですから、あそこでテストの勉強をしましょう 中村さんは昨日夜10時まで仕事をしましたので、残業代をたくさんもらいるでしょう これをください 私の嫌いなことはバスケットをすることです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります そっか、今度早く家を出ろ 私の趣味は本を読むことです どうして今日遅刻した？ えっと、電車が遅れたので、遅刻しました 私の苦手なことは料理を作ることです 私は懐石料理が非常に好きです そっか、今度早く家をでろ 中村さんは昨日夜10時まで仕事しましたから、今日来ませんよね あの喫茶店は静かなので、あそこで勉強する人が多いでしょう 今日は何か買いますか はい、オレンジを買います 今夜は蒸し暑いので、明日は雨が降るでしょう 私は冬が嫌いです 私は懐石料理がとても好きです 今夜は蒸し暑いので、蚊が多くなりました 彼は小学校の先生なので、毎日よじちょうど家に帰ります 川の岸に桜の木があります 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 私は自分の力で仕事を探します えっと、電車が遅れたから遅刻しました テストはいつですか 明日や、明後日や、来週などですね 昨日、何処かに行きましたか はい、コンサートに行きました ゴミ箱にペットボトルがあります あの喫茶店は静かなので、あそこで勉強する人が多いでしょう 病人が元気になる 私は風邪をひきました。だから、明日学校に行きたくありません 動物園のパンダは小さくありません 私は刺身があまり好きではありません 私の趣味は野球をすることです 弟は父の性格がわかります オートバイ 広告 布団 大きな竜巻 剣道 美術館 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 陽傘 フクロウ 物理学 茶髪 新ゲームソフトを買いました。だから、古いスフとを売りました 私は風邪をひきました。だから、明日学校に行きたくありません 病人が元気になる 新ゲームソフトを買いました。だから、古いソフトを売りました 私は風邪をひきました。だから、明日学校に行きたくありません 広告 私は風邪をひきました。だから、明日は学校に行きたくありません 新しいゲームソフトを買いました。だから、古いソフトを売りました 新しいゲームソフトを買いました。だから、古いソフトを売りました 広告 2019-11-12乗る 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 言葉 赤いバラを買いました 彼はまだ若いです 彼は窓側の席に座った 覚える お腹 今夜は蒸し暑いので、蚊が多くなりました 鼻がかゆいです これはかなり金がかかった 髪の毛が伸びたね 答える 時計を見たらちょうど3時だった 大人 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 今夜は蒸し暑いので、蚊が多くなりました 時計を見たら、ちょうど3時だった 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう 彼はとても優しい人です 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 腰 火曜日に会議があります 掛ける 八日からイギリスに行きます 強調 この服は三百ドルしました 合格者が発表された 中村さんは昨日夜10時まで仕事をしましたので、残業代がたくさんもらえるでしょう 宇宙人は存在するとどう思いますか 彼は小さな会社に勤めています 処理 続ける 生まれる 計算 後 今夜は蒸し暑いので、蚊が多くなりました 規模 彼がクラスの代表だ 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 私は四つの会社に投資しています 企業 種類 提供 中村さんは昨日夜10時まで仕事をしましたので、残業代がたくさんもらえるでしょう 今日の新聞どこに置いた 私は納豆が全然好きではありません 今夜は蒸し暑いので、蚊が多くなりました 氷山が小さくなる あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 何も食べません 弟は父の性格がわかります どうして今日遅刻した 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう どうして今日遅刻した？ 何処かに行きましたか いいえ、どこも行きませんでした 中村さんは昨日夜10時まで仕事しましたから、今日は来ませんよね 今夜は蒸し暑いから、明日は雨が降るでしょう 弟は父の性格がわかります どうして今日遅刻した 彼女はマイカーを買いたがります どうして今日遅刻した 誰もいません 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 私の苦手なことは料理を作ることです 夜市はスーパーよりうるさいです あの喫茶店で静かですから、あそこでテストの勉強をしましょう 引き出しにハムスターが一匹います えっと、電車が遅れたから遅刻しました お釣りをください 日曜日が暇です ゲーム機 プール その男の人はフロントで働いている 買い物カート えっと、電車が遅れたから遅刻しました どうして今日遅刻した？ あの喫茶店が静かですから、あそこでテストの勉強をしましょう えっと、電車か遅れたから遅刻しました えっと、電車が遅れたから遅刻しました 2019-11-11勉強 広い カナダの冬はとても寒いです 起きる 考える 起こる 変える 彼はまだ若いです 忘れる あの喫茶店は静かですから、あそこでテストの勉強をしましょう 私たちのチームはその試合で負けた 少し疲れました 少ない １つ 一日 八 土曜日 先月の七日に孫が生まれました あの喫茶店は静かですから、あそこでテストの勉強をしましょう 私の祖母は100歳です この部屋は寒いです 八日からイギリスに行きます 曲がる ご飯 彼が来た目的がわかりません 彼は食品工場で働いています 新聞 彼は小学校の先生ですから、子供の親のプレッシャーが大きでしょう あの喫茶店は静かですから、あそこでテストの勉強をしましょう 計画 この服は三百ドルしました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう あの喫茶店は静かですから、あそこでテストの勉強をしましょう 八日からイギリスに行きます 報告 減る 集める 以上 一緒に対策を考えましょう 今夜は蒸し暑いから、明日は雨が降るでしょう 宇宙人は存在すると思いますか この服は三百ドルしました 加える 姿 備える それはどういう意味ですか 合格者が発表された 彼は事故で怪我をしました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 一部 相手 交差点で事故が発生した 今夜は蒸し暑いですから、明日は雨が降るでしょう 部長を除く全員が土曜日も働いた 商品 変化 中心 音楽は彼の得意な分野です どこが賑やかですか 私の好きなことは音楽を聴くことです 明日、何処かに行きましたか いいえ、何処も行きませんでした 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね 宇宙人は存在すると思いますか 今夜は蒸し暑いから、明日は雨が降るでしょう 合格者が発表された 日曜日が暇です 私の苦手なことは料理を作ることです 私は世界一周をしたくありませんでした 川の岸に桜の木があります 台北駅はどこですか 彼は私の両親に美味しい日本料理をくれました 私は討論を始めたいです 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね 今夜は蒸し暑いですから、明日は雨が降るでしょう 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね 私は苦手なことは料理を作ることです 今日は何曜日ですか 授業をしている教師 みんなは運動会の予定がわかります 氷山が小さくなる 私は彼女のことは好きです インターネットで新幹線の時刻表がわかります 私はあの人のことが嫌いです ご飯を食べる人 犬を飼う あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 私は世界一周をしたかったです 原稿を改訂する 日曜日 屋上 明後日 烏龍茶 蝉 腹部 あの喫茶店は静かなので、あそこで勉強する人が多いでしょう 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね つ 氷山が小さくなる あの喫茶店が静かなので、あそこで勉強する人が多いでしょう あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 2019-11-10彼女はオーエルです 見つける 言葉 かく 病気 次 そう 消す 私はワインが好きです 近く このコートはとても暖かい 左 上を向いて 彼女は三人の子供の母親だ 明日は昼頃から曇るでしょう 彼に会えて嬉しかった ここから富士山がよく見えます よう 私が手伝いましょう 二十日 一杯 後ろ向いて 千円貸してください 小さい花が咲いています 入る 悪い この道をまっすぐ行くと駅です 上る 対象 国は国語教育を強化しています 相手 完成 今年は変化の多い年でしだ 強調 採用 写真はいい思い出になります はげしい雨が降っています 行う 社会 自由 比べる 引越しを業者に頼んだ 繰り返す 外国 先生の隣に父と母がいます レシートをください 私は世界一周をしたくありませんでした どこも行きません 彼女は明日の天気がわかります どれが綺麗ですか テレビを付けました ご飯を食べている人 紙箱に猫がいます 小西さんは映画のチケットをあげましたよね 私は日本料理を作ることがよくできます 私は学生ではありませんでした 何も食べません 今日、何か買いますか？ はい、オレンジを買い明日 私のカバンはどれですか 小林さんは中国語を話すことができます カレンダー 嫌い 自分 故郷 烏龍茶 屋上 買い物カート スーツケースに詰める 私は世界一周をしたくありませんでした 烏龍茶 屋上 2019-11-9学校は8時半に始まります 歌う 飛行機 彼は意外に気が小さい おかげさまで元気です いつ 誰もその話を知らない また会いましょう 変える 子供 言葉 勝つ 部屋 彼はシートベルト締めた 昨日、母と話をしました このコートはとても暖かい 治る 四日 答える 切る よう 彼はその辺に住んでいる 嬉 その子は指で十数えました お願い 来月の二十日は弟の誕生日です 私たちは二階に上がった 残る 写真はいい思い出になります 比べる 報告 計画を一部変更しましょう 販売 強調 企業 その計算は間違っている 言葉 このコートはとても暖かい よう ゴミのリサイクルが普及している かの 住宅 姉夫婦に男の子が生まれました 国会 対策 増える 彼は事故で怪我をしました 彼は選挙に出るつもりだ 処理 話 のじ 方向 夜市はスーパーよりうるさいです どこが賑やかですか 台北駅はどこですか 何も買いません 私の嫌いなことは部屋を掃除することです テレビをつけました どれも要りません 宮沢さんは課長のことを、どう思いますか 日本語を上手にする 私は頑張りたくありませんでした 私は学業を続けたいです 飲み物と言えば、コーラやジュースやお茶などです 期末テストは大変でした 私はあの人のことが嫌いです 私は納豆が全然好きではありません 梅 リング マンション 親切 学長 親戚 大きな竜巻 女性はモモの太さを測っている 雨の後、虹が見られるかもしれません フクロウ 彼女は茶髪で、えくぼがあります かっこいい ぽ 2019-11-8カナダの冬はとても寒いです 国 置く 次 消す 直ぐ 約束を忘れないでください 変える 私たちのチームはその試合で負けた 彼に手紙を書きました 近い いつも 彼女は眠いようです 小さい花が咲いています 教科書を閉じてください 太い 彼女は三人の子供の母親だ 他に方法がありません 金 虹 晴れる お腹が空きました 大人 治る お店はもう閉まっていました 答えが違います 私は4つの会社に投資しています 問題 処理 彼は事故で怪我をしました 対策 商品 輸入 文章 報告 昨年は地震が多い年でした 変える 遅れた理由を教えてください 強調 その事件の犯人はまだ捕まっていない 種類 解決 計画を一部変更しましょう 処理 結果 遅れた理由を教えてください 帰ったら、まず手を洗いましょう 病院 全国 のち 彼は事故で怪我をしました 対策 報告 対立 私の好きなことは音楽です 夜市はスーパーよりうるさいです 何曜日が暇ですか 料理をおいしくする 教室は静かです 動物園のパンダは小さかったです 計画を一部変更しましょう のちに 夜市はスーパーよりうるさいです 私はおばあちゃんのことが好きです ワンピースはスカートより高いです 夜市はどこですか 引き出しにハムスターが一匹います プレで泳ぎます 昨日、どこに行きましたか 昨日、コンサートに行きました スーパーは夜市ほどうるさくありません 一眼レフカメラ 机 クリップ 中学生 陽傘 宝石 緑茶 買い物カートはからです う 2019-11-7生きる 私は体が丈夫だ 消す 肉と魚とどちらが好きですか 去年 くれる 起こす 日曜日は図書館に行きます 授業 郵便局で切手を買いました 走る いう 私たちのチームはその試合で負けた 取る １つ 登る 彼女は三人の子供の母親だ 大人 駅 口 触る 甘い 小さい花は咲いています 企業 変化 なお 方針 仕事がほぼ終わりました 私は４つの会社に投資しています 状態 備える 会長 商品 設計 原因 十分 消す 住宅 政権が交代した 彼は就職試験を受けた 対する 部長除く全員が土曜日の働いた 種類 とち 強調 塩、胡椒加えてください 彼は何年も自身の研究をしている 私たちのチームはその試合で負けた 国会 彼女は三人の子供の母親だ 大人 実現 彼は非常に高い技術を持っている 会談 問題が１つあります 小さい花は咲いています 彼は食品工場で働いています その問題に関する記事を読みました 狭い部屋 ご飯を食べた人 私は４つの会社に投資しています 台北駅はどこですか 商品 私は彼女のことが好きです 夜市は賑やかです 先生は学生の気持ちがわかります 私の趣味は本を読むことです 私は嫌いなことは部屋を掃除することです 種類 どこも行きません 私の好きなことは音楽を聴くことです 強調 今日、何か買いますか いいえ、何も買いません 犬と猫と兎、どれが好きですか 夜市はスーパーよりうるさいで 寝る猫 宮沢さんは課長のことを、どう思いますか 私は日本語が少しでします 私の趣味は料理を作るとこです 私は日本料理を作ることがまあまあできます これは私の小説です 私は懐石料理が一番好きです 私の得意なことはギターを弾くことです 私のカバンはどれですか 私は日本語が大体できます 小説はどれですか 鶴 ノートパソコン 中華料理 折り畳み傘 羊 明日 大学生が教授に質問してい フクロウ 2019-11-6おかげさまで元気です 考える 覚える 色 使う カナダの冬はとても寒いです 狭い 私は朝シャワーを浴びます 教える 漢字は中国から来ました 一日 見つかる 柿の木に実が沢山なっています 腰 直る 彼女は指が細いです 後ろを向いて お願い こっち 泊まる お手洗い 喋る 手紙が届くのに三日かかりました 住宅 病院はどこですか 企業 一般の方はこちらの席へどうぞ とち 開発 段階 国は国語教育を強化しています 参加 強調 まま トラブルがやっと解決した 姿 政治 対象 今後ともよろしくお願いします 作業 評価 それはどういう意味ですか 目立つ 国会 増加 前売券は窓口で販売しています 夢を実現するには努力が必要だ 今回 宮沢さんは課長のことを、どう思いますか 企業 何も買いません 今日は何曜日ですか 昨日、どうかに行きましたか はい、コンサートに行きました ゴミ箱にペットボトルがあります 彼女は飛行機を運転することができます どこが賑やかですか 今日、何か買いますか いいえ、何も買いません 昨日、どこに行きましたか 昨日、コンサートに行きました レシートをください 引き出しにハムスターが一匹います 国会 あなたのカバンはこれです あの人は木に登ることができます 国仲さんはあなたにギターをもらいました テストはいつですか 明日や、明後日や、来週などですね 何も食べません 静かな教室 夜市はどこですか 私はノートパスコンをテレビにする どこが賑やかですか 昨日、何処かに行きましたか いいえ、どこも行きませんでした 誰もいません どれも要りません 今日、何か買いますか はい、オレンジを買います 先生の隣に父と母がいます 飲み物を買いません 私は味噌汁が全然嫌いではありません 教室に学生と先生がいます 梅 簡単 フローリング 大きな竜巻 説明する ゴリラ センチメートル フクロウ 大学生が教授に質問している あごひげ づ フクロウ 2019-11-5九份は賑やかです 親 私位は友たちがたくさんいます 緑 安い 飛行機 一番 春 作る おかげさまで元気です 彼は医者になりました 弱い 昨日タイカレーを食べました カナダの冬はとても寒いです また会いましょう 彼女はいつも元気だ 住む 電車で子供が騒いでいた もう 家 茶色 ある 千円貸してください 彼女は眠いようです 上る 母 これは医者のためのサイトです 九日に荷物が届きます 土曜日 百 優しい 愛する 私の質問に答えてください 曲がる 宿題は自分でやりなさい お願い 閉める 私が手伝いましょう 店員は若い女の人でした 要る 続ける 交渉 彼は食品工場で働いています 彼は選挙にですつもりだ 子供の頃、その公園で遊んだ 競争 工場 変化 内容 強調 おかげさまで元気です カナダの冬はとても寒いです 首相 とし 意見 今年は変化の多い年でした まあ今回は許してあげよう 目立つ 文章 住宅 部長を除く全員が土曜日も働いた 決定 調べる 運動会は9時開始です このビールはあまり美味しくありません 採用 備える お金が十分あります このソフトにはいろいろな機能があります 増加 ここは静かな住宅地だ 経済 語る もう 存在 中心 彼女は同じ間違いを繰り返した 国は国語教育を強化しています 強調 試合の相手は誰ですか 信号が青に変わりました 建設 交差点で事故が発生した 計画 お金がほとんどありません 計算 おかげさまで元気です 住宅 部屋にベッドがあります 私は茶碗蒸しがあまり嫌いではありません 夜市が賑やかです 私は日本語が全然できません 日曜日が暇です 私は自分の力で仕事を探します 引き出しにハムスターが一匹います 大学の先輩は商売ができます 何曜日が暇ですか 台北駅はあそこです ご飯を食べた人 九份は賑やかです 犬は大きかったです 私は懐石料理がとても好きです 昨日、何処かに行きましたか はい、コンサートに行きました どこも行きません ご飯を食べている人 どれも要りません 国は国語教育を強化しています 私の苦手なことは料理を作ることです 床にアリがいます どこが賑やかですか 先生の隣に父と母がいます 誰もいません 本棚に小説と雑誌があります 宮沢さんは課長のとこを、どう思いましか 上手なコック 引き出しにハムスターが一匹います どれが綺麗です 私は日本語があまりでしませ 私はおばあちゃんのことが好きです 彼女を幸せにする 授業をした教師 私はゲームが好きです いつが暇ですか 土曜日か日曜日 私が冬が嫌いです まず、次に、そして、それから、最後に あなたのカバンはこれです 日本語が上手になる 私は懐石料理が非常に好きです 私は彼にノートパソコンをもらいました 先生の隣に父と母がいます 何も食べません 本屋で小説を買います 庭の松は高いです 私は懐石料理がかなり好きです 宮沢さんは課長のことを、どう思いますか あれはカーテンです 母はペットと海外旅行しました 昨日、何処かに行きましたか いいえ、どこも行きませんでした 何も買いません 今日、何か買いますか はい、オレンジを買います 親戚 文房具 大きな竜巻 翻訳する 竹 大人 小説 梅 たつ 中学生 乗客 一眼レフカメラ 校長 香水 陽傘 鶏 ませんでした フルート 虹 せみ ツアーガイド 茶髪 大きな竜巻 梅 づ 2019-11-3うる 紙 立つ 引く 彼は荷物を網棚にあげた 春 息子は飛行機のオモチャが好きです 続く 上を向いて かける 六日前に日本に帰ってきました 冷たい ３つ 私の家は駅の近くです 彼女は眠いようです これはかなり金がかかった 彼はとても楽しい人です 上る 妹は歌が上手です 後ろをいて 備える 進める 今後の方針が決まった 夢を実現するには、努力を必要です トラプルがやっと解決した 彼は食品工場で働いています 上る 備える 今日は自由な時間が多い 彼は小さな会社に勤めています 強化 受ける 示す 増える ドル 帰ったらまず手を洗いましょう 関する 文章 生産 変化 部長を除く全員が土曜日も働いた 彼は選挙にですつもりだ 選挙 生活 彼は新製品に興味を示している 広がる 全国 写真はいい思い出になります 理由 何も食べません あなたは小西さんに映画のチケットをもらいましたよね 彼は食品工場で働いています 備える 台北駅はどこですか 私の趣味は野球をすることです 夜市はどこですか 私は日本語ができます 誰も居ません 昨日、何処かに行きましたか いいえ、どこも行きませんでした 今日、何か買いますか はい、オレンジを買います シャワーを浴びる象 私の嫌いなことはバスケットをすることです 何も買いません どこも行きません 授業をする教師 コンビニに電子レンジがあります 部長を除く全員が土曜日も働いた 私は刺身があまり好きではありません レシートをください 彼は選挙にですつもりだ 犬は大きくありません 私のカバンはどれですか 動物園のパンダは小さくありません どれが綺麗ですか どこが賑やかですか 台北駅はどこですか 冬は暖かくありませんでした 今日、何か買いますか いいえ、何も買いません あのバカは2本の鉛筆を箸にして、ご飯を食べる どれも要りません そく 今日は何曜日ですか 何曜日が暇ですか 犬は大きくありませんでした お釣りをください 日曜日が暇です テストはいつですか 明日や、明後日や、来週などですね 昨日、どこに行きましたか 昨日、コンサートに行きました 親戚 下手 中学生 布 ペットボトル 予備校生 和食 どれも要りません 親戚 2019-11-2読む 待つ 彼女は雑誌を読んでいます 郵便局で切手を買いました 胸 起こる 右 生きる 払う 軽い また会いましょう 入れる お兄さん 喉が渇きました 強い 誰もいません 時計 つける 月曜日に会いましょう 今日は風が強い 姉は大学生です 誰もいません 彼女は眠いようです お願い 教科書を閉じてください 誰もいません 彼女は眠いようです 重要 夢を実現するには努力が必要です 比べる 何も食べません 今の首相はあまり力がない 情報 私たちはその問題を調査しています システムも構成を変えてみました 変化 関係 それはどういう意味ですか 彼は就職試験を受けた なお、雨の場合は中止です 事件 交渉 誰もいません 昨日、何処かに行きましたか いいえ、どこも行きませんでした 私のカバンはどれですか どこも行きません うそ 今日は何曜日ですか ピザを買いました。パスタも買いました 今日、何か買いますか いいえ、何も買いません 私は日本料理を作ることができます 夢を実現するには努力が必要です 何も食べません 寝る猫 変化 何も買いません どれも要りません 昨日、何処かに行きましたか はい、コンサートに行きました 広い部屋 私の苦手なことは料理を作ることです どれも要りません 授業をしている教師 みんなは運動会の予定かわかります 私は部長のことが嫌いです シャワーを浴びる象 誰もいません どれも要りません 今日、何か買いますか はい、オレンジを買います 役所の人はおばあちゃんに綺麗のカレンダーをくれました 何も食べません 台北駅はどこですか 私は懐石料理がかなり好きです 今日、どこに行きましたか コンサートに行きました レシートください あなたのカバンはこれです シャワーを浴びる象 夜市は賑やかです 彼女は明日の天気がわかります 向日葵はくさより綺麗です ゴミ箱にペットボトルがあります 何も食べません レシートください 私の好きなことは音楽です どれも要りません 夜市はどこですか どこが賑やかですか タプレット プール 年齢 ビジネスマン 記憶 校長 皿 かっこいい 雄鶏 栓抜きありますか どれも要りません 2019-11-1呼ぶ 冬 いつも 前の車はとても遅い また会いましょう 送る 宿題は未だ終わっていません 会議は四時に終わります 直ぐ 昨日、何処かに行きましたか いいえ、どこも行きませんでした 腰 左 時計を見たらちょうど3時だった 彼はシートベルト締めた 時の経つのは早い 大人 千円貸してください 五日 今日は、何か買いますか はい、オレンジを買います 今日は頭が痛いです 後ろを向いて 分からない場合は私に聞いてください それはどういう意味ですか 選挙 実現 予定 これからより一層努力します また会いましょう 計算 構成 力 姿 姉夫婦に男の子が生まれました 昨日、何処かに行きましたか いいえ、どこも行きませんでした 目立つ 減る 今日は、何か買いますか いいえ、何も買いません 対する 状態 いえ ここは一方通行です 採用 解決 販売 私は紙で鶴を作りました どこも行きません 私は歌を歌うことができます 夜市はどこですか 私の趣味は映画を見ることです 今日は、何か買いますか はい、オレンジを買います それはどういう意味ですか あなたのカバンはこれです 昨日、どこに行きましたか 昨日、コンサートに行きました 何も買いません どこが賑やかですか 何曜日が暇ですか 私は世界一周をしたくありません 貯金箱にコインが40個あります テストはいつですか 明日や、明後日や、来週などですね 授業をしている教師 運動場で走ります 今日、何か買いますか いいえ、何も買いません 私の好きなことは音楽を聴くことです 昨日、どこかに行きましたか いいえ、どこも行きませんでした 私は料理を作ることができます 台北駅はあそこです どこが賑やかですか 私の苦手なことは料理を作ることです どこも行きません 私は部長のことが嫌いです 私の得意なことはギターを弾くことです 今日、何か買いますか はい、オレンジを買います ゴミ箱にペットボトルがあります どれが綺麗ですか 私は学生ではありません 何も買いません 昨日、何処かに行きましたか はい、コンサートに行きました 日曜日が暇です 昨日、何処かに行きましたか いいえ、どこも行きませんでした ゴミ箱にペットボトルがあります 今日、何か買いますか はい、オレンジを買います 犬は大きくありません インターネットで新幹線の時刻表が分かります レストランの前に看板があります 私は日本語がまあまあできます 今日、何か買いましか いいえ、何も買いません 夜市が賑やかです 私は日本料理を作ることがでします 海 中学生 夜市 どこも行きません 鶏 どこも行きません 今日、何か買いますか いいえ、何も買いません 楓 台風 馬 腹部は、肋とお尻の間の部分です 雨の後、虹が見られるかもしれません こ ぬ 何も買いません どこも行き前ん 何も買いません","link":"/zh-tw/japanese/2019/November/index.html"},{"title":"September 2019","text":"2019-9-30あの歌手は有名です 起こる 彼は背が低い 使う 肩が凝りました 私はワインが好きです 一番 午前 肩 会議は四時に終わります 読む 私は去年フランスへ行った 昼間は電気を消してください お店はもう閉まっていました 私は腕時計を四つ持っています 昨日から腰が痛い 七日 彼は神を信じている これはかなり金がかかった これは医者のためのサイトです 黄色い 九日 柿の木に実が沢山なっています 32ページを開いてください 力 普及 事件 昨日の会議について報告があります 明らか 理由 病院 問題 報告 構造 今回 私は彼から大きな影響受けました 資金 島の人口は年々増加しています いずれ 導入 従来 彼はその詩を用いて自分の気持ちを伝えた 今年は変化の多い年でした システムの構成を変えてみました 都市 話 住宅 変わる 強調 私は彼に使い捨ての箸をあげました 私は彼と彼女に誕生日カードをもらいました 私は日本語が大体できます あなたは私にこのDVDをくれました 母は料理の方法が分かります 彼女を幸せにする 私は親友と遊びたいです 私はあなたにデジタルカメラをもらいました あの屋敷に幽霊がいまし 部長は仕事ができます 一眼レフカメラ 布 動物園 隣人 テレビ 雄鶏 かっこいい 彼女はマーカーを買いたがります かっこいい 2019-9-29私は電車で通学しています まだ会いましょう １ 郵便局で切手を買いました 教える 見つける 肉と魚とどちらが好きですか 親の愛は有難い 週 旅行の日程を変えました 家 電車で子供が騒いでいた 午前 私の部屋は狭いです 置く 学生 飛行機 男の人が私たちに話しかけた 火曜日に会議があります 駅はどこですか 先月の七日に孫が生まれました 有る 私は夏が大好き 喉が渇きました 風邪 切る 時計を見たらちょうど三時だった 服 この曲線がこの車の特徴です 対象 会談の内容が発表されました 住宅 その計算は間違っている 方針 今後の方針が決まった 午前 方向 事務的な処理に一週間かかります 調べる 評価 商品 このソフトで日本語勉強することができます 選挙 彼は何年も地震の研究をしている ガソリンの価格がどんどん上がっている 重要 私は彼から大きな影響受けました 比べる それは最近話題の本ですね 女性 ここは一方通行です 命令 関係 建設 研究 段階 結果 制度 インターネットで新幹線の時刻表が分かります 向日葵は草より綺麗です 引き出しにはハムスターが一匹います 小林さんは中国語を話すことができます 私は日本語大体できます あの屋敷に幽霊がいますよ 全然 そこはどこですか 夏は涼しかったです 母はペットと海外旅行しました 私は彼から大きな影響受けました 簡単な質問 私は泳ぐことができます 乗客 下手 ギター ポルトガル 浅い 学長 サツマイモは焼いても揚げても美味しい ツアーガイド フロント フルート リットル クロサイが草原をありいている あの屋敷は幽霊がいますよう 2019-9-28そこに大きな円を書いて 彼は荷物を網棚に上げた 電車で子供が騒いでいた 彼の日本語のレベルは私と同じくらいだ 髪 工事は三月まで続きます 漢字は中国から来ました 彼は意外に気が小さい 戻る 顔 そう 授業 時の経つのは早い 冷たい ご飯 その子は指で十数えました 強い 私は二日待った この部屋は寒いです 時計を見たらちょうどさんじだた 左 触る 髪の毛が伸びたね 電車で子供が騒いでいた まずい お願い 五日 来る 乾く 首相 受ける 時計を見たらちょうど三時だった 彼は新製品に興味を示している 以上 関する 今後ともよろしくお願いします 自由 それはどういう意味ですか 彼は一人旅の計画を立てた 増える 工場 一部 重要 彼は選挙に出るつもりだ 試合の相手は誰ですか 方向 国は国語教育を強化しています 比べる 消える システムの構成を変えてみました 選挙 皆私たちに期待しています 銀行は三時まで開いています 可能 彼が来た目的がわかりません まあ今回は許してあげよう 輸入 傘をさす 母は料理の方法がわかります 私はサラリーマンです、彼もサラリーマンです みんなは運動会の予定がわかります 重要 あなたは小西さんに映画のチケットをもらいましたよね 運動場で走ります 方向 床に蟻がいます 比べる 部長は仕事ができます 校長 ポルトガル 生まれる 翻訳する ポスター か 熊 烏龍茶 年齢 ツアーガイド 料理を炒める 髭剃り フットボール 買い物カート ツアーガイド 2019-9-27大学に行ってもっと勉強したいです 入れる 図書館で料理の本を借りた 乗る 郵便局で切手を買いました 彼はまだ若いです 私たちのチームはその試合で負けた 帰国することに決めました 送る 誰と会ってみたいですか 探す 病気 喉が渇きました 嬉しい 今週 九日に荷物が届きます 後ろ向いて 上る 来る 口 よう 見つかる 今日はこのホテルに泊まります 柿の木に実が沢山なっています クーラーはまだ直りません 愛する 千円貸してください 付ける 三日 左 他に方法がありません 開ける まま その質問に対する答えが見つからなかった 政権が交代した 一緒に対策を考えましょう 建設 これら 段階 選挙 この段階では決断するのはまだ早いです 社会 立場 会長 残る なお 強化 生産 示す 部長を除く全員が土曜日も働いた 競争 次は全国のお天気です 実現 彼がクラスの代表だ あの服のほうが可愛いです 日本語を上手にする 九份は賑やかではありませんでした 私は日本語がわかります その子供は親友と遊びたがります 左 先生は難しいの本を読むことができます ないでください 動物園のパンダは小さいです 背が高くなる 選挙 深い湖 私は日本語ができます 動物園のパンダは小さかったです ハンバーガーとコーラ あなたの会社は私の会社に統計ソフトウエアをくれました 私は料理を作ることができます すみません、今は何時ですか 私は鉛筆で字を書く 私は日本料理を作ることが全然できません 鶏 社員 スプーン 愛妻弁当 あごひげ 栓抜きありますか スーツケースに詰める む 2019-9-26春 去年 若い 言葉 いつ 難しい 使う かく 郵便局で切手を買いました 言う 近い 狭い 質問のある方はどうぞ 私たちは先月十一日に結婚しました 千円貸してください 強い 要る 大人 悲し 泊まる 喉が渇きました 宿題は自分でやりなさい 桃を五つください 選ぶ 残る 動き お金はまだ十分あります 建設 伴う 部長除く全員が土曜日も働いた 問題が一つあります よく答えが分かりましたね 計画 決定 実現 ゴミのリサイクルが普及している 郵便局で切手を買いました 私は四つの会社に投資しています 段階 経済 電話 関する 地域 なお、雨の場合は中止です 喉が渇きました 試合の相手は誰ですか 交渉 音楽は彼の得意な分野です これから、より一層努力します 残る 調査 一緒に対策を考えましょう 事故 建設 かく 私は日本語はあまりできません お爺さんは昔の記憶を忘れたがります あの歌手は有名でがありません インターネットで新幹線の時刻表が分かります ゲームをしませんでした テストはいつですか 明日や明後日や来週などですね 私は王建民ほど有名ではありません 彼女は飛行機を運転することができます 私は実家に帰りたいです 夏は涼しくありませんでした 弟は父の性格がわかります チケットください レシートをください 父は台湾料理をできます 上野さんは彼女と映画を見ました 冬は暖かかった 私はあの記憶を忘れたいです ニュースで道の状況がわかります 彼女は明日の天気がわかります 小学生 有名 キャベツ 一眼レフカメラ あごひげ 女性がももの太さを計っている 腹部は、肋とお尻の間の部分です を あごひげ 2019-9-25遅い こう 次 安い 知る 部屋 一番 彼は意外に気が小さい 見つかる レストランは空いていました 十日後に帰ります 細い 汚い お母さんによろしくを伝えください 彼は昼過ぎに来ます 治る この道を真っ直ぐ行くと駅です 悪い 一杯 ご主人 お腹が空きますた 私の祖母は100歳です 彼はこの辺に住んでいる 五月五日は祝日です 構成 生活 交渉 彼がクラスの代表だ より 開発 可能 彼は非常に高い技術を持っている 初めて 試合 文章 私たちがその問題を調査しています 良い方法思いつきました 利用 方針 段階 トラブルがやっと解決しだ 遅れた理由を教えてください なお 対する 今日中にこの問題を検討してください 帰ったらまず手を洗いましょう 影響 決定 話 管理 引越しを業者に頼んだ 意見 母は日本料理を作ることができます 期末レポートは大変です 浅い川 日本語が上手になる 貯金箱に40個のコインがあります 傘は長いです 私は日本料理を作ることがよくできます 試合の相手は誰ですか 両親は日本に行きます、私も行きます あの人は木を登ることができます さあ、私もわかりませんね ピザを買いました、パスタも買いました 小林さんは中国を話すことができます お母さんは実家に帰ります レシートをください うそ 美味しいデザート ボタンを押す 教室が静かではありません 彼女は飛行機を運転することができます キャベツ 蚊 辞書 餌 サツマイモは、焼いても揚げても美味しい もも センチメートル 茶髪 2019-9-24取る 彼の日本語のレベルは私と同じ位だ 短い 食べる 今朝は早く家を出ました もっと近くに来てください 病気 立つ 彼は意外に気が小さいい 飛行機 私は二日待った 米 妹 十日後に帰ります 閉まる これは医者のためのサイトです 教科書閉じてください 答えが違います 閉める 店員は若い女の人でした 悲しい 後で電話します 増える 彼がクラスの代表だ 段階 彼は意外に気が小さいい 写真はいい思い出になります 問題 加える 政権が交代した 変わる 資金 集める 前売券は窓口で販売しています 可能 国会 変化 病院 土地 方針 のち 彼がクラスの代表だ 段階 これら 明らかに彼が悪い 調べる ここは静かな住宅地だ 私は世界一周をしたかったです 冬は暖かくありません 彼女はボーリングができます 彼は実家に帰りたがります 彼女を幸せにする あなたの会社は私の会社に統計ソフトウエアをくれました 私は日本語ができます 先生は私に100点くれました 石原さんは彼に防虫スプレーをもらいました 可能 先生は学生の気持ちがわかります 文房具 液晶テレビ 翻訳する たつ 一眼レフカメラ 皿 蚊 雄鶏 私は物理の基礎はしています 教授ガズを説明する フロント 2019-9-23古い 引く 肩 全部 軽い 起こす 勝つ 少し疲れました 一番 使う 持つ 始める 質問 図書館 太い 冷たい ６ 三つ 茶色 野球は九人で人チームです 開く 口 彼に会えて嬉しかった 姉は大学生です 泊まる 彼はシートベルト締めた 宿題は自分でやりなさい 導入 対策 十分 種類 内容 私たちは二階に上がった まま 会談の内容が発表されました 彼はその詩を用いて、自分の気持ちを伝えた 今日の予定教えてください 首相 あまり 完成 我が社の経営はうまくいっています 部分 行う 工場 一部 政権が交代した 経営 仕事がほぼ終わりました 対する 彼は新製品に興味を示している 関係 ここは静かな住宅地だ 今夜は大いに語りましょう 調べる 私は先生と事務室に行きます プールで泳ぎます 私は歌を歌うことができます 私は日本料理を作ることができます 石原さんは彼に防虫スプレーをもらいました 私は日本語がよくできます 元気な子供う 向日葵は草より綺麗です あなたの会社わ私の会社に統計ソフトウエアをくれました ドアを開ける 運動場で走ります 政権が交代した あの人は木に登ることができます ベッドの下にゴキブリがいます 私は日本料理を作ることが大体できます ジーンズを買いましょう 川の岸に桜の木があります 新設の先生 下手 布 期末レポート 大きな竜巻 明後日 暑い 教授が、図を説明する スーツケースに詰める 腹部は肋とお尻の間の部分です フルード 黒犀が草原を歩いている フットボール あなたの会社わ私の会社に統計ソフトウエアをくれました 2019-9-22学校 一番 私は朝シャワーを浴びます 約束を忘れないてください ウエイターを呼びましょう こう小さい字は読めない 学校は8時半に始まります 彼の日本語のレベルは私の同じくらいだ 弱い 私は二日待った 私は絵手伝いましょう お腹 泊まる 宿題が自分でやりなさい 一番 喋る 閉める 晴れる 腰 彼女は眠いようです 神 増える 方針 生まれる 代表 宿題は自分でやりなさい 生活 外国 増加 計算 解決 新聞 首相 開発 私たちは今結婚資金を貯めています 実現 試合の相手は誰ですか 実施 一般 強化 より 特徴 ほとんど 調べる 彼は食品工場で働いています 今後の方針が決まった 建設 開く 変化 私にはたくさんのお金が必要だ 販売 住宅 立場 計画 存在 今回 彼女は同じ間違いを繰り返した なお、雨の場合は中止です いずれ システムの構成を変えてみました 予定 決定 ニュースで道の状況がわかります 私は日本料理を大体できます 私は日本料理作ることがまあまあできます 長い傘 あの屋敷に幽霊がいますよ 彼は学校に来ませんでした 引き出しにハムスターが一匹います 佐々木さんはサラリーマンです 私のノートはどれですか 白い紙を黒くする 川の岸に桜の木があります ご飯を食べましょう 私は会社に行きます 台湾は暑いです 私は日本語が全然できません 私はもっと頑張りたかったです 私は日本料理を作ることがあまりできません 私は日本料理を作ることが全然できません 田舎は都市ほど便利ではありません チケットをください ハンバーガーとコーラ はい、そうです 私は実家に帰りたがります 林さんは私にコンサートのチッケトをくれました 彼は明日の天気がわかります 小林さんの妻は小林さんに愛妻弁当あげました 乗客 鶏 ゲーム機 翻訳する 社員食堂 ゴミ箱 腹部は、肋とお尻の間の部分です サツマイモは、焼いてもあげても美味しい 女性はももの太さを計っている 栓抜きありますか む 2019-9-21生活 なお、雨の場合は中止です 実現 決定 試合の相手は誰ですか 会談 試合の結果早く知りたい 政府 私は日本語がまあまあできます 私は料理を作ることができます 国仲さんは貴方にギターをもらいました それは正方形です 私は世界一周をしたいです 車の後ろに子猫と子犬がいます お元気な子供 貴方は貴方の弟にケーキをあげましたか なお、雨の場合は中止です 日本語を上手にする 私は日本料理を作ることがあまりできません 私は日本料理を作ることができます 先生は私に100点をくれました 私は日本料理を作ることが少しできます 正方形はどれですか 私は日本料理を作ることがまあまあできます 犬と猫と兎、どれが好きですか 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 試合の相手は誰ですか 床に蟻がいます 私は弟と妹と実家に帰りました 調べる ポルトガル 烏龍茶 簡単 翻訳する 隣人 年齢 海外旅行 腹部は肋とお尻の間の部分です 雄鶏 ロブスター センチメートル む う 翻訳する 腹部は、肋とお尻の間の部分です 2019-9-20九份わ賑やかです 肉と魚とどちらが好きですか 知る 国 体 この靴はとても軽い 帰国することに決めました 家に帰ろ 軽い 酒 質問の意味はわかりましたか 今日は日本語の授業があります 見つける 私は友達が沢山います 笑う 飛行機 私は平仮名を全部読めます 時 六つ 私は腕時計を四つ持っています この道を真っ直ぐ行くと駅です 柿の木に実が沢山なっています 時の経つのは早い 書ける 辛い 細い 彼はこの辺に住んでいます 冷たい 他に方法がありません 九日に荷物が届きます 飛行機 彼はこの辺に住んでいます 野球 先 一部 昨年 資金 示す その問題に関する記事を読みます ここは一方通行です 会社 従来 生産 彼は行政を改革したいと思っていあ 資金 帰ったら、まず手を洗いましょう 増える 方針 工場 やる 兄は船の設計をしています彼は就職試験を受けた 問題 株 交渉 一緒に対策を考えもしょ 政権が交代した 強調 商品 評価 変わる 開発 島の人口は年々増加しています 情報 私たちがその問題を調査しています 増える 工場 事務的な処理に1週間かかります 解決した 機能 彼は歌で自分の気持ちを表現した 20キロのダイエットは可能だと 良い方法を思いつきました 今日の予定教えてください 彼はその詩を用いて自分の気持ちを伝えた 私は日本語があまりできません 料理を美味しくする この犬 浅い川 皆に運動会の予定わかります 私は日本料理を作ることが少しできます 私は日本語が全然できません ハンバーガーとコーラ 夏はシズしかったです 先生は学生の気持ちがよくできます 私は日本語が少しできます 深い湖 運動場で走ります 鉛筆で字を書く 私は日本語がよくできます 国内旅行 キャベツ 一眼レフカメラ 皿 子猫眠った センチメートル 雄鶏 私が物理の基礎はしています 良い方法思いつきました フットボール 夜市は賑やかです サツマイモは焼いても揚げても美味しい 教授が図を説明する フロント 栓抜きありますか クロサイが草原を歩いている スーツケースに詰める ぬ い ゆ ぎ ざ ね 2019-9-19サツマイモは焼いても揚げても美味しい 歩く 首 働く 肩 質問のある方はどうぞ 払う 彼に手紙を書きました まだ わかる 直る 八 五日 大好き 今週 お先にどうぞ 私は平仮名を全部読めます 鼻がかゆいです 冷たい 答える これはかなり金がかかった これは医者のためのサイトです 彼には子供が六人います 後ろを向いて 場合 愛する 他に方法がありません 経済 導入 関係 前売券は窓口で販売しています 国は国語教育を強化しています 冷たい はげしい雨が降っています 彼は新製品に興味を示している その問題に関する記事を読みました 消える 一部 政権が交代した 動き ガソリンの価格がどんどん上がっている 変わる 計画 増える 普及 対処 今の首相はあまり力がない 力 トラブルがやっと解決した 信号が青に変わりました 一部 政権が交代した 変わる 問題 増える 政権 報告 結果 ドル 今後ともよろしくお願いします 母はペットと海外旅行しました うそ 私は使い捨ての箸をあげました ハンバーガーとコーラ 方針 私は日本語があまりできません 彼のお父さんは彼に新し腕時計をもらいました 楽し一日 彼女を幸せにする 私は学生でした いつが暇ですか 私は泳ぐことができます 隣の人は私の猫に餌をくれました コーヒーを飲みましょうか 私は貴方にデジタルカメラをくれました 大学の先輩は商売ができます 小西さんは貴方に映画のチケットをあげましたよね 私は討論を始めたいです ハンバーガーとコーラ 大きくなかった お爺さんは昔の記憶を忘れたがります 西洋料理 鶏 一眼レフィカメラ 布 金曜日 文房具 液晶テレビ 映画 タンス フクロウ フットボール フロント 栓抜きありますか 栓抜き 買い物カート 教授が、図を説明する 妹はコップを割った 蝉 十八 葉が落ちます フルート 雄鶏 虹 センチメートル 物理学 説明する 買い物カートはからです フットボール フロント 栓抜きありますか スーツケースに詰める 女性がももの太さを計っている 教授が、図を説明する 私は物理の基礎はしてリマス 鳴いている雄鶏 雄鶏 炒める アリクイ センチメートル コロサイが草原を歩いている 彼女は茶髪でえくぼがあります スーツケースに詰める 私は物理の基礎は知っています 緑色の蝉 ７.９センチメートル センチメートル コロサイが草原を歩いている 2019-9-18親の愛は有難い 出来る 美しい 肩 私は電車で通学しています 質問 彼女は秋に結婚します 入れる 質問のある方はどうぞ 広い 言う 知る 今年 喉が渇きました 四月に大学に入学しました 二つ 何か飲み物が欲しいな 私は昼のドラマを毎日見ます 彼女はとても綺麗だ クーラーはまだ直りません 要る これは医者のためのサイトです 入る お父さんは会社員です 決まる 赤い線を2本引いてください 帰ったら先ず手を洗いましょう 報告 自由 よく答えが分かりましたね 質問のある方はどうぞ 新製品に興味を示している 以上 より システム 銀行は3時まで開いています 住宅 導入 まあ今回は許してあげよう 目たつ 文章 強化 彼はその詩を用いて自分の気持ちを伝えた 企業 これからより一層努力します これは医者のためのサイトです 首相 解決 実現 関係 運動場で走ります 弟は父の性格が分かります 私は石原さんに防虫スプレーをあげました 先生はテストの解答が分かります 教室は静かではありません 遊びましょう 私は日本語が少しできます 短い鉛筆 導入 日本語が上手になる 私は王建民ほど有名ではありません 私は親友と遊びたいです ご飯を食べましょう 烏龍茶 ドラゴン 一眼レフカメラ 土曜日 車の乗客 期末レポート 下手 あっさて 明後日 日本 女性がももの太さを 女性がももの太さを測っている 関係 調味料 料理を炒める 説明する 茶髪 質問する フルート チームでフットボールをしています サツマイモは、焼いても揚げても美味しい サツマイモは、焼いても揚げても美味しい 女性がももの太さを計っている フルート 妹はコップを割った 2019-9-17運動場で走ります あの歌手は有名です 次 聞く 近い 彼は荷物を網棚に上げだ 大学に行ってもっと勉強したいです 立つ 会議は四時に終わります 肩 彼はまだ若いです 作る 私達のチームはその試合で負けた 楽しむ 私は毎朝6時に起きます 決まる 使う 立てる 父 彼女は茶色の靴を履いています 先 柿の木に実がたくさんなっています 金 駅 来る 今夜は月がとても綺麗です 悪い 土曜日 肩 有る この道を真っ直ぐ行くと駅です 知る 喉が渇きました そばにいてください 悲し お金はまだ十分あります 多く 語る 私たちは今、結婚資金を貯めています 交渉 資金 まま 私たちがその問題を調査しています 銀行は3時まで開いています それはどういう意味ですか 計画 女性 採用 このアンケート大学生が対象です 一緒に対策を考えましょう 実現 けれは新製品に興味を示している 銀行は3時まで開いています ここは父の土地です 土地 社会 私たちは二階に上がった 文章 首相 帰ったら先ず手を洗いましょう 強化 今日の新聞どこに置いた 彼はその詩を用いて自分の気持ちを伝えだ お金がほとんどありません 実現 開発 引き出しにハムスターが一匹います 歩きます 首相 私は日本語が大体できます 私は世界一周をしたかったです 彼は学校に来ませんでした 簡単な質問 佐々木さんはサラリーマンです 私は日本料理を作ることがよくできます 机の上に雑誌があります 帰ったら、先ず手を洗いましょう 強化 ご飯を食べましょう 私は頑張りたくありませんでした 石原さんは彼に防虫スプレーをもらいました 彼はその詩を用いて自分の気持ちを伝えた あの屋敷に幽霊がいましよ 浅い川 私は日本語がまあまあできます お爺さんは昔の記憶を忘れたがります 私のノートはどれですか 庭に松があります 小林さんは中国語を話すことができます 愛妻弁当 烏龍茶 乗客 ご飯を食べましょう 皿 烏龍茶 ポルトガル 布団 液晶テレビ 和食 引き出し 隣人 暇 腕時計 一眼レフカメラ 社員食堂 親戚 フライト 解答 スマホ 果物 羊 鶏 涼しい 社長 オフィス 学長 年齢 紙箱 親切 文房具 布 折りたたみ傘 トンネル 竹 カレンダー 上手 一眼レフカメラ 調味料 アリクイ 2019-9-16予約は要りません 八つ 娘は明日九つになります 今日の予定を教えてください 構成 この商品はよく売れている 彼はロボットの研究をしています 計画 命令 中心 重要 話 彼は新製品に興味を示している 一緒に対策を考えましょう 私たちがその問題を調査しています 十分 変化 対する なお 開発 動き 島の人口が年々増加しています この曲線がこの車の特徴です 交渉 その事件の犯人はまだ捕まっていない 彼は社員ですか 九份は賑やかです 私は日本語があまりできません うそ 川の岸に桜の木があります 先生は私に100点をくれました 私は妹と弟と実家に帰りました 計画 ドアをあげました 書店で小説を買う 狭い部屋 私は鉛筆で字を書く 彼は新製品に興味を示している あの服のほうが可愛いです 向日葵は草より綺麗です 台湾は日本より暑いです 一緒に対策を考えましょう ニュースて道の状況がわかります 私たちかその問題を調査しています 開発 交渉 国仲さんは彼にギターをもらいましたよう あの人は字を登ることができます 日本語を上手にする 夏は涼しくありません 猫の方が好きですジュースはコーヒーほど高くありません 深い湖 運動場で走ります 貴方は彼女に期末テストの解答をもらいましたようね インターネットで新幹線の時刻表が分かります 車の後ろに子猫と子犬がいます キマレポート 鶴 中学生 大きな竜巻 うし 乗客 布団 キャベツ 文房具 動物園 布 フライト 下手 虎 手 2019-9-15下手 液晶テレビ 今朝は早く家を出ました 起きる 切る 言う もつ この本はとても面白い 私たちは大きな声で歌いました 鳥が飛んでいます 工事は3月まで続きます 日記 まだ会いましょう 負けた いろ 入れた 送る 言う 入れる 兄 肉と魚とどちらが好きですか 漢字は中国から来ました 私は朝シャワーを浴びます 帰国することに決めました 今年はイタリヤに旅行したい 死ぬ 私が手伝いましょう 強い 万 彼はシートベルト締めた その子は指で十数えました 母 一杯 神 大人 時計を見たらちょうどさん時だった この部屋は寒いです 宿題は自分でやりなさい 彼は時々遅刻します 妻 店員は若い女の人でした この道を真っ直ぐ行くと駅です帰国することに決めました 他に方法がありません 十日後に帰ります ご主人 彼は昼過ぎに来ます 前売券は窓口で販売しています 彼は食品工場で働いています 加える トラブルがやっと解決した 対する 彼かクラスの代表だ 相手 一般 この段階では決断すろのはまだ早いです ポルトガル コンピューター 私はテレビをあまり見ません ほぼ 集める その計算は間違っている 島の人口は年々増加しています 写真はいい思い手になります 関する 引越しを業者に頼んだ 生まれる 国会が再開した 種類 動き 彼は就職試験を受けだ 消える 我が社の経営はうまく行っています これは重要な書類です 病院 彼は非常に高い技術を持っている 音楽は彼の得意な分野です 内容 ポルトガル 状態 システムの構成を変えてみました ここは静かな住宅地だ 住宅 提供 彼は選挙に出るつもりだ 島の人口は年々増加しています 株 それはどういう意味でスカ いずれ この段階です決断するのはまだ早いです 今回 彼女は幸せにするベッドの下にゴキブリがいます 静かな教室 動き 床に蟻がいます 浅い川 2019-9-14社員食堂 見せる 帰る 私の部屋は狭いです こう 見つける 負ける 今朝は早く家を出ました 待つ 疲れました 起こす 生きる 来月の一日は空いていました 社員食堂 わかった人は手を上げてください 来る 不味い 彼女は足が太い 他に方法がありません 九日に荷物が届きます 私の祖母は100歳です 悲し 五日 答が違います 教科書閉じてください 千円貸してください いる 風邪 腰 細い 彼は私の方見ました 方針 完成 この道をまっすぐ行くと駅です 他に方法がありません 国内 会長 制度 強化 この温泉はただです 今後ともよろしくお願いします 仕事がほぼ終わりました 生産 研究 受ける 部分 構成 外国 事務的な処理に1週間かかります 多く 叔母は小さな会社の社長です ガソリンの価格がどんどん上がっている 影響 消える ここは一方通行です 貴方の意見が聞きたいです 前売券は窓口で販売しています フランスの大統領は誰ですか 料理が沢山残りました 存在 評価 全体の80%が完成しました 管理 輸入 トラブルがやっと解決した 強調 彼は私にノートパソコンをくれました ビザを買いました、パスタも買いました 彼女はボーリングができます 佐々木さんはサラリーマンです 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 石原さんは彼に防虫スプレーをもらいました 前売券は窓口で販売しています 教室は静かではありません 私は日本語があまりできません 日本語が上手になる 彼は学校に来ませんでした母はペットと海外旅行しました あの屋敷幽霊がいますよ トラブルがやっと解決した 私のノートはどれですか 夏は涼しかったです 私はもっと頑張りたいです 私は世界一周をしたかったです 犬と猫と兎、どれが好きですか うそ 長い傘 引き出しにハムスターが一匹います 先生は私に１００点をくれました ストップウォッチ 期末レポート 猿 緑茶 文房具 布 キャベツ 隣人 書店 皿 乗客 そば 餌 レンタサイクル 蜘蛛 車の乗客 うそ 解答 年齢 ペットボトル 原稿を改訂する 嫌い ソファ 自転車 一眼レフカメラ 期末レポート 雑誌 文房具 布 キャベツ 大人 彼は行ったり来たりして、とても焦っています 隣人 皿 乗客 年齢 うそ 暇 下手 博物館 カレーライス 海 故郷 一眼レフカメラ マイカー 消しゴム 香水 レタス 牛 液晶テレビ 2019-9-13引き出しにハムスターが一匹います 今年は雨が少ないです 学校は8時半に始まります 彼女からプレゼントをもらいました もう寝よう 祖父が病気になった 弱い 約束を忘れないでください 数 続きます 使う あげる 仕事のあと映画を見た 彼は毎晩3キロ走っています 授業 去年 悲し お店はもう閉まっていました 10日後に帰ります 彼女は眠いようです 男の人が私達に話しかけだ 私は好み性に良く来ます 三つ 夫の服をハンガーにかれた 後ろ向いて 米 来る 私は腕時計を四つ持っています 日本人はお米が大好きです 彼に会えて嬉しかった 悲し 休む いる 3日 時の経つのは早い 酸っぱい 一方 私の両親は昭和生まれです 選挙 部長除く全員がと土曜日も働いた 会談の内容は発表されました 対立 発生 輸入 遠くに彼女の姿が見えた 事件 うんどうかいはくじに開始です 来る これからより一層努力します 建設 強化 病院はどこですか 競争 規模 いる 開発 予定 原因 工場 トラブルがやっと解決した 電話 住宅 彼女は同じ間違いを繰り返した 経済 私は討論を始めたいです 鉛筆は短くありません 強化 カレーライスとオムライス、どちらが美味しですか 石原さんは彼に防虫スプレーをもらいました 私は父と食事をしました 彼は学校に来ませんでした ドアを開ける 皆は運動会の予定が分かります 楽しい一日 彼女は幸せにする 貴方は小西さんに映画のチケットをもらいましたよね トラブルがやっと解決した 料理を美味しいくする 私は学生です その子は親友と遊びただります 私は貴方にデジタルカメラをもらいました 石原さんは彼に防虫スプレーをもらいました 私は彼に使い捨ての箸をあげました 彼は学校に来ませんでした 私は日本語があまりできません 川の岸に桜の木があります 傘を長くありません 彼女は私に新し手帳をくれました 部屋で食べます 私は王建民ほど有名ではありません 私は学業を続きたいです 先生は私に100点をくれました 弟は父の性格がわかります 私は鉛筆で字を書く 彼の父は彼に新し腕時計をもらいました 私にデジタルカメラを 私は日本語があまりできません 先生は私に１００点をくれました 私は親友と遊びたいです このリングをください お爺さんは昔の記憶を忘れただります 楓 机 ロッキングチェア 社員食堂 森 夜市 予備校生 生まれる 中学生 レストラン 着物 紅茶 部長 ペット 課長 校長 宝石 2019-9-12おじいさんは昔の記憶を忘れたがります 九份は賑やかです 約束を忘れないでください 仕事 見る 胸 肉と魚とどちらが好きですか 忘れす 冬 私はワインが好きです 誰 私は去年フランスへ行った 座る 乗る 帰る 授業 20日 鼻 時の経つのははやい 喉が渇きました 強い 今週 お願い 閉める 柿木に実が沢山なっています 先月の7日に孫が生まれました 多分 太い お先にどうぞ 約束を忘れないでください 国は国語教育を強化しています 彼は何年も地震の研究をしている 授業 国内 あの人たちは皆同じ方向見ている お金はまだ十分あります 体重がかなり減りました 経済 私たちは二階に上がった 変わる 以上 のちに 構造 建設 備える 交渉 より 今後ともよろしくお願いします 良く答えが分かりましたね 私は四つの会社に投資しています 目たつ 文章 方法 昭和 普及 それは最近話題の本ですね 問題が一つあります 怪我はもう治るましたか 住宅 用いる 販売 与える 声 皆私たちに期待しています 検討 生活 商品 ただです 庭の中に松があります 簡単な質問 ドアを開ける 佐々木さんはサラリーマンです 深い湖 川の岸に桜の木があります 私は世界一周をしたかったです 学生ではない 日本語が上手になる ニュースで道の状況がわかります 夏は涼しいです 国仲さんは貴方にギターをもらいましたよね 住宅 床に蟻がいます 私は学業続けたいです 私のノートはどれですか この服とあの服、どちらが可愛いですか 運動場で走ります 貴方にプレゼントをあげました 貴方は教師ではありません ドアを開ける 回 期末テストは大変でした 日本語を上手にすろ 私は弟と妹と実家に帰りました ペットを飼いましょうか キマワリは草より綺麗です カバンに香水があります あの屋敷に幽霊がいますよ 九份は賑やかではありません 引き出しにハムスターが一匹います 飲み物を買いません 学食の料理は不味いです、このレストランの料理も不味いでしょ 教室は静かではありません これはなんですか あの人は木を登ることがでします 大学の先輩は商売ができます 本棚に小説と雑誌があります 2019-9-11私は朝シャワーを浴びます 飛行機 春 引く 見つける 彼は数学を教えています 言葉 宿題はまだ終わっていません いつ かく 一緒に たつ 見つかる 口 私はパンよりご飯が好きだ 宿題は自分でやりなさい 私は夏が大好き 野球は九人で人チームです 喋る 先月の7日に孫が生まれました 側 強い 6日前日本に帰ってきました 階段 変化 国会 今後ともよろしくお願いします 報告 競争 生まれる 販売 関する 国内 行う 命令 ここは静かな住宅地だ 語る 一般 導入 パソコン システムの構成を変えてみました 先月の7日に孫が生まれました 強い 東京は日本一大きな都市です 今後ともよろしくお願いします 資金 ガソリンの価格がどんどん上がっている 計算 消える 理由 いるに餌をやった 土地 株 彼はパーティー会場を提供してくれました 決定 傘は長くありません 深い湖 私は頑張りたくありません あのバカは2本の鉛筆を箸にして、ご飯を食べる 母はペットと海外旅行しました お爺さんは昔の記憶を忘れたがります テレビをつけました 国仲さんは貴方にギターをもらいましたよ これは私のコンピューターです 父は台湾料理を作ることができます 私は鉛筆で字を書く 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 先生はテストの解答がわかります 刺身をください プールで泳ぎます 深い湖 私は日本語が大体できます 庭の松は高くありません 九份は賑やかでわありません 2019-9-10あの人は木の登ることができます 日本語が上手になる 教室は静かではありません 彼女を幸せにする 川の岸に桜の木があります あの屋敷に幽霊がいますよう 置く 彼は荷物を網棚に上げた 使う 私たちのチームはその試合で負けた 肉と魚とどちらが好きですか 親の愛入り難い 午前 どれ 大学に行って、もっと勉強したいです 次 彼は郵便局を探していました 取る 消す 軽い 飛ぶ 掛ける 分からない場合は私に聞いてください 私が手伝いましょう 宿題は自分でやりなさい 九日に荷物が届きます クーラーはまだ直りません あの屋敷に幽霊がいますよう 載せる 娘は明日九つになります 晴れる 曇る 悪い 終わり 九日 四月に大学に入学したした 五日 音楽は彼の得意な分野です 都市 昨年 事務的な処理に1週間かかります システムの構成を変えてみました まま 彼は選挙に出るつもりだ それはどういう意味ですか 消える 宿題は自分でやりなさい 彼は食品工場で働いています 参加 女性 部分 彼は就職試験を受けた 彼がクラスの代表だ 加える 結果 彼は行政を改革したいと思っている ガソリンの価格がどんどん上がっている 一般 内容 力 可能 対する 十分 文章 ここは一方通行です システムの構成を変えてみました 佐々木さんは大学生です、私も大学生です 彼女はボーリングができます 消える 床に蟻がいます 私は学生です 楽しい一日 私は鉛筆で字を書く（書きます） 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 私のノートはどれですか ガソリンの価格がどんどん上がっている ペットを飼いましょうう 一般 佐々木さんはサラリーマンです あの服のほうが可愛です 私は世界一周をしたかったです 庭の松は高いです 先生は討論を始めたがります 床に蟻がいます 私にデジタルカメラをくれました アフリカにきりんがいます 私は鉛筆で字を書く 弟は家に帰りました お釣りをください 私は書いた原稿本にする 小林さんは中国語を話すことができます 弟は父の性格がわかります 私のノートはどれですか 母は日本料理ができます 私は彼に使い捨ての箸をあげました","link":"/zh-tw/japanese/2019/September/index.html"},{"title":"February 2020","text":"2020-2-29彼はカバンに手帳を入れた また会いましょう 働く ドア 彼の家はとても広い 耳 私は朝シャワーを浴びます 言う 日本人はお米が大好きです 来る 手伝う 背 その子は指で十数えました いっぱい 見つかる その質問に対する答えが見つからなかった 目的 予定 構成 決定 解決 彼は一人旅の計画を立てた 方針 対する 姉夫婦に男の子が生まれました 私は自分の力で仕事を探します タバコを吸ってはいけません 夜市はどこですか インターネットで新幹線の時刻表がわかります 私は本屋で本を買って、開いて、読む 王さんは彼女にギターを弾いてあげます 彼女は私に新しい手帳をくれました 川の岸に桜の木があります 母は怒っています 法律を破ってはいけません このパソコン、使ってもいいですか いいえ、使ってはいけません 和食と言えば、寿司や味噌汁や天ぷらなどです 明日からは夏休みですが、宿題がいっぱいあります 私の苦手なことは料理を作ることです 何で学校に行くのですか この服とあの服、どちらが可愛いですか 旅行会社の人は家族に海外旅行ビザを申し込んでくれます あの人は木を登ることがですかす そっか、今度家を早く出ろ 森に熊がいます 台風の時に、海辺で遊んではいけません 彼女は英語の先生で、動物園のボランティアです あの塾はパートにチラシを配ってもらいます 生まれる 合格点 書店 宝石 め 何で学校に行くのですか 森に熊がいます 2020-2-28約束を忘れないてください 会議は四時に終わります 起こる 入れる 起こす 短い 木曜日 水曜日がバイトがあります 土曜日 あそこにバステがあります 手伝う 米 場合 五つ クーラーはまだ直りません 小さい これは重要な書類です 国は国語教育を強化しています この本を内容を説明してください 進める 彼は一人旅の計画を立てた 影響 今後ともよろしくお願いします まあ、今回は許してあげよう 引っ越しを業者に頼んだ 今日はこれらの問題について話し合います 特徴 解決 土地 ダムの開発に住民は反対しています 災害に備えて大量の水を買い込んだ 消える あのお爺さんは妹に靴を直してくれます 私は懐石料理がかなり好きです 手伝う どうして今日は遅刻した インターネットで新幹線の時刻表がわかります 寝る猫 自転車とバイクと車、それが便利ですか あの店は高いけれども、全然美味しくありません 彼は一人旅の計画を立てた リビングのソファで寝ました。それで、風邪をひきました 法律を破ってはいけません レストランの前に看板があります ゲームをしません 彼は妻に昼ごはんの弁当を作ってもらいます 昨日、何処かに行きましたか ええい、どこも行きませんでした 母は私に飴を買ってくれます 母は怒っています 私は歩いて、電車に乗って、バスに乗る 解決 なぜ台湾の会社は大学生に雇いたくないのですか インターネットで新幹線の時刻表がわかります そのパソコン使ってもいいですか はい、使ってもいいです 天気が良いありません。それで、海辺で行くのやめました この店の料理は美味しいです。それに、値段もとても安いです 大きて 小さて 広くて 狭くて 法律を破ってはいけません 高野さんは私に英語を教えてくれました 私の部屋は狭くて、暗くて、汚いです 大人 教科書 静か 来月 ドラゴン 水曜日 こんばんは ポルトガル 顎髭 切る 走る 帰る そのボトルには二リットルのコーラが入っている 2020-2-27生きる 母と電話で話しました 買う 米 日曜日は海に行きました 五月五日は祝日です 五つ 側 八日からイギリスに行きます こっち 柿の木に実がたくさんなりました ソフトクリームを二つください 彼はシートベルト締めた 水曜日はバイトがあります 泊まる 手伝う 彼は時々遅刻します 夕食には何を食べたいですか そのデモについて、政府は何もしなかった 受ける 突然、電気が消えた 結果 期待 まあ今回は許してあげよう 発生 対策 米 五つ 生活 もう それは全て事実ですか 電気がついたままですよ お金はまだ十分あります この部分は問題ないです 昨年 あの塾はパートにチラシを配ってもらいます ペットを飼いましょうよう タバコを吸ってはいけませんか いいえ、吸ってもいいです 友達は私に本を買ってくれました 水曜日はバイトがあります 手伝う 最近、雨の日が多いです。それに、台風も二個来ました なぜ大体のお店は試食を置きますか 日本語先生のくせに、日本語で自己紹介することもできません 旅行会社の人は家族に海外旅行のビザを申し込んでくれました このパソコン、使ってもいいですか はい、使ってもいいですよ いつが暇ですか 土曜日か日曜日 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげました カバンに香水があります テレビを付けました。しかし、画面がなかなか出ません 彼女は彼氏に食事代を払ってもらいます タバコを吸ってはいけませんか はい、吸ってはいけません 課長は電話しています ジーンズを買いましょうか 小西さんはあなたに映画のチケットをあげましたよね 今夜は蒸し暑いですから、明日は雨が降るでしょう 電気屋の人は私に新しいテレビを運んでくれました 彼は泳いでいます 私はご飯を食べています 彼は妻に昼ごはんの弁当を作ってもらいます 母は私に飴を買ってくれました えっと、電車が遅れましたので、遅刻しました 私は日本料理を作ることが少しできます 先月私は台湾を旅行しました 私はご飯を食べて、テレビを見て、宿題をする 机 原稿改訂する 美味しい 私は物理の基礎は知っています 葉が落ちます サツマイモ 2020-2-26今朝は早く家を出ました 質問 払う みんなにお菓子をあげましょう 安い 美しい 肩 腰 閉める 駅 食べ物 曲がる 万 治る 突然、電気が消えた 生活 彼は食品工場で働いています 今回 除く 対策 予定 コンピュター 弟は父の性格がわかります あの塾はパートにチラシを配ってもらいます 私は友達に本を買ってもらいます 私はご飯を食べています この店は高いけれども、全然美味しくありません 北川さんはたくさん食べましたが、全然太りません 私は懐石料理がかなり好きです 旅行会社の人は家族に海外旅行のビザを申し込んでくれます みてください スピーチは何時からですか 私あなたにプレゼントをあげましたよね 庭の松は高くありませんでした あれはカーテンです ニュースで道の状況がわかります 中村さんは昨日夜１０時まで仕事をしましたので、残業代がたくさんもらえるでしょう 生活 それで？ どうした 私は宿題をしています 田村さんは林さんに中国語を教えてもらいます 明日の食券をください 食べて みて あげて 寝て 始めて 集めて 忘れて 対策 課長は電話しています 運動場で走ります もう25歳なのに、両親らからお小遣いをもらいます この本、借りてもいいですか いいえ、借りてはいけません 弟は私に部屋を掃除してくれます 待ってくれますか 吸って 買って 言って 打って 待って 立って 切って 帰って 送って 売って 何曜日が暇ですか 旅行会社の人は私にホテルに予約してくれます 彼女は彼氏に食事代を払ってもらいます あの日本料理店は広くて、美味しくて、安いです 王さんは彼女にギターを弾いてあげます 彼は泳いでいます 楓 解答 スプレー 駅弁 布 走る 切る 帰る ㎝ 2020-2-25車 漢字は中国から来ました 酒 近く 病気 見つかる 彼に会えて嬉しかった ハワイは4回目です 触る 教科書を閉じとください 六日前に日本に帰ってきました 5日 その計算は間違っている その問題に関する記事を読みました 変わる 全国 関する 仕事はほぼ終わりました 予定 彼は事故で怪我をしました それは最近話題の本ですね まあ、今回は許してあげよう 変化 写真 今後の方針が決まった この服とあの服、どちらが可愛いですか 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう もう25歳なのに、両親からお小遣いをもらいます 課長は電話しています 彼女は私に新しい手帳をくれました 先生はクラスメートに綺麗な絵本を貸してあげます 私は弟に部屋を掃除してもらいます 電気屋の人は私に新しいテレビを運んでくれます 私はあなたに宿題の答えを教えてあげます あの塾はパートにチラシを配ってもらいます 法律は破ってはいけません 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません なぜ大体のお店は試食を置きますか この車はとんでもなく高いくせに、すぐ故障しました テレビを付けました。しかし、画面がなかなか出ません 役所の人は私たちに道を案内してくれました どこも行きません 参勤、雨の日が多いです。それに、台風もにこ来ました 彼女は彼氏に食事代を払ってもらいました この本、借りてもいいですか 田村さんは林さんに中国語を教えてもらいます 彼は泳いでいます 夜中にギターを弾いてはいけません 母は怒っています ないでください 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 彼の父は彼に新しい腕時計をもらいました 新しパソコンを買いましたが、キーボードがありません 私は宿題をしています 最後に、南東から台北に帰りました あの塾はパートにチラシを配ってもらいます 私は旅行会社の人にホテルを予約してもらいます あなたのカバンはこれです 母は弟にオモチャを買ってあげます 私はサラリーマンで、父親です 明日からは夏休みです。でも、宿題がいっぱいあります 台風の時に、海辺で遊んではいけません 私は本屋で本を買って、開いて、読む あのお爺さんは妹に靴を直してくれます 私は学生ではありません 日本語先生のくせに、日本語で自己紹介することもできません ゴミ箱 マイカー 猿 フライト 駅弁 アリクイが行ったり来たりしている 走る 切る 帰る フットボール そのボトルには二リットルのコーラが入っている あの塾はパートにチラシを配ってもらいます 駅弁 走る 帰る 切る 2020-2-24部屋 私はワインが好きです 今会社に戻ります 肩が凝りました こう 私は電車で通学しています 私たちは来年、家を建てます 素敵な色のセーターですね ウエイターを呼ぶましょう 夏休みももう終わりだ 上る 見つかる 渇く 後ろを向いて これはかなり金がかかった 父 予定 改革 なお 彼は行政を改革したいと思っている 方法 事実 写真はいい思い出になります 彼はその詩を用いて自分の気持ちを伝えた この単語の意味を辞書で調べましょう 与える まあ、今回は許してあげよ ジーンズを買いましょうか 飛行機が二時間遅れました。なので、到着時間に遅くなります うそ 道に迷いました。それで、交番に道を尋ねに行きました 夏なのに、陽明山で雪が降りました パソコンを買いましたが、キーボードがありません 母は弟にオモチャを買ってあげます その塾はパートにチラシを配ってもらいます 見つかる 宿題をしました。それに、明日の授業の予習もしました 予定 あの店は高いけれども、全然美味しくありません 彼は妻に昼ご飯の弁当を作ってもらいます ここの公務員は暇なくせに、文句を言います この本、借りてもいいですか して きて 私はあなたに宿題の答えを教えてあげます 二月に日本を旅行しました。それから、韓国と中国にも行きました バカ！言い訳するな 旅行会社の人は家族に海外旅行のビザを申し込んでくれました まあ、今回は許してあげよ あれは店長のカーテンです お金を振り込んだくせに、商品が全く来ません 夜中にギターを弾いてはいけません 法律を破ってはいけません 先生はクラスメートに綺麗な絵本を貸してあげます 私はご飯を食べています 私の好きなことは音楽です 役所の人は私たちに道を案内してくれます 私あ宿題をしています あの塾はパートにチラシを配ってもらいます どうして台湾の会社は大学生を雇いたくないのですか 高野さんは私に英語を教えてくれました 見つかる ご飯を食べる時に、テレビを見てはいけません なぜ大体のお店は試食を置きますか 私ゲームが好きです 書いて 描いて 続いて 泳いで 課長は電話しています このパソコン、使ってもいいですか いいえ、使ってはいけません 基隆の夜市は有名で、賑やかです 私は部長のことが嫌いです 母は怒っています 田村さんは林さんに中国語を教えてもらいます 彼女は彼氏に食事代を払ってもらいます タバコを吸ってはいけません 彼は泳いでいます 私は頑張りたくありませんでした 彼は運動場で倒れました。そして、三分後救急車が来ました 私はご飯を食べて、テレビを見て、宿題をする 彼女は私に新しい手帳をくれました 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 雨 布団 走る 切る 帰る 栓抜き サツマイモ なぜ大体のお店は試食を置きますか 彼女は彼氏に食事代を払ってもらいます 彼女は私に新しい手帳をくれました 帰る 走る 切る 2020-2-23知る 見せる 授業 見つける 約束を忘れないてください 起きる 食べ物 日 万 嬉しい 財布は机の下にあった 晴れる 一日 何か飲み物が欲しいな 飲み物 閉める 彼は泳いでいます 時計を見たら、ちょうど３時だった 男の人は私に話しかれた 対象 これら 話 影響 彼が文章がとてもうまい ここが建物の中心です 選挙 二十キロのダイエットは可能だと思いますか 彼は泳いでいます 特徴 それは全て事実ですか 完成 予定 母は怒っています 比べる ほぼ 部分 今回 方針 従来 計算 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 宿題をしました。それに、明日の授業の予習もしました 友達は私に本を買ってくれました タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 予定 田村さんは林さんに中国語を教えてもらいます 母は怒っています 法律を破ってはいけません 課長は電話しています 彼女は彼氏に食事代を払ってもらいます アフリカにキリンがいます ドアを開ける ジーンズを買いましょうか 行って 私は宿題をしています 明日からは夏休みだけれども、宿題がいっぱいあります あの喫茶店は静かなので、あそこで勉強する人が多いでしょう あの塾はパートにチラシを配ってもらいます 寮の管理員さんは郵便物をみんなんのメールボックスに入れてあげます 法律を破ってはいけません 課長は電話しています ジーンズを買いましょうか 私の得意なことはギターを弾くことです あの塾はパートにチラシを配ってもらいます 私は弟に部屋を掃除してもらいます タバコを吸ってはいけませんか はい、吸ってはいけません 高野さんは私に英語を教えてくれます お金持ちのくせに、スーパーで散々値切りをしました 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 庭の松は高いです 待って 書いて 見て 食べて して 来て 彼は泳いでいます 夏なのに、要名山で雪が降りました 私はご飯を食べています 次に、桃園で飛行機を見に行きました 彼は妻に昼ごはんの弁当を作っても洗います 私は旅行会社の人にホテルを予約してもらいます あの店の弁当は美味しいのに、４０元もかかりません 基隆の夜市は有名で、賑やかです 貯金箱に40個のコインがあります 法律を破ってはいけません 床に蟻がいます どうしてキリンの首が長いですか 母は怒っています 電気屋の人は私に新しいテレビを運んでくれました 王さんは彼女にギターを弾いてあげます 予備校生 タプレット 虎 宝石 そのボトルには二リットルのコーラが入っている 買い物カートは空です 蝉 ぴ 課長は電話しています 彼は泳いでいます 母は怒っています 課長は電話しています 2020-2-22そう 美しい たつ 親の愛は有り難い 汚い もの道をまっすぐ行くと駅です 入る お店はもう閉まっていました 渇く 万 彼女は彼氏に食事代を払ってもらいます 食べ物 答えが違います 建設 彼はその詩を用いて自分の気持ちを伝えた 政権が交代した 彼女は彼氏に食事代を払ってもらいます それは全て事実ですか それは全て事実ですか 彼女は彼氏に食事代を払ってもらいます ドル 続ける 彼がクラスの代表だ 国は国語教育を強化しています 彼は食品工場で働いています 力 昨年 全体の八十パーセントが完成しました 田村さんは林さんに中国語を教えてもらいます 万 食べ物 引っ越しを業者に頼んだ 段階 首相 中心 従来 交差点で事故が発生した 彼女は彼氏に食事代を払ってもらいます それは全て事実ですか この段階では、決断するのはまだ早い 彼女は彼氏に食事代を払ってもらいます 十分 ほとんど 発生 それは世界最大の船です 王さんは彼女にギターを弾いてあげます あの塾はパートにチラシを配ってもらいます 田村さんは林さんに中国語を教えてもらいます 先生はクラスメートに綺麗な絵本を貸してあげます あの塾はパートにチラシを配ってもらいます ジーンズを買いましょうか 田村さんは林さんに中国語を教えてもらいます あの絵は綺麗です。なのに、誰も買いません あの塾はパートにチラシを配ってもらいます タバコを吸ってはいけませんか はい、吸ってはいけませ あのお爺さんは妹に靴を直してくれます このノートは私のノートです 私はあなたにプレゼントをあげましたよね 都市は田舎より便利です 宿題の答えを教えてあげます 昨日、どこにか行きましたか はい、コンサートに行きました 私はご飯を食べています 私の部屋は小さくて、暗くて、汚いです 母は私に飴を買ってくれます 私は弟に部屋を掃除してもらいます 私は友達に本を買ってもらいます お金持ちのくせに、スーパーで散々値切りをしました 彼女を幸せにする 法律を破ってはいけません 日本、ヨーロッパ、そしてアメリカを旅行しました 私は電気屋の人に新しいテレビを運んてくれます ジーンズを買いましょうか 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 田村さんは林さんに中国語を教えてもらいます あの塾はパートにチラシを配ってもらいます 彼は妻に昼ごはんの弁当を作ってもらいます あの塾はパートにチラシを配ってもらいます 私ご飯を食べています 法律を破ってはいけません どうして台湾の会社は大学生を雇いたくないのですか 電気屋の人は私に新しいテレビを運んでくれます ジーンズを買いましょう 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます あの塾はパートにチラシを配ってもらいます 旅行会社の人は家族に海外旅行のビザを申し込んでくれます あの塾はパートにチラシを配ってもらいます 母は弟にオモチャを買ってあげます 明日からは夏休みだけれども、宿題がいっぱいあります テレビをつけましたけれども、画面がなかなか出ません あの塾はパートにチラシを配ってもらいます 台風の時に、海辺で遊んではいけません タバコを吸ってはいけませんか いいえ、吸ってもいいですよ あの塾はパートにチラシを配ってもらいました 私は旅行会社の人にホテルに予約してもらいます 食べてください 私は電気屋の人は新しいテレビを運んでくれます 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 旅行会社の人は家族に海外旅行のビザを申し込んでもらいます 先生はテストの解答がわかります 私はご飯を食べています この店は高いけれども、全然美味しくありません 夜 梅 合格点 涼しい 皿 私は宿題をしています 蟹 あの塾はパートにチラシを配ってもらいます ティーカップとソーサー あの塾はパートにチラシを配ってもらいます そのボトルには2リットルのコーラが入っている 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私は宿題をしています 私はご飯を食べています 私は宿題をしています そのボトルには二リットルのコーラが入っている 私は宿題をしています 2020-2-21息子は飛行機のオモチャが好きです 会議は四時に終わります 妹は平仮名を全部覚えました 膝に痛みを感じます 約束を忘れないてください 話す 二十日 五日 九つ 日本の食べ物は美味しいです 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます ソフトクリームを二つください 駄目 時 多分 彼は食品工場で働いています 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 今月と先月の売上を比べた その問題関する記事を読みました 備える 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 政権 進める オスモさんは、みんな力持ちだ 状態 変化 彼女は私のスケジュールを管理している 消える 今回 生活 私は友達に本を買ってもらいます どこが賑やかですか 母は弟におもちゃを買ってあげます すみません、今は何時ですか 私はあなたに宿題の答えを教えてあげます タバコを吸ってはいけません 駅の前に新しいコンビニができます。それから、駅の後ろにもコンビニできます 白い紙を黒くする この絵は綺麗なのに、誰も買いません 王さんは彼女にギターを弾いてあげます 彼は食品工場で働いています お客さんは家に来ました 母は私に飴を買ってくれました それで？ ここからどうします 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです 先生はクラスメートに綺麗な絵本を貸してあげます 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 私は友達に本を買ってもらいます 私は友達に本を買ってもらいました この店は高いけれども、全然美味しくありません テレビをつけましたが、画面がなかなか出ません なんで台湾の会社は大学生を雇いなくなりましたか 本棚に小説と雑誌があります 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません この絵が綺麗です。なのに、誰も買いません 私は弟に部屋を掃除してもらいます あの店は高いけれども、全然美味しくありません 私は友達に本を買ってもらいます 役所の人は私たちに道を案内してくれました えっと、電車が遅れたので、遅刻しました 先生は学生の気持ちがわかります 貯金箱に40個のコインがあります 高野さんは私に英語を教えてくれました 私は旅行会社の人にホテルを予約してもらいます 明日の食券をください 電気屋の人は私に新しいテレビを運んでくれます あのおじいさんは妹に靴を直ってくれます なんで台湾の会社は大学生を雇いたくないのですか 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私は弟に部屋を掃除してもらいます あなたは彼女に期末テストの解答をもらいましたよね 彼は妻に昼ご飯の弁当を作ってもらいます 弟は学業を続けたがります 私は自分の力で仕事を探します なるほど、これは正方形ですね それは誰のパソコンですか 夜中にギターを弾いてはいけません 食べる時に、テレビを見てはいけません 書いてくれますか 私は弟に部屋を掃除してくれました あの人は木に登ることができます 弟は父の性格がわかります この本、借りてもいいですか いいえ、借りてはいけません 私は旅行会社の人にホテルを予約してもらいます 私はパソコンで字を打って、インターネットして、印刷する それは彼のジュースです テストはいつですが 明日や明後日や来週なとです 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 彼女は飛行機を運転することができます 乗客 彼は妻に昼ごはんの弁当を作ってもらいます レンタサイクル ポルトガル 妹 書店 私は旅行会社の人にホテルを予約してもらいました 生徒 愛妻弁当 ピザ かっこいい フットボール 脈を取る 茶髪 彼は彼の妻に昼ごはんの弁当を作ってもらいました 私は弟に部屋を掃除してもらいます 私は旅行会社の人にホテルを予約してもらいます 彼は妻に昼ご飯の弁当を作ってもらいました 2020-2-20九份は賑やかです 始める 膝に痛みを感じます 彼女はよく旅行に行きます 約束を忘れないてください 彼女は来月結婚します そこに大きな円を描いて 少ない 続く 私はワイン好きです 旅行会社の人は家族に海外旅行のビザを申し込んでくれます ソフトクリームを二つください 細い お願い 千円貸してください 夕食には何を食べたいですか この書類を書き直してください 強い 違う いつか 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私が手伝いましょう 会社 今回 私は政治に関心がある 国は国語教育を強化しています 今日の新聞どこに置いた 約束を忘れないでください のち 交渉 私はあなたに宿題の答えを教えてあげます あまり お金はまだ十分あります その問題に関する記事を読みました 旅行会社の人は家族に海外旅行のビザを申し込んでくれます いつか 今回 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私はあなたに宿題の答えを教えてあげます 全国 母は弟にオモチャを買ってあげます 影響 国内 なお、雨の場合は中止です 変化 私はあなたにプレゼントをあげましたよ 私は歩いて、電車に乗って、バスに乗る このパソコン、使ってもいいですか。 はい、使ってもいいですよ お金を振り込んだくせに、商品が全く来ません 私は味噌汁が全然嫌いではありません 王さんは彼女にギターを弾いてあげます 待ってくれますか タバコを吸ってはいけません 夜中にギターを弾いてはいけません ご飯を食べる時に、テレビを見てはいけません 王さんは彼女にギターを弾いてあげます 役所の人は私たちに道を案内してくれます あのおじいさんは妹に靴を直してくれます 私はサラリーマンで、父親です 冷蔵庫のケーキ、食べでもいいですか いいえ、食べてはいけません 先生はクラスメートに綺麗な絵本を貸してあげます その問題に関する記事を読みます 母は私に飴を買ってくれます 母は弟にオモチャを買ってあげます 私は風邪をひきました。だから、明日学校に行きたくありません この車はとんでもなく高いくせに、すぐ故障しました 大きて 小さて 広くて 狭くて 道を迷いました。それで、交番に道を尋ねに行きました 彼女は可愛いけれども、わがままな人です あの絵が綺麗なのに、誰も買いません 私はあなたに宿題の答えを教えてあげます 王さんは彼女にギターを弾いてあげます 本棚に小説と雑誌があります あの店は高いけれども、全然美味しくありません 私はパソコンで字を打って、インターネットして、印刷する おじいさんは昔の記憶を忘れたがります あの公園は綺麗で、静かで、有名です 法律を破ってはいけません この店は高いです。ですが、全然美味しくありません 私の趣味は作るとこです 高野さんは私に英語を教えてくれます 母は弟にオモチャを買ってあげます 先生はクラスメートに綺麗な絵本を貸してあげます 庭の松は高かったです 飛行機が二時間遅れました。だから、それで怒っている人は多いでしょう 彼女可愛いですが、わがままな人です 電車やの人は私に新しいテレビを運んでくれます 私は紙で鶴を作りました 王さんは彼女にギターを弾いてあげます この本、借りてもいいですか いいえ、借りてはいけません 私はあなたに宿題の答えを教えてあげます あの店は高いけれども、全然美味しくありません このパソコン、使ってもいいですか いいえ、使ってはいけません 中村さんは昨日夜１０時まで仕事をしましたから、今日は来ませんよね ふーん、それで 先生はクラスメートに綺麗な絵本を貸してあげます 見てくれますか 給料をたくさんもらうくせに、全然仕事をしません 台風の時に、海辺で遊んではいけません 母は弟にオモチャを買ってあげます 弁当 布 宝石 ラーメン アリクイ フットボール 電気屋の人は私に新しいテレビを運んでくれます 王さんは彼女にギターを弾いてあげます 先生はクラスメートに綺麗な絵本を貸してあげます フットボール 電気屋の人は私に新しいテレビを運んでくれます 2020-2-19私はワインが好きです 彼は数学を教えています おこる 死ぬ いつも 美しい グラスの数が足りません 見える 十日後に帰ります 六つ 高野さんは私に英語を教えてくれます 高校生 来月の二十日は弟の誕生日です 方針 今回 高野さんは私に英語を教えてくれます 彼は一人旅の計画を立てた 部長除く全員が土曜日も働いた 影響 彼は選挙に出るつもりだ 電気屋の人は私に新しいテレビを運んでくれます 塩、胡椒加えてください 高野さんは私に英語を教えてくれます 以上 彼はその死を用いて自分の気持ちを伝えた 商品 ガソリンの価格がどんどん上がっている 作業 発生 今後 交渉 音楽は彼の得意な分野です 工場 電気屋の人は私に新しいテレビを運んでくれます 昨年 今回 引っ越しを業者に頼んだ 示す 除く 彼は新製品に興味を示している このパソコン、使ってもいいですか いいえ、使ってはいけません 影響 高野さんは私に英語を教えてくれます この車はとんでもなく高いくせに、すぐ故障します 役所の人は私たちに道を案内してくれます 母は私に飴を買ってくれます ここの公務員は暇なくせに、文句を言います 電気屋の人は私に新しいテレビを運んでくれます 高野さんは私に英語を教えてくれます タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 私はあなたにプレゼントをあげましたよね 役所の人は私たちに道を案内してくれます 上野さんは彼女と映画を見ました 電気屋の人は私に新しいテレビを運んでくれます 明日の食券をください 私はノートパソコンをテレビにする 彼は私の両親に美味しい日本料理をくれました このノートは私のです まず、台北のお寺と夜市に行きました あの公園は綺麗で、静かで、有名です 動物園のパンダは小さかったです 給料をたくさんもらうくせに、全然仕事をしません 役所の人は私たちに道を案内してくれます 法律を破ってはいけません 飛行機が二時間遅れました。なので、到着時間も遅くなります あのお爺さんは妹に靴を直してくれます あのお爺さんは妹に靴を直してくれます 私はあなたにプレゼントをあげましたよね もう25歳なのに、両親からお小遣いをもらいます 役所の人は私たちに道を案内してくれます 私はあなたに誕生日プレゼントをもらいましたよね 夜中にギターを弾いてはいけません 何を食べますか 定食かうどんかラーメンですね 私の部屋は狭くて、暗くて、汚いです 話はここまでです。あ、それから このパソコンを使ってもいいですか はい、使ってもいいですよ タバコを吸ってはいけませんか はい、吸ってはいけません 法律を破ってはいけません 台風の時に、海辺で遊んではいけません 彼女は英語の先生で、動物園のボランティアです この本、借りてもいいですか あの日本料理店は広くて、美味しくて、安いです あのお爺さんは妹に靴を直してくれます ロッキングチェア 大人 あのお爺さんは妹に靴を直してくれます 龍 夜中にギターを弾いてはいけません 解答 ㎝ あのおじいさんは妹に靴を直してくれます 2020-2-18座る 郵便局で切手を買いました 私は朝シャワーを浴びます また会いましょう 会う 私は体が丈夫だ 近い 首 彼の日本語のレベルは私の同じくらいだ 私は電車で通学しています 宿題は自分でやりなさい 教科書を閉じてください 見つかる 左 渇く ある 方針 昨年 国会 発生 理由 備える もう 全国 その計算は間違っている バラには色々な種類があります ほとんど 結果 いずれ その仕事は危険を伴う 多く 待ってくれますか 明日の食券をください タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 夜中にギターを弾いてはいけません 昨日財布をなくしました。それに、傘も電車に忘れました 弟は父の性格がわかります 台風の時に、海辺で遊んではいけません そして、台中で有名な湖の隣のホテルに泊まりました 方針 昨年 スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 発生 飛んで 運で 遊んで 読んで 住んで 死んで えっと、電車が遅れたので、遅刻しました 彼女は英語の先生で、動物園のボランティアです 私は彼女のことが好きです 中村さんは昨日夜１０時まで仕事をしましたので、残業代がたくさんもらえるでしょう あの歌手は有名だけれども、歌が下手です 法律を破ってはいけません 明日の食券をください 夜中にギターを弾いてはいけません 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう タバコを吸ってはいけませんか はい、吸ってはいけません もう朝なのに、なかなか起きる事ができません 北川さんはたくさん食べましたけれども、全然太りません 食べてくれますか 今夜は蒸し暑いですから、明日は雨が降るでしょう タバコを吸ってはいけません 最近、雨の日が多いです。それに、台風も二個来ました 向日葵は草より綺麗です 母は私に飴を買ってくれます ご飯を食べる時に、テレビを見てはいけません 私は日本の神社に参拝しましたよ。あ、それからお守りも買いました 母は私に飴を買ってくれます どうして今日遅刻した 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 見てくれますか 夜中にギターを弾いてはいけません 明日の食券をください 買いてくれますか 貸して 指して 無くして 刺して 出して 戻して 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 宝石 原稿を改訂する 合格点 炒める 物理学 かっこいい男 め 母は私に飴を買ってくれます 母は私に飴を買ってくれます 母は私に飴を買ってくれます 2020-2-17軽い 払う 言う 楽しむ 工事は3月まで続きます 遅い 私は去年フランスへ行った みんなにお菓子をあげましょう 夜中にギターを弾いてはいけません もう 辺 大人 優しい 彼は行政を改革したいと思っている システムの構成を変えてみました 夜中にギターを弾いてはいけません 夜中に弾いてはいけません 全国 引っ越しを業者に頼んだ 対象 バラには色々な種類があります 彼はいいところだけを強調した 母はまだ外国に行ったことがありません それはどういう意味ですか 待ってくれますか これは重要な書類です ただ 彼は非常に高い技術を持っている 待ってくれますか 国は国語教育を強化しています あの店は高いです。ですが、全然美味しくありません この車はとんでもなく高いくせに、すぐ故障します 書いてくれますか あの服のほうか可愛いです ご飯を食べる時に、テレビを見てはいけません 庭の松は高いです 明日からは夏休みです。でも、宿題がいっぱいあります 全国 夜中にギターを弾いてはいけません 私は歩いて、電車に乗って、バスに乗る 見てくれますか 夜中に、ギターを弾いてはいけません 台風の時に、海辺で遊んではいけません 法律を破ってはいけません 私は本屋で本を買って、開くて、読む まず、台北のお寺と夜市に行きました 私はフォークでパスタを食べました 私の部屋は小さいくて、暗くて、汚いです 食べてくれますか この本、借りてもいいですか いいえ、借りてはいけません 待ってくれますか 国仲さんはあなたにギターをもらいました 私は日本料理を作ることができます 私は自分の力で仕事を探します 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです タバコを吸ってはいけませんか はい、吸ってはいけません 書いてくれますか 目覚しとけいをかけたのに、なかなか鳴りません あの店の弁当は美味しいのに、40元もかかりません 台風の時に、海辺で遊んではいけません 見てくれますか 法律を破ってはいけません 先生の隣に父と母がいます タバコを吸ってはいけません いつが暇ですか 土曜日か日曜日です 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません ニュースで道の状況がわかります 食べてくれますか 私ご飯を食べて、テレビを見て、宿題をする タバコを吸ってはいけませんか はい、吸ってはいけません このパソコン、使ってもいいですか いいえ、使ってはいけません このパソコン、使ってもいいですか はい、使ってもいいですよ 今夜は蒸し暑いから、明日は雨が降るでしょう 中村さんは昨日夜１０時まで仕事をしましたから、今日は来ませんよね 私はサラリーマンで、父親です 待ってください 書いてください 見てください 食べてください してください 来てください えっと、電車か遅れ他ので、遅刻しました 弟は父の性格がわかります タバコを吸ってはいけませんか はい、吸ってはいけません タバコを吸ってはいけませんか いいえ、吸ってもいいですよ あの歌手は有名だけれども、歌が下手です 基隆の夜市は有名で、賑やかです キャベツ 宝石 使い捨て 屋上 合格点 原稿を改訂する プルトガル タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 炒める タバコを吸ってはいけませんか はい、吸ってはいけません えっと、電車が遅れましたので、遅刻しました 弟は父の性格がわかります タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 宝石 合格点 タバコを吸ってはいけませんか イエイ、吸ってもいいですよ 2020-2-16私が払いましょう 教える 短い ドアを開けてください 私はワインが好きです 建てる 気 私は二日待った 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません 茶色 渇く 四日 ソフトクリームを二つください この道をまっすぐ行くと駅です 閉める 多分 タバコを吸ってはいけません 九つ ない 財布は机の下にあった 強調 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 話 仕事を続けください みんな私たちに期待しています 内容 トラブルがやっと解決した お金はまだ十分あります タバコを吸ってはいけません いい方法思いつきました 問題 災害に備えて大量の水を買い込んだ 外国 彼はその詩を用いて自分の気持ちを伝えた この服は三百ドルしました 法律を破ってはいけません 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません 写真はいい思い手になります 法律を破ってはいけまあせん 解決 法律を破ってはいけません 変化 タバコを吸ってはいけません 法律を破ってはいけません 階段 私は書店で本を買って、開くて、読む 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 私は日本語が全然できません 台風の時に、海辺で遊んではいけません 台風の時に、海辺で遊んではいかません タバコを吸ってはいかません 私はサラリーマンで、父親です それで、これからどうします 日本、ヨーロッパ、そしてアメリカを旅行しました 台風の時に、海辺で遊んではいけません あの公園は綺麗で、静かで、有名です 私はパソコンで字を打って、インターネットして、印刷する うそ この本、借りてもいいですか 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ そのパソコン、使ってもいいですか はい、使ってもいいですよ 台風の時に、海辺で遊んではいけません 寂しい人 この本、借りてもいいですか いいえ、借りてはいけません 法律を破ってはいけません 図書館に本とパソコンがあります あの車は この車はとんでもなく高いくせに、すぐ故障します 法律を破ってはいけません このパソコン、使ってもいいですか いいえ、使ってはいけません して きて 大きくて 小さくて 広くて 狭くて テレビをつけましたけれども、画面がなかなか出ません 基隆の夜市は有名で、賑やかです ご飯を食べる時に、テレビを見てはいけません もう25歳なのに、両親からお小遣いをもらいます 歩く あなたは彼女に期末テストの解答をもらいましよね 台風の時に、海辺で遊んではいけません ご飯を食べる時に、テレビを見てはいけません たつ 課長 羊 布 博物館 ご飯を食べる時に、テレビを見てはいけません 台風の時に、海辺で遊んではいけません この車はとんでもなく高いくせに、すぐ故障します ご飯を食べる時に、テレビを見てはいけません あの車はとんでもなく高いくせに、すぐ故障します ご飯を食べる時に、テレビを見てはいけません 2020-2-15短い 探す 今年 右 早い 出る 赤いバラを買いました 気持ち 上る はい、借りてもいいですよ 空く 細い ご主人はお元気ですか 女 開ける 休む 男の人が私たちに話しかけた 手紙が届くのに三日かかりました このパソコン、使ってもいいですか はい、使ってもいいですよ 渇く 曲がる 力 帰ったら、まず手を洗いましょう お金はまだ十分あります 対象 可能 建設 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 外国 変化 国は国語教育を強化しています 計算 住宅 彼は事故で怪我をしました 多く 計画を一部変更しましょう この本、借りてもいいですか これら 対する 国会 彼は行政を改革したいと思っている テレビをつけました。しかし、画面がなかなか出ません はい、借りてもいいですよ このパソコン、使ってもいいですか はい、使ってもいいですよ お金はまだ十分あります 変化 私んは自分の力で仕事を探しました 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ あの絵は綺麗なのに、誰も買いません 和食と言えば、寿司や味噌汁や天ぷらなどです 私の得意なことはギターを弾くことです この本、借りてもいいですか いいえ、借りてはいけません 彼女は英語の先生で、動物園のボランティアです 私はパソコンで、字を打って、インターネットして、印刷する この本、借りてもいいですか いいえ、借りてはいけません なんでこんな時間に学校にいないのですか 私は日本料理が好きです 私の部屋は狭くて、暗くて、汚いです もう25歳なのに、両親からお小遣いをもらいます この本、借りてもいいですか 私はご飯を食べて、テレビを見て、宿題をする もう朝なのに、なかなか起きることができません 変化 このパソコン、使ってもいいですか いいえ、使ってはいけません 引き出しにハムスターが一匹います それから、台中の有名な湖の隣のホテルに泊まりました あの日本料理店は広くて、美味しくて、安いです 食べて 見て 開けて 寝て 始めて 忘れて 集めて 私はピーマンが嫌いです あの店の料理は美味しいです。それに、値段も安いです 友達は朝９時に家にきました。そhして、夜６時にみんなに帰りました この本、借りてもいいですか いいえ、カリではいけません パソコンを買いましたけれども、キーボードがありません 林さんは私にコンサートのチケットをくれました 待って 書いて 見て 食べて して 来て 小林さんは中国語を話すことができます あの公園は綺麗で、静かで、有名です このパソコン、使ってもいいですか はい、使ってもいいですよ 石原さんは彼に防虫スプレーをもらいました このパソコン、使ってもいいですか いいえ、使ってはいけません 飛行機は二時間遅れました。なので、到着時間も遅くなります 布 紙粘土 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです ポルトガル 解答 湖 教科書 メロン この本、借りてもいいですか ええい、借りてはいけません 雨の後、虹が見られるかもhしれません 虹 栓抜き 蝉 そのパソコン、使ってもいいですか いいえ、使ってはいけません このパソコン、使ってもいいですか はい、使ってもいいですよ 布 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ この本、借りてもいいですか いいえ、借りてはいけません このパソコン、使ってもいいですか いいえ、使ってはいけません 2020-2-14電車 兄は水泳が得意です 狭い 起こす 多い 送る 私はワインが好きです 四月に大学に入学しました ハワイは4回目です お母さんによろしくを伝えください 夕食には何を食べたいですか 彼女は茶色の靴履いています 道 見つかる お腹 渇く 国は国語教育を強化しています 引っ越しを業者に頼んだ 調査 株 会談 行う 競争 与える 種類 自由 待ってください 書いてください 見てください 食べてください して下さい 来て下さい 話 彼はその詩を用いて自分の気持ちを伝えた 前売券は窓口で販売しています 強化 北川さんはたくさん食べましたけれども、全然太りません あの公園は綺麗で、静かで、有名です 私はサラリーマンで、父親です お金持ちのくせに、スーパーで散々値切りをしました 彼女は英語の先生で、動物園のボランティアです 明日からは夏休みです。でも、宿題がいっぱいあります 二月に日本を旅行しました。それから、韓国と中国にも行きました もう25歳なのに、両親からお小遣いももらいます 渇く 国は国語教育を強化しています 本棚に小説と雑誌があります 私は歩いて、電車に乗って、バスに乗る 基隆の夜市は有名で、賑やかです 明日からは夏休みですが、宿題がいっぱいあります 道に迷いました。それで、交番に道を尋ねに行きました あの日本料理店は広くて、美味しくて、安いです テレビをつけましたが、画面がなかなかでません 私の部屋は狭くて、暗くて、汚いです 私は料理を作ることができます 部屋でご飯を食べる 待ってください 書いてください 見てください 食べてください してください 来てください この本、借りてもいいですか この本、借りてもいいですか 私はパソコンで字を打った、インターネットして、印刷する 大きくて 小さくて 広くて 狭くて この服とあの服、どちらが可愛いですか 書いて 描いて 続いて 泳いで もう25歳なのに、両親からお小遣いももらいます パソコンを買いましたけれども、キーボードがありません 天気を良くありません、それで、海に行くのをやめました 私は自分の力で仕事を探します 飛行機を二時間遅れました。なので、到着時間も遅くなります 買って 言って 打って 待って 立って 切って 帰って 送って 売って 彼女は可愛いだれども、わがままな人です 都市は田舎より便利です 台南に遊びに行きました。そして、美味しいものをたくさん食べました 行って ポルトガル 着物 乗客 冷蔵庫 書店 この本、借りてもいいですか 解答 大きいな竜巻 買い物カートはからです ツアーガイドはあなたの旅行を楽しくする興味深い情報知っているだろう この本、借りてもいいですか 私は自分の力で仕事を探します 飛行機が二時間遅れました。それで、到着時間も遅くなります ポルトガル この本、借りてもいいですか 解答 2020-2-13私たちのチームはその試合で負けた 高い 彼は足が長い 起こる 彼はまだ若いです 古い 美し 私はワインが好きです おかげさまで元気です 私には友達がたくさんいます 喋る あの公園は綺麗で、静かで、有名です あそこ この道を真っ直ぐ行くと駅です 触る 酸っぱい 九つ 何 金曜日の夜は友達と出かけます 銀行は３時まで開いています 建設 受付でプログラムを受け取った この曲線がこの車の特徴です 大きくて 小さくて 広くて 狭くて 彼はその詩を用いて自分の気持ちを伝えた 話 留学してから私の世界が広がった 私は一人旅の計画を立てた 引っ越しを業者に頼んだ 対立 変わる 私はサラリーマンで、父親です 私はワインが好きです 日本の神社に参拝しましたよ。あ、それから、御守りも買いました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました あの日本料理店は広くて、美味しくて、安いです 台南に遊びに行きました。そして、美味しいものをたくさん食べました あの公園は綺麗で、静かで、有名です 飛行機が二時間遅れました。なので、到着時間も遅くなります 北川さんはたくさん食べますが、全然太りません 目覚し時計をかけたのに、なかなか鳴りません 大きくて 小さくて 広くて 狭くて 日本、ヨーロッパ、そしてアメリカを旅行しました 私は魚が嫌いです 彼女は英語先生で、動物園のボランティアです 彼はその詩を用いて自分の気持ちを伝えた 彼は運動場で倒れました。そして、三分後救急車が来ました 引っ越しを業者に頼んだ ゲームをした 日本語先生のくせに、日本語で自己紹介することもできません 私はパソコンで字を打って、インターネットして、印刷する 私は本屋で本を買って、開いて、読む 何曜日が暇ですか 彼女は可愛いですが、わがままな人です あの日本料理店は広くて、美味しくて、安いです テレビをつけました。しかし、画面がなかなかでません 天気が良くありません。それで、海に行くのをやめました。 飛行機が二時間遅れました。なので、到着時間も遅くなります どうして今日は遅刻した 私の部屋は狭くて、暗くて、汚いです 私の嫌いなことは部屋を掃除することです 私はご飯を食べて、テレビを見て、宿題をする 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 私の部屋は狭くて、暗くて、汚いです あの歌手は有名です あの絵が綺麗なのに、誰も買いません あの絵が綺麗です。なのに、誰も買いません 私の部屋は狭くて、暗くて、汚いです 中村さんは昨日夜１０時まで仕事をしましたので、残業代がたくさんもらえるでしょう 私の部屋は狭くて、暗くて、汚いです 基隆の夜市は有名で、賑やかです 私パソコンで字を打って、インターネットして、印刷する 飛んで 運で 遊んで 読んで 住んで 死んで 私はありいて、電車に乗って、バスに乗る 昨日、どこに行きましたか コンサートに行きました あなたは私にデジタルカメラをくれました 庭の松は高いです ふーん、それで 明日からは夏休みだけれども、宿題がいっぱいあります 道を迷いでした。それで、交番に道を尋ねに行きました 液晶テレビ その男の人は満足している 調味料 あの公園は綺麗で、静かで、有名です あの日本料理店は広くて、美味しくて、安いです 私の部屋は狭くて、暗くて、汚いです 私の部屋は狭くて、暗くて、汚いです あの日本料理店は広くて、美味しくて、安いです あの公園は綺麗で、静かで、有名です 私の部屋は狭くて、暗くて、汚いです 2020-2-12飛行機 右のポケットにハンカチが入っています 一つ 払う 鼻が痒いです 入る 暖かい この道を真っ直ぐ行くと駅です 掛ける 私はパソコンで字を打って、インターネットして、印刷する つける 一日 彼女は眠いようです 来る 愛する 教科書を閉じてください 私はパソコンで字を打って、インターネットして、印刷する 彼に会えて、嬉しかった ソフトクリームを二つください これはかなり金がかかった 先月の七日に孫が生まれました 私はパソコンで字を打って、インターネットして、印刷する 話 決定 方針 増える 彼女は同じ間違いを繰り返した 彼は行政を改革したいと思っている 私はサラリーマンで、父です のちに彼は総理大臣になりました 二社は互いに競争しています ダムの開発に住民は反対しています 私はサラいーマンで、父親です この道を真っ直ぐ行くと駅です 私は学生ではありません 彼女は英語の先生で、動物園のボランティアです 彼は運動場で倒れました。そして、三分後救急車が来ました 彼女は英語の先生で、動物園のボランティアです この絵が綺麗です。なのに、誰も買いません 庭の松は高いです 私はパソコンで字を打って、インターネットして、印刷する ニュースで道を状況がわかります 話 それで、どうした 今夜は蒸し暑いですから、明日は雨が降るでしょう 私はパソコンで字を打って、インターネットして、印刷する 私はご飯を食べて、テレビを見て、宿題をする 私は歩いて、電車に乗って、バスを乗る 私は先月台湾を旅行しました 基隆の夜市は有名で、賑やかです 私は紙で鶴を作りました 日本語の先生のくせに、日本語で自己紹介することもできません あの絵が綺麗なのに、誰も買いません 私はサラリーマンで、父親です 私はサラリーマンで、父親です ないでください 私は本屋で本を買って、開いて、読む 彼女は英語の先生で、動物園のボランティアです 庭の松は高いです 彼女は英語の先生で、動物園のボランティアです あのバカは二本の鉛筆を箸にして、ご飯を食べる 私は日本の神社に参拝しましたよ。あ、それから、お守りも買いました して 来て 日本、ヨーロッパ、そしてアメリカを旅行しました お金を振り込んだくせに、商品が全く来ません 貸して 指して 無くして 刺して 出して 戻して 基隆の夜市は有名で、賑やかです あの絵が綺麗なのに、誰も買いません 先生は私に100点をくれました 基隆の夜市は有名で、賑やかです 喫茶店で教科書を読みます 明日からは夏休みですが、宿題がいっぱいあります それから、南投の有名な牧場に遊びに行きました 私はサラリーマンで、父親です 期末レポート 一眼レフカメラ 緑茶 大人 原稿を改訂する 彼女は英語の先生で、動物園のボランティアです 日本、ヨーロッパ、そしてアメリカを旅行しました 基隆の夜市は有名で、賑やかです 2020-2-11飲む 質問のある方はどうぞ 兄 うちに帰ろ 緑 その次の週は空いていますか 私は朝シャワーを浴びます 弱い みんなにお菓子をあげましょう ウエイターを呼びましょう 僕 渇く 悪い 平仮名 目 九つ これは医者のためのサイトです 私はご飯を食べて、テレビを見て、宿題をする 七日 閉める これは医者のためのサイトでづ 見つかる 今晩のパーテイーは何時からですか 彼女は三人の子供の母親だ 神 強調 私は歩いて、電車に乗って、バスに乗る その質問に対する答えが見つからなかった 方向 一方 彼女は自分の立場をわかっていない 内容 彼は事故で怪我をしました この携帯電話が使えるのは国内だけです まず相手の動きを見ましょう 私は本屋で本を買って、開いて、読む 一緒に対策を考えましょう して きて 私にはたくさんのお金が必要だ 前売券は窓口で販売しています 彼は選挙に出るつもりだ 交差点で事故が発生した もう 私はご飯を食べて、テレビを見て、宿題をする 最近雨の日が多いでしょう。それに、台風が二個をきました 私は頑張りたくありません 食べて 見て 開けて 寝て 始めて 集めて 忘れて お金持ちのくせに、スーパーで散々値切りをしました 私は歩いて、電車に乗って、バスに乗る 日本、ヨーロッパ、そしてアメリカを旅行しました 給料をたくさんもらうくせに、全然仕事をしません コーヒーショップで教科書を読む 私はご飯を食べて、テレビを見て、宿題をする 行って それ店は高いですが、全然美味しくありません 夏なのに、陽明山で雪が降ります うそ あの歌手は有名だけれども、歌を下手です それから、南投の有名な牧場に遊びに行きました 私は本屋で本を買って、開いて、読む 私は歩いて、電車に乗って、バスに乗る 次に、桃園で飛行機を見に行きました ここの公務員は暇なくせに、文句を言います 餌 暑い 火曜日 期末レポート デスクトップパソコン 体育館 私は本屋で本を買って、開いて、読む フクロウ 脈を取る 蟹 茶髪 私はご飯を食べて、テレビを見て、宿題をする 私は歩いて、電車に乗って、バスに乗る 私は本屋で本を買って、開いて、読む 2020-2-10切る 足 好き 軽い 美し 九つ 辛い よやくはいりません 曲がる 明日は昼頃から曇るでしょう ソフトクリームを二つください 彼女は三人の子供の母親だ 決まる 見つかる 入る 比べる 受付でプログラムを受け取った 資金 全体のは八十パーセントが完成しました 結果 経済 彼は一人旅の計画を立てた 彼は事故で怪我をしました 夏なのに、陽明山で雪が降りました お金を振り込んだくせに、商品が全く来ません 最後に、南東から台北に来ました お金持ちのくせに、スーパーで散々値切りをしました 九つ ボタンを押す 私の得意なことはギターを弾くことです 彼は小学校の先生なので、毎日四時ちょうどに帰ります 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 行って この店は高いですが、全然美味しくありません テレビをつけました。しかし、画面がなかなか出ません 期末テストは大変です どうして今日遅刻した 浅い川 小林さんの妻は小林さんに愛妻弁当をあげました 駅の前に新しいコンビニがてきました。それから、駅の後ろにもコンビニができました 彼は事故で怪我をしました 明日からは夏休みです。でも、宿題がいっぱいあります あの店の弁当は美味しいのに、４０元もかかりません 私日本語ができます 何を食べたいですか 定食かうどんかラーメンですね 都市は田舎より便利です それで、これからどうします この車はとんでもなく高いくせに、すぐ故障します 書店 原稿改訂する 広告 嫌い フロント 私は物理の基礎は知っています 行って 2020-2-9今朝は早く家を出ました 私は窓側の席に座った 払う どう 美し 置く 彼女はイタリア語ができます 妹は平仮名を全部覚えました いう 手伝う 見つかる ソフトクリームを二つください 男の人が私たちに話しかけた 渇く 私はパンよりご飯が好きだ 夕食には何を食べたいですか 夏休みももう終わりだ 新しいテーブルを買いました 評価 今後ともよろしくお願いします 彼女の大きな帽子はとても目立つ 信号が青に変わりました 作業 普及 力 建設 写真はいい思い出になります 今夜は大いに語りましょう 彼は一人旅の計画を立てた 集める 彼は行政を改革したいと思っている 災害備えて、大量の水を買い込んだ お爺さんは昔の記憶を忘れたがります 美しい 私はあの記憶を忘れたいです 明日からは夏休みだけれども、宿題がいっぱいあります 給料をたくさんもらうくせに、全然仕事をしません 私は日本の神社に参拝しました。な、それから、お守りも買いました 昨日財布を無くしました。それに、傘も電車に忘れました ソフトクリーム二つください ここの公務員は暇なくせに、文句を言います この絵は綺麗なのに、誰も買いません 北川さんはたくさん食べますが、全然太りません 道を迷いました。それで、交番に道を尋ねに行きました あの店は高いです。ですが、全然美味しくありません 彼は小学校の先生ですから、子供の両親からのプレッシャーが多いでしょう 中村さんは昨日１０時まで仕事しましたので、残業代がたくさんもらえるでしょう この店は高いけれども、全然美味しくありません テレビをつけました。しかし、画面がなかなか出ません どうして今日遅刻した 彼は一人旅の計画を立てた お客さんは家に来ました あの絵は綺麗です。なのに、誰も買いません 飛行機が二時間遅れました。なので、到着時間も遅くなります あの車はとんでもなく高いくせに、すぐ故障しました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう テレビをつけましたけれども、画面がなかなか出ません 日本、ヨーロッパ、そしてアメリカに旅行しました パソコンお買いましたが、キーボードがありません すみません、今は何時ですか 明日からは夏休みです。でも、宿題がいっぱいあります 二月に日本を旅行しました。それから、韓国と中国にも行きました 話はここまでです。な、それから もう25歳なのに、両親からお小遣いをもらいます 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 都市は田舎より便利です 机 どうして今日遅刻した 原稿を改訂する ペットボトル 書店 高校生 タプレット カニが浜辺を歩いている 雄鶏 都市は田舎より便利です 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 原稿を改訂する 書店 2020-2-8電車で子供が騒いでいた 電車で子供が騒いでいた 言う 祖父が病気になった 肩 起こる また会いましょう みんなにお菓子をあげましょう 払う 会う 色 太い 教科書を閉じてください 見つかる 答えが違います 二 あの家には時計が八つあります ハワイは4回目です ちゃんとドアを閉めてよう 彼は私の上司です 悲しい 国内 今夜は大いに語りましょう 計算 文章 これら 選挙 最近、株を始めました バラには色々な種類があります これは重要な書類です 彼がクラスの代表だ 犬に餌をやった 彼女は明日の天気がわかります あの歌手は有名けれども、歌が下手です 中村さんは昨日夜１０時まで仕事しましたので、残業代がたくさんもらえるでしょう 払う みつかる 中村さんは昨日夜１０時まで仕事しましたので、残業代がたくさんもらえるでしょう いつが暇ですか お金持ちのくせに、スーパーで散々値切りをしました 日本、ヨーロッパ、そしてアメリカを旅行しました あのノートは私のです もう二十五さなのに、両親からお小遣いをもらいます 二月に日本を旅行しました。それから、韓国と中国にも行きました ニュースで道の状況がわかります この店は高いです。ですが、全然美味しくありません 本棚に小説と雑誌があります 私は日本の神社に参拝しました。な、それから、お守りも買いました もう朝なのに、なかなか起きることができません なんで台湾の会社は大学生を雇いたくないのですか 教室が静かではありません テレビをつけましたが、画面がなかなか出ません 彼女は可愛いけれども、わがままな人です 道を迷いました。それで、交番に道を尋ねに行きました この絵が綺麗です。なのに、誰も買いません ご飯を食べた人 台 私の得意なことはギターを弾くことです 先生の隣に父と母がいます 何曜日が暇ですか 明日からは夏休みだけれども、宿題がいっぱいあります 昨日はテレビを見ました。それから、テストの勉強をしました 目覚しとけいをかけたのに、なかなか鳴りません 日本、ヨーロッパ、そしてアメリカを旅行しました 今夜は蒸し暑いですから、明日は雨が降るでしょう そば 校長 親戚 ハンバーグ 屋上 乗客 レンタサイクル 美術館 映画 栓抜き 私は日本の神社に参拝しましたよ。な、それから、お守りも買いました サイ 貸して 指して 買い物カートはからです 蝉 2020-2-7とても 次はいつ会いましょうか 彼の日本語のレベルは私と同じくらいだ 紙 高い 私の夫はサラリーマンです みんなにお菓子をあげましょう 五月五日は祝日です 円 上る 曲がる 彼は駄目な男だ 九日に荷物が届きます 渇く 宿題は自分でやりなさん 六日前に日本に帰ってきました 私はパンよりご飯が好きだ 閉める 口 今週 三 存在 彼は行政を改革したいと思っている 毎年多くの人が海外へ旅行する 企業 もう 調査 これは世界最大の船です パソコンを買いましたが、キーボードがありません 最後に、南投から台北に帰りました 和食といえば、寿司や味噌汁や天ぷらなどです 日本語先生のくせに、日本語で自己紹介することもできません 給料をたくさんもらうくせに、全然仕事をしません 私の得意なことはギターを弾くことです 私はあの人のことが嫌いです みんなにお菓子をあげましょう 彼は運動場で倒れました。そして、三分後救急車が来ました お金持ちのくせに、スーパーで散々値切りをしました 明日から夏休みです。でも、宿題がいっぱいあります 私は風邪をひきました。なので、映画館に行きませんでした あの弁当は美味しいのに、40元もかかりません 私は風邪をひきました。だから、明日学校に行きたくありません まず、次に、そして、それから、最後に 私は日本語ができます 夜市が賑やかです 台北駅はあそこです 私は学生ではありません 友達は朝９時に家にきました。そして、夜６時にみんな帰りました 彼女は可愛いですが、わがままな人です この服とあの服、どちらが可愛いですか 私は日本語料理を作るとこが少しできます リビングのソファで寝ました。それで、風邪をひきました あの絵は綺麗です。なのに、誰も買いません テレビをつけました。しかし、画面がなかなか出ません うそ 私はフォークでパスタを食べます 最近、雨の日が多いです。それに、台風も二個来ました 私は日本料理を作ること大体できます 先月私は台湾を旅行しました 私は得意なことはギターを弾くことです ニュースで道の状況がわかります 道に迷いました。それで、交番に道を尋ねに行きました 先生は親切ではありません お金を振り込んだくせに、商品が全くきません あの歌手は有名だけれども、歌が下手です テレビを見ました。それから、テストの勉強をしました あの店は高いけれども、全然美味しくありません 床に蟻がいます 私は日本語がまあまあできます 虹 サツマイモ め ニュースで道の状況が分かります 2020-2-6短い 彼は荷物を網棚に上げた 紙 親の愛は有り難い 旅行の日程を変えました 学校は８時半に始まります 授業 よう 細い 八つ 綺麗 渇く 風邪 留学生 教科書を閉じてください 男の人が私たちに話しかけた 続ける 彼は行政を改革したいと思っている のち より いい方法思いつきました 報告 その二社は対立しています 昨日、財布を無くしました。それに、傘も電車に忘れました テレビを付けました。しかし、画面がなかなか出ません 何を食べたいですか 定食かうどんかラーメンですね お金持ちのくせに、スーパーで散々値切りをしました 彼女は可愛いけれども、わがままな人です あの歌手は有名だけれども、歌が下手です あの絵が綺麗です。なのに、誰も買いません もう朝なのに、なかなか起きることができません 彼女は可愛いですが、わがままな人です 道を迷いました。それで、交番に道を尋ねに行きました 私は日本料理を作ることができます 私は彼にノートパソコンをもらいました あの絵が綺麗なのに、誰も買いません 彼は行政を改革したいと思っている 日本語が上手になる リビングのソファで寝ました。それで、風邪をひきました。 宿題をしました。それに、明日の授業の予習もしました 明日からは夏休み。でも、宿題がいっぱいあります 25歳なのに、両親からお小遣いをもらいます お金持ちのくせに、スーパーで散々値切りをしました あの歌手は有名だけれども、歌が下手です 私は歌を歌うことができます 北川さんはたくさん食べましたけれども、全然太りません あの車はとんでもなく高いくせに、すぐ故障しました あの絵が綺麗です。なのに、誰も買いません 次に、桃園で飛行機を見に行きました どこが賑やかですか うそ ここの公務員は暇なくせに、文句を言います 日本語先生のくせに、日本語で自己紹介することもできません 明日からは夏休みだけれども、宿題がいっぱいあります テレビをつけましたけれども、画面がなかなか出ません 二月に日本を旅行しました。それから、韓国と中国にも行きました 宮沢さんは課長のことをどう思いますか この店の料理は美味しいです。それに、値段もとても安いです 給料をたくさんもらうくせに、全然仕事をしません 大人 歌手 文房具 楓 お金持ちのくせに、スーパーで散々値切りをしました 定食 キャベツ 選手 葉が落ちます 脈を取る 銀のフルート うそ 給料をたくさんもらいましたくせに、仕事を全然しません 2020-2-5右 紙 会う そう 変える 私は朝シャワーを浴びます 夕食には何を食べたいですか 違う 触る 渇く 茶色 易しい 曲がる 明日からは夏休みです。でも、宿題がいっぱいあります その子は指で十数えました 今夜は月がとても綺麗です 金 教科書を閉じてください 明日からは夏休みです。でも、宿題がいっぱいあります 採用 事実 明らか 与える 私は今結婚資金を貯めています 業者 新聞 テレビをつけました。しかし、画面がなかなか出ません 生産 構造 災害に備えて、大量の水を買い込んだ 目覚まし時計をかけたのに、なかなか鳴りません テレビをつけました。しかし、画面がなかなか出ません 話はここまでです。な、それから お金を振り込んだくせに、商品が全くきません 新しいパソコンを買いましたけれども、キーボードがありません 北川さんはたくさん食べましたけれども、全然太りません そして、対中で有名な湖の隣のホテルに泊まりました さあ、私もわかりませんね この車はとんでもなく高いくせに、すぐ故障します この絵が綺麗です。なのに、誰も買いません 給料をたくさんもらうくせに、全然仕事をしません 教科書を閉じてください 天気が良くありません。それで、海に行くのやめました それで、どうした 二月に日本を旅行しました。それから、韓国と中国にも行きました もう25歳なのに、両親からお小遣いをもらいます 明日からは夏休みです。でも、宿題がいっぱいあります 私は学生ではありません 何を食べたいですか 定食かうどんかラーメンですね 今夜は蒸し暑いから、明日雨が降るでしょう あの店の弁当は美味しいのに、40元もかかりません あの店は高いです。ですが、全然美味しいくありません テレビをつけました。しかし、画面がなかなか出ません あの歌手は有名だけれども、歌が下手です 道を迷いました。それで、交番に道を尋ねに行きました 私はあなたにデジタルカメラをもらいました この絵が綺麗です。なのに、誰も買いません 明日からは夏休みだけれども、宿題がいっぱいあります 何曜日が暇ですか 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 二月に日本を旅行しました。それから、韓国と中国にも行きました 梅と桜 向日葵は草より綺麗です 明日から夏休みです。でも、宿題がいっぱいあります 何を食べたいですか 定食かうどんか、らーめんですね 夏休みなのに、陽明山で雪が降りました 宿題をしました。それに、明日の授業の予習もしました お金持ちのくせに、スーパーで散々値切りをしました ここの公務員は暇なくせに、文句を言います あの歌手は有名だけれども、歌が下手です 羊 記憶 事務室 弁当 フクロウが頭を上下に動かしている 道を迷いました。それで、交番に道を尋ねに行きました テレビをつけました。しかし、画面がなかなか出ません 蟹 明日からは夏休みだけれども、宿題がいっぱいあります あの絵が綺麗です。なのに、誰も買いません 明日からは夏休みです。でも、宿題がいっぱいあります ま テレビをつけました。しかし、画面がなかなか出ません その絵が綺麗です。なのに、誰も買いません 2020-2-4帰る 質問のある方はどうぞ 起こる 乗る 去年 広い 肉と魚とどちらが好きですか 夏休みももう終わりだ 千円 晴れる 入る 柿の木に実がたくさんなっています 私は腕時計を四つもっています 渇く 男の人が私たちに話しかけた 閉める 曲がる 近く ハワイは4回目です 研究 調査 トラブルがやっと解決した もう 建設 受付でプログラムを受け取った 生まれる その会社は来月キャンペーンを行う 計画を一部変更しましょう 災害に備えて、大量の水を買い込んだ 力 対象 写真はいい思い出になります 対する 代表 銀行は３時まで開いています 私は学生ではありません もう朝なのに、なかなか起きることができません なんでこんな時間に学校にいないのですか 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 夏は涼しかったです お金を振り込んだくせに、商品が全くきません 北川さんはたくさん食べますが、全然太りません 渇く まず、台北のお寺と夜市に行きました 曲がる 給料をたくさんもらうくせに、全然仕事をしません 夏なのに、よう名山で雪が降りました あなたの会社は私の会社に統計ソフトウエアをくれました 目覚まし時計をかけたのに、なかなか鳴りません ここの公務員は暇なくせに、文句を言います この店は高いです。ですが、全然美味しくありません 授業をする教師 災害に備えて大量の水を買い込んだ 私の好きなことは音楽を聴くこのです 日本語先生のくせに、日本語自己紹介することもできません 私は学生ではありません お金持ちのくせに、スーパーで散々値切りをしました 小林さんは中国語を話すことができます 私は世界一周をしたいです もう25歳なのに、両親からお小遣いをもらいます 何曜日が暇ですか 給料をたくさんもらうくせに、全然仕事をしません 明日から夏休みですが、宿題がいっぱいあります 道を迷いました。それで、交番に道を尋ねに行きました この車はとんでもなく高いくせに、すぐ故障します 明日から夏休みですが、宿題がいっぱいあります 私は日本語があまりできません この絵は綺麗なのに、誰も買いません この服とあの服、どちらが可愛いですか 今夜は蒸し暑いから、明日は雨が降るでしょう パソコンを買いましたけれども、キーボードがありません このノートは私のです 彼は運動場で倒れました。そして、三分後救急車が来ました テレビをつけましたけれども、画面がなかなか出ません 最近、雨の日が多いです。それに、台風もニコ来ました ジーンズを買いましょうか そっか、今度早く家をでろう もう25歳なのに、両親からお小遣いをもらいます 何曜日が暇ですか えっと、電車が遅れましたから、遅刻した 接続詞 メロン 液晶テレビ 乗客 買い物カートはからです 道に迷いました。それで、交番に道を尋ねに行きました 炒める 脈を取る 蝉 この車はとんでもなく高いくせに、すぐ故障します 明日から夏休みだけれども、宿題がいっぱいあります 今夜は蒸し暑いから、明日は雨が降るでしょう この車はとんでもなく高いくせに、すぐ故障します この車はとんでもなく高いなのに、すぐ故障しますた この車はとんでもなく高いくせに、すぐ故障します 2020-2-3いつも 消す 次 いう 働く 起こる 来年 男の人は私たちに話しかけだ 渇く 彼はシートバルトを閉めた お金持ちのくせに、スーパーで散々値切りをしました 起こる ハワイは4回目です 男の人は私たちに話しかれた 渇く お金持ちのくせに、スーパーで散々値切りをしました ある 悲しい 閉める このコートはとても暖かい お金持ちのくせに、スーパーで散々値切りをしました お金持ちのくせに、スーパーで散々値切りをしました この車はとんでもなく高いくせに、すぐ故障します 銀行 業者 生まれる あの車はとんでもなく高いくせに、すぐ故障します もう この車はとんでもなく高いくせに、すぐ故障します 調査 バラには色々な種類があります ハワイは4回目です 結果 これは重要な書類です 計算 制度 語る 動き 姿 ここの公務員は暇なくせに、文句を言います ここの公務員は暇なくせに、文句を言います 閉める お金持ちのくせに、スーパーで散々値切りをしました お金持ちのくせに、スーパーで散々値切りをしました もう この車はとんでもなく高いくせに、すぐ故障します 調査 この車はとんでもなく高いくせに、すぐ故障します お金持ちのくせに、スーパーで散々値切りをしました この公務員は暇なくせに、文句を言います その会社は来月、キャンペーンを行う 日本語先生のくせに、日本語で自己紹介することもできません この店は高いけれども、全然美味しくありません 本棚に小説と雑誌があります 私は日本語が全然できません 私は世界一周をしたくありません コンビニに電子レンジがあります お金を振り込んだくせに、商品が全くきません 給料をたくさんもらうくせに、全然仕事をしません ここの公務員は暇なくせに、文句を言います スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 静かな教室 お爺さんは昔の記憶を忘れたがります 夏なのに、幼名山で雪が降りました 国仲さんはあなたにギターをもらいました それから、南投の有名な牧場に遊びに行きました 目覚まし時計を狩れたのに、なかなか鳴りません 最近雨の日が多いです。それに、台風をにこきました もう25歳なのに、両親からお小遣いをもらいます ふーん、それで？ スピーチは何時からですか この絵が綺麗なのに、誰も買いません お金持ちのくせに、スーパーで散々値切りをしました この公務員は暇なくせに、文句を言います 彼女は可愛いけれども、わがままな人です まず、台北のお寺と夜市に行きました お金を振り込んだくせに、商品が全くきません 給料をたくさんもらうくせに、全然仕事をしません 明日からは夏休みですが、宿題がいっぱいあります 明日からは夏休みだけれども、宿題がいっぱいあります それで？これからどうします この店は高いです。ですが、全然美味しくありません この服とあの服、どちらが可愛いですか 目覚まし時計かけたのに、なかなか鳴りません 上野さんは彼女と映画を見ました 彼は運動場で倒れました。そして、三分後救急車が来ました もう25歳なのに、両親からお小遣いをもらいます 朝なのに、なかなか起きることができません 私は日本語がよくできます テレビをつけましたが、画面がなかなか出ません どうして今日遅刻した あの店は高いです。ですが、全然美味しくありません ないでください 彼女は可愛いですが、わがままな人です あの店の弁当は美味しいのに、４０元もかかりません 乗客 博物館 鶴 広告 雨の後、虹が見られるかもしれません お金が振り込んだくせに、商品が全く来ません 脈を取る この服とあの服、どちらが可愛いですか この店は高いです。ですが、全然美味しくありません 彼は運動場で倒れました。そして、三分後救急車が来ました 朝なのに、なかなか起きることができません もう25歳なのに、両親からお小遣いをもらいます あの店は高いです。ですが、全然美味しくありません 乗客 脈を取る 2020-2-2落ちる グラスの数が足りません 鳥が飛んでいます 走る 3月は仕事が忙しい 切る 一日 8 直る 店員は若い女の人でした 夕食には何を食べたいですか 腰 愛する 多分 給料をたくさんもらうくせに、全然仕事をしません お名前をカタカナで書いてください 写真はいい思い出になります 変わる それは最近話題の本ですね 給料をたくさんもらうくせに、全然仕事をしません これら 検討 残る 方向 より 意味 彼は就職試験を受けた 立場 給料をたくさんもらうくせに、全然仕事をしません ほぼ 現在 これから、より一層努力します この絵は綺麗なのに、誰も買いません あの歌手は有名だけれども、歌が下手です テレビをつけましたけれども、画面がなかなか出ません もう25歳なのに、両親からお小遣いをもらいます 友達は朝９時に家にきました。そして、夜６時にみんな帰りました 私はあなたにデジタルカメラをもらいました それから、台中で有名な湖の隣のホテルに泊まりました 給料をたくさんもらうくせに、全然仕事をしません 夏なのに、幼名山で雪が降りました 目覚まし時計をかけたのに、なかなか鳴りません お金を振り込んだくせに、商品が全くきません お金を振り込んだくせに、商品が全くきません 給料をたくさんもらうくせに、全然仕事をしません もう25歳なのに、両親からお小遣いをもらいます もう朝なのに、なかなか起きることがでいません 彼女は可愛いですが、わがままな人です 最後に、南投から台北に帰りました あの店の弁当は美味しいのに、40元もかかりません テレビをつけましたが、画面がなかなか出ません 彼女は可愛いけれども、わがままな人です 北川さんはたくさん食べましたけれども、全然太りません お金が振り込んだくせに、商品が全くきません 私は日本料理を作ることが大体できます いつが暇ですか 土曜日か日曜日です お金が振り込んだくせに、商品が全くきません 私は日本料理を作ることがまあまあできませう 北川さんはたくさん食べますが、全然太りません あの店は高いですが、全然美味しくありません お金を振り込んだくせに、商品が全くきません 日本語先生のくせに、日本語で自己紹介することもできません 日本お神社に参拝しhましたよ。な、それから、お守りも買いました 私のカバンはどれですか 私はフォークでパスタを食べます このノート私のです 和食と言えば、寿司や味噌汁や天ぷらなどです どうしてキリンは首が長いですか パソコンを買いましたが、キーボードがありません 引き出し 大人 ゲーム 陽傘 日本語先生のくせに、日本語で自己紹介することもできません カーテン 深い 香水 小テスト 茶髪 買い物カートはからです 栓抜き 蟹 ロブスターが岩の上にいる 日本語先生のくせに、日本語で自己紹介することもできません もも 7点9センチメートル お金を振り込んだくせに、商品が全くきません ぎ 日本語先生のくせに、日本語で自己紹介することもできません 日本語先生のくせに、日本語で自己紹介することもできません 2020-2-1働く 仕事 春 宿題はまだ終わっていません 私は朝シャワーを浴びます あなたの来るの、待っています 起こす 言う もう25歳なのに、両親からお小遣いをもらいます 彼に会えて嬉しかった 上る お腹が空きました 時の経つのは早い 火曜日 もう25歳なのに、両親からお小遣いをもらいます もう25歳なのに、両親からお小遣いをもらいます 彼は時々遅刻します もう25歳なのに、両親からお小遣いをもらいます 夕食には何を食べたいですか 彼は神を信じている 彼は昼過ぎにきます 建設 あの店の弁当は美味しいのに、４０元もかかりません 実現 外国 開発 写真はいい思い出になります 開く 私は四つの会社に投資しています この絵は綺麗なのに、誰も買いません 方向 その仕事は危険を伴う 資金 遅れた理由を教えてください もう 全体の80パーセントが完成しました 会社 あの店の弁当は美味しいのに、40元もかかりません 二十キロのダイエットは可能だと思いますか もう25歳なのに、両親からお小遣いをもらいます 夕食には何を食べたいですか 25歳なのに、両親からお小遣いをもらいます あの店の弁当は美味しいのに、40元もかかりません 写真はいい思い出になります 明日からは夏休みだけれども、宿題がいっぱいあります この絵は綺麗なのに、誰も買いません 彼は運動場で倒れました。そして、三分後救急車が来ました 天気が良くありません。それで、海に行くのやめました もう朝なのに、なかなか起きることができません あの歌手は有名だけれども、歌が下手です パソコンを買いましたけれども、キーボードがありません あの店は高いけれども、全然美味しくありません もう朝なのに、なかなか起きることができません 彼女は可愛いけれども、わがままな人です あの店の弁当は美味しいのに、40元もかかりません 私はおばあちゃんのことが好きです 私はピーマンが嫌いです 北川さんはたくさん食べましたけれども、全然太りません テレビをつけましたけれども、画面がなかなか出ません 彼女は可愛いですが、わがままな人です 目覚まし時計を狩れたのに めざまし時計をかけたのに、なかなか鳴りません 道を迷いました。それで、交番に道を尋ねに行きました この店の料理が美味しいです。それに、値段もとても安いです 駅の前に新しいコンビニができます。それから、駅の後ろにもコンビニができます 彼女は可愛いけれども、わがままな人です もう朝なのに、なかなか起きることができません あの絵は綺麗なのに、誰も買いません 日曜日が暇です この店は高いですが、全然美味しくありません パソコンを買いましたが、キーボードがありません 夏なのに、幼名山で雪が降るました 湖 もう朝なのに、なかなか起きることができません ビジネスマン 鶏 蟹 買い物カートはからです 蝉 目覚まし時計をかけなのに、なかなか鳴りません 目覚まし時計をかけたのに、なかなか鳴りません 目覚まし時計をかけたのに、なかなか鳴りません あの絵は綺麗なのに、誰も買いません 夏なのに、陽明山で雪が降りました 蟹 買い物カートはからです もう朝なのに、なかなか起きることができません もう目覚まし時計をかけたのに、なかなか鳴りません","link":"/zh-tw/japanese/2020/February/index.html"},{"title":"December 2018","text":"2018/12/31The result of my target yesterday linux: 鳥哥的linux基礎篇 i read some book not related to coding yesterday. i was guilty! git: pro git i read some book not related to coding yesterday. i was guilty! challenge20181217 rewriting paymentdetail function getachievedachievement function getpossessions function profile function DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting deposit achievement 2018/12/30The result of my target yesterday linux: 鳥哥的linux基礎篇 i read some book not related to coding yesterday. i was guilty! git: pro git i read some book not related to coding yesterday. i was guilty! challenge20181217 rewriting shop system function rewriting DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting getachievedachievement getachievedachievement function getpossessions function profile function 2018/12/29The result of my target yesterday linux: 鳥哥的linux基礎篇 head -n number filename tail -f filename cat -n filename | tail -n git: pro git how to revert a merged commit and undo all the changes introduced by the branch being merged?git revert -m 1 commitid if i reverted a merged commit and chose the parent, what if i want to merge it again?revert the reverted commit when merging, how to skip mamually resolving and just choose the side we choose? git merge branchname -xours or git merge branchname -xtheirs challenge20181217 rewriting shop system function rewriting went to a movie theater. DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting shop system function rewriting 2018/12/28The result of my target yesterday linux: 鳥哥的linux基礎篇 nl -ba filename nl -bt filename nl -w filename nl -nln filename nl -nrn filename nl -nrz filename git: pro gitgit merge -xignore-all-space git merge -xignore-space-change git log --oneline --left-right --merge -p (option) challenge20181217 rewriting readability of achievement function shop system function rewriting to be completed today DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting shop system function rewriting 2018/12/27The result of my target yesterday linux: 鳥哥的linux基礎篇 cat -a cat -b cat -e cat -n cat -t cat -v git: pro gitgit filter-branch --subdirectory-filter directoryname head git filter-branch --commit-filter &#x27; if [ &quot;$git_author_email&quot; = &quot;currentemail&quot; ] ; then git_author_name=&quot;newauthornameyouwanttobe&quot;; git_author_email=&quot;newemailyouwanttobe&quot;; git commit-tree &quot;$@&quot;; else git commit-tree &quot;$@&quot;; fi&#x27; head rewrite challenge20181217 achievement function achievement function was completed, but need to improvie its readability Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting readability of achievement function shop system function rewriting2018/12/26 The result of my target yesterday linux: 鳥哥的linux基礎篇 went to ktv instead git: pro git went to ktv instead rewrite challenge20181217 getachievementlist &amp; getitemlist api was completed Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git i think i need to focus on my challenge code rework until i finish it 2018/12/25The result of my target yesterday linux: 鳥哥的linux基礎篇辦事項 git: pro git git commit –amend –no-edit git commit filter-branch –tree-filter –all ‘rm -f file’ head laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (2/5) rewrite challenge20181217 redesign tables Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git i think i need to focus on my challenge code rework until i finish it 2018/12/24The result of my target yesterday linux: 鳥哥的linux基礎篇辦事項 git: pro git - git grep filename -n &amp; git grep filename -n laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (1/5) Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (2/5) 2018/12/23The result of my target yesterday figure out how to use moment of js to covert the timezone from utc to where you are - not completed yet wondering presentation - completed Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (1/5) 2018/12/22The result of my target yesterday challenge 20181221 passed figure out how to use moment of js to covert the timezone from utc to where you are - not completed yet Achieved except for set target yesterdayDescriptionToday’s target wondering presentation 2018/12/21The result of my target yesterday challenge 20181220 passed Achieved except for set target yesterdayDescriptionToday’s target don’t special game challenge 20181221 2018/12/20The result of my target yesterday challenge 20181219 passed Achieved except for set target yesterdayDescriptionToday’s target challenge 20181220 2018/12/19The result of my target yesterday challenge 20181218 passed Achieved except for set target yesterdayDescriptionToday’s target challenge 20181219 2018/12/18The result of my target yesterday challenge 20181217 passed Achieved except for set target yesterdayDescriptionToday’s target challenge 20181218 2018/12/17The result of my target yesterdaylaravel warming up laravel warm up Achieved except for set target yesterdayDescriptionToday’s target challenge 20181217 2018/12/16The result of my target yesterdaylaracast focus on laravel warming up first laravel warming up laravel_5.7_from_scratch series (9~12/36) linux: focus on laravel warming up first git git add -i revert git add -p git reset -p git stash apply –index git stash –keep-index git add -i update Achieved except for set target yesterdayDescriptionToday’s target laravel- warming up for challenge next week 2018/12/15The result of my target yesterdaylaracast recap the php practitioner series (22/25) laravel warming up laravel_5.7_from_scratch series (4~8/36) linux: what’s cp -s? waht’s cp -r? waht’s cp -u? waht’s cp –preserve=all? if there are two sources when placing cp command, what the destination should be? waht’s cp –preserve=all? git git log origin/master..head git log master..test git log ^master test git log test –not master git log test develop ^master git log test develop –not master Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 23 laravel- warming up for challenge next week 2018/12/14The result of my target yesterdaylaracast recap the php practitioner series (21/25) laravel warming up laravel_5.7_from_scratch series (1~3/36) linux: what’s cp -a? what’s cp -d? what’s cp -f? what’s cp -i? what’s cp -l? what’s cp -p? git git rebase -i ‘wondering’ presentation perfectly done Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 22 laravel- warming up for challenge next week 2018/12/13The result of my target yesterdaylaracast the php practitioner series (19~20/25) linux: what’s in /var/spool folder of linux? what’s ls -a? what’s ls -f? what’s ls -h? what’s ls -i? what’s ls -n? what’s ls -r? what’s ls -r? what’s ls -s? what’s ls -t? what’s ls –full-time? challenge 20181212 passed git git rebase -i Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 21 ‘wondering’ presentation laravel- warming up for challenge next week 2018/12/12The result of my target yesterdaylaracast no time for it. linux: what’s in /var/spool folder of linux? what’s nfs in full name? what’s lsb in full name? how to show true path rather than link path when using pwd? how to create folders through multipal layers? how to give authority when creating a folder? how to show $path? how to add a folder into $path? what’s ls -a? challenge 20181211 passed adaptor make every single book an object how to pass outside variable into closure git github notification flicked through github api and github hooks Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 18~? challenge 20181212 ‘wondering?’ rehersal 2018/12/11The result of my target yesterdaylaracast have completed recapping of 15~17 linux: what’s in /include folder of linux? what’s in /libexec folder of linux? what’s in /usr/src folder of linux? what’s in /var folder of linux? what’s in /var/cache folder of linux? what’s in /var/lib folder of linux? what’s in /var/lock folder of linux? what’s in /var/log folder of linux? what’s in /var/mail folder of linux? what’s in /usr folder of linux? what’s in /usr/bin folder of linux? challenge 20181210 passed git how to fetch all pull-requests without adding them as remotesfetch = +refs/pull//head:refs/remotes/origin/pr/ Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 18~? challenge 20181211 2018/12/10The result of my target yesterdaylaracast the_php_practitioner series (25/25) was completed. have recapped the_php_practitioner 1~15. linux: what’s in /usr folder of linux? what’s in /usr/bin folder of linux? what’s in /usr/lib folder of linux? what’s in /usr/local folder of linux? what’s in /usr/sbin folder of linux? what’s in /usr/share folder of linux? what’s in /usr/games folder of linux? what’s in /home folder of linux? what’s in /lib qual folder of linux? what’s in /root qual folder of linux? what’s in /proc qual folder of linux? what’s in /sys folder of linux? git if you see something like pull request does not merge cleanly in github, what should you do?① add the original repository as a remote named “upstream”② fetch the newest work from that remote③ merge the main branch of that repository into your topic branch④ fix the conflict that occurred⑤ push back up to the same topic branch how could we reference issue or pull-request on github?## how to use task list on github? write the code write all the tests document the code Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap challenge 20181210 2018/12/9The result of my target yesterdaylaracast having completed episode 24, and will recap it again and push it to github linux: what’s in /home folder of linux? what’s in /lib qual folder of linux? what’s in /root folder of linux? what’s in /lost+found folder of linux? what’s in /proc folder of linux? what’s in /sys folder of linux? git what are the steps to create a pull-request on github?① clone our fork of the project locally② create a descriptive topic branch③ make our change to the code④ check that the change is good⑤ commit our change to the topic branch⑥ push our new topic branch back up to our github fork how to condense a whole feature branch into a single commit and push it to master branch as production branch. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner (24/25) recap and (25/25) 2018/12/8The result of my target yesterdaylaracast having completed episode 23 and pushed it to github linux: what’s in /media folder of linux? what’s in /mnt folder of linux? what’s in /opt folder of linux? what’s in /run folder of linux? what’s in /sbin folder of linux? what’s in /srv folder of linux? what’s in /tmp folder of linux? The Wondering having completed presentation for ‘wondering’ next week. git i didn’t have time for it yesterday. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner (24/25) 2018/12/7The result of my target yesterdaylaracast yesterday i didn’t watch it at all, my goodness. i must finish it today and move on! linux: what’s in /bin folder of linux? what’s in /boot folder of linux? what’s in /dev folder of linux? what’s in /etc folder of linux? what’s in /lib folder of linux? The Wondering both rehersal and presentation were perfectly done. Achieved except for set target yesterday sharing what i learnt from the deployment event at tuesday night with the whole backend team. DescriptionToday’s target presentation for The Wondering next week, or perhaps the week after that. linux: 鳥哥的linux基礎篇 git: pro git laracast: the php practitioner(23/25) recap, and push every step of it on github 2018/12/6The result of my target yesterdaylaracast finally, i finished episode (23/25) yesterday. i will try to recap it again and push each step on github linux: when installing package, why it shows 403 forbidden? the limit of length of the name of files and repositories in linux. fhs - filesystem hierarchy standard the purpose of fhs four types of repositories in linux explanation of four types of repositories - shareable, unshareable, static, variable three defaultly defined repositries by fhs The Wondering i have finished rehersal one time, and am going to do that again before presentation.Achieved except for set target yesterdayDescriptionToday’s target The Wondering rehersal before presentation linux: 鳥哥的linux基礎篇 laracast: the php practitioner(23/25) recap, and push every step of it on github 2018/12/5The result of my target yesterdaylaracast still stuck on the_php_practitioner episode 23. maybe bacause i stayed up late the night before last night with whole backend working server deployment, yesterday i was too groggy to figure it out. i have to finish it today!git: gpg security keys for git tag signituressl: having completed ssl hand-on experiment. linux: recap authority command with jett and soj. i was supposed to read linux book last night, however, i passed out as soon as i took a shower. Achieved except for set target yesterdayDescriptionToday’s target laracast: the php practitioner(23/25) The Wondering rehersal linux: 鳥哥的linux基礎篇 2018/12/4The result of my target yesterdaylaracast the php practitioner (23/25). i was scheduled to finish episode 23 yesterday. however, the whole backend team and i were working on server configuration and deployment all day long, and i will manage to finish it today. git: as above mentioned, i counldn’t manage any time for git yesterday. linux: what’s link file what’s data file what’s device file what are block and character of device file what’s socket file what’s fifo file Achieved except for set target yesterday ssl signature frontend and backend deployment on server with apache.DescriptionToday’s target laracast: the php practitioner(23/25) git: pro git linux: 鳥哥的linux基礎篇 ssl signature hand-on experiment.2018/12/3 The result of my target yesterdaylaracast the php practitioner (23/25), i’ve recapped the logic, and ready to go further. git: hand-on experiment on rerere function linux: chmod ugoa, +-=, rwx rules of authority for files and repositories regular file: ascii, data, binary how to read data file - last how to read ascii file - cat The Wondering completedAchieved except for set target yesterdayDescriptionToday’s target laracast: the php practitioner(23/25) git: pro git linux: 鳥哥的linux基礎篇2018/12/2 The result of my target yesterdaylaracast the php practitioner (23/25): i spent a lot of time recaping what i’d leart before backend challenge. i think i will need more time to retrive the logic before getting later episode. git: merging work flow large-merging workflow git config –global rerere.enabled true linux: chgrp [-r] groupname filename chown [-r] user:group filenameorrepositoryname chmod [-r] xyz filenameorrepositoryname docker: create a dockerfile build a dockerfile run a dockerfile push a dockerfile rough concept of docker Achieved except for set target yesterdayDescriptionToday’s target laracast: the php practitioner series git linux presentation of The Wondering for next week. 2018/12/1The result of my target yesterdayapache and nginx: having learnt how to use either apache or nginx as reverse proxy and proxy_pass to webserver with whatever headers that are required. git: create a branch based off another branch - git branch thebranchyouwant thebranchyouwouldliketobebasedoff will git reflog be pushed? - no can i pull from repositories that haven’t been added as remote? - yes how to pull from repositories that haven’t been saved as remote - git pull theurl, append –allow-unrelated-histories if not related. it shows only the work your current topic branch has introduced since its common ancestor with master - git diff master…meatlinux: drwxrwxrwx, what does d mean? -rwxrwxrwx, what does - mean? lrwxrwxrwx, what does l mean? brwxrwxrwx, what does b mean? crwxrwxrwx, what does c mean?DescriptionToday’s target laracast: the php practitioner series attending docker speech held on good idea studio git linux","link":"/zh-tw/schedule/2018/December/index.html"},{"title":"April 2020","text":"2020-4-30町で大事件が起こりました 髪 今日は日本語の授業があります 質問 名前 彼は足が長い この町には緑がたくさんあります 軽い 言う キリンの首は長い すぐ行きます クーラーはまだ直りません マン 先月の七日に孫が生まれました 冷たい お手洗い 一日 彼は神を信じている 解決 いずれ 消える 彼は食品工場で働いています 信号が青に変わりました 彼は事故で怪我をしました 変わる まあ今回は許してあげよう 分野 制度 可能 東京に来るのは初めてです なお 原因 犬に餌をやった 質問 机の上にペンが二本あります 旅行会社の人は家族に海外旅行のビザを申し込んでくれました 私はゲームが好きです シャワーを浴びる象 そっか、今度早く家を出ろ あの店は高いです。ですが、全然美味しくありません 話はここまでです。あ、それから 私はご飯を食べています 私は懐石料理が非常に好きです 彼は彼の父に新しい腕時計をあげました これは私のノートです 歩きます 夜中にギターを弾いてはいけません タバコを吸ってはいけません 私はおばあちゃんのことが好きです 弟は部屋を掃除してくれました 彼は事故で怪我おしました 私の苦手なことは料理を作ることです 分野 今日 文房具 原稿改定する フライドチキン 2020-4-29美しい 楽し 落ちる ところ 神 場合 昨日、あなたのお姉さんに会ったよう 冷たい 閉める 閉じる 八日からイギリスに行きます わからない場合は私に聞いてください 時の経つのは早い 彼女はよく喋るね 切って 集める 強調 なお 予定 影響 受ける 存在 生活 対策 この段階では決断するのはまだ早い 競争 信号が青に変わりました 先生は私に100点をくれました えっと、電車が遅れたから遅刻しました 昨日何処かに行きましたか いいえ、何処も行きませんでした 冷たい お釣をください なんで今日は私の家に行きましたか はい、そうです 給料をたくさんもらうくせに、全然仕事をしません 彼は中国語と英語がわかります コーヒーを飲みましょう 私の苦手なことは料理を作ることです 小林さんは中国語を話すことができます ボタンをおっす デザートは美味しくありません 夜中にギターを弾いていけません 新しいゲームソフトを買いました。だから、古いソフトを売りました 電気屋の人は私に新しいテレビを運んでくれました 彼は泳いでいます 彼は社員です シャワーを浴びる象 信号が青に変わりました 私は討論を始めたいです 田村さんは林さんに中国語を押しいてもらいます 私は親友と遊びたいです あのおじいさんは妹に靴を直してくれました 園長 楓 寿司 乗客 誕生日 調味料 夜中にギターを弾いてはいけません シャワーを浴びる象 2020-4-28今日は日本語の授業があります 家 見つける まだ 上る 教科書を閉じてください あなたのお兄さんは何歳 書ける 閉まる 八日からイギリスに行きます お腹 作業 示す 受ける ドル 全てのシステムの停止した 相手 生活 彼はその死を用いて自分の気持ちを伝えた 今日の新聞どこに置いた 実施 彼は行政を改革したいと思っている 制度 ほとんど どれも要りません 何で 何で 弟は父の性格がわかります もう朝なのに、なかなか起きることができません 楽しい一日 ペットを飼いましょう あの塾はパートにチラシを配ってもらいます 友達は朝9時に家に来ました。そして、みんなは夜6時に家に帰りました それで？これからどうします？ 私は茶碗蒸しがあまり嫌いではありません 引き出しにハムスターが一匹います 待ってくれますか あの絵は美しいです。なのに、誰も買いません 八日からイギリスに行きます 私はあなたに宿題の答えを教えてあげます 昨日、どこかに行きましたか いいえ、ドコモ行きませんでした 生活 乗客 液晶テレビ 茶髪 栓抜き ㎝ 昨日、どこかに行きましたか いいえ、何処も行きませんでした 2020-4-27消す 兄 兄は水泳が得意です 直ぐ 今日は日本語の授業があります 美しい カナダの冬はとても寒いです 先生 赤い 彼の家に荷物を送りました 彼は神を信じている 辛い 私が手伝いましょう ハワイは4回目です 前 夕食に穴のを食べたいですか 時の経つのは早い 話すを止めてください 彼女はよく喋るね なお 理由 制度 情報 二十キロのダイエットは可能だと思いますか 方向 弟は父の性格がわかります コーヒーを飲みましょうよ 日本は台湾ほど暑くありません 次に、桃園で飛行機を見に行きました 教室は静かではありません 学生ではない リビングのソファで寝ました。それで、風邪をひきました 私は懐石料理が非常に好きです 今日は日本語の授業があります 何も食べません 役所の人は私たちに道を案内してくれます 電気屋の人は私に新しいテレビを運んでくれました いつが暇ですか そっか、今度早く家を出ろ 私はプレゼントをあげますか 旅行会社の人は家族に海外旅行のビザを申し込んでくれました 制度 果物 湖 炊飯器 大人 生まれる フロント 葉が落ちます ツアーカイトはあなたの旅行を楽しくする興味深い情報を知っているだろ 脈を取る 2020-4-26彼は数学を教えています 私たちのチームはその試合で負けた おかげさまで元気です 午前 一番 そこに大きな円を描いて そう 辛い 彼はカバンから教科書を出した 嬉しい 彼女はよく喋るね 米 もう なお 対象 関する 全てのシステムが停止した 我が社の経営はうまくいっています 昨年は地震が多い年でした 調べる 島の人口は年々増加しています 原因 今後ともよろしくお願いします お金がほとんどありません 彼女はよく喋るね なお 私は世界一周をしたくありませんでした 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 引き出しにハムスターが一匹います 私はフォークでパスタを食べます 私は茶碗蒸しがあまり嫌いではありません 夏は涼しくありません コーヒーを飲みましょうよ カレーライスのほうが美味しいです 私は懐石料理が非常に好きです それはジュースです そっか、今度早く家を出ろ 電気屋の人は私に新しいテレビを運んでくれました 旅行会社の人は家族に海外旅行のビザを申し込んでくれます コーヒーを飲みましょうよ 弟は父の性格がわかります 彼女は社長ではありません 果物 数字の17 大人 私は懐石料理が非常に好きです こんにちは 泣いている雄鶏 茶髪 そっか、今度早く家を出ろ 電気屋の人は私に新しいテレビを運んでくれました 旅行会社の人は家族に海外旅行のビザを申し込んでくれました 弟は父の性格がわかります 果物 2020-4-25今月 直ぐ 郵便局で切手を買いました 始める 漢字は中国から来ました いつも 起こす 一つ 小さい花が咲いています 分からない場合は私に聞いてください クーラーはまだ直りません 終わり 触る 渇く 彼は神を信じている 父 手紙が届くのに三日かかりました お腹 この靴は一万円です 与える 加える 力 開く 変化 全てのシステムが停止した 会談 原因 生活 治る ドル 今後の方針が決まった 私の嫌いなことはバスケットをすることです この本、借りてもいいですか 私は歌を歌うことができます 給料をたくさんもらうくせに、全然仕事をしません コンビニに電子レンジがあります 引き出しにハムスターが一匹います 眠くなる 彼は運動場で倒れました。そして、3分後救急車がきました 私は茶碗蒸しが嫌いではありません 向日葵は草より綺麗です 私はパソコンで打って、インターネットして、印刷する キャベツ 緑茶 女性が桃の太さを測っている 全てのシステムが停止した 引き出しにハムスターが一匹います 私は茶碗蒸しがあまり嫌いではありません 2020-4-24いつも また会いましょう もらう 行く 売る 使う 右 座る 直ぐ 肉と魚とどちらが好きですか お兄さん お腹 晴れる 彼は神を信じている 時計を見たらちょうど3時だった 私が手伝いましょう わからない場合は私に聞いてください 私の祖母は100歳です 曲がる 7 電気がついたままですよ 新聞 これは重要な書類です 今回 彼は小さな会社に勤めています 住宅 どる 報告 我が社の経営はうまくいっています 与える 彼は行政を改革したいと思っている 状態 より 強調 あの店の料理は美味しいです。それに、値段もとても安いです そっか、今度早く家を出ろ 飛行機が二時間遅れました。なので、到着時間も遅くなります 直ぐ ジーンズを買いましょうよ 役所の人はお婆ちゃんに綺麗なカレンダーをくれました デザートは美味しくありません お腹 ニュースで道の状況がわかります 彼は神を信じている ご飯を食べましょう それで？これからどうします 机の上にペンが二本あります 法律を破ってはいけません ないで下さい 分からない場合は私に聞いてください 彼女は可愛いけれども、わがままな人です 給料をたくさんもらうくせに、全然仕事をしません ドル 九份は賑やかではありません お釣をください 北川さんはたくさん食べますが、全然太りません 日本、ヨッロバ、そしてアメリカを旅行しました 駅弁 幽霊 書店 サラリーマン 葉が落ちます 買い物カートは空です 2020-4-23約束を忘れないでください 私には友達がたくさんいます 気持ち 会議は四時に終わります 一番 カナダの冬はとても寒いです 五月五日は祝日です 易しい 新しい仕事が始まりました その映画はとても悲しかった そこには私一人しかいなかった 喉が乾きました 国会 生産 その計算は間違っている 彼は選挙に出るつもりだ 我が社の経営はうまくいっています 調べる 実現 事故 給料をたくさんもらうくせに、全然仕事をしません 目覚し時計をかけたのに、なかなかなりません 私は彼に使い捨ての箸をあげました カレーライスとオムライス、どちらが美味しいですか そっか、今度早く家を出ろ ジーンズを買いましょうか 二月に日本を旅行しました。それから、韓国と中国にも行きました 母は私に飴を買ってくれました 九份は賑やかではありません 私の苦手なことは料理を作ることです 布団 フライドチキン 梅 雨の後、虹が見られるかもしれません か 我が社の経営はうまくいっています 給料をたくさんもらうくせに、全然仕事をしません そっか、今度早く家を出ろ 2020-4-22一つ ドアを開けてください 日記 一番 見つける 病気 今年 一緒に カナダの冬はとても寒いです 入れる クーラーはまだ直りません これは医者のためのサイトです 他に方法がありません 十日後に帰ります 大人 強い 閉じる あれは何ですか 五つ 私が手伝いましょう 昨年 評価 影響 問題 頃 方針 はげしい雨が降っています いずれ 増える ジーンズを買いましょう 母は弟におもちゃを買ってあげます スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 一番 彼女は英語先生で、動物園のボランティアです カナダの冬はとても寒いです 道を迷いました。それで、交番に尋ねに行きました 私の好きなことは音楽です あの子供は親友で遊びたがります 学生ではありません それで？これからどうします 私の趣味は野球をすることです 学生だ 一眼レフカメラ 数字の17 私は物理の基礎は知っています ましょうか 茶髪 葉が落ちます 2020-4-21うちの息子は大学一年生です 私たちのチームはその試合で負けた 少し疲れました 前 六日前に日本に帰ってきました 細い その子は指で十数えました 話すを止めてください 私が手伝いましょう 休む 髪の毛が伸びたね クーラーはまだ直りません あなたは本当に好きです 冷たい お先にどうぞ その人には二回あった 写真はいい思い出になります 方針 対策 この車はよく持っているね 原因 その仕事は危険を伴う 女性 プログラム 国は国語教育を強化しています 明日の食券をください 私は親友と遊びたいです 台北駅はどこですか 私が手伝いましょう クーラーはまだ直りません 佐々木さんはサラリーマンです それで、これからどうします 眠くなる ワンピースはスカートより高いです 私は討論を始めたいです この店の料理は美味しいです。それに、値段もとても安いです どれも要りません あの車はとんでもなく高いくせに、すぐ故障します 絵を描く 数字の17 アジア レンタサイクル 湖 葉が落ちます それで？これからどうします 数字の17 葉が落ちます 2020-4-20美しい 彼の家はとても広い 近い 早い 郵便局で切手を買いました 今 喉が渇きました 八日からイギリスに行きます 悪い 黄色い 閉める 採用 討論 検討 交渉 原因 これら 発生 激しい雨が降っています 完成 へる その問題に関する記事を読みました ほとんど 相手 なんでこんな時間に学校にいないのですか 小林さんの妻は小林さんに愛妻弁当をあげました これをください 授業をしている教師 机の上にペンが二本あります 私の苦手なことは料理を作ることです 先生討論を始めたがります 庭の松は高いです 佐々木さんはサラリーマンでした 何を食べますか 定食かうどんかラーメンですね いつが暇ですか 土曜日か日曜日 私の得意なことはギターを弾くことです 中学生 描く こんにつは 鶏肉 フロント 2020-4-19見つける 教える 彼は意外に気が小さい 彼は荷物を網棚にあげた 乗せる 大きい 強い 予定 国会 彼は一人旅の計画を立てた 関する 地域 次は全国の天気です 競争 私たちがその問題を調査しています 調べる 私の苦手なことは料理を作ることです デザートは美味しくありません 最後に、南投から台北に帰りました 課長は電話しています 学生ではない 机の上にペンが二本あります 基隆の夜市は有名で、賑やかです 北川さんはたくさん食べだけれども、全然太りません あれは店長のカーテンです バカ、言い訳するな ジーンズを買いましょうか 彼女は社長です 私は冬が嫌いです 文房具 涼しい ビジネスマン クリップ 調味料はレストランのテーブルによく置いてあります 走る 帰る 切る 私の苦手なことは料理を作ることです 机の上にペンが二本あります 2020-4-18町で大事件が起こりました 郵便局で切手を買いました 新しい仕事を見つけました 工事は三月まで続きます みんなにお菓子をあげましょう 髪 建てる 旅行の日程を変えました 彼に会えて嬉しかった 話すのを止めてください 時の経つのは早い 口 夏休みももう終わりだ 一日 今後ともよろしくお願いします 試合の相手は誰ですか 与える 原因 選挙 東京に来るのは初めてです 必要 調べる 彼は就職試験を受けた 私は歌を歌うことができます 課長は電話しています ジーンズを買いましょうか 買いてくれますか グラスを静かにする タバコを吸ってはいけませんか いいえ、吸ってもいいです あのバカは二本の鉛筆を箸にして、ご飯を食べる 基隆の夜市は有名で、賑やかです 都市は田舎より便利です 明日からは夏なすみだけれども、宿題がいっぱいあります お釣をください 彼女は彼氏に食事代を払ってもらいます 調べる ジーンズを買いましょうか 森に熊がいます 待ってくれますか 2020-4-17遅い 彼に手紙を書きました 私たちのチームはその試合で負けた 彼女は耳がよく聞こえません 郵便局で切手を買いました 働く 五日 辛い 柿の木に実がたくさんなっています 前 一日 優しい 開く 話すのを止めてください 終わり 側 今の首相はあまり力がない 日本での生活は楽しいです 二十キロのダイエットは可能だと思いますか この町は人口が増えた 原因 方向 彼は歌で自分の気持ちを表現した いずれ 彼は小さなか会社に勤めています 土地 それは最近話題の本ですね 合格者が発表された どれも要りません あなたの会社は私の会社に統計ソフトウエアをくれました 郵便局で切手を買いました 台風の時に、海辺で遊んではいけません 机の上に雑誌があります デザートは美味しくありません 昨日、テレビを見ました。それから、テストの勉強をしました 母は私に飴を買ってくれました この本、借りてもいいですか 役所の人はおばあちゃんに綺麗なカレンダーをくれました 話すのを止めてください このパソコン、使ってもいいですか はい、使ってもいいですよ 学生ではない なるほど、これは正方形ですね どれが綺麗ですか 動物園のパンダは小さくありませんでした どうして台湾の会社は大学生に雇いたくないのですか 楽しい一日 あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 私は日本料理を作ることが少しできます 私は親友と遊びたいです 体育館 傘 フライドチキン 竹 乗客 18 男性は顎髭がたくさん生えているが、頭の毛が少ないです サツマイモ フクロウ 2020-4-16美しい 知る 腕 戻る 怒る 彼はまだ若いです まだ 私たちのチームはその試合で負けた こう 払う 先 決まる 手紙が届くのに三日かかりました 前 なる 閉まる 四日 六日 この葡萄は酸っぱいです 原因 昨年 この建物の構造は複雑です 選挙 広がる 多く いい方法を思いつきました バラには色々種類があります 計画 私は味噌汁が全然嫌いではありません 大きかった 授業をした教師 もう朝なのに、なかなか起きることができません 母は私に飴を買ってくれます ゲームをしませんでした いつが暇ですか 土曜日日曜日 学食の料理はまずいです。このレストランの料理もまずいです タバコを吸ってはいけませんか はい、吸ってはいけません 私は親友と遊びたいです 私たちのチームはその試合で負けた 前 川の岸に桜の木があります 私は先月台湾を旅行しました 原因 どれも要りません 私は納豆が全然好きではありません 私はプレゼントをあげましたよね 学生ではない カレーライスのほうが美味しいです 道を迷いました。それで、交番に道を尋ねに行きました デザートは美味しくありません 私は親友と遊びたいです 台風の時に、海辺で遊んではいけません 教室は静かではありません 王さんは彼女にギターを弾いてあげめます 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 解答 こんにちは 机 マンション レタス 雄鶏 どれも要りません 学生ではない デザートは美味しkぅありません 2020-4-15酒 どう それを一つください 私には友達がたくさんいます 左 来る 時計を見たらちょうど三時だった 見つかる 水曜日がバイトがあります お店はもう閉まっていました お願い 多分 細い 来月の二十日は弟の誕生日です 土曜日 手伝う 暖かい 彼は選挙に出るつもりだ 運動会は9時開始です 続けつ 国内 原因 お金はまだ十分があります 影響 私は歩いて、電車に乗って、バスに乗る お客さんは家に来ました 夏なのに、陽明山で雪が降ります 道を迷いました。それで、交番に道を尋ねに行きました ゴミ箱にペットボトルがあります 私はあなたに宿題の答えを教えてあげます 私は歌を歌うことができます あのおじいさんは妹に靴を直してくれます 箸 学長 ひまわり 親戚 茶髪 ず 原因 2020-4-14見つける 午後 その次の週は空いてますか 素敵な色のセーターですね 出す 辺 わかった人は手をあげてください この葡萄は酸っぱいです 国会 設計 トラブルがやっと解決した 解決 引越しを業者に頼んだ ここは静かな住宅地だ 階段 存在 トンの代表が質問に答えました 建設 昨年 対策 関する 状態 全国 彼がクラスの代表だ 私は世界旅行したい 情報 彼は小さな会社に勤めています 私は歌を歌うことができます 次に、登園で飛行機を見に行きました ペットを飼いましょうよ あの塾はパートにチラシを配ってもらいます 最近、雨の日が多いです。それに、台風もにこ来ました なんで今日私の家に来ましたか 庭の松はたかくありませ すみません、今は何時ですか 部長は仕事ができます あの屋敷に幽霊がいますよ うそ 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう あのお爺さんは妹に靴を直してくれます いつが暇ですか 土曜日日曜日 私は歌を歌うことができます 私は自分の力で仕事を探します キャベツ 鶴 カレンダー フライドチキン 布 ハエ こんにちは 嫌い 和食 茶髪 そのボトルには二リットルのコーラが入っている フットボール フロント ぎ 茶髪 2020-4-13たつ 私たちは大きな声で歌いました 姉は銀行で働いています 美しい 髪の毛が伸びたね 起きる 私はひらがなを全部読めます 曜日を間違いました 状態 与える この段階では、決断するのはまだ早い 小さな会社に勤めでいます 立場 加える 帰ったら、まず手を洗いましょう ほとんど 昨日の会議について、報告があります 相手 最近、彼の評価が上がった 評価 まあ今回は許してあげよう 二十キロのダイエットは可能だと思いますか いずれ 夏は涼しくありませんでした 電気屋の人は私に新しいテレビを運んでくれました あの店は高いですが、全然美味しくありません いつが暇ですか 彼は小さな会社に勤めています お釣をください 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 最近、雨の日が多いです。それに、台風もにこ来ました 深い湖 フライドチキン 博物館 ストップウオッチ こんにちは 西洋料理 液晶テレビ 予備校生 18 いつが暇ですか フランイドチキン こんにちは 2020-4-12美しい 色 妹は平仮名を全部覚えました 今朝は早く家を出ました 生きる 遅い 今晩 十日後に帰ります お兄さん 鼻 宿題は自分でやりなさい 冷たい 増える 比べる 調べる 競争 会社で新しいシステムを導入した 頃 変化 今後ともよろしくお願いします 二十キロのダイエットは可能だと思いますか 関する 今後 規模 資金 現在、スペシャルキャンペーンを実施中です カレーライスのほうが美味しです 私は弟に部屋を掃除してもらいます 母は弟におもちゃを買ってあげます カバンに降水があります 会社の人は私にホテルを予約してくれました 母は飴を買ってもらいます 貸して 無くして 出して 戻して 鉛筆は短いです いつが暇ですか 土曜日日曜日 二十キロのダイエットは可能だと思いますか 法律を破ってはいけません 机の上にペンが二本あります そこは病院ですね 彼女は彼氏に食事代を払ってもらいます 便利な所 私は日本の神社に参拝しましたよ。あ、それからお守りも買いました 日本語を上手にする 明日からは夏な、宿題がいっぱいあります みてください インターネットで新幹線の時刻表がわかります 期末テスト 熊 味噌汁 ポルトガル 無料 ましょうか フロント 鶏肉 いつが暇ですか 土曜日と日曜日 2020-4-11私たちのチームはその試合で負けた 彼は荷物を網棚にあげた 彼女は耳がよく聞こえません 彼は会社の近くに住んでいる 彼は私にノートパソコンをくれました テストを始めてください 私は朝、シャワーを浴びます どちら 美しい そこには私一人しかいなかった 千円貸してください 違う 開く テーブル 終わり 私の机の上に書類が沢山あります ソフトクリームを二つください 32ページを開いてください 文章 商品 彼は行政を改革したいと思っている 今回 関する 必要 いずれ 島の人口は年々増加しています テレビ 母は私に飴を買ってくれます 私は宿題をしています それから、南東の有名な牧場に遊びに行きました 美しい なぜ台湾の会社は大学生に雇いたくないのですか 私は彼に使い捨ての箸をあげました 道を迷いました。それで、交番に道を尋ねに行きました この店は高いけれども、全然美味しくありません 飛んで 運んで 遊んで 読んで 住んで 死んで 関する 私は旅行会社の人にホテルを予約してもらいます カレーライスの方が美味しいでう おじいさんは昔の記憶を忘れたがります お金持ちのくせに、スーパーで散々値切りをしました 母は私に飴を買ってくれました 今夜は蒸し暑いので、蚊がたくさんなりました 最後に、南投から台北に帰りました 私は彼と彼女に誕生日カードをもらいました それで？どうした 彼は妻に昼ごはんの弁当を作ってもらいます 期末テストは大変でした 冷蔵庫リンゴとオレンジが3個あります カレーライスのほうが美味しいです 羊 テレビ 文房具 桜 調味料 フロント 2020-4-10消す 見つける 一緒に 言葉 私は毎日日記をつけています うちに遊びに来てください 私には友達が沢山います 次はいつ会いましょうか 腕 彼はかばんから教科書を出した 入る 一日 答えが違ういます ある お母さんによろしくを伝えください 後ろを向いて 締める お名前をカタカナで書いてください カレーライスは七百円です 与える 事故 昨年 いずれ 予定 へる 利用 行う 私は彼から大きな影響を受けました 以上 電話 パソコンを買いましたが、キーボードがありません 台風の時に、海辺で遊んではいけません 私は彼に使い捨ての箸をあげます この車はとんでもなく高いくせに、すぐ故障します どれが綺麗ですか 今日、何かかいますか はい、オレンジを買います テストはいつですか 明日か明後日か来週ですね 私は日本語がわかります お釣をください 彼女は彼氏に食事代を払ってもらいます 乗客 布団 動物園 本棚 フロント 私は物理の基礎はしています ぜ いずれ フロント 2020-4-9消す ここ そこし疲れました 見つける 彼の車は新しい 十日 窓を開けてください 強い 喉が乾きました そこには私一人しかいなかった 辛い 曲がる ちゃんとドアを閉めてよ こっち 閉じる 時の経つのは早い 与える 対する 結果 二社は互いに競争している 災害に備えて、大量の水を買い込んだ 政権が交代した 島の人口は年々増加しています ほとんど 国会 首相 写真はいい思い出になります それは世界最大の船です 昨年 彼は食品工場で働いています この本を借りてもいいですか いいえ、借りてはいけません 本棚に小説と雑誌がありまあす 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 見つける 私は書店で本を買って、開いて、読む 私は泳ぐこのができます お釣をください 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 石原さんは彼に防虫スプレーをもらいました 与える 母は怒っている 楽しい一日 彼女の彼氏に食事代を払ってもらいます 中村さんは昨日夜十時まで仕事をしましたので、残業代がたくさんもらえるでしょう お母さんは実家に帰ります 机の上にペンが二本あります 昨年 乗客 カード ビール 顎髭 蝉 お釣をください 2020-4-8彼女は耳がよく聞これません 体 髪 決める 弱い 午前 うちに帰ろう なる 手紙が届くのに三日かかりました これは医者のためのサイトです 四つ 男の人が私たちに話しかけた 彼には子供が六人います 口 した 曇る 受付でプログラムを受け取った 彼は選挙に出るつもりだ 受ける ころ 種類 彼はその詩を用いて自分の気持ちを伝えた 毎年多くの人が海外へ旅行する 対策 私たちは二階に上がった もう 企業 目覚し時計をかけたから、なかなかなりません 食べてくれますか 上野さんは彼女と映画を見ました 彼女は私に新しい手帳をくれました 道を迷いました。それで、交番に道を尋ねに行きました 母は怒っています 母は料理の方法がわかります 私は会社に行きます 彼女は彼女の彼氏に食事代を払ってもらいます 彼女は可愛いですが、わがままな人です 母は日本料理を作ることができます お爺さんは昔の記憶を忘れたがります 私は弟と妹と実家に帰りました あの歌手は有名だけれども、歌が下手です 次に、桃園で飛行機を見に行きました 旅行会社は家族に海外旅行のビザを申し込んでくれました 法律を破ってはいけません あの店は高いけれども、全然美味しくありません 犬と猫、どちらが好きですか あの服のほうが可愛いです 宿題をしました。それに、明日の授業の予習もしました トンネル 彼女は彼氏に食事代を払ってもらいます ラーメン 原稿改訂する 夜市 タプレット 医者は、患者の脈をとっている タンス 2020-4-7町で大事件が起こりました 乗る 私たちのチームはその試合で負けた 送る 去年 私には友たちが沢山います 私は絵を見るのが好きです 愛する 今週 髪の毛が伸びたね お先にどうぞ 食べ物 晴れる 時計を見たらちょうど三時だった 米 教科書を閉じてください 直る 今後ともよろしくお願いします 技術 生産 力 彼女は同じ間違いを繰り返した 計算 方針 調査 相手 建設 工場 新しいホームページが完成した ペットを飼いましょう 宿題をしました。それに、明日の授業の予習もしました あの店の料理は美味しいです。それに、値段もとても安いです あのおじいさんは妹に靴を直してくれました 上野さんは彼女と映画を見ました 飛行機が二時間遅れました。なので、到着時間に遅くなりました 父は台湾料理ができます ころ 遊びましょう はい、そうです 次に、桃園で飛行機を見に行きました 陽傘 餌 広告 カバン サイ 調味料はレストランのテーブルによく置いてあります 雄鶏 鶏肉 走る 切る 帰る す ぬ て ざ 2020-4-6軽い 会う まだ 変える この服はとても安かった 後 私たちのチームはその試合で負けた 彼女は耳がよく聞こえません 言う 彼は荷物を網棚に上げた 渇く 上る 金 昼 易しい 月 まずい 予約は要りません お兄さん お母さんによろしくを伝えください 終わり 口を大きく上げてください 新学期は来月の四日からです まま 私たちのチームはその試合で負けた 競争 夢を実現するには努力が必要です 私は四つの会社に投資しています 十分 合格者が発表された ほとんど 増える 彼は就職試験を受けた 東京に来るのは初めてです どこが賑やかですか 弟は父の性格がわかります 日本語先生のくせに、日本語で自己紹介する子こともできません スピーチは何時からですか 道を迷いました。それで、交番に道を尋ねに行きました 授業をしている教師 私は頑張りたくありません 私は友達に本を買ってもらいます 友達は朝九時に家に来ました。そして、夜六時にみんな帰りました 夜市はスーパーよりうるさいです 台風の時に、海辺で遊んではいけません 母は料理の方法がわかります 中華料理 英語からフランス語に翻訳する 体育館 彼女は茶髪で、えくぼがあります 女性がモモの太さを測っている 2020-4-5約束を忘れないでください 難しい 私には友達がたくさんいます 彼女は耳がよく聞こえません 授業 親の愛は有難い 短い 彼の日本語のレベルは私に同じくらいだ 五日 辺 そこには私一人しかいなかった 父 この道を真っ直ぐ行くと駅です 彼に会えて嬉しかった 夕食には何を食べたいですか 黄色い 閉まる 彼女は多分家で寝ています 減る 地域 解決 この車はよく持っているね 情報 一般 それは最近話題の本ですね 銀行は三時まで開いています 影響 評価 ほとんど 生活 この本の内容を説明してください 彼女は耳がよく聞こえません 状態 留学してから私の世界が広がった 全体の80%が完成しました 一緒に対策を考えましょう 選ぶ 外国 私はパソコンで、字を打って、インタネットして、印刷する 次に、桃園で飛行機を見に行きました 台風の時に、海辺で遊んではいけません 電気屋の人は新しいテレビを運んでくれました 書いてくれますか あなたは私にこのDVDをくれますか 彼女は幸せにする 台湾は暑いです 田舎は都市ほど便利ではありません 北川さんはたくさん食べますが、全然太りません このパソコン、使ってもいいですか。 いいえ、使ってはいけません ほとんど 道を迷いでした。それで、交番に道を尋ねに行きました この服とあの服、どちらが可愛いですか ふーん、それで ニュースで道の状況を分かりました あの塾はパートにチラシを配ってもらいます 机の上にペンが二本あります 台風の時に、海辺で遊んではいけません 大人 文房具 竹 その男性は使い捨て髭剃りで顎髭を剃っている 18 18年前 鶏肉 栓抜き ディ 道を迷いました。それで、交番に道を尋ねに行きました 2020-4-4払う 私には友達がたくさんいます 少ない 狭い 彼は荷物を網棚にあげた 帰る 彼に手紙を書きました 短い 一緒に 宿題はまだ終わっていません 春 目 喉が乾きました 強い 一日 酸っぱい 来月の二十日は弟の誕生日です 辛い 月曜日に会いましょう 四日 宇宙人は存在すると思いますか 今後ともよろしくお願いします 島の人口は年々増加しています システムの構成を変えてみました 国は国語教育を強化しています 対策 作業 存在 加える 建設 女性 彼は非常に高い技術を持っている 普及 田村さんは林さんに中国語を教えてもらいます 彼女はマイカーを買いたがります それは小説です 私には友達がたくさんいます パソコンを買いましたが、キーボードがありません 次に、桃園で飛行機を見に行きました 彼は泳いでいます 電気屋の人は私に新しいテレビを運んでくれます 佐々木さんはサラリーマンではありません ペットを飼いましょう クラスを静かにする テレビを付ける あの車はとんでもなく高いくせに、すぐ故障します 庭の松は高くありませんでした 机の上にペンが日本あります あのおじいさんは妹に靴を直してくれました 翻訳する 芸人 中華料理 書店 乗客 炒める 鶏肉 ま 次に、桃園で飛行機を見に行きました 机の上にペンが二本あります 鶏肉 2020-4-3出来る 荷物を網棚にあげた 春 グラスの数が足りません 彼は時々遅刻します お兄さん 月 髪の毛が伸びたね 党の代表が質問に答えました 構造 競争 自由 現在 会議重要な決定がありました 彼は荷物を網棚にあげた 必要 その問題に関する記事を読みました 全国 発生 これは世界最大の船です より のち 国会 体重がかなり減りました 今後 変わる 計画を一部変更しましょう 彼の妻は彼に昼ごはんの弁当を作ってあげました お釣をください 誰もいません 私は彼に使い捨ての箸をあげました 傘は長いです 氷山が小さくなる ご飯を食べる時に、テレビを見てはいけません どれも要りません 床に蟻がいます 冬は暖かかった 中村さんは昨日夜十時まで仕事をしましたので、残業代がたくさんもらえるでしょう ペットを飼いましょう 何で学校に行くのですか あのおじいさんは妹に靴を直してくれました 台風 皿 箸 アジア プレゼント 買い物カートは空です アリクイ サイ ましょうか か しょ ペットを飼いましょう あのおじいさんは妹に靴を直してくれました 2020-4-2私が払いましょう 置く おこる そう 起こす くれる 赤ん坊が笑っています 髪 喉が乾きました こっち 私はこの辺に住んでいる 終わり 8 辛い 手紙が届くのに三日かかりました 悪い 触る お兄さん そこには私一人しかいなかった 髪の毛が伸びたね 金 彼女は眠いようです 閉める 話 増える ガソリンの価格がどんどん上がっている いい方法思いつきました 調べる 会談の内容は発表されました 構造 この段階では決断するのはまだ早い 彼は一人旅の計画を立てた 彼は選挙に出るつもりだ 交差点で事故が発生した 用いる 相手 競争 今後ともよろしくお願いします 彼は実家に帰りたがります お兄さん プールで泳ぎます 先生は難しい本を読むことができます 上野毛が伸びたね 競争 私は書いた原稿を本にする 最近雨の日が多いです。それに、台風もにこ来ました まず、台北のお寺と夜市に行きました 友達は私に本を買ってくれました ゴミ箱にペットボトルがあります 誰もいません あのおじいさんは妹に靴を直してくれます バイクのほうが便利です 私はサラリーマンで、父親です 彼女は飛行機を運転することができます 楽しい一日 レポート ハエ ペット 雄鶏 あのおじいさんは妹に靴を直してくれます 2020-4-1一緒に うちの息子は大学一年生です 図書館で、料理の本を借りた かなり 勝つ 右 家に帰ろう 顔 水 喉が渇きました 起きる 出す 冷たい 辛い 彼はかばんから教科書を出した 曲がる 曜日を間違いました 食べ物 時の経つのは早い 見つかる まあ今回は許してあげよう 株 今後ともよろしくお願いします 経済 昨日の会議について報告があります まず相手の動きを見ましょう 減る 東京に来るのは初めてです 対策 交渉 喉が渇きました ソフト 試合の相手は誰ですか これは大きな社会問題になっている 彼は行政を改革したいと思っている 問題 辛い 事件 研究 ダムの開発に住民は反対しています 導入 話 私の嫌いなことはバスケットをすることです 彼は小学校の先生なので、毎日四時ちょうどに家に帰りました タバコを吸ってはいけませんか はい、吸ってはいけません 今後ともよろしくお願いします 彼女は私に新しいノートをくれました あの公園は綺麗で、静かで、有名です 電気屋の人は私に新しいテレビを運んでくれました 私は日本語が大体できます お金持ちのくせに、スーパーで散々値切りをしました 高野さんは私に英語を教えてくれます あの店は高いです。ですが、全然美味しくありません 今夜は蒸し暑いから、明日は雨が降るでしょう 私はあなたにデジタルカメラをおらいました 佐々木さんは大学生です、私も大学生です 夏は涼しくありません 合格点 布団 乗客 アジア 文房具 フォーク ペットボトル 香水 雑誌 私は物理の基礎は知っています 雄鶏","link":"/zh-tw/japanese/2020/April/index.html"},{"title":"November 2018","text":"2018/11/30The result of my target yesterday ‘The Wondering’ sharing was perfectily done. having learnt the purpose of $remote_addr and $proxy_add_x_forwarded_forAchieved except for set target yesterdayDescription Today’s target go deeper into apache and nginx config git linux 2018/11/29The result of my target yesterday having learnt how to use apache with php-fpmAchieved except for set target yesterday having completed backend challenge of second roundDescription Today’s target go deeper into apache and nginx config share git in ‘The Wondering’ 2018/11/28The result of my target yesterday backend challenge was completedAchieved except for set target yesterday DescriptionToday’s target go deeper into apache config 2018/11/27The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target aws ec2, eip, security group server default environment apache, nginx installation and config","link":"/zh-tw/schedule/2018/November/index.html"},{"title":"April 2019","text":"2019/4/30The result of my target yesterday node.js Implementing MVC on Express.js docker English Japanese achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/29The result of my target yesterday English docker Japanese Node.js Working on documentation of GCP Mountain hiking achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/28The result of my target yesterday English docker Japanese Node.js Working on documentation of GCP IWD worker achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/27The result of my target yesterday English docker Japanese Node.js Build an app server with express.js achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/26The result of my target yesterday English Japanese Node.js Go deeper into event loop What’s event loop Every phase in event loop timers I/O callbacks idle, prepare poll check close callbacks achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/25The result of my target yesterday English Japanese Node.js Parsing request bodies Understanding the concept of event driven Blocking and Non-Blocking Code Roughly reading through event loop achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/24The result of my target yesterday English Japanese Node.js module create a rudimentary server end a loop get information we want from request define response rudimentary request routing achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/23The result of my target yesterday English Japanese Get deeper into Docker Write down current progressAchieved except for set target yesterdayDescriptionToday’s target English Japanese Node.js 2019/4/22The result of my target yesterday English Japanese Get deeper into Docker Completed my first image made by Docker commitAchieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/21The result of my target yesterday English Japanese Get deeper into Docker Docker commit Achieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/20The result of my target yesterday English Japanese Get deeper into Docker docker tag, docker push, docker volume, docker save Achieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/19The result of my target yesterday English Japanese Finish Inboxer project Get deeper into Docker Create a MySQL container and connect to it while another MySQL is installed locally. That is, I could connect to two MySQLs in the server. Achieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/18The result of my target yesterday English Japanese Finish Inboxer project Still wait for DNS to update for SSL signature Achieved except for set target yesterdayDescriptionToday’s target English Japanese Finish Inboxer project Get deeper into Docker 2019/4/17The result of my target yesterday English Japanese Complete CentOS document with Docker Achieved except for set target yesterdayDescriptionToday’s target English Japanese Finish Inboxer project 2019/4/16The result of my target yesterday English Japanese Inboxer project Quote the translation feeAchieved except for set target yesterdayDescriptionToday’s target English Japanese Complete CentOS document with Docker 2019/4/15The result of my target yesterday English Japanese Inboxer project Initially completed deploying and send-mail function Achieved except for set target yesterdayDescriptionToday’s target English Japanese Inboxer project Quote the translation fee 2019/4/14The result of my target yesterday English Japanese GCP event Achieved except for set target yesterdayDescriptionToday’s target English Japanese Inboxer project 2019/4/13The result of my target yesterday English Japanese GCP Essentials review Working on docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Event 2019/4/12The result of my target yesterday English Japanese GCP Essentials review Working on docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Kubernetes and Load Balance 2019/4/11The result of my target yesterday English Japanese GCP Essentials review Working on docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/10The result of my target yesterday English Japanese GCP Essentials review Go deeper into docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/9The result of my target yesterday English Japanese GCP Essentials review Docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/8The result of my target yesterday English Japanese GCP Essentials review Go deeper into Docker - Overlay Network Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/7The result of my target yesterday English Japanese GCP Essentials review Go deeper into Docker - Swarm and Service Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/6The result of my target yesterday English Japanese GCP Essentials review Docker - containerAchieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/5The result of my target yesterday English Japanese GCP Essentials review Docker - image Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/4The result of my target yesterday English Japanese GCP Essentials review Go deeper into Docker Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/3The result of my target yesterday English Japanese GCP Essentials review Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/2The result of my target yesterday English Japanese GCP Essentials review 1~3 Laracasts-Laravel_5.7_From_Scratch No time for it Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review 2019/4/1The result of my target yesterday English Japanese GCP Essentials - Kubernetes Quick Start Laracasts-Laravel_5.7_From_Scratch Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Laracasts-Laravel_5.7_From_Scratch","link":"/zh-tw/schedule/2019/April/index.html"},{"title":"December 2019","text":"2019/12/31Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2019/12/30Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Exercise Squat 2019/12/29Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Write down how to deploy Jenkins with Laradock Others: Implement continuous delivery in carSharing project 2019/12/28Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Deploy Jenkins with Laradock 2019/12/27Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/26Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/25Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/24Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/23Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/22Target and result today Work: Learning: Kubernetes English Japanese Laravel Linux Others: Deploy all of my side projects 2019/12/21Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2019/12/20Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2019/12/19Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/18Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/17Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/16Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/15Target and result today Work: Learning: English Japanese Laravel Linux Others: Hackathon 2019/12/14Target and result today Work: Learning: English Japanese Laravel Linux Others: Hackathon 2019/12/13Target and result today Work: Learning: English Japanese Laravel Linux Others: Mountain hiking 2019/12/12The target I set today Work: BeePay v1.4.0 Besides work: NGINX Linux English Japanese Laravel Kubernetes BeePay code reading The result of today’s target Work: BeePay v1.4.0 Besides work: NGINX Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/11The target I set today Work: BeePay v1.4.0 Besides work: Linux English Japanese Laravel Kubernetes BeePay code reading The result of today’s target Work: BeePay v1.4.0 Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/10The target I set today Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading The result of today’s target Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/9The target I set today Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading The result of today’s target Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/8The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/12/7The target I set today Work: Besides work: GDG Linux English Japanese Laravel The result of today’s target Work: Besides work: GDG Linux English Japanese Laravel 2019/12/6The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/5The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/4The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/3The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/2The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/12/1The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel","link":"/zh-tw/schedule/2019/December/index.html"},{"title":"August 2019","text":"2019/8/31the result of my target yesterday Task: Working on logParsing and inserting project Still working on it Working on Stackdriver course 2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on Stackdriver Logging - Using BigQuery and Stackdriver to Analyze BigQuery Usage Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Linux English Japanese 2019/8/30the result of my target yesterday Task: Working on logParsing and inserting project Still working on it Working on Stackdriver course 2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing and inserting project Working on Stackdriver course 2 Linux English Japanese 2019/8/29the result of my target yesterday Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing and inserting project Working on Stackdriver course 2 Linux English Japanese 2019/8/28the result of my target yesterday Task: Finish Netdata Still working on it Finish Stackdriver course 1 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese 2019/8/27the result of my target yesterday Task: Finish Netdata Still working on it Finish Stackdriver course 1 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese 2019/8/26the result of my target yesterday Task: Start a new Quest on QwikLab Finish Cloud FUnction document Not yet, do Stackdriver first. Finish Node course episode 2 Not yet, haven’t finished Stackdriver Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese 2019/8/25the result of my target yesterday Task: Finish QwikLab Baseline: Infrastructure Finish The Wondering presentation next week Post at least an article of QwikLab Improve my resume Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Start a new Quest on QwikLab Finish Cloud FUnction document Finish Node course episode 2 Linux English Japanese 2019/8/24the result of my target yesterday Task: Working on Netdata and MongoDB Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish QwikLab Baseline: Infrastructure Finish The Wondering presentation next week Post at least an article of QwikLab Improve my resume Linux English Japanese 2019/8/23the result of my target yesterday Task: Working on customer-dashboard Was assigned to do another work Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on Netdata and MongoDB Linux English Japanese 2019/8/22the result of my target yesterday Task: Working on customer-dashboard Still working on it Finish GCP Cloud IAM: Qwik Start Still no time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Linux English Japanese 2019/8/21the result of my target yesterday Task: Working on customer-dashboard Still working on it Finish GCP Cloud IAM: Qwik Start Still no time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/20the result of my target yesterday Task: Working on customer-dashboard Still working on it Finish GCP Cloud IAM: Qwik Start No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/19the result of my target yesterday Task: Post GCP Cloud Storage Qwiklab start: SDK/CLI Finish GCP Cloud IAM: Qwik Start Still haven’t finished yet Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/18the result of my target yesterday Task: Post GCP Storage Qwiklab start: Console Finish GCP Storage Qwiklab start: SDK/CLI Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Post GCP Cloud Storage Qwiklab start: SDK/CLI Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/17the result of my target yesterday Task: Release checkEdgeAlive asynchronous beta version Release checkEdgeAlive process-block-proof shell script Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Post GCP Storage Qwiklab start: Console Finish GCP Storage Qwiklab start: SDK/CLI Linux English Japanese 2019/8/16the result of my target yesterday Task: Build new site with SSL certificate Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Release checkEdgeAlive asynchronous beta version Release checkEdgeAlive process-block-proof shell script Linux English Japanese 2019/8/15the result of my target yesterday Task: Optimise checkEdgeAlive to reduce the Datastore read time Add a time response on DNS Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Build new site with SSL certificate Linux English Japanese 2019/8/14the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Optimise checkEdgeAlive to reduce the Datastore read time Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise checkEdgeAlive to reduce the Datastore read time Add a time response on DNS Linux English Japanese 2019/8/13the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Still working on it Optimise checkEdgeAlive to reduce the Datastore read time Initially completed the cost part, and going to remove unnecessary code Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Optimise checkEdgeAlive to reduce the Datastore read time Linux English Japanese 2019/8/12the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Optimise checkEdgeAlive to reduce the Datastore read time Linux English Japanese 2019/8/11the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Not yet QQ Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Linux English Japanese 2019/8/10the result of my target yesterday Task: Refactor checkEdgeAlive Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Linux English Japanese 2019/8/9the result of my target yesterday Task: Figure out how logParser works Suspended temporarily Completed logrotate documentation Suspended temporarily Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Refactor checkEdgeAlive Linux English Japanese 2019/8/8the result of my target yesterday Task: Figure out how deploy works Will focus on logParser first Completed logrotate documentation No time for it yet Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out how logParser works Completed logrotate documentation Linux English Japanese 2019/8/7the result of my target yesterday Task: Figure out what lerna is Completed Figure out what yarn workspace is Completed Completed logrotate documentation No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out how deploy works Completed logrotate documentation Linux English Japanese 2019/8/6the result of my target yesterday Task: Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Completed logrotate documentation Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out what lerna is Figure out what yarn workspace is Completed logrotate documentation Linux English Japanese 2019/8/5the result of my target yesterday Task: Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out what lerna is Figure out what yarn workspace is Completed logrotate documentation Linux English Japanese 2019/8/4the result of my target yesterday Task: Organise GCP Load Balancer Finally completed it Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out what lerna is Figure out what yarn workspace is Linux English Japanese 2019/8/3the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out what lerna is Figure out what yarn workspace is Linux English Japanese 2019/8/2the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Figure out how to use logRotate Completed Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out what lerna is Figure out what yarn workspace is Linux English Japanese 2019/8/1the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Figure out how to use logRotate Teh result is to be seen Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out how to use logRotate Figure out what lerna is Figure out what yarn workspace is Linux English Japanese","link":"/zh-tw/schedule/2019/August/index.html"},{"title":"February 2018","text":"2019/2/28The result of my target yesterday Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Make recipient information only required when a order is paid Achieved except for set target yesterday Solve the problem that the canvas-nest special effect doesn’t work properly on Schedule page DescriptionToday’s target Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Restructure WebSocket 2019/2/27The result of my target yesterday One more section of my Git course Write down an article - how to build a multilingual blog with Hexo Optimize FB online selling project Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Make recipient information only required when a order is paid 2019/2/26The result of my target yesterday My blog - improve the layout Achieved except for set target yesterdayDescriptionToday’s target One more section of my Git course Write down an article - how to build a multilingual blog with Hexo Optimize FB online selling project 2019/2/25The result of my target yesterday Working on the blog, I would like to make a bilingual version Achieved except for set target yesterdayDescriptionToday’s target My blog - improve the layout 2019/2/24The result of my target yesterday Fix the decoded garble problem of my blog Completed a bit, but still working on it Achieved except for set target yesterdayDescriptionToday’s target Working on the blog, I would like to make a bilingual version 2019/2/23The result of my target yesterday Challenge: Facebook optimized selling system - keep optimizing Git course: The presentation Finished first course Write down how to make PayPal payment service work Working on my blog instead Achieved except for set target yesterdayDescriptionToday’s target Fix the decoded garble problem of my blog 2019/2/22The result of my target yesterday Challenge: Facebook optimized selling system Optimize and debug Demo Achieved except for set target yesterdayDescriptionToday’s target Challenge: Facebook optimized selling system - keep optimizing Git course: The presentation Write down how to make PayPal payment service work 2019/2/21The result of my target yesterday Challenge: Facebook optimized selling system - Optimize and debug Optimize images upload function with Laravel way Reorganise and write down how to make PayPal payment service works Achieved except for set target yesterday Challenge: Facebook optimized selling system Added new function that when an order is paid, the buyer will receive a notification email DescriptionToday’s target Challenge: Facebook optimized selling system optimize and debug demo 2019/2/20The result of my target yesterday challenge: facebook optimized selling system - optimize and debug added email update function in update-user-info function Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - optimize and debug optimize images upload function with laravel way reorganise and write down how to make paypal payment service works 2019/2/19The result of my target yesterday challenge: facebook optimized selling system - paypal payment service finally app site is able to use it Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - optimize and debug 2019/2/18 gcp quiklab training course stackdriver: qwik start set up network and http load balancers The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/17The result of my target yesterday gcp quiklab training course completed lessons 6 Achieved except for set target yesterdayDescriptionToday’s target gcp quiklab training course 2019/2/16The result of my target yesterday gcp quiklab training course completed lessons 1~5 Achieved except for set target yesterdayDescriptionToday’s target gcp quiklab training course 2019/2/15 challenge: facebook optimized selling system - paypal payment service completed paypal payment service function The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target gcp quiklab training course 2019/2/14 challenge: facebook optimized selling system - paypal payment service still working on it The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/13 challenge: facebook optimized selling system - paypal payment service still working on it The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/12 challenge: facebook optimized selling system paypal payment service The result of my target yesterdayAchieved except for set target yesterday api revise create new api- get user status DescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/11 challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service still working on it. The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system paypal payment service 2019/2/10 challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service still working on it The result of my target yesterdayAchieved except for set target yesterday challenge: facebook optimized selling system debug optimize DescriptionToday’s target challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service 2019/2/9 challenge: facebook optimized selling system write an article about how to handle allpay payment service paypal payment service still working on it git pro 鳥哥的linux The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service 2019/2/8The result of my target yesterday challenge: facebook optimized selling system write down how to use task scheduling of laravel with crontab to routinely delete expired orders the presentation of hackmd for ‘the wondering’ on 14 february 2019 paypal payment service git pro git object 鳥哥的linux Achieved except for set target yesterday adopted task scheduling of laravel with crontab to routinely delete expired orders DescriptionToday’s target challenge: facebook optimized selling system write an article about how to handle allpay payment service paypal payment service git pro 鳥哥的linux 2019/2/7The result of my target yesterday challenge: facebook optimized selling system write down how to use aws ses find out why ngrok doesn’t work with aws ses it’s caused by the port. Achieved except for set target yesterday adopted task scheduling of laravel with crontab to routinely delete expired orders DescriptionToday’s target challenge: facebook optimized selling system write down how to use task scheduling of laravel with crontab to routinely delete expired orders the presentation of hackmd for ‘the wondering’ on 14 february 2019 paypal payment service git pro 鳥哥的linux 2019/2/6The result of my target yesterday challenge: facebook optimized selling system mail notification system via ses and laravel Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system write down how to use aws ses find out why ngrok doesn’t work with aws ses 2019/2/5The result of my target yesterday challenge: facebook optimized selling system optimize order system for allpay payment service Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system mail notification system via ses and laravel 2019/2/4The result of my target yesterday challenge: facebook optimized selling system third party payment service, allpay Achieved except for set target yesterday git pro: git hash-object -w stdin git cat-file -p checksum DescriptionToday’s target challenge: facebook optimized selling system optimize order system for allpay payment service 2019/2/3The result of my target yesterday challenge: facebook optimized selling system still working on third party payment service, allpay git pro no time for it = = 鳥哥的linux no time for it = = Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service, allpay 2019/2/2The result of my target yesterday challenge: facebook optimized selling system still working on it git pro no time for it 鳥哥的linux no time for it Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux 2019/2/1The result of my target yesterday challenge: facebook optimized selling system ‘the wondering presentation’ instead git pro step into plumbing’s world 鳥哥的linux no time for it Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux","link":"/zh-tw/schedule/2019/February/index.html"},{"title":"January 2019","text":"2019/1/31The result of my target yesterday challenge: facebook optimized selling system revised api instead git pro prepared ‘the wondering’ rehearsal 鳥哥的linux prepared ‘the wondering’ rehearsal Achieved except for set target yesterday block chain knowledgeDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux 2019/1/30The result of my target yesterday challenge: facebook optimized selling system completed api (26/26) git course outline provided to howard Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux2019/1/29 The result of my target yesterday challenge: facebook optimized selling system commpleted api (23/25) git pro prepared git course outline instead 鳥哥的linux prepared git course outline instead Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system git course outline 2019/1/28The result of my target yesterday challenge: facebook optimized selling system commpleted api (22/25) introduction of my blog Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system git pro 鳥哥的linux2019/1/27 The result of my target yesterday ‘the wondering’ presentation next week challenge: facebook optimized selling system completed 3 api Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system introduction of my blog 2019/1/26The result of my target yesterday challenge: facebook optimized selling system working on my blog and linkedin instead. Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system ‘the wondering’ presentation next week 2019/1/25The result of my target yesterday challenge: facebook optimized selling system working on ci with jenkins instead Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/24The result of my target yesterday challenge: facebook optimized selling system completed three apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/23The result of my target yesterday challenge: facebook optimized selling system completed three apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/22The result of my target yesterday challenge: facebook optimized selling system completed three apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/21The result of my target yesterday challenge: facebook optimized selling system completed six apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/20The result of my target yesterday challenge: facebook optimized selling system completed three api Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/19The result of my target yesterday challenge: facebook optimized selling system initially completed api document Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/18The result of my target yesterday challenge: facebook optimized selling system intially confirmed the specification Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system2019/1/17 The result of my target yesterday challenge: facebook optimized selling system initially discussed the feature Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/16The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/15The result of my target yesterday linux: 鳥哥的linux基礎篇 git: pro git build my own blog in github with hexo almost complete personal configuration Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/14The result of my target yesterday linux: 鳥哥的linux基礎篇 suid full name suid’s function and limit git: pro git how to configure your git to save your credentials? what are three level of git configurations? where is the configuration file that git looks for when it comes to system level configuration? where is the configuration file that git looks for when it comes to global level configuration? how to ignore files globaly in git? build my own blog in github with hexo i’m still working on it, still some issues to be solved. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git build my own blog in github with hexo 2019/1/13The result of my target yesterday iron man award ceremony Achieved except for set target yesterday completed presentation for ‘the wondering’ on 17 january 2019DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git reorganize those presentations i’ve made from keynote to hackmd the first commit 沒遇到這些事之前，我也覺得我git超屌 episode 1 沒遇到這些事之前，我也覺得我git超屌 episode 2 沒遇到這些事之前，我也覺得我git超屌 episode 3 沒遇到這些事之前，我也覺得我git超屌 episode 4 2019/1/12The result of my target yesterday challenge20181217 rewriting optimize readme the wondering organize git presentation that i’ve shared in ‘the wondering’ presentation for ‘the wondering’ next week 鳥哥的Linux基礎篇 git: pro git Achieved except for set target yesterday build opendata project on aws and so my team members could use it for their interviews in the future.DescriptionToday’s target iron man award ceremony 2018/1/11The result of my target yesterday challenge20181217 rewriting add status code to all the functions revise api document accordingly to restful api. Achieved except for set target yesterday git: if you create a new branch, add a submodule there, and then switch back to a branch without that submodule, what will happen?DescriptionToday’s target challenge20181217 rewriting optimize readme the wondering organize git presentation that i’ve shared in ‘the wondering’ presentation for ‘the wondering’ next week linux: 鳥哥的linux基礎篇 git: pro git 2019/1/10The result of my target yesterday linux: 鳥哥的linux基礎篇 working on swagger api git: pro git working on swagger api challenge20181217 rewriting added customized status code on register, login, and get profile api revise api document accordingly to restful api Achieved except for set target yesterdayDescriptionToday’s target challenge20181217 rewriting add status code to all the functions revise api document accordingly to restful api.2019/1/9 The result of my target yesterday linux: 鳥哥的linux基礎篇 working on swagger api git: pro git working on swagger api challenge20181217 rewriting complete register and login function api with swagger Achieved except for set target yesterdayDescriptionToday’s target challenge20181217 rewriting make api document with swagger2019/1/8 The result of my target yesterday linux: 鳥哥的linux基礎篇 working on challenge20190107 - how to upload a file to aws-s3 via a pre-signed url instead. git: pro git how to stash all the work in all our submodules? how to create a new branch and switch to it in all our submodules? how to use ‘git diff’ in your main project and all your submodules? challenge20181217 rewriting working on challenge20190107 - how to upload a file to aws-s3 via a pre-signed url instead. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting revise api document learn how to use swagger 2019/1/7The result of my target yesterday had a wonderful getaway yesterday.Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting revise api document 2019/1/6The result of my target yesterday linux: 鳥哥的linux基礎篇 git: pro git practice submodule challenge20181217 rewriting complete transferring to restful apiAchieved except for set target yesterdayDescriptionToday’s target have a getaway today. 2019/1/5The result of my target yesterday linux: 鳥哥的linux基礎篇 git: pro git practice submodule challenge20181217 rewriting publish api document on github page, and sign ssl certificateAchieved except for set target yesterday how to build a blog with hexo DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting optimize api to restful api 2019/1/4The result of my target yesterday linux: 鳥哥的linux基礎篇 what’s chattr [+-=] [asacdistu] how to search placed command in lunux? git: pro git how to check if we find a bug after a lot of commits made, and we have no idea when and where the code went wrong? how to revise submodule url? what does 160000 mode means when commit a submodule? how to make a submodule? a better diff for submodule? challenge20181217 rewriting complete ‘aws deployment’ DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting publish the api document on github page 2019/1/3The result of my target yesterday linux: 鳥哥的linux基礎篇 how to execute cat command with value got previously in linux? git: pro git what’s the progress of cloning project with submodule in? if, in master branch, i reset with a sha1 from develop branch, what would happen? how to specify lines with git blame? how to show where it’s originally copied from with git blame? challenge20181217 rewriting complete ‘optimizing payment controller’ DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting deploy on aws2019/1/2 The result of my target yesterday linux: 鳥哥的linux基礎篇 ‘wondering’ rehearsal instead git: pro git ‘wondering’ rehearsal instead challenge20181217 rewriting complete ‘deposit common achievement’ DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting optimize payment controller2019/1/1 The result of my target yesterday linux: 鳥哥的linux基礎篇 what’s default authority when creating a file? what’s the default umask? so what’s the final default authority? how to see default umask? how to set umask? what’s the correct way of calculating final authority after deducting umask? git: pro git challenge20181217 rewriting do a linebot challenge held by howard instead DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting deposit achievement","link":"/zh-tw/schedule/2019/January/index.html"},{"title":"July 2019","text":"2019/7/31the result of my target yesterday Task: Organise GCP Load Balancer Completed testing, and going to write a documentation Figure out how to use logRotate No time for it Optimise CICD on api-server project Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out how to use logRotate Linux English Japanese 2019/7/30the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Initially completed Figure out how to use logRotate No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out how to use logRotate Optimise CICD on api-server project Linux English Japanese 2019/7/29the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Figure out how to use logRotate No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Figure out how to use logRotate Linux English Japanese 2019/7/28the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Figure out how to use logRotate No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Figure out how to use logRotate Linux English Japanese 2019/7/27the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Figure out how to use logRotate Linux English Japanese 2019/7/26the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Linux English Japanese 2019/7/25the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown We’ve got some progress Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Linux English Japanese 2019/7/24the result of my target yesterday Task: Build new sites Organise pm2 config Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Linux English Japanese 2019/7/23the result of my target yesterday Task: Trace edgeOnline API Initially found the issue, going to test it Organise pm2 config No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Build new sites Organise pm2 config Linux English Japanese 2019/7/22the result of my target yesterday Task: Organise GCP Load Balance No time for it Organise pm2 config Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Trace edgeOnline API Organise pm2 config Linux English Japanese 2019/7/21the result of my target yesterday Task: Organise GCP Load Balance No time for it Organise pm2 config Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balance Organise pm2 config Linux English Japanese 2019/7/20the result of my target yesterday Task: Observe new LB, and if every thing goes well, delete all previous VMs Build CICD for all of the projects Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balance Organise pm2 config Linux English Japanese 2019/7/19the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Initially completed, and going to observe it further Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Observe new LB, and if every thing goes well, delete all previous VMs Build CICD for all of the projects Linux English Japanese 2019/7/18the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/17the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Shutdown qcdn-job and move the job to another VM Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/16the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Shutdown qcdn-job and move the job to another VM Linux English Japanese 2019/7/15the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Fix eon_v3 DNS issue Initially completed, but still have something to discuss with Raymond before closing this issue Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Fix eon_v3 DNS issue Linux English Japanese 2019/7/14the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Fix eon_v3 DNS issue Initially fixed it, but still have some problems to discuss Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Fix eon_v3 DNS issue Linux English Japanese 2019/7/13the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Fix eon_v3 DNS issue Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Fix eon_v3 DNS issue Linux English Japanese 2019/7/12the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Added a feature sending event notification to Slack channel Completed Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/11the result of my target yesterday Task: Trace customer-api code to find out what might cause huge Datastore read It seems that either cloud-api and cloud-customer-api is not the cause of this issue. Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/10the result of my target yesterday Task: Trace customer-api code to find out what might cause huge Datastore read Still working on it Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Trace customer-api code to find out what might cause huge Datastore read Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/9the result of my target yesterday Task: Optimise CI with pm2 Still working on it Publish my article regarding pm2 Still working on it Trace customer-api code to find out what might cause huge Datastore read still tracing Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Trace customer-api code to find out what might cause huge Datastore read Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/8the result of my target yesterday Task: Optimise CI with pm2 Still working on it Publish my article regarding pm2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise CI with pm2 Publish my article regarding pm2 Trace customer-api code to find out what might cause huge Datastore read Linux English Japanese 2019/7/7the result of my target yesterday Task: Change CI with pm2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise CI with pm2 Publish my article regarding pm2 Linux English Japanese 2019/7/6the result of my target yesterday Task: Change CI with pm2 Still working on it Turn off loadAccessLog, bandwidthUsage, and emptyGzLogRemover API Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Linux English Japanese 2019/7/5the result of my target yesterday Task: Change CI with pm2 Still working on it Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Turn off loadAccessLog, bandwidthUsage, and emptyGzLogRemover API Linux English Japanese 2019/7/4the result of my target yesterday Task: Change CI with pm2 Analyse the bill Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese 2019/7/3the result of my target yesterday Task: Configure ShadowSocks client setting Change CI with pm2 Make ShadowSocks automatically restart after reboot and shutdown the instance Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Analyse the bill Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese 2019/7/2the result of my target yesterday Task: Configure ShadowSocks sever setting Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Configure ShadowSocks client setting Change CI with pm2 Make ShadowSocks automatically restart after reboot and shutdown the instance Linux English Japanese 2019/7/1the result of my target yesterday Task: Make a pm2 document Still working on it Make a Let’s Encrypt document and publish it Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese","link":"/zh-tw/schedule/2019/July/index.html"},{"title":"June 2019","text":"2019/6/30the result of my target yesterday Task: Complete FTP server document and publish it Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Make a pm2 document Make a Let’s Encrypt document and publish it Linux English Japanese JavaScript 2019/6/29the result of my target yesterday Task: Make PM2 document, and optimise every VM Still working on it Made a FTP server for internal deployment Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Complete FTP server document and publish it Linux English Japanese JavaScript 2019/6/28the result of my target yesterday Task: Auto sign three sites with Let&#39;s Encrypt Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Make PM2 document, and optimise every VM Linux English Japanese JavaScript 2019/6/27the result of my target yesterday Task: Figure out how pm2 works and optimise VMs with pm2 Partially Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Auto sign three sites with Let&#39;s Encrypt Linux English Japanese JavaScript 2019/6/26the result of my target yesterday Task: Understand how Cloud Function works Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out how pm2 works and optimise VMs with pm2 Linux English Japanese JavaScript 2019/6/25the result of my target yesterday Task: Optimise VMs Re-purged failed edges Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Understand how Cloud Function works Linux English Japanese JavaScript 2019/6/24the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese JavaScript 2019/6/23the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/22the result of my target yesterday Task: Made eov_v3 work Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/21the result of my target yesterday Task: Working on EON_V3 Make domain column accepts array Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese 2019/6/20the result of my target yesterday Task: Working on EON_V3 Completed CI Completed revising, the service is working now. Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on EON_V3 Make domain column accepts array Linux English Japanese 2019/6/19the result of my target yesterday Task: The handover of the work with Eddie I was told to work on project EON_V3 first Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on EON_V3 Linux English Japanese 2019/6/18the result of my target yesterday Task: The handover of the work with Eddie Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: The handover of the work with Eddie Linux English Japanese 2019/6/17the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese JavaScript 2019/6/16the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/15the result of my target yesterday Task: Edge and Site API Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/14the result of my target yesterday Task: Working on DNS function Completed Working on Site and Edge API Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Edge and Site API Linux English Japanese 2019/6/13the result of my target yesterday Task: Working on DNS function Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on DNS function Linux English Japanese 2019/6/12the result of my target yesterday Task: Working on DNS function Finished GCP Cloud DNS Service part Linux English Japanese JavaScript No time for it achieved except for set target yesterdaydescriptiontoday’s target Task: Working on DNS function Linux English Japanese 2019/6/11the result of my target yesterday Task: Have a meeting with ST, Raymond, and OY Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on DNS function Linux English Japanese JavaScript 2019/6/10the result of my target yesterday Task: Figured out how to add a Load-Balancing with gcloud Got stuck on SSH issue instead. However, I learnt something from it. Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Have a meeting with ST, Raymond, and OY Linux English Japanese 2019/6/9the result of my target yesterday Task: Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript Today I will go out with friends for dinner, I hope that I will still finish my schedule achieved except for set target yesterdaydescriptiontoday’s target Task: Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript 2019/6/8the result of my target yesterday Task: Transfer the drawing from HackMD to Draw.io Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript Today I will go out with friends for dinner, I hope that I will still finish my schedule 2019/6/7the result of my target yesterday Task: Discuss with Raymond to finalize initial version, and discuss with ST Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Transfer the drawing from HackMD to Draw.io Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript 2019/6/6the result of my target yesterday Task: Discuss with Raymond to finalize initial version of programming process drawing and make it with draw.io Raymond pointed out some errors, to be revised and resubmitted Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Discuss with Raymond to finalize initial version, and discuss with ST Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript 2019/6/5the result of my target yesterday Task: Revised the data path according to the discussion yesterday. Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Discuss with Raymond to finalize initial version of programming process drawing and make it with draw.io Linux English Japanese 2019/6/4the result of my target yesterday Task: Completed logic part and compare with ST’s data path Completed first version of scratch, and had a discussion with Raymond Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Revised the data path according to the discussion yesterday. Linux English Japanese 2019/6/3the result of my target yesterday Task: Add new Japanese vocabulary card Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Completed logic part and compare with ST’s data path Linux English Japanese 2019/6/2the result of my target yesterday task: add new japanese vocabulary card Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Add new Japanese vocabulary card Linux English Japanese 2019/6/1the result of my target yesterday Task: Working on architecture of Cloud API Initially finished Ready Pool and Bootstrap Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: add new japanese vocabulary card Linux English Japanese","link":"/zh-tw/schedule/2019/June/index.html"},{"title":"November 2018","text":"2019/3/31The result of my target yesterday Deploy jenkins for openData Laracasts-Laravel_5.7_From_Scratch Achieved except for set target yesterdayDescriptionToday’s target GCP Essentials - Kubernetes Laracasts-Laravel_5.7_From_Scratch 2019/3/30The result of my target yesterday Write down how to do jenkins deployment Deploy ‘backendOfMobileGames’ and ‘openData’ Achieved except for set target yesterdayDescriptionToday’s target Deploy jenkins for openData Laracasts-Laravel_5.7_From_Scratch 2019/3/29The result of my target yesterday AWS Deployment: jenkins deployment Achieved except for set target yesterdayDescriptionToday’s target Write down how to do jenkins deployment Deploy ‘backendOfMobileGames’ and ‘openData’ 2019/3/28The result of my target yesterday AWS Deployment Completed supervisor and queue setting Achieved except for set target yesterdayDescriptionToday’s target AWS Deployment: jenkins deployment 2019/3/27The result of my target yesterday AWS Deployment Still working on it Achieved except for set target yesterdayDescriptionToday’s target AWS Deployment 2019/3/26The result of my target yesterday Laracasts-Laravel_5.7_From_Scratch Episode 6-11 Achieved except for set target yesterdayDescriptionToday’s target AWS Deployment 2019/3/25The result of my target yesterday Laracasts-Laravel_5.7_From_Scratch Episode 1~5 Achieved except for set target yesterdayDescriptionToday’s target Laracasts-Laravel_5.7_From_Scratch 2019/3/24The result of my target yesterday Write down how to use queue with sqs Prepare interview tonight Well, the interview was rescheduled because the interviewer was indisposed. Achieved except for set target yesterdayDescriptionToday’s target Laracasts-Laravel_5.7_From_Scratch 2019/3/23The result of my target yesterday Write down how to use Supervisor to manage queue work with sqs Completed Supervisor part, and will work on sqs part today. Prepare interview tonight The interview time was changed to tonight. Achieved except for set target yesterdayDescriptionToday’s target Write down how to use queue with sqs Prepare interview tonight 2019/3/22The result of my target yesterday Figure out how to use Supervisor to manage queue work Write down how to use Supervisor to manage queue work ‘The Wondering’ presentation Achieved except for set target yesterdayDescriptionToday’s target Write down how to use Supervisor to manage queue work with sqs Prepare interview tonight 2019/3/21The result of my target yesterday Figure out how to use SQS to send email Recap GCP Essentials Achieved except for set target yesterdayDescriptionToday’s target Figure out how to use Supervisor to manage queue work Write down how to use Supervisor to manage queue work ‘The Wondering’ presentation 2019/3/20The result of my target yesterday Complete FB selling side project’s ReadMe Recap GCP Essentials Achieved except for set target yesterdayDescriptionToday’s target Figure out how to use SQS to send email Recap GCP Essentials 2019/3/19The result of my target yesterday Write down Ray’s git flow Complete FB selling side project’s ReadMe Not yet completed, but working on it. Achieved except for set target yesterdayDescriptionToday’s target Complete FB selling side project’s ReadMe Recap GCP Essentials 2019/3/18The result of my target yesterday The Wondering presentation. Optimize FB online selling project Achieved except for set target yesterdayDescriptionToday’s target Write down Ray’s git flow Complete FB selling side project’s ReadMe 2019/3/17The result of my target yesterday The Wondering presentation. Optimize FB online selling project Phone validation and address validation Mail system Achieved except for set target yesterdayDescriptionToday’s target The Wondering presentation. Optimize FB online selling project 2019/3/16The result of my target yesterday Optimize FB online selling project Still working on the mail system for refund Achieved except for set target yesterdayDescriptionToday’s target The Wondering presentation. Optimize FB online selling project Phone validation and address validation Mail system 2019/3/15The result of my target yesterday Write down how to use PayPal payment service I’ve done it! Optimize FB online selling project If possible, I will go validation today! Achieved except for set target yesterdayDescriptionToday’s target Optimize FB online selling project Phone validation and address validation 2019/3/14The result of my target yesterday Write down how to use PayPal payment service I’m working on it! Optimize FB online selling project Have added refund function on both PayPal and AllPay Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Finish it! Optimize FB online selling project If possible, I will go validation today! 2019/3/13The result of my target yesterday Write down how to use PayPal payment service Finished the refund function of PayPal. Optimize FB online selling project Finished the refund function of PayPal. Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Will start to write this article after AllPay system refund function is completed. Optimize FB online selling project Finish refund function of AllPay 2019/3/12The result of my target yesterday Write down how to use PayPal payment service Almost finished refund function Optimize FB online selling project Almost finished PayPal refund function Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/11The result of my target yesterday Write down how to use PayPal payment service Completed capture authorization function. Optimize FB online selling project Completed capture authorization function. Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/10The result of my target yesterday Write down how to use PayPal payment service Nearly finished a basic transaction with REST API of PayPal Optimize FB online selling project Nearly finished a basic transaction with REST API of PayPal Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/9The result of my target yesterday Write down how to use PayPal payment service Still working on new features Optimize FB online selling project Working on refund feature Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/8The result of my target yesterday Write down how to use PayPal payment service Still working on new features Optimize FB online selling project Working on refund feature Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/7The result of my target yesterday Write down how to use PayPal payment service Already figured out how to use REST API, and now working on how to integrate it into my system Optimize FB online selling project Restructure Currently working on refund function WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/6The result of my target yesterday Write down how to use PayPal payment service still working on figuring out how rest API works Optimize FB online selling project Restructure WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/5The result of my target yesterday Write down how to use PayPal payment service Completed Payment Standard and IPN Message method Optimize FB online selling project Refine payment service Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/4The result of my target yesterday Write down how to use PayPal payment service Still working on it, it’s a epic task! Optimize FB online selling project Restructure Make PayPal page show items and recipient in detail WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/3The result of my target yesterday Write down how to get long-lived and forever token from FB One more section of my Git Course Basically, it’s completed Optimize FB online selling project Restructure WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/2The result of my target yesterday Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Added long-lived token function Achieved except for set target yesterdayDescriptionToday’s target Write down how to get long-lived and forever token from FB One more section of my Git Course Optimize FB online selling project Restructure WebSocket 2019/3/1The result of my target yesterday Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project - Restructure - WebSocket Achieved except for set target yesterdayDescription Went to help 日安 carry the new counter she bought Went to KTV with Lester Today’s target Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project - Restructure - WebSocket","link":"/zh-tw/schedule/2019/March/index.html"},{"title":"March 2020","text":"2020-3-31読む 遠い 私はワインが好きです 安い 見つかる 彼はシートベルト締めた 飲み物 彼女は青い目をしています 口を大きく開けてください 強い 時計を見たらちょうど三時だった 腰 私が手伝いましょう 来年一緒に旅行しましょう 九つ 十日後に帰ります そこには私一人しかいなかった ハワイは4回目です 状態 解決 実施 対象 評価 今回 ほとんど 受ける ここは一方通行です これは重要な書類です 写真はいい思い出になります 報告 減る 種類 増える これら 私にはたくさんのお金が必要だ 段階 情報 会長 対策 方針 強化 あの塾はパートにチラシを配ってもらいます 書店で小説を買いました 使い捨て箸をあげました 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 電気屋の人は私に新しいテレビを運んでくれます 減る あの店の料理が美味しいです。それに、値段も安いです スーパーは夜市ほどうるさくありません ないでください この本、ありてもいいですか 対策 もう夏なのに、陽明山で雪が降りました あの車はとんでもたく高いくせに、すぐ故障します 明日からは夏休みです。でも、宿題がいっぱいあります 私の部屋は小さくて、暗くて、汚いです 文房具 乗客 電気屋の人は私に新しいテレビを運んでくれました 冷蔵庫 中華料理 男性は顎髭がたくさん生えているが頭の毛は少ないです 雄鶏 虹 文房具 乗客 2020-3-30私は毎日、日記をつけています また会いましょう 紙 少し疲れました 鳥が飛んでいます 一緒に 落ちる 住む お先にどうぞ この葡萄は酸っぱいです 九日に荷物が届きます 終わり 来月の二十日は弟の誕生日です 優しい そこには私一人しかいなかった 掛ける 私は夏が大好き 一日 対策 増える 対立 力 合格者が発表された 島の人口は年々増加しています 彼は選挙に出るつもりだ それは最近話題の本ですね この車はとんでもなく高いのくせに、すぐ故障します お釣をください あの日本料理店は広くて、美味しくて、安いです スーパーで野菜、人参、玉葱、そしてジャガイモを買いました そこはここですか 私は本屋で本を買って、開くて、読む 大きくない なぜ大体の店は試食を置きますか どうして台湾の会社は大学生を雇いたくないのですか 私は彼に使い捨ての橋をあげました そこには私一人しかいなかった 対策 増える 電気屋の人は私に新しいテレビを運んでくれました テレビをつけました。しかし、画面がなかなか出ません 書いてくれますか 布 宝石 乗客 あの車はとんでもなく高いくせに、すぐ故障します 中学生 解答 水曜日 雄鶏 18 私は彼に使い捨て箸をあげました 電気屋の人は私に新しいテレビを運んでくれました 乗客 雄鶏 2020-3-29図書館 私は毎日日記をつけています 駅を近くで、食事をした 所 髪 一緒に まだ 町で大事件が起こりました 月 月 悪い 易しい 終わり 昨日、母と話をしました 見つかる 桃を五つください 私は夏が大好き ハワイは4回目いです 渇く 晴れる 茶色 黄色い 引っ越しを業者に頼んだ 種類 状態 この車はよく持っているね 相手 与える 今回 東京に来るのは初めてです 情報 会社 お金はまだ十分があります 髪 一緒に 試合の結果を早く知りたい 終わり それは最近話題の本ですね 比べる 国会 どうして台湾の会社は大学生を雇いたくないのですか 旅行会社の人は家族に海外旅行のビザを申し込んでくれました どうして今日遅刻した 私は紙で鶴を作りました あの公園は綺麗で、静かで、有名です あの塾はパートにチラシを配ってもらいます 夏なのに、陽明山で雪が降りました 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません あの店の弁当は美味しいのに、40元もかかりません 私は茶碗蒸しがあまり嫌いではありません 私は日本語が少しできます 私は冬が嫌いです お釣をください レンタサイクル ましょうか 調味料はレストランのテーブルによく置いてあります へ お釣をください 2020-3-28町で大事件が起こりました 飛行機 付ける 強い 手紙が届くのに三日かかりました 彼は優しい人です 柿の木に実がたくさんなっています いっぱい 彼はかばんから教科書を出した 中心 方向 状態 東京に来るのは初めてです 相手 情報 彼は選挙に出るつもりだ 内容 党の代表が質問に答えました 存在 クラスを静かにする 私の得意なことはギターを弾くことです 大きくなかった 部長は仕事ができます はい、そうです 法律を破ってはいけません 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました あの店の料理が美味しいです。それに、値段も安いです 犬は大きかったです 話はここまでです。あ、それから 彼女は英語の先生で、動物園のボランティアです ひまわりは草より綺麗です 眠くなる 小説 部長 竹 中華料理 マイカー 箸 体育館 ロブスターが岩の上にいる 状態 東京に来るのは初めてです 相手 情報 2020-3-27書く 聞く 国 冬 美しい だめ 来月の二十日はお弟の誕生日です お腹 窓を開けてください 私は父が大好きです 9 上を見いて 彼は選挙に出るつもりだ 評価 関する 受ける 規模 調査 影響 目立つ 加える ほとんど 天気が良くありません。それで、海に行くのやめました 聞いてくれますか 両親は日本に行きます、私も行きます ここは私の学校です ご飯を食べる時に、テレビを見てはいけません ワンピースはスカートより高いです 授業をしている教師 彼は選挙に出るつもりだ 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 楽しい一日 王さんは彼女にギターを弾いてあげました 私は書いた原稿を本にする 役所の人は私たちに案内してくれます ベッドの下にゴキブリがいます 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 教室は静かです 私は歩いて、電車に乗って、バスに乗る 食べて 見て 開けて 寝て 始めて 集めて 忘れて 日本語の先生のくせに、日本語で自己紹介することもできません テレビをつけましたけれども、画面がなかなか出ません 便利な所 もう25歳なのに、両親からお小遣いをもらいます ハンバーガーとコーラ 女性がモモの太さいwお測っている 調味料 腹部 走る 切る 帰る 緑色のセミ フットボール 2020-3-26近い 大学に行ってもっと勉強したいです 彼に手紙を書きました わかる 消す 質問 五日 時の経つのは早い 二つ 父 喉が渇きました 五つ 時計を見たら、ちょどさん時だった これは医者のためのサイトです 一日 服 彼はかばんから教科書を出した 来月の二十日は弟の誕生日です 曲がる 強い 曜日を間違いました 起きる 閉まる 輸入 特徴 問題が一つあります 変化 方針 部長を除く全員が土曜日も働いた 島の人口は年々増加しています 女性 彼は就職試験を受けた この段階では決断するのはまだ早い 地域 建設 従来 その質問に対する答えが見つからなかった 一部 それは全て事実ですか 何曜日が暇ですか 日本は台湾ほど暑くありません テレビをつけました。しかし、画面がなかなか出ません 私は書店で本を買って、開いて、読む 私は日本語を大体できます 来月の二十日は弟の誕生日です お金持ちのくせに、スーパーで散々値切りをしました 見てくれますか えっと、電車が遅れましたので、遅刻しました タバコを吸ってはいけません インターネットで新幹線の時刻表がわかります 私は日本語ができます 彼女は日本語先生で、動物園のボランティアです テストはいつですか 明日か、明後日か、来週ですね 授業をしている教師 私の嫌いなことは部屋を掃除することです 私は懐石料理が一番好きです 私の嫌いなことはブスケットをすることです 友達は朝九時に家に来ました。そして、夜六時にみんなにかえりました あの店の料理は美味しいです。それに、値段も安いです 友達は朝九時に家に来ました。それて、夜六時に身なんに帰りました ハエ 湖 乗客 アジア 中華料理 私は物理の基礎は知っています ロブスター 18 2020-3-25払う 質問のある方はどうぞ 彼はかばんから教科書を出した 太い わかった人は手を上げてください 易しい 千円貸してください 火曜日 店員は若い女の人でした 晴れる 彼は昼過ぎにきます 甘い 自分 愛する 冷たい 曲がる 黄色い 強い 月 最近 国会 語る 彼女はアメリカの企業で働いています ほぼ 彼はその詩を用いて自分の気持ちを伝えた 開発 料理がたくさん残りました 予定 私にはたくさんのお金が必要だ 遅れた理由を教えてください 合格者が発表された 受ける この車はよく持っているね そして、台中で有名な湖の隣のホテルに泊まりました この本、借りてもいいですか いいえ、借りてはいけません 彼はかばんから教科書を出した 彼女は可愛いけれども、わがままな人です 母は私に飴を買ってくれました 飲み物を買いません 買いてくれますか ここの公務員は暇なくせに、文句を言います 何も食べません あの塾はパートにチラシを配ってもらいます 宮澤さん、課長のことを、どう思いますか 強い テレビを見ました。それから、テストの勉強をしました 日本語が上手になる 道を迷ういました。それで、交番に道を尋ねに行きました 上手なコック 高野さんは私に英語を教えてくれます いつが暇ですか 土曜日か日曜日 私は学生ではありません 森に熊がいます 私は父と食事をしました 小林さんは中国語ができます この店の料理は美味しいです。それに、値段もとても安いです もう朝なのに、なかなか起きることができません 中華料理 楓 雨の後、虹が見られるかもしてません 栓抜き 顎髭 18 ましょうか あの店の料理は美味しいです。それに、値段も安いです 中華料理 18 2020-3-24笑う 町で大事件が起こりました 私が行きましょう 月 お先にどうぞ 他 時計を見たらちょうど三時だった 優しい 月 冷たい 一日 手紙が届くのに三日かかりました 晴れる 黄色い 五月五日は祝日です 手伝う 昨日、あなたのお姉さんにあったよ 出す 住宅 それは最近話題の本ですね 党の代表が質問に答えました より 昭和 調べる 存在 彼は食品工場で働いています この車はよく持っているね 評価 昨日の会議について報告があります 優しい 受ける 彼は新製品に興味を示している 生産 ほとんど 報告 島の人口は年々増加しています 写真はいい思い出になります 黄色い 昨日、どこに行きましたか。昨日、コンサートに行きました ゴミ箱にペットボトルがあります 旅行会社の人は家族に海外旅行のビザを申し込んでくれました すみません、今何時ですか 買いてくれますか もう夏なのに、陽明山で雪が降りました 和食といえば、寿司や味噌汁や天ぷらなどです 台湾は日本より暑いです 冬は暖かくありません この車はよく持っているね 受ける 私は料理を作ることができます 彼女はボウリングができます ください はい、そうです 竜巻 レタス 布団 折りたたみ傘 箸 な 書いてくれますか 2020-3-23約束を忘れないてください うちの息子は大学一年生です 彼はタオルで顔を拭きました 広い 終わる 肩 私は毎日日記をつけています まだ 全部 悪い 曜日を間違いました 晴れる 火曜日に会議があります この靴は一万円です この葡萄は酸っぱいです 十日後に帰ります ソフトクリームを二つください 夜 後ろ 一日 時計を見たらちょうど3時だった お米 決定 けれは行政を改革したと思っている 内容 命令 島の人口は年々増加しています 試合の相手は誰ですか 力 この建物の構造は複雑です 十分 方針 なお、雨の場合は中止です もう 存在 新聞 商品 との代表が質問に答えました 晴れる 一日 時計を見たらちょうど三時だった 島の人口は年々増加しています まあ今回は許してあげよう ほとんど 前売券は窓口で販売しています 評価 存在 目覚し時計をかけたのに、なかなか鳴りません 当の代表が質問に答えました 日本、ヨーロッパ、そしてアメリカを旅行しました 授業をしている教師 庭の松は高いです 楽しい一日 夜中にギターを弾いてはいけません 書いて 引いて 描いて このパスコン、使ってもいいですか いいえ、つけっはいけません ほとんど 晴れる 評価 お金持ちのくせに、スーパーで散々値切りをしました それで、これからどうします はい、そうです 私は日本の神社を参拝しました。あ、それから、お守りも買いました 先生はクラスメートに綺麗な絵本を貸してあげます 私はご飯を食べて、テレビを見て、宿題をする 傘は長くありません クラスを静かにする この絵は綺麗なのに、誰も買いません 旅行会社の人は家族に海外旅行のびざを申し込んでくれます はい、そうです 旅行会社の人は家族に海外旅行のびざを申し込んでくれます 苺 箸 隣人 期末レポート 体育館 駅弁 田舎 フクロウが頭を上下に動かしている 2020-3-22妹は平仮名を全部覚えました 彼女はイタリア語が出来ます 彼はまだ若いです 宿題は自分でやりなさい 水曜日 起きる 渇く 曜日を間違いました 時の経つのは早い 喉が渇きました 手紙が届くのに三日かかりました 加える 結果 事務的な処理に一週間かかります 方針 生まれる 必要 情報 評価 銀行 普及 国会 ここが私の家です その問題関する記事を読みました 多く 販売 会議は重要な決定がありました 今回 影響 合格者が発表された 旅行会社の人は家族に海外旅行のビザを申し込んでくれました 曜日を間違いました あの絵が綺麗なのに、誰も買いません 授業をしている教師 テレビをつけましたが、画面がなかなか出ません まず、台北のお寺と夜市に行きました 台南に遊びに行きました。そして、美味しいものをたくさん食べました かい お金持ちのくせに、スーパーで散々値切りをしました 方針 もう25歳なのに、両親からお小遣いをもらいます 最近雨の日が多いです。それに、台風もにこ来ました あの塾はパートにチラシを配ってもらいます 今日は何曜日ですか あなたはあなたの弟にケーキをあげますか 飛行機が二時間遅れました。なので、到着時間に遅くなりました 狭い部屋 お金を振り込んだくせに、商品が全く来ません スーパーで野菜、人参、玉葱、そしてジャガイモ買いました 楽しい一日 レンタカー 原稿改訂する コイン ハエ 消しゴム 海 茶髪 授業をしている教師 女性がモモの太さを測っている 私は物理の基礎は知っています 蝉 男性は顎髭がたくさん生えているが、頭の毛が少ないです ましょうか ま 楽しい一日 2020-3-21うち 覚える まだ 少し疲れました 今月はとても忙しい 起きる マン 喉が乾きました お先にどうぞ 手紙が届くのに三日かかりました 入る 上 答える ため 発生 私たちは今結婚資金を貯めています 国会 合格者が発表された 完成 トラブルがやっと解決した 明日は市民マラソンに参加します それはどういう意味ですか 技術 それは最近話題の本ですね 解決 消える ドル 国は国語教育を強化しています 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 起きる 私のノートはどれですか 明日からは夏休みだけれども、宿題がいっぱいあります 喉が渇きました 台南に遊びに行きました。それから、美味しいものをたくさん食べました ご飯を食べます 手紙が届くのに三日かかりました それから、南投の有名な牧場に遊びに行きました 友達は朝9時に家に来ました。そして、夜6時にみんな帰りました 国会 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです 合格者が発表された 夏なのに、陽明山で雪が降りました 旅行会社の人は家族に海外旅行のビザを申し込んでくれました 私は日本料理を作ることが全然できません まず、次に、そして、それから、最後に 私はピーマンが嫌いです どうして遅刻した 話はここまでです。あ、それから 私は風邪を引きました。なので、映画館に行きませんでした 机の上に雑誌があります 明日からは夏休みです。でも、宿題がいっぱいあります お金持ちのくせに、スーパーで散々値切りをしました 弟は父の性格がわかります ご飯を食べる人 彼は泳いでいます 何を食べますか 定食とうどんとラーメンです 大きな竜巻 ハエ 竹 魔法瓶 大人 アジア あの塾はパートにチラシを配ってもらいます 書店 ティーカップ ましょうか お金持ちのくせに、スーパーで散々値切りをしました 私は物理の基礎は知っています ハエ ましょうか 私は物理の基礎は知っています 2020-3-20町で大事件が起こりました 作る 次 学校は8時半に始まります 彼に手紙を書きました 起こる いつ 男の人は私たち話しかけた 曲がる 夕食には何を食べたいですか ご飯 お腹が空きました お先にどうぞ 新学期は来月の四日からです 口 六つ 出す 父 これはかなり金がかかった 六日前に日本に帰ってきました 教科書を閉じてください 私はパンよりご飯が好きだ 写真はいい思い出になります 生活 加える この段階では決断するのはまだ早い 強調 彼は非常に高い技術を持っている 関する 影響 女性 ほとんど この車はとんでもなく高いです、すぐ故障します クラスを静かにする 私はご飯を食べています 私はあなたにプレゼントをあげましたよね ジーンズを買いましょうか 私はあなたに宿題の答えを教えてあげます 私は宿題をしています ゲームをしました 電気屋の人は私に新しいテレビを運んでくれます 弟は家に帰りました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました この服とあの服、どちらが可愛いですか 私は本屋で本を買って、開いて、読む 次に、桃園で飛行機を見に行きました お先にどうぞ 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます あなたは先生ですか 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 弟は私に部屋を掃除してくれました 夏なのに、陽明山で雪が降りました 役所の人は私たちに道を案内してくれます 彼女は可愛いですが、わがままな人です あの店は高いです。ですが、全然美味しくありません 明日の食券をください 夜中にギターを弾いてはいけません 私の部屋は狭くて、暗くて、汚いです 大きくて 小さくて 広くて 狭くて 羊 体育館 サツマイモは、焼いてもあげても美味しい 栓抜き 夏なのに、陽明山で雪が降りました 2020-3-19彼は走るのが速い 日記 白い 私は毎日日記を付けています 右 いつも この葡萄は酸っぱいです 時の経つのは速い あれはなんですか 閉まる 悪い 上る 四つ 私の机の上に書類がたくさんあります 冷たい 曲がる 息子は六つになりました 部分 それは最近話題の本ですね 加える よく答えがわかりましたね ほとんど 今日の新聞、どこに置いた 私達は二階に上がった 関する ゴミのリサイクルが普及している 彼は一人旅の計画を立てた 地域 写真はいい思い出になります 彼は行政を改革したいと思っている 実施 影響 調べる 目的 評価 友達は朝9時に家に来ました。そして、夜6時にみんな家に帰りました 加える ほとんど 写真はいい思い出になります 影響 彼は社長でした タバコを吸ってはいけませんか いいえ、吸ってもいいですよ あの喫茶店は静かですから、あそこでテストの勉強をしましょう 先生はクラスメートに綺麗な絵本を貸してあげます 石原さんは彼に防虫スプレーをもらいました 法律を破ってはいけません この服とあの服、どちらが可愛いですか どれが美しいですか ゴミ箱にペットボトルがあります このパソコンを、使ってもいいですか はい、使ってもいいですよ あの日本料理店は広くて、美味しくて、安いです 新しいゲームソフトを買いました。それで、古いソフトを売りました 天気が良くありません。それで、海に行くのをやめました お金を振り込んでくせに、商品が全く来ません ニュースで道の状況を分かります この店は高いです。ですが、全然美味しくありません 見てください そして、台中の有名な湖の隣のホテルに泊まりました アジア 梅 キャベツ 博物館 買い物カートはからです ましょうか 夜市は賑やかです 2020-3-18体 軽い まだ 私は毎日、日記をつけています 母と電話で話しました うちの息子は大学一年生です 家に遊びに来てください 私は朝シャワーを浴びます 町て大事件が起こりました 嫌い この葡萄は酸っぱいです 朝9時からミーテイングが始まった 愛する 百 悪い 夏休みももう終わりだ 男の人が私たちに話しかけた 時の経つのは早い 私は腕時計を4つ持っています 水曜日はバイトがあります 姿 試合の相手は誰ですか 新しいホームページが完成した それは最近話題の本ですね 私は毎日、日記を付けています 対する 対策 計算 彼は行政を改革したいと思っている 彼は就職試験を受けった 彼は新製品に興味をしましている この葡萄は酸っぱいです 引っ越しを業者に頼んだ 規模 評価 まあ今回は許してあげよう 悪い 新しいゲームソフトを買いました。それで、バイト代が全部なくなりました 引き出しにハムスターが一匹います 時の経つのは早い テレビをつけました 私はパソコンで字を打って、インターネットして、印刷する 課長は電話しています 最近、雨の日が多いです。それに、台風も二個来ました ゴミ箱にペットボトルがあります 国仲さんはあなたにジータをもらいました 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 友達朝9時に家に来ました。そして、夜6時にみんな帰りました それは最近話題の本ですね クラスを静かにする この本、借りてもいいですか いいえ、借りてはいけません 評価 母は弟にオモチャを買ってあげました どうして台湾の会社は大学生を雇いたくないのですか 庭に松があります 林さんは田村さんに中国語を教えてあげます 林さんは私にコンサートのチケットをくれました 体育館 プレゼント アジア カレーライス 皿 年齢 女性がモモの太さを測っている 調味料はレストランのテーブルによく置いてあります ましょうか 切る 走る 帰る 友達は朝9時に家に来ました。そして、夜6時にみんな帰りました アジア ましょうか 2020-3-17会う 町で大事件が起こりました 難しい 言う 歩く 呼ぶ この部屋は寒いです 父 見つかる 曲がる これは医者のためのサイトです 十日後に帰ります 出す よう 冷たい 六日 五日 ばん 閉める 調べる 株 昨日の会議について、報告があります 実現 会議で重要な決定がありました これから、より一層努力します お金はまだ十分あります これら 災害に備えて、大量の水を買い込んだ 町で大事件が起こりました 理由 情報 作業 私はご飯を食べて、テレビを見て、宿題をしました 母は私に飴を買ってくれました 課長は電話しています 彼は社長ではありません ワンピースはスカートより高いです 眠くなる 何曜日が暇ですか 短い鉛筆 クラスを静かにする 彼は小学校の先生なので、毎日四時ちょうどに家に帰りました して 来て なんでこんな時間に学校にいないのですか インタネットで新幹線の時刻表がわかります 寮の管理員は郵便物をみんなのメールボックスに入れてあげます タバコを吸ってはいけません 私は書店で本を買って、開いて、読む あの塾はパートにチラシを配ってもらいます 楽しい一日 私は先月台湾を旅行しました どこが賑やかですか 私はサラリーマンで、父親です 二月に日本を旅行しました。それから、韓国と中国にも行きました お金持ちのくせに、スーパーで散々値切りをしました 布団 記憶 体育館 クラスを静かにする 布 プール 顎髭 説明する 調味料 綺麗 嫌い 有名 男性は顎髭がたくさん生えているが、頭の毛が少ないです そのボトルには2リットルのコーラが入っている ん 体育館 2020-3-16兄は水泳が得意です 見る 美しい ところ 彼は足が長い 今朝は早く家を出ました この中でどれが好きですか 消す 時間 飛行機 使う 重い みんなにお菓子をあげましょう 冷たい 曲がる 十日後に帰ります この道を真っ直ぐ行くと駅です 片仮名 出す 道 父 閉まる 彼は行政を改革したいと思っている 示す 女性 彼は事故で怪我をしました 関する 会談 調べる このアンケートは大学生が対象です まま それで、そうした うちから学校まで 彼は運動場で倒れました。そして、3分後救急車がきました 私懐石料理が非常に好きです テレビをつけましたが、画面がなかなか出ません 冷たい 曲がる ハンバーガーとコーラ 出す 見てくれますか 私は書店で本を買って、開いて、読む 父 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 私は茶碗蒸しがあまり嫌いではあげません お釣をください 明日からは夏休みですが、宿題がいっぱいあります スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 調べる 夜市は賑やかです 本棚に小説と雑誌があります 嫌いな店員 あの店は高いけれども、全然美味しくありません ゲームをしましょう 私は学業を続けたいです 明日からは夏休みです。でも、宿題がいっぱいあります プール 学長 女性がモモの太さを測っている 私は書店で、本を買って、開いて、読む 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 2020-3-15それはとってもいい話だ まだ 行く 短い 起こす 持つ 郵便局で切手を買いました 赤い うちの息子は大学一年生です 彼は真面目な学生です 彼に手紙お書きました そこし疲れました 曇る 大人 左 曜日 情報 関する 信号が青に変わりました 用いる まあ今回は許してあげよう 地域 方向 彼は行政を改革したいと思っている 会議で重要な決定がありました 彼がクラスの代表だ この段階では決断するのはまだ早い 銀行は3時まで開いています 午後一時からです カレーライスのほうが美味しです ゴミ箱にペットボトルがあります 私はあなたに宿題の答えを教えてあげます 何を買いますか カバンか服か化粧品です 関する 本屋で小説を買います 飲み物を買いました もう朝なのに、なかなか起きることができません 台風の時に、海辺で遊んではいけません そっか、今度早く家を出ろ 庭の松は高かったです この車はとんでもなく高いくせに、すぐ故障します 彼は行政を改革したいと思っている 私は納豆が全然好きではありません お金持ちのくせに、スーパーで散々値切りをしました 母は弟にオモチャを買ってあげます あの店の弁当は美味しいのに、40元もかかりません 私の趣味は料理を作ることです 道を迷いました。それで、交番に道を尋ねに行きました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました あの塾はパートにチラシを配ってもらいます 北川さんはたくさん食べましたけれども、全然太りません 竹 ポルトガルはポートワインで有名です 解答 一眼レフカメラ 蟹 クロサイが草原を歩いている スーツケース見つめる 男性は、顎髭がたくさん生えているが、頭の毛が少ないです 女性がモモの太さを測っている スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 女性がモモの太さを計っている 2020-3-14私は日本語の先生になりたいです まだ うちの息子は大学一年生です このドアは引いてください 祖父は病気になった あげる 難しい 一つ 多分 米 要る この携帯電話が使えるのは国内だけです 彼はその詩を用いて自分の気持ちを伝えた それは世界最大の船です 生産 会議で重要な決定がありました まだ 試合の相手は誰ですか 一般の方はこちらの席へどうぞ うちの息子は大学一年生です 今回 予定 実施 変化 情報 この部分は問題ないです ゴミ箱にペットボトルがあります 私は先生と職員室に行きました この本、借りてもいいですか いいえ、借りてはいけません 目覚し時計をかけたのに、なかなか鳴りません 彼女は彼氏に食事代を払ってもらいます あの塾はパートにチラシを配ってもらいます 私は世界一周をしたくありません あなたは国仲さんにゲームソフトをもらいましたよ 話はここまでです。あ、それから 大学の先輩は商売ができます アフリカにきりんがいます 行く 何で学校に行くのですか 見てくれました このノートは私のです ニュースで道の状況がわかります インターネットで新幹線の時刻表がわかります ゴミ箱にペットボトルがあります この車はとんでもなく高いくせに、すぐ故障します 私は学生でした お金持ちのくせに、スーパーで散々値切りをしました あの塾はパートにチラシを配ってもらいます 親切な先生 私は自分の力で仕事を探します この店は高いです。ですが、全然美味しくありません 待ってくれますか 法律を破ってはいけません タプレット 木製のロッキングチェア たつ 男性は、顎髭がたくさん生えているが、頭の毛は少ないです 男性は、顎髭がたくさん生えているが、頭の毛が少ないです お金持ちのくせに、スーパーで散々値切りをしました 男性は、顎髭がたくさん生えているが、頭の毛は少ないです 2020-3-13右 また会いましょう 約束を忘れないでください あげる 親の愛は有難い 触る 休む 細い お米 食べ物 せ 金 彼に会えて嬉しかった 閉まる 答えが違います 地域 規模 まあ今回は許してあげよう 情報 女性 怪我はもう治りましたか 政治 解決 これは重要な書類です このパソコン、使ってもいいですか はい、使ってもいいですよ 彼女は英語先生で、動物園のボランティアです それで、これからどうします あの絵は綺麗です。なのに、誰も買いません 道に迷いました。それで、交番に道を尋ねに行きました 私の嫌いなことはバスケットをすることです 次に、桃園で飛行機を見に行きました 王さんは彼女にギターを弾いてあげます 私は部長のことが嫌いです 台北駅はあそこです 私の趣味は映画を見ることです 眠くなる ワンピースはスカートより高いです 法律を破ってはいけません ふーん、それで 私は日本の神社に参拝しましたよ。あ、それから、お守りも買いました 情報 私は弟に部屋を掃除してもらいます 私は旅行会社の人にホテルを予約してもらいます この本、借りてもいいですか 私は宿題をしています ここの公務員は暇なくせに、文句を言います 昨日、財布をなくしました。それに、傘も電車に忘れました 彼女は彼氏に食事代を払ってもらいます 上野さんは彼女と映画を見ました 母は私に飴を買ってくれました あのおじいさんは妹に靴を直してくれます 昨日、テレビを見ましょう田。それから、テストの勉強をしました 見てくれますか 楽しい一日 食べる人 レシートをください 乗客 布団 フットボール 質問する 調味料はレストランのテーブルによく置いてあります アリクイ 見てくれますか 2020-3-12私は朝、シャワーを浴びます 少し疲れました かなり そう 耳 今年はイタリヤに旅行したい 新学期は来月の四日からです 違う 昨日の会議について、報告があります まあ今回は許してあげよう 女性 発生 いずれ 彼は就職試験を受けた 必要 調査 技術 変わる この段階では決断するのはまだ早い その問題に関する記事を読みました 彼は食品工業で働いています 建設 情報 地域 電気屋の人は私に新しいテレビを運んでくれます 明日からは夏休みだけれども、宿題がいっぱいあります ご飯を食べる時に、テレビを見てはいけません 今夜は蒸し暑いから、明日は雨が降るでしょう 母は怒っています 私の得意なことはギターを弾くことです まあ、今回は許してあげよう 女性 眠くなる 基隆の夜市は有名で、賑やかです なぜ大体のお店は試食を置きますか 母は私に飴を買ってくれます タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 字を書く ワンピースはスカートより高いです この本、借りてもいいですか いいえ、借りてはいけません 何を買いますか カバンか服か化粧品です 情報 地域 あの歌手は有名だけれども、歌が下手です 病人が元気になる 森に熊がいます たかったです この絵が綺麗です。なのに、誰も買いません あの塾はパートにチラシを配ってもらいます うそ 彼は泳いでいます 眠くなる 私は新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 最近雨の日が多いです。それに、台風もにこ来ました ワンピースはスカートより高いです ポルトガル メロン チケット かっこいい 脈を取る 顎髭 2020-3-11私は友達のところに泊まった 家から学校までは遠いです そこし疲れました 彼に手紙を書きました 起こす 昼 十日後に帰ります これは医者のためのサイトです 手伝う 五つ 直る 来月の一日は空いていますか ハワイは4回目です 開発 のちに 試合の相手は誰ですか 参加 彼は行政を改革したいと思っている 実施 結果 この建物の構造は複雑です ないでください 書いてください 楽しい一日 日本は台湾ほど暑くありません 基隆の夜市は有名で、賑やかです 給料をたくさんもらうくせに、全然仕事をしません 少し疲れました この車はとんでもなく高いくせに、すぐ故障します いつが暇ですか 土曜日か日曜日 あの店は高いです。ですが、全然美味しくありません 私は茶碗蒸しがあまり嫌いではありません 彼女は私に新しい手帳をくれました 母は私に飴を買ってくれました 私は石原さんに防虫スプレーをあげました 新しいゲームソフトを買いました。なので、バイト代が全然なくなりました それから、南投の有名な牧場に遊びに行きました 都市は田舎より便利です 母は怒っている この本、借りてもいいですか もう朝なのに、なかなか起きることができません タバコを吸ってはいけませんか はい、吸ってはいけません 彼は妻に昼ご飯の弁当を作ってもらいます ご飯を食べている人 竹 ポルトガル 合格点 布団 討論 月曜日 ませんでした 調味料はレストランのテーブルによく置いてあります 母は飴を買ってくれました この本、借りてもいいですか いいえ、借りてはいけません 2020-3-10子供 ここに本があります グラスの数が足りません その次の週は空いてますか ところ 渇く お姉さん 冷たい 近所で盗難事件が起こりました 輸入 提供 今日は自由な時間が多い 採用 全体の80パーセントが完成しました 今年は変化の多い年でした 電話 関係 力 帰ったらまず手を洗いましょう 管理 去年 昨年 与える この段階では決断するのはまだ早い 彼は就職試験を受けた 重要 何も買いません 彼は妻に昼ご飯の弁当を作ってもらいます 次に、桃園で飛行機を見に行きました そして、南投の有名な牧場に遊びに行きました 楽しい一日 なんで台湾の会社は大学生を雇いたくないのですか 彼は小学校の先生なので、毎日四時ちょうどに家に帰りました 字を書く 飛行機が二時間遅れました。なので、到着時間も遅くなりました テレビをつけましたけれども、画面がなかなか出ません 私はフォークでパスタを食べる もう朝なのに、なかなか起きることができません テレビをつけません 待って 書いて 見て 食べて して 来て 中村さんは昨日夜10時まで仕事をしましたので、残業代がたくさんもらえるでしょう お爺さんは昔の記憶を忘れたがります 弟は父の性格がわかります この本、借りてもいいですか 楽しい一日 田村さん林さんに中国語を教えてもらいます あの店は高いです。ですが、全然美味しくありません 部屋が綺麗になる 明日からは夏休みです。でも、宿題がいっぱいあります 故郷 宝石 書店 布団 小テスト 買い物カート 調味料はラストランのテーブルによく置いてあります もう朝なのに、なかなか起きることができません 調味料 夜市は賑やかです 虹 走る 帰る きる フクロウ 栓抜きありますか あの店は高いです。ですが、全然美味しくありません 布団 調味料はレストランのテーブルによく置いてあります 2020-3-9起こる 消す 払う 肩が凝りました 右 今朝ご飯を作っています 首 ソフトクリームを二つください ご主人 私の机の上に書類がたくさんあります お母さんによろしくを伝えください 五日 オスモさんはみんな力持ちだ 関係 方向 生活 規模 昨日の会議について報告があります 業者 彼は一人旅の計画を立てた 彼は非常に高い技術を持っている この段階では、決断するのはまだ早い もう やる 彼は行政を改革したいと思っている 試合の相手は誰ですか 結果 彼は就職試験を受けた 対策 国は国語教育を強化しています 実施 道を迷いました。それで、交番に道を尋ねに行きました どれが綺麗ですか 次に、登園で飛行機見て見に行きました 彼は運動場で倒れました。そして、三分後救急車が来ました 何で学校に行くのですか 給料をたくさんもらうくせに、全然仕事をしません パソコンを買いましたけれども、キーボードがありません 私にデジタルカメラをくれました 最近雨の日が多いです。知れに、台風も二個来ました ゲームをしました 旅行会社の人は私にホテルを予約してくれました この段階では、決断するのはまだ早い あの塾はパートにチラシを配ってもらいました 法律を破ってはいけません 私は懐石料理がとても好きです 日本、ヨーロッパ、そしてアメリカを旅行しました お釣をください カレーライスとオムライス、どちらが美味しいですか 次に、桃園で飛行機を見に行きました 目覚まし時計をかけたのに、なかなか鳴りません 高野さんは私に英語を教えてくれました あの車はとんでもなく高いくせに、すぐ故障します 私は友達に本を買ってもらいます 大人 部長 紅茶 顎髭 葉が落ちます 2020-3-8引く 待つ 右 彼に手紙を書きました 帰国することに決めました 口 新学期は来月の四日からです 先月の七日に孫が生まれました これは医者のためのサイトです 閉まる 木曜日 風邪 お腹が空きました その二社は対立しています 増加 引越しを業者に頼んだ 目立つ 処理 技術 実施 生産 投資 彼は就職試験を受けた 全国 彼は行政を改革したいと思っている 試合の相手は誰ですか 今の首相はあまり力がない 右 システムの構成を変えてみました 方向 新しいホームページが完成した 友達は私に本を買ってくれました 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 私は日本料理を作ることがよくできます 日曜日が暇です 私は歩いて、電車に乗って、バスに乗る 電気屋の人は私に新しいテレビをい運んでくれます 話はここまでです。あ、それから 床に蟻がいます 実施 彼女はマイカーを買いたがります ボタンを押す 冷蔵庫のケーキ、食べてもいいですか。 はい、食べてもいいですよ 私は日本の神社に参拝しましたよ。あ、それから、お守りも買いました 彼は就職試験を受けた 昨日財布をなくしました。それに、傘も電車に忘れました 目覚し時計をかけたのに、なかなか鳴りません 彼は行政を改革したいと思っている 試合の相手は誰ですか 何を食べますか 定食かうどんかラーメンですね 私は茶碗蒸しをあまり嫌いではありません その車はとんでもなく高いくせに、すぐ故障します 最近雨の日が多いです。それに、台風も二個来ました パソコンを買いましたけれども、キーボードがありません 庭の中に松があります 彼女は英語の先生で、動物園のボランティアです 駅弁 レンタサイクル 写真 原稿改訂する 辞書 パソコン 竹 下手 顎髭 あの車はとんでもなく高いくせに、すぐ故障します 最近雨の日が多いです。それに、台風も二個来ました 顎髭 2020-3-7ところ 両親 次はいつ会いましょうか 一緒に帰りましょう 引く 彼の日本語のレベルは私の同じくらいだ 予約は要りません 冷たい 夕食には何を食べたいですか これは医者のためのサイトです 見つかる 一日 どうしてないているの 今週は日本語のテストがあります 十日後に帰ります 渇く 彼は就職試験を受けた それは全て事実ですか 解決 今回 対する 写真はいい思い出になります 選ぶ 技術 昨日の会議について報告があります 今日は自由な時間が多い 外国 影響 一緒に対策を考えましょう 社会 インターネットで新幹線の時刻表がわかります 日本の神社に参拝しましたよ。 あ、それから。お守りも買いました これは医者のためのサイトです 目覚し時計をかけたのに、なかなか鳴りません 彼は就職試験を受けた 技術 私は茶碗蒸しがあまり嫌いではありません 私の嫌いなことはバスケットをすることです ジュースはコーヒーほど高くありません 台風の時に、海辺で遊んではいけません えっと、電車が遅れましたので、遅刻しました それから、南投の有名な牧場に遊びに行きました 法律を破ってはいけません ニュースで道の状況がわかります ひまわりは草より綺麗です 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 明日からは夏休みです。でも、宿題がいっぱいあります あの塾はパートにチラシを配ってもらいます 電気屋の人は私に新しいテレビを運んでくれました このパソコン、使ってもいいですか いいえ、使ってはいけません 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう テレビを見ました。それから、テストの勉強をしました 私は茶碗蒸しがあまり嫌いではありません 歌手 実家 メモ 携帯ゲーム 牛 餌 スーパー 親戚 教授が図を説明する ロブスター ろ 2020-3-6私はワインが好きです 若い 昨日タイカレーを食べました 払う 美しい 送る 姉は銀行で働いています 彼に手紙を書きました 次はいつ会いましょうか お手洗い 十日後に帰ります 新学期は来月の四日からです 教科書を閉じてください 水曜日はバイトがあります 動く 彼女は眠いようです お米 冷たい 予約は要りません お願い 必要 写真はいい思い出になります 文章 バラには色々な種類があります この建物の構造は複雑です 実現 規模 試合の相手は誰ですか 十日後に帰ります フランスの大統領は誰ですか 可能 彼は就職試験を受けった 冷たい 話 お金はまだ十分あります 新しいホームページが完成した あのおじいさんは妹に靴を直してくれました あの塾はパートにチラシを配ってもらいます ご飯を食べる時に、テレビを見てはいけません 明日からは夏休みです。でも、宿題がいっぱいあります 電気屋の人は私に新しいテレビを運んでくれます 昨日の会議について、報告があります どうしてこんな時間に学校にいないのですか この車はとんでもなく高いくせに、すぐ故障します 旅行会社の人は家族に海外旅行のビザを申し込んでくれました 王さんは彼女にギターを弾いてあげます 彼は就職試験を受けた 部屋が綺麗になす 小林さんは中国語を話すことができます 法律を破ってはいけません 弟は家見帰りました 私はあの人のことが嫌いです あの塾はパートにチラシを配ってもらいました もう朝なのに、なかなか起きることができません それから、南投の有名な牧場に遊びに行きました 明日からは夏休みです。でも、宿題がいっぱいあります 電気屋の人は私に新しいテレビを運んでくれました 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました もう25歳なのに、両親からお小遣いをもらいます 目覚し時計をかけたのに、なかなか鳴りません 法律を破ってはいけません 道を迷いました。それで、交番に道を尋ねに行きました すみません、今は何時ですか 竹 烏龍茶 魔法瓶 鶏 栓抜き 教授が、図を説明する 調味料 茶髪 買い物カートはからです 蝉 炒める それかな、南投の有名な牧場に遊びに行きました 目覚し時計をかけたのに、なかなか鳴りません 2020-3-5近い 彼に手紙を書きました 私 ところ 消す 妹は平仮名を全部覚えました 約束を忘れないてください 彼はタオルで顔を拭きました 高校生 二日 九つ 掛ける 入る 小さに花が咲いています 昨日から腰が痛い 上る 駅はどこですか ご主人 閉める 男の人は私たちに 閉まる 私の机の上に書類がたくさんあります 彼に手紙を書きました 新学期は来月の四日からです 予定 病院 企業 建設 生産 きぼ 彼は行政を改革したいと思っている 昨日の会議について報告があります 試合の相手は誰ですか まあ今回は許してあげよう 道を迷いでした。それで、交番にみちを尋ねに行きました 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 昨日はテレビを見ました。それから、テストの勉強をしました 夜市はどこですか この店は高いですが、全然美味しくありません 何で学校に行くのですか 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 明日の食券をください 夜中にギターを弾いてはいけません タバコを吸ってはいけませんか はい、吸ってはいけません 規模 目覚し時計をかけたのに、なかなか鳴りません 私はパソコンで字を打て、インターネットして、印刷する 私はご飯を食べます 森に熊がいます 彼のお父さんは彼に新しい腕時計をもらいました お釣をください ご飯を食べる時に、テレビを見てはいけません 庭の松が高いです 日本は台湾ほど暑くありません 昨日の会議について報告があります 書いてくれますか 試合の相手は誰ですか あの車はとんでもなく高いくせに、すぐ故障します 私は日本の神社に参拝しました。あ、それから、お守りも買いました 道を迷いました。それで、交番に道を尋ねに行きました ジーンズを買いましょうか 彼女は英語先生で、動物園のボランティアです 話はここまでです。あ、それから プールで泳いでいます あなたのカバンはこれです あの歌手は有名だけれども、歌が下手です 貸して 無くして 出して 戻して どれが綺麗ですか 彼女は可愛いけれども、わがままな人です 目覚し時計をかけたのに、なかなか鳴りません 食べてくれますか あの店は高いけれども、全然美味しくありません リービングのソファで寝ました。それで、風邪をひきました 紅茶 竹 布 レンタサイクル あの車はとんでもなく高いくせに、すぐ故障します 回答 調味料 竹 調味料 あの車はとんでもなく高いくせに、すぐ故障します 2020-3-4戻る ところ 数 消す 弟が車を買った 近く いい 閉まる 四つ ところ 万 私の机の上に書類がたくさんあります 手伝う 平仮名 宿題は自分でやりなさい 九つ こっちに来てください 増加 対象 方針 この建物の構造は複雑です 構造 彼はその詩を用いて自分の気持ちを伝えた 発生 計算 新しいホームページが完成した 最近、株を始めました 方向 彼は食品工場で働いています 彼は行政を改革したいと思っている 生産 これら 彼は小学校の先生なので、毎日四時ちょうどに家に来ました おちりをください 消す 昨日テレビを見ました。それから、テストの勉強をしました 閉まる 私はご飯を食べています 課長は電話しています 今日、何か買いますか いいえ、何も買いません 私はあなたにプレゼントをあげますか 私の机の上に書類がたくさんあります 話はここまでです。あそれから 彼は行政を改革したいと思っている 生産 先生はクラスメートにキレにな絵本を貸してあげます 彼は小学校の先生なので、毎日四時ちょうどに家に来ました お釣をください 私は嫌いなことはバスケットをすることです 私の部屋は小さいくて、暗くて、汚いです みんなは運動会の予定がわかります 私は日本の神社に参拝しましたよ。あ、それから、お守りも買いました 今夜は蒸し暑いので、蚊が多くなりました 私の趣味は野球をすることです 北川さんはたくさん食べましたけれども、全然太りません 日本、ヨーロッパ、そしてアメリカを旅行しました 役所の人は私たちに道を案内してくれました 話はここまでです。あ、それから あの屋敷に幽霊がいますよ どれが綺麗ですか なんで台湾の会社は大学生を雇いたくないのですか 弟は私に部屋を掃除してくれました 道を迷いでした。それで、交番に道を尋ねに行きました 私は日本料理を作ることがまあまあできます 彼は泳いでいます 北川さんはたくさん食べますが、全然太りません 彼女は明日の天気がわかります 中学生 昨日 昨日 社員食堂 18年前 そのボトルには二リットルのコーラが入っている 私は日本の神社に参拝しましたよ。あ、それから、お守りも買いました どれが綺麗ですか 道を迷いました。それで、交番に道を尋ねに行きました 2020-3-3胸 する グラスの数が足りません 辛い お腹 喉が乾きました 食べ物 五つ 茶色 この建物の構造は複雑です 彼は一人旅の計画を立てた 解決 その会社は来月キャンペーンを行う 計画 増える 交差点で事故が発生した 新しいホームページが完成した この建物の構造は複雑です いい方法思い付きました その問題に関する記事を読みました 変化 課長は電話しています 昨日テレビを見ました。それから、テストの勉強をしました 先生はクラスメートに綺麗な絵本を貸してあげます あの公園は綺麗で、静かで、有名です 役所の人は私たちに道を案内してくれます 私は宿題をしています 飛んで 遊んで 読んで 運で 死んで 住んで あの塾はパートにチラシを配ってもらいます インターネットで新幹線の時刻表がわかります 寮の管理員は郵便物をみんなのメールボックスに入れてあげます 長い傘 母は弟にオモチャを買ってあげます 新しいホームページが完成した 彼女は彼氏に食事代を払ってもらいます 友達は朝9時に家に来ました。そして、夜6時にみんな帰りました 弟は父の性格がわかります 彼女は英語先生で、動物園のボランティアです 昨日テレビを見ました。それから、テストの勉強をしました タバコを吸ってはいけません 彼は社長です 私はあなたに宿題の答えを教えてあげます カーテン 芸能人 液晶テレビ 湖 緑色の蝉 ツアーガード フットボール 走る 帰る 切る 雨の後、虹が見られるかもしれません 2020-3-2彼の家に荷物を送りました 住む 彼はまだ若いです 言葉 帰る 会う この道をまっすぐ行くと駅です 五日 お名前を片仮名で書いてください 高校生 三つ 米 八つ 銀行は3時まで開いています 受付でプログラムを受け取った 私は四つの会社に投資しています 対策 必要 方向 構造 生活 これは大きな社会問題になっている 一般の方はこちらの席へどうぞ タバコを吸ってはいけませんか いいえ、吸ってもいいですよ なぜ大体のお店は試食を置きますか 母は弟にオモチャを買ってあげます 彼は泳いでいます 私は頑張りたくありませんでした 私はサラリーマンで、父親です 日本語を上手にする 高野さんは私に英語を教えてくれます 動物園のパンダは小さくありませんでした 私は新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 田村さんは林さんに中国語を教えてもらいます 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 夜中にギターを弾いてはいけません 最後に、南東から台北まで帰りました 法律を破ってはいけません 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません ご飯を食べる時に、テレビを見てはいけません この本、借りてもいいですか いいえ、借りてはいけません あの公園は綺麗で、静かで、有名です 彼女は英語先生で、動物園のボランティアです 日本は台湾ほど暑くありません 買いてくれますか 私の嫌いなことはバスケットをすることです 小西さんはあなたに映画のチケットをあげますか 母はペットと海外旅行をしました 小林さんは中国語を話すことができます 本棚に小説と雑誌があります 私は学生ではありません 彼女は彼氏に食事代を払ってもらいます 卵 液晶テレビ 校長 形容詞 蚊 炒める スーツケースに詰める 彼女は英語先生で、動物園のブランティアです 2020-3-1あの歌手は有名です みんなにお菓子をあげましょう 取る 猫が屋根に上っている 昨日、友達にあった 彼 水曜日はバイトがあります 渇く 治る 商品 トラブルがやっと解決した 残る 計画を一部変更しましょう 今回 運動会は9時開始です 調査 建設 その質問に対する答えが見つからなかった 機能 対策 方向 報告 力 作業 必要 比べる 資金 彼は文章がとてもうまい 方向 必要 森に熊がいます 私は弟に部屋を掃除してもらいます 私は宿題をしています 私は頑張りたくありません 法律をう破ってはいけません 私はあなたに宿題の答えを教えてあげます 田村さんは林さんに中国語を教えてもらいます 父は台湾料理を作ることができます あの絵はとても綺麗なのに、誰も買いません 私は旅行会社のにホテルを予約してもらいます 私は新しいゲームソフトを買いました。それで、バイト代が全部なくなりました 買いてくれますか 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 私の嫌いなことはバスケットをすることです 彼は私にノートパソコンをくれました 私はもっと頑張りたかったです ご飯を食べる時に、テレビを見てはいけません 私はパソコンで字を打って、インターネットして、印刷する あの店は高いですが、全然美味しくありません 日本は台湾ほど暑くありません 私の趣味は本を読むことです あの日本料理店は広くて、美味しくて、安いです 私と妹と弟 何で学校に行くのですか 二月に日本を旅行しました。それから、韓国と中国にも行きました 飛行機が二時間遅れました。それで、到着時間も遅くなります 彼女は可愛いですが、わがままな人です 博物館 私は新しいゲームソフトを買いました。なので、バート代が全部なくなりました 書いてくれますか 昨日の夜、キャベツを食べました 陽傘 乗客 私の嫌いなことはバスケットをすることです 布 キャベツ 広告 フライト 上手 駅弁 羊 ご飯を食べる時に、テレビを見てはいけません 日本は台湾ほど暑くありません","link":"/zh-tw/japanese/2020/March/index.html"},{"title":"May 2019","text":"2019/5/31the result of my target yesterday Task: Working on architecture of Cloud API Started working on Discover Service Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on architecture of Cloud API Linux English Japanese 2019/5/30the result of my target yesterday Task: Working on architecture of Cloud API Initially completed Ready Pool and Bootstrap Help Raymond to check edge condition Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on architecture of Cloud API Linux English Japanese 2019/5/29the result of my target yesterday Task: A meeting in Hsinchu Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on architecture of Cloud API Linux English Japanese 2019/5/28the result of my target yesterday Task: Completed edge-ip-revising API Still working on GCP Cloud DNS documentation Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: A meeting in Hsinchu Linux English Japanese 2019/5/27the result of my target yesterday Task: Completed a course in Qwiklab Watch Game of Thrones instead, I was guilty! Fix my windows computer Containerise HX-API Watch Game of Thrones instead, I was guilty! Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Completed edge-ip-revising API Linux English Japanese 2019/5/26the result of my target yesterday Task add getting new ip feature to monitor api Organising what I have learnt those weeks English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Completed a course in Qwiklab Fix my windows computer Containerise HX-API Linux English Japanese 2019/5/25the result of my target yesterday Task review merge request of monitor api add getting new ip feature to monitor api working on onedgeipchange api English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task add getting new ip feature to monitor api Organising what I have learnt those weeks English Japanese 2019/5/24the result of my target yesterday Task figured out how edge dns works English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task review merge request of monitor api add getting new ip feature to monitor api working on onedgeipchange api English Japanese 2019/5/23The result of my target yesterday Task Comment issue 302~310 Have a meeting with Raymond English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Working on API developing and refactoring. English Japanese 2019/5/22The result of my target yesterday Task Added new feature into monitor API English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Comment issue 302~310 Have a meeting with Raymond English Japanese 2019/5/21The result of my target yesterday Task English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Added new feature into monitor API English Japanese 2019/5/20The result of my target yesterday Task English Japanese achieved except for set target yesterdaydescriptiontoday’s target Organise what I learnt those weeks English Japanese 2019/5/19The result of my target yesterday Organise what I learnt those weeks Completed gitlac CI/CD on GCP virtual machine document organisation English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Figure out checkEdgeAlive API Complete issue 302~310 English Japanese 2019/5/18The result of my target yesterday Organise what I learnt those weeks Organised Gitlab CI/CD English Japanese achieved except for set target yesterdaydescriptiontoday’s target Organise what I learnt those weeks English Japanese 2019/5/17The result of my target yesterday Task I would like to complete API support feature of the healthCheck function, however, it depends on the task English Japanese achieved except for set target yesterdaydescriptiontoday’s target Organise what I learnt those weeks English Japanese 2019/5/16The result of my target yesterday Task Understand the logic of checkEdgeAlive API - Then, we optimise the healthCheck function instead. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task I would like to complete API support feature of the healthCheck function, however, it depends on the task English Japanese 2019/5/15The result of my target yesterday Task Come out with a solution for checkEdgeAlive issue: Completed a health check program to check the health per 10 minutes for temporary solution. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Understand the logic of checkEdgeAlive API English Japanese 2019/5/15The result of my target yesterday Task Initially fixed issue from 302 to 310 English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Come out with a solution for checkEdgeAlive issue English Japanese 2019/5/14The result of my target yesterday Task Understand the logic of API implementation of QCDN. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Solve issue 302~310 English Japanese 2019/5/13The result of my target yesterday Task Understand the logic of API implementation of QCDN. Deploy Node.js project on Google App Engine English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Understand the logic of API implementation of QCDN. English Japanese 2019/5/12The result of my target yesterday Task Figured out how to use breakpoint feature in PHPStorm. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Understand the logic of API implementation of QCDN. English Japanese 2019/5/11The result of my target yesterday Task Have initially completed the database organising, however, still have to change the logic of API implementation. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Figure out how to use IDE breakpoint feature English Japanese 2019/5/10The result of my target yesterday Task Have figured out the logic, still working on it. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Fix siteEdge unmatched data issue English Japanese 2019/5/9The result of my target yesterday English Japanese Task Got siteEdge.host unmatched from either site.host or site.cname Learnt how to build a site achieved except for set target yesterdaydescriptiontoday’s target Task Fix siteEdge unmatched data issue English Japanese 2019/5/8The result of my target yesterday English Japanese node.js How to insert data into datastore achieved except for set target yesterdaydescriptiontoday’s target Task English Japanese 2019/5/7The result of my target yesterday English Japanese A go over with Eddie and Raymond achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/6The result of my target yesterday English Japanese Gitlab CI Load Balance achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/5The result of my target yesterday English Japanese Gitlab CI Load Balance achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/4The result of my target yesterday node.js English Japanese Gitlab CI achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/3The result of my target yesterday node.js English Japanese Gitlab CI achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/2The result of my target yesterday node.js add a new route in Express.js make different routes with different prefixes in Express.js send status code in Express.js docker English Japanese achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese Gitlab CI 2019/5/1The result of my target yesterday node.js Implementing mass delete and get function in GCP Datastore docker English Japanese achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese","link":"/zh-tw/schedule/2019/May/index.html"},{"title":"November 2019","text":"2019/11/30The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/11/29The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/11/28The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/27The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/26The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/25The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/24The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/23The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/22The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/21The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/20The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/19The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/18The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/17The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/11/16The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/15The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/14The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/13The target I set today Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/12The target I set today Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/11The target I set today Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/10The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/9The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/8The target I set today Work: Besides work: Linux English Japanese Laravel BeePay The result of today’s target Work: Besides work: Linux English Japanese Laravel BeePay 2019/11/7The target I set today Work: Besides work: Linux English Japanese Laravel BeePay The result of today’s target Work: Besides work: Linux English Japanese Laravel BeePay 2019/11/6The target I set today Work: Besides work: Linux English Japanese BeePay The result of today’s target Work: Besides work: Linux English Japanese BeePay 2019/11/5The target I set today Work: Besides work: Linux English Japanese BeePay The result of today’s target Work: Besides work: Linux English Japanese BeePay 2019/11/4The target I set today Work: Besides work: Linux English Japanese BeePay The result of today’s target Work: Besides work: Linux English Japanese BeePay 2019/11/3The target I set today Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up The result of today’s target Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up 2019/11/2The target I set today Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up The result of today’s target Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up 2019/11/1The target I set today Work: Besides work: Linux English Japanese Case warm up The result of today’s target Work: Besides work: Linux English Japanese Case warm up","link":"/zh-tw/schedule/2019/November/index.html"},{"title":"January 2020","text":"2020-1-31言う 直ぐ 彼はまだ若いです 大学に行って、もっと勉強したいです 書く 右 勝つ 妹は平仮名を全部覚えました 暑い 来月の二十日は弟の誕生日です 彼女は可愛いけれども、わがままな人です 宿題は自分でやりなさい つける 五日 建設 バラには色々な種類があります 選ぶ もう 理由 生まれる 北川さんはたくさん食べましたけれども、全然太りません 銀行は３時まで開いています いい方法思いつきました 比べる 私たちは二階に上がった 力 計画 彼は非常に高い技術を持っている 加える 彼は文章がとてもうまい テレビをつけましたけれども、画面がなかなか出ません 作業 受付でプログラムを受け取った 彼女は可愛いけれおども、わがままな人です 言う 北川さんはたくさん食べますが、全然太りません 彼女は可愛いけれども、わがままな人です パソコンを買いましたけれども、キーボードがありません 音量を大きくする 私にデジタルカメラをくれました 次に、登園で飛行機を見に行きました 昨日、財布を無くしました。それに、傘も電車に忘れました 彼女は可愛いけれども、わがままな人です 建設 もう 北川さんはたくさん食べましたけれども、全然太りません 私は先月台湾を旅行しました ふーん、それで 犬が大きくありません 北川さんはたくさん食べましたけれども、全然太りません 天気が良くありません。それで、海に行くのをやめました 明日からは夏休みですだけれども、宿題がいっぱいあります テレビをつけましたが、画面がなかなか出ません それから、南投で有名な牧場に遊びに行きました ゴミ箱にペットボトルがあります 彼女は可愛いですが、わがままな人です テレビをつけましたけれども、画面がなかなか出ません スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 最後に、南投から台北に帰りました この店は高いけれども、全然美味し行くありません 彼女は可愛いけれども、わがままな人です 明日からは夏休みだけれども、宿題がいっぱいあります 道を迷いました。それで、交番に道を尋ねに行きました 床に蟻がいます すみません、今は何時ですか 日本、ヨーロッパ、そしてアメリカを旅行しました テレビをつけましたけれども、画面がなかなか出ません あの歌手は有名だけれども、歌が下手です どこが賑やかですか 北川さんはたくさん食べましたけれども、全然太りません 夏なのに、幼名山で雪が降りました 夏なのに、陽明山で雪が降りました 回 私は頑張りたくありません それで、これからどうします 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 夏なのに、陽明山で雪が降りました 台南に遊びに行きました。そして、美味しいものをたくさん食べました 梅 液晶テレビ 夏なのに、陽明山で雪が降りました コンビニ弁当 おやつ 夜市 道を迷いました。それで、交番に道を尋ねに行きました せみ テレビをつけましたけれども、画面がなかなか出ません 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 夏なのに、幼名山で雪が降りました 夏なのに、陽明山で雪が降りました 蝉 2020-1-30学校 もらう 会う わかる 彼女はOLです 笑う カナダの冬はとても寒いです また会いましょう 質問 どれ もう 近所で盗難事件が起こりました 十日後に帰ります 先月の七日に孫か生まれました 受付でプログラムを受け取った ほどんと 比べる 今の首相はあまり力がない これは重要な書類です 結果 備える システムの構成を変えてみました 会談 与える いずれ バラには色々な種類があります あの歌手はトレも有名だけれども、歌が下手です 語る 今日の新聞、どこに置いた 販売 計算 私はフォクでパスタを食べます あの歌手は有名だけれども、歌が下手です 私は先月台湾を旅行します 昨日財布を無くしました。それに、傘も電車に忘れました 飛行機が二時間遅れました。なので、到着時間も遅くなります えっと、電車が遅れたので、遅刻しました 二月に日本を旅行しました。それから、韓国と中国にも行きました 天気が良くありません。それで、海に行くのやめました 明日からは夏休みだけれども、宿題がいっぱいあります 受付でプログラムを受け取った 本棚に小説と雑誌があります 北川さんは沢山食べますが、全然太いません 私は好きなことは音楽を聴くことです あの喫茶店は静かですから、それでテストの勉強をします バラには色々な種類があります 周りが静かになる 私は日本の神社を参拝しました。な、それから、お守りを買いました それで、これからどうします それから、南投の有名な牧場に遊びに行きました 私は先生と職員室に行きました あの歌手は有名だけれども、歌が下手です あのお店は高いけれども、全然お美味しくありません 犬は大きいです 台南に遊びに行きました。そして、お美味しいものをたくさん食べました 天気が良くありません。それで、海に行くのやめました 明日からは夏休みですが、宿題がいっぱいあります 和食と言えば、寿司や味噌汁や天ぷらなどです 明日からは夏休みだけれども、宿題がいっぱいあります 新しいパソコンを買いましたが、キーボードがありません 新しいパソコンを買いましたが、キーボードがありません このノートは私のです 明日からは夏休みだけれども、宿題がいっぱいあります 彼女は可愛いですが、わがままの人です 昨日はテレビを見ました。それから、テストの勉強をしました そのレストランは高いですが、全然美味しくありません 明日から夏休みですけれども、宿題がいっぱいあります テレビをつけましたが、画面がなかなか出ません 最近、雨の日が多いです。それに、台風が二個きました パソコンを買いましたけれども、キーボードがありません そして、台中で有名な湖の隣のホテルに泊まりました 話すはここまでです。な、それから 寂しい とり レンタサイクル 動詞 大人 栓抜き 妹はコップを割った 新しいパソコンを買いましたけれども、キーボードがありません フルート 明日からは夏休みだけれども、宿題がいっぱいあります パソコンを買いましたけれども、キーボードがありません 新しいパソコンを買いましたけれども、キーボードがありません 2020-1-29読む 短い 私は朝シャワーを浴びます もっと 駅からタクシーに乗ってください 元気 彼の日本語のレベルは私と同じくらいだ 素敵な色のセーターですね 午前 彼女は可愛いですが、わがままな人です 探す 言葉 行く わからない場合は私に聞いてください 彼女は可愛いですが、わがままな人です 金曜日の夜は友達と出かけます 弟は野球が好きです 小さい花が咲いています 彼女は可愛いですが、わがままなひとです 触る 茶色 野球は9人で人チームです お腹 泊まる 従来 会長 結果 北川さんはたくさん食べますが、全然太りません 最近、株を始めました 経営 これは重要な書類です まず 計算 その質問に対する答えが見つからなかった 北川さんはたくさん食べましすが、全然太りません 内容 テレビを付けましたが、画面がなかなか出ません 事務的な処理に1週間かかります 彼女は可愛いですが、わがままな人です 彼女は可愛いですが、わがままな人です テレビを付けましたが、画面がなかなか出ません 続ける 結果 増える 彼がクラスの代表だ この店は高いですが、全然美味しくありません 話はここまでです。な、それから パソコンを買いましたが、キーボードがありません これは重要な書類です 私の得意なことはギターを弾くことです 最後に、南投から台北に帰りました 天気が良くありません。それで、海にやめました 私はフォークでパスタを食べます 北川さんはたくさん食べますが、全然太りません 友達は朝九時に家に来ました。そして、夜6時にみんな帰りました なんで台湾の会社は大学生を雇いたくないのですか 彼は運動場で倒れました。そして、三分後救急車が来ました いつが暇ですか 土曜日か日曜日です 宿題をしました。それに、明日の授業の予習もしました 授業をした教師 次に、桃園で飛行機を見に行きました 日本、ヨーロッパ、そしてアメリカを旅行しました この店は高いけれでも、全然おいしくありません まず、台北のお寺と夜市に行きました 和食と言えば、寿司や味噌汁や天ぷらなどです テレビを付けましたが、画面がなかなか出ません 小林さんは中国語を話すことができます それで、どうした 明日からは夏休みですが、宿題がいっぱいあります 天気が良くありません。それで、海に行くのやめました 私はフォクでパスタを食べました 最近、雨の日が多いです。それに、台風もニコ来ました このノートは私のです 何も買いません 私の趣味は本を読むことです 私は彼女のことが好きです 昨日、テレビを見ました。それから、テストの勉強をしました 冷蔵庫に三個のリンゴーとオレンジがあります けえは私のパソコンです あの歌手は有名だけれども、歌が下手です 和食といえば、寿司や味噌汁や天ぷらなどです この店は高いけれども、全然美味しくありません なんでこんな時間に学校にいないのですか それで、これからどうします 私は両親の支えでマンションを買いました 本棚に小説と雑誌があります 私は世界一周をしたくありませんでした お爺さんは昔の記憶を忘れたがります このノートは私のです 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 私は頑張りたくありません メロン 液晶テレビ 水曜日 ９分 キャベツ 大人 ラーメン 北川さんはたくさん食べますが、全然太りません 調味料 サツマイモ 鶏肉 テレビをつけましたが、画面がなかなか出ません あの歌手は有名だけれども、歌がは下手です 栓抜き サイ この店が高いけれども、全然美味しくありません それで、これからどうします 本棚に小説と雑誌があります 大人 北川さんはたくさん食べますが、全然太りません テレビをつけましたが、画面がなかなか出ません 栓抜き 大人 この店が高いけれども、全然美味しくありません 2020-1-28今日は日本語の授業があります 右 郵便局で切手を買いました 持つ 考える 緑 使う 彼に手紙を書きました 出来る 冷たい 答えが違います この店は高いですが、全然美味しくありません 細い 入る 時計を見たら、ちょうど3時だった 昨日、あなたのお姉案に会ったよ 銀行は3時まで開いています 力 これら 変化 資金 彼が来た目的がわかりません 計算 販売 重要 彼は何年も地震の研究をしている この服は三百ドルしました 昨年 このお店は高いですが、全然美味しくありません 対象 方向 二月に日本を旅行しました。それから、韓国と中国にも行きました えっと、電車が遅れたので、遅刻した 彼は運動場で倒れました。そして、三分後救急車が来ました この店の料理は美味しいです。それに、値段もとても安いです リビングのソファで寝ました。それで、風邪をひきました 私は日本料理を作ることが少しできます ないでください 明日からは夏休みですが、宿題がいっぱいあります 国仲さんはあなたにギターをもらいました この店は高いですが、全然美味しくありません まず、台北のお寺と夜市に行きました 日本語を上手にする 最後に、南投から台北に帰りました それで、これからどうします 日本の神社に参拝しましたよ。な、それから、お守りも買いました 宿題をしました。それに、明日の授業の予習もしました いつが暇ですか 土曜日か日曜日です このお店は高いですが、全然美味しくありません 氷山が小さくなる ボタンを押す そして、台中の有名な湖の隣のホテルに泊まります 床に蟻がいます 道に迷いました。それで、交番に道を尋ねに来ました それから、南投の有名な牧場に遊びに行きました 最近、雨の日が多いです。それに、台風もにこ来ました 私は王建民ほど有名ではありません 明日からは夏休みですが、宿題がいっぱいあります パソコンを買いましたが、キーボードがありません。 昨日、財布を無くしました。それに、傘も電車に忘れました それで？これからどうします 隣人 羊 幽霊 液晶テレビ いつが暇ですか 土曜日か日曜日です タプレット スーツケースに詰める 明日から夏休みですが、宿題がいっぱいあります 彼女は茶髪で、えくぼがあります パソコンを買いましたが、キーボードがありません パソコンを買いましたが、キーボードがありません 液晶テレビ 明日から夏休みですが、宿題がいっぱいあります パソコンを買いましたが、キーボードがありません 2020-1-27今月 使う 今朝は早く家を出ました 浴びる いつ 誰と会ってみたいですか 右 重い 起こす 私は朝シャワーを浴びます 聞く 妻 太い お母さんによろしくを伝えください 休む こっち 一日 三日 側 宿題は自分でやりなさい 上る この段階では決断するのはまだ早い 利用 問題が一つあります 商品 資金 相手 計算 全体の80%が完成しました 処理 運動会は9時開始です 住宅 力 いい方法思いつきました 価格 これからより一層努力します 治る 駅の前に新しいコンビニをできました。それから、駅の後ろに新しいコンビニをできました 右 リビングのソファで寝ました。それで、風邪をひきました まず、台北のお寺と夜市に行きました 昨日、財布を無くしました、それに、傘も電車に忘れました 資金 私は先月台湾を旅行しました 計算 友達は朝九時に家に行きました。それから、夜6時に帰りました 友達は朝九時に家に来ました。そして、夜6時にみんな帰りました 日本の神社を参拝しました。な、それから、御守りも買いました 力 最近、雨の日が多いです。それに、台風も二個来ました 最後に、南投から台北に帰りました それから、南投の有名な牧場に遊びに行きました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう あなたは教師ではありません ふーん、それで なぜ台湾の会社は大学生を雇いたくないのですか どれで、どうした そして、台中で有名な湖の隣のホテルに泊まりました 私は納豆が全然好きではありません 私は日本料理を作ることが全然できません スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 昨日財布を無くしました。それに、傘も電車に忘れました このお店の料理は美味しいです。それに、値段もとても安いです 彼は運動場で倒れました。そして、三分後救急車が来ました 道を迷いました。それで、交番に道を尋ねに行きました 日本語を上手にする 次に、桃園で飛行機を見に行きました 床に蟻がいます 駅弁 副詞 西洋料理 中学生 親切 炒める 彼は運動場で倒れました。そして、三分後救急車が来ました 床に蟻がいます 炒める 茶髪 2020-1-26古い 私は朝シャワーを浴びます 国 閉める 昨日、友達にあった 大人 彼は留学生です 掛ける 水曜日はバイトがあります 比べる 消える 銀行は三時まで開いています 理由 遠くに彼女の姿が見えた それは世界最大の船です それから、南投の有名な牧場に遊びに行きました 方向 今後 その会社は女性を多く採用している 彼がパーティー会場を提供してくれました それから、南東の有名な牧場に遊びに行きました 建設 彼は食品工場で働いています 特徴 島の人口は年々増加しています 彼は歌で自分の気持ちを表現した 私は朝シャワーを浴びます 与える ガソリンの価格がどんどん上がっている 前売券は窓口で販売しています 最後に、南東から台北に帰りました まま 台南に遊びに行きました。そして、美味しいものをたくさん食べました ふーん、それで？ 私の嫌いなことは部屋を掃除することです 夜市はスーパーよりうるさいです 二月に日本を旅行しました。それから、韓国と中国にも行きました そして、台中で有名な湖の隣のホテルに泊まりました 次に、登園で飛行機を見に行きました 昨日財布を無くしました。それに、傘も電車に忘れました 私は先月台湾を旅行しました 日本、ヨーロッパ、そしてアメリカを旅行しました お爺さんは昔の記憶を忘れたがります 最近雨の日が多いです。それに、台風も二個きました 向日葵は草より綺麗です それから、南投の有名な牧場に遊びに行きました 最後に、南投から台北に帰りました 私の苦手なことは料理を作る 私の苦手なことは料理を作ることです 話はここまでです。な、それから 私は日本料理を作ることが少しできます まず、台北のお寺と夜市に行きました 昨日はテレビを見ました。それから、テレビの勉強をしました 日本の神社に参拝しましたよ。な、それから、お守りも買いました 道を迷いました。それで、交番に道を尋ねに行きました 車の後ろに子猫と子犬がいます 私のカバンはどれですか 母とペットと海外旅行をしました 私はピーマンが嫌いです 駅の前に新しいコンビニができました それから、南投の有名な牧場に行きました 彼は運動場で倒れました。そして、三分後救急車が来ました 私は石原さんに防虫スプレーをあげました 学長 校長 メロン カーテン 雨の後、虹が見られるかもしれません 私は物理の基礎はしています ㎝ 質問する お 最後に、南投から台北に帰りました 道に迷いました。それで、交番に道を尋ねに行きました 彼は運動場で倒れました。そして、三分後救急車が来ました それから、南投の有名な牧場に遊びに行きました 最後に、南投から台北に帰りました 2020-1-25覚える 国 兄は水泳が得意です 楽しむ 使う 彼は医者になりました 妹は平仮名を全部覚えました 少し疲れました 日本の神社に参拝しましましたよ。な、それから、御守りも買いました 軽い 午後 私が払いましょう 千円貸してください 日本の神社に参拝しましたよ。な、それから、御守りも買いました それはどういう意味ですか 目的 私は先月台湾を旅行しました 全体の八十パーセントが完成しました トラブルがやっと解決した いい方法思いつきました 首相 方向 部長を除く全員が土曜日も働いた 対する まず、台北のお寺と夜市に行きました 状態 これら 帰ったら、まず手を洗いましょう 銀行は三時まで開いています 最近株を始めました よく答えがわかりました 日本の神社に参拝しましたよ。な、それから、お守りを買いました 私は先月台湾を旅行しました 方向 銀行は三時まで開いています まず、台北のお寺と夜市に行きました 中心 よく答えがわかりました 私は神社に参拝しましたよ。な、それから、お守りを買いました 駅の前に新しいコンビニができました。それから、駅の後ろに新しいコンビニができました 昨日財布を無くしました。それに、傘も電車に忘れました 私は日本料理を作ることがあまりできません 日本、ヨーロッパ、そしてアメリカも旅行しました この犬 道に迷いました。それで、交番に道を尋ねに行きました 先月台湾を旅行しました 私はおばあちゃんのことが好きです このお店の料理は美味しいです。それに、値段もとても安いです 天気が良くありません。それで、海に行くのをやめました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 彼は運動場で倒れました。そして、三分後救急車が来ました 私は日本の神社に参拝しましたよ。な、それから、お守りを買いました 昨日、財布が無くしました。それに、傘も電車に忘れました 私は先月台湾を旅行しました なんでこんな時間に学校にいないのですか テレビを見ました。それから、テストの勉強をしました 最近、雨の日が多いです。それに、台風もにこ来ました 何か買いますか いいえ、何も買いません 二月に日本を旅行しました。それから、韓国と中国にも行きました まず、台北のお寺と夜市に行きました 話はここまでです。な、それから 私は学生です 今夜は蒸し暑いから、明日は雨が降るでしょう 友達は朝九時に家にきました。そして、夜六時にみんな帰りました 最近、雨の日が多いです。それに、台風も二個きました すみません、今は何時ですか 次、桃園で飛行機を見に行きました 次に、桃園で飛行機を見に行きました 庭の松は高いです 私は世界一周をしたくありません おじいさんは昔の記憶を忘れたがります 宿題をしました。それから、明日の授業の予習もしました まず、台北のお寺と夜市に行きました 次に、桃園で飛行機を見に行きました 次に、登園で飛行機を見に行きました お爺さんは昔の記憶を忘れたがります それで、これからどうします 台南に遊びに行きました。それから、美味しいものを沢山食べました 弟は父の性格がわかります そして、台中で有名な湖の隣のホテルに泊まりました 小林さんは中国語話すことができます 大学の先輩は商売ができます リング 答え 水族館 そして、台中で有名な湖の隣のホテルに泊まりました 苺 明後日 腿 スーツケース そして、台中で有名な湖の隣のホテルに泊まりました そして、台中で有名な湖の隣のホテルに泊まりました 2020-1-24足 いつも 親の愛は有り難い 決める また会いましょう 元気 腕 違う 七日 最近、雨の日が多いです。それに、台風も二個きました 息子は六つになりました 切る 宿題は自分でやりなさい 六日前に日本に帰ってきました 喉が乾きました 茶色 四日 細い 昨日はテレビを見ました。それから、テストの勉強しました 触る 答える 最近株を始めました 全体の80%が完成しました 昨日はテレビを見ました。それから、テストの勉強をしました 最近、雨の日が多いです。それに、台風を二個きました 姿 与える 対象 管理 のち 飛行機は一時間以上遅れた 新聞 昨日テレビを見ました。それから、テストの勉強をしました 最近、雨の日が多いです。それに、台風も二個きました いい方法を思いついました この携帯電話が使えるのは国内だけです 比べる これら 新しいビルの建設が始まった 女性 二月に日本を旅行しました。それから、韓国と中国にも行きました 最近、株を始めました 段階 やる 一緒に対策を考えましう それで？これからどうします 私の嫌いなことは部屋を掃除することです ふーん、それで？ 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 日本、ヨーロッパ、そしてアメリカを旅行しました 全体の80パーセントが完成しました 昨日はテレビを見ました。それから、テストの勉強をしました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 最近、雨の日が多いです。それに、台風も二個きました 私は日本語が大体できます 昨日財布を無くしました。それに、傘を電車に忘れました いい方法を思いつきました 最近、雨の日が多いです。それに、台風も二個きました これら 昨日テレビを見ました。それから、テストの勉強をしました 台南に遊びに来ました。そして、美味しいものをたくさん食べました 引き出しにハムスターが一匹います 床に蟻がいます その子供は親友と遊びたがります 二月に日本を旅行しました。それから、韓国と中国にも行きました 友達は九時に家に来ました。そして、夜六時にみんな帰りました 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 日本、ヨーロッパ、そしてアメリがを旅行しました なんでこんな時間に学校にいないのですか 彼は運動場で倒れまhした。そして、三分後救急車が来ました そっか、今度早く家を出ろ その店の料理が美味しいです。それに、値段を安いです 話はここまでです。な、それから 小林さんは中国語を話すことができます 宿題をしました。それに、明日の授業の予習もしました 話はここまでです。な、それから 道を迷いました。それで、交番に道を尋ねに行きました リビングのソファで寝ました。それで、風邪をひきました 病人が元気になる 私は日本料理を作ることが少しできます 二月に日本を旅行しました。それから、韓国と忠告もに行きました なんでこんな時間に学校にいないのですか 彼は運動場で倒れました。そして、三分後救急車がきました 小林さんは中国語を話すことができます 道を迷いました。それで、交番に道を尋ねに行きました 話はここまでです。な、それから 二月に日本を旅行しました。それから、韓国と中国にも行きました 私の得意なことはギターを弾くすることです 私は世界一周をしたかったです それで、どうした 国仲さんはあなたにギターをもらいました 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 天気がよりありません。それで、海を行くのをやめました メロン 餌 博物館 話はここまでです。な、それから カード レンタサイクル サツマイモ 茶髪 彼は運動場で倒れました。そして、三分後救急車が来ました 二月に日本を旅行しました。それから、韓国と中国にも行きました 駅の前にコンビニができました。それから、駅の後ろにもコンビニができました 話はここまでです。な、それから 2020-1-23冬 猿も木から落ちる 入れる 生きる 早い 彼女はいい友達です 一日 大人 細い 新しいテープルを買いました 辛い 彼女は眠いようです 予約は要りません 彼は運動場で倒れました。そして、三分後救急車がきました 上る くる 切る これは医者のためのサイトです 与える 最近、雨の日が多いです。それに、台風もにこ来ました 彼は運動場で倒れました。そして、三分後救急車がきました 交差点で、事故が発生した 最近、雨の日が多いです。それに、台風も二個きました お金はまだ十分あります 彼は運動場で倒れました。そして、三分後救急車がきました 彼は運動場で倒れました。そして、三分後救急車がきました 比べる そのデモについて、政府は何もしなかった 変わる 大統領 大学で経済を勉強しました 最近、雨の日が多いです。それに、台風も二個きました 作業 もう 台南に遊びに行きました。そして、美味しいものをたくさん食べました 最近雨の日が多いです。それに、台風も二個きました 日本、ヨーロッパ、そしてアメリがを旅行しました この店の料理は美味しいです。それに、値段もとても安いです リビングのソファで寝ました。それで、風邪をひきました それで、どうした 友達は朝九時に家に来ました。そして、夜六時にみんな帰りました なぜ大体のお店は試食を置きますか 大きくなかった 宿題をしました。それに、明日の予習もしました 国仲さんはあなたにギターをもらいましたよ 最近、雨の日が多いです。それに、台風も二個来ました 彼は運動場で倒れました。そして、三分後救急車が来ました 比べる 彼は運動場で倒れました。そして、三分後救急車が来ました 昨日財布を無くしました。それに、傘も電車に忘れました 私は日本料理を作ることが少しできます 道に迷いました。それで、交番に道を尋ねに行きました 昨日財布を無くしました。それに、傘も電車に忘れました 日本、ヨーロッパ、そしてアメリカを旅行しました 最近雨の日が多いです。それに、台風も二個きました 最近、雨の日が大きです。それに、台風も二個きました この店の料理は美味しいです。それに、値段もとても安いです 国仲さんはあなたにギターをもらいましたよ 宿題をしました。それに、明日の授業の予習もしました 私は日本料理を作ることが少しできます 道に迷いました。それで、交番に道を尋ねに行きました 昨日財布を無くしました。それに、傘も電車に忘れました ふーん、それで あの店の料理が美味しいです。それに、値段もとても安いです ないでください 先生は学生の気持ちがとてもわかります 貯金箱にコインが四十個あります 彼女を幸せにする私のノートはどれですか バカ！言い訳するな！ 上野さんは彼女と映画を見ました 宿題をしました。それに、明日の授業の予習もしました それで、これからどうします スピーチは何時からですか 私はピーマンが嫌いです スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 私は寿司が好きです 天気が良くありません。それで、海に行くのをやめました あれはカーテンです 昨日財布を無くしました。それに、傘を電車に忘れました この店の料理は美味しいです。それに、値段もとても安いです キャベツ メロン 皿 竜巻 茶髪 それで？これからどうします 宿題をしました。それに、明日の授業の予習もしました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 昨日財布を無くしました。それに、傘も電車に忘れました メロン 茶髪 それで？これからどうします？ スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 2020-1-22そう 歩く 待つ 彼の日本語のレベルは私と同じくらいだ 彼の気持ちが分からない 妹は平仮名を全部覚えました 一から始めましょう 飛ぶ ふーん、それで？ 短い うち 会う 戻る 服 まずい 五月五日は祝日です ふーん、それで？ 彼に会えて嬉しかった 強い 入る 辺 米 宿題は自分でやりなさい ふーん、それで？ 赤い線を二本引いて下さい 夕食には何を食べたいですか 私は風邪をひきました 関係 彼がクラスの代表だ やる スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 社会 開始 与える スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 我が社の経営はうまくいっています その会社は来月キャンペーンを置くなう スーパーで野菜、人参、玉葱、そしてじゃがいも買いました ふーん、それで？ 国会が再開した 電気がついたままですよう ふーん、それで？ 建設 可能 日本、ヨーロッパ、そしてアメリカを旅行しました ダムの開発に住民は反対しています 国会 日本、ヨーロッパ、そしてアメリカを旅行しました トラブルがやっと解決した 彼は行政を改革したいと思っている 対策 台南に遊びに行きました。そして、美味しいものをたくさん食べました 外国 与える 川の岸に桜の木があります 道に迷いました。それで、交番に道を尋ねに行きました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 友達は朝九時に家に来ました。そして、夜六時にみんな帰りました それで、これからどうします ドアを開ける どこが賑やかですか どうして台湾の会社は大学生を雇いたくないのですか 日本、ヨーロッパ、そしてアメリカを旅行しました ボタンを押す 日本、ヨーロッパ、そしてアメリカを旅行しました 私はピーマンが嫌いです あの服のほうが可愛いです 台南に遊びにいきました。そして、美味しいものをたくさん食べました 天気が良くありません。それで、海に行くのをやめました あなたは教師です 寝る猫 友達は朝九時に家に来ました。そして、夜六時にみんな帰りました それで、どうした リビングのソファで寝ました。それで、風邪をひきました 道に迷いました。それで、交番に道を尋ねに行きました 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 友達は朝九時に家にきました。そして、夜六時にみんな帰りました 湖 台南に遊びに行きました。そして、美味しいものをたくさん食べました 水族館 海 ペット 羊 炒める ぬ 日本、ヨーロッパ、そしてアメリカを旅行しました 友達は朝九時に家に行きました。そして、夜六時にみんな帰りました それで、どうした 台南に遊びに行きました。そして、美味しいものをたくさん食べました 2020-1-21彼はかなり英語が上手です グラスの数が足りません その次の週は空いていますか 妹は平仮名を全部覚えました また会いましょう あなたが来るのを待っています 天気が良くありません。それで、海に行くのをやめました 祖父が病気になった 彼はまだ若いです 私は手伝いましょう 触る 閉める 道に迷いました。それで、交番に道を尋ねに行きました 風邪 八日からイギリスに行きます 茶色 先月の七日に孫が生まれました 道に迷いました。それで、交番に道を尋ねに行きました 妹は平仮名を全部覚えました 治る ある 一日 来月の二十日は弟の誕生日です 後ろを向いて 天気が良くありません。それで、海に行くのをやめました 手紙が届くのに三日かかりました 天気が良くありません。それで、海に行くのをやめました 宿題は自分でやりなさい 天気は良くありません。それで、海に行くのをやめました 示す 道を迷いました。それで、交番に道を尋ねに行きました 関係 彼は新製品に興味を示している 道に迷いました。それで、交番に道を尋ねに行きました 宿題は自分でやりなさい 天気が良くありません。それで、海に行くのをやめました 道を迷いました。それで、交番に道を尋ねに行きました ここは一方通行です 彼は選挙に出るつもりだ リビングのソファで寝ました。それで、風邪をひきました その質問に対する答えが見つからなかった 繰り返す 対象 留学してから私の世界が広がった 強調 それで、これからどうします 会談 現在 うちは五人家族です 二十キロのダイエットは可能だと思いますか それで、これからどうします それで、どうした 私は鉛筆で字を書く 私の得意なことはギータを弾くことです 飛行機が二時間遅れました。あので、到着時間も遅くなりました それで、どうした 私は紙で鶴を作りました リビングのソファで寝ました。それで、風邪をひきました 私は頑張りたくありません 昨日、何処かに行きましたか はい、コンサートに行きました 私は刺身があまり好きではありません どこが賑やかですか すみません、今は何時ですか それで、これからどうします 昼ごはん 暇 楓 て アパート それで、どうした レンタサイクル それで、これからどうします リビングのソファで寝ました。それで、風邪をひきました 栓抜きありますか 腹部は肋とお尻の間の部分です サツマイモ それで、これからどうします それで、どうした リビングのソファで寝ました。それで、風邪をひきました それで、これからどうします それで、どうした 2020-1-20右 彼女 授業 起こす 食べる 答えが違います 服 どうして泣いているの その人には2回に会った 上る この部屋は寒いです 対象 株 声 もう そっか、今度早く家をでそ これは私の小説です 私はピーマンが嫌いです 私の嫌いなことはバスケットをすることです すみません、今は何時ですか 彼は学校に来ませんでした 授業をする教師 私の得意なことはギターを弾くことです 台北駅はどこですか 今夜は蒸し暑いから、明日は雨が降るでしょう ライブ 下手 大人 ポルトガル 子猫 小学生 マイカー 雨の後、虹が見られるかもしれません サツマイモ 一日 対象 すみません、今は何時ですか 私の得意なことはギターを弾くことです サツマイモ 2020-1-19彼は歯が白い また会いましょう 引く 五月五日は祝日です 触る 側 コップを三つ買いました クーラーはまだ直りません 細い 先 今晩 上る 私は夏が大好き 閉める 茶色 内容 あなたの意見が聞きたいです 政権が交代した 宇宙人は存在すると思いますか 交渉 消える 目立つ 種類 参加 事実 まあ、今回は許してあげよう 方針 対する 増える なぜ大体のお店は試食を置きますか そっか、今度早く家を出ろ すみません、今は何時ですか 深い湖 どうして私の家に来ましたか 私はもっと頑張りたかったです 大学の先輩商売ができます レシートください 私は泳ぐことができます 犬と猫と兎、どれが好きですか 私はピーマンが嫌いです 料理をおいしくする そっか、今度早く家を出ろ すみません、今は何時ですか 私はピーマンが嫌いです 眠くなる ないでください 新しいゲームソフトを買いました。だから、古いソフトを売りました キャベツ レンタサイクル 店長 松 タプレット 高層ビル 一眼レフカメラ 雑誌 炒める 2020-1-18また会いましょう 会議は四時に終わります そこに座ってください 午前九時のニュースです 彼の日本語のレベルは私と同じくらいだ 結婚 三人 触る 口 細い 多分 時 お手洗い 夏休みももう終わりだ 入る 茶色 柿の木に実がたくさんなっています なお雨の場合は中止です かぶ 伴う よく それは最近話題の本ですね その仕事は危険を伴う お相撲さんはみんな力持ちだ 理由 土地 構造 私はフォークでパスタを食べます 冷蔵庫に三つのリンゴとオレンジがあります 私は会社に行きます 私は日本料理が好きです あの屋敷に幽霊がいますよ 動物園にライオンがいます また会いましょう 私は魚が嫌いです ないでください 石原さんは彼に防虫スプレーをもらいました 佐々木さんはサラリーマンでした 触る 細い どこが賑やかですか ボタンを押す 茶色 えっと、電車が遅れたから遅刻しました 台北の夜市は賑やかです。九分も賑やかです ご飯を食べましょう 予備校生 レンタサイクル 液晶テレビ 記憶 ラーメン 海外旅行 羊 ㎝ フクロウ ないでください 2020-1-17あげる 春 素敵な色のセーターですね 入れる 呼ぶ まだ学校へ行くには早い時間です 酒 短い 右 売る 天気 千円貸してください 違う 私はパンよりご飯が好きだ 教科書を閉じてください 私は二日待った 痛い 入る 作業 彼は非常に高い技術を持っている 提供 一部 輸入 システムの構成を変えてみました 彼は文章がとてもうまい 彼は良いだけを強調した 報告 それは世界最大の船です 短い鉛筆 向日葵は草より綺麗です ご飯を食べた人 一時から四時までです 今夜は蒸し暑いから、明日は雨が降るでしょう 私は鉛筆で字を書く 私は寿司が好きです 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう どこが賑やかですか えっと、電車が遅れたので、遅刻した 私は日本語が少しできます カーテン 社員食堂 カレンダー 大きな竜巻 入る 羊 映画 教授が図を説明する 炒める どこが賑やかです 羊 2020-1-16右 それ全部ください 同じ 彼の日本語のレベルは私と同じくらいだ 会う 私が払いましょう 兄は水泳が得意です 一つ 今朝は早く家を出ました 7つ 夕食には何を食べたいですか お腹 曜日を間違えました 上 十日後に帰ります 妻 来月の二十日は弟の誕生日です ゲーム まず相手の動きを見ましょう 彼がクラスの代表だ 二十キロのダイエットは可能だと思いますか 文章 十分 処理 一般 予定 変わる 私は彼から大きな影響受けました 病院 生活 トラブルがやっと解決した 対する 右 合格者が発表された 国は国語教育を強化しています 前売券は窓口で販売しています その問題関する記事を読みました 兄は船の設計をしています 輸入 これは世界最大の船です 計画を一部変更しましょう 飛行機が二時間遅れました。なので、到着時間も遅くなりました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 私は懐石料理がすごくできます 私の嫌いなことは部屋を掃除することです なぜ台湾の会社は大学生を雇いたくないのですか 川の岸に桜の木があります 私は懐石料理が一番好きです ボタンを押す 机の上に雑誌があります 有名な歌手 私は頑張りたくありません 今夜は蒸し暑いから、明日は雨が降るでしょう スピーチは何時からですか キャベツ 親戚 はな 湖 炒める 調味料 雨の後、虹が見られるかもしれません 私は物理の基礎は知っています 今夜は蒸し暑いから、明日は雨が降るでしょう 炒める 2020-1-15親の愛は有り難い 難しい する 彼の日本語のレベルは私の同じ位だ 彼はまだ若いです 一日 これはかなり金がかかった 人 私の妹は小学生です 嬉しい 閉める ここは父の土地です 全国 影響 外国 ほぼ その事件の犯人はまだ捕まっていない その質問に対する答えが見つからなかった 彼女の大きな帽子はとても目立つ 子供の頃よくその公園で遊んだ その会社は来月キャンペーンを行う 今日の新聞、どこに置いた 企業 建設 一般 のち どこも行きません ボタンを押す 彼の日本語のレベルは私と同じくらいだ 私は日本料理を作ることがあまりできません ペットを飼いましょう 日曜日は暇です あの歌手は有名ではありませんでした ご飯を食べている人 翻訳する 博物館 学長 ノートパソコン フルート 雨の後、虹が見られるかもしれません フクロウが頭を上下に動かしている りや みや ボタンを押す 雨の後、虹が見られるかもしれません 2020-1-14この言葉の意味がわかりません また会いましょう 短い 私は朝シャワーを浴びます 彼に会えて嬉しかった 違う 五日 来月の二十日は弟の誕生日です 大丈夫 先月の七日に孫が生まれました 閉める お店はもう閉まっていました お母さんによろしくを伝えください 酸っぱい 今後 工場 期待 二社は互いに競争している 広がる 二十キロのダイエットは可能だと思いますか この携帯電話が使えるのは国内だけです 信号が青に変わりました ほとんど 今回 水を熱くする 宮沢さんは課長のことを、どう思いますか 私は世界一周をしたくありません 今日、何か買いますか はい、オレンジ買います 日曜日が暇です 冷蔵庫にリンゴとオレンジが三つあります 閉める 竹 鶴 大人 広告 キャベツ 黒板 おやつ 冷蔵庫 チームで、フットバールをしている 葉が落ちます 2020-1-13短い 祖父が病気になった また会いましょう 考える 次はいつ会いましょうか 約束を忘れないでください グラスの数が足りません 取る 答えが違います 四日 昨日から腰が痛い 目 見える 来月の二十日は弟の誕生日です 彼はシートベルト締めた 一杯 口 後ろ 一日 調べる 二十キロのダイエットは可能だと思いますか 問題 内容 建設 いずれ なお、雨の場合は中止です 管理 彼がクラスの代表だ 宮沢さんは課長のことを、どう思いますか 短い なんで今日私の家に来ましたか また会いましょう ペットを飼いましょうか あなたは小西さんに映画のチケットをもらいますか 上野さんは彼女と映画を見ました 何も要りません 飛行機が二時間遅れました。なので、到着時間も遅くなります 隣の人は私の猫に餌をくれました 来月の二十日は弟の誕生日です あの喫茶店は静かなので、あそこで勉強する人は多いでしょう 消しゴム 火曜日 キャベツ 動詞 ラーメン 小学生 合格点 彼女は茶髪でえくぼがあります 調味料 二十キロのダイエットは可能だと思いますか 虹 キャベツ 2020-1-12肩 そう くれる 会う 場合 夕食には何を食べたいですか 終わり 掛ける 六日前に日本に帰ってきました 日曜日 32ページを開いてください 一日 夜 彼がクラスの代表だ もう 解決 情報 ここは道の状態がとても悪いです 一日 彼がクラスの代表だ 決定 変化 その質問に対する答えが見つからなかった 彼女は命令に従わなかった その会社は来月キャンペーンを行う ガソリンの価格がどんどん上がっている ダムの開発に住民は反対しています いずれ 作業 企業 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう 今日は何曜日ですか 私は頑張りたありません 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は実家に帰りたいです 私の嫌いなことは部屋を掃除することです コーヒーを飲みましょうよ 今夜は蒸し暑いので、蚊が多くなりました 私の苦手なことは料理を作ることです 私は先生と職員室に行きます コイン タプレット 梅 アパート もり 女性が桃の太さを計っている フロント 飛行機が二時間遅れました。なので、到着時間も遅くなりました 2020-1-11消す 兄は水泳が得意です 朝 飛行機 知る 彼女はいつも元気だ 病気 私が払いましょう 起こす 漢字は中国から来ました 夕食には何を食べたいですか ちゃんとドアを閉めてよ お母さん 髪の毛が伸びたね 腰 休む 曜日 五月五日は祝日です 黄色い 彼女はいい友達です その質問に対する答えが見つからなかった 建設 それは世界最大の船です その会社は来月キャンペーンを行う トラブルがやっと解決した 商品 彼は文章がとてもうまい 一緒に対策を考えましょう 対する 事故 生産 方向 年 前売券は窓口で販売しています 選挙 これは重要な書類です 私は苦手なことは部屋を掃除することです 狭い部屋 スピーチは何時からですか 夕食には何を食べたいですか えっと、電車が遅れたので、遅刻しました お客さんは家に来ました 昨日、何処かに行きましたか いいえ、どこに行きませんでした 絵を描く 私は紙で鶴を作りました あの喫茶店が静かなので、あそこで勉強する人が多いでしょう ニュースで道の状況がわかります 都市は田舎より便利です その質問に対する答えが見つからなかった どうして今日遅刻した 焼き鳥 湖 ラーメン 大人 バイク その会社は来月キャンペーンを行う 布 私は苦手なことは部屋を掃除することです 2020-1-10言葉 立つ 素敵な色のセーターですね 彼はまだ若いです お腹が空きました お名前をカタカナで書いてください 火曜日に会議があります 新学期は来月の四日からです 彼は時々遅刻します 建設 外国 導入 全体のは八十%が完成しました 毎年多くの人が海外へ旅行する 今後の方針が決まった 増える 体重がかなり減りました はげしい雨が降っています 変わる 内容 今後の方針が決まった 種類 のち その計算は間違っている 私は日本料理を作ることがよくできます カレーライスとオムライス、どちらが美味しいですか 弟は父の性格がわかります 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 自転車とバイクと車、どれが便利ですか 何も食べません あの服のほうが可愛いです ゴミ箱にペットボトルがあります 建設 何で学校に行くのですか 私は茶碗蒸しがあまり嫌いではありません えさ 牛 大人 ライ面 大人 2020-1-9見つける 生きてる 私たちのチームはその試合て負けた 祖父が病気になった 会う 郵便局で切手を買いました これは医者のためのサイトです 茶色 ミーテイング 先月の七日に孫が生まれました 五つ 二つ 火曜日 辺 答えが違います 目的 今後 治る 作業 文章 理由 内容 あなたの意見が聞きたいです 比べる 規模 留学してから私の世界が広がった 計画 評価 私は先生と職員室に行きました 病人が元気になる こ 私は頑張りたくありません ゲームをしませんでした 午後一時から四時までです 向日葵は草より綺麗です あの歌手は有名です これはなんですか 自転車とバイクと車、どれが便利ですか 中学生 さ 内容 2020-1-8祖父が病気になった 私が払いましょう 勝つ 若い グラスの数が足りません 親の愛は有り難い 今朝は早く家を出ました 会う 私は朝シャワーを浴びます 覚える 秋 答えが違います 九日 違う 多分 予約は要りません 彼女は眠いようです 彼に会えて嬉しかった 閉める 四日 百 書き直す 従来 私は四つの会社に投資しています それは世界最大の船です 対する 作業 強化 完成 現在 実現 この携帯電話が使えるのは国内だけです 交渉 構成 それはどういう意味ですか 彼は文章がとてもうまい 祖父が病気になった 対象 部長除く全員が土曜日も働いた 受ける 前売券は窓口で販売しています それは最近話題の本ですね 会う 交差点で事故が発生した 答えが違います 私の苦手なことは料理を作ることです 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 作業 私は懐石料理がすごく好きです どうして なぜ なんで 上手なコック えっと、電車が遅れたので、遅刻しました 冬は暖かかった 彼は社員ではありません チケットをください 私は頑張りたくありません 布団 プール 楓 博物館 木曜日 陽傘 湖 描く 折りたたみ傘 フットボール 鶏肉にしますか、魚にしますか 私は頑張りたくありません 2020-1-7昨日、タイカレーを食べました 買う 一番 素敵な色のセーターですね 夫 すぐ行きます 私が払いましょう 週 軽い 私が払いましょう 彼はまだ若いです 午前 開く お腹 時計を見たらちょうど三時だた つける 辛い そこには私一人しかいなかった 私はパンよりご飯が好きだ した 大人 トラブルがやっと解決した 彼は就職試験を受けた そのデモについて政府は何もしなかった 私たちはその問題を調査しています 私たちがその問題を調査しています 前売券は窓口で販売しています ダムの開発に住民は反対しています 計画 内容 外国 選挙 採用 もう 以上 対する 消える システムの構成を変えてみました 開発 彼は文章がとてもうまい そのデモについて政府は何もしなかった 仕事がほぼ終わりました 車の後ろに子猫と子犬がいます えっと、電車が遅れたので、遅刻しました スピーチは何時からですか 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう シャワーを浴びる象 日曜日は暇です 私は紙で鶴を作りました 小林さんは中国語を話すことができます どうして台湾の会社は大学生を雇いたくないのですか どれが綺麗ですか 中村さんは昨日夜十時まで仕事しましたので、残業代が沢山もらえるでしょう 前売券は窓口で販売しています いいえ、違います 辞書は雑誌より厚いです 対する タプレット 餌 小説 苺 期末レポート 湖 駅 台風 ツアーガイドはあなたの旅行楽しくする興味深い情報を知っているだろう 彼は文章がとてもうまい えっと、電車が遅れたので、遅刻しました 私は物理の基礎はしています 蝉 い 湖 2020-1-6素敵な色のセーターですね 質問のある方はどうぞ 質問 グラスの数が足りません素敵な色のセーターですね 私の部屋は二階にあります お願い ある こっち 私の祖母は100歳です よう どうして泣いているの 国会が再開した なお これは世界最大の船です 夢を実現するには努力が必要です ゴミのリサイクルが普及している 競争 対立 のち 特徴 変わる 写真はいい思い出になります よく 存在 帰ったら、まず手を洗いましょう 私にはたくさんのお金が必要だ 部分 今後 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 台北駅はどこですか まずい料理 私は紙で鶴を作りました 社長は部長と出かけました スピーチは何時からですか えっと、電車が遅れだので、遅刻しました ばか！いい訳するな 原稿を改訂する 記憶 猿 ペットボトル 調味料 タンス 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 私は紙で鶴を作りました スピーチは何時からですか えっと、電車が遅れ他ので、遅刻しました 2020-1-5彼はまだ若いです 友達とお酒を飲んでいます グラスの数が足りません そう 日記 言葉 強い 千円貸してください 十日後に帰ります 食べ物 小さい花が咲いています 四日 先月の七日に孫が生まれました 違う 昨日、あなたのお姉さんに会ったよ 近所で盗難事件が起こりました これは世界の最大の船です 自由 お金がほとんどがありません 報告 話 ドル 変化 外国 消える 変わる 今後 ソフト 事件 国内 販売 構造 私は風邪をひきました。なので、映画館に行きませんでした 遊びましょう 私の好きなことは音楽です グラスの数が足りません これは世界最大の船です 変わる 今後 石原さんは彼に防虫スプレーをもらいました 私の趣味は映画を見ることです 彼は実家に帰りたがります 私は書いた原稿本にする 引き出しにハムスターが一匹います シャワーを浴びる象 私は世界一周をしたいです 辞書は雑誌より厚いです 部屋が綺麗になる まず、次に、そして、それから、最後に 鶏 ゲーム機 姉 ツアーガイド 髭剃り フクロウが頭の上下に動かしている 2020-1-4彼はまだ若いです グラス数が足りません 若い 水 お願い 四日 悪い 時計 二つ 彼に会えて嬉しかった 先月の七日に孫が生まれました 違う お母さんによろしくを伝えください 今日はこのホテルに泊まります もう あまり 彼はまだ若いです 階段 改革 決定 ガソリンの価格がどんどん上がっている グラスの数が足りません 普及 頃 留学してから私の世界が広がった 方向 解決 四日 受ける ダムの開発に住民は反対しています 理由 この携帯電話が使えるのは国内だけです トラブルがやっと解決した 建設 外国 先月の七日に孫がを生まれました 違う 多く その仕事は危険を伴う まず相手の動きを見ましょう 彼は食品工場で働いています 彼は非常に高い技術を持っている 計算 上野さんは彼女と映画を見ました 私の友達は野球とサッカーができます 新しいゲームソフトを買いました。だから、古いゲームを売りました どうして台湾の会社は大学生を雇いたくないのですか あの服のほうが可愛いです あなたにデジタルカメラをもらいました 私は納豆が全然好きではありません 明日の食券をください 全然 犬を飼う 一眼レフカメラ 犬 化粧品 説明する 炒める リットル 雄鶏 ロブスターが岩の上にいる 外国旅行 2020-1-3やる 彼女は酒に強い 私には友達がたくさんいます 始める 狭い 彼はタオルで顔を拭きました 起こす 彼は数学を教えています 送る 私は朝シャワーを浴びます 感じる 夏休みももう終わりだ 昨日 強い 時 妹 五月五日は祝日です 上を向いて 時計 八つ 中心 なお、雨の場合は中止です 原因 ダムの開発に住民は反対しています 今日の新聞どこい置いた トラブルがやっと解決した のち もう 強調 段階 状態 スーパーは夜市ほどうるさくありません 授業をする教師 私は世界一周をしたくありません 日曜日は暇です 日本語を上手にする 私の趣味はバスケットをすることです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 私は飛行機で日本に行きます 自動車 知り合い 図 牛 鼠 タプレット レタス 烏龍茶 ダムの開発に住民は反対しています トラブルがやっと解決した もう 2020-1-2いつも 作る 変える 数 親の愛は有り難い 重い こう その次の週は空いていますか もう寝よう 学校亜八時半に始まります 気持ちのいい朝です 彼は意外に気が小さい おかげさまで元気です 暖かい 閉じる 私はパンよりご飯が好きだ 六日前に日本に帰ってきました 左 彼に会えて嬉しかった 教科書閉じてください 財布は机の下にあった ほう 見つかる あそこ 愛する 私はテレビをあまり見ません 昭和 行う 夢を実現するには努力が必要です あなたの話は面白いね 一部 私は行政を改革したいと思っている 経済 従来 全体の80%が完成しました 理由 ほとんど 増える 彼女は同じ間違いを繰り返した 弟は切手を集めています 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は刺身があまり好きではありません 大学の先輩は商売ができます 私はゲームを好きです 飛行機が二時間遅れました。なので、到着時間も遅くなります 向日葵は草より綺麗です 私は懐石料理がとても好きです なんでこんな時間に学校にいなにのですか 誰もいません インターネットで新幹線の時刻表がわかります 今日、何か買いますか はい、オレンジを買います スピーチは何時からですか なぜ大体のお店は試食を置きますか 日曜日が暇です 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう ドアを開けません チケットをください 月曜日 博物館 ペンギン タプレット たつ サツマイモは、焼いても揚げても美味しい 日曜日は暇です タプレット 2020-1-1今朝は早く家を出ました 弱い 見せる 鳥が飛んています 一番 彼に会えて嬉しかった 私は腕時計を四つ持っています 辺 お腹が空きました プールは人で一杯です 国会 生活 今、値段を交渉しています 繰り返す 与える これは大きな社会問題になっている 留学してから私の世界が広がった 理由 彼に会えて嬉しかった 交渉 システムの構成を変えてみました 報告 立場 ほぼ 今年は変化の多い年でした 彼はパーティー会場を提供してくれました 都市 建設 のち この携帯電話が使えるのは国内だけです あの人 飲み物といえば、コーラーやジュースやお茶などです 宮沢さんは課長のことをどう思いますか 弟は父の性格がわかります 私は日本語が少しできます あの喫茶店は静かですから、あそこでテストの勉強をしましょう あの服のほうが可愛いです どれも要りません 私の嫌いなことはバスケットをすることです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 忙しい会社員 テレビをつけませんでした 私は懐石料理をかなり好きです 理由 スピーチは何時からですか そっか今度早く家を出ろう 今日は何曜日ですか 動詞 水曜日 田舎 おやつ 綺麗 生まれす ましょう 私は物理の基礎は知っています フクロウ スピーチは何時からですか","link":"/zh-tw/japanese/2020/January/index.html"},{"title":"April 2020","text":"2020/4/30Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - Security - Authorization Reviewing Operating System Concepts Exercise: Pull-ups Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/29Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - Security - Authorization Reviewing knowledge Operating System Concepts Exercise: Pull-ups Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/28Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - Security - Authorization Reviewing knowledge Operating System Concepts Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/27Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - Security - Authorization Reviewing knowledge Operating System Concepts Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/26Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authorization Reviewing knowledge Operating System Concepts Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/25Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/24Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/23Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/22Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/21Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/20Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/19Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/18Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Laravel documentation - The Digging Deeper - Authentication Reviewing knowledge Operating System Concepts Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/17Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/16Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/15Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Operating System Concepts Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/14Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Operating System Concepts Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/13Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Operating System Concepts Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/12Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/11Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/10Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/9Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/8Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Laravel documentation - The Digging Deeper - Notifications Reviewing knowledge Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/7Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/6Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/5Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/4Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/3Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Squat Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/2Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Squat Badminton Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/4/1Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/schedule/2020/April/index.html"},{"title":"October 2019","text":"2019/10/31The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning case The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning case 2019/10/30The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning 2019/10/29The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning 2019/10/28The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning 2019/10/27The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/26The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/25The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/24The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/23The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/22The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/21The target I set today Work: Update site list Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Update site list Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/20The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Jogging Kubernetes learning Organise an article Post an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Jogging Kubernetes learning Organise an article Post an article 2019/10/19The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes learning Japanese grammar Post an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes learning Japanese grammar Post an article 2019/10/18The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes 2019/10/17The target I set today Work: Working on tw02 to tw01 switching Besides work: Linux English Japanese Working on a tech documentation translation push up The result of today’s target Work: Working on tw02 to tw01 switching Besides work: Linux English Japanese Working on a tech documentation translation push up 2019/10/16The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article Squat The result of today’s target Work: Added a new site as told Besides work: Linux English Japanese Working on a tech documentation translation Draft an article Organised an article Squat 2019/10/15The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Draft an article Organised an article 2019/10/14The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article 2019/10/13The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer 2019/10/12The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer 2019/10/11The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js pull ups Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js pull ups Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer 2019/10/10The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Japanese Grammar Squat hair cut Complete at least one course of Stackdriver Logging Quest The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Japanese Grammar Squat hair cut Completed at least one course of Stackdriver Logging Quest 2019/10/9The target I set today Work: webdev with Nginx Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: webdev with Nginx Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/8The target I set today Work: Working on logParsing upload API Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing upload API Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/7The target I set today Work: Working on logParsing frontend and backend deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing frontend and backend deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/6The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article 2019/10/5The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article Figure out Lookahead rule of Regex The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article Figure out Lookahead rule of Regex 2019/10/4The target I set today Work: Working on Web and Backend dashboard deployment Check siteEdge KIND Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on Web and Backend dashboard deployment Check siteEdge KIND Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/3The target I set today Work: Working on Web and Backend dashboard deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on Web and Backend dashboard deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/2The target I set today Work: Working on logParsing API Working on SFTP Server Working on Netdata API Working on Node Validator Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing API Working on SFTP Server Working on Netdata API Working on Node Validator Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/1The target I set today Work: Working on logParsing API Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing API Working on Netdata API Besides work: Linux English Japanese Working on a tech documentation translation Node.js","link":"/zh-tw/schedule/2019/October/index.html"},{"title":"September 2019","text":"2019/9/30The target I set today Work: Working on logParsing API Besides work: Linux English Japanese Working on a tech documentation translation The result of today’s target Work: Working on logParsing API Besides work: Linux English Japanese Working on a tech documentation translation 2019/9/29The target I set today Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising The result of today’s target Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising 2019/9/28The target I set today Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising The result of today’s target Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising 2019/9/27The target I set today Work: Make an auto-delete shell script to periodically clean Influxdb Besides work: Linux English Japanese The result of today’s target Work: Make an auto-delete shell script to periodically clean Influxdb Was told to do something else Besides work: Linux English Japanese 2019/9/26The target I set today Work: Make realtime traffic display API Besides work: Linux English Japanese The result of today’s target Work: Make realtime traffic display API Besides work: Linux English Japanese 2019/9/25The target I set today Work: Figure out how to get data from Influxdb with Node.js Besides work: Linux English Japanese The result of today’s target Work: Figure out how to get data from Influxdb with Node.js Besides work: Linux English Japanese 2019/9/24The target I set today Task: Working on logParsing API Complete the Tool Linux English Japanese The result of today’s target Task: Working on logParsing API Complete the Tool Linux English Japanese 2019/9/23The target I set today Task: Working on logParsing API Renew a wildcard SSL certificate Linux English Japanese The result of today’s target Task: Working on logParsing API Renew a wildcard SSL certificate Linux English Japanese 2019/9/22The target I set today Task: Post an article Completed a documentation of Stackdriver Logging Linux English Japanese The result of today’s target Task: Post an article Completed a documentation of Stackdriver Logging Linux English Japanese 2019/9/21The target I set today Task: Linux English Japanese The result of today’s target Task: Linux English Japanese 2019/9/20The target I set today Task: Working on logParsing API Deploy to production machine Linux English Japanese The result of today’s target Task: Working on logParsing API Deploy to production machine Linux English Japanese 2019/9/19The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Linux English Japanese 2019/9/18The target I set today Task: Working on logParsing API Deploy first version of Flow API Linux English Japanese The result of today’s target Task: Working on logParsing API Deploy first version of Flow API Linux English Japanese 2019/9/17The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Linux English Japanese 2019/9/16The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Linux English Japanese 2019/9/15The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Complete translated course so far Post an article Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Complete translated course so far Post an article Linux English Japanese 2019/9/14The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Post one article Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Post one article Linux English Japanese 2019/9/13The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Post one article Finish one Qwiklab course Make a Qwiklab lesson documentation Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Post one article Finish one Qwiklab course Make a Qwiklab lesson documentation Linux English Japanese 2019/9/12The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Working on SSH issue Linux English Japanese 2019/9/11The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Linux English Japanese 2019/9/11the result of my target yesterday Task: Working on logParsing API Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing API Linux English Japanese 2019/9/10the result of my target yesterday Task: Working on logParsing API Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing API Linux English Japanese 2019/9/9the result of my target yesterday Task: Finish one course of GCP Post an article Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing API Linux English Japanese 2019/9/8the result of my target yesterday Task: Finish one course of GCP Post an article Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish one course of GCP Post an article Linux English Japanese 2019/9/7the result of my target yesterday Task: Working on logParsing Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish one course of GCP Post an article Linux English Japanese 2019/9/6the result of my target yesterday Task: Working on logParsing Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Linux English Japanese 2019/9/5the result of my target yesterday Task: Working on logParsing Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Linux English Japanese 2019/9/4the result of my target yesterday Task: Working on logParsing Still working on it Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine No time for it Learn Node course 3 No time for it One interesting thing Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Linux English Japanese 2019/9/3the result of my target yesterday Task: Working on logParsing Still working on it Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine No time for it Learn Node course 3 No time for it One interesting thing No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Learn Node course 3 One interesting thing Linux English Japanese 2019/9/2the result of my target yesterday Task: Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Completed document Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Learn Node course 3 One interesting thing Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Learn Node course 3 One interesting thing Linux English Japanese 2019/9/1the result of my target yesterday Task: Working on Stackdriver Logging - Using BigQuery and Stackdriver to Analyze BigQuery Usage Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Still working Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Learn Node course 3 One interesting thing Linux English Japanese","link":"/zh-tw/schedule/2019/September/index.html"},{"title":"February 2020","text":"2020/2/29Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/2/28Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的網路技術知識 2020/2/27Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/26Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/25Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/24Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/23Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/22Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Jogging Reading Book: 2020/2/21Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/20Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/19Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/18Target and result today Work: Login Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/17Target and result today Work: Login Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/16Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/15Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/14Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/13Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/12Target and result today Work: Existing code understanding Con-call Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: Others: 2020/2/11Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: 2020/2/10Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: 2020/2/9Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Reading Book: Others: Resume improving 2020/2/8Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: Others: Resume improving 2020/2/7Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: pull-up Reading Book: Others: Resume improving 2020/2/6Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: Resume improving 2020/2/5Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: Resume improving 2020/2/4Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Exercise: Pull-up Reading Book: Others: Resume improving 2020/2/3Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: Resume improving 2020/2/2Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book 2020/2/1Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book","link":"/zh-tw/schedule/2020/February/index.html"},{"title":"July 2020","text":"# 2020/7/31Target and result today Work: update upstreamMerchantChannel Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Aerobic exercise Reading Book: SQL 必知必會 # 2020/7/30Target and result today Work: update upstreamMerchantChannel Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Pull-ups Aerobic exercise Reading Book: SQL 必知必會 # 2020/7/29Target and result today Work: update upstreamMerchantChannel Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Squat Aerobic exercise Reading Book: SQL 必知必會 # 2020/7/28Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Aerobic exercise Reading Book: SQL 必知必會 # 2020/7/27Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Aerobic exercise Reading Book: SQL 必知必會 # 2020/7/26Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Pull-ups Aerobic exercise Reading Book: SQL 必知必會 # 2020/7/25Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Pull-ups Aerobic exercise Reading Book: SQL 必知必會 # 2020/7/24Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Squat Cycling Reading Book: SQL 必知必會 # 2020/7/23Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Cycling Reading Book: SQL 必知必會 # 2020/7/22Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/21Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/20Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/19Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/18Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/17Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/16Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/15Target and result today Work: update upstreamMerchant k3s Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/14Target and result today Work: update upstreamMerchant k3s Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/13Target and result today Work: update upstreamMerchant k3s Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/12Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/11Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/10Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Pull-ups Reading Book: SQL 必知必會 # 2020/7/9Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/7/8Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/7/7Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/7/6Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/7/5Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/7/4Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/7/3Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/7/2Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/7/1Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會","link":"/zh-tw/schedule/2020/July/index.html"},{"title":"January 2020","text":"2020/1/31Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/30Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book 2020/1/29Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/28Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/27Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/26Target and result today Work: Learning: Qwiklab Kubernetes - secret English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/25Target and result today Work: Learning: Qwiklab Kubernetes - secret English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/24Target and result today Work: Learning: Qwiklab Kubernetes - secret English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/23Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - dig deeper - Eloquent ORM relationships 2 BeePay API reading Reviewing Git case-insensitive note organising Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/22Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - dig deeper - Eloquent ORM relationships 2 BeePay API reading Reviewing Git case-insensitive note organising Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/21Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/20Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel 2020/1/19Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/18Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/17Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/16Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/15Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/14Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/13Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/12Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/11Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/10Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/9Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/8Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/7Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/6Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/5Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/4Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/3Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/2Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/1Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Exercise pull-ups","link":"/zh-tw/schedule/2020/January/index.html"},{"title":"June 2020","text":"# 2020/6/30Target and result today Work: update upstreamMerchant Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Squat Reading Book: SQL 必知必會 # 2020/6/29Target and result today Work: Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/28Target and result today Work: Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/27Target and result today Work: Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/26Target and result today Work: Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/25Target and result today Work: Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/24Target and result today Work: Learning: English Laravel documentation - Database - Getting Started Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/23Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/22Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/21Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/20Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/19Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/18Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/17Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/16Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/15Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/14Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/13Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/12Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/11Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/10Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts Exercise: Reading Book: SQL 必知必會 # 2020/6/9Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/8Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/7Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/6Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/5Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/4Target and result today Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/3Target and result today The twenty-first day of fasting Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/2Target and result today The twentieth day of fasting Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/6/1Target and result today The nineteenth day of fasting Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會","link":"/zh-tw/schedule/2020/June/index.html"},{"title":"December 2020","text":"# 2020/12/31Target and result today Learning: English Laravel documentation - Digging Deeper - Cache Reviewing MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Encryption Laravel documentation organising - Reset Password Laravel documentation organising - Hashing others: Working on English Resume # 2020/12/30Target and result today Learning: English Laravel documentation - Digging Deeper - Cache Reviewing MySQL - Documentation - SQL Statements - CREATE INDEX Statement Nginx - proxy set header and variable Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Encryption others: Working on English Resume # 2020/12/29Target and result today Learning: English Laravel documentation - Digging Deeper - Cache Reviewing MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authorization NFS server others: Working on English Resume # 2020/12/28Target and result today Learning: English Laravel documentation - Digging Deeper - Cache Reviewing MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authorization NFS server # 2020/12/27Target and result today Learning: English Laravel documentation - Testing - Console Tests Laravel documentation - Digging Deeper - Cache Reviewing Kubernetes - PV - Demonstration Kubernetes - Daemon Set - Documentation MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authorization # 2020/12/26Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Laravel documentation - Testing - Console Tests Reviewing Kubernetes - PV - Demonstration Kubernetes - Daemon Set - Documentation MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authorization # 2020/12/25Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Reviewing Kubernetes - PV - Demonstration Kubernetes - Daemon Set - Documentation MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authentication Laravel documentation organising - Authorization # 2020/12/24Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Reviewing Kubernetes - PV - Demonstration Kubernetes - Daemon Set - Documentation MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authentication # 2020/12/23Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Reviewing Kubernetes - StatefulSet - Demonstration Kubernetes - Daemon Set - Documentation MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authentication # 2020/12/22Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Reviewing Kubernetes - StatefulSet - Demonstration Kubernetes - Daemon Set - Documentation MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Bench Press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Authentication # 2020/12/21Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Reviewing Kubernetes - Daemon Set - Demo Kubernetes - Daemon Set - Documentation MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Full body exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Logging # 2020/12/20Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - Word Press Deployment MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Pull up Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Error Handling Laravel documentation organising - Logging # 2020/12/19Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - Word Press Deployment MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Dead lift Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Error Handling # 2020/12/18Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Validation # 2020/12/17Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Validation # 2020/12/16Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Validation # 2020/12/15Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Validation # 2020/12/14Target and result today Learning: English Reviewing Exercise: Baduanjin Bench Press Reading Book: Movie: Demon Slayer The damn plate # 2020/12/13Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Queue in Action Blog: Laravel documentation organising - Validation # 2020/12/12Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Full body exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Queue in Action Blog: Laravel documentation organising - Validation # 2020/12/11Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - Character Sets, Collations, Unicode PHP Documentation Exercise: Baduanjin Dead Lift Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Queue in Action Blog: Laravel documentation organising - Validation # 2020/12/10Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Bench Press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Queue in Action Blog: Laravel documentation organising - Validation One post on FB Backend # 2020/12/9Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - Authenticating MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - URL Generation Laravel documentation organising - Validation # 2020/12/8Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - Create a user MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Pull-ups Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - URL Generation # 2020/12/7Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - Create a user MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - URL Generation # 2020/12/6Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Bench Press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Responses # 2020/12/5Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Responses # 2020/12/4Target and result today Learning: English Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Requests # 2020/12/3Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Laravel documentation - Frontend - Blade Templates Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Requests # 2020/12/2Target and result today Learning: English Laravel documentation - Testing - HTTP Tests Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Dead-lift Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Requests Post an article # 2020/12/1Target and result today Learning: English Laravel documentation - Testing - Getting Started Laravel documentation - Testing - HTTP Tests Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Pull-ups Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Requests","link":"/zh-tw/schedule/2020/December/index.html"},{"title":"March 2020","text":"2020/3/31Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/3/30Target and result today Work: Withdraw list Learning: Kubernetes - volume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/3/29Target and result today Work: Withdraw list Learning: Kubernetes - PersistentVolume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/3/28Target and result today Work: Withdraw list Learning: Kubernetes - PersistentVolume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Pull-up Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP 2020/3/27Target and result today Work: Withdraw list Learning: Kubernetes - PersistentVolume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Squat Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/26Target and result today Work: Withdraw list Learning: Kubernetes - PersistentVolume English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/25Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Events Reviewing knowledge Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/24Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Events Reviewing knowledge Exercise: Pull-up Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/23Target and result today Work: Withdraw list Learning: Kubernetes - Volume English Japanese Laravel documentation - The Digging Deeper - Events Reviewing knowledge Exercise: Squat Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/22Target and result today Work: Withdraw list Learning: Kubernetes English Japanese Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/21Target and result today Work: Withdraw list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Logging Laravel documentation - The Digging Deeper - Broadcasting Reviewing knowledge Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/20Target and result today Work: Withdraw list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Logging Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/19Target and result today Work: Withdraw list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Logging Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/18Target and result today Work: Deposit list Withdraw list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Logging Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/17Target and result today Work: Deposit list Withdraw list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Logging Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/16Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Logging Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/15Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Logging Reviewing Exercise: Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/14Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Error Handling Laravel documentation - The Basic - Logging Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/13Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Error Handling Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/12Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - The Basic - Error Handling Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/11Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - URL Generation Laravel documentation - The Basic - Error Handling Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/10Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - URL Generation Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/9Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - URL Generation Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/8Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Views Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/7Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Response Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/6Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Response Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/5Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Response Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/4Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Response Reviewing Exercise: Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/3Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Response Reviewing Exercise: Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/2Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Response Reviewing Exercise: Squat Pass, seems to have a cold. Reading Book: MIS 82 個一定要懂的網路技術知識 2020/3/1Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Reading Book: MIS 82 個一定要懂的網路技術知識","link":"/zh-tw/schedule/2020/March/index.html"},{"title":"August 2020","text":"# 2020/8/18Target and result today Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Aerobic exercise Pull-ups Deadlift Reading Book: SQL 必知必會 # 2020/8/2Target and result today Work: update upstreamMerchantChannel Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Aerobic exercise Pull-ups Reading Book: SQL 必知必會 # 2020/8/1Target and result today Work: update upstreamMerchantChannel Learning: English Laravel documentation - Database - Query Builder Reviewing Operating System Concepts Exercise: Aerobic exercise Squat Reading Book: SQL 必知必會","link":"/zh-tw/schedule/2020/August/index.html"},{"title":"May 2020","text":"# 2020/5/31Target and result today The eighteenth day of fasting Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/5/30Target and result today The seventeenth day of fasting Work: UpstreamMerchant list Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: SQL 必知必會 # 2020/5/29Target and result today The sixteenth day of fasting Work: Learning: English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/28Target and result today The fifteenth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/27Target and result today The fourteenth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/26Target and result today The thirteenth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/25Target and result today The twelfth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/24Target and result today The eleventh day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/23Target and result today The tenth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/22Target and result today The ninth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/21Target and result today The eighth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/20Target and result today The seventh day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/19Target and result today The sixth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/18Target and result today The fifth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/17Target and result today The forth day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/16Target and result today The third day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/15Target and result today The second day of fasting Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/14Target and result today The first day of fasting Work: Learning: English Japanese Reviewing Exercise: Reading Book: # 2020/5/13Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/12Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - HTTP Client Laravel documentation - Digging Deeper - Collections Reviewing Operating System Concepts CORS Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/11Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - HTTP Client Reviewing Operating System Concepts CORS Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP SQL 必知必會 # 2020/5/10Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - HTTP Client Reviewing Operating System Concepts CORS Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/9Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - HTTP Client Reviewing Operating System Concepts application/json vs www-urlencoded Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/8Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Digging Deeper - HTTP Client Reviewing Operating System Concepts CORS application/json vs www-urlencoded Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/7Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Security - Password Reset Reviewing Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/6Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Security - Hashing Laravel documentation - Security - Password Reset Reviewing Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/5Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Security - Encryption Laravel documentation - Security - Hashing Reviewing Operating System Concepts Exercise: Pull-ups Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/4Target and result today Work: UpstreamMerchant list Learning: Kubernetes - RBAC English Japanese Laravel documentation - Security - Encryption Laravel documentation - Security - Email Verification Reviewing Operating System Concepts Exercise: Squat Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/3Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Job English Japanese Laravel documentation - Security - Authorization Reviewing Operating System Concepts Exercise: Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/2Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - Security - Authorization Reviewing Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # 2020/5/1Target and result today Work: UpstreamMerchant list Learning: Kubernetes - Volume English Japanese Laravel documentation - Security - Authorization Reviewing Operating System Concepts Exercise: Jogging Reading Book: PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/schedule/2020/May/index.html"},{"title":"November 2020","text":"# 2020/11/30Target and result today Learning: English Laravel documentation - Digging Deeper - Artisan Console Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Requests # 2020/11/29Target and result today Learning: English Laravel documentation - Digging Deeper - Artisan Console Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Requests # 2020/11/28Target and result today Learning: English Laravel documentation - Digging Deeper - Artisan Console Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Bench Press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Controllers Post an article # 2020/11/27Target and result today Learning: English Laravel documentation - Digging Deeper - Artisan Console Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Controllers # 2020/11/26Target and result today Learning: English Laravel documentation - Digging Deeper - Artisan Console Reviewing Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms PHP 設計模式 Blog: Laravel documentation organising - Controllers # 2020/11/25Target and result today Learning: English Laravel documentation - Digging Deeper - Artisan Console Reviewing Laravel Eloquent Performance Patterns Kubernetes - RBAC TDD with Laravel MySQL - Documentation - Character Sets, Collations, Unicode Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Blog: Post an article Laravel documentation organising - CSRF Protection # 2020/11/23Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - RBAC TDD with Laravel Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/22Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - RBAC TDD with Laravel Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/21Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project TDD with Laravel Exercise: Baduanjin Bench Press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/20Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project TDD with Laravel Exercise: Baduanjin Dead Lift Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/19Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project TDD with Laravel Exercise: Baduanjin Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/18Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Baduanjin Pull-up Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/17Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Baduanjin Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/16Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Baduanjin Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/15Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Baduanjin Full Body Exercise Bench Press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Figure out whether PHP-FPM reload is truly graceful # 2020/11/14Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/12Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Differences of static, self, $this in PHP Exercise: Full Body Exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/11Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Pull-ups Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/10Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/11/9Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Full Body Exercise Bench Press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms","link":"/zh-tw/schedule/2020/November/index.html"},{"title":"October 2020","text":"# 2020/10/23Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/22Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/21Target and result today Learning: English Laravel documentation - Eloquent ORM - Getting started Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Full body exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/20Target and result today Learning: English Laravel documentation - Database - Seeding Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/18Target and result today Learning: English Laravel documentation - Database - Seeding Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Pull-up Jogging Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/17Target and result today Learning: English Laravel documentation - Database - Seeding Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Squat Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/16Target and result today Learning: English Laravel documentation - Database - Seeding Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Bench press Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/15Target and result today Learning: English Laravel documentation - Database - Seeding Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/14Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Kubernetes - Deploy Laravel Project Exercise: Full body training Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/13Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Dead lift Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/10/8Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms","link":"/zh-tw/schedule/2020/October/index.html"},{"title":"September 2020","text":"# 2020/9/30Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Dead lift Aerobic Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/9/29Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Pull-ups Walking Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/9/28Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Squat Bench Press Walking Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/9/27Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/9/26Target and result today Learning: English Laravel documentation - Database - Migrations Reviewing Laravel Eloquent Performance Patterns Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Aerobic exercise Full-Body exercise Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms # 2020/9/25Target and result today Learning: English Laravel documentation - Database - Pagination Reviewing Operating System Concepts Kubernetes - Deploy Laravel Project Exercise: Aerobic exercise Pull-ups Deadlift Reading Book: SQL 必知必會 Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms","link":"/zh-tw/schedule/2020/September/index.html"},{"title":"February 2021","text":"# 2021/2/28Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: EchossVIP # 2021/2/27Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: EchossVIP # 2021/2/26Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: EchossVIP # 2021/2/25Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: EchossVIP # 2021/2/24Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: EchossVIP # 2021/2/23Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: EchossVIP # 2021/2/22Target and result today Learning: English Laravel documentation - Digging Deeper - Task Serialization Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP # 2021/2/21Target and result today Learning: English Laravel documentation - Digging Deeper - Task Scheduling Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/17Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/16Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/15Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/14Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/13Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/12Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/11Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: EchossVIP Registration # 2021/2/10Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Laravel timezone &amp; MySQL timezone Work: LINE Login # 2021/2/9Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Laravel timezone &amp; MySQL timezone Work: LINE Login Refactor naming # 2021/2/8Target and result today Learning: English Laravel documentation - Digging Deeper - Mail Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Laravel documentation organising - Database - Pagination Laravel timezone &amp; MySQL timezone Work: LINE Login # 2021/2/7Target and result today Learning: English Laravel documentation - Package - Redis Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: # 2021/2/6Target and result today Learning: English Laravel documentation - Package - Redis Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work:","link":"/zh-tw/schedule/2021/February/index.html"},{"title":"January 2021","text":"# 2021/1/28Target and result today Learning: English Laravel documentation - Package - Redis Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: Admin Api # 2021/1/27Target and result today Learning: English Laravel documentation - Package - Redis Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: Admin Api # 2021/1/26Target and result today Learning: English Laravel documentation - Package - Redis Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: Laravel - AWS SES - Deployment # 2021/1/25Target and result today Learning: English Laravel documentation - Package - Redis Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: Admin Login Admin Loout # 2021/1/24Target and result today Learning: English Laravel documentation - Package - Redis Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: # 2021/1/20Target and result today Learning: English Laravel documentation - Package - Sanctum Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: Line Login admin api # 2021/1/19Target and result today Learning: English Laravel documentation - Package - Sanctum Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination Work: Line Login # 2021/1/18Target and result today Learning: English Laravel documentation - Package - Sanctum Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Queue in Action Blog: Laravel documentation organising - Database - Pagination # 2021/1/17Target and result today Learning: English Laravel documentation - Package - Sanctum Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication MySQL Repeatable Isolation Misconception Queue in Action Blog: Laravel documentation organising - Database - Getting Started # 2021/1/16Target and result today Learning: English Laravel documentation - Package - Sanctum Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication MySQL Repeatable Isolation Misconception Queue in Action Blog: Laravel documentation organising - Database - Getting Started # 2021/1/12Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication MySQL Repeatable Isolation Misconception Queue in Action Blog: Laravel documentation organising - Database - Getting Started # 2021/1/11Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing CSRF Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Database - Getting Started # 2021/1/10Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing CSRF Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Queue # 2021/1/9Target and result today Learning: English Laravel documentation - Digging Deeper - File Storage Reviewing CSRF Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Queue # 2021/1/8Target and result today Learning: English Laravel documentation - Digging Deeper - File Storage Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Queue others: Working on English Resume # 2021/1/7Target and result today Learning: English Laravel documentation - Digging Deeper - File Storage Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Notification others: Working on English Resume # 2021/1/6Target and result today Learning: English Laravel documentation - Digging Deeper - File Storage Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Notification others: Working on English Resume # 2021/1/5Target and result today Learning: English Laravel documentation - Basics - Views Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Notification others: Working on English Resume # 2021/1/4Target and result today Learning: English Laravel documentation - Basics - View Reviewing Exercise: Baduanjin Reading Book: High Performance MySQL: Optimization, Backups, and Replication Learning MySQL and MariaDB (本日完結) PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - HTTP Client others: Working on English Resume # 2021/1/3Target and result today Learning: English Laravel documentation - Basics - Session Laravel documentation - Basics - View Reviewing MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Events Laravel documentation organising - HTTP Client others: Working on English Resume # 2021/1/2Target and result today Learning: English Laravel documentation - Basics - Session Reviewing MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Broadcasting others: Working on English Resume # 2021/1/1Target and result today Learning: English Laravel documentation - Basics - Session Reviewing MySQL - Documentation - SQL Statements - CREATE INDEX Statement Exercise: Baduanjin Reading Book: Learning MySQL and MariaDB PHP 7 Data Structures and Algorithms Queue in Action Blog: Laravel documentation organising - Broadcasting others: Working on English Resume","link":"/zh-tw/schedule/2021/January/index.html"},{"title":"March 2021","text":"# 2021/3/31Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/30Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/29Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/28Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Laradock &amp; PHPSTORM - testing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: # 2021/3/27Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Laradock &amp; PHPSTORM - testing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: # 2021/3/26Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/25Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/24Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/23Target and result today Learning: English Laravel documentation - Testing - Mocking Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/22Target and result today Learning: English Laravel documentation - Digging Deeper - Package Development Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echo Square # 2021/3/21Target and result today Learning: English Laravel documentation - Eloquent ORM - Localization Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echoss CD Deployment # 2021/3/20Target and result today Learning: English Laravel documentation - Eloquent ORM - Localization Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echoss CD Deployment # 2021/3/19Target and result today Learning: English Laravel documentation - Eloquent ORM - Collections Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: HUCC Echo Square API # 2021/3/18Target and result today Learning: English Laravel documentation - Eloquent ORM - Collections Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: HUCC Echo Square API # 2021/3/17Target and result today Learning: English Laravel documentation - Eloquent ORM - Collections Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: HUCC Echo Square API # 2021/3/16Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: echo-square api interface echo-square db schema echo-square requirement checking # 2021/3/15Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: hucc-778, issue-133 # 2021/3/14Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echoss CD deployment # 2021/3/13Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echoss CD deployment # 2021/3/12Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Issue hu_788 # 2021/3/11Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Issue hu_788 # 2021/3/10Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Issue 199 # 2021/3/9Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Issue 199 # 2021/3/8Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Issue 133, 189, 199 # 2021/3/7Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echoss - memberCard component # 2021/3/6Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Echoss - member-card component Hucc - scheduled task # 2021/3/5Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Issue JIRA 778 # 2021/3/4Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Laravel - Backpack documentation Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Issue JIRA 778 # 2021/3/3Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: Laravel - Backpack 熟悉 # 2021/3/2Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: 專案環境架設 # 2021/3/1Target and result today Learning: English Laravel documentation - Digging Deeper - Helpers Reviewing Exercise: Baduanjin Reading Book: 極客時間: MySQL 實戰 45 講 Queue in Action Blog: Work: EchossVIP","link":"/zh-tw/schedule/2021/March/index.html"}],"posts":[{"title":"Cloud Shell 及 Gcloud 簡介！","text":"本篇將會做什麼？ 練習使用 gcloud 指令 連結到 Google Cloud Platform 的儲存裝置 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記原文可參閱:官方連結 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 理解 Regions 和 Zones 特定的 Compute Engine 資源位於特定的 regions 或 zones. Region 表示一個你可以運行你的資源的特定地理位置。 每個 region 都有一個或多個 zones，舉例來說，us-central1 region 位於 Central United States，並且下面有 us-central1-a, us-central1-b, us-central1-c, us-central1-f 這些 zones 位於 zone 的資源算是 zonal 資源。 Virtual machine instance 還有 persistent disk 都位於 zone, 如果要在一個 virtual machine 上加一個 persistent disk ，那兩者必須位於同一個 zone 很類似的，如果你要分配一個 static IP 位址到一個 instance ，這個 instance 必須要跟這個 static IP 同一個 region 使用終端機 點擊位於 GCP 主控台右上角的圖案來開始一個新的 Cloud Shell 視窗，如下圖： 在 Cloud Shell 成功開啟後，我們可以使用終端機來下達 Cloud SDK gcloud ，或任何其他 vurtual machine instance 有提供的指令。 我們也可以在不同的專案，或著 Cloud Shell，把檔案儲存在 persistent disk 的 HOME 資料夾。 HOME資料夾只屬於你個人，任何其他USER將無法存取。 gcloud提供使用指南，只要在指令的後面加上-h，試試下面的指令: gcloud -h 或者，你也可以打長一點 gcloud config --help gcloud help config 使用你的 Home 資料夾 現在，讓我們來試試 Home 資料夾。就算你結束或者重開你的 virtual machine, Cloud Shell Home 資料夾內的內容也會繼續存在，不同的專案或者 Cloud Shell 都可以存取。 改變目前的工作資料夾cd $HOME 使用vim打開.bashrc設定檔vim .bashrc 使用 gcloud 指令 讓我們來檢視一下我們環境內的設定列表gcloud config list 檢視其他的 property 是怎麼被設定的gcloud config list --all 管理 Cloud 儲存資料 建立一個 Cloud Storage bucket, bucket 的名字必須獨一無二，所以請給一個名稱來取代下面的unique-namegsutil mb gs://unique-name 現在，我們可以建立一些資料，並上傳的我們的 bucket 建立一個 test 檔案vim test.dat 加一些資料進去welcome to gcloud! 存檔:wq 現在，上傳一些檔案到我們建立的 bucket，請使用我們之前給的名字來取代下面的 unique-namegsutil cp test.dat gs://unique-name 如果想看一下我們建立的 bucket, 以及我們上傳的檔案，可以打開 Navigation menu &gt; Storage &gt; Browser, 然後點擊 bucket, 應該可以看到 test.dat 檔案，如下圖： 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： Three basic ways to interact with the GCP services and resources: Command-line interface Client libraries GLib GStreamer GCP Console","link":"/zh-tw/CloudShellAndgcloud/"},{"title":"取得 Facebook 長期權杖 (long lived token)，以及 永不過期權杖 (never expired token)","text":"前言本篇將分享如何利用 Facebook 的圖形 API 測試工具，以及 PHP 來取得長期權杖 (long lived token)，以及永不過期權杖 (never expired token) 目前正在做一個 Facebook 的直播拍賣優化系統的後端，發現前端的短期 (short lived token) 權杖有效時間只有不到兩個小時，相較於 Android 的三個月，以及 iOS 的兩個月，實在是有夠短。雖然說 code 寫好之後其實也無所謂，但是就想來研究一下如何拿到長期的權杖 (long lived token) Facebook 的圖形 API 測試工具長期權杖 (long lived token)首先，讓我們先用 Facebook 的圖形 API 來拿長期權杖 (long lived token) 測試帳號 取得測試測試帳號權杖 圖形 API 測試工具 輸入剛剛獲得的權杖 按下’提交’ 按下權杖左邊的驚嘆號，並選擇，以存取權杖工具開啟 點擊左下方的，延伸存取權杖 得到兩個月的長期權杖 (long lived token) 永不過期的粉絲專頁權杖接下來，讓我們使用 Facebook 的圖形 API 測試工具來取得永不過期的權杖 (never expired token) 首先，讓我們登入測試帳號，並申請一個粉絲團 跟上面的流程完全一模一樣，我們就可以拿到永不過期的權杖 (never expired token) PHP長期權杖 (long lived token)現在讓我們使用 PHP 來透過呼叫 Facebook 的 API 來取得長期權杖 (long lived token) 使用 PHP 的 function file_get_contents來呼叫 Facebook 的 APIpublic static function getLongLivedToken($token)&#123; $url = &#x27;https://graph.facebook.com/oauth/access_token?grant_type=fb_exchange_token&amp;client_id=yourClientID&amp;client_secret=yourClientSecret&amp;fb_exchange_token=shortLivedToken; return json_decode(file_get_contents($url), true);&#125; 會得到以下資訊:&#123; &quot;result&quot;: true, &quot;response&quot;: &#123; &quot;access_token&quot;: &quot;EAAEpKfFACZA8BAGyTFU29VFIlEjhDaUe66eliyWdGQDfVTBUUdFZBZAGeZBEgTEwxgthvdABuzECYi1ahqm8ZCYNRSV9YMnegq7XxCouP1sR8kXMdnNFysGb2IHZBhSB3KENeTZCBzHrFSJ9BJLt9k6xkuWkJsVHnG0KahmFmybKTG6pVaFoZATN&quot;, &quot;expires_in&quot;: 5182393 &#125;&#125; 結語至於如何利用 PHP 來取得永不過期的粉絲專頁權杖 (never expired token)，似乎需要提升 APP 的權限，這方面需要審查，所以我就暫時無法測試啦。","link":"/zh-tw/FacebookLongLivedToken/"},{"title":"Laravel串接歐付寶第三方金流支付","text":"建立Laravel專案Laravel new AllPay 一開始先Git，這幾乎是一定要的啊！git init 下載歐付寶SDK，本篇使用PHP SDKgit clone https://github.com/o-pay/Payment_PHP 將SDK移到Laravel裡頭的app底下 cp Payment_PHP/sdk/AllPay.Payment.Integration.php AllPay/app/ 建立等等測試用的Controllerphp artisan make:controller PaymentsController 從剛剛的SDK包裡面，複製example到我們的controller裡，本篇使用All的example，如下：/****/ //載入SDK(路徑可依系統規劃自行調整) include(&#x27;AllPay.Payment.Integration.php&#x27;); try &#123; $obj = new AllInOne(); //服務參數 $obj-&gt;ServiceURL = &quot;https://payment-stage.opay.tw/Cashier/AioCheckOut/V5&quot;; //服務位置 $obj-&gt;HashKey = &#x27;5294y06JbISpM5x9&#x27; ; //測試用Hashkey，請自行帶入AllPay提供的HashKey $obj-&gt;HashIV = &#x27;v77hoKGq4kWxNNIS&#x27; ; //測試用HashIV，請自行帶入AllPay提供的HashIV $obj-&gt;MerchantID = &#x27;2000132&#x27;; //測試用MerchantID，請自行帶入AllPay提供的MerchantID $obj-&gt;EncryptType = EncryptType::ENC_SHA256; //CheckMacValue加密類型，請固定填入1，使用SHA256加密 //基本參數(請依系統規劃自行調整) $MerchantTradeNo = &quot;Test&quot;.time(); $obj-&gt;Send[&#x27;ReturnURL&#x27;] = &#x27;http://gw.grazia.tw/sdk/op_sdk/op_payment/example/simple_ServerReplyPaymentStatus.php&#x27; ; //付款完成通知回傳的網址 $obj-&gt;Send[&#x27;MerchantTradeNo&#x27;] = $MerchantTradeNo; //訂單編號 $obj-&gt;Send[&#x27;MerchantTradeDate&#x27;] = date(&#x27;Y/m/d H:i:s&#x27;); //交易時間 $obj-&gt;Send[&#x27;TotalAmount&#x27;] = 2000; //交易金額 $obj-&gt;Send[&#x27;TradeDesc&#x27;] = &quot;good to drink&quot;; //交易描述 $obj-&gt;Send[&#x27;ChoosePayment&#x27;] = PaymentMethod::ALL; //付款方式:全功能 //訂單的商品資料 array_push($obj-&gt;Send[&#x27;Items&#x27;], array(&#x27;Name&#x27; =&gt; &quot;歐付寶黑芝麻豆漿&quot;, &#x27;Price&#x27; =&gt; (int)&quot;2000&quot;, &#x27;Currency&#x27; =&gt; &quot;元&quot;, &#x27;Quantity&#x27; =&gt; (int) &quot;1&quot;, &#x27;URL&#x27; =&gt; &quot;dedwed&quot;)); # 電子發票參數 /* $obj-&gt;Send[&#x27;InvoiceMark&#x27;] = InvoiceState::Yes; $obj-&gt;SendExtend[&#x27;RelateNumber&#x27;] = $MerchantTradeNo; $obj-&gt;SendExtend[&#x27;CustomerEmail&#x27;] = &#x27;test@opay.tw&#x27;; $obj-&gt;SendExtend[&#x27;CustomerPhone&#x27;] = &#x27;0911222333&#x27;; $obj-&gt;SendExtend[&#x27;TaxType&#x27;] = TaxType::Dutiable; $obj-&gt;SendExtend[&#x27;CustomerAddr&#x27;] = &#x27;台北市南港區三重路19-2號5樓D棟&#x27;; $obj-&gt;SendExtend[&#x27;InvoiceItems&#x27;] = array(); // 將商品加入電子發票商品列表陣列 foreach ($obj-&gt;Send[&#x27;Items&#x27;] as $info) &#123; array_push($obj-&gt;SendExtend[&#x27;InvoiceItems&#x27;],array(&#x27;Name&#x27; =&gt; $info[&#x27;Name&#x27;],&#x27;Count&#x27; =&gt; $info[&#x27;Quantity&#x27;],&#x27;Word&#x27; =&gt; &#x27;個&#x27;,&#x27;Price&#x27; =&gt; $info[&#x27;Price&#x27;],&#x27;TaxType&#x27; =&gt; TaxType::Dutiable)); &#125; $obj-&gt;SendExtend[&#x27;InvoiceRemark&#x27;] = &#x27;測試發票備註&#x27;; $obj-&gt;SendExtend[&#x27;DelayDay&#x27;] = &#x27;0&#x27;; $obj-&gt;SendExtend[&#x27;InvType&#x27;] = InvType::General; */ //產生訂單(auto submit至AllPay) $obj-&gt;CheckOut(); &#125; catch (Exception $e) &#123; echo $e-&gt;getMessage(); &#125; 我們將上面一些機敏資訊，移到Laravel的.env檔裡面，如下://服務位置$obj-&gt;HashKey = env(&#x27;HASHKEY&#x27;); //測試用Hashkey，請自行帶入AllPay提供的HashKey$obj-&gt;HashIV = env(&#x27;HASHIV&#x27;); //測試用HashIV，請自行帶入AllPay提供的HashIV$obj-&gt;MerchantID = env(&#x27;MERCHANTID&#x27;); //測試用MerchantID，請自行帶入AllPay提供的MerchantID$obj-&gt;Send[&#x27;ReturnURL&#x27;] = env(&#x27;ALLPAYRETURNURL&#x27;);//付款完成通知回傳的網址$obj-&gt;Send[&#x27;ClientBackURL&#x27;] = $request-&gt;ClintBackURL;//付款完成後，於第三方頁面顯示回到我們服務的網址 .env檔內如下：ALLPAYRETURNURL=https://163be100.ngrok.io/api/paymentsResponseHASHKEY=5294y06JbISpM5x9HASHIV=v77hoKGq4kWxNNISMERCHANTID=2000132 使用use代替include 刪除//載入SDK(路徑可依系統規劃自行調整)include(&#x27;AllPay.Payment.Integration.php&#x27;); 新增AllPay.Payment.Integration.php到composer.json file&quot;autoload-dev&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Tests\\\\&quot;: &quot;tests/&quot; &#125;, &quot;files&quot;: [ &quot;app/Helpers.php&quot;, &quot;app/AllPay.Payment.Integration.php&quot; ] 在terminal下達composer dump-autoload` 在controller檔案裡，use新的classnamespace App\\Http\\Controllers;use AllInOne;use EncryptType;use Exception;use Illuminate\\Http\\Request;use PaymentMethod; 建立金流訂單 (這部分屬個人表格設計，帶入參數每個人都不同)因為會一次性的寫入兩張表格，所以這邊會使用 Laravel 的 transaction 來寫入資料 //總金額$totalAmount = Order::getTotalAmountForPayments($orders);//商品訂單編號$ordersName = Order::getOrdersNameForPayments($orders);//金流訂單編號$MerchantTradeNo = time() . Helpers::createAUniqueNumber();//金流訂單建立時間$MerchantTradeDate = date(&#x27;Y/m/d H:i:s&#x27;);//金流訂單敘述$TradeDesc = &#x27;BuyBuyGo&#x27;;//數量$quantity = 1;//因為同時建立兩張表格，這邊使用Laravel的transaction功能來防止資料庫資料不一//transaction開始DB::beginTransaction();//以下動作需全部完成無錯誤，否則終止並回朔try&#123; $payment_service_order = new PaymentServiceOrders(); $payment_service_order-&gt;user_id = User::getUserID($request); //金流服務商ID $payment_service_order-&gt;payment_service_id = $thirdPartyPaymentService-&gt;id; $payment_service_order-&gt;expiry_time = (new Carbon())-&gt;now()-&gt;addDay(1)-&gt;toDateTimeString(); $payment_service_order-&gt;MerchantID = env(&#x27;MERCHANTID&#x27;); $payment_service_order-&gt;MerchantTradeNo = $MerchantTradeNo; $payment_service_order-&gt;MerchantTradeDate = $MerchantTradeDate; $payment_service_order-&gt;TotalAmount = $totalAmount; $payment_service_order-&gt;TradeDesc = $TradeDesc; //商品訂單的編號 $payment_service_order-&gt;ItemName = $ordersName; $payment_service_order-&gt;save(); foreach ($orders as $order) &#123; $order_relations = new OrderRelations(); $order_relations-&gt;payment_service_id = $thirdPartyPaymentService-&gt;id; $order_relations-&gt;payment_service_order_id = $payment_service_order-&gt;id; $order_relations-&gt;order_id = $order-&gt;id; $order_relations-&gt;save(); &#125; //若有錯誤，則停止並回朔，回報自訂錯誤訊息&#125; catch (Exception $e)&#123; DB::rollBack(); return Helpers::result(&#x27;false&#x27;, &#x27;Something went wrong with DB&#x27;, 400);&#125;//若無錯誤，則寫入資料庫DB::commit(); 為PaymentsController建立一支API 到routes資料夾底下的api.php 增加routeRoute::post(&#x27;pay&#x27;, &#x27;PaymentsController@pay&#x27;); 建立一頁最簡單的的html 直接更改Laravel內建welcome.blade的內容，如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Facebook Login JavaScript Example&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;// 這邊需輸入PaymentsController的API&lt;form action=&quot;/api/pay&quot; method=&quot;POST&quot;&gt; @csrf() &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; name=&quot;order_id[]&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;2&quot; name=&quot;order_id[]&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;3&quot; name=&quot;order_id[]&quot;&gt; &lt;input type=&quot;hidden&quot; value=&quot;https://64b30ea0.ngrok.io/&quot; name=&quot;ClintBackURL&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 簡單傳送測試 到Laravel首頁，此時此頁面應已經變更為我們剛剛建立的簡單form頁面 什麼都不要勾選，點選submit 成功到了歐付寶的付款頁面 建立Log 為了要知道當我們成功付款之後，歐付寶會回傳什麼給我們，我們需要用Log來看看回傳的東西 有沒有一個地方，是所有的請求跟回饋都一定會進出通過，而且可以讓我們控制的？ 這似乎是個完美記log的地方 我們可以建立一個middleware，然後在middleware裏頭使用Laravel的Log功能，將所有進來的請求跟我們回饋的東西全都記下來 建立middleware 於terminal頁面php artisan make:middleware TestLog 註冊middleware 到/app/Http/Kernel.php檔案裡頭，加上我們剛剛建立的middleware protected $middleware = [ \\App\\Http\\Middleware\\CheckForMaintenanceMode::class, \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class, \\App\\Http\\Middleware\\TrimStrings::class, \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class, \\App\\Http\\Middleware\\TrustProxies::class, \\App\\Http\\Middleware\\TestLog::class,]; 建立Log 到我們剛剛建立的TestLog檔案裡頭，新增： $response = $next($request);log::info([$request-&gt;header(),$request-&gt;getMethod(),$request-&gt;getRequestUri(),$request-&gt;all(),$response-&gt;getStatusCode(),$response-&gt;getContent()]);return $response; 實際上，Log要記些什麼視乎每個人的需求 建立public url 我們要取得第三方回傳的資訊，所以我們必須要有一個public url來接收第三方的response 我們可以使用ngrok來取得public url 至ngrok官網安裝ngrok 將ngrok變更為可全域執行 mv ngrok /usr/local/bin 先取得public url，在terminal中 ngrok http 8000 在terminal中，位於AllPay專案資料夾內，開啟本機通道 php artisan serve 8000` 複製ngrok產生的public https url 建立接收的function 我們準備要來接歐付寶回傳的訊息了，我們需要建立一個function，並且接到之後，可以在裡面做我們想做的事 在PaymentsController裡頭，我們先建一個function receive，如下：public function receive()&#123; &#125; 針對此function，建立一個APIRoute::post(&#x27;pay&#x27;, &#x27;PaymentsController@pay&#x27;);Route::post(&#x27;receive&#x27;, &#x27;PaymentsController@receive&#x27;); 設定ReturnURL 於.env檔內，如有照之前步驟，應有以下參數，將複製的public url 貼上 ALLPAYRETURNURL=https://163be100.ngrok.io/api/recevie 你的連結跟我的不一樣哦，別貼我的 付款測試 再次連到歐付寶付款頁面 登入歐付寶提供的買家測試帳號 帳號：stageuser001 密碼：test1234 使用歐付寶提供的測試信用卡付款 卡號：4311-9522-2222-2222 有效期限：請大於目前月/年，例：12 / 20 末三碼：222 付款後，我們到log去看一下有沒有收到歐付寶的回饋，於terminal，位於AllPay的資料夾內cat storage/logs/laravel-2019-02-08.log` 咦，有收到歐付寶的回饋了！&#x27;MerchantID&#x27; =&gt; &#x27;2000132&#x27;, &#x27;MerchantTradeNo&#x27; =&gt; &#x27;Test1549597724&#x27;, &#x27;PayAmt&#x27; =&gt; &#x27;2000&#x27;, &#x27;PaymentDate&#x27; =&gt; &#x27;2019/02/08 11:49:03&#x27;, &#x27;PaymentType&#x27; =&gt; &#x27;Credit_CreditCard&#x27;, &#x27;PaymentTypeChargeFee&#x27; =&gt; &#x27;20&#x27;, &#x27;RedeemAmt&#x27; =&gt; &#x27;0&#x27;, &#x27;RtnCode&#x27; =&gt; &#x27;1&#x27;, &#x27;RtnMsg&#x27; =&gt; &#x27;交易成功&#x27;, &#x27;SimulatePaid&#x27; =&gt; &#x27;0&#x27;, &#x27;TradeAmt&#x27; =&gt; &#x27;2000&#x27;, &#x27;TradeDate&#x27; =&gt; &#x27;2019/02/08 11:48:44&#x27;, &#x27;TradeNo&#x27; =&gt; &#x27;1902081148440800&#x27;, &#x27;CheckMacValue&#x27; =&gt; &#x27;5B1EE24B0E9D600C65578DD82D3168E2ED56799453577E17E1EBEFC536BD7EAF&#x27;, 驗證 試想，如果有人不小心知道了你的API，然後對方也是開發者，他如果跑到你的服務購買商品，然後呼叫你的API結帳，你如何辨別？ 所以說，第三方跟廠商會有一套只有雙方身份對了，驗證才能通過的機制 驗證機制大概就是，所以你傳出去的資料，每一項欄位，會經過一套只有雙方適用的公式下去計算，最後會得出一串CheckMacValue，眼尖的朋友應該已經看到，在我們收到的訊息最下面一個欄位帶的就是這串資料。 詳細的公式各位朋友可參照官方網站。 由於本篇使用官方的SDK，所以本篇將教大家如何使用官方SDK來驗證收到的資訊 首先，我們到官方SDK的檔案中app/AllPay.Payment.Integration.php，搜尋名為CheckMacValue的class CheckMacValue class裡頭，有一個名為generate的function，大家可以看一下它是怎麼寫的，這就是產生這串CheckMacValue的公式。 所以說，我們只要通過這套公式，驗證我們收到的訊息之中，除了CheckMacValue這個欄位的資訊，那理應得到跟回傳的CheckMacValue一模一樣的值 先取得回傳資訊中，除了CheckMacValue之外的所有資訊，我們可以使用以下的code$parameters = $paymentResponse-&gt;except(&#x27;CheckMacValue&#x27;); 再來，取得歐付寶回傳的CheckMacValue$receivedCheckMacValue = $paymentResponse-&gt;CheckMacValue; 接下來，使用官方的generate function，帶入我們收到的資訊，來產出正確的CheckMacValue$calculatedCheckMacValue = CheckMacValue::generate($parameters, env(&#x27;HASHKEY&#x27;), env(&#x27;HASHIV&#x27;), EncryptType::ENC_SHA256); 最後，比較兩者的值是否一樣？如果一樣，表示這則訊息的確來自歐付寶，如果不同，那此資訊沒有可信度if($receivedCheckMacValue == $calculatedCheckMacValue) return true;return false; 驗證之後呢？ 確認資訊來源正確之後，我們就可以依據收到的資訊下去做事了！ 比方說，付款了做些什麼，付款失敗又做些什麼 本篇範例為收到付款之後，將資料庫內訂單標記付款，並發email通知買家，如下：if (PaymentServiceOrders::checkIfCheckMacValueCorrect($request) &amp;&amp; PaymentServiceOrders::checkIfPaymentPaid($request-&gt;RtnCode))&#123; $paymentServiceOrder = (new PaymentServiceOrders)-&gt;where(&#x27;MerchantTradeNo&#x27;, $request-&gt;MerchantTradeNo)-&gt;first(); $paymentServiceOrder-&gt;update([&#x27;status&#x27; =&gt; 1, &#x27;expiry_time&#x27; =&gt; null]); $orderRelations = $paymentServiceOrder-&gt;where(&#x27;MerchantTradeNo&#x27;, $request-&gt;MerchantTradeNo)-&gt;first()-&gt;orderRelations; Order::updateStatus($orderRelations); $payerEmail = $paymentServiceOrder-&gt;user-&gt;email; if ($payerEmail !== null) Mail::to($payerEmail)-&gt;send(new PaymentReceived($paymentServiceOrder, $orderRelations)); return &#x27;1|OK&#x27;;&#125; 最後記得別忘記return ‘1|OK’, 通知歐付寶我們已經收到付款囉！ 一些沒說到的事 歐付寶測試帳號中，除了信用卡之外，也支援多種其他方式付款哦！可於登入買家測試帳號之後使用。 超商或轉帳付款方式，需特別登入歐付寶提供的後台測試帳號，方可達到模擬付款！ 帳號：StageTest 密碼：test1234 退款 退款範例如下： public static function refund($order, $paymentServiceInstance, $orderRelation)&#123; try &#123; $obj = new AllInOne(); $obj-&gt;ServiceURL = &quot;https://payment-stage.opay.tw/Cashier/AioChargeback&quot;; // 服務位置 $obj-&gt;HashKey = env(&#x27;HASHKEY&#x27;); // 測試用Hashkey，請自行帶入AllPay提供的HashKey $obj-&gt;HashIV = env(&#x27;HASHIV&#x27;); // 測試用HashIV，請自行帶入AllPay提供的HashIV $obj-&gt;MerchantID = env(&#x27;MERCHANTID&#x27;); // 測試用MerchantID，請自行帶入AllPay提供的MerchantID $obj-&gt;EncryptType = EncryptType::ENC_SHA256; // CheckMacValue加密類型，請固定填入1，使用SHA256加密 $obj-&gt;ChargeBack[&#x27;MerchantTradeNo&#x27;] = $paymentServiceInstance-&gt;MerchantTradeNo; // 當初訂單成立時，提供的訂單號碼 $obj-&gt;ChargeBack[&#x27;TradeNo&#x27;] = $paymentServiceInstance-&gt;TradeNo; // AllPay提供的訂單號碼 $obj-&gt;ChargeBack[&#x27;ChargeBackTotalAmount&#x27;] = $order-&gt;total_amount; // 退款金額 $obj-&gt;AioChargeback(); &#125; catch (Exception $e) &#123; // 若錯誤，return return Helpers::result(true, &#x27;Something wrong happened&#x27;, 200); // Debug模式，印出錯誤 echo $e-&gt;getMessage(); &#125;&#125; 帶入參數可參考官方文件，選項12，會員通知退款。","link":"/zh-tw/AllPayPaymentService/"},{"title":"gcloud CLI 用法","text":"前言本篇記錄 gcloud CLI 用法 computeinstance 建立一台虛擬機 gcloud compute instances create example-instance-1 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=10GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=example-instance-1,http-server,https-server \\--zone=asia-east1-c 由自己建立的 image 建一台 VM gcloud compute instances create example-instance-1 \\--image-project=yourProject \\--image=yourImage \\--boot-disk-size=10GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=example-instance-1,http-server,https-server \\--zone=asia-east1-c 停止 instance gcloud compute instances stop instanceName1 instanceName2 instanceName3 啟動 instance gcloud compute instances start instanceName1 instancesName2 instanceName3 刪除 instance gcloud compute instances delete instanceName 列出 instances 列表 gcloud compute instances list 列出特定 instance 細節資料 gcloud compute instances describe instanceName 查詢執行個體的 ssh 金鑰 gcloud compute instances describe instanceName | grep -A 5 ssh-keys 移除或新增執行個體 ssh 金鑰 gcloud compute instances add-metadata instanceName --metadata-from-file ssh-keys=fileName 指令如上，以下是 fileName 的格式 [USERNAME_2]:ssh-rsa [EXISTING_KEY_VALUE_2] [USERNAME_2][USERNAME_3]:ssh-rsa [NEW_KEY_VALUE] [USERNAME_3] 為 instance 增加 tags gcloud compute instances add-tags instanceName \\--tags tag1,tag2,tag3... 封鎖全專案公開 SSH 金鑰 gcloud compute instances add-metadata [INSTANCE_NAME] --metadata block-project-ssh-keys=TRUE 允許全專案公開 SSH 金鑰 gcloud compute instances add-metadata [INSTANCE_NAME] --metadata block-project-ssh-keys=FALSE firewall-rules 增加防火牆規則gcloud compute firewall-rules create firewallRuleName --allow tcp:50005,port2,port3 --target-tags targetTags 文件連結 images 查詢可用的 images 相關資訊 gcloud compute images list 從現有的 disk 創立 image gcloud compute images create shadowsocks \\--source-disk test-shadowsock \\--source-disk-zone asia-east1-a \\--family ubuntu-1804-lts project 查詢全專案公開 ssh 金鑰並且顯示 5 行資料 gcloud compute project-info describe | grep -A 5 ssh-keys 移除或新增全專案公開 ssh 金鑰 gcloud compute project-info add-metadata --metadata-from-file ssh-keys=fileName 指令如上，以下是 fileName 的格式 [USERNAME_2]:ssh-rsa [EXISTING_KEY_VALUE_2] [USERNAME_2][USERNAME_3]:ssh-rsa [NEW_KEY_VALUE] [USERNAME_3] addresses 將現有 VM 使用的 IP 轉為靜態gcloud compute addresses create addressName \\--addresses IP \\--region regionName 列出 IPgcloud compute addresses list 刪除 IPgcloud compute addresses delete ip1 ip2 ip3 regions 取得 regions 列表gcloud compute regions list backend-service 更新 draining-time-outgcloud compute backend-services update [BACKEND_SERVICE] \\ --connection-draining-timeout [CONNECTION_TIMEOUT_SECS] DNSrecord-sets顯示區域的當前 DNS 紀錄gcloud dns record-sets list --zone=&quot;myzonename&quot; 此指令會以含有前 100 筆記錄的資源記錄集，輸出 JSON 回應。您可以指定下列額外參數： limit：要列出的記錄集數目上限。 name：只列出含有這個確切網域名稱的記錄集。 type：只列出這個類型的記錄。如果有這類記錄，則必須同時使用 –name 參數。 新增 A record 開始 transaction gcloud dns record-sets transaction start --z zoneName 增加 A 紀錄 gcloud dns record-sets transaction add &#x27;ip&#x27; --name &#x27;domainName&#x27; --ttl 5 --type A --zone &#x27;zoneName&#x27; 增加 cname 紀錄 gcloud dns record-sets transaction add -z=zoneName --type=CNAME --name=&quot;www.ray.com&quot; --ttl 5 &quot;ray.com.&quot; 增加 MX 紀錄 gcloud dns record-sets transaction add --z=zoneName --name=&quot;ray.com&quot; --ttl 5 --type MX &quot;10 mail1.ray.com.&quot; &quot;20 mail2.ray.com.&quot; 執行 gcloud dns record-sets transaction execute -z &#x27;zoneName&#x27; managed-zones列出所有 zone 列表 gcloud dns managed-zones list config 切斷 project gcloud config set projectID 取得 config 的 zone 的值 gcloud config get-value compute/zone 取得 config 的 account 的值 gcloud config get-value account projects取得 project list gcloud projects list gsutilCloud Storage mb建立儲存區, 命名規格請參考 gsutil mb gs://YOUR-BUCKET-NAME cp上傳檔案 gsutil cp ada.jpg gs://YOUR-BUCKET-NAME 下載檔案 gsutil cp -r ada.jpg gs://YOUR-BUCKET-NAME -r: recursive 複製檔案 gsutil cp gs://YOUR-BUCKET-NAME/ada.jpg gs://YOUR-BUCKET-NAME/image-folder/ ls列出物件 gsutil ls gs://YOUR-BUCKET-NAME 列出物件細節 gsutil ls -l gs://YOUR-BUCKET-NAME/ada.jpg -l: list acl增加公開存取權限 gsutil acl ch -u AllUsers:R gs://YOUR-BUCKET-NAME/fileName 移除公開存取權限 gsutil acl ch -d AllUsers gs://YOUR-BUCKET-NAME/fileName rm刪除物件 gsutil rm gs://YOUR-BUCKET-NAME/fileName containercluster 建立集群, 並且限定集群內 instance 可存取的 API 範圍gcloud container clusters create jenkins-cd \\--num-nodes 3 \\--machine-type n1-standard-2 \\--scopes &quot;https://www.googleapis.com/auth/source.read_write,cloud-platform&quot; –num-nodes: 集群含有三台機器, 最少三台 –machine-type: 機器類型 –scopes: instance 可存取的 API 範圍, API 可從官方文件 獲得 Q&amp;A","link":"/zh-tw/GCP/"},{"title":"利用GCP Marketplace來提供服務","text":"概述GCP Marketplace 讓我們可以透過簡單的幾下點擊就可以在 Google Compute Engine 部署一些常見的套裝軟體。 許多網頁框架，資料庫，客戶管理系統以及客戶關係管理系統都有支援。 這是最快速的方法之一，來讓我們的服務運行在 Google Cloud Platform. 在這個手把手教程中，你將會學習如何在 Google Cloud Platform 開始並設置一個 Marketplace 服務 本篇將會做什麼？ 使用 Marketplace 來建立一套網路工具包 核對部署 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 導覽到 Marketplace 在 Google Cloud Console ，找到 Marketplace 如下： 然後應該可以看到 Marketplace 首頁 選擇 Nginx 在搜尋欄輸入 Nginx, 然後選擇 Nginx Certified by Bitnami 的版本 建立 Nginx 工具組VM instance 設定 一旦專案建立了，我們將會被帶到位於 Cloud 主控台，新的 Nginx 部署頁面來設定我們的 Nginx instance 為 instance 取名，例如， nginxstack-1 選擇 zone 以下保持預設值 Machine type: micro(1-shared vCPU)0.6GB memory Boot Disk: 10 GB SSD “Allow HTTP Traffic” 以及 “Allow HTTPS Traffic” 需要被勾選 請接受 GCP Marketplace Terms of Service ，在頁面的下方 點擊 Deploy 來建立我們的Nginx 工具組 核對部署 當 Cloud 主控台回報，我們的 Nginx 套組已經部署完畢，我們可以核實一下，是否所有東西都正常運行，我們的畫面看起來應該如下圖： 核對網頁 點擊上圖的藍色按鈕 Visit the site ，我們可以存取部署好的 Nginx 套組，看起來如下圖： 核對 SSH 我們也可以點擊 SSH 連結來打開一個新的 VM instance 視窗。我們可以使用 Unix 指令，像是 ps 來看看 Nginx 是否正常的運行在我們的 instanceps aux | grep nginx 考考你！！ Does Google Cloud Platform Marketplace allow you to deply a software package now, and scale that deployment later when your application require additional capacity without updating the software that you have already deployed true false","link":"/zh-tw/GCPMarketplace/"},{"title":"手把手教你理解並建立 GCP 平衡負載","text":"前言為什麼要使用 Load Balancer? 可以分攤流量, 利用多台機器跑多個服務 當一台機器掛了，你還有另外一台 當負載到達一定程度，可以啟動 auto scaling (本篇不會使用到) 配合適當的 CI / CD, 以及健康檢查，可達到 rolling upgrade 的效果 本篇重點 本篇分享最簡單易設的 unmanaged Load Balancer 為避免混淆，本篇對於有意義的元件術語，將維持原文，不會特別翻譯 詳解每個元件行為 簡單的概念圖如下 (圖片來源： Google )： IPv4 以及 IPv6 的使用者，對我們的服務發請求 我們設定的 IPv4 以及 IPv6 Forwading rules，會將使用者導向我們設定好的 HTTP(S) proxy 到了 HTTP(S) proxy 的 request, 會根據我們設定好的 url-map 規則，導向相對應的backend-service, 例如說， 透過 domain name 為 ‘test1’ 的 request, 導向backend-service 1, 而 ‘test2’ 的 request 導向 backend-service 2 backend-service 由 instance group 組成，舉例來說，我們可以指定， backend-service A 導向 instance group A 的 port 8000 , 而 backend-service B 導向 instance group B 的 port 6000 instance group, 顧名思義，由 instance 所組成，當我們在 instance group 中設定好特定的 port, 並且設定好 backend-service, 那麼 request 將會經由 backend-service, 再到 instance group 指定的 port, 最後到依照 instance 本身的負載狀況, 將 request 導向適合服務的 instance 每個 backend-service 都可以設定一個 health-check, health-check 會根據指定的頻率向指定的 port 探測並取得回應，如果回應的速度低於我們設立的門檻，那麼該 instance 就會被判定為不健康。 request 不會導向已被判定為不健康的 instance 如果有 SSL 需求，可建立 SSL certificate, 並且掛在 HTTPS proxy 以下我們就開始來實作吧! 安裝 Google Cloud SDK本篇所有的指令都會使用到 Google Cloud SDK 的指令, 所有在我們開始之前，先安裝它哦！根據你的作業系統的不同，安裝方法也不一樣哦，請參考官方文件 建立 instance 建立兩個 instances gcloud compute instances create test-01 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=30GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=test-01,http-server,https-server \\--zone=asia-east1-c gcloud compute instances create test-02 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=30GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=test-02,http-server,https-server \\--zone=asia-east1-c 建立二台機器, 叫做 test-01, test-02 開機碟的空間為 30GB 從 ubuntu-os-cloud, 來 pull 我們需要的 image 我們使用 ubuntu-1804-lts 的 image 版本, 這會自動使用這個版本的最新版 硬碟類型為 pd-standard, 不知道類型可以跑 gcloud compute disk-types list 來看看 機器型號為 f1-micro, 不知道類型可以跑 gcloud compute machine-types list 來看看 tags 用來當作該 instance 的一個識別，等等開防火牆的時候會用到 zone 指定該 instance 的地區, 有些資源只有相同 zone 或者 region 可以取用，要注意 可參考官方文件 instance 環境建置以下為 instance 上的環境建置範例，與本篇主題較無關係，可跳過 apt-get update -y &amp;&amp; apt-get install curl -y &amp;&amp; curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash &amp;&amp; export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; &amp;&amp; [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; &amp;&amp; nvm install yourNodeVersion &amp;&amp; apt-get install npm -y &amp;&amp; npm install pm2 -g &amp;&amp; pm2 update &amp;&amp; apt-get install git -y &amp;&amp; apt-get install build-essential 開啟防火牆看服務跑在哪一個 port, 我們需要將防火牆打開，這樣 instance group 才能將 request 從 Load Balancer 經由 backend-service 導向相對應的 port, 可參考官方文件 gcloud compute firewall-rules create test-01 --allow tcp:123,tcp:456,tcp:789 --target-tags test-01 gcloud compute firewall-rules create test-02 --allow tcp:123,tcp:456,tcp:789 --target-tags test-02 外部靜態 IP這邊建立一個 IPv4 的靜態 IP , 之後會用到, 可參考官方文件 gcloud compute addresses create lb-test \\ --ip-version=IPV4 \\ --global Instance groupInstance group 可由多個 instance 所組成，為組成 backend-service 的主體, 可參考官方文件 建立 instance group, 之後 Load Balancer 可以用它來建立不同的 backend-service gcloud compute instance-groups unmanaged create test --description &#x27;run test project&#x27; --zone asia-east1-c 設定 named port, 所以不同的 backend-service 可以指定要用哪一個 port gcloud compute instance-groups unmanaged set-named-ports test --named-ports port1:3000,port2:6000,port3:9000,port4:12000,port5:15000 --zone asia-east1-c 將現有的 instance 加到 instance group gcloud compute instance-groups unmanaged add-instances test \\ --instances test-01,test-02 \\ --zone asia-east1-c Health checkhealth-check , 可根據我們指定的頻率，探測指定的 port, 如果該 port 無回應， health-check 將判定這個 port 不健康， backend-service 不會將 request 送往不健康的 instance 可參考官方文件 gcloud compute health-checks create tcp test-tcp-3000 \\ --description=&#x27;test tcp 3000&#x27;\\ --port=3000 gcloud compute health-checks create tcp test-tcp-6000 \\ --description=&#x27;test tcp 6000&#x27;\\ --port=6000 gcloud compute health-checks create tcp test-tcp-9000 \\ --description=&#x27;test tcp 9000&#x27;\\ --port=9000 gcloud compute health-checks create tcp test-tcp-12000 \\ --description=&#x27;test tcp 12000&#x27;\\ --port=12000 gcloud compute health-checks create tcp test-tcp-15000 \\ --description=&#x27;test tcp 15000&#x27;\\ --port=15000 Backend service這邊的 --port-name, 就是上面我們在 instance-group 中，建立的 port, 在此範例中，不同的 backend-service 會將 request 導向不同的 port, 這邊看起來沒有提到 instance group ? 別緊張，下一步我們就會把 instance group 加到 backend-service 當中。 同理， health-check 也是掛在 backend-service 上的, 因為 backend-service 將決定要將 request 導向哪一個 instance。可參考官方文件 建立後端服務 gcloud compute backend-services create backend-service-port1 \\ --protocol http \\ --port-name port1 \\ --health-checks test-tcp-3000 \\ --global gcloud compute backend-services create backend-service-port2 \\ --protocol http \\ --port-name port2 \\ --health-checks test-tcp-6000 \\ --global gcloud compute backend-services create backend-service-port3 \\ --protocol http \\ --port-name port3 \\ --health-checks test-tcp-9000 \\ --global gcloud compute backend-services create backend-service-port4 \\ --protocol http \\ --port-name port4 \\ --health-checks test-tcp-12000 \\ --global gcloud compute backend-services create backend-service-port5 \\ --protocol http \\ --port-name port5 \\ --health-checks test-tcp-15000 \\ --global 接下來，我們將 instance group 加到我們剛剛建立的 backend-service, 因為我們在建立 backend-service 時就已指定了 port, 所以 backend-service 會將 request 導向所屬的 instance group 中已指定的 port, 嗯, 聽起來有點饒舌, 不過的確是這樣。 除了設定導向的 port 之外，這邊也會設定 instance 的負載門檻。 設定 UTILIZATION 表示使用率，當使用到 80 % 時， backend-service 便會停止將 request 導向這個 instance capacity-scaler 表示， 1 * 0.8, 所以說，如果你有多個 backend-service 使用這個 instance-group, 那你希望多保留一些 instance-group 的可使用率，給其他 backend-service 使用，那就可以將 capacity-scaler 調低，如此一來，當這個 backend-service 已使用了 capacity-scaler * max-utilization 的 CPU 時，來自於該 backend-service 的請求就不會導向該 instance-group, 可以很大程度地保留該 instance-group 服務其他 backend-service 的可用性。 下面範例，可參考官方文件 將 instance group 加到 backend-service gcloud compute backend-services add-backend backend-service-port1 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port2 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port3 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port4 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port5 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global URL map前面介紹完了 backend-service, 那這個 url-map, 就是將 request 導向 backend-service 的元件。 首先，我們要先建立一個 url-map, 並且給予一個默認的 backend-service, 意思就是說，如果沒有特別指定的話，收到的 request 要導向哪一個 backend-service 下面範例，可參考官方文件 建立 URL-map gcloud compute url-maps create web-map \\ --default-service backend-service-port1 上面建立了 url-map, 並且指定了一個默認的 backend-service, 現在我們可以定義怎麼樣的 request 該導向哪一個 backend-service。 路徑的指定，我們需要使用 path-matcher, 範例如下： path-matcher: 建立一個 path-matcher, 並給予指定的路徑規則 new-hosts: 當 request 是對 host sunday.com.tw 發請求時，會套用此規則 所以就是說, 當 request 的 host 為 sunday.com.tw 時，會導向 backend-service-port1 以下為範例，可參考官方文件 新增 path-matcher gcloud compute url-maps add-path-matcher web-map \\ --default-service backend-service-port1 \\ --path-matcher-name pathmap-port1 \\ --new-hosts=sunday.com.tw 這邊可以看到比上面多了一個新的元件，叫做 path-rules 當 request 的 host 為 monday.com.tw, 默認路徑如 / 會導向 backend-service-port2 當 request 的路徑為 happy, 如 monday.com.tw/happy, 會導向 backend-service-port1 當 request 的路徑為 unhappy, 如 monday.com.tw/unhappy, 會導向 backend-service-port2 當 request 的路徑為 sad, 如 monday.com.tw/sad, 會導向 backend-service-port3 gcloud compute url-maps add-path-matcher web-map \\ --default-service backend-service-port2 \\ --path-matcher-name pathmap-port2 \\ --path-rules=/happy=backend-service-port1,/unhappy=backend-service-port2,/sad=backend-service-port3 \\ --new-hosts=monday.com.tw 以下範例同上，當 request 為 tuesday.com.tw 時，導向 backend-service-port3 gcloud compute url-maps add-path-matcher web-map \\ --default-service backend-service-port3 \\ --path-matcher-name pathmap-port3 \\ --new-hosts=tuesday.com.tw 建立 SSL 憑證要讓我們的服務支援 HTTPS, 我們需要建立 ssl-certificates, ssl-certificates 分成 self-managed, 以及 google-managed。 self-managed 顧名思義就是你提供你自己的 ssl 簽證，以下範例採用 google-managed 可參考官方文件 gcloud beta compute ssl-certificates create www-ssl-cert \\ --domains sunday.com.tw,monday.com.tw,tuesday.com.tw HTTP proxy所有來自 HTTP 的請求，都會先到這裡，再經由我們剛剛建立的 url-map 導向指定的 backend-service 可參考官方文件 建立 HTTP proxy gcloud compute target-http-proxies create http-lb-proxy \\ --url-map web-map HTTPS proxy所有來自 HTTPS 的請求，都會先到這裡，再經由我們剛剛建立的 url-map 導向指定的 backend-service 並且，我們剛剛建立的 ssl-certificates 也要掛在這, 這樣 target-https-proxies 才能支援 HTTPS 可參考官方文件 建立 HTTPS proxy gcloud compute target-https-proxies create https-lb-proxy \\--url-map web-map \\--ssl-certificates www-ssl-cert 查看外部靜態 IP 清單列出我們一開始建立的 addresses 可參考官方文件 gcloud compute addresses list 轉發規則當 request 的 address 以及 port 符合 forwarding-rules, 導向指定的 target-http-proxy 下面範例的 [LB_IP_ADDRESS] 請替換為上面建立的靜態 IP 可參考官方文件 建立 HTTP forwarding-rules gcloud compute forwarding-rules create http-content-rule \\ --address [LB_IP_ADDRESS] \\ --global \\ --target-http-proxy http-lb-proxy \\ --ports 80 當 request 的 address 以及 port 符合 forwarding-rules, 導向指定的 target-https-proxy 下面範例的 [LB_IP_ADDRESS] 請替換為上面建立的靜態 IP 可參考官方文件 建立 HTTPS forwarding-rules gcloud compute forwarding-rules create https-content-rule \\ --address [LB_IP_ADDRESS] \\ --global \\ --target-https-proxy https-lb-proxy \\ --ports 443 總結以上便是 GCP Load Balancer 的 gcloud 各元件順序流程，順序如下：request =&gt; forwarding-rules =&gt; target-http(s)-proxy =&gt; url-map =&gt; backend-service =&gt; instance-group =&gt; instance 照著以上範例跑完之後，只要在 instance 跑服務，並且跑在範例上指定的 port 號，那 request 應會照著上面的順序到達我們的服務。 我花了不少時間來寫這篇文章，希望有幫到需要的人，如果你已經看到這裡，很感謝你把它看完了！ 最後，如果你覺得這篇文章有幫到你，或者你覺得寫得不錯，你的掌聲將是對我最大的鼓勵！ 如果有發現任何錯誤，還請不吝指教哦！","link":"/zh-tw/GCPLoadBalancer/"},{"title":"GKE Migrating to Containers","text":"容器正在以很快的速度成為軟體應用部署的業界標準。 容器化所帶來的商業以及技術上的好處正在推動很多團隊將他們的應用移到容器內。 本教程會提供一個基礎的示範, 示範如何將一個無狀態的應用, 從 VM 上轉移到 Kubernetes Engine (GKE), 本範例示範了應用轉移的過程, 從典型的 VM/OS-based 部署, 到特定的容器化的 os, 再到一個你所知道的容器專用的平台 GKE 概述容器化部署應用有許多的好處, 像是： 隔離 - 應用們有各自的 libraries; 各個應用之間不會因為有不同的 libraries 而產生衝突。 限制(CPU/memory) - 應用們不會佔用其他應用的資源 可攜帶 - 容器含有任何所需的東西, 且不會被 OS 或雲端服務商綁死 輕量化 - 共享 Kernel, 比完整的 OS 鏡像還要輕量且快速 學習目標這個專案示範了轉移一個名為 Prime-flask 的簡單 Python 應用, 到： 一台 虛擬機(Debian VM), Prime-flask 是被部署在這台機器上的唯一應用, 就好像是傳統的運行在一台實體資料中心上的應用。 一個容器化版本的 Prime-flask, 被部署在 Container-Optimized OS (COS) 使用 [Kubernetes] 將 Prime-flask 部署在 Kubernetes Engine 上, 並且使負載平衡來暴露服務。 在完成部署後, 你將會針對最後版本的部署實施一個負載測試, 並且擴縮服務來適應負載 在教程途中, 如果有遇到什麼錯誤, 可以重新執行失敗的 script, 因為偶而會因為網路連線問題出錯, 重試之後就好了。 本教程由 GKE Helmsman 工程師建立, 讓你更了解如何轉移到容器。 你可以在這檢視範例, 並且, 我們歡迎任何人貢獻這個專案。 架構佈局 1: 運行 Debian 的虛擬機, 應用被直接部署到主機的 OS, 無容器 佈局 2: 虛擬機運行容器優化的 OS, 應用被部署在容器內 佈局 3: Kubernetes Engine (GKE) 平台, 很多容器運行在很多機器上 用於此範例的一個簡單的 Python Flask web 應用 (Prime-flask) 已被建立, 並且擁有兩個端點：http://&lt;ip&gt;:8080/factorial/ 以及 http://&lt;ip&gt;:8080/prime/ 使用範例如下： curl http://35.227.149.80:8080/prime/10The sum of all primes less than 10 is 17curl http://35.227.149.80:8080/factorial/10The factorial of 10 is 3628800 以及也可用來驗證是否成功部署 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 安裝 ApacheBench現在安裝 ApacheBench: sudo apt-get install apache2-utils 當被詢問是否繼續是, 輸入 “y” 驗證安裝是否成功： ab -V 輸出應如下： This is ApacheBench, Version 2.3 &lt;$Revision: 1757674 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, 建立虛擬環境執行以下指令下載並更新套件清單: sudo apt-get update Python 虛擬環境是被用來獨立系統內的套件安裝 sudo apt-get install vitualenv 如果跳出 [Y/n], 選擇 Y, 然後按 Enter virtualenv -p python3 venv 啟動虛擬環境 source venv/bin/activate 複製倉庫git clone https://github.com/GoogleCloudPlatform/gke-migration-to-containers.git 到範例資料夾內： cd gke-migration-to-containers 設定你的 region 以及 zone特定的 Compute Engine 資源位於 regions 以及 zones, 一個 region 為一個運行你的資源的特定地理位置, 然一個 region 有一或多個 zones 更多有關 regions 以及 zones 的資訊可以參考 Regions &amp; Zones documentation 運行以下的指令來設定本教程中的 region 以及 zone (你也可以使用對你來說最佳的 region/zone) gcloud config set compute/region us-central1gcloud config set compute/zone us-central1-a 部署這個專案需要的基礎設施可執行以下指令部署 make create 這個範例的設定大概需要最多 15 分鐘。 如果沒有跳錯的話, 建議持續等待。 不要中斷 make create 的執行。 資源建立的過程中, 你可以從主控台的 Compute Engine &gt; VM instances 確認目前進度。 等待過程中, 可以看一下 create.sh script 的內容, 了解它幫你建立了什麼。 你可以使用編輯器來檢視 gke-migration-to-containers/scripts/create.sh make create 指令執行了 create.sh script, 做了以下幾件事： 打包 Prime-flask 應用, 使它可以被複製到 Google Cloud Storage 透過 Google Cloud Build 建立容器鏡像, 並推送到這個專案的 private Container Registry (GCR) 產生 Terraform 適當的設置 執行 Terraform, 建立上述的情境 範例輸出如下：Terraform 建立一個 VM, COS VM, 以及 GKE 叢集： Terraform 輸出顯示在 Debain VM 以及 COS 系統的 (factorial endpoints) 階乘端點： Kubernetes 叢集以及 Prime-flask 服務也被啟動： 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立基礎設施, 你將獲得一個評價分數。 探索 Prime-Flask 環境三個不一樣的環境已經完成設置, Prime-flask app 可以橫跨這些環境, 成為一個在單一虛擬機上運行的容器化應用, 到一個 pod, 運行在一個編排容器的平台, 像是 Kubernetes 一旦你的資源已經準備就緒, 這對你探索系統來說有很大的幫助。 執行以下指令到 vm-webserver 機器, 在這台機器上, 應用正運行在主機的作業系統 gcloud compute ssh vm-webserver --zone us-central1-a 如果有詢問是否繼續, 輸入 “Y”, 按下 Enter 兩次來確認不使用密碼 這個環境中沒有隔離效果, 攜帶性也不好。 在某種意義上, 這個應用具有整個系統的存取權, 且在一些其他因素下, 可能無法在失敗後自動回復。 若要擴充這個應用可能需要更多台的虛擬機, 而這很可能無法有效地利用資源。 列出所有程序： ps aux (輸出) root 882 0.0 1.1 92824 6716 ? Ss 18:41 0:00 sshd: user [priv]user 888 0.0 0.6 92824 4052 ? S 18:41 0:00 sshd: user@pts/0user 889 0.0 0.6 19916 3880 pts/0 Ss 18:41 0:00 -bashuser 895 0.0 0.5 38304 3176 pts/0 R+ 18:41 0:00 ps auxapprunn+ 7938 0.0 3.3 48840 20328 ? Ss Mar19 1:06 /usr/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-serverapprunn+ 21662 0.0 3.9 69868 24032 ? S Mar20 0:05 /usr/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 離開： exit 執行以下指令到 cos-vm 機器, 在這台機器上你運行著 docker 容器 gcloud compute ssh cos-vm --zone us-central1-a 如果有詢問是否繼續, 輸入 “Y”, 按下 Enter 兩次來確認不使用密碼 COS 是一個優化過的作業系統, 作業系統佔用了很小的空間, 這也是它比較適合運行容器化工作的原因之一。 它是先安裝了 cloud-init 以及 Docker runtime, 而如果有些容器並不需要跑在一些高可靠性的平台的話, 也是很適合跑在這樣的系統。 你可以在宿主機上運行 ps aux 來檢視運行中的 prime-flask ps aux 注意到 docker 以及容器的參考資訊： root 626 0.0 5.7 496812 34824 ? Ssl Mar19 0:14 /usr/bin/docker run --rm --name=flaskservice -p 8080:8080 gcr.io/migration-to-containers/prime-flask:1.0.2root 719 0.0 0.5 305016 3276 ? Sl Mar19 0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 8080 -container-ip 172.17.0.2 -container-port 8080root 724 0.0 0.8 614804 5104 ? Sl Mar19 0:09 docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/mochronos 741 0.0 0.0 204 4 ? Ss Mar19 0:00 /usr/bin/dumb-init /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-serverchronos 774 0.0 3.2 21324 19480 ? Ss Mar19 1:25 /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-serverchronos 14376 0.0 4.0 29700 24452 ? S Mar20 0:05 /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 並且, 如果你試著列出 python path, 會顯示不存在 ls /usr/local/bin/python (輸出) ls: cannot access &#x27;/usr/local/bin/python&#x27;: No such file or directory Docker 列出容器 sudo docker ps (輸出) CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd147963ec3ca gcr.io/migration-to-containers/prime-flask:1.0.2 &quot;/usr/bin/dumb-init …&quot; 39 hours ago Up 39 hours 0.0.0.0:8080-&gt;8080/tcp flaskservice 現在你可以執行以下指令來檢視運行在容器內的程序: sudo docker exec -it $(sudo docker ps |awk &#x27;/prime-flask/ &#123;print $1&#125;&#x27;) ps aux (輸出) PID USER TIME COMMAND 1 apprunne 0:00 /usr/bin/dumb-init /usr/local/bin/gunicorn --bind 0.0.0.0: 6 apprunne 1:25 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn - 17 apprunne 0:05 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn - 29 apprunne 0:00 ps aux 退出： exit 接下來, 讓我們到 Kubernetes 環境。 在 Kubernetes 我們可以運行千百個 pods, pods 代表容器的群組。 Kubernetes 是現今部署容器的標準。 它提供了高生產力, 可靠性, 以及擴充性。 Kubernetes 讓你的容器有個家, 且當你的容器失敗了, 它會再次重啟它。 你可以使用很多機器來組成一個叢集, 所以你可以讓它橫跨了不同的區域, 確保了可用性, 以及一些對潛在問題的高適應性。 取得叢集配置： gcloud container clusters get-credentials prime-server-cluster 取得運行在預設命名空間下的 pods kubectl get pods (輸出) NAME READY STATUS RESTARTS AGEprime-server-6b94cdfc8b-dfckf 1/1 Running 0 2d5h 檢視 pod 內運行著什麼： kubectl exec $(kubectl get pods -lapp=prime-server -ojsonpath=&#x27;&#123;.items[].metadata.name&#125;&#x27;) -- ps aux (輸出) PID USER TIME COMMAND 1 apprunne 0:00 /usr/bin/dumb-init /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 6 apprunne 1:16 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 8 apprunne 2:52 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 19 apprunne 0:00 ps aux 如你所見, python 應用目前正運行在容器內。 這個應用無法存取任何主機上的東西, 因為這個容器是被隔離的。 它運行在一個 Linux 命名空間, 且(預設)無法存取檔案, 網路, 或在 VM 上的, 在容器裡的, 或任何地方的其他資源。 驗證現在此應用已被部署, 執行以下指令來驗證三種部署: make validate API 可能會花一些時間完成。 立即執行 make validate 可能會出現錯誤, 但那是因為 instances 還沒有完成初始化。 等個 1 或 2 分鐘然後重試一次應可以解決任何問題。 一個成功的輸出將如下： Validating Debian VM Webapp...Testing endpoint http://35.227.149.80:8080Endpoint http://35.227.149.80:8080 is responding.**** http://35.227.149.80:8080/prime/10The sum of all primes less than 10 is 17The factorial of 10 is 3628800Validating Container OS Webapp...Testing endpoint http://35.230.123.231:8080Endpoint http://35.230.123.231:8080 is responding.**** http://35.230.123.231:8080/prime/10The sum of all primes less than 10 is 17The factorial of 10 is 3628800Validating Kubernetes Webapp...Testing endpoint http://35.190.89.136Endpoint http://35.190.89.136 is responding.**** http://35.190.89.136/prime/10The sum of all primes less than 10 is 17The factorial of 10 is 3628800 當然, IP 位址會與你的不同。 負載測試在 Cloud Shell 點擊 + 打開新的 Cloud Shell 視窗。 執行以下指令, 記得將 [IP_ADDRESS] 替換成從驗證輸出得到的 IP 位址以及 port, 注意 Kubernetes 部署運行在 port 80, 而其他兩個部署運行在 port 8080 ab -c 120 -t 60 http://&lt;IP_ADDRESS&gt;/prime/10000 ApacheBench(ab) 將在一分鐘內每秒鐘對指定端點發送 120 個併發請求。範例應用的規模並不足以處理這個數量的請求。 結果可以經由 ab 指令的輸出來確認, 如果你看到一個 Failed requests 的值大於 0, 這表示 server 無法成功回應這個負荷 注意: 能不會三個資源都有錯誤 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功地實施負載測試, 你將獲得一個評價分數。 若要確保你的系統可以處理這樣的流量, 可以使用擴充。 在此範例中, 我們將水平的擴充服務 在 Debian 以及 COS 架構, 水平擴充包含： 建立一個平衡負載 開啟額外的機器 使用平衡負載來重新註冊機器 這是一個複雜的程序, 且不在本範例的範圍內。 在第三個部署中 (Kubernetes), 這個程序簡單多了 在你的第一個 Cloud Shell 視窗, 執行以下指令: kubectl scale --replicas 3 deployment/prime-server 測試進度點擊 Check my progress 來確認目前的進度。如果你成功地擴充了你的部署, 你將獲得一個評價分數。 等待 30 秒鐘讓 replicas 初始化, 重新執行以下負載測試： ab -c 120 -t 60 http://&lt;IP_ADDRESS&gt;/prime/10000 可以注意到, Failed requests 現在是 0, 這代表針對這所有的 10,000+ 請求, server 都有成功回應。 清理儘管 Qwiklabs 將會清理所有在本教程中提供的資源, 不過也可以學學如何清理你的環境 在第一個 Cloud Shell 執行以下指令： make teardown 這將執行 terraform destroy, 它會刪除所有本範例中建立的資源。 恭喜你已完成本教程","link":"/zh-tw/GKEMigratingToContainers/"},{"title":"設定 Network 以及 HTTP 平衡負載器","text":"概述在這個教程中，你將會學習 network load balance 與 HTTP load balance 之間的不同，以及如何正確地根據你的應用來設定，讓你的應用在 Google Compute Engine VM 上運行平衡負載的功能。 有好幾種方法可以在Google Cloud Platform 上實施平衡負載。 本教程會帶你走過以下兩種負載器的設定： L3 Network Load Balancer L7 HTTP(s) Load Balancer 學生們會建議自己輸入指令，這對學習核心概念有幫助。 很多教程中，都會有代碼區塊，可以直接複製需要的代碼，你可以很簡單的從代碼區塊複製貼上這些指令到教程中適當的位置。 你將會做什麼 設定一個網路平衡負載器 設定一個 HTTP(S) 平衡負載器 通過實作，學習兩者之間的不同之處 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 為你的資源設定預設的 region 以及 zone 在 Cloud Shell ，設定預設 zonegcloud config set compute/zone us-central1-a 在 Cloud Shell ，設定預設 regiongcloud config set compute/region us-central1 建立多個 web server instance 為了模擬使用一個群組的機器來服務，我們可以利用 Instance Template 以及 Managed Instance Groups 來創建一個群集的 Nginx web servers 用以服務靜態的內容。 Instance Template 定義了在這個群組中的 virtual machine 的規格（ disk, CPUs, memory, 等等）。 Managed Instance Groups 可以初始化多台使用 Instance Template 定義的 virtual machine 要建立一個 Nginx web server 服務群，建立以下事物: 一份用來設定所有 virtual machine 上的 Nginx server 的 script 一份 instance template 來使用上述的 script 一個 target pool 一個使用 instance template 的 managed instance group 在 Cloud Shell 中，建立一個使用在所有 VM 上的 startup script。 這個腳本會在一開始時設定 Nginx server cat &lt;&lt; EOF &gt; startup.sh#! /bin/bashapt-get updateapt-get install -y nginxservice nginx startsed -i -- &#x27;s/nginx/Google Cloud Platform - &#x27;&quot;\\$HOSTNAME&quot;&#x27;/&#x27; /var/www/html/index.nginx-debian.htmlEOF 建立使用 startup script 的 instance template gcloud compute instance-templates create nginx-template \\ --metadata-from-file startup-script=startup.sh (輸出) Created [...].NAME MACHINE_TYPE PREEMPTIBLE CREATION_TIMESTAMPnginx-template n1-standard-1 2015-11-09T08:44:59.007-08:00 建立 target pool 。一個 target pool 將針對所有的群組內的 instance 提供一個存取點，且在之後的平衡負載步驟，這是必須的。 gcloud compute target-pools create nginx-pool (輸出) Created [...].NAME REGION SESSION_AFFINITY BACKUP HEALTH_CHECKSnginx-pool us-central1 建立一個使用 instance template 的 managed instance group gcloud compute instance-groups managed create nginx-group \\ --base-instance-name nginx \\ --size 2 \\ --template nginx-template \\ --target-pool nginx-pool (輸出) Created [...].NAME LOCATION SCOPE BASE_INSTANCE_NAME SIZE TARGET_SIZE INSTANCE_TEMPLATE AUTOSCALEDnginx-group us-central1-a zone nginx 0 2 nginx-template no 這將會建立兩個擁有相同前綴名稱 nginx-的vurtual machine ，需要幾分鐘。 檢視所有已建立的 instances gcloud compute instances list (輸出) NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSnginx-7wvi us-central1-a n1-standard-1 10.240.X.X X.X.X.X RUNNINGnginx-9mwd us-central1-a n1-standard-1 10.240.X.X X.X.X.X RUNNING 現在設定防火牆，所以我們可以經由 port 80，EXTERNAL_IP 位址來連接我們的機器 gcloud compute firewall-rules create www-firewall --allow tcp:80 現在我們應該要可以經由上述的 external IP 位址連接到任何一台的 instance 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 建立Network Load BalancerNetwork Load Balancing 允許我們依據收到的 IP 協議資料，像是位址， port 號，還有協議類型，來平衡負載我們的系統。我們還可以取得一些 HTTP(S) load balancing 沒有提供的選項，例如說，基於 TCP/UDP 的協議, 像是 SMTP traffic ，且如果你的應用對 TCP 連結相關的特性感興趣的話， Network Load Balacing 也允許你的 app 去檢查封包，這是 HTTP(S) Load Balancing 沒有提供的。 更多資訊，可以參考Setting Up Network Load Balancing 針對我們的 instance ，建立一個 L3 network load balancer gcloud compute forwarding-rules create nginx-lb \\ --region us-central1 \\ --ports=80 \\ --target-pool nginx-pool (輸出) Created [https://www.googleapis.com/compute/v1/projects/...]. 列出所有 Google Compute Engine 轉發的規則 gcloud compute forwarding-rules list (輸出) NAME REGION IP_ADDRESS IP_PROTOCOL TARGETnginx-lb us-central1 X.X.X.X TCP us-central1/targetPools/nginx-pool 經由瀏覽器來拜訪 load balancerhttp://IP_ADDRESS/IP_ADDRESS 可從上一個指令輸出中找到 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 建立一個 HTTP(S) Load BalancerHTTP(S) Load Balancing 提供全球性的所有對我們的 instance 所做的請求。我們可以設定 URL 規則來將某些 URL 導向一些 instance ，而將另一些 URL 導向另外一些 instance 。正常下，請求將會被導向離使用者最近的 instance ，以確保該群組的 instance 有足夠的資源可以提供給使用者。如果被導向的 instance 沒有足夠的資源，那請求將會被導向離使用者最近的並且有足夠資源的 instance 更多資訊可以參考 HTTP(s) Load Balancer in the documentation 首先，建立一個 health check 。 Health check 可以核實 instance 有針對 HTTP 或 HTTPS 通道做回應 gcloud compute http-health-checks create http-basic-check (輸出) Created [https://www.googleapis.com/compute/v1/projects/...].NAME HOST PORT REQUEST_PATHhttp-basic-check 80 / 定義一個 HTTP 服務，並且給予我們 instance 使用的 port 號, 現在平衡負載服務已經將流量轉發到指定的 port gcloud compute instance-groups managed \\ set-named-ports nginx-group \\ --named-ports http:80 (輸出) Updated [https://www.googleapis.com/compute/v1/projects/...]. 建立 後端服務 gcloud compute backend-services create nginx-backend \\ --protocol HTTP --http-health-checks http-basic-check --global (輸出) Created [https://www.googleapis.com/compute/v1/projects/...].NAME BACKENDS PROTOCOLnginx-backend HTTP 將我們的 instance 群組加到後端服務: gcloud compute backend-services add-backend nginx-backend \\ --instance-group nginx-group \\ --instance-group-zone us-central1-a \\ --global (輸出) Updated [https://www.googleapis.com/compute/v1/projects/...]. 建立一個預設的 URL 指定，他將會把所有收到的請求導向我們的 instance gcloud compute url-maps create web-map \\ --default-service nginx-backend (輸出) Created [https://www.googleapis.com/compute/v1/projects/...].NAME DEFAULT_SERVICEWeb-map nginx-backend 若要直接將流量基於請求的 URL 不同，導向不同的 instance, 請參考 content-based routing 建立一個 target HTTP proxy 來將請求導向我們的 URL map gcloud compute target-http-proxies create http-lb-proxy \\ --url-map web-map (輸出) Created [https://www.googleapis.com/compute/v1/projects/...].NAME URL_MAPhttp-lb-proxy web-map 建立一個全球轉發規則來處理導向所有收到的請求。一個轉發規則將流量送到指定的 HTTP 或 HTTPS 代理根據請求的 IP 位址， IP 協議，或特定的 port 號。全球轉發規則不支援多個 port gcloud compute forwarding-rules create http-content-rule \\ --global \\ --target-http-proxy http-lb-proxy \\ --ports 80 (輸出) Created [https://www.googleapis.com/compute/v1/projects/...]. 全球轉發規則建立之後，需要幾分鐘時間生效 gcloud compute forwarding-rules list (輸出) NAME REGION IP_ADDRESS IP_PROTOCOL TARGEThttp-content-rule X.X.X.X TCP http-lb-proxynginx-lb us-central1 X.X.X.X TCP us-central1/.... 我們現在應該要可以從瀏覽器經由http://IP_ADDRESS/來連接，這可能會需要幾分鐘生效。如果無法連接，多等一些時間，重新整理瀏覽器。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 答案是 true 恭喜你已經完成本教程","link":"/zh-tw/HTTPAndNetworkLoadBalancer/"},{"title":"IAM 自訂角色","text":"概述Cloud IAM 提供適當的工具, 以最少的麻煩, 高自動化來管理資源的權限。 你不直接賦予使用者權限。 你賦予他們角色, 角色與一個或多個權限綁定。 這個功能讓我們可以依照工作內容來付予適當的群組以及角色權限。 使用者只會被賦予足夠完成他們工作的權限, 而管理者可以輕鬆地賦予預設權限到整個群組的使用者。在 Cloud IAM 中, 有兩種角色: 預定義好的角色 自定義角色 預定義角色 由 Google 建立並管理。 他們的權限視必要會自動更新, 例如 GCP 新加入了功能或服務。 自定義角色 為使用者自定義, 讓我們可以視需求綁定一個或多個有支援的權限。 自定義角色不被 Google 維護, 當有新權限, 新功能, 或新服務新增到 GCP, 你的自定義角色將不會自動被更新。 自定義角色由一個或多個可用的 Cloud IAM 權限所組成。 權限讓使用者可以對 Google Cloud Platform 資源做特定的操作 你將在本教程中做什麼？ 建立, 更新, 刪除, 取消刪除自定義角色 預先具備條件 對 IAM 角色熟悉 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 理解 IAM 自定義角色Cloud IAM 也提供了自定義角色的能力。 你可以建立一個自訂義的 Cloud IAM 角色, 並加入一個或多個權限, 然後將這個角色賦予給使用者。 Cloud IAM 提供圖形化以及 API 的方式來建立以及管理自定義角色 Key Point: 自定義角色讓你可以實施最低特權的原則, 確保在你的組織中, 使用者以及服務帳號都僅有剛好足夠完成他們工作的權限。 **Note:** 你可以建立組織等級以及專案等級的自定義角色, 但你無法建立資料夾等級的自定義角色。 藉由整合一個或多個 Cloud IAM 權限, 建立一個自定義角色。 權限可以讓使用者在 Cloud Platform 資源做特定的操作。 在 Cloud IAM 的世界, 權限被表現為以下格式： &lt;service&gt;.&lt;resource&gt;.&lt;verb&gt; 例如, compute.instances.list 權限讓使用者可以列出他們擁有的 Google Compute Engine instance, 而 compute.instances.stop 讓使用者停止一台 VM 通常, 但不是絕對, 權限跟 REST 方法的比例為 1:1 。 這代表說, 每一個 GCP 服務中, 每一個 REST 方法都會有一個相關的權限。 要呼叫一個方法, 你需要相對應的權限。 比如說, topic.publish() 的呼叫者會需要 pubsub.topics.publish 的權限。 唯有該資源是隸屬在該專案或組織的情況之下, 你才可以在該專案或組織內賦予跟此資源有關的權限。 如果你想要自定義角色擁有不屬於這個專案或組織的資源的權限, 那是不行的。 必要的權限以及角色要建立一個自定義角色, 呼叫者必須擁有 iam.roles.create 權限 非擁有者的使用者包含 organization administrators (組織管理者), 必須要被賦予 Organization Role Administrator (組織角色管理者) (roles/iam.organizationRoleAdmin) 或是 IAM Role Administrator (IAM 角色管理者) (roles/iam.roleAdmin) 。 IAM Security Reviewer (IAM 安全審查者) (roles/iam.securityReviewer) 可以檢視自定義角色, 但無法管理他們 自定義角色使用者的介面位於 Google Cloud Platform 主控台的 IAM Roles 之下。 只有有權限的使用者可以建立或管理自定義角色。 若照預設, 只有專案擁有者可以建立新角色。 專案擁有者可以藉由給予其他使用者 IAM Role Administrator 角色來做權限操作; 若是組織的話, 只有組織管理者可以賦予 Organization Role, Administrator 角色 準備建立自定義角色在自定義角色之前, 你可能會想知道 什麼樣的權限可以應用在資源上 什麼樣的角色可以被賦予在資源上 什麼是角色的 metadata? 檢視可獲得的資源權限在你建立一個自訂義角色之前, 你可能會想要知道什麼權限可以被應用到資源上。 你可以使用 gcloud command-line 工具, 主控台, 或是 IAM API 來取得所有適用在資源上的權限, 以及階層排列的資源。 例如, 你可以取得所有你可應用在一個組織中的權限, 以及那個組織中的專案的權限。 執行以下的執行來取得專案中可獲得的權限列表： gcloud iam list-testable-permissions //cloudresourcemanager.googleapis.com/projects/$DEVSHELL_PROJECT_ID 輸出： name: appengine.applications.createstage: GA---name: appengine.applications.getstage: GA---name: appengine.applications.updatestage: GA---name: appengine.instances.delete stage: GA---name: appengine.instances.getstage: GA---name: appengine.instances.liststage: GA---customRolesSupportLevel: TESTINGname: appengine.memcache.addKeystage: BETA---customRolesSupportLevel: TESTINGname: appengine.memcache.flushstage: BETA--- 取得角色 metadata在你建立自訂義角色之前, 你可能會想要獲得事先定義以及自定義角色的 metadata。 角色 metadata 包含角色 ID 以及該角色擁有的權限。 你可以使用 Google Cloud Platform 主控台或者是 IAM API 來檢視 metadata 執行以下指令來檢視角色 metadata, 將 [ROLE_NAME] 替換成欲檢視的角色, 例如： roles/viewer 或 roles/editor gcloud iam roles describe [ROLE_NAME] 範例輸出(roles/viewer): description: Read access to all custom roles in the project.etag: AA==includedPermissions:- iam.roles.get- iam.roles.list- resourcemanager.projects.get- resourcemanager.projects.getIamPolicy......name: roles/iam.roleViewerstage: GAtitle: Role Viewer 檢視資源上可賦予的角色使用 gcloud iam list-grantable-roles 指令來獲得可賦予到指定資源上的角色列表 執行以下的 gcloud 指令來列出你的專案中可賦予的角色: gcloud iam list-grantable-roles //cloudresourcemanager.googleapis.com/projects/$DEVSHELL_PROJECT_ID 輸出應如下： ---description: Full management of App Engine apps (but not storage).name: roles/appengine.appAdmintitle: App Engine Admin---description: Ability to view App Engine app status.name: roles/appengine.appViewertitle: App Engine Viewer---description: Ability to view App Engine app status and deployed source code.name: roles/appengine.codeViewertitle: App Engine Code Viewer---...... 建立自定義角色要建立自定義角色, 呼叫者必須擁有 iam.roles.create 權限。 預設來說, 專案或組織的擁有者擁有可以建立以及管理自定義角色的權限 非擁有者的使用者, 包含組織管理員, 必須被賦予 Organization Role Administrator 角色, 或是 IAM Role Administrator 角色 使用 gcloud iam roles create 指令來建立新的自訂義角色。 你有兩種方式來使用這個指令： 提供含有角色定義的 YAML 檔案 當建立自定義角色時, 使用指定角色定義的旗標, 你必須指定指令的作用範圍, 是組織等級的還是專案等級的, 使用 --organization [ORGANIZATION_ID] 或 --project [PROJECT_ID] 旗標。 下面的範例都是建立一個專案等級的自定義角色 循著以下的範例, 你將建立專案等級的自訂義角色 使用 YAML 檔案來建立自訂義角色建立一個含有自定義角色定義的 YAML 檔。 檔案的結構必須像下面這樣： title: [ROLE_TITLE]description: [ROLE_DESCRIPTION]stage: [LAUNCH_STAGE]includedPermissions:- [PERMISSION_1]- [PERMISSION_2] 填入值的敘述如下： [ROLE_TITLE] 角色職稱, 像是 Role Viewer, 可自定義 [ROLE_DESCRIPTION] 簡短的角色敘述, 像是 My custom role description [LAUNCH_STAGE] 角色在啟動的生命週期, 像是 ALPHA, BETA, 或 GA, 可參考文件 [includePermissions] 指定了一個或多個這個自定義角色將包含的權限, 像是 iam.roles.get 該是動手的時間了！ 建立你的角色定義 YAML 檔, 執行以下指令： vim role-definition.yaml 將下面的定義增加到 YAML 檔案： title: &quot;Role Editor&quot;description: &quot;Edit access for App Versions&quot;stage: &quot;ALPHA&quot;includedPermissions:- appengine.versions.create- appengine.versions.delete 然後儲存並關閉檔案 執行下面的 gcloud 指令: gcloud iam roles create editor --project $DEVSHELL_PROJECT_ID \\--file role-definition.yaml 如果角色成功被建立, 會得到以下的回應 Created role [editor].description: Edit access for App Versionsetag: BwVs4O4E3e4=includedPermissions:- appengine.versions.create- appengine.versions.deletename: projects/[PROJECT_ID]/roles/editorstage: ALPHAtitle: Role Editor 使用 flag (旗標) 來建立自定義角色現在你將使用旗標方法來建立一個新的自訂義角色。 旗標方法採用一個類似 YAML 檔案的格式, 所以你將可以辨識這個指令是如何被建立的 執行以下 gcloud 指令來使用旗標建立一個新的角色 gcloud iam roles create viewer --project $DEVSHELL_PROJECT_ID \\--title &quot;Role Viewer&quot; --description &quot;Custom role description.&quot; \\--permissions compute.instances.get,compute.instances.list --stage ALPHA 範例輸出： Created role [viewer].description: Custom role description.etag: BwVs4PYHqYI=includedPermissions:- compute.instances.get- compute.instances.listname: projects/[PROJECT_ID]/roles/viewerstage: ALPHAtitle: Role Viewer 列出自定義角色執行以下指令來列出自定義角色, 指定專案等級或是組織等級 gcloud iam roles list --project $DEVSHELL_PROJECT_ID 範例輸出： ---description: Edit access for App Versionsetag: BwVxLgrnawQ=name: projects/[PROJECT_ID]/roles/editortitle: Role Editor---description: Custom role description.etag: BwVxLg18IQg=name: projects/[PROJECT_ID]/roles/viewertitle: Role Viewer 若要列出已刪除的角色, 你可以使用 --show-deleted 旗標執行下面的 gcloud 指令來列出預定義的角色 gcloud iam roles list 編輯一個現存的自定義角色更新資源的 metadata 的一個常用模式, 例如更新一個自訂義角色, 會先讀他目前的狀態, 在本地更新資料, 然後送出更改後的資料來複寫。 如果兩個或以上的動作同時發生, 可能會造成衝突 例如, 如果兩個專案的擁有者在同一時間試圖對一個角色做修改, 某些改變可能會失敗 Cloud IAM 在自定義角色中使用 etag 屬性來解決這個問題。 這個屬性被使用來核對這個自定義角色從上次請求之後是否被更改過了。 當你使用 etag 對 Cloud IAM 送出一個請求, Cloud IAM 會比較請求中以及目前的 etag 值, 唯有 etag 值吻合了, 變更才會被寫入 使用 gcloud iam roles update 指令來更新自定義角色。 你有兩種方式來使用這個指令: 提供含有角色定義的 YAML 檔案 當更新自定義角色時, 使用指定角色定義的旗標 當更新一個自定義角色時你必須指定指令的作用範圍, 是組織等級的還是專案等級的, 使用 --organization [ORGANIZATION_ID] 或 --project [PROJECT_ID] 旗標。 下面的範例都是建立一個專案等級的自定義角色 describe 指令會返回角色的定義, 包含可獨特辨識角色目前版本的 etag 值。 當更新角色定義時, etag 值必須被提供, 以確保同時變更的請求不會互相複寫 使用 YAML 檔案來更新自定義角色執行以下的 gcloud 指令來取得目前的角色定義, 將 [ROLE_ID] 替換成 editor gcloud iam roles describe [ROLE_ID] --project $DEVSHELL_PROJECT_ID describe 指令會返回以下輸出: description: [ROLE_DESCRIPTION]etag: [ETAG_VALUE]includedPermissions:- [PERMISSION_1]- [PERMISSION_2]name: [ROLE_ID]stage: [LAUNCH_STAGE]title: [ROLE_TITLE] 你將使用輸出的值來建立一個新的 YAML 檔案。 從這個指令中複製輸出 使用你的編輯器建立一個 new-role-definition.yaml vim new-role-definition.yaml 將上面輸出的值貼上, 然後在 includedPermissions 下面增加兩個權限： - storage.buckets.get- storage.buckets.list 現在你的 YAML 檔看起來應該如下： description: Edit access for App Versionsetag: BwVxIAbRq_I=includedPermissions:- appengine.versions.create- appengine.versions.delete- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/editorstage: ALPHAtitle: Role Editor 儲存並離開檔案 現在你將使用 update 指令來更新角色。 執行以下的 gcloud 指令, 將 [ROLE_ID] 替換成 editor: gcloud iam roles update [ROLE_ID] --project $DEVSHELL_PROJECT_ID \\--file new-role-definition.yaml 如果角色成功被更新, 輸出會像以下那樣: description: Edit access for App Versionsetag: BwVxIBjfN3M=includedPermissions:- appengine.versions.create- appengine.versions.delete- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/editorstage: ALPHAtitle: Role Editor 使用旗標來更新自定義角色角色定義更新中, 每部份都有各自對應的旗標。 旗標清單可參考文件 你可以使用下面的旗標來增加以及移除權限: --add-permissions: 增加一個或多個, 以逗號分隔的權限 --remove-permissions: 移除一個或多個, 以逗號分隔的權限 你也可以指定新的權限來取代掉目前的權限, 使用 --permissions [PERMISSIONS] 旗標以及以逗號來分隔權限 執行下面的 gcloud 指令, 使用旗標來增加權限到 viewer 角色 gcloud iam roles update viewer --project $DEVSHELL_PROJECT_ID \\--add-permissions storage.buckets.get,storage.buckets.list 如果角色成功地被更新, 以下的輸出將會返回 description: Custom role description.etag: BwVxLi4wTvk=includedPermissions:- compute.instances.get- compute.instances.list- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/viewerstage: ALPHAtitle: Role Viewer 使自定義角色失效當角色被無效化, 與之相連的政策也會失效, 就是說權限將會停止被賦予到這個角色, 儘管你賦予了使用者這個角色 無效化一個現存自定義角色最簡單的方法就是使用 --stage 指標來把它設成 DISABLED 執行以下的 gcloud 指令來無效化 viewer 角色 gcloud iam roles update viewer --project $DEVSHELL_PROJECT_ID \\--stage DISABLED 如果角色成功地被更新了, 將會返回以下輸出： description: Custom role description.etag: BwVxLkIYHrQ=includedPermissions:- compute.instances.get- compute.instances.list- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/viewerstage: DISABLEDtitle: Role Viewer 刪除自定義角色使用 gcloud iam roles delete 指令來刪除自定義角色。 一旦角色被刪了, 它就失效了, 無法再被用來與任何政策相對應 gcloud iam roles delete viewer --project $DEVSHELL_PROJECT_ID 範例輸出： description: Custom role description.etag: BwVxLkf_epw=includedPermissions:- compute.instances.get- compute.instances.list- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/viewerstage: DISABLEDtitle: Role Viewer 在角色被刪除之後, 現存的連結將會保留, 但是是無效的。 角色可以在 7 天內被復原, 要是過了 7 天, 這個角色會進入一個永久刪除程序, 持續 30 天, 所以過了 37 天之後, 這個角色的 ID 又可以被使用了 注意： 如果角色被棄用了, 修改 role.stage 屬性為 DEPRECATED, 然後設定 deprecation_message, 這樣可以讓使用者知道替代角色是哪一個, 或是哪裡可以得到更多資訊 復原自定義角色在 7 天內, 你可以復原一個刪除了的角色。 被刪除的角色處於 DISABLED 階段, 你可以利用旗標 --stage 來更新它, 讓他再次可用 gcloud iam roles undelete viewer --project $DEVSHELL_PROJECT_ID 恭喜你已經完成本教程！","link":"/zh-tw/IAMCustomRoles/"},{"title":"使用 `Laravel` `template` 與 `blade`","text":"前言本篇為Laravel 的學習筆記，主要紀錄 Laravel blade 的用法，重點如下： 建立並重複使用 template 使用 yield 及 section 將值傳到 view {{ }} 幫我們做了什麼？ 建立 template 建立 template ，名為 layout ，如下&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; // 使用 yield 設定 title 的範圍，並將 Laracasts 設為預設值，若在頁面中沒有特別指定 title 的值時，會自訂套用預設 &lt;title&gt;@yield(&#x27;title&#x27;, &#x27;Laracasts&#x27;)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/&quot;&gt;Welcome&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/contact&quot;&gt;contact&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;// 使用 yield 設定區塊的範圍，範圍名稱為 content@yield(&#x27;content&#x27;)&lt;/body&gt;&lt;/html&gt; 使用 section 上面已經建立好了 template ，所以我們可以在新的頁面直接套用 template // 下面我們直接套用名為 layout 的 template@extends(&#x27;layout&#x27;)// 使用 section ， 在 template 中已經設定好的區塊，插入我們想要的元素。在 title 區塊插入新的值@section(&#x27;title&#x27;, &#x27;Welcome Page&#x27;)// 使用 section ， 在 content 區塊插入值@section(&#x27;content&#x27;) &lt;h1&gt;Welcome here&lt;/h1&gt;// 使用 endsection 來明確範圍@endsection 重複上面的操作，在多個新頁面上套用 template 將值傳到 view 要將值帶到 view 其實也很多種做法，以下列舉四種 1. Route::get(&#x27;/&#x27;, function () &#123; $task = [ &#x27;Go to the school&#x27;, &#x27;Go to the market&#x27;, &#x27;Go to work&#x27; ]; return view(&#x27;welcome&#x27;, compact(&#x27;task&#x27;) );&#125;); 2. Route::get(&#x27;/&#x27;, function () &#123; $task = [ &#x27;Go to the school&#x27;, &#x27;Go to the market&#x27;, &#x27;Go to work&#x27; ]; return view(&#x27;welcome&#x27;, [&#x27;tasks&#x27; =&gt; $task] ); Route::get(&#x27;/&#x27;, function () &#123; return view(&#x27;welcome&#x27;, [&#x27;tasks&#x27; =&gt; [ &#x27;Go to the school&#x27;, &#x27;Go to the market&#x27;, &#x27;Go to work&#x27; ]]);&#125;); Route::get(&#x27;/&#x27;, function () &#123; return view(&#x27;welcome&#x27;)-&gt;withTasks([ &#x27;Go to the school&#x27;, &#x27;Go to the market&#x27;, &#x27;Go to work&#x27; ]);&#125;); 以上四種做法， Ray 比較常用第一種。 在 view 接值 在 view 把剛剛傳過來的值取出，並顯示 @extends(&#x27;layout&#x27;)@section(&#x27;title&#x27;, &#x27;Welcome Page&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;Welcome here&lt;/h1&gt; &lt;ul&gt; @foreach ($tasks as $task) &lt;li&gt; &#123;&#123; $task &#125;&#125; &lt;/li&gt; @endforeach &lt;/ul&gt;@endsection 在Laravel 的 blade 檔案中，可以在 {{ }} 中使用變數 畫面如下： blade {{ }} 幫我們做了什麼？ {{ }} 除了可讓我們取得傳過來的變數之外，還自動執行了 `PHP`的 function `htmlspecialchars` ，防止有心人 `XSS` 攻擊。 做個實驗，使用blade:Route::get(&#x27;/&#x27;, function () &#123; $test = &#x27;&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;&#x27;; return view(&#x27;welcome&#x27;)-&gt;withTasks([ &#x27;Go to the school&#x27;, &#x27;Go to the market&#x27;, &#x27;Go to work&#x27; ])-&gt;withTest($test);&#125;); @extends(&#x27;layout&#x27;)@section(&#x27;title&#x27;, &#x27;Welcome Page&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;&#123;&#123; $test &#125;&#125;&lt;/h1&gt; &lt;ul&gt; @foreach ($tasks as $task) &lt;li&gt; &#123;&#123; $task &#125;&#125; &lt;/li&gt; @endforeach &lt;/ul&gt;@endsection 如上面的 code ，我們傳了有著 script tag 的 變數過去經由瀏覽器渲染出來後，如下： 再做個實驗，我們可以使用&#123;!! !!&#125; 來取消htmlspecialchars，慎用！@extends(&#x27;layout&#x27;)@section(&#x27;title&#x27;, &#x27;Welcome Page&#x27;)@section(&#x27;content&#x27;) &lt;h1&gt;&#123;!! $test !!&#125;&lt;/h1&gt; &lt;ul&gt; @foreach ($tasks as $task) &lt;li&gt; &#123;&#123; $task &#125;&#125; &lt;/li&gt; @endforeach &lt;/ul&gt;@endsection 瀏覽器渲染出來後，如下： 可以看到，該 script 真的被執行了 總結有關於blade的應用還有很多，之後會繼續更新。","link":"/zh-tw/LaravelView/"},{"title":"你好！Kubernetes","text":"概述本教程的目標是將開發完畢的代碼轉成運行在 Kubernetes 上可複製的應用, 本教程中 Kubernetes 運行在 Kubernetes Engine。 在本教程中, 代碼會是簡單的 Hello World node.js 應用 下圖是一個圖示顯示個元件在本教程中扮演的角色, 讓我們了解個元件彼此之間是如何互相配合的。 當你在進行本教程時, 可以參考這個圖示。 當你結束本教程, 你將會了解整個脈絡 (如果現在看不懂可以先跳過) 。 Kubernetes 是一個開源的專案 (可從 kubernetes.io 獲得), 可以運行在很多不同的環境上, 從筆電到高可用的多主機叢集; 從公開的雲端到人為部署; 從虛擬機到裸機 在本教程中, 使用一個受管理的環境, 像是 Kubernetes Engine (一個由 Google 維護的 Kubernetes 版本, 運行在 Compute Engine 上), 將會讓你可以更專注在體驗 Kubernetes, 而不是設定底層的環境。 本篇將會做什麼？ 建立一個 Node.js server 建立一個 Docker container image 建立一個 container cluster 建立一個 Kubernetes Pod 擴大服務 前言本篇主要是利用Google的Qwiklab平台學習的同時,做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 **注意：** 按下左上方位於 `Google Cloud Platform` 隔壁的 `Navigation menu`, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立你的 Node.js 應用使用 Cloud Shell, 寫一個簡單的 Node.js server, 你將會部署這個 Server 到 Kubernetes Engine vi server.js 進入編輯模式 i 在檔案中增加以下內容： var http = require(&#x27;http&#x27;);var handleRequest = function(request, response) &#123; response.writeHead(200); response.end(&quot;Hello World!&quot;);&#125;````**注意:** 這邊使用 `vi`, 但是 `nano` 以及 `emacs` 在 Cloud Shell 當中也有。 你也可以使用 CloudShell 的瀏覽器編輯器功能, [像是](https://cloud.google.com/shell/docs/features#web_editor)儲存 `server.js` 檔案, 按下 **Esc**, 然後：```bash:wq Cloud Shell 已內建 node, 直接執行 node server node server.js 使用 Cloud Shell 內建的 Web 預覽功能, 開一個新的視窗並發請求到 port 8080, 如下圖： 一個新的瀏覽器視窗將會開啟並且顯示結果： 在更進一步之前, 讓我們先到 Cloud Shell 按下 Ctrl+c 停止正在運行中的 node server, 我們將打包這個運用, 並置於 Docker container 內 建立一個 Docker container image接下來, 建立一個 Dockerfile 來敘述我們想要建立的 image, Docker container images 可以是已經存在 image 的延伸, 所以我們將從已經存在的 Node image 來延伸 vim Dockerfile 進入編輯模式 i 增加以下內容 FROM node:6.9.2EXPOSE 8080COPY server.js .CMD node server.js 上面 Docker image 的內容將會執行以下的事： 開始一個從 Docker hub 找到的 node image 暴露 port 8080 複製 server.js 檔案到此 docker image 開始一個 node server, 就像我們上一步手動開啟那樣 儲存 Dockerfile 檔案, 按下 Esc, 然後： :wq 輸入以下的指令來建立 image, 將下面的 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到 docker build -t gcr.io/PROJECT_ID/hello-node:v1 . 接下來會花一些時間來下載以及擷取需要的東西, 但你可以從進度條看到 image 建立的進度 完成之後, 於本地端使用下面的指令測試一下這個 image, 這個指令會從剛新建立的 container image 中, 將 Docker container 以常駐的方式跑在 port 8080, 執行下面的指令, 並將的 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到 docker run -d -p 8080:8080 gcr.io/PROJECT_ID/hello-node:v1 結果大概如下 325301e6b2bffd1d0049c621866831316d653c0b25a496d04ce0ec6854cb7998 可使用 Web 預覽功能 或在 Cloud Shell 中使用 curl kcurl http://localhost:8080 注意： 完整的 docker run 文件你可以在這裏找到 接下來, 停止運行中的容器 尋找 Docker container ID docker ps 結果大概如下 CONTAINER ID IMAGE COMMAND2c66d0efcbd4 gcr.io/PROJECT_ID/hello-node:v1 &quot;/bin/sh -c &#x27;node 執行以下指令來關閉容器, 並將 [CONTAINER ID] 替換成之前獲得的值 docker stop [containerID] 結果會輸出你的 container ID ,如下： 2c66d0efcbd4 現在, image 如我們預期般的運作著, 接下來我們將它推到 Google Container Registry, 一個可被 Google Cloud Projects 存取的 Docker image 私人資料夾。 執行下面的指令, 並將的 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。 gcloud auth configure-docker docker push gcr.io/PROJECT_ID/hello-node:v1 第一次的推送可能會花個幾分鐘完成。 當它在建立時, 你可以看到進度條。 The push refers to a repository [gcr.io/qwiklabs-gcp-6h281a111f098/hello-node]ba6ca48af64e: Pushed381c97ba7dc3: Pushed604c78617f34: Pushedfa18e5ffd316: Pushed0a5e2b2ddeaa: Pushed53c779688d06: Pushed60a0858edcd5: Pushedb6ca02dfe5e6: Pushedv1: digest: sha256:8a9349a355c8e06a48a1e8906652b9259bba6d594097f115060acca8e3e941a2 size: 2002 Container image 將會被列在主控台中, 選擇 Navigation menu &gt; Container Registry 現在我們擁有 project-wide 的 Docker image ,可供 Kubernetes 存取以及編排 注意： 在這次註冊中使用一個通用的 domain (gcr.io)。 在你自己的環境中, 你可以指定哪一個 zone 或是儲存區, 詳見文件 建立 cluster現在我們已經準備好可以建立 Kubernetes Engine cluster 。 一個 cluster 內, 有由 Google 管理的 Kubernetes master API server, 以及一組 worker nodes 。 worker nodes 為 Compute Engine 的虛擬機 確保我們已經使用 gcould 來設定我們的專案 (將 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。) gcloud config set project PROJECT_ID 使用兩個 n1-standard-1 nodes 來建立 cluster (將會耗費幾分鐘) gcloud container clusters create hello-world \\ --num-nodes 2 \\ --machine-type n1-standard-1 \\ --zone us-central1-a 在建立時, 若看到警告可以無視。輸出應會如下： Creating cluster hello-world...done.Created [https://container.googleapis.com/v1/projects/PROJECT_ID/zones/us-central1-a/clusters/hello-world].kubeconfig entry generated for hello-world.NAME ZONE MASTER_VERSION MASTER_IP MACHINE_TYPE STATUShello-world us-central1-a 1.5.7 146.148.46.124 n1-standard-1 RUNNING 注意： 你也可以透過主控台來建立 cluster, 打開 Navigation 選單並選擇 Kubernetes Engine &gt; Kubernetes cluster &gt; Create cluster 注意： cluster 建立的區域,建議跟 container registry 使用的儲存區的所在區域一樣 如果你選擇 Navigation menu &gt; Kubernetes Engine , 可以看到, 現在有一個由 Kubernetes Engine 驅動的, 功能完全的 Kubernetes 叢集 接下來, 是時候將我們容器化的 application 部署到 Kubernetes cluster, 從現在開始, 我們將使用 kubectl 命令行（在 Cloud Shell 環境中,這已經被設定完畢） 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 建立 PodKubernetes pod 由多個容器組成, 用於管理以及連結。 它可以容納單一或多個容器。 這邊我們將會使用儲存於私人的 container registry, 由 Node.js image 建立的容器 。 將會運行在 8080 port 使用 kubectl run 指令來建立一個 pod (將 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。) kubectl run hello-node \\ --image=gcr.io/PROJECT_ID/hello-node:v1 \\ --port=8080 輸出： deployment &quot;hello-node&quot; created 可以看到, 我們已經建立一個 deployment 物件。 Deployments 是建立跟擴大 pods 推薦的方法。 這邊, 一個新的 deployment 管理一個正運行著 hello-node:v1 image 的 pod 若要檢視 deployment, 運行： cloudkubectl get deployments 輸出： NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-node 1 1 1 1 2m 若要檢視由 deployment 建立的 pod, 運行： kubectl get pods 輸出： NAME READY STATUS RESTARTS AGEhello-node-714049816-ztzrb 1/1 Running 0 6m 現在是時候來看看一些有趣的 kubectl 指令。 他們都不會變更叢集的狀態, 完整個文件可參考這裡 cloudkubectl cluster-info cloudkubectl config view Debug 專用： cloudkubectl get events cloudkubectl logs &lt;pod-name&gt; 現在你需要讓外部可以存取你的 pod 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 允許外部連結在預設中, Pod 只可被 cluster 內部的 IP 存取。為了要讓 hello-node container 可被 Kubernetes virtual network 之外的地方存取,我們必須設定 Pod 成可被存取的 Kubernetes 的服務 在 Cloud Shell, 透過使用 kubectl expose 指令, 並結合 --type=&quot;LoadBalancer&quot; 旗標, 我們可以讓 Pod 可被公用網路存取。要建立一個外部存取 IP, 這個 flag 是必須的。 kubectl expose deployment hello-node --type=&quot;LoadBalancer&quot; 輸出： service &quot;hello-node&quot; exposed 這個 flag 指定我們將使用底層基礎設施提供的平衡負載 (在此範例中,為 Compute Engine load balancer)。需注意我們是使 deployment 可視化, 並非直接暴露 Pod 。這代表, 服務將會在所有由 deployment 管理的 pods 之間平衡負載流量 (於此範例中, 為一個Pod, 但我們等等會增加) 此 Kubernetes master 建立了 load balancer, 相關的 Compute Engline 轉發規則, target pools, 以及防火牆規則, 所以服務可被 Google Cloud Platform 之外的來源所存取 若要找公開可存取IP, 可要求 kubectl 列出所有的 cluster 服務 kubectl get services 結果如下： NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-node 10.3.250.149 104.154.90.147 8080/TCP 1mkubernetes 10.3.240.1 &lt;none&gt; 443/TCP 5m 上圖可以看到, hello-node service 有兩組 IP, 兩組都使用 port 8080, CLUSTER-IP 是內部 IP, 只可被內部 cloud virtual network 所見, EXTERNAL-IP 為外部 load-balanced IP 注意： EXTERNAL-IP 可能會需要幾分鐘的時間變得可用, 以及可視化。 如果 EXTERNAL-IP 不可用, 等幾分鐘, 然後再次執行指令。 現在你應該可以透過以下的連結來存取服務: http://&lt;EXTERNAL_IP&gt;:8080 使用容器化以及 Kubernetes 之後, 你已經獲得很多新的功能 - 你不需要指定哪台主機來運行你的工作, 且還有服務的監控以及重啟功能。 現在讓我們來看看我的們新 Kubernetes 還有什麼其他功能 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 擴充服務Kubernetes 提供的其中一個強大的功能, 就是非常簡單的擴充你的應用。 假如你忽然間需要很大的容量, 你可以告訴 replication controller 來為我們的 pod 設置一個新的 replicas 數量 kubectl scale deployment hello-node --replicas=4 輸出： deployment &quot;hello-node&quot; scaled 你可以查看更新後的 deployment kubectl get deployment 輸出： NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-node 4 4 4 4 16m 你也可以列出所有的 podskubectl get Pods 輸出： NAME READY STATUS RESTARTS AGEhello-node-714049816-g4azy 1/1 Running 0 1mhello-node-714049816-rk0u6 1/1 Running 0 1mhello-node-714049816-sh812 1/1 Running 0 1mhello-node-714049816-ztzrb 1/1 Running 0 16m 一個宣告式的方法在這裡被使用。 你宣告了多少個 instances 應該被使用, 而不是開啟或關閉新的 instances. Kubernetes 的調和迴圈確保實際情況符合你要求的, 並且必要時採取動作。 以下圖片總結 Kubernetes 叢集的狀態: 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 升級服務某些時候,已經被部署的應用需要 debug 或增加新的功能。 Kubernetes 幫我們部署新的版本,並且不影響使用者 首先, 修改應用, 編輯 server.js vim server.js i 更新回覆訊息 response.end(&quot;Hello Kubernetes World!&quot;); 按下 ESC, 然後輸入以下指令來儲存 server.js :wq 現在, 我們可以透過往上增加的版本號, (v2, 在本範例中) 建立以及發布一個新的 container image 到 registry。 執行以下指令(將 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。) docker build -t gcr.io/PROJECT_ID/hello-node:v2 . gcloud docker -- push gcr.io/PROJECT_ID/hello-node:v2 注意： 建立以及推送更新的 image 應該會比較快, 因為 cache 已經被使用了 Kubernetes 將會流暢的更新你的 replication controller 到新的應用程式版本。 為了要改變運行中容器的 image 的標籤, 你需要編輯已經存在的 hello-node deployment 以及將 image 由 gcr.io/PROJECT_ID/hello-node:v1 變更為 gcr.io/PROJECT_ID/hello-node:v2 使用 kubectl edit 指令來做到這一點。 它會打開一個顯示所有 deployment yaml 設定檔的編輯器。 現在不需要理解所有的 yaml 設定, 只需要理解如果我們更新了 spec.template.spec.containers.image 欄位, 那相當於告訴 deployment 使用新的 image 更新 pods。 cloudkubectl edit deployment hello-node 尋找 Spec &gt; containers &gt; image, 然後改變版本號碼到 v2 # Please edit the object below. Lines beginning with a &#x27;#&#x27; will be ignored,# and an empty file will abort the edit. If an error occurs while saving this file will be# reopened with the relevant failures.#apiVersion: extensions/v1beta1kind: Deploymentmetadata: annotations: deployment.kubernetes.io/revision: &quot;1&quot; creationTimestamp: 2016-03-24T17:55:28Z generation: 3 labels: run: hello-node name: hello-node namespace: default resourceVersion: &quot;151017&quot; selfLink: /apis/extensions/v1beta1/namespaces/default/deployments/hello-node uid: 981fe302-f1e9-11e5-9a78-42010af00005spec: replicas: 4 selector: matchLabels: run: hello-node strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 type: RollingUpdate template: metadata: creationTimestamp: null labels: run: hello-node spec: containers: - image: gcr.io/PROJECT_ID/hello-node:v1 ## Update this line ## imagePullPolicy: IfNotPresent name: hello-node ports: - containerPort: 8080 protocol: TCP resources: &#123;&#125; terminationMessagePath: /dev/termination-log dnsPolicy: ClusterFirst restartPolicy: Always securityContext: &#123;&#125; terminationGracePeriodSeconds: 30 更改之後, 按下 Esc, 然後輸入以下指令來儲存並且離開檔案 :wq 輸出應如下： deployment &quot;hello-node&quot; edited 執行以下指令來使用新的 image 更新 deployment cloudkubectl get deployments 更新後的 image 將會被使用來建立新的 pods, 而舊的 pods 會被刪除 輸出應如下： NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-node 4 4 4 4 1h 在這一切發生的過程中, 你的服務的使用者不會看到任何的服務中斷。 過一段時間後, 他們會開始存取新版的應用。 關係滾動升級的更多細節可以參考文件 使用這些部署, 擴充, 更新的功能, 一旦我們完成 Kubernetes Engine 叢集的設定, 我們可以把我們節省花在基礎設施上的時間並專注在開發上。 Kubernetes圖形化面板 (optional)最近的 Kubernetes 版本已經推出了圖示化的網頁使用者介面 (dashboard)。 顯示面板讓我們可以更快速的使用 Kubernetes, 並且可以開啟一些 CLI 的功能, 像是是一種更容易理解, 且更容易發現問題的與系統互動的方式。 執行以下指令來取得 cluster 層級權限 kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account) 使用適當的權限設定, 執行以下指令來建立一個新的顯示面板服務 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml 你應會收到類似輸出： secret &quot;kubernetes-dashboard-certs&quot; createdserviceaccount &quot;kubernetes-dashboard&quot; createdrole.rbac.authorization.k8s.io &quot;kubernetes-dashboard-minimal&quot; createdrolebinding.rbac.authorization.k8s.io &quot;kubernetes-dashboard-minimal&quot; createddeployment.apps &quot;kubernetes-dashboard&quot; createdservice &quot;kubernetes-dashboard&quot; created 執行以下指令來編輯面板服務的 yaml 表現 kubectl -n kube-system edit service kubernetes-dashboard 按下 i, 進入編輯模式 將 type: ClusterIP 更改為 type: NodePort 在做完一切更改後, 按下 Esc, 然後輸入以下指令儲存離開 :wq 要登入 Kubernetes 顯示面板, 你需要使用 token 驗證。 使用由 service account 分配的 token, 例如 namespace-controller 要獲得 token, 執行以下指令： cloudkubectl -n kube-system describe $(kubectl -n kube-system \\get secret -n kube-system -o name | grep namespace) | grep token: 輸出應如下： token: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJuYW1lc3BhY2UtY29udHJvbGxlci10b2tlbi1kOTZyNCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJuYW1lc3BhY2UtY29udHJvbGxlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImU2ZmFkNGQ5LTJjNjYtMTFlOC05NDFiLTQyMDEwYTgwMDFlYiIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTpuYW1lc3BhY2UtY29udHJvbGxlciJ9.AY3Fp-T_4wxTzvo4kiWi4zxojVTSr1Wy7BL_-HmIRlWTRAUmy_1RAJS19zn4BbSkxlV13Y9Bv3NoVcG01jKd4QoM172OXo2TqSU5v2B62i3-_CDZtf3CVgQIp9jiuxACcR5zg3w-4ewGfH4C3ospoKCuayyRaADLq0ThWLGaTQv9e7UjSfWAPir3XPXQut3mMRYrSiHcFNiEGeztSfF3cyhuvL2I5Lfh20yYuqW5j-w72BLnlqQGPuhJXJgH1_35XUCU8WtnkEK-qYX40ajDWJYa1s9_R-MWzF6Zwji2Gh5txOvxG3lZuIq9GSAOBp85617wB3eCGio6Nu3L9TwWXA 複製 token 然後儲存, 等等要進到顯示面板會用到。 執行以下指令來打開連線 cloudkubecl proxy --port 8081 然後使用 Cloud Shell 網頁預覽功能來改變 port 到 8081: 我們將收到一串API endpoint, 要連結到面板, 將 /?authuser=0 移除,然後加上下面的 url: /api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default 最終的 URL 看起來應該會像下面那樣： https://8081-dot-5177448-dot-devshell.appspot.com/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default 然後你會被帶到一個網頁預覽 點選 Token radio 按鈕, 然後貼上剛剛拿到的 token, 然後點擊 Sign in 現在你可以享受 Kubernetes 圖形化顯示面板帶來的好處, 使用它來部署容器化應用, 以及監控和管理你的叢集。 你可以從主控台或是使用 Command-line 存取面板服務, Navigation menu &gt; Kubernetes Engine, 然後點擊 Connect 按鈕連接到我們想要連接的叢集 如果想要瞭解更多有關 Kubernetes 顯示面板的資訊, 參考文件 習題測驗 which of the following are features of the Kubernetes Engine? Identity and Access Management Integrated Logging and Monitoring None of these Stateful Application Support 恭喜你已經完成本教程！","link":"/zh-tw/Kubernetes/"},{"title":"使用 Laravel Queue 以及 AWS SQS","text":"前言本篇重點如下： 使用 Laravel queue 完成寄 Email 功能 使用 AWS SQS 為什麼要使用 queue 呢？當我們執行一些耗時較久的工作時，像是發送 Email ， 或是上傳圖片或是影片，讓使用者等到工作執行完畢才進行下一個動作的話，是不太現實的。所以當使用者發出一些需要較長時間執行的請求時，我們要使用 queue 來幫我們隊列，在背景慢慢執行，然後讓使用者可以立即執行下一個動作。 申請 AWS SQS 服務 首先，你要有 AWS 帳號 到 AWS 上申請 SQS 服務 這邊可以參考 AWS教學，完成設定。 記住下面的資料，後面會用到 到右上角，選擇帳戶的地方，選擇My Security Credentials 到左邊選擇 Users 建立新的 User 輸入 user 名稱，打勾 Programmatic access ，然後下一步 然後 Create group ，如下圖 再來把剛剛建立的 user 加到這個新建的 group 接下來 Add tags 是選填，不一定要填 然後就可以獲得 Access key ID 以及 Secret access key ，如果怕忘記的話，可以下載下來哦！ 這個 Secret access key 只會出現一次哦，如果不小心忘記或沒有記下來的話，就要重新產生哦！ 實作 Laravel queue配置 AWS SQS 以下操作均參考官方文件 安裝 AWS 官方 SDK ，參照官方文件 ，在專案資料夾底下：composer require aws/aws-sdk-php 在.env檔案中，做以下配置QUEUE_CONNECTION=sqsSQS_KEY=上面拿到的 keySQS_SECRET=上面拿到的 secretSQS_QUEUE=testSQSSQS_REGION=ap-northeast-1SQS_PREFIX=依照上面的URL去掉queue名稱後填入 建立 jobsphp artisan make:job ProcessPodcast job 範本如下&lt;?phpnamespace App\\Jobs;use App\\Helpers;use Illuminate\\Bus\\Queueable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;class SendMailWhenOrderPlaced implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $job; // 嘗試執行最高次數 public $tries = 5; /** * Create a new job instance. * * @return void */ public function __construct($order, $FB_email, $Local_email) &#123; $this-&gt;order = $order; $this-&gt;FB_email = $FB_email; $this-&gt;Local_email = $Local_email; $this-&gt;job = Helpers::mailWhenOrderPlaced($order, $FB_email, $Local_email); &#125; /** * Execute the job. * * @return void */ public function handle() &#123; return $this-&gt;job; &#125;&#125; 上面的範例，是使用 queue 來執行 Ray 專案裡頭的一個寄送 Email 的功能，叫做 mailWhenOrderPlaced。 使用 dispatch 在我們想要執行這一個job的地方，使用dispatch，就可以囉！SendMailWhenOrderPlaced::dispatch($order, $FB_email, $Local_email); 執行 queue 在專案底下，執行php artisan queue:work 測試 這個時候，當程式執行到 dispatch 那行時，就會使用 queue 來執行哦！ 總結是不是很簡單啊？另外，因為我們使用了 queue ，所以必須要確保 queue 的運作是正常的。以這個例子來說的話，如果 queue 不幸失效了，那這個發 Email 的功能就會失效哦！為了確保 queue 在失敗後重新自動執行，我們需要 Supervisor 來幫我們監控並管理程序！關於 Supervisor ，可以參考 Ray 的另外一篇文章哦！如果想知道如何用 Laravel Mail 以及 AWS SES 來發送 mail ，也可以參考 Ray 的另外一篇文章","link":"/zh-tw/LaravelQueueWithSQS/"},{"title":"MongoDB 學習筆記","text":"前言一份未整理的 MongoDB 學習筆記 環境GCP Linux Ubuntu 19.04 安裝參考 官方文件 重啟sudo service mongod restart 登入無建立使用者mongo 有建立使用者mongo -u user -p password 設定檔位置ubuntu vim /etc/mongod.conf vim /lib/systemd/system/mongod.service MacOS vim /usr/local/etc/mongod.conf 說明書mongo --help 一般指令 顯示 database show databases 顯示 collections show collections 顯示使用者 use adminshow users 使用資料庫 use databaseName 刪除 user db.dropUser(&#x27;User&#x27;) 變更密碼 db.changeUserPassword(&#x27;user&#x27;, &#x27;updatedPassword&#x27;) 建立需驗證的 user參考文件 登入 mongo --host &lt;HOSTNAME&gt; --port &lt;PORT&gt; 切換到 admin 資料庫 use admin 建立 user db.createUser( &#123; user: &quot;superuser&quot;, pwd: &quot;changeMeToAStrongPassword&quot;, roles: [ &quot;root&quot; ] &#125;) 驗證 user 是否成功建立 show users 關閉 MongoDB server db.shutdownServer() 離開 exit 如果是用套件安裝，需要先更改設定。 編輯設定檔，並新增 uncomment security 欄位 vim /etc/mongod.conf 如下設定 security: authorization: enabled 重新啟動 MongoDB Server, dbPath 可以在設定檔裡面看到 vim /etc/mongod.conf ubuntu # Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true MacOS systemLog: destination: file path: /usr/local/var/log/mongodb/mongo.log logAppend: truestorage: dbPath: /usr/local/var/mongodbnet: bindIp: 127.0.0.1security: authorization: enabled 執行下面指令重新啟動 mongod --dbpath &lt;path to data directory&gt; --auth &amp; 連接連接語法 mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] mongodb://這是固定的格式，必須要指定。 username:password@可選項，如果設置，在連接數據庫服務器之後，驅動都會嘗試登陸這個數據庫 host1必須的指定至少一個host, host1是這個URI唯一要填寫的。它指定了要連接服務器的地址。如果要連接複製集，請指定多個主機地址。 portX可選的指定端口，如果不填，默認為27017 /database如果指定username:password@，連接並驗證登陸指定數據庫。若不指定，默認打開test數據庫。 ?options是連接選項。如果不使用/database，則前面需要加上/。所有連接選項都是鍵值對name=value，鍵值對之間通過&amp;或;（分號）隔開 讓外面可以連到資料庫 更改 IP 如下# network interfacesnet: port: 27017 bindIp: 0.0.0.0","link":"/zh-tw/MongoDB/"},{"title":"PayPal REST API 串接金流好簡單","text":"前言本篇將會分享，如何使用 PayPal REST API，來做到以下的動作： 建立授權訂單 授權 請款 退款 部分款項凍結 本篇屬於個人學習筆記，所以可能會參雜一些個人的專案內容，請選擇性參考。 安裝 PayPal REST API 官方 SDK本篇使用的為目前 PayPal 最新釋出的 SDK 版本 安裝composer require paypal/paypal-checkout-sdk 設定個人設定 安裝完成之後，可在 SDK 的資料夾底下，找到範例，如下圖： 設定 PayPalClient.php 檔案，如下: 1. 申請開發者帳號並登入 2. 建立一個App 3. 取得 Client ID 以及 Secret 4. 將取得的 Client ID 以及 Secret 填入， Ray 是設在環境變數 public static function environment()&#123; $clientId = env(&#x27;PAYPAL_SANDBOX_API_ClientID&#x27;); $clientSecret = env(&#x27;PAYPAL_SANDBOX_API_SECRET&#x27;); return new SandboxEnvironment($clientId, $clientSecret);&#125; 開始在上面提到的範例資料夾中，可以找到幾乎所有會用到的範例。這邊可以根據每個人的需求不同來客制，以下是 Ray 自己的版本任何疑惑，請參考 sample 裡頭的範例，以及官方文件如下:orderpayment order 跟 payment 的差異主要的差異如下： order： 只支援 PayPal 的會員。可以延後付款，並且視乎貨物的狀態做部分的請款 payment: 可以延後付款，但不可以分批請款。 詳細的介紹可以參考原文解說 建立訂單 ( order )public function createOrder($toBeSavedInfo, Recipient $recipient, $debug = false)&#123; // 引用SDK $request = new OrdersCreateRequest(); $request-&gt;headers[&quot;prefer&quot;] = &quot;return=representation&quot;; // 這邊的RequestBody等等會貼在下面 $request-&gt;body = self::buildRequestBody($toBeSavedInfo, $recipient); // 這邊引用剛剛設定好的 PayPalClient $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print &quot;Status Code: &#123;$response-&gt;statusCode&#125;\\n&quot;; print &quot;Status: &#123;$response-&gt;result-&gt;status&#125;\\n&quot;; print &quot;Order ID: &#123;$response-&gt;result-&gt;id&#125;\\n&quot;; print &quot;Intent: &#123;$response-&gt;result-&gt;intent&#125;\\n&quot;; print &quot;Links:\\n&quot;; foreach ($response-&gt;result-&gt;links as $link) &#123; print &quot;\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n&quot;; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), &quot;\\n&quot;; &#125; // 建立建立完成後，我只取讓使用者用來確認的連結，預設 PayPal 提供了很多的連結，但是其他的我們都可以靠 API 來達成。 foreach (($response-&gt;result-&gt;links) as $link) &#123; if ($link-&gt;rel === &#x27;approve&#x27;) &#123; $linkForApproval = $link-&gt;href; break; &#125; &#125; // 這邊取得建立訂單之後的一些會用到的資訊，然後 return $toBeSavedInfo[&#x27;payment_id&#x27;] = $response-&gt;result-&gt;id; $toBeSavedInfo[&#x27;statusCode&#x27;] = $response-&gt;statusCode; $toBeSavedInfo[&#x27;custom_id&#x27;] = $response-&gt;result-&gt;purchase_units[0]-&gt;custom_id; $toBeSavedInfo[&#x27;PayPal_total_amount&#x27;] = $response-&gt;result-&gt;purchase_units[0]-&gt;amount-&gt;value; $toBeSavedInfo[&#x27;orderStatus&#x27;] = $response-&gt;result-&gt;status; $toBeSavedInfo[&#x27;linkForApproval&#x27;] = $linkForApproval; return $toBeSavedInfo;&#125; 下面是建立訂單功能會用到的 RequestBodypublic static function buildRequestBody($toBeSavedInfo, Recipient $recipient)&#123; // 這邊的設定，使得我們可以在 PayPal 的付款頁面，看到多個商品的明細 $item = []; $i = 1; foreach ($toBeSavedInfo[&#x27;orders&#x27;] as $order) &#123; $item[] = [ &#x27;name&#x27; =&gt; $order-&gt;item_name, &#x27;description&#x27; =&gt; $order-&gt;item_description, &#x27;sku&#x27; =&gt; $i, &#x27;unit_amount&#x27; =&gt; [ &#x27;currency_code&#x27; =&gt; $toBeSavedInfo[&#x27;mc_currency&#x27;], &#x27;value&#x27; =&gt; $order-&gt;unit_price, ], &#x27;quantity&#x27; =&gt; $order-&gt;quantity, ]; $i ++; &#125; // 這邊我們指定 intent ，我設在環境變數， return [ &#x27;intent&#x27; =&gt; env(&#x27;PAYPAL_SANDBOX_INTENT_OF_CREATED_ORDERS&#x27;), &#x27;application_context&#x27; =&gt; [ &#x27;return_url&#x27; =&gt; env(&#x27;PAYPAL_SANDBOX_RETURN_URL&#x27;), &#x27;cancel_url&#x27; =&gt; env(&#x27;PAYPAL_SANDBOX_CANCEL_URL&#x27;), &#x27;brand_name&#x27; =&gt; env(&#x27;APP_NAME&#x27;), &#x27;locale&#x27; =&gt; env(&#x27;PAYPAL_SANDBOX_LOCALE&#x27;), &#x27;landing_page&#x27; =&gt; env(&#x27;PAYPAL_SANDBOX_LANDING_PAGE&#x27;), &#x27;shipping_preferences&#x27; =&gt; env(&#x27;PAYPAL_SANDBOX_SHIPPING_PREFERENCES&#x27;), &#x27;user_action&#x27; =&gt; env(&#x27;PAYPAL_SANDBOX_USER_ACTION&#x27;), ], // 這邊可以設定 purchase_unit ，一個 purchase_unit 裡面可以設定税、運費、等等，這邊省略 &#x27;purchase_units&#x27; =&gt; [ [ &#x27;custom_id&#x27; =&gt; $toBeSavedInfo[&#x27;merchant_trade_no&#x27;], &#x27;amount&#x27; =&gt; [ &#x27;currency_code&#x27; =&gt; $toBeSavedInfo[&#x27;mc_currency&#x27;], &#x27;value&#x27; =&gt; $toBeSavedInfo[&#x27;total_amount&#x27;], &#x27;breakdown&#x27; =&gt; [ &#x27;item_total&#x27; =&gt; [ &#x27;currency_code&#x27; =&gt; $toBeSavedInfo[&#x27;mc_currency&#x27;], &#x27;value&#x27; =&gt; $toBeSavedInfo[&#x27;total_amount&#x27;], ], ], ], &#x27;items&#x27; =&gt; $item, // 這邊可以指定收件人 &#x27;shipping&#x27; =&gt; array( &#x27;name&#x27; =&gt; array( &#x27;full_name&#x27; =&gt; $recipient-&gt;name, ), &#x27;address&#x27; =&gt; array( &#x27;address_line_1&#x27; =&gt; $recipient-&gt;others, &#x27;admin_area_2&#x27; =&gt; $recipient-&gt;district, &#x27;admin_area_1&#x27; =&gt; $recipient-&gt;city, &#x27;postal_code&#x27; =&gt; $recipient-&gt;postcode, &#x27;country_code&#x27; =&gt; $recipient-&gt;country_code, ), ), ], ], ];&#125; 授權 ( authorization )接下來，我們要使用 REST API 中的特別功能， Authorization 。 授權之後，我們有29天的時間可以使用 capture 來從使用者的帳戶裡面扣錢。 不過呢，雖然有效期限是29天，但是 PayPal 只能保證給予單次授權開始計算的三天內，使用者的帳戶裡頭會有足夠的金額。 意思就是說呢，在 authorization 開始計算的三天， PayPal 會暫時性的在付款方的 PayPal 帳戶中，凍結申請的款項，記住只有三天哦！ 這三天稱為 honor period 。 在首次的 authorization 之後，我們可以申請多次，最多10次的 authorization ，稱為 reauthorize 。如果你覺得這樣次數還是太少，可以通過跟 PayPal 客服聯絡的方式，將次數提升到最多99次！ 其實只要將時間算好，10次的授權應該很夠用了。平均三天授權一次，10次也一個月了，海運都到了！ 授權可以更改金額，最高可以授權115% 或 不超過 75 USD 的金額，如果運費或者稅務方面，或是其他原因造成費用有些許變動的話，可以透過重新授權來更改費用。 細節可以參考官方文件 授權的範例如下:記住這是 Ray 自己的版本，大家可以參考官方的範例，再依照自己的需求作更改，或者乾脆取SDK裡面的功能自己寫一個！ 這才是我認為的最佳解！ /** * This function can be used to perform authorization on the approved order. * Valid Approved order id should be passed as an argument. */ // 這邊我們可以變更授權的金額，根據你的需求public static function authorizeOrder($orderId, $amount = null, $debug = false)&#123; $request = new OrdersAuthorizeRequest($orderId); // RequestBody 跟上面提到的差不多，可以參考官方的範例！ $request-&gt;body = self::buildRequestBodyForAuthorizeOrder($amount); $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print &quot;Status Code: &#123;$response-&gt;statusCode&#125;\\n&quot;; print &quot;Status: &#123;$response-&gt;result-&gt;status&#125;\\n&quot;; print &quot;Order ID: &#123;$response-&gt;result-&gt;id&#125;\\n&quot;; print &quot;Authorization ID: &#123;$response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;id&#125;\\n&quot;; print &quot;Links:\\n&quot;; foreach ($response-&gt;result-&gt;links as $link) &#123; print &quot;\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n&quot;; &#125; print &quot;Authorization Links:\\n&quot;; foreach ($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;links as $link) &#123; print &quot;\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n&quot;; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), &quot;\\n&quot;; &#125; return $response;&#125; 授權之後呢，我們需要驗證授權是否成功，所以我利用回傳的response，寫一個驗證的 function，如下： public static function checkIfAuthorizedSuccessfully($response)&#123; $newPayPal = (new NewPayPal())-&gt;where(&#x27;payment_id&#x27;, request()-&gt;token)-&gt;first(); // 確認授權是否完成 if (($response-&gt;result-&gt;status) !== &#x27;COMPLETED&#x27;) return &#x27;Authorization isn\\&#x27;t completed&#x27;; // 確認授權是否已開始 if (($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;status) !== &#x27;CREATED&#x27;) return &#x27;Authorization was not created&#x27;; // 確認幣別是否一致 if (($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;amount-&gt;currency_code) !== ($newPayPal-&gt;mc_currency)) return &#x27;The currency is mismatched&#x27;; // 確認授權金額是否正確。這邊是我自己的版本，有需要變動授權金額的話，這邊可以變一下。 if (intval($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;amount-&gt;value) !== ($newPayPal-&gt;total_amount)) return &#x27;The total amount is not correct&#x27;;&#125; 提款 ( capture ) 就像上面提到的，成功授權之後，我們可以在29天內隨時向買家請款。 不過 PayPal 只有保證三天買家帳戶裡頭會有足夠的金額，又稱 honor period 一般來說，我們只要把時間算好，可以透過 授權 以及 再次授權 ，將 這筆金額臨時凍結30天。 以下是提款 ( capture ) 的範例：public static function captureAuthorization(NewPayPal $newPayPal, $final_capture = false, $debug = false)&#123; $NewPayPal = (new NewPayPal)-&gt;where(&#x27;merchant_trade_no&#x27;, $newPayPal-&gt;merchant_trade_no)-&gt;first(); // 提款功能，需要帶入授權id $request = new AuthorizationsCaptureRequest($newPayPal-&gt;authorization_id); // 這邊帶入要提款的金額，如上所敘，提款金額是可以分批次的！ Final_capture 如果設定為true的話，會結束此次授權，此次授權之後無法再進行提款，若要提款需要再重新授權。 $request-&gt;body = self::buildRequestBodyForCaptureAuthorization($NewPayPal-&gt;to_be_captured_amount, $final_capture, $newPayPal-&gt;mc_currency); $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print &quot;Status Code: &#123;$response-&gt;statusCode&#125;\\n&quot;; print &quot;Status: &#123;$response-&gt;result-&gt;status&#125;\\n&quot;; print &quot;Capture ID: &#123;$response-&gt;result-&gt;id&#125;\\n&quot;; print &quot;Links:\\n&quot;; foreach ($response-&gt;result-&gt;links as $link) &#123; print &quot;\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n&quot;; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), &quot;\\n&quot;; &#125; return $response;&#125; 以下是提款 ( capture ) 的 RequestBodypublic static function buildRequestBodyForCaptureAuthorization($amount = null, $final_capture = false, $currency = &#x27;USD&#x27;)&#123; if ($amount != null) &#123; // 指定提款的金額與幣別，需要跟授權的一致 return [ &quot;amount&quot; =&gt; [ &#x27;currency_code&#x27; =&gt; $currency, &#x27;value&#x27; =&gt; $amount, ], &#x27;final_capture&#x27; =&gt; $final_capture ]; &#125; return &quot;&#123;&#125;&quot;;&#125; 以下是提款的邏輯Ray 的邏輯是設定一個提款期限來決定什麼時候提款，因為每次退款都會扣掉手續費，所以 Ray 的想法是利用金額凍結取代退款，在提款期限之前，如果買家申請退款的話， Ray 這邊只需要去更改要提款的最終數字，這樣就可以避免掉手續費的部分。 Ray 自己設定的容許退款期限為七天，所以 Ray 會將這筆金額凍結七天，在七天後等到一切都確定了再依照最終的提款金額一次提款。所以下面的function每天都會跑一次，如果已經過了提款期限就會真正執行提款，並更新該訂單在所有資料庫裡頭相對應的狀態。 public static function dailyCaptureAuthorization()&#123; $toBeCapturedPayments = NewPayPal::whereNotNull(&#x27;authorization_id&#x27;)-&gt;whereNull(&#x27;capture_id&#x27;)-&gt;where(&#x27;to_be_captured_date&#x27;, &#x27;&lt;&#x27;, Carbon::now()-&gt;toDateTimeString())-&gt;get(); foreach ($toBeCapturedPayments as $toBeCapturedPayment) &#123; $response = NewPayPal::captureAuthorization($toBeCapturedPayment); if (($response-&gt;result-&gt;status) === &#x27;COMPLETED&#x27;) &#123; $toBeCapturedPayment-&gt;update([&#x27;capture_id&#x27; =&gt; $response-&gt;result-&gt;id, &#x27;status&#x27; =&gt; 7]); foreach ($toBeCapturedPayment-&gt;orderRelations as $orderRelation) &#123; if (($orderRelation-&gt;status == 5) || ($orderRelation-&gt;status == 6)) &#123; $orderRelation-&gt;order-&gt;update([&#x27;status&#x27; =&gt; 7]); $orderRelation-&gt;update([&#x27;status&#x27; =&gt; 7]); &#125; &#125; &#125; &#125;&#125; 退款 ( refund ) 退款的規則是，可以針對特定授權，進行一次性或者分批次的退款。 若屬於分批次，可以指定退款金額 若想要一次性，可以將整個 RequestBody 留空，像官方範例那樣public static function refundOrder($captureId, $amount, $currency, $debug = false)&#123; $request = new CapturesRefundRequest($captureId); // 這邊帶入指定的退款金額以及幣別，幣別必須要跟授權的一樣哦 $request-&gt;body = self::buildRequestBodyForRefundOrder($amount, $currency); $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print &quot;Status Code: &#123;$response-&gt;statusCode&#125;\\n&quot;; print &quot;Status: &#123;$response-&gt;result-&gt;status&#125;\\n&quot;; print &quot;Order ID: &#123;$response-&gt;result-&gt;id&#125;\\n&quot;; print &quot;Links:\\n&quot;; foreach ($response-&gt;result-&gt;links as $link) &#123; print &quot;\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n&quot;; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), &quot;\\n&quot;; &#125; return $response;&#125; 以下是退款的 RequestBodypublic static function buildRequestBodyForRefundOrder($amount = null, $currency = &#x27;USD&#x27;, $final_capture = false)&#123; // 若金額有指定就為指定值，若無指定便為預設格式 if ($amount != null) &#123; return [ &quot;amount&quot; =&gt; [ &#x27;currency_code&#x27; =&gt; $currency, &#x27;value&#x27; =&gt; $amount, ], &#x27;final_capture&#x27; =&gt; $final_capture ]; &#125; return &quot;&#123;&#125;&quot;;&#125; 退款的邏輯 相對應提款時所做的操作，在商家真正對買家做出提款之前，買家所申請的退款請求都只是去更改資料庫的數字。 如果過了七天，但實屬特殊案例，買家也還是可以申請退款，不過到時候就會有手續費產生 以上邏輯只適用於 PayPal ，因為本專案整合兩家金流，所以上面的邏輯並不適用於歐付寶，不過總體來說，對買家來說都是沒有影響的。public static function refund(Order $order, NewPayPal $paymentServiceInstance, OrderRelations $orderRelation)&#123; // 當該申請訂單為已授權，但尚未請款 if (($paymentServiceInstance-&gt;capture_id === null) &amp;&amp; ($paymentServiceInstance-&gt;authorization_id !== null)) &#123; // 如上所敘，我們只更新資料庫的請款金額 $paymentServiceInstance-&gt;update([ &#x27;to_be_captured_amount&#x27; =&gt; $paymentServiceInstance-&gt;to_be_captured_amount - $order-&gt;total_amount, &#x27;total_amount&#x27; =&gt; $paymentServiceInstance-&gt;total_amount - $order-&gt;total_amount ]); $order-&gt;update([&#x27;status&#x27; =&gt; 4]); $orderRelation-&gt;update([&#x27;status&#x27; =&gt; 4]); &#125; // 當該訂單已經請款了 if ($paymentServiceInstance-&gt;capture_id !== null) &#123; // 真正執行退款 API ，將款項退給買家 $response = self::refundOrder($paymentServiceInstance-&gt;capture_id, $order-&gt;total_amount, $paymentServiceInstance-&gt;mc_currency); // 如果退款確定成功，更新訂單狀態 if ($response-&gt;result-&gt;status == &#x27;COMPLETED&#x27;) &#123; $order-&gt;update([&#x27;status&#x27; =&gt; 4]); $orderRelation-&gt;update([&#x27;status&#x27; =&gt; 4]); $paymentServiceInstance-&gt;update([ &#x27;total_amount&#x27; =&gt; $paymentServiceInstance-&gt;total_amount - $order-&gt;total_amount ]); &#125; &#125;&#125; 取消授權取消方法非常簡單，只要使用官方範例，並且依照格式帶入授權的id就可以，這邊就不特別舉例！授權id在你成功授權的時候會回傳，在那時記得把它存起來！ 取得授權資料取得授權方法非常簡單，只要使用官方範例，並且依照格式帶入授權的id就可以，這邊就不特別舉例！授權id在你成功授權的時候會回傳，在那時記得把它存起來！ 取得提款資料取得提款方法非常簡單，只要使用官方範例，並且依照格式帶入提款的id就可以，這邊就不特別舉例！提款id在你成功提款的時候會回傳，在那時記得把它存起來！ 總結依照官方文件， PayPal REST API 是可以搭配 JavaScript 的 Smart Button 一起使用的，不過 Ray 負責的是後端的角色，所以這一部分就沒有深究。看起來還蠻有趣的！有興趣的可以花時間研究一下！PayPal 不愧是國際的金流系統，各項的支援都十分全面以及功能也十分多樣，可惜已經退出台灣了！不過據了解應該是因為相關法令的關係，退出在另一個角度來說也是在捍衛台灣的稅法，未嘗不是一件好事，這邊就不多做評論。這陣子算是針對 PayPal 的金流深入的研究了一下，當然還有許多比較細緻的功能因為時間的關係還沒有去接觸到，待之後有時間有機會再來好好研究，再把心得過程都記錄下來分享給大家！ 歡迎轉載，但麻煩請註明出處，感謝！","link":"/zh-tw/PayPalRestAPI/"},{"title":"OOP-Class and Object","text":"大家好，我是Ray! 今天想跟大家分享，什麼是Ｃlass，以及什麼是Object，還有他們之間的關係！ 講到class就不得不講到object，而要解釋object就離不開class，這也常常是讓許多人感到困惑與不解的地方。 簡單來說，class算是一用來創造object的code模板。 廢話不多說，讓我們來創一個class先： 我們可以自訂我們喜歡的class的名稱，class的名稱可以是數字與字母的組成，但開頭的第一個字不可以是數字，如下面的code： class ＭyAccessories&#123; // class body&#125; 雖然上面的東西看起來沒什麼用，但是這已經是一個符合標準的class 如上所述，我們說class是產出object的一個模板，現在讓我們來產出幾個object，如以下的code: $accessory1 = MyAccessories();$accessory2 = MyAccessories(); 以上我們使用MyAccessories class 造出了兩個object，由於這兩個object是由同樣的class造出來的，所以他們有著相同的功能與類型。 那你會問，他們一樣嗎？ 答案是，不。 或許在功能以及類型上它們是一樣的，但他們的確是不同的object。 我知道你可能還有疑惑，讓我們把他們印出來看看！新增以下的code: var_dump($accessory1);var_dump($accessory2); 沒有意外的話，你應該會印出下面的東西。#後面的編號代表著他們的獨特性。或許你會說，啊～這會不會是照順序來顯示＃後面數字啊？ object(MyAccessories)#1 (0) &#123;&#125;object(MyAccessories)#2 (0) &#123;&#125; 那我們再來做一個實驗 我們將var_dump內的object名稱互換，如果說＃後面的數字只是照順序來顯示的話，照理說印出來的東西應該不會變，是吧？ var_dump($accessory2);var_dump($accessory1); 你應該會印出下面的東西： object(MyAccessories)#2 (0) &#123;&#125;object(MyAccessories)#1 (0) &#123;&#125; ＃後面的數字變了！ 這代表一個事實，那就是每個object，儘管他們是由同一個class所產出的，都會有屬於自己的一組編號，代表他們的獨特性，所以每一個object都會是不同的。 如果你還有些困惑，讓我再來舉個例子： Class就像是生產鑄件的模具，而object就像是被壓出來的鑄件，可以是一個鍵帽，或是一個同型號的耳機。外觀看來他們都是一模一樣的，但是他們確實是不同的獨立個體。你或許可以在上面看到生產流水編號，那就相當於上面印出來的#後面的數字。 看完以上的文章，各位是否對class以及object有更深一層的認識了呢？","link":"/zh-tw/OOP-ClassAndObject/"},{"title":"PHP OOP 筆記","text":"# 前言留下我學習 OOP 的痕跡 # 正文# Object-Oriented and Procedural Programming以下列出兩種範例, 藉由程式碼來比較兩者的不同之處 # Procedural&lt;?phpfunction readParams(string $source): array&#123; $params = []; // read text parameters from $source return $params;&#125;function writeParams(array $params, string $source)&#123; // write text parameters to $source&#125;$file = __DIR__ . &quot;/params.txt&quot;;$params = [&quot;key1&quot; =&gt; &quot;val1&quot;,&quot;key2&quot; =&gt; &quot;val2&quot;,&quot;key3&quot; =&gt; &quot;val3&quot;,];writeParams($params, $file);$output = readParams($file);print_r($output);function readParams(string $source): array&#123;$params = []; if (preg_match(&quot;/\\.xml$/i&quot;, $source)) &#123; // read XML parameters from $source &#125; else &#123; // read text parameters from $source &#125; return $params;&#125;function writeParams(array $params, string $source)&#123; if (preg_match(&quot;/\\.xml$/i&quot;, $source)) &#123; // write XML parameters to $source &#125; else &#123; // write text parameters to $source &#125;&#125; # Object-Oriented&lt;?phpabstract class ParamHandler&#123;protected $source;protected $params = [];public function __construct(string $source)&#123; $this-&gt;source = $source;&#125;public function addParam(string $key, string $val)&#123; $this-&gt;params[$key] = $val;&#125;public function getAllParams(): array&#123; return $this-&gt;params;&#125;public static function getInstance(string $filename): ParamHandler&#123; if (preg_match(&quot;/\\.xml$/i&quot;, $filename)) &#123; return new XmlParamHandler($filename);&#125;return new TextParamHandler($filename);&#125;abstract public function write(): bool;abstract public function read(): bool;&#125;class XmlParamHandler extends ParamHandler&#123; public function write(): bool &#123; // write XML // using $this-&gt;params &#125; public function read(): bool &#123; // read XML // and populate $this-&gt;params &#125;&#125;// listing 06.06class TextParamHandler extends ParamHandler&#123; public function write(): bool &#123; // write text // using $this-&gt;params &#125; public function read(): bool &#123; // read text // and populate $this-&gt;params &#125;&#125;$test = ParamHandler::getInstance(__DIR__ . &quot;/params.xml&quot;);$test-&gt;addParam(&quot;key1&quot;, &quot;val1&quot;);$test-&gt;addParam(&quot;key2&quot;, &quot;val2&quot;);$test-&gt;addParam(&quot;key3&quot;, &quot;val3&quot;);$test-&gt;write(); // writing in XML format$test = ParamHandler::getInstance(__DIR__ . &quot;/params.txt&quot;);$test-&gt;read(); // reading in text format$params = $test-&gt;getAllParams();print_r($params); # UML通常要靠程式碼來描繪出整個架構會比較不好表示, 所以可以通過 UML 來描繪整個架構 # Class # Abstract Class # Interface # Class Properties &amp; Methods # InheritanceCd product 以及 BookProduct class 繼承了 ShopProduct # ImplementationShopProduct 實作了 Chargeable interface # Relations Teacher class 與 Pupil class 之間有 relationship, 可能是 Teacher 有 Pupil, 也可能是 Pupil 有 Teacher, 也可能互相有 Teacher class 有一個或多個 Pupil class Teacher class 與 Pupil class 互有一個或多個 一個 Teacher class 有多個 Pupil class 一個 Teacher class 有 5~10 個 Pupil class # AggregationSchoolClass class 由 Pupil class 組成, 但刪除 A SchoolClass 時不見得要刪除對應的 Pupil class, 因為 Pupil class 可能被複數的 SchoolClass 所擁有 # Compositionperson 由對應的 SocialSecurityData 組成, 每個 SocialSecurityData 只屬於特定的一個 person, 若刪除 person 則必定要刪除 SocialSecurityData # UseReport class 使用了 ShopProductWriter # Use NoteReport class 使用了 ShopProductWriter, 且詳述了使用細節","link":"/zh-tw/PhpOopNote/"},{"title":"Node.js 學習筆記","text":"前言這是一份未整理的 Node.js 學習筆記 正文安裝 在 CentOS 7 上安裝 Node.js 和 NPMNodeSource 是一家致力於提供企業級Node 支持的公司，他們為Linux 發行版維護一致更新的Node.js 軟件倉庫。要從CentOS 7 系統上的NodeSource 軟件倉庫安裝Node.js 和npm ，請按照下列步驟操作： 添加NodeSource yum 軟件倉庫Node.js 的當前LTS 版本是10.x 版。如果你想安裝的版本8 只吧下面的命令中setup_10.x 更改為setup_8.x 。運行以下curl命令將NodeSource yum軟件倉庫添加到您的系統： curl -sL https://rpm.nodesource.com/setup_10.x | bash - 安裝Node.js 和npm啟用NodeSource 軟件倉庫後，通過以下命令安裝Node.js 和npm ： yum install nodejs 驗證Node.js 和npm 安裝 node -v npm -v 如何使用NVM 安裝Node.js 和npmNVM （Node 版本管理器）是一個bash 腳本，用於管理多個活動的Node.js 版本。NVM 允許我們安裝和卸載任何特定的Node.js 版本，這意味著我們可以擁有任何數量的Node.js 版本供我們使用或測試。curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash &amp;&amp; export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; &amp;&amp; [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; 參考資料來源 要在CentOS 系統上使用NVM 安裝Node.js 和npm ，請按照下列步驟操作： 使用 fs module fs.writeFileSyncconst fs = require(&#39;fs);在 Node.js 裏頭，如果要引用一個 module ，要用一個變數引用，然後之後就可以使用它例如fs.writeFileSync(&#x27;hello.txt&#x27;, &#x27;Hello fromNode.js&#x27;); 上面的 function ，是將 Hello fromNode.js 寫進 hello.txt 這個檔案### 建立一個最簡單的 server首先，我們先引用 `http` module，當我們要調用本地 module 時，我們可以指定路徑，像是 `./http` ，但我們要調用 global 的 module 時，我們不加任何路徑， 如下```javascriptconst http = require(&#x27;http&#x27;); 接下來，我們利用剛剛引用的 http module 來建立一個 server ，如下： const server = http.createServer((req, res) =&gt; &#123; console.log(req);&#125;); or const server = http.createServer(function(req, res)&#123; console.log(req);&#125;); or function rqListener(req, res) &#123; console.log(req);&#125;const server = http.createServer(rqListener); 最後，我們雖然已經建立了 server ，但是我們還沒有指定它的位址。 我們指定 3000 port 給這個 server ，如下： server.listen(3000); 此時，我們可以從瀏覽器，輸入 localhost:3000 來拜訪這個 server 停止這個 loopconst http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; console.log(req); process.exit();&#125;);server.listen(3000); 從 request 中取得我們想要的資訊舉例來說，我們要取得 url , method , 以及 header 三項資訊，如下： const http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; console.log(req.url, req.method, req.header); // process.exit();&#125;);server.listen(3000); 下圖，我們可以看到我們特別指定的三項資訊: 設定 response我們可以在 server 中，指定 response ，如下： const http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; console.log(req.url, req.method, req.header); // process.exit(); res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); res.end();&#125;);server.listen(3000); 然後打開開發者工具，我們可以看到我們剛剛設定的 header 然後 response 的地方可以看到我們剛剛設定的 response 簡易的 request routing我們可以指定觸發特定 response 的 url ，當 client 呼叫這個 url 時，就會觸發我們指定的 response ，反之，則觸發另外的 response const http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; const url = req.url; if (url === &#x27;/&#x27;) &#123; res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;form action=&quot;/message&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); return res.end(); &#125; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); res.end();&#125;);server.listen(3000); 由上面的 code 可以看到，我們指定 req.url 必須要絕對等於 / 才會觸發條件內，我們指定的 response 如下： 當我們按下 send ，會執行 post method, action /message ，如下： 因為 action 的關係，會嘗試拜訪 message url ，而因為這個 url 並不符合我們設定的條件，所以會執行預設 response 簡單的 redirect request現在，我們要簡易的 redirect 我們的 request ，如下： const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const method = req.method; if (url === &#x27;/&#x27;) &#123; res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;form action=&quot;/message&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); return res.end(); &#125; if (url === &#x27;/message&#x27; &amp;&amp; method === &#x27;POST&#x27;) &#123; fs.writeFileSync(&#x27;message.txt&#x27;, &#x27;DUMMY&#x27;); res.statusCode = 302; res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;); return res.end(); &#125; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); res.end();&#125;);server.listen(3000); 從上面的 code 可以看到，我們新增了第二個 if statement。如果 url 等於 //message 以及 method 等於 post ，雙重條件都符合之下，就會觸發我們設定的條件我們使用了之前我們曾經使用的 fs module ，如果條件觸發，我們就會將 DUMMY 寫入一個叫做 message.txt 的檔案接著回傳 status code 302最後回導到 /在 res.end() 之後，我們不可以在 define 新的 res ，否則就會出現錯誤，因為這邊我們要使用 return ，後續的代碼就不會再執行 Parsing request bodies本章節，我們將解析 request 裡頭的 body 資料並且初次接觸到了 stream 以及 buffer 的概念。首先，我們先設定一個事件。 當接收到 data 時，觸發一個 function 並且帶入 chunk ， chunk 是資料的最小單位。接著我們使用了 console.log 來把 chunk 印出來！同時，我們建立一個 body 常數 array ，並且將每一次觸發 data 事件時，我們都將 chunk 丟到這個 array 裏頭， 代碼如下： const body = [];req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; console.log(chunk); body.push(chunk);&#125;); 接著，我們在建立一個事件，當 request 接收完成，我們在定義一個常數，叫做 parsedBody ， 至於這個常數的內容，我們使用 buffer 物件，來將 body array 裡頭的 chunk 都串起來，然後轉換成 string 。最後，我們使用 console.log 把常數 parsedBody 印出來，代碼如下： req.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); console.log(parsedBody);&#125;); 結果如下： 接下來，我們在定義一個常數 message ，它的內容是用 ‘=’ 來將常數 parsedBody 分隔，變成一個 array ，然後我們取 [1] ，就是 array 中的第二項資料。然後，我們將這個常數 message 一方面利用 console.log 印出來，一方面利用 fs module 來寫到一個叫做 message.txt 的檔案中。代碼如下： req.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(&#x27;=&#x27;)[1]; console.log(message); fs.writeFileSync(&#x27;message.txt&#x27;, message);&#125;); 至此, 此 episode 告一段落，最後全部的 code 如下： const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const method = req.method; if (url === &#x27;/&#x27;) &#123; res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;form action=&quot;/message&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); return res.end(); &#125; if (url === &#x27;/message&#x27; &amp;&amp; method === &#x27;POST&#x27;) &#123; const body = []; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; console.log(chunk); body.push(chunk); &#125;); req.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(&#x27;=&#x27;)[1]; console.log(message); fs.writeFileSync(&#x27;message.txt&#x27;, message); &#125;); res.statusCode = 302; res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;); return res.end(); &#125; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); res.end();&#125;);server.listen(3000); 了解事件驅動代碼的執行本章節介紹了事件驅動代碼的執行規則以及順序舉例來說，如果我們對目前的代碼做了一些調整，如下: req.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(&#x27;=&#x27;)[1]; fs.writeFileSync(&#x27;message.txt&#x27;, message); res.statusCode = 302; res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;); return res.end();&#125;); 首先，在一開始我們就引用了 http module 以及 fs module ，然後我們利用 http module 來建立一個 server ，並且讓這個 server 聽 3000 port 。當有任何 requets 呼叫這個 server 時，都會觸發這個 server 。我們帶入 request 以及 response ， 在 server 內可以用。首先，我們定義發請求的 url 為常數 url ， 再來，我們定義發請求的方法為常數 method如果常數 url 等於 / 時，會觸發一系列的 response ，並且 return res.end(); 做結束。如果常數 url 等於 /message 且常數 method 等於 POST 的話，定義常數 body 為 array。接下來進入事件驅動, 當開始解析 request 時，我們帶入 chunk ，印出 chunk ，並且將 chunk 放入一個叫做 body 的 array 常數另外一個事件，當 request 解析完成後， 定義一個常數叫做 parsedBody ，它是利用 buffer 物件來將在常數 body 內的所有 chunk 串連起來，然後變成 string在定義一個常數叫做 message ， 首先， 常數 parsedBody 是一個 string ，我們將這個 string 用 = 為分隔點，將這個 string 變成 array 之後，取 [1] ，就是這個 array 的第二項資料，這個就是常數 message 的值接下來，我們利用一開始引用的 fs module ， 將常數 message 的內容寫入一個叫做 message.txt 的檔案。接下來，定義 response 的 status code 為 302定義 response 跳轉的 location 為 /最後， return res.end(); 出了事件驅動之後，是定義 header ，然後定義另外一些 html 的 response ， 最後是 res.end(); Server 內的執行部分到此做一個結尾。 由於 js 的事件驅動屬性，事件 end 並不會先被執行，反之，後面的代碼會先被執行。所以這個更動會造成一個錯誤，那就是當 res.end(); 已經被執行了，才開始執行 end 事件內的 setHeader 以及 statusCode ，這樣就會造成如下的錯誤 如果，我們在 end 事件之下加了 return ，那錯誤就不會出現 ， 修改代碼如下： req.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(&#x27;=&#x27;)[1]; fs.writeFileSync(&#x27;message.txt&#x27;, message); res.statusCode = 302; res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;); return res.end();&#125;);return; 因為 end 事件之下的 res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;); 就不會被執行了。注意！ 在 return 的當下，其實 end 的監聽事件是還沒有被執行的，但是當 server 裡頭的動作執行完畢之後， request 被解析完成，觸發了 end 的監聽事件，然後才開始執行這個事件裡頭的動作。 至此，此 Episode 告一段落，截至目前的完整程式碼如下： const http = require(&#x27;http&#x27;);const fs = require(&#x27;fs&#x27;);const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const method = req.method; if (url === &#x27;/&#x27;) &#123; res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;form action=&quot;/message&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&lt;button type=&quot;submit&quot;&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); return res.end(); &#125; if (url === &#x27;/message&#x27; &amp;&amp; method === &#x27;POST&#x27;) &#123; const body = []; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; console.log(chunk); body.push(chunk); &#125;); req.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(&#x27;=&#x27;)[1]; fs.writeFileSync(&#x27;message.txt&#x27;, message); res.statusCode = 302; res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;); return res.end(); &#125;); return; &#125; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); res.write(&#x27;&lt;html&gt;&#x27;); res.write(&#x27;&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;&#x27;); res.write(&#x27;&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;&#x27;); res.write(&#x27;&lt;/html&gt;&#x27;); res.end();&#125;);server.listen(3000); Blocking and Non-Blocking Code所以，fs.writeFile 跟 fs.writeFileSync 差在哪？fs.writeFileSync 會待這個檔案寫入的任務完成之後，才會繼續向後執行，而 fs.writeFIle 會異步執行，儘管檔案寫入的任務還沒完成，程式一樣會繼續向後執行，並且，我們可以在任務完成時執行一項 callback ，修改代碼如下： req.on(&#x27;end&#x27;, () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(&#x27;=&#x27;)[1]; fs.writeFile(&#x27;message.txt&#x27;, message, (err)=&gt;&#123; res.statusCode = 302; res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;); return res.end(); &#125;);&#125;); 從以上的代碼來看，當程式執行到寫入檔案那一行， fs.writeFile ，程式不會停下來等待 fs.writeFile 執行完畢，反之，程式會繼續往下跑 ， 而當 fs.writeFile 執行完畢後，會觸發我們設定的 callback ，進而執行以下的代碼 res.statusCode = 302;res.setHeader(&#x27;Location&#x27;, &#x27;/&#x27;);return res.end(); 簡述事件迴圈本章節主要參閱官方文件 ， 以及這位大大的文章 。在本章節中，主要是搞懂 Node.js 中事件迴圈的概念。 Node.js 的架構圖 上圖可以看到，除了 V8 Engine ， Node.js 使用了 libuv 來處理 I/O 的部分，提供了 asynchronous 以及 Non-Blocking API 以及事件迴圈 ， 下面提到的事件迴圈，主要與 libuv 有關。 什麼是事件迴圈？事件迴圈，藉由將工作量分擔給 Kernel 來處理，使 Node.js 得以做非阻塞 I/O 的操作，儘管 JsvaScript 是單線程的。 因為目前新型的 Kernel 都是多線程的，它們可以在背景運行多個程序。當其中一個程序完成了， Kernel 會通知 Node.js ，所以 Node.js 會調整將適合的 callback 加到 poll 階段的 queue 當中 ，這些 callback 最終將會被執行。 深談事件迴圈以下是事件迴圈各個階段圖，以及運行順序 每個階段都有自己的 先進先出 的要被執行的 callback queue 。每個階段都有自己特別的運行方式，一般來說，當事件迴圈跑到一個特定的階段，事件迴圈將會執行這個特定階段裡頭的操作，然後執行它的 callback ，這個執行的動作會重複，直到該階段內的 callback 都被執行完畢了，或者已經達到最大的執行數量。當 queue 裡頭的工作都被處理完了，或者已達最大執行數量限制，事件迴圈會進入下一個階段，反覆循環。 因為上述提到的這些程序很有可能排定更多的程序，且由 poll 階段處理的事件將被 kernel 佇列著 ， 所以 poll 事件可以在被佇列的同時也被執行。 造成的結果是，一個耗時較長的 callback ， 會允許 poll 階段執行的久一點，甚至讓 timer 階段的工作等待。 各階段概述 timers: 這個階段主要處理 setTimeout() 以及 setInterval() 排程的 callback I/O callbacks: 除了 timers, setImmediate(), close 之外的多數類型 idle, prepare: 只供內部使用 poll: 取回新的 I/O 事件; 某些情況， node 將會阻塞在這裡 check: setImmediate() callbacks 將會在這階段被觸發 close callbacks: socket, on … libuv 各階段詳述timers:簡單來說， timers 階段將處理 setTimeout() 以及 setInterval() 的工作。 timers 並不保證可以準確地在給予的時間點執行 callback ， 反之 ，給予的時間更像是一個最低的門檻，唯有過了這個給予的時間點， callback 才會被執行，這視乎當時的工作狀態。 系統的排程或者是其他 callback 的運行都可能會延遲 timers 執行的確切時間。總而言之，過了指定的時間點之後， timers 會盡可能地盡快執行排程的 callback可以看看以下的範例： var fs = require(&#x27;fs&#x27;);function someAsyncOperation (callback) &#123; // Assume this takes 0 ms to complete fs.readFile(&#x27;/path/to/file&#x27;, callback);&#125;function anotherAsyncOperation (callback) &#123; // Assume this takes 0 ms to complete fs.readFile(&#x27;/path/to/file&#x27;, callback);&#125;var timeoutScheduled = Date.now();setTimeout(function () &#123; var delay = Date.now() - timeoutScheduled; console.log(delay + &quot;ms have passed since I was scheduled&quot;);&#125;, 100);// do someAsyncOperation which takes 200 ms to completesomeAsyncOperation(function () &#123; var startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 200) &#123; ; // do nothing &#125;&#125;);// do anotherSyncOperation which takes 200 ms to completeanotherAsyncOperation(function () &#123; var startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 200) &#123; ; // do nothing &#125;&#125;); 從上面的範例中可以看到， setTimeout 任務原定 100 ms 之後被執行，但是 someAsyncOperation 任務花了 0 + 200 ms ，當執行這個任務時，事件迴圈正處在 poll 階段，所以在一個循環中, 需等待 poll 階段中的任務完全處理完畢，或者達到最大處理數量限制。所以在上面的範例中，需等待 poll 階段的任務 someSyncOperation 以及 anotherSyncOperation 被執行完畢，總共花費 400 ms 左右， 之後才會執行 setTimeout() 的任務。 I/O callbacks這個階段主要執行系統端操作的 callbacks, 像是 TCP 錯誤。舉例來說，當試圖連接時，如果一個 TCP socket 接收到 ECONNREFUSED, 某個 *nix 系統想要等待並回報錯誤，這些都會在 I/O callbacks 階段被佇列。 pollpoll 階段有兩種主要功能: 替時間點已經到的 timers 執行腳本 處理 poll queue 當中的事件 當事件進入 poll 階段，且沒有 timers 排程事件 ， 下面兩件事中，其中一件會發生: 如果 poll 階段不為空，事件迴圈將會執行佇列中的所有 callbacks ，又或者達到最大 callbacks 處理上限 如果 poll 階段為空，以下兩件事中，其中一件會發生： 如果腳本已經被 setImmediate() 排程，事件迴圈將會結束 poll 階段，並且繼續進入到 check 階段來處理該佇列中的排程 如果腳本沒有 setImmediate() 的排程，那事件迴圈將會等待新的事件被加入到佇列，然後立即處理他們 一旦 poll 循環為空，事件迴圈將會檢查 timer 中有沒有可以執行的 callback。 如果有一個或多個可以執行了, 事件迴圈會回去執行 timer 階段的 callback check這個階段允許在 poll 階段完成後，立即執行 callback。如果 poll 階段處於空轉，或者已經有 setImmediate() 的排程，事件迴圈將會繼續進入到 check 階段，而不會等待。 setImmediate() 事實上，是一個很特別的 timer 階段，它跟 timer 在事件迴圈內跑在不同的階段。 它使用 libuv API ，這個 API 排程 callback 使之在 poll 階段結束後被執行 通常，事件迴圈會停在 poll 階段等待新的 request 或 connection ，但是當 setImmediate() 有排程，且 poll 階段處於空轉, 那事件迴圈將會結束 poll 階段，並且進入 check 階段 close callbacks如果一個 socket 或 handle 忽然被關閉， close 事件將會被置於這個階段，除非我們指定 process.nextTick 來執行它 setImmediate() vs setTimeout()setImmediate() 和 setTimeout() 很類似，但根據被呼叫的時機不一樣，行為也不同。 setImmediate() 被設計為，一旦 poll 階段結束時執行 setTimeout() 排程任務，在特定的時間之後執行 兩者之間執行的順序，根據被呼叫時的情況而有所不同。如果兩者都在主模組的時候被呼叫，那順序將由當時的程序的表現所決定，意思就是說，順序無法預測。範例如下： // timeout_vs_immediate.jssetTimeout(function timeout () &#123; console.log(&#x27;timeout&#x27;);&#125;,0);setImmediate(function immediate () &#123; console.log(&#x27;immediate&#x27;);&#125;); 然而，如果兩者是在 I/O cycle 中被呼叫，那 sedImmediate() 將會優先於 setTimeout() // timeout_vs_immediate.jsvar fs = require(&#x27;fs&#x27;)fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;timeout&#x27;) &#125;, 0) setImmediate(() =&gt; &#123; console.log(&#x27;immediate&#x27;) &#125;)&#125;) 對比 setTimeout() , 使用 setImmediate() 的主要優勢為，如果在 I/O cycle 中， setImmediate() 將會被優先執行，不管 setTimeout() 有幾個 process.nextTick()理解 process.nextTick()你可能已經注意到， process.nextTick() 並沒有被顯示在圖表上，儘管它也是 asynchronous API 的一部分。 這是因為 process.nextTick() 技術上來說不算是事件迴圈的一部分。 nextTickQueue 將會在目前操作完成後，立即被執行，不管目前是在事件迴圈內的哪一個循環。 看看我們的圖表，不管在什麼時候，只要你在特定的階段呼叫 process.nextTick() ， 所以經由 process.nextTick() 送出的 callbacks 將會在事件迴圈啟動下一個階段之前全部都處理完畢。 這樣的模式可能會造成一些不好的情況發生，因為如果你遞迴的使用 process.nextTick() callback ，就會造成所謂的 I/O 飢餓 ，事件迴圈將會無法進入 poll 階段 為什麼這樣的行為會被容許？你可能會想，為什麼這樣的行為在 Node.js 終會被容許？ Node.js 部分的設計哲學是， API 總是異步的，不管是否必要，可以參考以下範例: // this has an asynchronous signature, but calls callback synchronouslyfunction someAsyncApiCall (callback) &#123; callback(); &#125;;// the callback is called before `someAsyncApiCall` completes.someAsyncApiCall(() =&gt; &#123; // since someAsyncApiCall has completed, bar hasn&#x27;t been assigned any value console.log(&#x27;bar&#x27;, bar); // undefined&#125;);var bar = 1; 如果我們執行上面的代碼，會出現輸出如下： 因為 someAsyncApiCall 並沒有做任何異步的動作，照同步的流程跑到 console.log 時， bar 還沒有被定義 如果我們將代碼改成以下： function someAsyncApiCall (callback) &#123; process.nextTick(callback);&#125;;someAsyncApiCall(() =&gt; &#123; console.log(&#x27;bar&#x27;, bar); // 1&#125;);var bar = 1; 可以得到以下的輸出： 如上所述， process.nextTick() 的執行時間，是在當前的階段內所有的工作都完成了，在進入下個階段之前，會將所有的 process.nextTick() 處理完畢。在上面的例子中， process.nextTick() 會等到所有在此階段的代碼都被執行完畢，也就是待 var bar = 1 執行後，才去執行這個 callback ，所以不會出現 undefined 的情況。請注意！這沒有最大處理數量限制，所以如果利用 process.nextTick() 指派遞迴任務，那就會造成 I/O 飢餓 情況， 事件迴圈將無法接收到新的 request 一個 tick 到底是多長？一個 tick 的時間長度，是 Event Loop 繞完一圈，把所有 queues 中的 callbacks 依序且同步地執行完，所消耗的總時間。因此，一個 tick 的值是不固定的。可能很長，可能很短，但我們希望它能盡量地短。 process.nextTick() vs setImmediate()千萬不要被這兩個階段的命名搞混了！ process.nextTick():在當前階段結束前執行完畢 setImmediate():在下一個階段，或者下一個事件迴圈的 tick 中執行 基本上，這兩個命名應該是要互換。 process.nextTick() 比 setImmediate() 更快地被觸發。這算是一個很難更動的部分，因為當初命名錯誤之後，隨時時間的推移，越來越多 npm 的 package 都是使用這樣的命名，所以一旦這命名變更了，影響會非常的大。 官方文件上建議開發者，在任何情況中，都使用 setImmediate() ，因為它可以更簡單的被邏輯思考，然後在不同的環境上，有著更廣的相容性。 Promise從下面的原始碼可以看到 Promise ， 或者又稱為 microtasks 的執行優先順序依照原始碼的執行順序來看，在一個階段結束之前，process.nextTick() 會先被執行，緊接著, 執行 Promise 。 startup.processNextTick = function() &#123; var nextTickQueue = []; // Callbacks 會排進這個 queue!! var pendingUnhandledRejections = []; var microtasksScheduled = false; var _runMicrotasks = &#123;&#125;; // ... 略 process.nextTick = nextTick; // nextTick 函式在下面 // ... 略 // process._setupNextTick 在 node.cc 中, 我認為意思到了, 就不用再挖下去了 const tickInfo = process._setupNextTick(_tickCallback, _runMicrotasks); _runMicrotasks = _runMicrotasks.runMicrotasks; // ... 略 function _tickCallback() &#123; var callback, args, tock; do &#123; while (tickInfo[kIndex] &lt; tickInfo[kLength]) &#123; // callbacks 從 queue 中一個一個被挖出來執行 tock = nextTickQueue[tickInfo[kIndex]++]; callback = tock.callback; args = tock.args; if (args === undefined) &#123; nextTickCallbackWith0Args(callback); &#125; else &#123; switch (args.length) &#123; case 1: nextTickCallbackWith1Arg(callback, args[0]); // ... &#125; &#125; if (1e4 &lt; tickInfo[kIndex]) tickDone(); &#125; tickDone(); // process.nextTick 的 callbacks 跑完, 接著跑 Promise 的 microtasks _runMicrotasks(); emitPendingUnhandledRejections(); &#125; while (tickInfo[kLength] !== 0); &#125; // ...略 function nextTick(callback) &#123; var args; if (arguments.length &gt; 1) &#123; args = []; for (var i = 1; i &lt; arguments.length; i++) args.push(arguments[i]); &#125; // 將 callback 連它的 arguments 用一個物件存起來推進 queue nextTickQueue.push(new TickObject(callback, args)); tickInfo[kLength]++; &#125; // ... &#125;; 事件迴圈總結 順序:timers &rarr; I/O callbacks &rarr; idle, pare &rarr; poll &rarr; check &rarr; close callbacks &rarr; timers … 往復循環 順序細節 timers 設定的時間過了之後，才會被’盡快’的執行。如果 poll 階段內還有工作還沒做完，會先做完，才會執行 timers 的工作，所以可能會延遲 當處於 I/O 程序中，比如說， fs 模組中， setImmediate() 順序一定大於 setTimeout() ，因為 check 階段緊接在 poll 階段之後 當處於主要模組中， setImmediate() 以及 setTimeout 的優先順序，取決於運行狀況，這個狀態下，次序無法確定 process.nextTick() 將在當前階段的工作結束前，在進入下一個階段之前執行, 所以他的優先性是第一名的 promise 的執行次序緊接在 process.nextTick() 之後，也是在當前階段結束前執行完畢 Express.js建立一個 app server 安裝 npm npm install --save 安裝 express npm install --save express 安裝 nodemon npm install --save-dev nodemon 將 npm start script 設為 nodemonSet script as nodemon fileName.js 指定 status coderes.status (statusCode); Promise以下的範例中， function test 中，我們 return 了一個 Promise ，如果帶入 test function 中的 argument 是 1 ，那就走 resolve 路線 ， 而除了 1 之外所有的 argument, 都走 reject 路線。在 function main 中, 我們使用了 function test, 並帶入 argument 1, 個人覺得這有點像是 PHP 當中的 ternary 用法。當 argument 等於我們在 promise 當中指定的 1 時，走 resolve 路線, 而 then 就是當 promise 為 resolve 路線時該做的事。當 argument 等於是除了 1 之外的任何數，也就是會走 promise 當中的 reject 路線, 此時將會執行 catch 的動作。我們在 promise 當中指定，當走 resolve 路線時，輸出為字串 Success, 所以在 then 的 closure 當中，被帶入的 argument 就是 Success反之，當走 reject 路線時，輸出字串為 Error, 所以在 catch 的 closure 當中，被帶入的 argument 則為 Error function test(number) &#123; return new Promise((resolve, reject) =&gt; &#123; if (number === 1) &#123; resolve(&quot;Success&quot;) &#125; else &#123; reject(&quot;Failed&quot;) &#125; &#125;)&#125;function main() &#123; test(1).then((result) =&gt; &#123; // result === &quot;Success&quot; console.log(result) &#125;).catch((error) =&gt; &#123; // 不會被執行, 因為狀態是成功 &#125;) test(2).then((result) =&gt; &#123; // 不會被執行, 因為狀態是成功 console.log(result) &#125;).catch((error) =&gt; &#123; // error === &quot;Failed&quot; console.log(error) &#125;)&#125; 建立 Datastore Model// 從 google SDK 引用 Datastore functionconst &#123;Datastore&#125; = require(&#x27;@google-cloud/datastore&#x27;);// 輸入 project_idconst projectId = &#x27;balmy-sanctuary-238903&#x27;;// 初始一個 Datastore instanceconst datastore = new Datastore(&#123; projectId: projectId,&#125;);// 匯出這個 modulemodule.exports = datastore; 建立一個 Controller// 匯出這個 functionexports.test = function (req, res) &#123; async function quickStart() &#123; // The kind for the new entity const kind = &#x27;abc&#x27;; // The name/ID for the new entity const name = &#x27;sampletask1&#x27;; // The Cloud Datastore key for the new entity const taskKey = datastore.key([kind, name]); // Prepares the new entity const task = &#123; key: taskKey, data: &#123; description: &#x27;Buy milk&#x27;, &#125;, &#125;; console.log(datastore.key([&#x27;name&#x27;, &#x27;kind&#x27;])); // Saves the entity await datastore.save(task); console.log(`Saved $&#123;task.key.name&#125;: $&#123;task.data.description&#125;`); res.send(`Saved $&#123;task.key.name&#125;: $&#123;task.data.description&#125;`); &#125; quickStart().catch(console.error);&#125;; Routevar express = require(&#x27;express&#x27;);var router = express.Router();// 導入 controller 模組, 並給予名稱var datastore = require(&#x27;../controllers/datastoreController&#x27;);/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express&#x27; &#125;);&#125;);// 建一個 router, 並且導向 datastoreController 裡頭的 test functionrouter.get(&#x27;/test&#x27;, datastore.test);module.exports = router; Root address// 找一個地方新增一個檔案，輸入以下的 code// 之後我們就可以在任何一個檔案中，透過 require 這個檔案來 const rootDirconst path = require(&#x27;path&#x27;);module.exports = path.dirname(&#x27;/Users/ray/code/datastore/app.js&#x27;); 若我們 console.log 上面 exports 的值，可以得到該專案下的 root 位址 Path利用 path module 來指定路徑 // p 會等於專案根目錄下, data 資料夾之下的一個叫做 `products.json` 的檔案// 專案根目錄請參考 `root address` 章節const p = path.join(rootDir, &#x27;data&#x27;, &#x27;products.json&#x27;) object.assign 可用來複製或覆蓋目標物件let exampleObject = &#123;a:1, b:2, c:3, c:4&#125;;let copy = object.assign(&#123;&#125;, exampleObject, &#123;a:4, b:4, c:4, d:4&#125;); test 用來確認該 string 是否符合該 regex pattenvar str = &quot;Hello world!&quot;;// look for &quot;Hello&quot;var patt = /Hello/g;var result = patt.test(str);// result = true 時間var moment = require(&#x27;moment-timezone&#x27;);var test = moment(createdDate).tz(&quot;Asia/Taipei&quot;).format(&#x27;YYYY-MM-DD HH:MM:SS&#x27;);console.log(test); // 2019-05-21 08:05:44 同時異步發多請求，並待全部有結果後繼續// 需安裝兩個套件 `request-promise` 以及 `p-limit`const request = require(&#x27;request-promise&#x27;);const pLimit = require(&#x27;p-limit&#x27;);class HealthCheckService &#123; static async getHealthCheckResults(sites) &#123;// 指定 limit 同時最多發十個 request const limit = pLimit(10);// 利用 map 從 sites 中拿到我們要發請求的 url// 然後利用套件 `limit` 來限制同時發請求的數量，再來使用 `request-promise` 套件來對上面拿到的 url 發請求 let promises = sites.map((site) =&gt; &#123; let url = `https://yourAPI?host=$&#123;site.host&#125;&amp;cname=$&#123;site.cname&#125;`; return limit(() =&gt; request(url)); &#125;);// 上面的每一個 promises, 都是一個請求。 現在我們利用 `Promise.all`, 待所有的結果都回來之後，在 return return await Promise.all(promises); &#125;&#125; dotenv安裝npm npm install dotenv yarn yarn add dotenv 建立 .env 檔.env touch .env require 語法, 會自動去讀 .env 檔require(&#x27;dotenv&#x27;).config(); customName.env touch custom.env require 語法, 需要額外指定require(&#x27;dotenv&#x27;).config(&#123; path: &#x27;custom.env&#x27; &#125;); 使用方法直接使用 process.env let DB_AUTH = process.env.DB_AUTH; 使用 multer 上傳檔案安裝npm install multer --save 定義 storage在 /Storages/local.js 輸入以下 code const multer = require(&#x27;multer&#x27;);const moment = require(&#x27;moment&#x27;);module.exports = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; // 目的地資料夾位址 cb(null, &#x27;uploads&#x27;) &#125;, filename: function (req, file, cb) &#123; // 上傳檔案命名規則 cb(null, file.fieldname + &#x27;-&#x27; + moment(new Date()).format(&quot;YYYYMMDD-hhmmss&quot;)) &#125;&#125;); 建立 middleware在 server.js require 上面定義的 storage 以及 multer const multer = require(&#x27;multer&#x27;);const storage = require(&#x27;./Storages/local&#x27;);const upload = multer(&#123;storage: storage,&#125;); 將 upload 加到 routeApp.post(&#x27;/logParsing/upload&#x27;, [upload.single(&#x27;log&#x27;), LogParsingController.validate(&#x27;upload&#x27;)], LogParsingController.upload); Error Handing在 Controller 中自定義 error handing, 也可建立一個 middleware 來驗。 注意： err, req, res, next 的順序至關重要！！ upload(err, req, res, next) &#123; if (err instanceof multer.MulterError) &#123; return res.status(400).send(Output(false, [], &#x27;Wrong field&#x27;)) &#125;&#125; validator安裝Document npm install express-validator --save 引用模組在 controller 引用模組 const &#123; body &#125; = require(&#x27;express-validator&#x27;);const &#123; validationResult &#125; = require(&#x27;express-validator&#x27;); 設立規則在 controller 定規則, 新增一個 method validate(method)&#123; switch (method) &#123; case &#x27;getCountHost&#x27;: &#123; return [ body(&#x27;measurement&#x27;).exists(), ] &#125; case &#x27;getSumData&#x27;: &#123; return [ body(&#x27;measurement&#x27;).exists(), body(&#x27;host&#x27;).exists(), ] &#125; case &#x27;getData&#x27;: &#123; return [ body(&#x27;measurement&#x27;).exists(), body(&#x27;host&#x27;).exists(), ] &#125; &#125;&#125; 驗證並回報錯誤在 controller 中定義錯誤並設定回報格式 const errors = validationResult(req);if (!errors.isEmpty()) &#123; return res.status(400).send(Output(false, [], errors.errors[0].msg))&#125; 使用 validator以 middleware 的方式使用 validator App.post(&#x27;/netdatadb/sum&#x27;, NetdataController.validate(&#x27;getSumData&#x27;), NetdataController.getSumData); 結果若有錯誤, 結果如下： &#123; &quot;succeeded&quot;: false, &quot;data&quot;: [], &quot;message&quot;: [ &#123; &quot;msg&quot;: &quot;Invalid value&quot;, &quot;param&quot;: &quot;measurement&quot;, &quot;location&quot;: &quot;body&quot; &#125; ]&#125; serve static file in Expressapp.use(&#x27;/static&#x27;, express.static(path.join(__dirname, &#x27;public&#x27;))) path.join(__dirname, ‘public’): 使用絕對路徑讀取檔案 以下為請求的路徑範例： http://localhost:3000/static/images/kitten.jpghttp://localhost:3000/static/css/style.csshttp://localhost:3000/static/js/app.jshttp://localhost:3000/static/images/bg.pnghttp://localhost:3000/static/hello.html Error Handing in Express參考文件 同步的錯誤需要被 catch 嗎？ 不需要 對 controller 的 error handler 的 error catch? exports.catchErrors = (fn) =&gt; &#123; return function(req, res, next) &#123; return fn(req, res, next).catch(next); &#125;;&#125;; next() 與 next(err) 的分別？ next() 是將當前的 middleware 終止, 並導向下一個 middleware, 而 next(err) 則是會直接導向 err handler 異步錯誤需要特別被 catch 嗎？ 需要哦！ 下面的代碼中, next 的位置是怎麼樣的一種寫法？ 將 next 置於 callback 的位置, 當沒有錯時, 跳往下一個 handler, 而當有錯誤時, 將錯誤導向 error handler app.get(&#x27;/&#x27;, [ function (req, res, next) &#123; fs.writeFile(&#x27;/inaccessible-path&#x27;, &#x27;data&#x27;, next) &#125;, function (req, res) &#123; res.send(&#x27;OK&#x27;) &#125;]) 在 asynchronous 中, 如何處理 error? 若出錯, 要將 err 放到 next() 中帶往 error handler 下面的代碼中, 處理 error 的邏輯是什麼？ 當 fs.readFile 沒錯時, 跳往下一個 handler, 如果有錯, 跳往 error handler app.get(&#x27;/&#x27;, [ function (req, res, next) &#123; fs.readFile(&#x27;/maybe-valid-file&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123; res.locals.data = data next(err) &#125;) &#125;, function (req, res) &#123; res.locals.data = res.locals.data.split(&#x27;,&#x27;)[1] res.send(res.locals.data) &#125;]) 在 production 環境中, Express 會將 stack trace 送往客戶端嗎？ 不會 如果已經開始回 response 了才遇到錯誤, 比如說正在串流到客戶端, Express 預設的 error handler 會結束掉連線嗎？ 會哦 在使用自定義 error handler 時, 若要避免正在回 response 時遇到錯誤, 要注意什麼？ 要檢查 header 是否已經傳送了, 若是, 則要將錯誤導向 Express 預設 error handler 來中止連線 以下代碼是什麼樣的錯誤處理邏輯？ 如果 header 已經傳送了, 將錯誤傳給 Express 預設 error handler 來中止連線 function errorHandler (err, req, res, next) &#123; if (res.headersSent) &#123; return next(err) &#125; res.status(500) res.render(&#x27;error&#x27;, &#123; error: err &#125;)&#125; 什麼情況之下, 即使已經有建立自定義 error handler 了, Express 還是會將 error 送到預設的 error handler? 當 next(err) 被呼叫了一次以上 定義一個 error-handling middleware, 需要幾個參數？ 四個 如何在自訂的 error handler 中, 在回應 client 之前, log stack trace? console.error(err.stack) 怎麼寫一個最簡單的 log error 的 middleware? function logErrors (err, req, res, next) &#123; console.error(err.stack) next(err)&#125; 請敘述下面的 error handler 邏輯 若請求有使用 xhr 的話, 直接回應指定錯誤訊息, 若無, 導向預設 error handler (因為已經呼叫兩次) function clientErrorHandler (err, req, res, next) &#123; if (req.xhr) &#123; res.status(500).send(&#123; error: &#x27;Something failed!&#x27; &#125;) &#125; else &#123; next(err) &#125;&#125; 如果我有兩組以上的 app.get(‘/‘, [fn1, fn2, fn3]), 現在我已經執行了 fn1, 我想要跳掉 fn2, fn3 到下一個 app.get(‘/‘, [fn4, fn5, fn6]), 該怎麼做? fn1(req, res, next)&#123; //do something next(&#x27;route&#x27;)&#125;","link":"/zh-tw/Node-js/"},{"title":"第三方登入","text":"# 前言第三方登入筆記 # Facebook 使用 Laravel Socialite Provider 取得 user info FB 開發者登入, 用案主/公司的帳號建立一個應用程式 前端/APP端使用 SDK, 使用應用程式編號 &amp; 應用程式密鑰來取得 使用者的 access token 前端將 OAuth 取得的 access token 丟給後端 透過 token 取得 user info 的 code example 可參考 /Users/ray/code/fun-marketing-backend/vendor/laravel/socialite/src/Two/FacebookProvider.php 後端呼叫 debug API, 參數為 使用者的 access token 以及 應用程式的 access token, 驗證 使用者 access token 合法性 呼叫 debug API 的 response 可以取得應用程式編號, 這邊可以驗證是否跟我們的應用程式編號一致 (通常是一致) 細節 code example 可以參考 fun-marketing 專案的 FacebookService class, checkTokenValidity method # Google 使用 Laravel Socialite Provider 取得 user info 請案主/公司建立 GCP 專案 API和服務 -&gt; 資訊主頁 -&gt; 啟用 API 和服務 -&gt; 啟用 Google+ API 服務 設定 OAuth 同意畫面, 這邊具體可以參考這篇文章, 若失效可以 Google 一下 由於 Google 憑證, 採用一種平台一個憑證的方式, 因此假如有 iOS, Android, web 三種平台都會使用到 Google login, 那就會需要申請三種憑證 (Android 是使用 web 憑證, 這點我也很疑惑) 前端 (不管是 APP 端還是 web 端統稱前端) 會使用自己所屬的憑證, 將用戶導向 OAuth 頁面, 取得該用戶的 Access token 由於會有多個前端, 所以會有多組 client id, 當後端在驗證 token 合法性的時候, 會需要知道該平台所屬的 client id, 因此前端需要提供給後端 client id 以及 id token 後端可使用 Google SDK 來驗證 id token 的合法性, 需要的參數為 client id 以及 id token, code example 可參考 /Users/ray/code/fun-marketing-backend/app/Services/GoogleService.php, 從文件會發現前端多帶一個 access token, 這是在上個版本用其他的驗證方式, 後面更新了新的驗證方式, 但 iOS 更新都要上版審核, 因此保留前端接口, 後端取而不用 # Apple 使用 Laravel Socialite Provider 取得 user info 安裝 Socialite Apple Provider, 可參考文件 第一種流程: 由前端或 APP 拿到 code 後直接丟給後端, 由後端拿著 code 去跟 Apple 拿資料, 這種方式主要適合 server side render 或只有一個第三方, 要是雙平台可能就不適用, 因為 用 authorization code 跟 Apple 取得使用者資料會需要 client secret, 而 client secret 是由 private key, team_id, client_id, key_id 這些資訊封裝成一個 JWT, 問題就在於 client id 是會隨著平台變動的, 比如 iOS 會使用 app id, 但 web 就會使用 service id, 所以當雙平台都要實作 apple login 時, 這種流程就不適用 第二種流程: 這種流程基本上就不使用 Socialite 了, 因為 Socialite 主要是後端拿 authorization code 去跟 apple 端取 user info, 因此會需要上面提到的 client secret。 這種流程靠前端取得 identify_token, 後端只負責驗證 token 合法性, 若合法便可直接拿 token 中的 user info 來用 Apple login 驗證比較複雜, 首先第一步要先取得 public key, 因為 apple id token 是用 asymmetic 方式簽發的, apple 用 private key 簽, 而我們用 public key 來驗證, 蘋果文件 有提供 url 取得 JWKs 取得 JWKs 後, 可使用其中的 n 以及 e 參數, 來還原出 public key 取得 public key 後, 便可用該 public key 來驗證該 id token 是否合法, 完整流程可參考專案 /Users/ray/code/fun-marketing-backend/app/Services/AppleService.php, valdiateIdToken() 完整資訊可參考這邊文章, 我覺得寫得很棒 若使用流程一, 則需使用 gem 安裝 jwt 套件, 使用 script 來產生 client secret, secret 位於 /Users/ray/code/fun-marketing-backend/ignore_me/client_secret.rb","link":"/zh-tw/ThirdPartyLogin/"},{"title":"Linux 伺服器篇 - 學習筆記","text":"# 前言這是一份未整理過的 Linux Server 學習筆記內容參考出處： 鳥哥的 Linux 的私房菜 Internet # 電腦網路組成 節點 (node) 是什麼？ 具有網路位址 (IP) 的設備, 如 PC、Linux ServerHub 算 node 嗎？ 不算, 因為它沒有 IP伺服器主機 (server) 是什麼？ 就網路連線的方向來說，提供資料以『回應』給用戶的主機， 都可以被稱為是一部伺服器。工作站 (workstation) 或用戶端 (client) 是什麼？ 任何可以在電腦網路輸入的設備都可以是工作站， 若以連線發起的方向來說，主動發起連線去『要求』資料的，就可以稱為是用戶端 (client)。網路卡 (Network Interface Card, NIC)： 內建或者是外插在主機上面的一個設備， 主要提供網路連線的卡片網路介面： 利用軟體設計出來的網路介面，主要在提供網路位址 (IP) 的任務。一張網卡可以搭配幾個以上的網路介面？ 一個以上的網路介面；而每部主機內部其實也都擁有一個內部的網路介面，那就是 loopback (lo) 這個迴圈測試介面！網路形態或拓樸 (topology)： 各個節點在網路上面的連結方式，一般講的是物理連接方式。 舉例來說，上圖中顯示的是一種被稱為星形連線 (star) 的方式，主要是透過一個中間連接設備， 以放射狀的方式連接各個節點的一種形態，這就是一種拓樸。網關 (route) 或通訊閘 (gateway)： 具有兩個以上的網路介面， 可以連接兩個以上不同的網段的設備，例如 IP 分享器就是一個常見的網關設備。 # 電腦網路區域範圍網路的大小範圍主要區分為哪兩種？- 區域網路 (Local Area Network, LAN) - 廣域網路 (Wide Area Network, WAN) # OSI 七層協定什麼是 OCI? Open System InterconnectionOCI 有幾層？ 七層實體層必須要定義什麼？ 所使用的媒體設備之電壓與訊號實體層英文？ Physical Layer為什麼實體曾要先定義所使用媒體設備之電壓與訊號？ 因為網路媒體只能傳送 0 與 1 這種位元串實體層需要瞭解什麼的編碼方式？ 資料訊框轉成位元串的方式OSI 模型中, 將上層東西打包放進下一層, 這個動作稱為？封裝 OSI 模型中, 實體層的大概職責？定義網路線材質, 連接器的類型, Pin 腳排列方式, 實體網路器材相關 OSI 模型中, 鏈結層的大概職責？定義了如何和直接連線的設備之間建立邏輯傳送路徑 (資料鏈結) 的方法, OSI 模型中, 網路層的大概職責？定義了和相同或不同的網路設備連線時, 如何選擇位址和路徑的方法 OSI 模型中, 傳送層的大概職責？定義了如何確實將資料送達接收端的方法 OSI 模型中, 會談層的大概職責？定義了如何建立與切斷傳送資料所使用的通訊路徑(連線) OSI 模型中, 表現層的大概職責？定義了如何將應用資料轉換為通訊所適用的型態 OSI 模型中, 應用層的大概職責？定義了如何根據不同的應用, 提供各種服務的方法 訊框(Frame)中的 FCS 全寫是什麼？Frame Check Sequence OSI 七層系統中, 當乙太網路收到網路層傳來的封包時, 會附加哪三樣資訊？- 前序 (Preamble) - 標頭 (Header) - 訊框檢查序列 (Frame Check Sequence) MAC 位址中, OUI 的全寫是什麼？Organizationally Unique Identifier MAC 位址中, 前三碼 Vendor ID 是由哪個組織頒發的？美國電子電機工程協會 (IEEE) MAC 位址中, 每幾個 bit 會隔開?8 bits MAC 位址中, 共有幾個區段？6 個 MAC 位址中, 共有幾 bit 組成?48 bits MAC 位址中, 每一個區段用多少進位的方式表示？16 進位 當 OSI 第三層 (網路層) 從第四層 (傳送層) 收到 segment 之後, 會做什麼事？附加 IP 標頭 # 集線器、交換器與相關機制 集線器 (hub) 以及交換器 (switch) 的差異？ 交換器內有一個特別的記憶體, 這個記憶體可以記錄每個 switch port 與連接的 PC 的 MAC 位址如上圖, 假設每個 port 都擁有 10/100Mbps 的頻寬, 那當 A 與 D 都傳給 C 時, 會發生什麼事？ 等於 A 與 D 都需要搶 C 節點的 10/100Mbps 來用的意思。什麼是全雙工 (full-duplex)? 如果兩端的 PC 同時支援全雙工時, 那表示 input/output 均可達到 10/100 Mbpshub 可以達到全雙工嗎？ 因為網路線腳位的關係, 無法使用共享媒體來達到全雙工的switch 可以達到全雙工嗎？ 要有支援才行什麼是 N-Way? auto-negotiation, 可自動的協調出最高的傳輸速度來溝通是否需要分辨平行線與跳線？ 不需要, 因為 switch 若含有 auto MDI/MDIX 的功能, 會自動分辨網路線的腳位來調整連線的網路線如果在門邊常常被門板壓, 導致變形, 會造成訊號衰減嗎？ 會哦交換器會將哪兩項資訊記在 address table 裡？- 傳送端 LAN port - 傳送端 MAC address 當接收端的 MAC address 還未被記錄在交換器的 MAC address table 時, 交換器會將訊框發給哪些對象？所有對象 # 封包的封裝IP 封裝的表頭資料： IP 封包可以達到多大？ 65535 bytes如果 IP 封包比 MAC 還大, 那我們的作業系統會做什麼事？ 會對 IP 進行拆解的動作上圖中的 Version (版本), 代表什麼意思？ 宣告這個 IP 封包的版本, 例如 IPv4上圖中的 IHL, 代表什麼意思？ (Internet Header Length)(IP 表頭長度)上圖中的 Type of Service, 代表什麼意思？ IP 封包的服務類型IP 封包的服務類型的項目內容為？ PPPDARUUIP 封包的服務類型的項目內容 PPPDARUU, PPP 代表？ 此 IP 封包的優先度, 很少使用IP 封包的服務類型的項目內容 PPPDARUU, D 代表？ 一般延遲(delay), 若為 1 表示為低延遲IP 封包的服務類型的項目內容 PPPDARUU, T 代表？ 傳輸量 (throughput), 若為 1 表示為高傳輸量IP 封包的服務類型的項目內容 PPPDARUU, R 代表？ 可靠度 (reliability), 若為 1 表示為高可靠度IP 封包的服務類型的項目內容 PPPDARUU, UU 代表？ 保留尚未被使用IP 封包中, Total Length(總長度) 代表什麼？ 指這個 IP 封包的總容量, 包括表頭與內容IP 封包中, Identification (辨別碼) 代表什麼？ 識別這一個小 IP 封包是來自於哪一個大 IP 封包IP 封包中, Flags (特殊旗標) 代表意義？ 代表封包是否分段, 是否為最後一個分段IP 封包中, Flags (特殊旗標) 中, D 代表？ 0 可以分段, 1 不可分段IP 封包中, Flags (特殊旗標) 中, M 代表？ 0 最後一段, 1 非最後一段IP 封包中, Fragment offset (分段偏移) 代表意義？ 表示這個 IP 分段在原始 IP 封包中所佔的位置透過 IP 封包中的哪些資訊, 就能夠將小 IP 分段在接收端組合起來？ Total Length, Identification, Flags, Fragment OffsetIP 封包中, Time To Live (TTL, 存活時間), 是什麼？ 表示這個 IP 封包的存活時間IP 封包中, Time To Live (TTL, 存活時間), 範圍為多少? 0-255IP 封包中, Time To Live (TTL, 存活時間), 計算方法？ 當 IP 封包通過一個路由器, TTL 減一, 當 TTL 為 0, 封包將會被直接丟棄IP 封包中, Protocol Number (協定代碼)是什麼？ 記載資料是屬於哪一種協定IP 封包中, Header Checksum (表頭檢查碼) 是什麼？ 用來檢查這個 IP 表頭的錯誤檢驗之用IP 封包中, Source Address 是什麼？ 來源的 IP 位址IP 封包中, Destination Address 是什麼？ 目標的 IP 位址IP 封包中, Options (其他參數）是什麼？ 這個是額外的功能，提供包括安全處理機制、路由紀錄、時間戳記、嚴格與寬鬆之來源路由等。IP 封包中, Padding (補齊項目) 是什麼？ 每個 IP 資料都必須要是 32 bits, 若 Options 的資料不足 32 bits, 則由 padding 主動補齊若以配送貨物來比喻 IP 封包, IP 標頭就好像什麼一樣？託運單 若以配送貨物來比喻 IP 封包, 乙太網路訊框就像是？宅配車 # IP 位址的組成與分級 IP 的全寫？ Internet ProtocolIP 其實是什麼？ 是一種網路封包IP 是由幾個 bit 所組成？ 32個IP 是由 32 個什麼單位組成？ bit組成 IP 的 32 bit, 是幾進位？ 2 進位我們將 IP 分成幾小段？ 4 小段每小段的 IP 有幾 bit? 8 bitsIP 最小到最大分別是多少？ 0.0.0.0 ~ 255.255.255.255IP 又可分為哪兩個部分？ Net_ID (網域號碼) 與 Host_ID (主機號碼)同一個網域的定義？ 在同一個物理網段內, 主機的 IP 具有相同的 Net_ID, 並且具有獨特的 Host_ID什麼是物理網段？ 當所有的主機當是使用同一個網路媒體串在一起同一個 Net_ID 裏頭, 可以具有相同的 Host_ID 嗎？ 不可 在同一個網段內, Net_ID 會變嗎？ 不會哦Host_ID 在二進位的表示法中, 不可設置為哪兩種情況？ 同時為 0 或同時為 1Host_ID 若全部為 0, 表示？ 整個網段位址 (Network IP)Host_ID 若全部為 1, 表示？ 廣播位址 (Broadcast IP)上圖範例中, 可使用的主機 IP 範圍是？ 192.168.0.1 ~ 192.168.0.254透過 CSMA/CD 傳遞資料的條件是？ 必須在同一個網段內在同一個網段內, 如果要連結不同的網域, 要透過什麼？ 路由器 router InterNIC 將 IP 網段分成哪幾個等級？ A, B, C, D, EIP 等級中, 二進位的 class A 是？ 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxxIP 等級中, 二進位的 class B 是？ 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxxIP 等級中, 二進位的 class C 是？ 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxxIP 等級中, 二進位的 class D 是？ 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxxIP 等級中, 二進位的 class E 是？ 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx能夠設定在一般系統上的, 只有哪三個等級的 IP? A, B, CIP 等級中, class D 的用途？ Multicast (群播), 通常用在大批電腦的網路還原IP 等級中, class E 的用途？ 保留沒有使用 # IP 的種類與取得方式IPv4 當中, IP 有哪兩種類別？ public IP (公共 IP), private IP (私有 IP)IPv4 當中, 什麼是 public IP ? 經由 INTERNIC 所統一規劃的 IP，有這種 IP 才可以連上 Internet ；IPv4 當中, 什麼是 private IP ? 不能直接連上 Internet 的 IP ， 主要用於區域網路內的主機連線規劃。private IP class A 範圍？ 10.0.0.0 - 10.255.255.255private IP class B 範圍？ 172.16.0.0 - 172.31.255.255private IP class C 範圍？ 192.168.0.0 - 192.168.255.255私有 IP 的路由資訊可以對外散播嗎？ 不行使用私有 IP 作為來源或目的地址的封包, 可以透過 Internet 轉送嗎？ 不行關於私有 IP 的參考紀錄(如 DNS), 可以在 Internet 上使用嗎？ 不行如果電腦沒有網卡, 可以測試伺服器環境運作狀況嗎？ 可以, 使用 localhost內部迴圈的網段範圍？ class A 的 127.0.0.0/8DHCP 全寫是什麼？ Dynamic Host Configuration ProtocolDHCP 用途是什麼? 內部網路或網路服務供應商自動分配 IP 位址給用戶IP 的三種取得方式？ 手動設定, 撥接取得, DHCPISP 全寫是什麼？ Internet Service Provider # Netmask, 子網路與 CIDR (Classless Interdomain Routing)Netmask (子網路遮罩) 的功能？ 將 Net_ID 以及 Host_ID 的界線切割出來Host_ID 範圍內的第一個 IP 是什麼？ Network, 可以說是這個 IP 範圍的路徑Host_ID 範圍內的最後一個 IP 是什麼？ Broadcast, 用來廣播用要得到精確的 Host_ID, 需要哪兩項資訊？ IP 位址, Netmask 上圖的寫法又稱為？ CIDR 寫法CIDR 全寫為？ Classless Interdomain Routing # 路由概念192.168.10.100/25 與 192.168.10.200/25 是否在同一個網域內？ 如果經過計算，會發現 192.168.10.100 的 Network 為 192.168.10.0 ，但是 192.168.10.200 的 Network 卻是 192.168.10.128，由於 Net_ID 不相同，所以當然不在同一個網段內！ 上圖中, 當 PC01 這部主機想要傳送資料到 PC11 時, 他的 IP 封包該如何傳輸？- 查詢目標 IP 封包的目標 IP 位址 - 查詢是否位於本機所在的網域之路由設定 - 查詢預設路由 - 送出封包至 gateway 後, 不理會封包流向 當主機想要傳送資料時, 第一個動作是？ 查詢本機路由表 (route table)當主機想要傳送資料時, 發現目標 IP 與本機 IP 的 Net_ID 相同時(同一網域), 會怎麼做？ 直接透過區網功能, 將資料直接傳送給目的地主機當主機想要傳送資料時, 發現目標 IP 與本機 IP 的 Net_ID 不同時, 會怎麼做？ 直接將 IP 封包送到預設路由器 (default gateway)當主機送出封包後, 是否會追蹤封包流向？ 不會網關 / 路由器的功能？ 負責在不同網域之間的封包傳遞 上圖中, 當 PC 01 要將封包傳送到 Server Bingo, 流程該是怎樣？ 依據自己的路由表，將該封包送到 Server A 去，Server A 再繼續送到 Server B ，然後在一個一個的接力給他送下去，最後總是可以到達 Server Bingo 的。 # 觀察主機路由： route如何觀察主機自己的路由表？ route or route -n 上圖中, Destination 代表什麼？ Network上圖中, Gateway 代表什麼？ 通往該 Destination 所需要的 Gateway, 若為 0.0.0.0 表示不需要額外的 IP上圖中, Genmask 代表什麼？ Netmask上圖中, Flags 代表什麼？ 多個旗標來表示網域或主機代表的意義上圖中, Flags 為 U 代表什麼？ 代表該路由可用上圖中, Flags 為 G 代表什麼？ 代表該網域須經由 Gateway 幫忙轉遞上圖中, Flags 為 H 代表什麼？ 代表該路由為一部主機, 而非一整個網域上圖中, iface 代表什麼？ Interface上圖中, 共有幾個路由規則? 三個上圖中, 第一欄顯示的是? 目的地網域上圖中, 最後一欄顯示的是? 要去這個目的地要使用哪一個網路介面上圖中, etho 是什麼? 網路卡裝置代號上圖中, 假設我們要傳送的封包在路由規則裡面的 192.168.0.0/255.255.255.0 或者 127.0.0.0/255.0.0.0 裡面時，因為第二欄 Gateway 為*, 所以封包會怎麼樣？ 直接以後面的網路介面來傳送出去, 不透過 Gateway上圖中, 萬一我們要傳送的封包目的地 IP 不在路由規則裡面, 會怎麼樣? 封包會被傳送到 default 的路由規則 # IP 與 MAC：鏈結層的 ARP 與 RARP 協定ARP 全寫是？ Address Resolution Protocol 網路位址解析協定RARP 全寫是？ Reverse Address Resolution ProtocolARP 的作用？ 得到目標 IP 的實際網卡卡號 (MAC)如何從一個區網內得知目標主機的 MAC? 主機會對整個區網發出 ARP 封包, 對方收到封包後就會回傳他們的 MAC 給我們當使用 ARP 取得目標 IP 與它的網卡卡號之後, 主機會做什麼事？ 將該筆記錄寫進我們主機的 ARP table當使用 ARP 取得目標 IP 與它的網卡卡號之後, 並將該紀錄寫進主機的 ARP table 之後, 資料會記錄多久？ 20 分鐘如何取得自己的網卡卡號 in Linux？ ifconfig eth0如何取得本機的 ARP table 資訊？ arpIP 是邏輯為止, 而 MAC 是實體位置, 是什麼將兩者聯繫起來？ARP 在封包的傳送過程中, IP 在不同網段內是否會改變？不會 在封包的傳送過程中, MAC 在不同網段內是否會改變？會 # ICMP 協定ICMP 全名是？ Internet Control Message Protocol 網際網路訊息控制協定基本上, ICMP 的作用是？ 錯誤偵測與回報的機制ICMP 是透過什麼來進行資料傳送的？ IP 封包 哪兩個簡單的指令是利用 ICMP 來檢驗網路的狀態？ ping, traceroute # 可靠連線的 TCP 協定TCP 全寫？ Transmission Control Protocol網路層的 IP 封包, 跟此封包會不會被接受, 或有沒有正確的被接受, 有關係嗎？ 沒有 TCP 封包位於什麼內？ IP 封包 TCP 封包中有 Source port 跟 Destination port 嗎？ 有哦TCP 封包中, 什麼是 Sequence Number (封包序號)? 由於 TCP 封包必須要帶入 IP 封包當中，所以如果 TCP 資料太大時(大於 IP 封包的容許程度)， 就得要進行分段。這個 Sequence Number 就是記錄每個封包的序號，可以讓收受端重新將 TCP 的資料組合起來。TCP 封包中, 什麼是 Acknowledge Number (回應序號)? 確認 client 端有收到資料TCP 封包中, 什麼是 Data Offset (資料補償)? 那個 Options 的欄位長度是非固定的，而為了要確認整個 TCP 封包的大小，就需要這個標誌來說明整個封包區段的起始位置。TCP 封包中, 什麼是 Reserved (保留)? 未使用的保留欄位TCP 封包中, 什麼是 code (Control Flag, 控制標誌碼)? 當我們在進行網路連線的時候，必須要說明這個連線的狀態，好讓接收端瞭解這個封包的主要動作TCP 封包中, code (Control Flag, 控制標誌碼), 共有幾 bit? 6 bitsTCP 封包中, code (Control Flag, 控制標誌碼), 共有幾個控制碼? 6 個TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, 若為 1 時, 代表什麼? 啟動TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, URG (Urgent) 代表什麼? 若為 1 則代表該封包為緊急封包， 接收端應該要緊急處理，且上圖當中的 Urgent Pointer 欄位也會被啟用。TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, ACK (Acknowledge) 代表什麼? 若為 1 代表這個封包為回應封包， 則與上面提到的 Acknowledge Number 有關。TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, PSH (Push function )代表什麼? 若為 1 時，代表要求對方立即傳送緩衝區內的其他對應封包，而無須等待緩衝區滿了才送。TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, RST(Reset) 代表什麼? 如果 RST 為 1 的時候，表示連線會被馬上結束，而無需等待終止確認手續。這也就是說， 這是個強制結束的連線，且發送端已斷線。TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, SYN(Synchronous) 代表什麼? 若為 1，表示發送端希望雙方建立同步處理， 也就是要求建立連線。通常帶有 SYN 標誌的封包表示『主動』要連接到對方的意思。TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, FIN(Finish) 代表什麼? 若為 1 ，表示傳送結束，所以通知對方資料傳畢， 是否同意斷線，只是發送者還在等待對方的回應而已。TCP 封包中, Window (滑動視窗), 代表什麼？ 主要是用來控制封包的流量的，可以告知對方目前本身有的緩衝器容量TCP 封包中, Window (滑動視窗), 當 Windows = 0 時, 代表什麼？ 代表緩衝器已經額滿，所以應該要暫停傳輸資料。TCP 封包中, Window (滑動視窗), Window 的單位？ ByteTCP 封包中, Checksum(確認檢查碼), 檢查原理？ 當資料要由發送端送出前，會進行一個檢驗的動作，並將該動作的檢驗值標注在這個欄位上； 而接收者收到這個封包之後，會再次的對封包進行驗證，並且比對原發送的 Checksum 值是否相符，如果相符就接受，若不符就會假設該封包已經損毀，進而要求對方重新發送此封包！TCP 封包中, Urgent Pointer(緊急資料), 是什麼？ 這個欄位是在 Code 欄位內的 URG = 1 時才會產生作用。可以告知緊急資料所在的位置。TCP 封包中, Options(任意資料)? 目前此欄位僅應用於表示接收端可以接收的最大資料區段容量，若此欄位不使用， 表示可以使用任意資料區段的大小。這個欄位較少使用。TCP 封包中, Padding(補足欄位)? 如同 IP 封包需要有固定的 32bits 表頭一樣， Options 由於欄位為非固定， 所以也需要 Padding 欄位來加以補齊才行。同樣也是 32 bits 的整數。TCP 是連接導向還是非連接導向？ 連接導向port 最大可達多少？ 65535 (2 的 16 次方)假如 IP 是網路世界的門牌, 那麼 port 可以想像成什麼？ 該門牌號碼上建築物的樓層小於 1024 的 port 要啟動時, 啟動者的身份必須是? root特權埠口的範圍？ 小於 1024 的 port哪裡可以查到每個 port 的已規範網路服務軟體 /etc/services當 server 收到 client 端的請求後, 當 server 要回應給 client 時, 需回應給當初請求的 port 號口嗎？需要哦 # TCP 的三向交握 三項交握的第一步驟 - 封包發起？ 當用戶端想要對伺服器端連線時，就必須要送出一個要求連線的封包，此時用戶端必須隨機取用一個大於 1024 以上的埠口來做為程式溝通的介面。然後在 TCP 的表頭當中，必須要帶有 SYN 的主動連線(SYN=1)，並且記下發送出連線封包給伺服器端的序號 (Sequence number = 10001) 。三項交握的第二步驟 - 封包接收與確認封包傳送？ 當伺服器接到這個封包，並且確定要接收這個封包後，就會開始製作一個同時帶有 SYN=1, ACK=1 的封包， 其中那個 acknowledge 的號碼是要給 client 端確認用的，所以該數字會比(A 步驟)裡面的 Sequence 號碼多一號 (ack = 10001+1 = 10002)， 那我們伺服器也必須要確認用戶端確實可以接收我們的封包才行，所以也會發送出一個 Sequence (seq=20001) 給用戶端，並且開始等待用戶端給我們伺服器端的回應喔！三項交握的第三步驟 - 回送確認封包 當用戶端收到來自伺服器端的 ACK 數字後 (10002) 就能夠確認之前那個要求封包被正確的收受了， 接下來如果用戶端也同意與伺服器端建立連線時，就會再次的發送一個確認封包 (ACK=1) 給伺服器，亦即是 acknowledge = 20001+1 = 20002 囉。三項交握的第一步驟 - 封包發起, 用戶端會隨機取得合乎哪個條件下的 port? 大於 1024三項交握的第一步驟 - 封包發起, 在 TCP 表頭, 必須帶有哪些資訊？ SYN=1, Sequence number三項交握的第二步驟 - 封包接收與確認封包傳送, 伺服器端若決定要接收封包, 會回傳哪些資訊？ SYN=1,ACK=1,sequence number,acknowledge number三項交握的第二步驟 - 封包接收與確認封包傳送, 伺服器端若決定要接收封包, 回傳的 Acknowledge number 規則是？ 比 client 端的 sequence number 多 1 個號碼 # 非連接導向的 UDP 協定 UDP 的全寫是？ User Datagram Protocol 用戶資料流協定UDP 協定中, 接收端在接收到封包之後, 會回應封包 (ACK) 給發送端嗎？ 不會UDP 比較適合哪些使用情境？ 影像即時傳送軟體, 網路攝影機封包上面通常都會具有哪四個基本的資訊 來源與目的 IP 以及來源與目的端的 port number防火牆基本原理？ 進行封包表頭的分析，並且設定分析的規則，當發現某些特定的 IP 、特定的埠口或者是特定的封包資訊(SYN/ACK等等)，那麼就將該封包給他丟棄 # DNSDNS 全寫 Domain Name SystemDNS 主機的 IP 位址設定在哪個檔案？ /etc/resolv.conf若在本機沒有把 DNS 伺服器的位址設定好, 會變成怎樣？ 只能用 IP 上網Hinet 最大的 DNS 伺服器？ 168.95.1.1 # 一組可以連上 Internet 的必要網路參數一組合理的網路設定需要哪些資料？ IP, Network, Netmask, Broadcast, Gateway, DNSNetwork 以及 Broadcast 可以經由哪兩個資訊計算得來？ IP/Broadcast如果是使用 ADSL 撥接上網的話, 可以經由哪里獲得資料？ ISP如果是使用 ADSL 撥接上網的話, 資料會如何設定完成？ 自動設定完成 # 習題在 ISP 提供的網路服務中，他們提到傳輸速度為 1.5M/382K ，請問這個數據的單位為何？數據單位為 bits/second, 與慣用的 bytes 差 8 倍。 # 連上 Internet在 Linux 中, 預設的網卡代號為？eth0 如何確認網路卡有被核心捕捉到？dmesg | grep -in eth # Linux 常用網路指令 上圖中, etho 代表什麼？ 就是網路卡的代號，也有 lo 這個 loopback上圖中, HWaddr 代表什麼？ 就是網路卡的硬體位址，俗稱的 MAC 是也上圖中, net addr 代表什麼？ IPv4 的 IP 位址上圖中, Bcast 代表什麼？ Broadcast上圖中, Mask 代表什麼？ Netmask上圖中, inet6 addr 代表什麼？ 是 IPv6 的版本的 IP上圖中, MTU 代表什麼？ Maximum Transmission Unit上圖中, RX 代表什麼？ 那一行代表的是網路由啟動到目前為止的封包接收情況， packets 代表封包數、errors 代表封包發生錯誤的數量、 dropped 代表封包由於有問題而遭丟棄的數量等等上圖中, TX 代表什麼？ 那一行代表的是網路由啟動到目前為止的封包傳送情況， packets 代表封包數、errors 代表封包發生錯誤的數量、 dropped 代表封包由於有問題而遭丟棄的數量等等上圖中, collisions 代表什麼？ 代表封包碰撞的情況，如果發生太多次， 表示你的網路狀況不太好；上圖中, txqueuelen 代表什麼？ 代表用來傳輸資料的緩衝區的儲存長度上圖中, RX bytes, TX bytes 代表什麼？ 總接收、傳送的位元組總量在 Linux 當中, 當我們連線到網路的速度慢時, 想要確認是我們自己網路環境有問題, 還是外部 Internet 有問題, 可以使用哪一個指令？ 可使用 traceroute在 Linux 的 traceroute 指令, 可以更換測試的封包類型嗎？ 可以哦在 Linux 中, 如果要下載指定 url 的檔案, 可以使用哪一個文字介面下載器呢？ wget在 Linux 中, 若想要監聽封包可以使用哪一個指令？ tcpdump # 網路安全與主機基本防護：限制埠口, 網路升級與 SELinux網路封包進入主機的流程? Linux 中, 預設的防火牆有幾種機制？ 兩個Linux 中, 預設的防火牆有哪兩種機制？1. 封包過濾式的 netfilter 防火牆2. 軟體控管的 TCP Wrapper 防火牆 Linux 中, 預設的防火牆 netfilter 是哪一個軟體提供的功能？ iptableLinux 中, 預設的防火牆 netfilter 是分析什麼來進行過濾的機制？ TCP/IPLinux 中, 預設的防火牆 netfilter 是分析 OSI 的哪幾層？(2) 資料連結層(3) 網路層(4) 傳輸層 Linux 中, 預設的防火牆 netfilter 主要控制的是什麼？MAC, IP, ICMP, TCP, UDP, PORT, 狀態(SYN, ACK...) 等 # SELinux 的運作模式SELinux 的順序？ 上圖中, 主體的意思是？就是程序 上圖中, 目標的意思是？檔案系統 上圖中, 政策的意思是？由於程序與檔案數量龐大，因此 SELinux 會依據某些服務來制訂基本的存取安全性政策。這些政策內還會有詳細的規則 (rule) 來指定不同的服務開放某些資源的存取與否。 Centos 提供的兩個 SELinux 的主要政策是？targeted：針對網路服務限制較多，針對本機限制較少，是預設的政策；mls：完整的 SELinux 限制，限制方面較為嚴格。 # DNSFQDN 的全寫??Fully Qualified Domain Name DNS 的階層架構?? DNS 的最上層 server 為??., 又稱為 root DNS 中, 什麼是 TLD?Top Level Domains DNS 中, 什麼是 gTLD?Generic Top Level Domains DNS 中, 什麼是 ccTLD?Country Code Top Level Domains DNS 中, 最早由 root 管理的六大領域中, com 為？Company DNS 中, 最早由 root 管理的六大領域中, org 為？organisation DNS 中, 最早由 root 管理的六大領域中, edu 為？education DNS 中, 最早由 root 管理的六大領域中, gov 為？Government DNS 中, 最早由 root 管理的六大領域中, net 為？Network DNS 中, 最早由 root 管理的六大領域中, mil 為？Military DNS 中, 當我今天在瀏覽器輸入一個 domain name, 其具體步驟為何？ 如上圖, 當今天我在瀏覽器輸入一個 domain name, 第一步驟是？像 /etc/resolv.conf 檔案中的 DNS server 查詢 如上圖, 當 DNS Server 收到 Client 端的查詢請求時, 第一步驟會做什麼？查詢本身有沒有紀錄 如上圖, 當 DNS Server 收到 Client 端的查詢請求時, 如果 DNS Server 本身沒有紀錄, 會怎麼做？向 . (也就是 root) 做查詢 如上圖, 當 .(root) 收到 DNS Server 的查詢請求時, 會做什麼？告知 .tw 的位置 如上圖, 當 .tw 收到 DNS Server 的查詢請求時, 會做什麼？告知 .edu.tw 的位置 如上圖, 當 .edu.tw 收到 DNS Server 的查詢請求時, 會做什麼？告知 .ksu.edu.tw 的位置 如上圖, 當 .ksu.edu.tw 收到 DNS Server 的查詢請求時, 會做什麼？告知 www.ksu.edu.tw 的 IP 位置 如上圖, 當 DNS Server 查到該 DNS 的 IP 並回報 Client 之後, 會把紀錄存起來嗎？會哦 如何追蹤 DNS 查詢的過程？dig +trace domain DNS 使用哪個 port?53 要讓你的主機名稱對應 IP 且讓其他電腦都可以查詢的到，有哪兩種方式？- 上層 DNS 授權領域查詢權，自己設定 DNS 伺服器 - 請上層 DNS 伺服器設定主機名稱對應 DNS 系統中, 從主機名稱查詢到 IP 的流程稱為?正解 dns lookup DNS 系統中, 從 IP 反解析到主機名稱的流程稱為?反解 reverse dns lookup DNS 系統中, PTR 的全寫是？PoinTeR DNS 系統中, PTR 的功用是？反解, 指向 resource DNS 系統中, 誰能夠設定反解？IP 的擁有人 DNS 系統中, 一部簡單的 DNS server 基本上要有兩個 zone, 哪兩個?hint: 紀錄 . 的 zone自己領域的正解 zone DNS 系統中, 如果有兩部以上的 DNS 伺服器, 會先搜尋到哪一台？不知道, 是隨機的 DNS server 中, Master 跟 Slave 的查詢優先權？先搶先贏 DNS server 中, Master/Slave 的同步又分成哪兩種方式?1. Master 主動告知 2. Slave 主動提出 DNS server 中, Master/Slave 的更新, 決定是否更新的要素是什麼？代表該資料庫新舊的序號 DNS server 中, Master/Slave 的更新, Master 主動告知的方式中, master 什麼時候向 slave 發請求？當 master 在修改了資料庫內容後 DNS server 中, Master/Slave 的更新, slave 主動告知的方式中, slave 什麼時候向 master 發請求？slave 會定時查看 master 資料庫的序號, 如果發現 master 的序號比較大, 就會開始更新 DNS 系統設定檔中, 有哪三個？- /etc/hosts - /etc/resolv.conf - /etc/nsswitch.conf DNS 系統設定檔中, /etc/hosts 的作用是？最早 hostname 對應 IP 的檔案 DNS 系統設定檔中, /etc/resolv.conf 的作用是？ISP 的 DNS server IP 紀錄處 DNS 系統設定檔中, /etc/nsswitch.conf 的作用是？決定先要使用 /etc/hosts 還是 /etc/resolv.conf 以下的 dig 指令查詢結果, QUESTION 代表什麼意思？顯示所要查詢的內容，因為我們是查詢 linux.vbird.org 的 IP，所以這裡顯示 A (Address)； 上圖中的 dig 指令查詢結果, ANSWER 代表什麼意思？QUESTION 查詢得到的結果 上圖中的 dig 指令查詢結果, AUTHORITY 代表什麼意思？哪一部 DNS server 所提供答案的 上圖中的 dig 指令查詢結果, 600 代表什麼意思？查詢者能夠保留這筆記錄多久的意思 (cache) DNS 系統中, cache-only 的伺服器中只有什麼檔案？只有 . root 的 zone file DNS 系統中, cache-only 的伺服器中有主機名稱以及 IP 正反解的檔案嗎？沒有 DNS 系統中, cache-only 的伺服器當收到查詢請求時, 會怎麼做？向 . root 查詢 DNS 系統中, cache-only 實際上只有哪兩種功能？cache搜尋 DNS 系統中, forwarding 伺服器有正反解的檔案嗎?沒有 DNS 系統中, forwarding 伺服器有 . root zone 檔案嗎?沒有 DNS 系統中, forwarding 伺服器收到請求時, 如何處理嗎?委託上一層查詢 什麼時候有架設 cache-only DNS 伺服器的需求？安全性需求 當我們使用 dig 來查詢 DNS 時, 如果主機名稱是全名, 務必在結尾加上什麼？. root 符號 以下的 SOA 輸出, ns-cloud-c1.googledomains.com.代表什麼？Master DNS 伺服器主機名稱 承上的圖片中, ns-cloud-c1.googledomains.com. 代表什麼？管理員的 email 承上, ns-cloud-c1.googledomains.com. 為什麼沒有 @ 符號？因為 @ 在資料庫檔案中是有特別意義的 承上的圖片中, 21600 代表什麼？更新頻率: 每隔多久時間, slave server sync master server 一次 承上的圖片中, 3600 代表什麼？失敗重新嘗試時間: 如果 slave sync master 失敗, 則將嘗試間隔時間縮短為 3600 秒, 直到成功之後才會變更為 21600 秒 承上的圖片中, 300 代表什麼？快取時間: 資料庫內沒有指定 TTL 的紀錄, 將使用這一項預設值 承上的圖片中, 259200 代表什麼？如果失敗了, slave server 會持續每 3600 秒嘗試一次, 持續 259200 秒, 如果過了這段時間依然沒有成功, 那 slave server 將不再繼續嘗試連線 承上的圖片中, 如果持續嚐試超過 259200 slave server 會做什麼事？刪除這份 zone file, 並停止嘗試連線 以下的圖片中, 2010080369 代表什麼意思？序號, 判別是否從 master server 上下載更新 DNS 系統中, 從網域的角度來看, 越右邊出現的名稱代表網域越大或越小？越大 DNS 系統中, 從 IP, 的角度來看, 越右邊出現的名稱代表網域越大或越小？越小 # WWW ServerInternet 中, WWW 是什麼的縮寫？World Wide Web 如果我要使用瀏覽器連接到 port 21 的 ftp, 我可以怎麼做？ftp://address # 防火牆與 NAT 伺服器廣義上的防火牆定義？能夠分析與過濾進出我們管理之網域的封包資料 網路技術中, NAT 的全寫是??Network Address Translation 網路技術中, NAPT 的全寫是??Network Address Port Translation 網路技術中, NAT 是以一對一還是多對一的方式轉換私人到公開的 IP??一對一 網路技術中, NAPT 是以一對一還是多對一的方式轉換私人到公開的 IP??多對一 網路技術中, 如果 NAPT 將多個私人 IP 轉換成一個公開 IP, 當 Server 回應請求時, NAPT 是如何辨別這一個公開 IP 當初是由哪一個私人 IP 所發出的？利用埠號 網路技術中, 什麼樣的技術可以將私人 IP 轉換成公開 IP?NAT, NAPT # DevOps資訊安全中, CIA 的全寫是？- Confidentiality - Integrity - Availability 資安三大要素是？CIA Protocol 中, AH 的用途是？認證標頭是否遭到竄改或偽裝 Protocol 中, ESP 的用途是？處理加密後的資料 Protocol 中, IKE 的用途是？交換加密金鑰 Protocol 中, IKE, ESP, AH 這些協定都屬於哪一個協定？IPsec Protocol 中, AH 的全寫是？Authentication Header Protocol 中, ESP 的全寫是？Encapsulated Security Payload Protocol 中, IKE 的全寫是？Internet Key Exchange protocol Protocol 中, IPsec 的全寫是？Security Architecture for Internet Protocol Protocol 中, L2TP 的全寫是？Layer 2 Tunneling Protocol Protocol 中, PPTP 的全寫是？Point-to-Point Tunnel Protocol VPN 的全寫是？Virtual Private Network Tag based VLAN 的用途是？如果要從 A Port based VLAN 傳資料到 B port based VLAN, 勢必要在同一條網路線傳送兩個 VLAN 的資料, Tag based VLAN 會 在 frame 中加入 tag, 以區別資料來源自哪一個 VLAN Port based VLAN 的用途是？利用不同的 port 建立獨立的 VLAN VLAN 又分為哪兩種？- Port based VLAN - Tag based VLAN VLAN 全寫是？Virtual LAN, 虛擬網路 DHCP 中, 當其他的 DHCP Server 收到 Client 端的 DHCP Request, 得知該 Client 已接受某一個 DHCP Server 的租約後, 這些其他的 DHCP Server 會做什麼事？註銷原本發出的租約, 重新提供給其他 Client 使用 DHCP 的第四步？發出該租約的 Server 回傳 DHCP ACK, 並使該租約生效 DHCP 的第三步？Client 端廣播 DHCP Request, 聲明接受的租約 DHCP 中, DHCP Server 提供的租約, 內容是？- Client MAC 位址 - Server offer IP 位址 - 子網路遮罩 - 租期 - Server 本身 IP DHCP 的第二步？Server 端一對一提供 DHCP Offer, 提供租約 DHCP 的第一步？Client 端廣播 DHCP Discover, 要求 server 指派位址 路由協定中, EGP 的用途是？用於自治系統間的路由 路由協定中, IGP 的用途是？用於自治系統內的路由 路由協定中, AS 的意思是？自治系統, 相當於一個 ISP 或一個大型企業網路 路由協定中, AS 的全寫是？Autonomous System 路由協定中, OSPF, RIP/RIP2, 哪個適用於中規模以上網路？OSPF 路由協定中, OSPF, RIP/RIP2, 哪個適用於較小規模網路？RIP/RIP2 路由協定中, OSPF, RIP/RIP2 是屬於 IGP 還是 EGP？IGP 路由協定中, OSPF 的全寫是？Open Shortest Path First 路由協定中, RIP/RIP2 的全寫是？Routing Information Protocol 路由協定中, EGP 的意思是？外部路由協定 路由協定中, EGP 的全寫是？Exterior Gateway Protocol 路由協定中, IGP 的全寫是？Interior Gateway Protocol On-premise 的意思是？內部部署 DevOps 中, IaaS 的全寫是?Infrastructure as a Service DevOps 中, PaaS 的全寫是?Platform as a Service DevOps 中, Saas 的全寫是?Software as a Service 虛擬化軟體大致上又可分成哪兩種？- Bare-metal Hypervisor - Hosted Hypervisor Bare-metal Hypervisor 需要先安裝作業系統嗎？不需要 Hosted Hypervisor 需要先安裝作業系統嗎？需要 伺服器的機櫃外型又分成哪三種？- 直立式 - 機架式 - 刀鋒式 什麼是 Appliance Server?專為特定的服務或功能而製造出來的伺服器 專用伺服器 (Appliance Server) 有什麼優點？- 導入門檻低 - 價格低廉 - C/P 值高 專用伺服器 (Appliance Server) 有什麼缺點？- 無法做更細部的設定 - 無法升級部份硬體 NAS 的全寫是??Network Attached Storage 列印伺服器和一般網路印表機的差別是?- 列印伺服器可預裝各種 OS 驅動程式, 並在有需要的時候發送驅動程式 - 可處理較大量需求 伺服器中, SSO 的全寫是??Single Sign On 伺服器中, SIP 的全寫是?Session initiation Protocol 伺服器中, SMTP 的全寫是?Simple Mail Transfer Protocol 傳送郵件的第一步, 會將郵件傳送到什麼地方？傳送端的 SMTP server 當傳送方的 SMTP server 收到使用者的郵件之後, 會採取什麼動作？ 向 DNS server 查詢, 解析 @ 後方的 domain, 獲得相對應的 IP 位址 當傳送方的 SMTP server 獲得相對應的 IP 位址後, 會採取什麼動作？傳送到接收端的 SMTP server 當接收方的 SMTP server 收到郵件之後, 會採取什麼動作?會根據 @ 郵件發往屬於該使用者位於 server 的信箱, 此處的信箱不是使用者電腦上的信箱 接收方的 SMTP server 是依據什麼將收到的郵件儲存到屬於該使用者位於 server 上的信箱？依據 @ 之前的使用者名稱 負責傳送郵件的伺服器有哪兩種？- SMTP server - POP3 server SMTP 有哪兩種防護對策？- SMTP AUTH - POP BEFORE SMTP POP3 server 的全寫是？Post Office Protocol Version:3 負責將郵件從位於 Server 的 user 郵箱傳送到使用者手上的 server 稱為？POP3 server 傳送郵件的伺服器中, 哪個負責推播 (push)？SMTP server 傳送郵件的伺服器中, 哪個負責拉播 (pull)？POP3 server POP3 server 的用途為？收到使用者 pull 請求後, 從使用者位於 server 的郵箱中, 取出使用者的信件, 傳送到使用者手上 APOP 的全寫是？Authenticated Post Office Protocol POP3S 的全寫是？Post Office Protocol over SSL 通常用以處理郵件收發的 server 上, 會同時安裝哪兩種郵件相關的 server?- SMTP server - POP3 server 何謂 symmetric-key algorithm？加解密都使用同一把金鑰 對稱加密的英文是？symmetric-key algorithm 公開金鑰加密的英文是？public-key cryptography 何謂 public-key cryptography？即非對稱加密, 利用 public 以及 private key 做加解密動作 public-key cryptography 的優點是？- 優點：傳送 key 給對方簡單 public-key cryptography 的缺點是？- 缺點：運算複雜, 效能負荷大 symmetric-key algorithm 的優點是？- 優點：加解密使用單一金鑰, 效能友善 symmetric-key algorithm 的缺點是？- 缺點：傳送 key 給對方要注意 SSL 融合了哪兩種加密方法？- Symmetric-key algorithm - public-key cryptography SSL 最終使用哪一種加密方法？Symmetric-key algorithm SSL 在何處使用使用了 public-key cryptography?傳輸 symmetric key 時 SSL 中, CSR 的全寫是？Certificate Sign Request (簽證簽署請求) SSL 中, CA 的全寫是？Certificate Authority (憑證授權機構) SSL 的第一步, 當 Server 收到用戶端請求時, 會做什麼事？回傳公鑰, 以及含數位簽章的數位憑證 SSL 的第二步, 當用戶端收到 server 端的公鑰以及數位憑證之後時, 會做什麼事？會核對數位憑證, 若內容無誤, 則使用 server 公鑰加密共用金鑰的基礎資料, 並回傳 SSL 的第三步, 當 server 收到用戶端的公鑰以及共用金鑰的基礎資料後, 會做什麼事？進行解密, 並製作共用金鑰 Server 中, 何謂 CMS?Content Management System Server 中, 因應故障的技術在概念上主要分為哪兩種？- Redundancy - Backup Server 中, 將多個實體網路卡整合為邏輯上單一網路卡的技術稱為？Teaming 網卡技術中的 Teaming, 在 Linux 中又稱為？Bonding 網卡中的 Teaming 技術, 較常使用的有哪兩種模式？- 平衡負載 - 容錯 網卡中 Teaming 技術的容錯模式優點是？故障排除較簡單 網卡中 Teaming 技術的容錯模式缺點是？還是只有一張網卡在運作, 無法提高通訊量 網卡中 Teaming 技術的平衡負載模式缺點是？因為不知道封包是從哪一張網卡出入的, 故障排除難度較高 網卡中 Teaming 技術的平衡負載模式優點是？可使用兩張網卡的通訊量, 通訊量大大提高 Server 中的 UPS 全寫為?Uninterruptible Power System Server 中的 UPS 有哪兩大功能？- 忽然停電時, UPS 可以繼續供電 - 當電壓忽高忽低時, UPS 可調節電壓 伺服器平衡負載技術主要分為哪三種?- DNS route-robin (DNS 輪替式) - Server Type - Appliance Server Type 伺服器平衡負載技術中, 簡單解釋 DNS 輪替式?將一個 DNS 設定多組 IP 伺服器平衡負載技術中, 簡單解釋 Server Type?在一台 Server 上安裝平衡負載軟體, 並使用它來協調 伺服器平衡負載技術中, 簡單解釋 Appliance Server Type?使用專用型的平衡負載機器 提升安全策略中, 何謂 PDCA?- Plan - Do - Check - Action 防火牆一般來說分成哪四種？- 傳統型 - UTM - NGFW - WAF 防火牆軟體中, UTM 的全寫是？United Threat Management (整合式威脅管理系統) 防火牆軟體中, NGFW 的全寫是？Next Generation Firewall (次世代防火牆) 防火牆軟體中, WAF 的全寫是？Web Application Firewall (網頁應用程式防火牆) 以下四種防火牆, 若要阻擋 VPN, 垃圾郵件, 過濾內容, 那哪一種較為適合？- **Example**: - 傳統型 - UTM - NGFW - WAF - **Answer**: UTM 以下四種防火牆, 若要允許 Twitter, 拒絕 YouTube, 那哪一種較為適合？- **Example**: - 傳統型 - UTM - NGFW - WAF - **Answer**: NGFW 以下四種防火牆, 若要簡單的依據來源以及目的 IP, port 來阻擋, 那哪一種較為適合？- **Example**: - 傳統型 - UTM - NGFW - WAF - **Answer**: 傳統型 以下四種防火牆, 若要阻擋 CSRF, SQL injection, 那哪一種較為適合？- **Example**: - 傳統型 - UTM - NGFW - WAF - **Answer**: WAF 網路上依據信任程度大致可分為幾大分區？- trust Zone - Untrust Zone - DMZ (De-Militarized Zone) - WAN Zone (Wide Area Network Zone) Security zone 當中, DMZ 的全寫是？De-Militarized Zone Security zone 當中, WAN Zone 的全寫是？Wide Area Network Zone Security Zone 當中, trust zone 的簡單定義為？防火牆內, 不對外部網路公開 Security Zone 當中, untrust zone 的簡單定義為？防火牆外的區域 Security Zone 當中, DMZ 的簡單定義為？防火牆內, 但對外部網路公開的區域 Security zone 當中, WAN Zone 的簡單定義是？利用 VPN 等方式連接至其他據點的區域 防火牆系統中, IDS 的全寫是？Intrusion Detection System 防火牆系統中, IPS 的全寫是？Intrusion Prevention System 試描述防火牆系統中, IPS 以及 IDS 的簡單概念？會從通訊連線中偵測疑似不正常的行為, 並採取相對應的動作, 像是回報, 或是阻斷連線, 等等… 防火牆系統中, UTM 優點?多功能整合成一台, 維運較容易, 成本也較低 防火牆系統中, UTM 缺點?- 效能負荷高 - 無法針對單一功能升級 防火牆中, 專用伺服器優點?- 效能較穩定 - 可針對單一功能升級 防火牆中, 專用伺服器缺點?- 成本較高, 因為每種功能都有其 Appliance Server - 運維難度較高 Server 中, NTP 的全寫是？Network Time Protocol NTP Server 採用什麼協定？UDP NTP Server 中, stratum 的意思是？從標準時刻來源起算的網路距離 最上層 NTP Server 中, stratum 是多少？0 NTP Server 中, stratum 0, 1, 2 的 Server 之間的關係？？0 為 1 的上層 server, 1 為 2 的上層 server syslog server 的作用是？專門用來收集 Log syslog server 透過什麼協定來接受 log？syslog protocol Syslog server 整理列出 log 時, 主要會使用到 syslog 訊息內哪兩個欄位？- Facility - Severity Syslog 訊息中, Facility 代表的意思是？該筆 log 的來源類型 Syslog 訊息中, Severity 代表的意思是？緊急程度或重要程度 Server 中, SNMP 的全寫是？Simple Network Management Protocol SNMP Server 中, MIB 的全寫是？Management Information Base SNMP Server 的主要功能是？- 監控效能 - 改變設定 - 故障偵測 網際網路中, WAN 的簡單解釋？讓據點和據點之間互相連結的網路 如何辨別二進制表示法？10b, 末尾加上字母 b 目前主流的網路架構是 OSI 還是 TCP/IP？TCP/IP 子網路遮罩中, VLSM 的全寫是?Variable Length Subnet Masking (可變長度子網路遮罩) 以下 netstat 輸出的意思是是？ Example: Answer:Local Address: 代表該 process Listen 的 IP 以及 Port, 127.0.0.1 代表 loop back, 任何發送到該 IP:port 的 request 都會被同一個 IP:port 所接收, 因此只有本機可存取, 而 0.0.0.0:80 代表監聽這台機器上所有 interface 的 80 port, 所以如果在防火牆打開的情況下, 是可以從外網透過此台電腦的 public IP:80 port 來存取此 process 的Foreign address: 表示存取此 process 的來源 IP:port, 如果是 0.0.0.0:* 表示此 process 目前沒有被 connect 哦","link":"/zh-tw/LinuxForServer/"},{"title":"使用 Laravel 儲存並重新縮放圖片大小","text":"前言 本篇為實際上使用Laravel，以及套件Intervention來儲存及重新修改圖片尺寸的學習筆記。 安裝套件Intervention安裝流程請參照 Intervention GitHub官網 composer require intervention/image 打開config/app.php, 在array $providers 裏頭加上Intervention\\Image\\ImageServiceProvider::class 在array aliases裏頭加上&#x27;Image&#x27; =&gt; Intervention\\Image\\Facades\\Image::class 建立上傳資料夾與storage資料夾的連結 依照官網說明建立連結 在terminal輸入 php artisan storage:link 連結之後，project/storage/app/public 會跟 project/public/storage這兩個資料夾就回相連。 如果你是要儲存檔案，請儲存到project/storage/app/public/(anySubdirectoryYouWant) 如果你是要提供外部存取的URL，請使用project/public/storage/(anySubdirectoryYouWant)/fileName，因為對外部來說，預設可存取資料夾為public，所以直接使用asset(&#39;storage/(anySubdirectoryYouWant/fileName)&#39;) 驗證圖片是否有被帶進來// 因為我們不需要太多的東西，只需要request array裡頭的東西$parameters = request()-&gt;all();if (request()-&gt;hasFile(&#x27;image&#x27;))&#123; // 檔案存在，所以存到project/storage/app/public，並拿到url，此範例會拿到public/fileName $imageURL = request()-&gt;file(&#x27;image&#x27;)-&gt;store(&#x27;public&#x27;); // 因為我們只想要將純粹的檔名存到資料庫，所以特別做處理 $parameters[&#x27;image&#x27;] = substr($imageURL, 7);&#125; 重新縮放圖片大小 要縮放大小，所以會需要使用到套件intervention 在namespace下加上use Intervention\\Image\\ImageManagerStatic as Image; // 拿到剛剛存進DB的item實例$item = Item::update($parameters);// 設定driverImage::configure(array(&#x27;driver&#x27; =&gt; &#x27;gd&#x27;));// 如果我們dd (storage_phth)，我們將會得到&#x27;project/storage/&#x27;，但這不是我們要的// 所以我們在後面加上&#x27;app/public/，如上所敘，這是內部儲存的資料夾位址// 請注意，當我們重新縮放圖片大小，目標都是我們的內部資料夾// 並且，再重新縮放之後，也是要存到同樣的地方Image::make(storage_path(&#x27;app/public/&#x27; . $item-&gt;image))-&gt;resize(300, 300)-&gt;save(storage_path(&#x27;app/public/&#x27; . $item-&gt;image)); 刪除圖片(如果使用者要求)if ($request-&gt;imageDelete == true)&#123; Storage::delete($item-&gt;images); $item-&gt;update([&#x27;images&#x27; =&gt; null]);&#125; 產出可存取資源的URL// 當產出公開存取的URL，它必須要是外部存取位址return asset(&#x27;storage/&#x27; . $parameters[&#x27;image&#x27;]);","link":"/zh-tw/UploadAndResizeImagesWithLaravel/"},{"title":"Stackdriver 快速開始","text":"概述本篇實作將告訴你如何利用Stackdriver來監看Google Compute Engine virtual machine instance，你也將安裝監看以及紀錄的服務在你的VM上，他們可以從你的instance上收集更多的資訊 前言本篇主要是利用Google的Qwiklab平台學習的同時，做的一份學習筆記, 一些專有名詞將不會被翻譯 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個Compute Engine Instance 在GCP主控台的控制面板， Navigation menu &gt; Compute Engine &gt; VM instance，然後點擊 Create￼ 照下面的資訊填入相對應的空格，無提到的空格內請保持預設值 Name: lamp-1-vm Region: `us-central1 (Iowa)`` Zone: us-central1-a Machine type: small (1 shared vCPU) Firewall: Select Allow HTTP traffic 點擊Create 安裝Apache2 Server 在主控台，點擊SSH來開啟一個連接此instance的terminal 在SSH視窗中，執行下面的指令來設定Apache2 sudo apt-get update sudo apt-get install apache2 php7.0 當詢問是否繼續y 如果你無法安裝php7.0，裝php5 sudo service apache2 restart 回到主控台，在VM instance的頁面，點選External IP處以連接到Apache2預設頁面 建立 Stackdriver 帳號 要使用 Stackdriver ，你的專案必須要在一個 Stackdriver 帳號內，接下的步驟將建立一個有試用期的 Stackdriver 帳號 (1) 在GCP主控台，點擊 Navigation menu &gt; Monitoring - 這將在一個新視窗開啟 Stackdriver，並顯示你的 Qwiklabs 專案。 點擊 Create workspace ![](https://i.imgur.com/0wwazU5.png) (2) 在接下來的頁面: - 加入 GCP 專案到 monitor ，你將看到你的專案顯示已勾選 ![](https://i.imgur.com/97vi3ch.png) - 點擊 Continue - 監看 AWS 帳號 - 略過設定 - 安裝 Stackdriver 監看代理 curl -sSO https://dl.google.com/cloudagents/install-monitoring-agent.sh sudo bash install-monitoring-agent.sh 安裝 Stachdriver 記錄代理 curl -sSO https://dl.google.com/cloudagents/install-logging-agent.sh sudo bash install-logging-agent.sh 點擊 Continue 點擊 Launch monitoring 建立運行時間確認 Uptime check 用以確認資源總是可以被存取，在此範例中，我們將建立一個 uptime check 來確認 Google 網頁正常運行中 - 在 Stackdriver console 主控台，在控制面板上，點擊 Create an Uptime Check 按鈕。你也可以從左邊到 menu 中，找到 Uptime Checks > Uptime Checks Overview ，然後點擊 Create an Uptime Check 編輯 New Uptime Check ，加入以下資訊 Title: Lamp Uptime Check Check type: HTTP Resource Type: Instacne Applies to: Single, lamp-1-vm Path: leave at default Check every: 1 min 如果 instance 沒有自動載入在我們寫則 \"single\" 之後，取消這次的 uptime check ，重新整理 Stackdriver 頁面，然後重新試一遍 點擊 Test 來確認我們的 uptime check 可以連結到資源 點擊 save ，當顯示所有的資源都已經可以連接 點擊 No thanks 來為這個 uptime check 建立一個警告政策 Uptime Check 的設置將會需要一些時間生效，我們繼續我們的進度，等等我們再來確認結果。讓我們先來建立一個警告政策。 建立一個警告政策 利用 Stackdriver 來建立一個或多個的 alerting policies. 從左邊的選單，點擊 Alerting > Create a Policy ，然後設置 Conditions, Notifications, and Documentation 條件： 點擊 Add Condition 依照下面的資訊來設置空格處，如果沒有提到，請保留為默認值 Target: Resource Type: GCE VM Instance (gce_instance)Metric: Type &quot;network&quot; then select Network traffic ConfigurationCondition: is aboveThreshold: 500 bytesFor: 1 minute 點擊 Save Notifications: 選擇 Email Address ，然後輸入你的個人信箱地址 Documentation: 點擊 Add Documentation 然後新增一個訊息，這個訊息將會被包含在郵件警告中 Name this policy: Inbound Traffic Alert 點擊 save 我們已經建立一個警告了！ 在等待系統觸發警告的同時，建立一個控制面板和圖表，然後看一下紀錄 建立控制面板和圖表 左邊選單， Dashboards &gt; Create Dashboard 螢幕右上方，點擊 Add Chart 在 Find resource type and metric 區域，輸入 CPU ，然後選擇 CPU Load(1m). GCE VM instance 根據資源類型自動被選擇，圖表名稱自動命名，但如果你想要的話，你可以自訂命名 點擊 save 現在建立第二個圖表 在新的控制面板右上方的選單，選擇 Add Chart Find resource type and metric 欄位內輸入 Network ，選擇 Received Packets ，其餘欄位保持預設值，你可以在預覽區域看到圖表資料 點擊 save 重新命名新的控制面板，從 Untitled Dashboard 改成 Stackdriver LAMP Qwik Start Dashboard 檢視紀錄 Stackdriver Monitoring 和 Stackdriver Logging 緊密地互相整合著 在Stackdriver 左手邊選單，點擊 Logging 來檢視紀錄 選擇 GCE VM instance &gt; lamp-1-vm 在第一個下拉選單 從第二個下拉選單選擇 syslog，然後點擊OK 其餘欄位保留預設 選擇 Start streaming logs 圖案 可以看到這個 VM instance 的 logs 現在來看看，當我們開始跟結束時，會發生什麼事 點擊並拖曳 Logs Viewer brower 視窗，所以 Compute Engine console 和 Stackdriver Logging console 會並排 在主控台內，VM instance 視窗，點擊 lamp-1-vm instance 在 VM instance details 視窗，於螢幕上方點擊 Stop，然後確認停止 instance ，這會需要幾分鐘，我們來看 log messages 我們可以看著 Logs View 視窗，然後看VM什麼時候被結束 在 VM instance detail 視窗，在螢幕最上方點擊 Start，然後確認。這會需要幾分鐘的時間，我們可以檢視 log 訊息 確認 uptime check 結果以及警告觸發 在 Stackdriver 左邊區域，點擊 Uptime Checks &gt; Lamp Uptime Check 。這將顯示 uptime check 的細節，包含等待時間， uptime 百分比，區域結果以及設定檢查。如果你看到的 Location result 是 “No checks have run yet” ，那請等待幾分鐘，然後重新整理頁面 左方區域點擊 Uptime Checks &gt; Uptime Checks Overview ，這將提供所有運行中的 uptime checks ，包含網站在不同區域的狀態 確認警報是否有觸發 在 StackDriver 主控台，左方頁面點擊 Alerting &gt; Incidents ，如果你沒有看到開啟的事件，請確定一下你在看的是 RESOLVED 頁面 依然在 Stackdriver 主控台，點擊 Alerting &gt; Events ，你應該會看到一個事件列表 確認一下我們的 email 帳號，應該會收到警報 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： Stackdriver supports which of the following cloud platforms / Stackdriver 支援以下哪種雲端平台? Google Cloud Platform Azure Amazon Web Services","link":"/zh-tw/Stackdriver/"},{"title":"架設一個 NFS Server","text":"# 前言本篇主要紀錄如何架設一個 NFS server, 並從其他 node 共享檔案 # 環境VERSION=”19.10 (Eoan Ermine)”ID=ubuntuID_LIKE=debianPRETTY_NAME=”Ubuntu 19.10”VERSION_ID=”19.10” # 安裝假如你的 apt 無法更新, 執行 sed -i -e &#x27;s/archive.ubuntu.com\\|security.ubuntu.com/old-releases.ubuntu.com/g&#x27; /etc/apt/sources.list # Hostsudo apt update &amp;&amp; sudo apt install nfs-kernel-server # Clientsudo apt update &amp;&amp; sudo apt install nfs-common # 建立分享資料夾sudo mkdir -p /yourPreferred/directoryLocation NFS server 預設會將 root 登入者轉為 nobody:nogroup, 因此修改資料夾權限 sudo chown nobody:nogroup /yourPreferred/directoryLocation # exports 設定檔 設定 exports 檔案, 定義要 export 的資料夾以及細項設定 sudo vim /etc/exports 設定檔 /yourPrederred/directoryLocation *(rw,sync,no_root_squash) 一些設定參數定義 參數 用途 rw &amp; ro 該目錄分享的權限是可讀寫 (read-write) 但最終能不能讀寫，還是與檔案系統的 rwx 及身份有關。 sync &amp; async sync 代表資料會同步寫入到記憶體與硬碟中，async 則代表資料會先暫存於記憶體當中，而非直接寫入硬碟。 sync 會增加穩定性以及一致性, 因為返回的結果就代表遠端 disk 的狀態, 而非 cache, 但同時速度也會比較慢 no_root_squash 預設 NFS 會將來自於 root user 的 request 轉換成 nobody, 以避免 client root 擁有 host root 的權限, 若要取消預設行為, 可使用此選項 root_squash 如上, 預設行為 all_squash 不管訪問者是誰, 全部都轉換成 nobody anonuid &amp; anongid 可以自定義上面提到的 nobody, nogroup 的 uid 以及 gid, 前提是此 uid &amp; gid 必須要存在於 /etc/passwd fsid 在 NFS4, 若設為 0, 則代表 root, 表示分享的資料夾為該 host 的 root, 即 client 端掛載時需為 mount -t nfs hostIp:/ /clientTargetMountingDirectory, 若分享多個資料夾, fsid 不可相同, 每個 fsid 都代表一個獨立的分享區塊 完成設定後, 重啟 serversudo systemctl restart nfs-kernel-server # 防火牆設定# 查看防火牆狀態sudo ufw status 一般來說, 防火牆越嚴謹越好, 但我們需要開啟特定的 port 讓外部可以存取 NFS server # 開啟防火牆 請將 client_ip 替換成實際的 client ip sudo ufw allow from client_ip to any port nfs 查看結果 sudo ufw status # 掛載到 client 端# 確認 nfs-common 有啟動 如果 nfs-common 服務沒啟動的話, 啟動它 sudo systemctl start nfs-common 如果顯示 masked, 使用 unmask 又無效的話, 先刪除 service sudo rm /lib/systemd/system/nfs-config.service 刪除後在 reload daemon sudo systemctl daemon-reload 然後再 start nfs-common 一次 # 建立空資料夾 建立一個空的資料夾sudo mkdir -p /yourPrefered/emptyDirectoryLocation # 掛載sudo mount -t nfs4 yourHostIp:/ /yourPrefered/emptyDirectoryLocation 這邊要注意一下, 如果使用的是 nfs4, 那 fsid = 0 實際上就代表 root, 即根目錄實際上就是 host exports 出來的資料夾, 所以要使用 yourHostIp:/, 而實際上是掛載到上面在 Host 端建立的資料夾 # 卸載umount /yourClientMountedDirectory 需注意, 如果你當前位置正在掛載的資料夾, 那會顯示 target is busy, 所以要先離開啦！ # 結語至此簡易的 NFS 就完成掛載囉, 更多的設定可以參考文末的參考來源。 # 參考資源 鳥哥 DigitalOcean Internet","link":"/zh-tw/build-a-nfs-server/"},{"title":"用 NGINX 配置一個 WebDAV Server","text":"前言 用 NGINX 配置一個 WebDAV Server 使用者可透過帳號密碼登入存取指定資料夾 環境GCP InstanceUbuntu 18.04NGINXRoot 安裝apt-get install nginx-full 開啟 gzip頻寬有限, 機器速度較快, 開啟 gzip 讓 server 回覆的資料都先經過壓縮, 減少經由網路傳送的資料大小 sed -i &#x27;/gzip_/ s/#\\ //g&#x27; /etc/nginx/nginx.conf /gzip_/: 尋找含有 /gzip_/ 的行數s/#\\ //g: 將 # 替換成 空白 意思就是 uncomment 掉 gzip 啦 配置 WebDAV Server建立檔案 vim /etc/nginx/conf.d/webdav.conf 配置檔案 server &#123; listen 80; listen [::]:80; server_name yourDomain; # 使用者認證 auth_basic realm_name; # 使用者身份檔案位置 auth_basic_user_file /etc/nginx/.passwords.list; # dav 允許的使用方法 dav_methods PUT DELETE MKCOL COPY MOVE; # 在目前的範圍內啟動支持特定的 WebDAV 方法, PROPFIND 可參考 https://docs.oracle.com/cd/E19857-01/819-0824/agdav.html dav_ext_methods PROPFIND OPTIONS; # 在此資料夾內, 新建的文件以及資料夾的權限, 若無特別設定, 預設為 user:rw。 若以指定 all 及 group 權限, 則 user 可忽略 dav_access user:rw group:rw all:r; # 臨時中轉目錄 client_body_temp_path /tmp/nginx/client-bodies; # 上傳檔案最大限制, 0 為不限制 client_max_body_size 0; # 允許在現有目錄中增加檔案時, 如果指定的資料夾不存在, 自動創建 create_full_put_path on;&#125; 建立使用者 輸入 userecho -n &#x27;userName:&#x27; | sudo tee -a /etc/nginx/.passwords.list; 印出使用者名稱, tee 會將使用者名稱印在螢幕上以及導入 /etc/nginx/.passwords.list 檔案, -a = append 輸入密碼openssl passwd -apr1 | sudo tee -a /etc/nginx/.passwords.list; 使用 openssl passwd 的 -apr1 規則來將密碼明文變成密文, tee 印出加密後密碼以及導入 /etc/nginx/.passwords.list 檔案, -a = append 大功告成！","link":"/zh-tw/buildAWebDavServerWithNginx/"},{"title":"Linux 基礎篇 - 學習筆記","text":"前言這是一份未整理過的 Linux 學習筆記OS 系統為 GCP 上的 Linux 18.04 LTS內容參考出處： 鳥哥的 Linux 的私房菜 Internet find搜尋屬於特定 user 或 group 的檔案find localtion -type f -user userName -group groupName -name fileName 搜尋屬於特定 user 或 group 的資料夾find localtion -type d -user userName -group groupName -name fileName 搜尋 $分鐘內的檔案或資料夾, 只搜尋當層find ./* -maxdepth 0 -type f -cmin -20 ps 列出系統正在執行的 process, 並且從中搜尋關鍵字ps -ef | node kill語法[root@study ~]# kill -signal %jobnumber[root@study ~]# kill -l選項與參數：-l ：這個是 L 的小寫，列出目前 kill 能夠使用的訊號 (signal) 有哪些？signal ：代表給予後面接的那個工作什麼樣的指示囉！用 man 7 signal 可知： -1 ：重新讀取一次參數的配置文件 (類似 reload)； -2 ：代表與由鍵盤輸入 [ctrl]-c 同樣的動作； -9 ：立刻強制刪除一個工作； -15：以正常的程序方式終止一項工作。與 -9 是不一樣的。 代號 | 名稱 | 內容—-|—–|1 | SIGHUP | 啟動被終止的程序，可讓該 PID 重新讀取自己的配置文件，類似重新啟動2 | SIGINT | 相當於用鍵盤輸入 [ctrl]-c 來中斷一個程序的進行9 | SIGKILL | 代表強制中斷一個程序的進行，如果該程序進行到一半， 那麼尚未完成的部分可能會有“半產品”產生，類似 vim會有 .filename.swp 保留下來。15 | SIGTERM | 以正常的結束程序來終止該程序。由於是正常的終止， 所以後續的動作會將他完成。不過，如果該程序已經發生問題，就是無法使用正常的方法終止時， 輸入這個 signal 也是沒有用的。19 | SIGSTOP | 相當於用鍵盤輸入 [ctrl]-z 來暫停一個程序的進行 指令 立刻強制刪除一個工作kill -9 processID killall語法[root@study ~]# killall [-iIe] [command name]選項與參數：-i ：interactive 的意思，互動式的，若需要刪除時，會出現提示字符給使用者；-e ：exact 的意思，表示“後面接的 command name 要一致”，但整個完整的指令 不能超過 15 個字符。-I ：指令名稱(可能含參數)忽略大小寫。 ln 建立一個捷徑ln -s sourceAbsoluteLink targetAbsoluteLink du 查檔案大小du -sh fileOrFolder df 查硬碟空間使用率df -h [[]] 回傳 true or false[[ -f /.dockerenv ]] [[]] 會將裡頭的參數結果回傳 true or false-f 表示 file exists所以意思是，如果 /.dockerenv 存在，則回傳 true grep 搜尋內容並顯示附近的行數從 gcloud command 中取得資料，並且顯示 ssh-keys 後面的 5 行gcloud compute project-info describe | grep -A 5 ssh-keys groupdel 刪除 groupgroupdel groupName userdel 刪除 useruserdel userName useradduseradd [-u UID] [-g 初始群組] [-G 次要群組] [-mM]\\&gt; [-c 說明欄] [-d 主文件夾絕對路徑] [-s shell] 使用者帳號名選項與參數：-u ：後面接的是 UID ，是一組數字。直接指定一個特定的 UID 給這個帳號；-g ：後面接的那個群組名稱就是我們上面提到的 initial group 啦～ 該群組的 GID 會被放置到 /etc/passwd 的第四個字段內。-G ：後面接的群組名稱則是這個帳號還可以加入的群組。 這個選項與參數會修改 /etc/group 內的相關數據喔！-M ：強制！不要創建使用者主文件夾！(系統帳號默認值)-m ：強制！要創建使用者主文件夾！(一般帳號默認值)-c ：這個就是 /etc/passwd 的第五欄的說明內容啦～可以隨便我們設置的啦～-d ：指定某個目錄成為主文件夾，而不要使用默認值。務必使用絕對路徑！-r ：創建一個系統的帳號，這個帳號的 UID 會有限制 (參考 /etc/login.defs)-s ：後面接一個 shell ，若沒有指定則默認是 /bin/bash 的啦～-e ：後面接一個日期，格式為“YYYY-MM-DD”此項目可寫入 shadow 第八字段， 亦即帳號失效日的設置項目囉；-f ：後面接 shadow 的第七字段項目，指定密碼是否會失效。0為立刻失效， -1 為永遠不失效(密碼只會過期而強制於登陸時重新設置而已。) 完全參考默認值創建一個使用者，名稱為 Ray useradd Ray 建立一個 user, 並加到指定 group useradd -G groupName userName useradd 之後，系統會幫我們做哪些事？ 在 /etc/passwd 裡面創建一行與帳號相關的數據，包括創建 UID/GID/主文件夾等； 在 /etc/shadow 裡面將此帳號的密碼相關參數填入，但是尚未有密碼； 在 /etc/group 裡面加入一個與帳號名稱一模一樣的群組名稱； 在 /home 下面創建一個與帳號同名的目錄作為使用者主文件夾，且權限為 700 useradd 參考檔 這個數據其實是由 /etc/default/useradd 調用出來的 useradd -DGROUP=100 &lt;==默認的群組HOME=/home &lt;==默認的主文件夾所在目錄INACTIVE=-1 &lt;==密碼失效日，在 shadow 內的第 7 欄EXPIRE= &lt;==帳號失效日，在 shadow 內的第 8 欄SHELL=/bin/bash &lt;==默認的 shellSKEL=/etc/skel &lt;==使用者主文件夾的內容數據參考目錄CREATE_MAIL_SPOOL=yes &lt;==是否主動幫使用者創建郵件信箱(mailbox) GROUP=100：新建帳號的初始群組使用 GID 為 100 者系統上面 GID 為 100 者即是 users 這個群組，此設置項目指的就是讓新設使用者帳號的初始群組為 users 這一個的意思。 但是我們知道 CentOS 上面並不是這樣的，在 CentOS 上面默認的群組為與帳號名相同的群組。 舉例來說， vbird1 的初始群組為 vbird1 。怎麼會這樣啊？這是因為針對群組的角度有兩種不同的機制所致， 這兩種機制分別是： 私有群組機制：系統會創建一個與帳號一樣的群組給使用者作為初始群組。 這種群組的設置機制會比較有保密性，這是因為使用者都有自己的群組，而且主文件夾權限將會設置為 700 (僅有自己可進入自己的主文件夾) 之故。使用這種機制將不會參考 GROUP=100 這個設置值。代表性的 distributions 有 RHEL, Fedora, CentOS 等； 公共群組機制：就是以 GROUP=100 這個設置值作為新建帳號的初始群組，因此每個帳號都屬於 users 這個群組， 且默認主文件夾通常的權限會是“ drwxr-xr-x … username users … ”，由於每個帳號都屬於 users 群組，因此大家都可以互相分享主文件夾內的數據之故。代表 distributions 如 SuSE等。由於我們的 CentOS 使用私有群組機制，因此這個設置項目是不會生效的！不要太緊張啊！ HOME=/home：使用者主文件夾的基準目錄(basedir)使用者的主文件夾通常是與帳號同名的目錄，這個目錄將會擺放在此設置值的目錄後。所以 vbird1 的主文件夾就會在 /home/vbird1/ 了！很容易理解吧！ INACTIVE=-1：密碼過期後是否會失效的設置值我們在 shadow 文件結構當中談過，第七個字段的設置值將會影響到密碼過期後， 在多久時間內還可使用舊密碼登陸。這個項目就是在指定該日數啦！如果是 0 代表密碼過期立刻失效， 如果是 -1 則是代表密碼永遠不會失效，如果是數字，如 30 ，則代表過期 30 天后才失效。 EXPIRE=：帳號失效的日期就是 shadow 內的第八字段，你可以直接設置帳號在哪個日期後就直接失效，而不理會密碼的問題。 通常不會設置此項目，但如果是付費的會員制系統，或許這個字段可以設置喔！ SHELL=/bin/bash：默認使用的 shell 程序文件名系統默認的 shell 就寫在這裡。假如你的系統為 mail server ，你希望每個帳號都只能使用 email 的收發信件功能， 而不許使用者登陸系統取得 shell ，那麼可以將這裡設置為 /sbin/nologin ，如此一來，新建的使用者默認就無法登陸！ 也免去後續使用 usermod 進行修改的手續！ SKEL=/etc/skel：使用者主文件夾參考基準目錄這個咚咚就是指定使用者主文件夾的參考基準目錄囉～舉我們的範例一為例， vbird1 主文件夾 /home/vbird1 內的各項數據，都是由 /etc/skel 所複製過去的～所以呢，未來如果我想要讓新增使用者時，該使用者的環境變量 ~/.bashrc 就設置妥當的話，您可以到 /etc/skel/.bashrc 去編輯一下，也可以創建 /etc/skel/www 這個目錄，那麼未來新增使用者後，在他的主文件夾下就會有 www 那個目錄了！這樣瞭呼？ CREATE_MAIL_SPOOL=yes：創建使用者的 mailbox你可以使用“ ll /var/spool/mail/vbird1 ”看一下，會發現有這個文件的存在喔！這就是使用者的郵件信箱！ UID/GID 還有密碼參數 路徑 /etc/login.defsMAIL_DIR /var/spool/mail &lt;==使用者默認郵件信箱放置目錄 PASS_MAX_DAYS 99999 &lt;==/etc/shadow 內的第 5 欄，多久需變更密碼日數PASS_MIN_DAYS 0 &lt;==/etc/shadow 內的第 4 欄，多久不可重新設置密碼日數PASS_MIN_LEN 5 &lt;==密碼最短的字符長度，已被 pam 模塊取代，失去效用！PASS_WARN_AGE 7 &lt;==/etc/shadow 內的第 6 欄，過期前會警告的日數UID_MIN 1000 &lt;==使用者最小的 UID，意即小於 1000 的 UID 為系統保留UID_MAX 60000 &lt;==使用者能夠用的最大 UIDSYS_UID_MIN 201 &lt;==保留給使用者自行設置的系統帳號最小值 UIDSYS_UID_MAX 999 &lt;==保留給使用者自行設置的系統帳號最大值 UIDGID_MIN 1000 &lt;==使用者自訂群組的最小 GID，小於 1000 為系統保留GID_MAX 60000 &lt;==使用者自訂群組的最大 GIDSYS_GID_MIN 201 &lt;==保留給使用者自行設置的系統帳號最小值 GIDSYS_GID_MAX 999 &lt;==保留給使用者自行設置的系統帳號最大值 GIDCREATE_HOME yes &lt;==在不加 -M 及 -m 時，是否主動創建使用者主文件夾？UMASK 077 &lt;==使用者主文件夾創建的 umask ，因此權限會是 700USERGROUPS_ENAB yes &lt;==使用 userdel 刪除時，是否會刪除初始群組ENCRYPT_METHOD SHA512 &lt;==密碼加密的機制使用的是 sha512 這一個機制！ mailbox 所在目錄：使用者的默認 mailbox 文件放置的目錄在 /var/spool/mail，所以 vbird1 的 mailbox 就是在 /var/spool/mail/vbird1 囉！ shadow 密碼第 4, 5, 6 字段內容：通過 PASS_MAX_DAYS 等等設置值來指定的！所以你知道為何默認的 /etc/shadow 內每一行都會有“ 0:99999:7 ”的存在了嗎？^_^！不過要注意的是，由於目前我們登陸時改用 PAM 模塊來進行密碼檢驗，所以那個 PASS_MIN_LEN 是失效的！ UID/GID 指定數值：雖然 Linux 核心支持的帳號可高達 232 這麼多個，不過一部主機要作出這麼多帳號在管理上也是很麻煩的！ 所以在這裡就針對 UID/GID 的範圍進行規範就是了。上表中的 UID_MIN 指的就是可登陸系統的一般帳號的最小 UID ，至於 UID_MAX 則是最大 UID 之意。 要注意的是，系統給予一個帳號 UID 時，他是 (1)先參考 UID_MIN 設置值取得最小數值； (2)由 /etc/passwd 搜尋最大的 UID 數值， 將 (1) 與 (2) 相比，找出最大的那個再加一就是新帳號的 UID 了。我們上面已經作出 UID 為 1500 的 vbird2 ， 如果再使用“ useradd vbird4 ”時，你猜 vbird4 的 UID 會是多少？答案是： 1501 。 所以中間的 1004~1499 的號碼就空下來啦！ 而如果我是想要創建系統用的帳號，所以使用 useradd -r sysaccount 這個 -r 的選項時，就會找“比 201 大但比 1000 小的最大的 UID ”就是了。 ^_^ 使用者主文件夾設置值：為何我們系統默認會幫使用者創建主文件夾？就是這個“CREATE_HOME = yes”的設置值啦！這個設置值會讓你在使用 useradd 時， 主動加入“ -m ”這個產生主文件夾的選項啊！如果不想要創建使用者主文件夾，就只能強制加上“ -M ”的選項在 useradd 指令執行時啦！至於創建主文件夾的權限設置呢？就通過 umask 這個設置值啊！因為是 077 的默認設置，因此使用者主文件夾默認權限才會是“ drwx—— ”哩！ 使用者刪除與密碼設置值：使用“USERGROUPS_ENAB yes”這個設置值的功能是： 如果使用 userdel 去刪除一個帳號時，且該帳號所屬的初始群組已經沒有人隸屬於該群組了， 那麼就刪除掉該群組，舉例來說，我們剛剛有創建 vbird4 這個帳號，他會主動創建 vbird4 這個群組。 若 vbird4 這個群組並沒有其他帳號將他加入支持的情況下，若使用 userdel vbird4 時，該群組也會被刪除的意思。 至於“ENCRYPT_METHOD SHA512”則表示使用 SHA512 來加密密碼明文，而不使用舊式的 MD5。現在你知道啦，使用 useradd 這支程序在創建 Linux 上的帳號時，至少會參考： /etc/default/useradd/etc/login.defs/etc/skel/* usermodusermod [-cdegGlsuLU] username選項與參數：-c ：後面接帳號的說明，即 /etc/passwd 第五欄的說明欄，可以加入一些帳號的說明。-d ：後面接帳號的主文件夾，即修改 /etc/passwd 的第六欄；-e ：後面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 內的第八個字段數據啦！-f ：後面接天數，為 shadow 的第七字段。-g ：後面接初始群組，修改 /etc/passwd 的第四個字段，亦即是 GID 的字段！-G ：後面接次要群組，修改這個使用者能夠支持的群組，修改的是 /etc/group 囉～-a ：與 -G 合用，可“增加次要群組的支持”而非“設置”喔！-l ：後面接帳號名稱。亦即是修改帳號名稱， /etc/passwd 的第一欄！-s ：後面接 Shell 的實際文件，例如 /bin/bash 或 /bin/csh 等等。-u ：後面接 UID 數字啦！即 /etc/passwd 第三欄的數據；-L ：暫時將使用者的密碼凍結，讓他無法登陸。其實僅改 /etc/shadow 的密碼欄。-U ：將 /etc/shadow 密碼欄的 ! 拿掉，解凍啦！ 增加指定 user 的次要群組usermod -a -G groupName userName chmod 給予一個資料夾 SGID 屬性chmod 2777 folderName passwdpasswd [--stdin] [帳號名稱] &lt;==所有人均可使用來改自己的密碼[root@study ~]# passwd [-l] [-u] [--stdin] [-S] \\&gt; [-n 日數] [-x 日數] [-w 日數] [-i 日期] 帳號 &lt;==root 功能選項與參數：--stdin ：可以通過來自前一個管線的數據，作為密碼輸入，對 shell script 有幫助！-l ：是 Lock 的意思，會將 /etc/shadow 第二欄最前面加上 ! 使密碼失效；-u ：與 -l 相對，是 Unlock 的意思！-S ：列出密碼相關參數，亦即 shadow 文件內的大部分信息。-n ：後面接天數，shadow 的第 4 字段，多久不可修改密碼天數-x ：後面接天數，shadow 的第 5 字段，多久內必須要更動密碼-w ：後面接天數，shadow 的第 6 字段，密碼過期前的警告天數-i ：後面接“日期”，shadow 的第 7 字段，密碼失效日期 確認 OS 種類以及版本 使用 lsb_release ， 如果沒安裝的話，安裝它 sudo apt-get install lsb-release 查詢用法 lsb_release --help 輸出如下： -h, --help show this help message and exit-v, --version show LSB modules this system supports-i, --id show distributor ID-d, --description show description of this distribution-r, --release show release number of this distribution-c, --codename show code name of this distribution-a, --all show all of the above information-s, --short show requested information in short format 根據上面的資訊，想查詢明細的話 lsb_release -a curl語法curl [options] [URL...]-X 代表 request 的方式-H 代表 header-d 代表傳送資料，等同於以 `Content-Type: application/x-www-form-urlencoded` 方式傳送-k 若經由 `https` 發請求，加上 -k 可避開 HTTPS 方式-v 代表 `verbose` , 若要顯示回覆訊息，需加上 `-v`-L 如果 server 端回報位置已轉址, curl 會對新的位址在發請求-T 上傳檔案-s slient 模式 範例假設請求如下： curl -X POST \\ https://requestedURL \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;&#123;&quot;dataA&quot;:&quot;content of data A&quot;,&quot;dataB&quot;:&quot;content of data B&quot;&#125;&#x27; -k -v -X 代表 request 的方式 ip 請由此查詢 -H 代表 header -d 代表傳送資料，等同於以 Content-Type: application/x-www-form-urlencoded 方式傳送 -k 若經由 https 發請求，需加上 -k -v 代表 verbose , 若要顯示回覆訊息，需加上 -v bash 環境配置文件bash 會根據有沒有登入來讀取相對應的環境配置文件 login shell /etc/profile /etc/profile.d/*.sh 被調用的條件如下： 在 /etc/profile.d/ 這個目錄內 擴展名為 .sh 使用者能夠具有 r 的權限 ~/.bash_profile or ~/.bash_login or ~/.profile (照順序讀，只會讀其中一個) ~/.bashrc (最終會讀取這一個文件) non-login shell ~/.bashrc etc/bashrc (會調用此文件) 流程圖 不小心刪除了 ~/.bashrc, 或是沒有這個文件，想創建怎麼辦？ 複製預設文件 cp /etc/skel/.bashrc ~/ 視需求修改 使立即生效 source ~/.bashrc or . ~/.bashrc Base 64 decodebase64 --decode /tmp/encoded.txt &gt; /tmp/decoded.txt ncftpncftpput -u account -p password -P port -m -R ipOrDomain remoteLocation locationFileOrDirectory -u：指定登錄FTP服務器時使用的用戶名； -p：指定登錄FTP服務器時使用的密碼； -P：如果FTP服務器沒有使用默認的TCP協議的21端口，則使用此選項指定FTP服務器的端口號。 -m：在傳之前嘗試在目錄位置創建目錄(用於傳目錄的情況) -R：遞規傳子目錄 ufw 啟用防火牆服務 ufw enable 關閉防火牆服務 ufw disable 打開指定 port ufw allow port/tcp install 使用 install 指令，我們可以在創立一個 folder 或 file 的同時，指定 owner, group 以及 mode install -d -o &lt;user&gt; -g &lt;group&gt; -m &lt;mode&gt; &lt;path&gt; -d : directory -o : owner -g : group -m : mode 建立一個資料夾，並給予權限 install -d -o ray -g ray -m 2770 /tmp/ray 建立一個檔案，並給予權限 install -m 777 -o ray -g ray /dev/null filename.txt yumwhatprovides 找出有提供特定 command 的 packageyum whatprovides */commandYouAreLookingFor install 安裝特定的 packageyum insatll packageName regular expression (regex) (正則表達式)特殊符號表 特殊符號 代表意義 [:alnum:] 代表英文大小寫字符及數字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小寫字符，亦即 A-Z, a-z [:blank:] 代表空白鍵與 [Tab] 按鍵兩者 [:cntrl:] 代表鍵盤上面的控制按鍵，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表數字而已，亦即 0-9 [:graph:] 除了空白字符 (空白鍵與 [Tab] 按鍵) 外的其他所有按鍵 [:lower:] 代表小寫字符，亦即 a-z [:print:] 代表任何可以被打印出來的字符 [:punct:] 代表標點符號 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大寫字符，亦即 A-Z [:space:] 任何會產生空白的字符，包括空白鍵, [Tab], CR 等等 [:xdigit:] 代表 16 進位的數字類型，因此包括： 0-9, A-F, a-f 的數字與字符 表達式彙整 字元 描述 \\ 將下一個字元標記為一個特殊字元(File Format Escape，見本表)、或一個原義字元(Identity Escape，有 ^ $ ( ) * + ? . [ \\ { &#124; 共計12個)、或一個向後參照(backreferences)、或一個八進位跳脫符。例如，「n」匹配字元「n」。「\\n」匹配一個換行符。序列「\\」匹配「\\」而「(」則匹配「(」。 ^ 匹配輸入字串的開始位置。如果設定了RegExp物件的Multiline屬性，^也匹配「\\n」或「\\r」之後的位置。 $ 匹配輸入字串的結束位置。如果設定了RegExp物件的Multiline屬性，$也匹配「\\n」或「\\r」之前的位置。 * 匹配前面的子表達式零次或多次。例如，zo能匹配「z」、「zo」以及「zoo」。等價於{0,}。 + 匹配前面的子表達式一次或多次。例如，「zo+」能匹配「zo」以及「zoo」，但不能匹配「z」。+等價於{1,}。 ? 匹配前面的子表達式零次或一次。例如，「do(es)?」可以匹配「does」中的「do」和「does」。?等價於{0,1}。 {n} n是一個非負整數。匹配確定的n次。例如，「o{2}」不能匹配「Bob」中的「o」，但是能匹配「food」中的兩個o。 {n,} n是一個非負整數。至少匹配n次。例如，「o{2,}」不能匹配「Bob」中的「o」，但能匹配「foooood」中的所有o。「o{1,}」等價於「o+」。「o{0,}」則等價於「o*」。 {n,m} m和n均為非負整數，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，「o{1,3}」將匹配「fooooood」中的前三個o。「o{0,1}」等價於「o?」。請注意在逗號和兩個數之間不能有空格。 ? 非貪心量化(Non-greedy quantifiers)：當該字元緊跟在任何一個其他重複修飾詞(*,+,?，{n}，{n,}，{n,m})後面時，匹配模式是非貪婪的。非貪婪模式儘可能少的匹配所搜尋的字串，而預設的貪婪模式則儘可能多的匹配所搜尋的字串。例如，對於字串「oooo」，「o+?」將匹配單個「o」，而「o+」將匹配所有「o」。 . 匹配除「\\r」「\\n」之外的任何單個字元。要匹配包括「\\r」「\\n」在內的任何字元，請使用像「(.&#124;\\r&#124;\\n)」的模式。 (pattern) 匹配pattern並取得這一匹配的子字串。該子字串用於向後參照。所取得的匹配可以從產生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中則使用$0…$9屬性。要匹配圓括號字元，請使用「(」或「)」。可帶數量字尾。 (?:pattern) 匹配pattern但不取得匹配的子字串(shy groups)，也就是說這是一個非取得匹配，不儲存匹配的子字串用於向後參照。這在使用或字元「(&#124;)」來組合一個模式的各個部分是很有用。例如「industr(?:y&#124;ies)」就是一個比「industry&#124;industries」更簡略的表達式。 (?=pattern) 正向肯定預查(look ahead positive assert)，在任何匹配pattern的字串開始處匹配尋找字串。這是一個非取得匹配，也就是說，該匹配不需要取得供以後使用。例如，「Windows(?=95&#124;98&#124;NT&#124;2000)」能匹配「Windows2000」中的「Windows」，但不能匹配「Windows3.1」中的「Windows」。預查不消耗字元，也就是說，在一個匹配發生後，在最後一次匹配之後立即開始下一次匹配的搜尋，而不是從包含預查的字元之後開始。 (?!pattern) 正向否定預查(negative assert)，在任何不匹配pattern的字串開始處匹配尋找字串。這是一個非取得匹配，也就是說，該匹配不需要取得供以後使用。例如「Windows(?!95&#124;98&#124;NT&#124;2000)」能匹配「Windows3.1」中的「Windows」，但不能匹配「Windows2000」中的「Windows」。預查不消耗字元，也就是說，在一個匹配發生後，在最後一次匹配之後立即開始下一次匹配的搜尋，而不是從包含預查的字元之後開始 (?&lt;=pattern) 反向(look behind)肯定預查，與正向肯定預查類似，只是方向相反。例如，「(?&lt;=95&#124;98 &#124; NT&#124;2000)Windows」能匹配「2000Windows」中的「Windows」，但不能匹配「3.1Windows」中的「Windows」。 (?&lt;!pattern) 反向否定預查，與正向否定預查類似，只是方向相反。例如「(?&lt;!95 &#124;98&#124;NT&#124;2000)Windows」能匹配「3.1Windows」中的「Windows」，但不能匹配「2000Windows」中的「Windows」。x&#124;y 沒有包圍在()里，其範圍是整個正規表示式。例如，「z&#124;food」能匹配「z」或「food」。「(?:z&#124;f)ood」則匹配「zood」或「food」。 [xyz] 字元集合(character class)。匹配所包含的任意一個字元。例如，「[abc]」可以匹配「plain」中的「a」。特殊字元僅有反斜線\\保持特殊含義，用於跳脫字元。其它特殊字元如星號、加號、各種括號等均作為普通字元。脫字元^如果出現在首位則表示負值字元集合；如果出現在字串中間就僅作為普通字元。連字元 - 如果出現在字串中間表示字元範圍描述；如果如果出現在首位(或末尾)則僅作為普通字元。右方括號應跳脫出現，也可以作為首位字元出現。 [^xyz] 排除型字元集合(negated character classes)。匹配未列出的任意字元。例如，「[^abc]」可以匹配「plain」中的「plin」。 [a-z] 字元範圍。匹配指定範圍內的任意字元。例如，「[a-z]」可以匹配「a」到「z」範圍內的任意小寫字母字元。 [^a-z] 排除型的字元範圍。匹配任何不在指定範圍內的任意字元。例如，「[^a-z]」可以匹配任何不在「a」到「z」範圍內的任意字元。 [:name:] 增加命名字元類(named character class)[註 1]中的字元到表達式。只能用於方括號表達式。 [=elt=] 增加目前locale下排序(collate)等價於字元「elt」的元素。例如，[=a=]可能會增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ 。只能用於方括號表達式。 [.elt.] 增加排序元素(collation element)elt到表達式中。這是因為某些排序元素由多個字元組成。例如，29個字母表的西班牙語， “CH”作為單個字母排在字母C之後，因此會產生如此排序「cinco, credo, chispa」。只能用於方括號表達式。 \\b 匹配一個單詞邊界，也就是指單詞和空格間的位置。例如，「er\\b」可以匹配「never」中的「er」，但不能匹配「verb」中的「er」。 \\B 匹配非單詞邊界。「er\\B」能匹配「verb」中的「er」，但不能匹配「never」中的「er」。 \\cx 匹配由x指明的控制字元。x的值必須為A-Z或a-z之一。否則，將c視為一個原義的「c」字元。控制字元的值等於x的值最低5位元(即對3210進位的餘數)。例如，\\cM匹配一個Control-M或回車字元。\\ca等效於\\u0001, \\cb等效於\\u0&#124; 002, 等等… \\d 匹配一個數字字元。等價於[0-9]。注意Unicode正規表示式會匹配全形數字字元。 \\D 匹配一個非數字字元。等價於[^0-9]。 \\f 匹配一個換頁符。等價於\\x0c和\\cL。 \\n 匹配一個換行符。等價於\\x0a和\\cJ。 \\r 匹配一個回車字元。等價於\\x0d和\\cM。 \\s 匹配任何空白字元，包括空格、制表符、換頁符等等。等價於[ \\f\\n\\r\\t\\v]。注意Unicode正規表示式會匹配全形空格符。 \\S 匹配任何非空白字元。等價於[^ \\f\\n\\r\\t\\v]。 \\t 匹配一個制表符。等價於\\x09和\\cI。 \\v 匹配一個垂直制表符。等價於\\x0b和\\cK。 \\w 匹配包括底線的任何單詞字元。等價於「[A-Za-z0-9_]」。注意Unicode正規表示式會匹配中文字元。 \\W 匹配任何非單詞字元。等價於「[^A-Za-z0-9_]」。 \\xnn 十六進位跳脫字元序列。匹配兩個十六進位數字nn表示的字元。例如，「\\x41」匹配「A」。「\\x041」則等價於「\\x04&amp;1」。正規表達式中可以使用ASCII編碼。. \\num 向後參照(back-reference)一個子字串(substring)，該子字串與正規表示式的第num個用括號圍起來的捕捉群(capture group)子表達式(subexpression)匹配。其中num是從1開始的十進位正整數，其上限可能是9[註 2]、31[註 3]、99甚至無限[註 4]。例如：「(.)\\1」匹配兩個連續的相同字元。 \\n 標識一個八進位跳脫值或一個向後參照。如果\\n之前至少n個取得的子表達式，則n為向後參照。否則，如果n為八進位數字(0-7)，則n為一個八進位跳脫值。 \\nm 3位八進位數字，標識一個八進位跳脫值或一個向後參照。如果\\nm之前至少有nm個獲得子表達式，則nm為向後參照。如果\\nm之前至少有n個取得，則n為一個後跟文字m的向後參照。如果前面的條件都不滿足，若n和m均為八進位數字(0-7)，則\\nm將匹配八進位跳脫值nm。 \\nml 如果n為八進位數字(0-3)，且m和l均為八進位數字(0-7)，則匹配八進位跳脫值nml。 \\un Unicode跳脫字元序列。其中n是一個用四個十六進位數字表示的Unicode字元。例如，\\u00A9匹配著作權符號(©)。 基礎正規表達式字符彙整 RE 字符 意義與範例 ^word 意義：待搜尋的字串(word)在行首！ 範例：搜尋行首為 # 開始的那一行，並列出行號 grep -n &#39;^#&#39; regular_express.txt word$ 意義：待搜尋的字串(word)在行尾！ 範例：將行尾為 ! 的那一行打印出來，並列出行號 grep -n &#39;!$&#39; regular_express.txt . 意義：代表“一定有一個任意字符”的字符！ 範例：搜尋的字串可以是 (eve) (eae) (eee) (e e)， 但不能僅有 (ee) ！亦即 e 與 e 中間“一定”僅有一個字符，而空白字符也是字符！ grep -n &#39;e.e&#39; regular_express.txt \\ 意義：跳脫字符，將特殊符號的特殊意義去除！ 範例：搜尋含有單引號 ‘ 的那一行！ grep -n \\&#39; regular_express.txt * 意義：重複零個到無窮多個的前一個 RE 字符 範例：找出含有 (es) (ess) (esss) 等等的字串，注意，因為 * 可以是 0 個，所以 es 也是符合帶搜尋字串。另外，因為 * 為重複“前一個 RE 字符”的符號， 因此，在 * 之前必須要緊接著一個 RE 字符喔！例如任意字符則為 “.*” ！ grep -n &#39;ess*&#39; regular_express.txt [list] 意義：字符集合的 RE 字符，裡面列出想要擷取的字符！ 範例：搜尋含有 (gl) 或 (gd) 的那一行，需要特別留意的是，在 [] 當中“謹代表一個待搜尋的字符”， 例如“ a[afl]y ”代表搜尋的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思！ grep -n &#39;g[ld]&#39; regular_express.txt [n1-n2] 意義：字符集合的 RE 字符，裡面列出想要擷取的字符範圍！ 範例：搜尋含有任意數字的那一行！需特別留意，在字符集合 [] 中的減號 - 是有特殊意義的，他代表兩個字符之間的所有連續字符！但這個連續與否與 ASCII 編碼有關，因此，你的編碼需要設置正確(在 bash 當中，需要確定 LANG 與 LANGUAGE 的變量是否正確！) 例如所有大寫字符則為 [A-Z] grep -n &#39;[A-Z]&#39; regular_express.txt [^list] 意義：字符集合的 RE 字符，裡面列出不要的字串或範圍！ 範例：搜尋的字串可以是 (oog) (ood) 但不能是 (oot) ，那個 ^ 在 [] 內時，代表的意義是“反向選擇”的意思。 例如，我不要大寫字符，則為 [^A-Z]。但是，需要特別注意的是，如果以 grep -n [^A-Z] regular_express.txt 來搜尋，卻發現該文件內的所有行都被列出，為什麼？因為這個 [^A-Z] 是“非大寫字符”的意思， 因為每一行均有非大寫字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小寫字 grep -n &#39;oo[^t]&#39; regular_express.txt {n,m} 意義：連續 n 到 m 個的“前一個 RE 字符” 意義：若為 {n} 則是連續 n 個的前一個 RE 字符， 意義：若是 {n,} 則是連續 n 個以上的前一個 RE 字符！ 範例：在 g 與 g 之間有 2 個到 3 個的 o 存在的字串，亦即 (goog)(gooog) grep -n &#39;go\\&#123;2,3\\&#125;g&#39; regular_express.txt 範例驗證密碼條件如下： 8~16字元 至少一個數字 至少一個小寫英文字母 或 大寫英文字母 至少要有一個特殊符號, 特殊符號限制在 @$%^&amp; 這些當中, 不然可能會出現 ∆©ƒ 這種符號, 使用者想像力無限 正則如下： ^(?=.*[a-z]|.*[A-Z])(?=.*[\\d])(?=.*[\\W])[\\w@$%\\^&amp;]&#123;8,16&#125;$ 第一個規則為 lookahead, 目標搜尋至少一個大寫字母或小寫字母, 因為前面加了 .*, 所以就算 lookahead 的前面是空的也沒關係, 從起始處開始往後搜尋, 需符合第一個 lookahead ?= 之後的規則, 若沒找到則停止, 找到則繼續下一個規則 開始第二個 lookahead 規則, 目標尋找至少一個數字, 第一個規則通過後, 才會開始第二個規則。 第二個規則從起始處開始搜尋, 若無找到則停止, 有找到則繼續 第三個 lookahead 規則, 目標尋找至少一個特殊字符, 行為同上 三個規則都通過後, 驗證最後一個規則, 字串可以是大小寫以及有列出的特殊符號, 數量為 8~16 個字元 crontab安裝 CentOSyum install cronie 代表意義 代表意義 分鐘 小時 日期 月份 周 指令 數字範圍 0-59 0-23 1-31 1-1 0-7 呀就指令啊 比較有趣的是那個“周”喔！周的數字為 0 或 7 時，都代表“星期天”的意思！另外，還有一些輔助的字符，大概有下面這些： 特殊字符 代表意義 *(星號) 代表任何時刻都接受的意思！舉例來說，範例一內那個日、月、周都是 * ， 就代表著“不論何月、何日的禮拜幾的 12:00 都執行後續指令”的意思！ ,(逗號) 代表分隔時段的意思。舉例來說，如果要下達的工作是 3:00 與 6:00 時，就會是： 0 3,6 * * * command 時間參數還是有五欄，不過第二欄是 3,6 ，代表 3 與 6 都適用！ -(減號) 代表一段時間範圍內，舉例來說， 8 點到 12 點之間的每小時的 20 分都進行一項工作：20 8-12 * * * command仔細看到第二欄變成 8-12 喔！代表 8,9,10,11,12 都適用的意思！ /n(斜線) 那個 n 代表數字，亦即是“每隔 n 單位間隔”的意思，例如每五分鐘進行一次，則： */5 * * * * command 很簡單吧！用 * 與 /5 來搭配，也可以寫成 0-59/5 ，相同意思！ /etc/crontab[root@study ~]# cat /etc/crontabSHELL=/bin/bash &lt;==使用哪種 shell 接口PATH=/sbin:/bin:/usr/sbin:/usr/bin &lt;==可執行文件搜尋路徑MAILTO=root &lt;==若有額外STDOUT，以 email將數據送給誰# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed MAILTO=root： 當 /etc/crontab 這個文件中的例行性工作的指令發生錯誤時，或者是該工作的執行結果有 STDOUT/STDERR 時，會將錯誤訊息或者是屏幕顯示的訊息送的對象 默認是由系統直接寄發一封 mail 給 root 例如：MAILTO=&#x64;&#x6d;&#x74;&#115;&#x61;&#105;&#x40;&#109;&#121;&#46;&#x68;&#111;&#115;&#x74;&#x2e;&#x6e;&#x61;&#x6d;&#x65; PATH=….：輸入可執行文件的搜尋路徑，使用默認的路徑設置就已經很足夠了！ “分 時 日 月 周 身份 指令”七個字段的設置 這個 /etc/crontab 可以設置的基本語法與 crontab -e 不太相同 前面同樣是分、時、日、月、週五個字段， 但是在五個字段後面接的並不是指令，就是“執行後面那串指令的身份” 這與使用者的 crontab -e 不相同。由於使用者自己的 crontab 並不需要指定身份 crond 服務讀取配置文件/etc/crontab/etc/cron.d/*/var/spool/cron/* 跟系統的運行比較有關係的兩個配置文件是放在 /etc/crontab 文件內以及 /etc/cron.d/* 目錄內的文件 跟用戶自己的工作比較有關的配置文件放在 /var/spool/cron/ 其他 輸入 crontab job crontab -e 確認 crontab 狀態 /etc/init.d/cron status 停止 crontab /etc/init.d/cron stop 啟動 crontab /etc/init.d/cron start anacron語法[root@study ~]# anacron [-sfn] [job]..[root@study ~]# anacron -u [job]..選項與參數：-s ：開始一連續的執行各項工作 (job)，會依據時間記錄文件的數據判斷是否進行；-f ：強制進行，而不去判斷時間記錄文件的時間戳記；-n ：立刻進行未進行的任務，而不延遲 (delay) 等待時間；-u ：僅更新時間記錄文件的時間戳記，不進行任何工作。job ：由 /etc/anacrontab 定義的各項工作名稱。 配置檔[root@study ~]# cat /etc/anacrontabSHELL=/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootRANDOM_DELAY=45 # 隨機給予最大延遲時間，單位是分鐘START_HOURS_RANGE=3-22 # 延遲多少個小時內應該要執行的任務時間1 5 cron.daily nice run-parts /etc/cron.daily7 25 cron.weekly nice run-parts /etc/cron.weekly@monthly 45 cron.monthly nice run-parts /etc/cron.monthly天數 延遲時間 工作名稱定義 實際要進行的指令串# 天數單位為天；延遲時間單位為分鐘；工作名稱定義可自訂，指令串則通常與 crontab 的設置相同！[root@study ~]# more /var/spool/anacron/*::::::::::::::/var/spool/anacron/cron.daily::::::::::::::20150731::::::::::::::/var/spool/anacron/cron.monthly::::::::::::::20150703::::::::::::::/var/spool/anacron/cron.weekly::::::::::::::20150727# 上面則是三個工作名稱的時間記錄文件以及記錄的時間戳記 拿 /etc/cron.daily/ 那一行的設置來說明，那四個字段的意義分別是： 天數：anacron 執行當下與時間戳記 (/var/spool/anacron/ 內的時間紀錄檔) 相差的天數，若超過此天數，就準備開始執行，若沒有超過此天數，則不予執行後續的指令。 延遲時間：若確定超過天數導致要執行調度工作了，那麼請延遲執行的時間，因為擔心立即啟動會有其他資源衝突的問題吧！ 工作名稱定義：這個沒啥意義，就只是會在 /var/log/cron 裡頭記載該項任務的名稱這樣！通常與後續的目錄資源名稱相同即可。 實際要進行的指令串：有沒有跟 0hourly 很像啊！沒錯！相同的作法啊！通過 run-parts 來處理的！ anacron 的執行流程(以 cron.daily 為例) 由 /etc/anacrontab 分析到 cron.daily 這項工作名稱的天數為 1 天； 由 /var/spool/anacron/cron.daily 取出最近一次執行 anacron 的時間戳記； 由上個步驟與目前的時間比較，若差異天數為 1 天以上 (含 1 天)，就準備進行指令； 若準備進行指令，根據 /etc/anacrontab 的設置，將延遲 5 分鐘 + 3 小時 (看 START_HOURS_RANGE 的設置)； 延遲時間過後，開始執行後續指令，亦即“ run-parts /etc/cron.daily ”這串指令；執行完畢後， anacron 程序結束。 如此一來，放置在 /etc/cron.daily/ 內的任務就會在一天後一定會被執行的！ 因為 anacron 是每個小時被執行一次嘛！ 所以如果隔了一陣子將 CentOS 開機，開機過後約 1 小時左右系統會有一小段時間的忙碌！硬盤會跑個不停！那就是因為 anacron 正在執行過去 /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/ 裡頭的未進行的各項工作調度 cron 與 anacron 與目錄之間的關係 crond 會主動去讀取 /etc/crontab, /var/spool/cron/, /etc/cron.d/ 等配置文件，並依據“分、時、日、月、周”的時間設置去各項工作調度； 根據 /etc/cron.d/0hourly 的設置，主動去 /etc/cron.hourly/ 目錄下，執行所有在該目錄下的可執行文件； 因為 /etc/cron.hourly/0anacron 這個指令檔的緣故，主動的每小時執行 anacron ，並調用 /etc/anacrontab 的配置文件； 根據 /etc/anacrontab 的設置，依據每天、每週、每月去分析 /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/ 內的可執行文件，以進行固定週期需要執行的指令。 如果你每個週日的需要執行的動作是放置於 /etc/crontab 的話，那麼該動作只要過期了就過期了，並不會被抓回來重新執行。 如果是放置在 /etc/cron.weekly/ 目錄下，那麼該工作就會定期，幾乎一定會在一週內執行一次 test測試的標誌|代表意義——–||1. 關於某個文件名的“文件類型”判斷，如 test -e filename 表示存在否-e|該“文件名”是否存在？(常用)-f|該“文件名”是否存在且為文件(file)？(常用)-d|該“文件名”是否存在且為目錄(directory)？(常用)-b|該“文件名”是否存在且為一個 block device 設備？-c|該“文件名”是否存在且為一個 character device 設備？-S|該“文件名”是否存在且為一個 Socket 文件？-p|該“文件名”是否存在且為一個 FIFO (pipe) 文件？-L|該“文件名”是否存在且為一個鏈接文件？|2. 關於文件的權限偵測，如 test -r filename 表示可讀否 (但 root 權限常有例外)-r|偵測該文件名是否存在且具有“可讀”的權限？-w|偵測該文件名是否存在且具有“可寫”的權限？-x|偵測該文件名是否存在且具有“可執行”的權限？-u|偵測該文件名是否存在且具有“SUID”的屬性？-g|偵測該文件名是否存在且具有“SGID”的屬性？-k|偵測該文件名是否存在且具有“Sticky bit”的屬性？-s|偵測該文件名是否存在且為“非空白文件”？|3. 兩個文件之間的比較，如： test file1 -nt file2-nt|(newer than)判斷 file1 是否比 file2 新-ot|(older than)判斷 file1 是否比 file2 舊-ef|判斷 file1 與 file2 是否為同一文件，可用在判斷 hard link 的判定上。 主要意義在判定，兩個文件是否均指向同一個 inode 哩！|4. 關於兩個整數之間的判定，例如 test n1 -eq n2-eq|兩數值相等 (equal)-ne|兩數值不等 (not equal)-gt|n1 大於 n2 (greater than)-lt|n1 小於 n2 (less than)-ge|n1 大於等於 n2 (greater than or equal)-le|n1 小於等於 n2 (less than or equal)|5. 判定字串的數據test -z|string 判定字串是否為 0 ？若 string 為空字串，則為 truetest -n|string 判定字串是否非為 0 ？若 string 為空字串，則為 false。 -n 亦可省略test str1 == str2|判定 str1 是否等於 str2 ，若相等，則回傳 truetest str1 != str2|判定 str1 是否不等於 str2 ，若相等，則回傳 false|6. 多重條件判定，例如： test -r filename -a -x filename-a|(and)兩狀況同時成立！例如 test -r file -a -x file，則 file 同時具有 r 與 x 權限時，才回傳 true。-o|(or)兩狀況任何一個成立！例如 test -r file -o -x file，則 file 具有 r 或 x 權限時，就可回傳 true。!|反相狀態，如 test ! -x file ，當 file 不具有 x 時，回傳 true 變量變量的設置 變量設置方式 str 沒有設置 str 為空字串 str 已設置非為空字串 var=${str-expr} var=expr var= var=$str var=${str:-expr} var=expr var=expr var=$str var=${str+expr} var= var=expr var=expr var=${str:+expr} var= var= var=expr var=${str=expr} str=expr var=expr var=expr var= str 不變 var=$str var=${str:=expr} str=expr var=expr str=expr var=expr str 不變 var=$str var=${str?expr} expr 輸出至 stderr var= var=$str var=${str:?expr} expr 輸出至 stderr expr 輸出至 stderr var=$str Script 變量帶入規則：script 名稱，如 /path/to/scriptname | opt1 | opt2 | opt3 | opt4—— | —— | —— | —— | $0 | $1 | $2 | $3 | $4 可以在 script 裡面使用的特殊變量$# ：代表後接的參數“個數”，以上表為例這裡顯示為“ 4 ”；$@ ：代表“ “$1” “$2” “$3” “$4” ”之意，每個變量是獨立的(用雙引號括起來)；$* ：代表“ “$1c$2c$3c$4” ”，其中 c 為分隔字符，默認為空白鍵， 所以本例中代表“ “$1 $2 $3 $4” ”之意。 條件判斷單一判斷式if [ 條件判斷式 ]; then 當條件判斷式成立時，可以進行的指令工作內容；fi &lt;==將 if 反過來寫，就成為 fi 啦！結束 if 之意！ 以下 test 的方式可改編成條件判斷式 test 方式 read -p &quot;Please input (Y/N): &quot; yn[ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;OK, continue&quot; &amp;&amp; exit 0[ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh, interrupt!&quot; &amp;&amp; exit 0echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0 條件判斷式 PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p &quot;Please input (Y/N): &quot; ynif [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then echo &quot;OK, continue&quot; exit 0fiif [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then echo &quot;Oh, interrupt!&quot; exit 0fiecho &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0 多重、複雜條件判斷式一個條件判斷，分成功進行與失敗進行 (else)if [ 條件判斷式 ]; then 當條件判斷式成立時，可以進行的指令工作內容；else 當條件判斷式不成立時，可以進行的指令工作內容；fi 多個條件判斷 (if … elif … elif … else) 分多種不同情況執行if [ 條件判斷式一 ]; then 當條件判斷式一成立時，可以進行的指令工作內容；elif [ 條件判斷式二 ]; then 當條件判斷式二成立時，可以進行的指令工作內容；else 當條件判斷式一與二均不成立時，可以進行的指令工作內容；fi 將以下的 test 方式改成條件判斷式 改前: read -p &quot;Please input (Y/N): &quot; yn[ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;OK, continue&quot; &amp;&amp; exit 0[ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;Oh, interrupt!&quot; &amp;&amp; exit 0echo &quot;I don&#x27;t know what your choice is&quot; &amp;&amp; exit 0 改後: #!/bin/bash# Program:# This program shows the user&#x27;s choice# History:# 2015/07/16 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p &quot;Please input (Y/N): &quot; ynif [ &quot;$&#123;yn&#125;&quot; == &quot;Y&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;y&quot; ]; then echo &quot;OK, continue&quot;elif [ &quot;$&#123;yn&#125;&quot; == &quot;N&quot; ] || [ &quot;$&#123;yn&#125;&quot; == &quot;n&quot; ]; then echo &quot;Oh, interrupt!&quot;else echo &quot;I don&#x27;t know what your choice is&quot;fi 利用 case ….. esac 判斷 語法： case $變量名稱 in &lt;==關鍵字為 case ，還有變量前有錢字號 &quot;第一個變量內容&quot;) &lt;==每個變量內容建議用雙引號括起來，關鍵字則為小括號 ) 程序段 ;; &lt;==每個類別結尾使用兩個連續的分號來處理！ &quot;第二個變量內容&quot;) 程序段 ;; *) &lt;==最後一個變量內容都會用 * 來代表所有其他值 不包含第一個變量內容與第二個變量內容的其他程序執行段 exit 1 ;;esac &lt;==最終的 case 結尾！“反過來寫”思考一下！ 範例： #!/bin/bash# Program:# Show &quot;Hello&quot; from $1.... by using case .... esac# History:# 2015/07/16 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHcase $&#123;1&#125; in &quot;hello&quot;) echo &quot;Hello, how are you ?&quot; ;; &quot;&quot;) echo &quot;You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;&quot; ;; *) # 其實就相當於萬用字符，0~無窮多個任意字符之意！ echo &quot;Usage $&#123;0&#125; &#123;hello&#125;&quot; ;;esac 練習題使用判斷式寫一個 script, 要可以做到以下幾件事： 先讓使用者輸入他們的退伍日期； 驗證輸入格式； 由兩個日期的比較來顯示“還需要幾天”才能夠退伍的字樣。 解答如下： #!/bin/bash# Program:# You input your demobilization date, I calculate how many days before you demobilize.# History:# 2015/07/16 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH# 1. 告知使用者這支程序的用途，並且告知應該如何輸入日期格式？echo &quot;This program will try to calculate :&quot;echo &quot;How many days before your demobilization date...&quot;read -p &quot;Please input your demobilization date (YYYYMMDD ex&gt;20150716): &quot; date2# 2. 測試一下，這個輸入的內容是否正確？利用正則表達式囉～date_d=$(echo $&#123;date2&#125; |grep &#x27;[0-9]\\&#123;8\\&#125;&#x27;) # 看看是否有八個數字if [ &quot;$&#123;date_d&#125;&quot; == &quot;&quot; ]; then echo &quot;You input the wrong date format....&quot; exit 1fi# 3. 開始計算日期囉～declare -i date_dem=$(date --date=&quot;$&#123;date2&#125;&quot; +%s) # 退伍日期秒數declare -i date_now=$(date +%s) # 現在日期秒數declare -i date_total_s=$(($&#123;date_dem&#125;-$&#123;date_now&#125;)) # 剩餘秒數統計declare -i date_d=$(($&#123;date_total_s&#125;/60/60/24)) # 轉為日數if [ &quot;$&#123;date_total_s&#125;&quot; -lt &quot;0&quot; ]; then # 判斷是否已退伍 echo &quot;You had been demobilization before: &quot; $((-1*$&#123;date_d&#125;)) &quot; ago&quot;else declare -i date_h=$(($(($&#123;date_total_s&#125;-$&#123;date_d&#125;*60*60*24))/60/60)) echo &quot;You will demobilize after $&#123;date_d&#125; days and $&#123;date_h&#125; hours.&quot;fi netstat這個指令可以看到目前有哪些 port 是對外開放的, 有哪些是 Listen 的 語法netstat -[atunlp]選項與參數：-a ：將目前系統上所有的連線、監聽、Socket 數據都列出來-t ：列出 tcp 網絡封包的數據-u ：列出 udp 網絡封包的數據-n ：不以程序的服務名稱，以埠號 (port number) 來顯示；-l ：列出目前正在網絡監聽 (listen) 的服務；-p ：列出該網絡服務的程序 PID 範例列出目前的路由表狀態，且以 IP 及 port number 顯示：[root@www ~]# netstat -rnKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth00.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0# 其實這個參數就跟 route -n 一模一樣，對吧！這不是 netstat 的主要功能啦！ 列出目前的所有網路連線狀態，使用 IP 與 port number[root@www ~]# netstat -anActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State....(中間省略)....tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTENtcp 0 52 192.168.1.100:22 192.168.1.101:1937 ESTABLISHED tcp 0 0 :::22 :::* LISTEN....(中間省略)....Active UNIX domain sockets (servers and established)Proto RefCnt Flags Type State I-Node Pathunix 2 [ ACC ] STREAM LISTENING 11075 @/var/run/hald/dbus-uukdg1qMPhunix 2 [ ACC ] STREAM LISTENING 10952 /var/run/dbus/system_bus_socketunix 2 [ ACC ] STREAM LISTENING 11032 /var/run/acpid.socket....(底下省略).... function語法：function fname() &#123; 程序段 注意： 因為 shell script 的執行方式是由上而下，由左而右， 因此在 shell script 當中的 function 的設置一定要在程序的最前面 function 內也可置變量，但跟 shell script 的內置變量方式不同 範例： 一般 #!/bin/bash# Program:# Use function to repeat information.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHfunction printit()&#123; echo -n &quot;Your choice is &quot; # 加上 -n 可以不斷行繼續在同一行顯示&#125;echo &quot;This program will print your selection !&quot;case $&#123;1&#125; in &quot;one&quot;) printit; echo $&#123;1&#125; | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; # 將參數做大小寫轉換！ ;; &quot;two&quot;) printit; echo $&#123;1&#125; | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; ;; &quot;three&quot;) printit; echo $&#123;1&#125; | tr &#x27;a-z&#x27; &#x27;A-Z&#x27; ;; *) echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot; ;;esac 內置變量#!/bin/bash# Program:# Use function to repeat information.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHfunction printit()&#123; echo &quot;Your choice is $&#123;1&#125;&quot; # 這個 $1 必須要參考下面指令的下達&#125;echo &quot;This program will print your selection !&quot;case $&#123;1&#125; in &quot;one&quot;) printit 1 # 請注意， printit 指令後面還有接參數！ ;; &quot;two&quot;) printit 2 ;; &quot;three&quot;) printit 3 ;; *) echo &quot;Usage $&#123;0&#125; &#123;one|two|three&#125;&quot; ;;esac loopwhile do done, until do done (不定循環)while do done語法while [ condition ] &lt;==中括號內的狀態就是判斷式do &lt;==do 是循環的開始！ 程序段落done &lt;==done 是循環的結束 範例#!/bin/bash# Program:# Repeat question until user input correct answer.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHwhile [ &quot;$&#123;yn&#125;&quot; != &quot;yes&quot; -a &quot;$&#123;yn&#125;&quot; != &quot;YES&quot; ]do read -p &quot;Please input yes/YES to stop this program: &quot; yndoneecho &quot;OK! you input the correct answer.&quot; #!/bin/bash# Program:# Use loop to calculate &quot;1+2+3+...+100&quot; result.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHs=0 # 這是加總的數值變量i=0 # 這是累計的數值，亦即是 1, 2, 3....while [ &quot;$&#123;i&#125;&quot; != &quot;100&quot; ]do i=$(($i+1)) # 每次 i 都會增加 1 s=$(($s+$i)) # 每次都會加總一次！doneecho &quot;The result of &#x27;1+2+3+...+100&#x27; is ==&gt; $s&quot; until do done語法until [ condition ]do 程序段落done 範例#!/bin/bash# Program:# Repeat question until user input correct answer.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHuntil [ &quot;$&#123;yn&#125;&quot; == &quot;yes&quot; -o &quot;$&#123;yn&#125;&quot; == &quot;YES&quot; ]do read -p &quot;Please input yes/YES to stop this program: &quot; yndoneecho &quot;OK! you input the correct answer.&quot; for…do…done (固定循環)語法for var in con1 con2 con3 ...do 程序段done 範例 假設我有三種動物，分別是 dog, cat, elephant 三種， 我想每一行都輸出這樣：“There are dogs…”之類的字樣，則可以： #!/bin/bash# Program:# Using for .... loop to print 3 animals# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHfor animal in dog cat elephantdo echo &quot;There are $&#123;animal&#125;s.... &quot;done 系統上面的各種帳號都是寫在 /etc/passwd 內的第一個字段，所以請通過管線命令的 cut 捉出單純的帳號名稱後，以 id 分別檢查使用者的識別碼與特殊參數 #!/bin/bash# Program# Use id, finger command to check system account&#x27;s information.# History# 2015/07/17 VBird first releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHusers=$(cut -d &#x27;:&#x27; -f1 /etc/passwd) # 擷取帳號名稱for username in $&#123;users&#125; # 開始循環進行！do id $&#123;username&#125;done 讓使用者輸入某個目錄文件名， 然後我找出某目錄內的文件名的權限 #!/bin/bash# Program:# User input dir name, I find the permission of files.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH# 1. 先看看這個目錄是否存在啊？read -p &quot;Please input a directory: &quot; dirif [ &quot;$&#123;dir&#125;&quot; == &quot;&quot; -o ! -d &quot;$&#123;dir&#125;&quot; ]; then echo &quot;The $&#123;dir&#125; is NOT exist in your system.&quot; exit 1fi# 2. 開始測試文件囉～filelist=$(ls $&#123;dir&#125;) # 列出所有在該目錄下的文件名稱for filename in $&#123;filelist&#125;do perm=&quot;&quot; test -r &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; readable&quot; test -w &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; writable&quot; test -x &quot;$&#123;dir&#125;/$&#123;filename&#125;&quot; &amp;&amp; perm=&quot;$&#123;perm&#125; executable&quot; echo &quot;The file $&#123;dir&#125;/$&#123;filename&#125;&#x27;s permission is $&#123;perm&#125; &quot;done for…do…done 的數值處理語法- 初始值：某個變量在循環當中的起始值，直接以類似 i=1 設置好； - 限制值：當變量的值在這個限制值的範圍內，就繼續進行循環。例如 i&lt;=100； - 執行步階：每作一次循環時，變量的變化量。例如 i=i+1。 for (( 初始值; 限制值; 執行步階 ))do 程序段done 範例 #!/bin/bash# Program:# Try do calculate 1+2+....+$&#123;your_input&#125;# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p &quot;Please input a number, I will count for 1+2+...+your_input: &quot; nus=0for (( i=1; i&lt;=$&#123;nu&#125;; i=i+1 ))do s=$(($&#123;s&#125;+$&#123;i&#125;))doneecho &quot;The result of &#x27;1+2+3+...+$&#123;nu&#125;&#x27; is ==&gt; $&#123;s&#125;&quot; 搭配亂數與陣列的實驗範例#!/bin/bash# Program:# Try do tell you what you may eat.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHeat[1]=&quot;賣噹噹漢堡包&quot;eat[2]=&quot;肯爺爺炸雞&quot;eat[3]=&quot;彩虹日式便當&quot;eat[4]=&quot;越油越好吃大雅&quot;eat[5]=&quot;想不出吃啥學餐&quot;eat[6]=&quot;太師父便當&quot;eat[7]=&quot;池上便當&quot;eat[8]=&quot;懷念火車便當&quot;eat[9]=&quot;一起吃方便麵&quot;eatnum=9eated=0while [ &quot;$&#123;eated&#125;&quot; -lt 3 ]; do check=$(( $&#123;RANDOM&#125; * $&#123;eatnum&#125; / 32767 + 1 )) mycheck=0 if [ &quot;$&#123;eated&#125;&quot; -ge 1 ]; then for i in $(seq 1 $&#123;eated&#125; ) do if [ $&#123;eatedcon[$i]&#125; == $check ]; then mycheck=1 fi done fi if [ $&#123;mycheck&#125; == 0 ]; then echo &quot;your may eat $&#123;eat[$&#123;check&#125;]&#125;&quot; eated=$(( $&#123;eated&#125; + 1 )) eatedcon[$&#123;eated&#125;]=$&#123;check&#125; fidone #!/bin/bash# Program:# Try do tell you what you may eat.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHeat[1]=&quot;賣噹噹漢堡包&quot; # 寫下你所收集到的店家！eat[2]=&quot;肯爺爺炸雞&quot;eat[3]=&quot;彩虹日式便當&quot;eat[4]=&quot;越油越好吃大雅&quot;eat[5]=&quot;想不出吃啥學餐&quot;eat[6]=&quot;太師父便當&quot;eat[7]=&quot;池上便當&quot;eat[8]=&quot;懷念火車便當&quot;eat[9]=&quot;一起吃方便麵&quot;eatnum=9 # 需要輸入有幾個可用的餐廳數！check=$(( $&#123;RANDOM&#125; * $&#123;eatnum&#125; / 32767 + 1 ))echo &quot;your may eat $&#123;eat[$&#123;check&#125;]&#125;&quot; loop arrayfor i in &quot;$&#123;array[@]&#125;&quot; shell script 的追蹤與 debug語法sh [-nvx] scripts.sh選項與參數：-n ：不要執行 script，僅查詢語法的問題；-v ：再執行 sccript 前，先將 scripts 的內容輸出到屏幕上；-x ：將使用到的 script 內容顯示到屏幕上，這是很有用的參數！ 範例 測試 dir_perm.sh 有無語法的問題？ sh -n dir_perm.sh 將 show_animal.sh 的執行過程全部列出來～ sh -x show_animal.sh 練習題 請創建一支 script ，當你執行該 script 的時候，該 script 可以顯示： 1. 你目前的身份 (用 whoami ) 2. 你目前所在的目錄 (用 pwd) #!/bin/bashecho -e &quot;Your name is ==&gt; $(whoami)&quot;echo -e &quot;The current directory is ==&gt; $(pwd)&quot; 請自行創建一支程序，該程序可以用來計算“你還有幾天可以過生日”啊？ #!/bin/bashread -p &quot;Pleas input your birthday (MMDD, ex&gt; 0709): &quot; birnow=`date +%m%d`if [ &quot;$bir&quot; == &quot;$now&quot; ]; thenecho &quot;Happy Birthday to you!!!&quot;elif [ &quot;$bir&quot; -gt &quot;$now&quot; ]; thenyear=`date +%Y`total_d=$(($((`date --date=&quot;$year$bir&quot; +%s`-`date +%s`))/60/60/24))echo &quot;Your birthday will be $total_d later&quot;elseyear=$((`date +%Y`+1))total_d=$(($((`date --date=&quot;$year$bir&quot; +%s`-`date +%s`))/60/60/24))echo &quot;Your birthday will be $total_d later&quot;fi 讓使用者輸入一個數字，程序可以由 1+2+3… 一直累加到使用者輸入的數字為止。 #!/bin/bashread -p &quot;Please input an integer number: &quot; numberi=0s=0while [ &quot;$i&quot; != &quot;$number&quot; ]doi=$(($i+1))s=$(($s+$i))doneecho &quot;the result of &#x27;1+2+3+...$number&#x27; is ==&gt; $s&quot; 撰寫一支程序，他的作用是: 1.) 先查看一下 /root/test/logical 這個名稱是否存在； 2.) 若不存在，則創建一個文件，使用 touch 來創建，創建完成後離開； 3.) 如果存在的話，判斷該名稱是否為文件，若為文件則將之刪除後創建一個目錄，文件名為 logical ，之後離開； 4.) 如果存在的話，而且該名稱為目錄，則移除此目錄！ #!/bin/bashif [ ! -e logical ]; thentouch logicalecho &quot;Just make a file logical&quot;exit 1elif [ -e logical ] &amp;&amp; [ -f logical ]; thenrm logicalmkdir logicalecho &quot;remove file ==&gt; logical&quot;echo &quot;and make directory logical&quot;exit 1elif [ -e logical ] &amp;&amp; [ -d logical ]; thenrm -rf logicalecho &quot;remove directory ==&gt; logical&quot;exit 1elseecho &quot;Does here have anything?&quot;fi 我們知道 /etc/passwd 裡面以 : 來分隔，第一欄為帳號名稱。請寫一隻程序，可以將 /etc/passwd 的第一欄取出，而且每一欄都以一行字串“The 1 account is “root” ”來顯示，那個 1 表示行數。 #!/bin/bashaccounts=`cat /etc/passwd | cut -d&#x27;:&#x27; -f1`for account in $accountsdodeclare -i i=$i+1echo &quot;The $i account is \\&quot;$account\\&quot; &quot;done /etc/passwd 文件架構 帳號名稱： 需要用來對應 UID, 例如 root 的 UID 對應就是 0 (第三字段) 密碼： 早期 Unix 系統的密碼就是放在這字段上！但是因為這個文件的特性是所有的程序都能夠讀取，這樣一來很容易造成密碼數據被竊取， 因此後來就將這個字段的密碼數據給他改放到 /etc/shadow 中了。所以這裡你會看到一個“ x ” UID: 使用者識別碼！ Linux 對於 UID 有幾個限制: id 範圍 | 該 ID 使用者特性——-|0(系統管理員)| 當 UID 是 0 時，代表這個帳號是“系統管理員”！ 所以當你要讓其他的帳號名稱也具有 root 的權限時，將該帳號的 UID 改為 0 即可。 這也就是說，一部系統上面的系統管理員不見得只有 root 喔！ 不過，很不建議有多個帳號的 UID 是 0 啦～容易讓系統管理員混亂！1999(系統帳號)| 保留給系統使用的 ID，其實除了 0 之外，其他的 UID 權限與特性並沒有不一樣。默認 1000 以下的數字讓給系統作為保留帳號只是一個習慣。 由於系統上面啟動的網絡服務或背景服務希望使用較小的權限去運行，因此不希望使用 root 的身份去執行這些服務， 所以我們就得要提供這些運行中程序的擁有者帳號才行。這些系統帳號通常是不可登陸的， 所以才會有我們在第十章提到的 /sbin/nologin 這個特殊的 shell 存在。 根據系統帳號的由來，通常這類帳號又約略被區分為兩種： 1200：由 distributions 自行創建的系統帳號； 201999：若使用者有系統帳號需求時，可以使用的帳號 UID。100060000(可登陸帳號)| 給一般使用者用的。事實上，目前的 linux 核心 (3.10.x 版)已經可以支持到 4294967295 (2^32-1) 這麼大的 UID 號碼喔！ GID： 這個與 /etc/group 有關！其實 /etc/group 的觀念與 /etc/passwd 差不多，只是他是用來規範群組名稱與 GID 的對應而已！ 使用者信息說明欄： 這個字段基本上並沒有什麼重要用途，只是用來解釋這個帳號的意義而已！不過，如果您提供使用 finger 的功能時， 這個字段可以提供很多的訊息呢！本章後面的 chfn 指令會來解釋這裡的說明。 主文件夾： 這是使用者的主文件夾，以上面為例， root 的主文件夾在 /root ，所以當 root 登陸之後，就會立刻跑到 /root 目錄裡頭啦！呵呵！ 如果你有個帳號的使用空間特別的大，你想要將該帳號的主文件夾移動到其他的硬盤去該怎麼作？ 沒有錯！可以在這個字段進行修改呦！默認的使用者主文件夾在 /home/yourIDname Shell： 我們在第十章 BASH 提到很多次，當使用者登陸系統後就會取得一個 Shell 來與系統的核心溝通以進行使用者的操作任務。那為何默認 shell 會使用 bash 呢？就是在這個字段指定的囉！ 這裡比較需要注意的是，有一個 shell 可以用來替代成讓帳號無法取得 shell 環境的登陸動作！那就是 /sbin/nologin 這個東西！這也可以用來製作純 pop 郵件帳號者的數據呢！ /etc/shadow 文件結構 帳號名稱：由於密碼也需要與帳號對應啊～因此，這個文件的第一欄就是帳號，必須要與 /etc/passwd 相同才行！ 密碼：這個字段內的數據才是真正的密碼，而且是經過編碼的密碼 (加密) 啦！ 你只會看到有一些特殊符號的字母就是了！需要特別留意的是，雖然這些加密過的密碼很難被解出來， 但是“很難”不等於“不會”，所以，這個文件的默認權限是“-rw——-”或者是“———-”，亦即只有 root 才可以讀寫就是了！你得隨時注意，不要不小心更動了這個文件的權限呢！另外，由於各種密碼編碼的技術不一樣，因此不同的編碼系統會造成這個字段的長度不相同。 舉例來說，舊式的 DES, MD5 編碼系統產生的密碼長度就與目前慣用的 SHA 不同[2]！SHA 的密碼長度明顯的比較長些。由於固定的編碼系統產生的密碼長度必須一致，因此“當你讓這個字段的長度改變後，該密碼就會失效(算不出來)”。 很多軟件通過這個功能，在此字段前加上 ! 或 * 改變密碼字段長度，就會讓密碼“暫時失效”了。 最近更動密碼的日期：這個字段記錄了“更動密碼那一天”的日期，不過，很奇怪呀！在我的例子中怎麼會是 16559 呢？呵呵，這個是因為計算 Linux 日期的時間是以 1970 年 1 月 1 日作為 1 而累加的日期，1971 年 1 月 1 日則為 366 啦！ 得注意一下這個數據呦！上述的 16559 指的就是 2015-05-04 那一天啦！瞭解乎？ 而想要了解該日期可以使用本章後面 chage 指令的幫忙！至於想要知道某個日期的累積日數， 可使用如下的程序計算： echo $(($(date --date=&quot;2015/05/04&quot; +%s)/86400+1)) 上述指令中，2015/05/04 為你想要計算的日期，86400 為每一天的秒數， %s 為 1970/01/01 以來的累積總秒數。 由於 bash 僅支持整數，因此最終需要加上 1 補齊 1970/01/01 當天。 密碼不可被更動的天數：(與第 3 字段相比)第四個字段記錄了：這個帳號的密碼在最近一次被更改後需要經過幾天才可以再被變更！如果是 0 的話， 表示密碼隨時可以更動的意思。這的限制是為了怕密碼被某些人一改再改而設計的！如果設置為 20 天的話，那麼當你設置了密碼之後， 20 天之內都無法改變這個密碼呦！ 密碼需要重新變更的天數：(與第 3 字段相比)經常變更密碼是個好習慣！為了強制要求使用者變更密碼，這個字段可以指定在最近一次更改密碼後， 在多少天數內需要再次的變更密碼才行。你必須要在這個天數內重新設置你的密碼，否則這個帳號的密碼將會“變為過期特性”。 而如果像上面的 99999 (計算為 273 年) 的話，那就表示，呵呵，密碼的變更沒有強制性之意。 密碼需要變更期限前的警告天數：(與第 5 字段相比)當帳號的密碼有效期限快要到的時候 (第 5 字段)，系統會依據這個字段的設置，發出“警告”言論給這個帳號，提醒他“再過 n 天你的密碼就要過期了，請儘快重新設置你的密碼呦！”，如上面的例子，則是密碼到期之前的 7 天之內，系統會警告該用戶。 密碼過期後的帳號寬限時間(密碼失效日)：(與第 5 字段相比)密碼有效日期為“更新日期(第3字段)”+“重新變更日期(第5字段)”，過了該期限後使用者依舊沒有更新密碼，那該密碼就算過期了。 雖然密碼過期但是該帳號還是可以用來進行其他工作的，包括登陸系統取得 bash 。不過如果密碼過期了， 那當你登陸系統時，系統會強制要求你必須要重新設置密碼才能登陸繼續使用喔，這就是密碼過期特性。 帳號失效日期：這個日期跟第三個字段一樣，都是使用 1970 年以來的總日數設置。這個字段表示： 這個帳號在此字段規定的日期之後，將無法再使用。 就是所謂的“帳號失效”，此時不論你的密碼是否有過期，這個“帳號”都不能再被使用！ 這個字段會被使用通常應該是在“收費服務”的系統中，你可以規定一個日期讓該帳號不能再使用啦！ 保留：最後一個字段是保留的，看以後有沒有新功能加入。 範例假如我的使用者的密碼欄如下所示： dmtsai:$6$M4IphgNP2TmlXaSS$B418YFroYxxmm....:16559:5:60:7:5:16679: 由於密碼幾乎僅能單向運算(由明碼計算成為密碼，無法由密碼反推回明碼)，因此由上表的數據我們無法得知 dmstai 的實際密碼明文 (第二個字段)； 此帳號最近一次更動密碼的日期是 2015/05/04 (16559)； 能夠再次修改密碼的時間是 5 天以後，也就是 2015/05/09 以前 dmtsai 不能修改自己的密碼；如果使用者還是嘗試要更動自己的密碼，系統就會出現這樣的訊息： You must wait longer to change your passwordpasswd: Authentication token manipulation error畫面中告訴我們：你必須要等待更久的時間才能夠變更密碼之意啦！ 由於密碼過期日期定義為 60 天后，亦即累積日數為： 16559+60=16619，經過計算得到此日數代表日期為 2015/07/03。 這表示：“使用者必須要在 2015/05/09 (前 5 天不能改) 到 2015/07/03 之間的 60 天限制內去修改自己的密碼，若 2015/07/03 之後還是沒有變更密碼時，該密碼就宣告為過期”了！ 警告日期設為 7 天，亦即是密碼過期日前的 7 天，在本例中則代表 2015/06/26 ~ 2015/07/03 這七天。 如果使用者一直沒有更改密碼，那麼在這 7 天中，只要 dmtsai 登陸系統就會發現如下的訊息：Warning: your password will expire in 5 days 如果該帳號一直到 2015/07/03 都沒有更改密碼，那麼密碼就過期了。但是由於有 5 天的寬限天數， 因此 dmtsai 在 2015/07/08 前都還可以使用舊密碼登陸主機。 不過登陸時會出現強制更改密碼的情況，畫面有點像下面這樣： You are required to change your password immediately (password aged)WARNING: Your password has expired.You must change your password now and login again!Changing password for user dmtsai.Changing password for dmtsai(current) UNIX password: 你必須要輸入一次舊密碼以及兩次新密碼後，才能夠開始使用系統的各項資源。如果你是在 2015/07/08 以後嘗試以 dmtsai 登陸的話，那麼就會出現如下的錯誤訊息且無法登陸，因為此時你的密碼就失效去啦！ Your account has expired; please contact your system administrator 如果使用者在 2015/07/03 以前變更過密碼，那麼第 3 個字段的那個 16559 的天數就會跟著改變，因此， 所有的限制日期也會跟著相對變動喔！^_^ 無論使用者如何動作，到了 16679 (大約是 2015/09/01 左右) 該帳號就失效了～ 獲取 shadow 的加密機制 安裝 authconfig, 如果沒有裝的話 yum install authconfig-gtk* 查詢 authconfig --test | grep hashing 關於群組： 有效與初始群組、groups, newgrp/etc/group 文件結構如下： root:x:0:bin:x:1:daemon:x:2:sys:x:3: 群組名稱：就是群組名稱啦！同樣用來給人類使用的，基本上需要與第三字段的 GID 對應。 群組密碼：通常不需要設置，這個設置通常是給“群組管理員”使用的，目前很少有這個機會設置群組管理員啦！ 同樣的，密碼已經移動到 /etc/gshadow 去，因此這個字段只會存在一個“x”而已； GID：就是群組的 ID 啊。我們 /etc/passwd 第四個字段使用的 GID 對應的群組名，就是由這裡對應出來的！ 此群組支持的帳號名稱：我們知道一個帳號可以加入多個群組，那某個帳號想要加入此群組時，將該帳號填入這個字段即可。 舉例來說，如果我想要讓 dmtsai 與 alex 也加入 root 這個群組，那麼在第一行的最後面加上“dmtsai,alex”，注意不要有空格， 使成為“ root:x:0:dmtsai,alex ”就可以囉～ /etc/gshadow 文件結構 群組名稱 密碼欄，同樣的，開頭為 ! 表示無合法密碼，所以無群組管理員 群組管理員的帳號 (相關信息在 gpasswd 中介紹) 有加入該群組支持的所屬帳號 (與 /etc/group 內容相同！) /etc/passwd 與 /etc/group 與 /etc/shadow 示意圖談完了 /etc/passwd, /etc/shadow, /etc/group 之後，我們可以使用一個簡單的圖示來了解一下 UID / GID 與密碼之間的關係， 圖示如下。其實重點是 /etc/passwd 啦，其他相關的數據都是根據這個文件的字段去找尋出來的。 下圖中， root 的 UID 是 0 ，而 GID 也是 0 ，去找 /etc/group 可以知道 GID 為 0 時的群組名稱就是 root 哩。 至於密碼的尋找中，會找到 /etc/shadow 與 /etc/passwd 內同帳號名稱的那一行，就是密碼相關數據囉。 finger Login：為使用者帳號，亦即 /etc/passwd 內的第一字段； Name：為全名，亦即 /etc/passwd 內的第五字段(或稱為註解)； Directory：就是主文件夾了； Shell：就是使用的 Shell 文件所在； Never logged in.：figner 還會調查使用者登陸主機的情況喔！ No mail.：調查 /var/spool/mail 當中的信箱數據； No Plan.：調查 ~vbird1/.plan 文件，並將該文件取出來說明！ chfnchfn [-foph] [帳號名]選項與參數：-f ：後面接完整的大名；-o ：您辦公室的房間號碼；-p ：辦公室的電話號碼；-h ：家裡的電話號碼！ chage 更詳細的密碼參數顯示功能 可讓使用者在第一次登陸時， 強制她們一定要更改密碼後才能夠使用系統資源 語法chage [-ldEImMW] 帳號名選項與參數：-l ：列出該帳號的詳細密碼參數；-d ：後面接日期，修改 shadow 第三字段(最近一次更改密碼的日期)，格式 YYYY-MM-DD-E ：後面接日期，修改 shadow 第八字段(帳號失效日)，格式 YYYY-MM-DD-I ：後面接天數，修改 shadow 第七字段(密碼失效日期)-m ：後面接天數，修改 shadow 第四字段(密碼最短保留天數)-M ：後面接天數，修改 shadow 第五字段(密碼多久需要進行變更)-W ：後面接天數，修改 shadow 第六字段(密碼過期前警告日期) 範例範例一：列出 vbird2 的詳細密碼參數[root@study ~]# chage -l vbird2Last password change : Jul 20, 2015Password expires : Sep 18, 2015Password inactive : Sep 28, 2015Account expires : neverMinimum number of days between password change : 0Maximum number of days between password change : 60Number of days of warning before password expires : 7 chsh語法：chsh [-ls]選項與參數：-l ：列出目前系統上面可用的 shell ，其實就是 /etc/shells 的內容！-s ：設置修改自己的 Shell 囉 範例範例一：用 vbird1 的身份列出系統上所有合法的 shell，並且指定 csh 為自己的 shell[vbird1@study ~]$ chsh -l/bin/sh/bin/bash/sbin/nologin &lt;==所謂：合法不可登陸的 Shell 就是這玩意！/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh &lt;==這就是 C shell 啦！# 其實上面的信息就是我們在 bash 中談到的 /etc/shells 啦！[vbird1@study ~]$ chsh -s /bin/csh; grep vbird1 /etc/passwdChanging shell for vbird1.Password: &lt;==確認身份，請輸入 vbird1 的密碼Shell changed.vbird1:x:1003:1004:VBird Tsai test,DIC in KSU,06-2727175#356,06-1234567:/home/vbird1:/bin/csh[vbird1@study ~]$ chsh -s /bin/bash# 測試完畢後，立刻改回來！[vbird1@study ~]$ ll $(which chsh)-rws--x--x. 1 root root 23856 Mar 6 13:59 /bin/chsh groupadd語法groupadd [-g gid] [-r] 群組名稱選項與參數：-g ：後面接某個特定的 GID ，用來直接給予某個 GID ～-r ：創建系統群組啦！與 /etc/login.defs 內的 GID_MIN 有關。 範例範例一：新建一個群組，名稱為 group1[root@study ~]# groupadd group1[root@study ~]# grep group1 /etc/group /etc/gshadow/etc/group:group1:x:1503:/etc/gshadow:group1:!::# 群組的 GID 也是會由 1000 以上最大 GID+1 來決定！ groupmod語法groupmod [-g gid] [-n group_name] 群組名選項與參數：-g ：修改既有的 GID 數字；-n ：修改既有的群組名稱 範例範例一：將剛剛上個指令創建的 group1 名稱改為 mygroup ， GID 為 201[root@study ~]# groupmod -g 201 -n mygroup group1[root@study ~]# grep mygroup /etc/group /etc/gshadow/etc/group:mygroup:x:201:/etc/gshadow:mygroup:!:: groupdel語法groupdel [groupname] gpasswd語法系統管理員 (root)gpasswd groupname[root@study ~]# gpasswd [-A user1,...] [-M user3,...] groupname[root@study ~]# gpasswd [-rR] groupname選項與參數： ：若沒有任何參數時，表示給予 groupname 一個密碼(/etc/gshadow)-A ：將 groupname 的主控權交由後面的使用者管理(該群組的管理員)-M ：將某些帳號加入這個群組當中！-r ：將 groupname 的密碼移除-R ：讓 groupname 的密碼欄失效 群組管理員 (Group administrator)gpasswd [-ad] user groupname選項與參數：-a ：將某位使用者加入到 groupname 這個群組當中！-d ：將某位使用者移除出 groupname 這個群組當中。 範例範例一：創建一個新群組，名稱為 testgroup 且群組交由 vbird1 管理：[root@study ~]# groupadd testgroup &lt;==先創建群組[root@study ~]# gpasswd testgroup &lt;==給這個群組一個密碼吧！Changing the password for group testgroupNew Password:Re-enter new password:# 輸入兩次密碼就對了！[root@study ~]# gpasswd -A vbird1 testgroup &lt;==加入群組管理員為 vbird1[root@study ~]# grep testgroup /etc/group /etc/gshadow/etc/group:testgroup:x:1503:/etc/gshadow:testgroup:$6$MnmChP3D$mrUn.Vo.buDjObMm8F2emTkvGSeuWikhRzaKHxpJ...:vbird1:# 很有趣吧！此時 vbird1 則擁有 testgroup 的主控權喔！身份有點像板主啦！ 範例二：以 vbird1 登陸系統，並且讓他加入 vbird1, vbird3 成為 testgroup 成員[vbird1@study ~]$ iduid=1003(vbird1) gid=1004(vbird1) groups=1004(vbird1) ...# 看得出來，vbird1 尚未加入 testgroup 群組喔！[vbird1@study ~]$ gpasswd -a vbird1 testgroup[vbird1@study ~]$ gpasswd -a vbird3 testgroup[vbird1@study ~]$ grep testgroup /etc/grouptestgroup:x:1503:vbird1,vbird3 ACLsetfacl setfacl ：設置某個目錄/文件的 ACL 規範。 語法setfacl [-bkRd] [&#123;-m|-x&#125; acl參數] 目標文件名選項與參數：-m ：設置後續的 acl 參數給文件使用，不可與 -x 合用；-x ：刪除後續的 acl 參數，不可與 -m 合用；-b ：移除“所有的” ACL 設置參數；-k ：移除“默認的” ACL 參數，關於所謂的“默認”參數於後續範例中介紹；-R ：遞迴設置 acl ，亦即包括次目錄都會被設置起來；-d ：設置“默認 acl 參數”的意思！只對目錄有效，在該目錄新建的數據會引用此默認值 getfacl語法getfacl filename選項與參數：# 請列出剛剛我們設置的 acl_test1 的權限內容：[root@study ~]# getfacl acl_test1# file: acl_test1 &lt;==說明文檔名而已！# owner: root &lt;==說明此文件的擁有者，亦即 ls -l 看到的第三使用者字段# group: root &lt;==此文件的所屬群組，亦即 ls -l 看到的第四群組字段user::rwx &lt;==使用者列表欄是空的，代表文件擁有者的權限user:vbird1:r-x &lt;==針對 vbird1 的權限設置為 rx ，與擁有者並不同！group::r-- &lt;==針對文件群組的權限設置僅有 r mask::r-x &lt;==此文件默認的有效權限 (mask)other::r-- &lt;==其他人擁有的權限囉！-m ：設置後續的 acl 參數給文件使用，不可與 -x 合用；-x ：刪除後續的 acl 參數，不可與 -m 合用；-b ：移除“所有的” ACL 設置參數；-k ：移除“默認的” ACL 參數，關於所謂的“默認”參數於後續範例中介紹；-R ：遞迴設置 acl ，亦即包括次目錄都會被設置起來；-d ：設置“默認 acl 參數”的意思！只對目錄有效，在該目錄新建的數據會引用此默認值 顯示的數據前面加上 # 的，代表這個文件的默認屬性，包括文件名、文件擁有者與文件所屬群組。user, group, mask, other 則是屬於不同使用者、群組與有效權限(mask)的設置值。 su語法su [-lm] [-c 指令] [username]選項與參數：- ：單純使用 - 如“ su - ”代表使用 login-shell 的變量文件讀取方式來登陸系統； 若使用者名稱沒有加上去，則代表切換為 root 的身份。-l ：與 - 類似，但後面需要加欲切換的使用者帳號！也是 login-shell 的方式。-m ：-m 與 -p 是一樣的，表示“使用目前的環境設置，而不讀取新使用者的配置文件”-c ：僅進行一次指令，所以 -c 後面可以加上指令喔！ sudo語法sudo [-b] [-u 新使用者帳號]選項與參數：-b ：將後續的指令放到背景中讓系統自行執行，而不與目前的 shell 產生影響-u ：後面可以接欲切換的使用者，若無此項則代表切換身份為 root 。 sudoers更改設置visodu root ALL=(ALL) ALL &lt;==找到這一行，大約在 98 行左右vbird1 ALL=(ALL) ALL &lt;==這一行是你要新增的！ 使用者帳號 登陸者的來源主機名稱=(可切換的身份) 可下達的指令root ALL=(ALL) ALL &lt;==這是默認值 “使用者帳號”：系統的哪個帳號可以使用 sudo 這個指令的意思； “登陸者的來源主機名稱”：當這個帳號由哪部主機連線到本 Linux 主機，意思是這個帳號可能是由哪一部網絡主機連線過來的， 這個設置值可以指定用戶端計算機(信任的來源的意思)。默認值 root 可來自任何一部網絡主機 “(可切換的身份)”：這個帳號可以切換成什麼身份來下達後續的指令，默認 root 可以切換成任何人； “可下達的指令”：可用該身份下達什麼指令？這個指令請務必使用絕對路徑撰寫。 默認 root 可以切換任何身份且進行任何指令之意。那個 ALL 是特殊的關鍵字，代表任何身份、主機或指令的意思。所以，我想讓 vbird1 可以進行任何身份的任何指令， 就如同上表特殊字體寫的那樣，其實就是複製上述默認值那一行，再將 root 改成 vbird1 即可啊！ 此時“vbird1 不論來自哪部主機登陸，他可以變換身份成為任何人，且可以進行系統上面的任何指令”之意。 修改完請儲存後離開 vi，並以 vbird1 登陸系統後，進行如下的測試看看： visudo更改默認編輯器 update-alternatives --config editor PAM 模塊設置語法程序與 PAM 的關係圖 程序調用 PAM 的流程 使用者開始執行 /usr/bin/passwd 這支程序，並輸入密碼； passwd 調用 PAM 模塊進行驗證； PAM 模塊會到 /etc/pam.d/ 找尋與程序 (passwd) 同名的配置文件； 依據 /etc/pam.d/passwd 內的設置，引用相關的 PAM 模塊逐步進行驗證分析； 將驗證結果 (成功、失敗以及其他訊息) 回傳給 passwd 這支程序； passwd 這支程序會根據 PAM 回傳的結果決定下一個動作 (重新輸入新密碼或者通過驗證！) 配置文件內容cat /etc/pam.d/passwd#%PAM-1.0 &lt;==PAM版本的說明而已！auth include system-auth &lt;==每一行都是一個驗證的過程account include system-authpassword substack system-auth-password optional pam_gnome_keyring.so use_authtokpassword substack postlogin驗證類別 控制標準 PAM 模塊與該模塊的參數 驗證類別 (type)驗證類別主要分為四種，分別說明如下： auth是 authentication (認證) 的縮寫，所以這種類別主要用來檢驗使用者的身份驗證，這種類別通常是需要密碼來檢驗的， 所以後續接的模塊是用來檢驗使用者的身份。 accountaccount (帳號) 則大部分是在進行 authorization (授權)，這種類別則主要在檢驗使用者是否具有正確的使用權限， 舉例來說，當你使用一個過期的密碼來登陸時，當然就無法正確的登陸了。 sessionsession 是會議期間的意思，所以 session 管理的就是使用者在這次登陸 (或使用這個指令) 期間，PAM 所給予的環境設置。 這個類別通常用在記錄使用者登陸與登出時的信息！例如，如果你常常使用 su 或者是 sudo 指令的話， 那麼應該可以在 /var/log/secure 裡面發現很多關於 pam 的說明，而且記載的數據是“session open, session close”的信息！ passwordpassword 就是密碼嘛！所以這種類別主要在提供驗證的修訂工作，舉例來說，就是修改/變更密碼啦！這四個驗證的類型通常是有順序的，不過也有例外就是了。 會有順序的原因是，(1)我們總是得要先驗證身份 (auth) 後， (2)系統才能夠藉由使用者的身份給予適當的授權與權限設置 (account)，而且(3)登陸與登出期間的環境才需要設置， 也才需要記錄登陸與登出的信息 (session)。如果在運行期間需要密碼修訂時，(4)才給予 password 的類別。這樣說起來， 自然是需要有點順序吧！ 驗證的控制旗標 (control flag)那麼“驗證的控制旗標(control flag)”又是什麼？簡單的說，他就是“驗證通過的標準”啦！ 這個字段在管控該驗證的放行方式，主要也分為四種控制方式： required此驗證若成功則帶有 success (成功) 的標誌，若失敗則帶有 failure 的標誌，但不論成功或失敗都會繼續後續的驗證流程。 由於後續的驗證流程可以繼續進行，因此相當有利於數據的登錄 (log) ，這也是 PAM 最常使用 required 的原因。 requisite若驗證失敗則立刻回報原程序 failure 的標誌，並終止後續的驗證流程。若驗證成功則帶有 success 的標誌並繼續後續的驗證流程。 這個項目與 required 最大的差異，就在於失敗的時候還要不要繼續驗證下去？由於 requisite 是失敗就終止， 因此失敗時所產生的 PAM 信息就無法通過後續的模塊來記錄了。 sufficient若驗證成功則立刻回傳 success 給原程序，並終止後續的驗證流程；若驗證失敗則帶有 failure 標誌並繼續後續的驗證流程。 這玩意兒與 requisits 剛好相反！ optional這個模塊控制項目大多是在顯示訊息而已，並不是用在驗證方面的。如果將這些控制旗標以圖示的方式配合成功與否的條件繪圖，會有點像下面這樣： 程序運行過程中遇到驗證時才會去調用 PAM ，而 PAM 驗證又分很多類型與控制，不同的控制旗標所回報的訊息並不相同。 如上圖所示， requisite 失敗就回報了並不會繼續，而 sufficient 則是成功就回報了也不會繼續。 至於驗證結束後所回報的信息通常是“succes 或 failure ”而已，後續的流程還需要該程序的判斷來繼續執行才行。 jobs語法[root@study ~]# jobs [-lrs]選項與參數：-l ：除了列出 job number 與指令串之外，同時列出 PID 的號碼；-r ：僅列出正在背景 run 的工作；-s ：僅列出正在背景當中暫停 (stop) 的工作。 fg語法[root@study ~]# fg %jobnumber選項與參數：%jobnumber ：jobnumber 為工作號碼(數字)。注意，那個 % 是可有可無的！ ps語法[root@study ~]# ps aux &lt;==觀察系統所有的程序數據[root@study ~]# ps -lA &lt;==也是能夠觀察所有系統的數據[root@study ~]# ps axjf &lt;==連同部分程序樹狀態選項與參數：-A ：所有的 process 均顯示出來，與 -e 具有同樣的效用；-a ：不與 terminal 有關的所有 process ；-u ：有效使用者 (effective user) 相關的 process ；x ：通常與 a 這個參數一起使用，可列出較完整信息。輸出格式規劃：l ：較長、較詳細的將該 PID 的的信息列出；j ：工作的格式 (jobs format)-f ：做一個更為完整的輸出。 觀察自己的 bash 相關程序ps -l 輸出如下： F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 14830 13970 0 80 0 - 52686 poll_s pts/0 00:00:00 sudo4 S 0 14835 14830 0 80 0 - 50511 wait pts/0 00:00:00 su4 S 0 14836 14835 0 80 0 - 29035 wait pts/0 00:00:00 bash0 R 0 15011 14836 0 80 0 - 30319 - pts/0 00:00:00 ps# 還記得鳥哥說過，非必要不要使用 root 直接登陸吧？從這個 ps -l 的分析，你也可以發現，# 鳥哥其實是使用 sudo 才轉成 root 的身份～否則連測試機，鳥哥都是使用一般帳號登陸的！ 詳解： 系統整體的程序運行是非常多的，但如果使用 ps -l 則僅列出與你的操作環境 (bash) 有關的程序而已， 亦即最上層的父程序會是你自己的 bash 而沒有延伸到 systemd (後續會交待！) 這支程序去！那麼 ps -l 秀出來的數據有哪些呢？ 我們就來觀察看看： F：代表這個程序旗標 (process flags)，說明這個程序的總結權限，常見號碼有： 若為 4 表示此程序的權限為 root ； 若為 1 則表示此子程序僅進行複製(fork)而沒有實際執行(exec)。 S：代表這個程序的狀態 (STAT)，主要的狀態有： R (Running)：該程序正在運行中； S (Sleep)：該程序目前正在睡眠狀態(idle)，但可以被喚醒(signal)。 D ：不可被喚醒的睡眠狀態，通常這支程序可能在等待 I/O 的情況(ex&gt;打印) T ：停止狀態(stop)，可能是在工作控制(背景暫停)或除錯 (traced) 狀態； Z (Zombie)：殭屍狀態，程序已經終止但卻無法被移除至內存外。 UID/PID/PPID：代表“此程序被該 UID 所擁有/程序的 PID 號碼/此程序的父程序 PID 號碼” C：代表 CPU 使用率，單位為百分比； PRI/NI：Priority/Nice 的縮寫，代表此程序被 CPU 所執行的優先順序，數值越小代表該程序越快被 CPU 執行。詳細的 PRI 與 NI 將在下一小節說明。 ADDR/SZ/WCHAN：都與內存有關，ADDR 是 kernel function，指出該程序在內存的哪個部分，如果是個 running 的程序，一般就會顯示“ - ” / SZ 代表此程序用掉多少內存 / WCHAN 表示目前程序是否運行中，同樣的， 若為 - 表示正在運行中。 TTY：登陸者的終端機位置，若為遠端登陸則使用動態終端接口 (pts/n)； TIME：使用掉的 CPU 時間，注意，是此程序實際花費 CPU 運行的時間，而不是系統時間； CMD：就是 command 的縮寫，造成此程序的觸發程序之指令為何。 所以你看到的 ps -l 輸出訊息中，他說明的是：“bash 的程序屬於 UID 為 0 的使用者，狀態為睡眠 (sleep)， 之所以為睡眠因為他觸發了 ps (狀態為 run) 之故。此程序的 PID 為 14836，優先執行順序為 80 ， 下達 bash 所取得的終端接口為 pts/0 ，運行狀態為等待 (wait) 。”這樣已經夠清楚了吧？ 您自己嘗試解析一下那麼 ps 那一行代表的意義為何呢？ ^_^接下來讓我們使用 ps 來觀察一下系統內所有的程序狀態吧！ 觀察系統所有程序ps aux 輸出： USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.2 60636 7948 ? Ss Aug04 0:01 /usr/lib/systemd/systemd ...root 2 0.0 0.0 0 0 ? S Aug04 0:00 [kthreadd].....(中間省略).....root 14830 0.0 0.1 210744 3988 pts/0 S Aug04 0:00 sudo su -root 14835 0.0 0.1 202044 2996 pts/0 S Aug04 0:00 su -root 14836 0.0 0.1 116140 2960 pts/0 S Aug04 0:00 -bash.....(中間省略).....root 18459 0.0 0.0 123372 1380 pts/0 R+ 00:25 0:00 ps aux 詳解： 你會發現 ps -l 與 ps aux 顯示的項目並不相同！在 ps aux 顯示的項目中，各字段的意義為： USER：該 process 屬於那個使用者帳號的？ PID ：該 process 的程序識別碼。 %CPU：該 process 使用掉的 CPU 資源百分比； %MEM：該 process 所佔用的實體內存百分比； VSZ ：該 process 使用掉的虛擬內存量 (KBytes) RSS ：該 process 佔用的固定的內存量 (KBytes) TTY ：該 process 是在那個終端機上面運行，若與終端機無關則顯示 ?，另外， tty1-tty6 是本機上面的登陸者程序，若為 pts/0 等等的，則表示為由網絡連接進主機的程序。 STAT：該程序目前的狀態，狀態顯示與 ps -l 的 S 旗標相同 (R/S/T/Z) START：該 process 被觸發啟動的時間； TIME ：該 process 實際使用 CPU 運行的時間。 COMMAND：該程序的實際指令為何？一般來說，ps aux 會依照 PID 的順序來排序顯示，我們還是以 14836 那個 PID 那行來說明！該行的意義為“ root 執行的 bash PID 為 14836，佔用了 0.1% 的內存容量百分比，狀態為休眠 (S)，該程序啟動的時間為 8 月 4 號，因此啟動太久了， 所以沒有列出實際的時間點。且取得的終端機環境為 pts/0 。”與 ps aux 看到的其實是同一個程序啦！這樣可以理解嗎？ 讓我們繼續使用 ps 來觀察一下其他的信息吧！ top相對於 ps 是擷取一個時間點的程序狀態， top 則可以持續偵測程序運行的狀態！使用方式如下： 語法[root@study ~]# top [-d 數字] | top [-bnp]選項與參數：-d ：後面可以接秒數，就是整個程序畫面更新的秒數。默認是 5 秒；-b ：以批次的方式執行 top ，還有更多的參數可以使用喔！ 通常會搭配數據流重導向來將批次的結果輸出成為文件。-n ：與 -b 搭配，意義是，需要進行幾次 top 的輸出結果。-p ：指定某些個 PID 來進行觀察監測而已。在 top 執行過程當中可以使用的按鍵指令： ? ：顯示在 top 當中可以輸入的按鍵指令； P ：以 CPU 的使用資源排序顯示； M ：以 Memory 的使用資源排序顯示； N ：以 PID 來排序喔！ T ：由該 Process 使用的 CPU 時間累積 (TIME+) 排序。 k ：給予某個 PID 一個訊號 (signal) r ：給予某個 PID 重新制訂一個 nice 值。 q ：離開 top 軟件的按鍵。 pstree語法[root@study ~]# pstree [-A|U] [-up]選項與參數：-A ：各程序樹之間的連接以 ASCII 字符來連接；-U ：各程序樹之間的連接以萬國碼的字符來連接。在某些終端接口下可能會有錯誤；-p ：並同時列出每個 process 的 PID；-u ：並同時列出每個 process 的所屬帳號名稱。 nice語法[root@study ~]# nice [-n 數字] command選項與參數：-n ：後面接一個數值，數值的範圍 -20 ~ 19。 renice語法[root@study ~]# renice [number] PID選項與參數：PID ：某個程序的 ID 啊！ free觀察內存使用情況 語法[root@study ~]# free [-b|-k|-m|-g|-h] [-t] [-s N -c N]選項與參數：-b ：直接輸入 free 時，顯示的單位是 KBytes，我們可以使用 b(Bytes), m(MBytes) k(KBytes), 及 g(GBytes) 來顯示單位喔！也可以直接讓系統自己指定單位 (-h)-t ：在輸出的最終結果，顯示實體內存與 swap 的總量。-s ：可以讓系統每幾秒鐘輸出一次，不間斷的一直輸出的意思！對於系統觀察挺有效！-c ：與 -s 同時處理～讓 free 列出幾次的意思～ 備註[root@study ~]# free -m total used free shared buff/cache availableMem: 2848 346 1794 8 706 2263Swap: 1023 0 1023 名稱 | 意義—-|swap | 內存交換空間的量total | 總量used | 已被使用的量free | 剩餘可用的量shared/buffers/cached | 已被使用的量中，用來作為緩衝及高速緩存的量。 這些用量中，在系統比較忙碌時，可以被釋出而繼續利用 uname查閱系統與核心相關信息 語法[root@study ~]# uname [-asrmpi]選項與參數：-a ：所有系統相關的信息，包括下面的數據都會被列出來；-s ：系統核心名稱-r ：核心的版本-m ：本系統的硬件名稱，例如 i686 或 x86_64 等；-p ：CPU 的類型，與 -m 類似，只是顯示的是 CPU 的類型！-i ：硬件的平臺 (ix86)範例一：輸出系統的基本信息[root@study ~]# uname -aLinux study.centos.vbird 3.10.0-229.el7.x86_64 #1 SMP Fri Mar 6 11:36:42 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux uptime觀察系統啟動時間與工作負載這個指令很單純: 顯示出目前系統已經開機多久的時間 1, 5, 15 分鐘的平均負載這個 uptime 可以顯示出 top 畫面的最上面一行 netstat追蹤網絡或插槽檔 語法[root@study ~]# uname [-asrmpi]選項與參數：-a ：所有系統相關的信息，包括下面的數據都會被列出來；-s ：系統核心名稱-r ：核心的版本-m ：本系統的硬件名稱，例如 i686 或 x86_64 等；-p ：CPU 的類型，與 -m 類似，只是顯示的是 CPU 的類型！-i ：硬件的平臺 (ix86) 備註[root@study ~]# netstatActive Internet connections (w/o servers) &lt;==與網絡較相關的部分Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 172.16.15.100:ssh 172.16.220.234:48300 ESTABLISHEDActive UNIX domain sockets (w/o servers) &lt;==與本機的程序自己的相關性(非網絡)Proto RefCnt Flags Type State I-Node Pathunix 2 [ ] DGRAM 1902 @/org/freedesktop/systemd1/notifyunix 2 [ ] DGRAM 1944 /run/systemd/shutdownd....(中間省略)....unix 3 [ ] STREAM CONNECTED 25425 @/tmp/.X11-unix/X0unix 3 [ ] STREAM CONNECTED 28893unix 3 [ ] STREAM CONNECTED 21262 在上面的結果當中，顯示了兩個部分: 網絡的連線 linux 上面的 socket 程序相關性部分 我們先來看看網際網絡連線情況的部分： Proto ：網絡的封包協定，主要分為 TCP 與 UDP 封包，相關數據請參考服務器篇； Recv-Q：非由使用者程序鏈接到此 socket 的複製的總 Bytes 數； Send-Q：非由遠端主機傳送過來的 acknowledged 總 Bytes 數； Local Address ：本地端的 IP:port 情況 Foreign Address：遠端主機的 IP:port 情況 State ：連線狀態，主要有創建(ESTABLISED)及監聽(LISTEN)； 我們看上面僅有一條連線的數據，他的意義是：“通過 TCP 封包的連線，遠端的 172.16.220.234:48300 連線到本地端的 172.16.15.100:ssh ，這條連線狀態是創建 (ESTABLISHED) 的狀態！”至於更多的網絡環境說明， 就得到鳥哥的另一本服務器篇查閱囉！ socket file: 插槽檔 溝通兩個程序之間的信息 上表中 socket file 的輸出字段: Proto ：一般就是 unix 啦； RefCnt：連接到此 socket 的程序數量； Flags ：連線的旗標； Type ：socket 存取的類型。主要有確認連線的 STREAM 與不需確認的 DGRAM 兩種； State ：若為 CONNECTED 表示多個程序之間已經連線創建。 Path ：連接到此 socket 的相關程序的路徑！或者是相關數據輸出的路徑。 dmesg分析核心產生的訊息 系統在開機的時候，核心會去偵測系統的硬件，你的某些硬件到底有沒有被捉到，那就與這個時候的偵測有關。 dmesg 可以顯示這些偵測的過程 範例範例一：輸出所有的核心開機時的信息 dmesg | less 範例二：搜尋開機的時候，硬盤的相關信息為何？ dmesg | grep -i vda 輸出： [ 0.758551] vda: vda1 vda2 vda3 vda4 vda5 vda6 vda7 vda8 vda9[ 3.964134] XFS (vda2): Mounting V4 Filesystem....(下面省略).... vmstat偵測系統資源變化vmstat 可以偵測“ CPU / 內存 / 磁盤輸入輸出狀態 ”等等 語法[root@study ~]# vmstat [-a] [延遲 [總計偵測次數]] &lt;==CPU/內存等信息[root@study ~]# vmstat [-fs] &lt;==內存相關[root@study ~]# vmstat [-S 單位] &lt;==設置顯示數據的單位[root@study ~]# vmstat [-d] &lt;==與磁盤有關[root@study ~]# vmstat [-p 分區] &lt;==與磁盤有關選項與參數：-a ：使用 inactive/active(活躍與否) 取代 buffer/cache 的內存輸出信息；-f ：開機到目前為止，系統複製 (fork) 的程序數；-s ：將一些事件 (開機至目前為止) 導致的內存變化情況列表說明；-S ：後面可以接單位，讓顯示的數據有單位。例如 K/M 取代 Bytes 的容量；-d ：列出磁盤的讀寫總量統計表-p ：後面列出分區，可顯示該分區的讀寫總量統計表 範例範例一：統計目前主機 CPU 狀態，每秒一次，共計三次！vmstat 1 3 範例輸出： 範例二：系統上面所有的磁盤的讀寫狀態vmstat -d 範例輸出： 利用 vmstat 甚至可以進行追蹤喔！你可以使用類似“ vmstat 5 ”代表每五秒鐘更新一次，且無窮的更新！直到你按下 [ctrl]-c 為止。如果你想要實時的知道系統資源的運行狀態，這個指令就不能不知道！那麼上面的表格各項字段的意義為何？ 基本說明如下： 程序字段 (procs) 的項目分別為： r ：等待運行中的程序數量； b：不可被喚醒的程序數量。這兩個項目越多，代表系統越忙碌 (因為系統太忙，所以很多程序就無法被執行或一直在等待而無法被喚醒之故)。 內存字段 (memory) 項目分別為： swpd：虛擬內存被使用的容量； free：未被使用的內存容量； buff：用於緩衝內存； cache：用於高速緩存內存。 這部份則與 free 是相同的。 內存交換空間 (swap) 的項目分別為： si：由磁盤中將程序取出的量； so：由於內存不足而將沒用到的程序寫入到磁盤的 swap 的容量。 如果 si/so 的數值太大，表示內存內的數據常常得在磁盤與內存之間傳來傳去，系統性能會很差！ 磁盤讀寫 (io) 的項目分別為： bi：由磁盤讀入的區塊數量； bo：寫入到磁盤去的區塊數量。如果這部份的值越高，代表系統的 I/O 非常忙碌！ 系統 (system) 的項目分別為： in：每秒被中斷的程序次數； cs：每秒鐘進行的事件切換次數；這兩個數值越大，代表系統與周邊設備的溝通非常頻繁！ 這些周邊設備當然包括磁盤、網卡、時間鍾等。 CPU 的項目分別為： us：非核心層的 CPU 使用狀態； sy：核心層所使用的 CPU 狀態； id：閒置的狀態； wa：等待 I/O 所耗費的 CPU 狀態； st：被虛擬機 (virtual machine) 所盜用的 CPU 使用狀態 (2.6.11 以後才支持)。 /proc基本上，目前主機上面的各個程序的 PID 都是以目錄的型態存在於 /proc 當中。 舉例來說，我們開機所執行的第一支程序 systemd 他的 PID 是 1 ， 這個 PID 的所有相關信息都寫入在 /proc/1/* 當中！若我們直接觀察 PID 為 1 的數據好了，他有點像這樣： 文件內容文件名 | 文件內容——|/proc/cmdline | 載入 kernel 時所下達的相關指令與參數！查閱此文件，可瞭解指令是如何啟動的！/proc/cpuinfo | 本機的 CPU 的相關信息，包含頻率、類型與運算功能等/proc/devices | 這個文件記錄了系統各個主要設備的主要設備代號，與 mknod 有關呢！/proc/filesystems | 目前系統已經載入的文件系統囉！/proc/interrupts | 目前系統上面的 IRQ 分配狀態。/proc/ioports | 目前系統上面各個設備所配置的 I/O 位址。/proc/kcore | 這個就是內存的大小啦！好大對吧！但是不要讀他啦！/proc/loadavg | 還記得 top 以及 uptime 吧？沒錯！上頭的三個平均數值就是記錄在此！/proc/meminfo | 使用 free 列出的內存信息，嘿嘿！在這裡也能夠查閱到！/proc/modules | 目前我們的 Linux 已經載入的模塊列表，也可以想成是驅動程序啦！/proc/mounts | 系統已經掛載的數據，就是用 mount 這個指令調用出來的數據啦！/proc/swaps | 到底系統掛載入的內存在哪裡？呵呵！使用掉的 partition 就記錄在此啦！/proc/partitions | 使用 fdisk -l 會出現目前所有的 partition 吧？在這個文件當中也有紀錄喔！/proc/uptime | 就是用 uptime 的時候，會出現的信息啦！/proc/version | 核心的版本，就是用 uname -a 顯示的內容啦！/proc/bus/* | 一些總線的設備，還有 USB 的設備也記錄在此喔！ fuser藉由文件(或文件系統)找出正在使用該文件的程序 語法[root@study ~]# fuser [-umv] [-k [i] [-signal]] file/dir選項與參數：-u ：除了程序的 PID 之外，同時列出該程序的擁有者；-m ：後面接的那個文件名會主動的上提到該文件系統的最頂層，對 umount 不成功很有效！-v ：可以列出每個文件與程序還有指令的完整相關性！-k ：找出使用該文件/目錄的 PID ，並試圖以 SIGKILL 這個訊號給予該 PID；-i ：必須與 -k 配合，在刪除 PID 之前會先詢問使用者意願！-signal：例如 -1 -15 等等，若不加的話，默認是 SIGKILL (-9) 囉！ 範例範例一：找出目前所在目錄的使用 PID/所屬帳號/權限 為何？[root@study ~]# fuser -uv . USER PID ACCESS COMMAND/root: root 13888 ..c.. (root)bash root 31743 ..c.. (root)bash``` 範例二：找到所有使用到 /proc 這個文件系統的程序吧！[root@study ~]# fuser -uv /proc/proc: root kernel mount (root)/proc rtkit 768 .rc.. (rtkit)rtkit-daemon 數據量還不會很多，雖然這個目錄很繁忙～沒關係！我們可以繼續這樣作，看看其他的程序！[root@study ~]# fuser -mvu /proc USER PID ACCESS COMMAND/proc: root kernel mount (root)/proc root 1 f…. (root)systemd root 2 …e. (root)kthreadd…..(下面省略)….. 有這幾支程序在進行 /proc 文件系統的存取喔！這樣清楚了嗎？ 範例三：找到所有使用到 /home 這個文件系統的程序吧！[root@study ~]# echo $$31743 # 先確認一下，自己的 bash PID 號碼吧！[root@study ~]# cd /home[root@study home]# fuser -muv . USER PID ACCESS COMMAND/home: root kernel mount (root)/home dmtsai 31535 ..c.. (dmtsai)bash root 31571 ..c.. (root)passwd root 31737 ..c.. (root)sudo root 31743 ..c.. (root)bash # 果然，自己的 PID 在啊！[root@study home]# cd ~[root@study ~]# umount /homeumount: /home: target is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1)) 從 fuser 的結果可以知道，總共有五隻 process 在該目錄下運行，那即使 root 離開了 /home，當然還是無法 umount 的！那要怎辦？哈哈！可以通過如下方法一個一個刪除～[root@study ~]# fuser -mki /home/home: 31535c 31571c 31737c # 你會發現， PID 跟上面查到的相同！Kill process 31535 ? (y/N) # 這裡會問你要不要刪除！當然不要亂刪除啦！通通取消！ &lt;br/&gt;### 那個 ACCESS 的項目，那個項目代表的意義為：- c ：此程序在當前的目錄下(非次目錄)；- e ：可被觸發為執行狀態；- f ：是一個被打開的文件；- r ：代表頂層目錄 (root directory)；- F ：該文件被打開了，不過在等待迴應中；- m ：可能為分享的動態函數庫；## lsof列出被程序所打開的文件文件名&lt;br/&gt;### 語法 lsof [-aUu] [+d]選項與參數：-t ：terse, 簡短輸出, 可以輸出符合 kill 的參數-a ：多項數據需要“同時成立”才顯示出結果時！-U ：僅列出 Unix like 系統的 socket 文件類型；-u ：後面接 username，列出該使用者相關程序所打開的文件；+d ：後面接目錄，亦即找出某個目錄下面已經被打開的文件！ ## pidof找出某支正在執行的程序的 PID&lt;br/&gt;### 語法 pidof [-sx] program_name選項與參數：-s ：僅列出一個 PID 而不列出所有的 PID-x ：同時列出該 program name 可能的 PPID 那個程序的 PID ## systemd### systemd 的配置文件放置目錄`/usr/lib/systemd/system/`：每個服務最主要的啟動腳本設置，有點類似以前的 /etc/init.d 下面的文件；`/run/systemd/system/`：系統執行過程中所產生的服務腳本，這些腳本的優先序要比 /usr/lib/systemd/system/ 高！`/etc/systemd/system/`：管理員依據主機系統的需求所創建的執行腳本，其實這個目錄有點像以前 /etc/rc.d/rc5.d/Sxx 之類的功能！執行優先序又比 /run/systemd/system/ 高喔！&lt;br/&gt;### systemd 服務類型擴展名 | 主要服務功能------|.service | 一般服務類型 (service unit)：主要是系統服務，包括服務器本身所需要的本機服務以及網絡服務都是！比較經常被使用到的服務大多是這種類型！ 所以，這也是最常見的類型了！.socket | 內部程序數據交換的插槽服務 (socket unit)：主要是 IPC (Inter-process communication) 的傳輸訊息插槽檔 (socket file) 功能。 這種類型的服務通常在監控訊息傳遞的插槽檔，當有通過此插槽檔傳遞訊息來說要鏈接服務時，就依據當時的狀態將該用戶的要求傳送到對應的 daemon， 若 daemon 尚未啟動，則啟動該 daemon 後再傳送用戶的要求。&lt;br/&gt;使用 socket 類型的服務一般是比較不會被用到的服務，因此在開機時通常會稍微延遲啟動的時間 (因為比較沒有這麼常用嘛！)。一般用於本機服務比較多，例如我們的圖形界面很多的軟件都是通過 socket 來進行本機程序數據交換的行為。 (這與早期的 xinetd 這個 super daemon 有部份的相似喔！).target | 執行環境類型 (target unit)：其實是一群 unit 的集合，例如上面表格中談到的 multi-user.target 其實就是一堆服務的集合～也就是說， 選擇執行 multi-user.target, 就是執行一堆其他 .service 或/及 .socket 之類的服務就是了！.mount &lt;br/&gt; .automount | 文件系統掛載相關的服務 (automount unit / mount unit)：例如來自網絡的自動掛載、NFS 文件系統掛載等與文件系統相關性較高的程序管理。.path | 偵測特定文件或目錄類型 (path unit)：某些服務需要偵測某些特定的目錄來提供佇列服務，例如最常見的打印服務，就是通過偵測打印佇列目錄來啟動打印功能！ 這時就得要 .path 的服務類型支持了！.timer | 循環執行的服務 (timer unit)：這個東西有點類似 anacrontab 喔！不過是由 systemd 主動提供的，比 anacrontab 更加有彈性！&lt;br/&gt;### systemctl管理單一服務 (service unit) 的啟動/開機啟動與觀察狀態&lt;br/&gt;#### 語法 systemctl [command] [unit]command 主要有：start ：立刻啟動後面接的 unitstop ：立刻關閉後面接的 unitrestart ：立刻關閉後啟動後面接的 unit，亦即執行 stop 再 start 的意思reload ：不關閉後面接的 unit 的情況下，重新載入配置文件，讓設置生效enable ：設置下次開機時，後面接的 unit 會被啟動disable ：設置下次開機時，後面接的 unit 不會被啟動status ：目前後面接的這個 unit 的狀態，會列出有沒有正在執行、開機默認執行否、登錄等信息等！is-active ：目前有沒有正在運行中is-enable ：開機時有沒有默認要啟用這個 unitis-enable ：開機時有沒有默認要啟用這個 unit systemctl [command] [–type=TYPE] [–all]command: list-units ：依據 unit 列出目前有啟動的 unit。若加上 –all 才會列出沒啟動的。 list-unit-files ：依據 /usr/lib/systemd/system/ 內的文件，將所有文件列表說明。–type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等 &lt;br/&gt;#### unit 狀態 systemctl list-units UNIT | LOAD | ACTIVE | SUB | DESCRIPTION---|---|---|---|proc-sys-fs-binfmt_mis... | loaded | active | waiting | Arbitrary Executable File Formats File System||| |sys-devices-pc...:0:1:... | loaded | active | plugged | QEMU_HARDDISKsys-devices-pc...0:1-0... | loaded | active | plugged | QEMU_HARDDISKsys-devices-pc...0:0-1... | loaded | active | plugged | QEMU_DVD-ROM.....(中間省略).....vsftpd.service | loaded | active | running | Vsftpd ftp daemon.....(中間省略).....cups.socket | loaded | failed | failed | CUPS Printing Service Sockets.....(中間省略).....LOAD = Reflects whether the unit definition was properly loaded.ACTIVE = The high-level unit activation state, i.e. generalization of SUB.SUB = The low-level unit activation state, values depend on unit type.141 loaded units listed. Pass --all to see loaded but inactive units, too.To show all installed unit files use &#x27;systemctl list-unit-files&#x27;.列出的項目中，主要的意義是：- UNIT ：項目的名稱，包括各個 unit 的類別 (看擴展名)- LOAD ：開機時是否會被載入，默認 systemctl 顯示的是有載入的項目而已喔！- ACTIVE ：目前的狀態，須與後續的 SUB 搭配！就是我們用 systemctl status 觀察時，active 的項目！- DESCRIPTION ：詳細描述囉- cups 比較有趣，因為剛剛被我們玩過，所以 ACTIVE 竟然是 failed 的喔！被玩死了！ ^_^- 另外，systemctl 都不加參數，其實默認就是 list-units 的意思！&lt;br/&gt;#### active 狀態狀態 | 解釋-----------------|active (running)| 正有一隻或多隻程序正在系統中執行的意思，舉例來說，正在執行中的 vsftpd 就是這種模式。active (exited)| 僅執行一次就正常結束的服務，目前並沒有任何程序在系統中執行。 舉例來說，開機或者是掛載時才會進行一次的 quotaon 功能，就是這種模式！ quotaon 不須一直執行～只須執行一次之後，就交給文件系統去自行處理囉！通常用 bash shell 寫的小型服務，大多是屬於這種類型 (無須常駐內存)。active (waiting)| 正在執行當中，不過還再等待其他的事件才能繼續處理。舉例來說，打印的佇列相關服務就是這種狀態！ 雖然正在啟動中，不過，也需要真的有佇列進來 (打印工作) 這樣他才會繼續喚醒打印機服務來進行下一步打印的功能。inactive| 這個服務目前沒有運行的意思。&lt;br/&gt;#### daemon 默認狀態狀態 | 解釋----|enabled | 這個 daemon 將在開機時被執行disabled | 這個 daemon 在開機時不會被執行static | 這個 daemon 不可以自己啟動 (enable 不可)，不過可能會被其他的 enabled 的服務來喚醒 (相依屬性的服務)mask | 這個 daemon 無論如何都無法被啟動！因為已經被強制註銷 (非刪除)。可通過 systemctl unmask 方式改回原本狀態&lt;br/&gt;#### 管理不同的操作環境```bashsystemctl list-units --type=target --all UNIT LOAD ACTIVE SUB DESCRIPTIONbasic.target loaded active active Basic Systemcryptsetup.target loaded active active Encrypted Volumesemergency.target loaded inactive dead Emergency Modefinal.target loaded inactive dead Final Stepgetty.target loaded active active Login Promptsgraphical.target loaded active active Graphical Interfacelocal-fs-pre.target loaded active active Local File Systems (Pre)local-fs.target loaded active active Local File Systemsmulti-user.target loaded active active Multi-User Systemnetwork-online.target loaded inactive dead Network is Onlinenetwork.target loaded active active Networknss-user-lookup.target loaded inactive dead User and Group Name Lookupspaths.target loaded active active Pathsremote-fs-pre.target loaded active active Remote File Systems (Pre)remote-fs.target loaded active active Remote File Systemsrescue.target loaded inactive dead Rescue Modeshutdown.target loaded inactive dead Shutdownslices.target loaded active active Slicessockets.target loaded active active Socketssound.target loaded active active Sound Cardswap.target loaded active active Swapsysinit.target loaded active active System Initializationsyslog.target not-found inactive dead syslog.targettime-sync.target loaded inactive dead System Time Synchronizedtimers.target loaded active active Timersumount.target loaded inactive dead Unmount All FilesystemsLOAD = Reflects whether the unit definition was properly loaded.ACTIVE = The high-level unit activation state, i.e. generalization of SUB.SUB = The low-level unit activation state, values depend on unit type.26 loaded units listed.To show all installed unit files use &#x27;systemctl list-unit-files&#x27;. graphical.target：就是文字加上圖形界面，這個項目已經包含了下面的 multi-user.target 項目！ multi-user.target：純文本模式！ rescue.target：在無法使用 root 登陸的情況下，systemd 在開機時會多加一個額外的暫時系統，與你原本的 系統無關。這時你可以取得 root 的權限來維護你的系統。 但是這是額外系統，因此可能需要動到 chroot 的方式來取得你原有的系統喔！ emergency.target：緊急處理系統的錯誤，還是需要使用 root 登陸的情況，在無法使用 rescue.target 時，可以嘗試使用這種模式！ shutdown.target：就是關機的流程。 getty.target：可以設置你需要幾個 tty 之類的，如果想要降低 tty 的項目，可以修改這個東西的配置文件！ 取得目前的操作環境以及修改systemctl [command] [unit.target]選項與參數：command: get-default ：取得目前的 target set-default ：設置後面接的 target 成為默認的操作模式 isolate ：切換到後面接的模式 範例範例一：我們的測試機器默認是圖形界面，先觀察是否真為圖形模式，再將默認模式轉為文字界面 [root@study ~]# systemctl get-default graphical.target # 果然是圖形界面喔！[root@study ~]# systemctl set-default multi-user.target[root@study ~]# systemctl get-default multi-user.target 範例二：在不重新開機的情況下，將目前的操作環境改為純文本模式，關掉圖形界面 [root@study ~]# systemctl isolate multi-user.target 範例三：若需要重新取得圖形界面呢？ [root@study ~]# systemctl isolate graphical.target 要注意，改變 graphical.target 以及 multi-user.target 是通過 isolate 來處理的。 在正常的切換情況下，使用上述 isolate 的方式即可。不過為了方便起見， systemd 也提供了數個簡單的指令給我們切換操作模式之用喔！ 大致上如下所示： systemctl 針對機器操作的幾個簡單指令[root@study ~]# systemctl poweroff 系統關機[root@study ~]# systemctl reboot 重新開機[root@study ~]# systemctl suspend 進入暫停模式[root@study ~]# systemctl hibernate 進入休眠模式[root@study ~]# systemctl rescue 強制進入救援模式[root@study ~]# systemctl emergency 強制進入緊急救援模式 suspend：暫停模式會將系統的狀態數據保存到內存中，然後關閉掉大部分的系統硬件，當然，並沒有實際關機喔！ 當使用者按下喚醒機器的按鈕，系統數據會重內存中回覆，然後重新驅動被大部分關閉的硬件，就開始正常運行！喚醒的速度較快。 hibernate：休眠模式則是將系統狀態保存到硬盤當中，保存完畢後，將計算機關機。當使用者嘗試喚醒系統時，系統會開始正常運行， 然後將保存在硬盤中的系統狀態恢復回來。因為數據是由硬盤讀出，因此喚醒的性能與你的硬盤速度有關。 通過 systemctl 分析各服務之間的相依性[root@study ~]# systemctl list-dependencies [unit] [--reverse]選項與參數：--reverse ：反向追蹤誰使用這個 unit 的意思！ 範例範例一：列出目前的 target 環境下，用到什麼特別的 unit [root@study ~]# systemctl get-defaultmulti-user.target[root@study ~]# systemctl list-dependenciesdefault.target├─abrt-ccpp.service├─abrt-oops.service├─vsftpd.service├─basic.target│ ├─alsa-restore.service│ ├─alsa-state.service.....(中間省略).....│ ├─sockets.target│ │ ├─avahi-daemon.socket│ │ ├─dbus.socket.....(中間省略).....│ ├─sysinit.target│ │ ├─dev-hugepages.mount│ │ ├─dev-mqueue.mount.....(中間省略).....│ └─timers.target│ └─systemd-tmpfiles-clean.timer├─getty.target│ └─getty@tty1.service└─remote-fs.target 如果要查出誰會用到 multi-user.target 呢？ systemctl list-dependencies --reversedefault.target└─graphical.target graphical.target 又使用了多少的服務呢？ systemctl list-dependencies graphical.targetgraphical.target├─accounts-daemon.service├─gdm.service├─network.service├─rtkit-daemon.service├─systemd-update-utmp-runlevel.service└─multi-user.target ├─abrt-ccpp.service ├─abrt-oops.service.....(下面省略)..... process substitution &lt;( command ) or &gt;( command )如果使用 &gt;(list), 那帶入的值將會作為 list 的輸入。 若使用 &lt;(list), 那將會是 list 的輸出 語法&lt;(list) 或是 &gt;(list) logrotate那個 logrotate.conf 才是主要的參數文件，至於 logrotate.d 是一個目錄， 該目錄裡面的所有文件都會被主動的讀入 /etc/logrotate.conf 當中來進行！另外，在 /etc/logrotate.d/ 裡面的文件中，如果沒有規定到的一些細部設置，則以 /etc/logrotate.conf 這個文件的規定來指定為默認值！ logrotate 這個程序的參數配置文件位置/etc/logrotate.conf/etc/logrotate.d/ 語法logrotate [-vf] logfile選項與參數：-v ：啟動顯示模式，會顯示 logrotate 運行的過程喔！-f ：不論是否符合配置文件的數據，強制每個登錄文件都進行 rotate 的動作！範例一：執行一次 logrotate 看看整個流程為何？[root@study ~]# logrotate -v /etc/logrotate.confreading config file /etc/logrotate.conf &lt;==讀取主要配置文件including /etc/logrotate.d &lt;==調用外部的設置reading config file chrony &lt;==就是外部設置啊！....(中間省略)....Handling 18 logs &lt;==共有 18 個登錄文件被記錄....(中間省略)....rotating pattern: /var/log/cron/var/log/maillog/var/log/messages/var/log/secure/var/log/spooler weekly (52 rotations)empty log files are not rotated, old logs are removedconsidering log /var/log/cron log does not need rotatingconsidering log /var/log/maillog log does not need rotatingconsidering log /var/log/messages &lt;==開始處理 messages log does not need rotating &lt;==因為時間未到，不需要更動！....(下面省略)....範例二：強制進行 logrotate 的動作[root@study ~]# logrotate -vf /etc/logrotate.conf....(前面省略)....rotating log /var/log/messages, log-&gt;rotateCount is 52dateext suffix &#x27;-20150820&#x27;glob pattern &#x27;-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]&#x27;compressing log with: /bin/gzip....(下面省略)....# 看到否？整個 rotate 的動作就是這樣一步一步進行的～[root@study ~]# ll /var/log/messages*; lsattr /var/log/messages-rw-------. 1 root root 143 Aug 20 01:45 /var/log/messages-rw-------. 1 root root 167125 Aug 20 01:40 /var/log/messages-20150820-----a---------- /var/log/messages &lt;==主動加入 a 的隱藏屬性囉！ [root@study ~]# vim /etc/logrotate.conf# 下面的設置是 &quot;logrotate 的默認設置值&quot; ，如果個別的文件設置了其他的參數，# 則將以個別的文件設置為主，若該文件沒有設置到的參數則以這個文件的內容為默認值！weekly &lt;==默認每個禮拜對登錄文件進行一次 rotate 的工作rotate 4 &lt;==保留幾個登錄文件呢？默認是保留四個！create &lt;==由於登錄文件被更名，因此創建一個新的來繼續儲存之意！dateext &lt;==就是這個設置值！可以讓被輪替的文件名稱加上日期作為文件名喔！#compress &lt;==被更動的登錄文件是否需要壓縮？如果登錄文件太大則可考慮此參數啟動include /etc/logrotate.d# 將 /etc/logrotate.d/ 這個目錄中的所有文件都讀進來執行 rotate 的工作！/var/log/wtmp &#123; &lt;==僅針對 /var/log/wtmp 所設置的參數 monthly &lt;==每個月一次，取代每週！ create 0664 root utmp &lt;==指定新建文件的權限與所屬帳號/群組 minsize 1M &lt;==文件大小一定要超過 1M 後才進行 rotate (略過時間參數) rotate 1 &lt;==僅保留一個，亦即僅有 wtmp.1 保留而已。&#125;# 這個 wtmp 可記錄登陸者與系統重新開機時的時間與來源主機及登陸期間的時間。# 由於具有 minsize 的參數，因此不見得每個月一定會進行一次喔！要看文件大小。# 由於僅保留一個登錄文件而已，不滿意的話可以將他改成 rotate 5 吧！ 範例範例 1/root/.pm2/logs/run-checkEdgeAlive.log &#123; daily dateext missingok rotate 14 compress notifempty&#125; 範例 2以 /etc/logrotate.d/syslog 這個輪替 rsyslog.service 服務的文件 vim /etc/logrotate.d/syslog/var/log/cron/var/log/maillog/var/log/messages/var/log/secure/var/log/spooler&#123; sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true endscript&#125; 文件名：被處理的登錄文件絕對路徑文件名寫在前面，可以使用空白字符分隔多個登錄文件； 參數：上述文件名進行輪替的參數使用 { } 包括起來； 執行腳本：可調用外部指令來進行額外的命令下達，這個設置需與 sharedscripts …. endscript 設置合用才行。至於可用的環境為： prerotate：在啟動 logrotate 之前進行的指令，例如修改登錄文件的屬性等動作； postrotate：在做完 logrotate 之後啟動的指令，例如重新啟動 (kill -HUP) 某個服務！ Prerotate 與 postrotate 對於已加上特殊屬性的文件處理上面，是相當重要的執行程序！ 那麼 /etc/logrotate.d/syslog 內設置的 5 個文件的輪替功能就變成了： 該設置只對 /var/log/ 內的 cron, maillog, messages, secure, spooler 有效； 登錄文件輪替每週一次、保留四個、且輪替下來的登錄文件不進行壓縮(未更改默認值)； 輪替完畢後 (postrotate) 取得 syslog 的 PID 後，以 kill -HUP 重新啟動 syslogd 假設我們有針對 /var/log/messages 這個文件增加 chattr +a 的屬性時， 依據 logrotate 的工作原理，我們知道，這個 /var/log/messages 將會被更名成為 /var/log/messages.1 才是。但是由於加上這個 +a 的參數啊，所以更名是不可能成功的！ 那怎麼辦呢？呵呵！就利用 prerotate 與 postrotate 來進行登錄文件輪替前、後所需要作的動作啊！ 果真如此時，那麼你可以這樣修改一下這個文件喔！ vim /etc/logrotate.d/syslog/var/log/cron/var/log/maillog/var/log/messages/var/log/secure/var/log/spooler&#123; sharedscripts prerotate /usr/bin/chattr -a /var/log/messages endscript sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true /usr/bin/chattr +a /var/log/messages endscript&#125; 先給他去掉 a 這個屬性，讓登錄文件 /var/log/messages 可以進行輪替的動作 然後執行了輪替之後，再給他加入這個屬性 /bin/kill -HUP … 的意義，這一行的目的在於將系統的 rsyslogd 重新以其參數文件 (rsyslog.conf) 的數據讀入一次！也可以想成是 reload 的意思！ 由於我們創建了一個新的空的記錄文件，如果不執行此一行來重新啟動服務的話， 那麼記錄的時候將會發生錯誤呦！ kill -HUP: 等同 kill -1, 重啟的意思 範例 3假設你已經創建了 /var/log/admin.log 這個文件， 現在，你想要將該文件加上 +a 這個隱藏標籤，而且設置下面的相關信息： 登錄文件輪替一個月進行一次； 該登錄文件若大於 10MB 時，則主動進行輪替，不需要考慮一個月的期限； 保存五個備份文件； 備份文件需要壓縮 先創建 +a 這個屬性[root@study ~]# chattr +a /var/log/admin.log[root@study ~]# lsattr /var/log/admin.log-----a---------- /var/log/admin.log[root@study ~]# mv /var/log/admin.log /var/log/admin.log.1mv: cannot move `/var/log/admin.log&#x27; to `/var/log/admin.log.1&#x27;: Operation not permitted# 這裡確定了加入 a 的隱藏屬性！所以 root 無法移動此登錄文件！ 開始創建 logrotate 的配置文件，增加一個文件在 /etc/logrotate.d 內[root@study ~]# vim /etc/logrotate.d/admin# This configuration is from VBird 2015/08/19/var/log/admin.log &#123; monthly &lt;==每個月進行一次 size=10M &lt;==文件大小大於 10M 則開始處置 rotate 5 &lt;==保留五個！ compress &lt;==進行壓縮工作！ sharedscripts prerotate /usr/bin/chattr -a /var/log/admin.log endscript sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true /usr/bin/chattr +a /var/log/admin.log endscript&#125; 測試一下 logrotate 相關功能的信息顯示：[root@study ~]# logrotate -v /etc/logrotate.conf....(前面省略)....rotating pattern: /var/log/admin.log 10485760 Bytes (5 rotations)empty log files are rotated, old logs are removedconsidering log /var/log/admin.log log does not need rotatingnot running prerotate script, since no logs will be rotatednot running postrotate script, since no logs were rotated....(下面省略)....# 因為還不足一個月，文件也沒有大於 10M，所以不需進行輪替！ 測試一下強制 logrotate 與相關功能的信息顯示：[root@study ~]# logrotate -vf /etc/logrotate.d/adminreading config file /etc/logrotate.d/adminreading config file /etc/logrotate.d/adminHandling 1 logsrotating pattern: /var/log/admin.log forced from command line (5 rotations)empty log files are rotated, old logs are removedconsidering log /var/log/admin.log log needs rotatingrotating log /var/log/admin.log, log-&gt;rotateCount is 5dateext suffix &#x27;-20150820&#x27;glob pattern &#x27;-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]&#x27;renaming /var/log/admin.log.5.gz to /var/log/admin.log.6.gz (rotatecount 5, logstart 1, i 5),old log /var/log/admin.log.5.gz does not existrenaming /var/log/admin.log.4.gz to /var/log/admin.log.5.gz (rotatecount 5, logstart 1, i 4),old log /var/log/admin.log.4.gz does not existrenaming /var/log/admin.log.3.gz to /var/log/admin.log.4.gz (rotatecount 5, logstart 1, i 3),old log /var/log/admin.log.3.gz does not existrenaming /var/log/admin.log.2.gz to /var/log/admin.log.3.gz (rotatecount 5, logstart 1, i 2),old log /var/log/admin.log.2.gz does not existrenaming /var/log/admin.log.1.gz to /var/log/admin.log.2.gz (rotatecount 5, logstart 1, i 1),old log /var/log/admin.log.1.gz does not existrenaming /var/log/admin.log.0.gz to /var/log/admin.log.1.gz (rotatecount 5, logstart 1, i 0),old log /var/log/admin.log.0.gz does not existlog /var/log/admin.log.6.gz doesn&#x27;t exist -- won&#x27;t try to dispose of itrunning prerotate scriptfscreate context set to system_u:object_r:var_log_t:s0renaming /var/log/admin.log to /var/log/admin.log.1running postrotate scriptcompressing log with: /bin/gzip[root@study ~]# lsattr /var/log/admin.log*-----a---------- /var/log/admin.log---------------- /var/log/admin.log.1.gz &lt;==有壓縮過喔！ command || true patten目前大部分的系統遵循 set -e (Exit immediately if a command exits with a non-zero status.) 規則，所以為了避免一些小錯誤中斷了 command 的執行，所以使用 command || true patten例如 rmdir ... || true, 這樣就算 remove directory 失敗了， command 也不會中斷執行。 timedatectl語法timedatectl [commamd]選項與參數：list-timezones ：列出系統上所有支持的時區名稱set-timezone ：設置時區位置set-time ：設置時間set-ntp ：設置網絡校時系統 範例顯示目前的時區與時間等信息 指令 timedatectl 輸出 Local time: Tue 2015-09-01 19:50:09 CST # 本地時間 Universal time: Tue 2015-09-01 11:50:09 UTC # UTC 時間，可稱為格林威治標準時間 RTC time: Tue 2015-09-01 11:50:12 Timezone: Asia/Taipei (CST, +0800) # 就是時區囉！ NTP enabled: noNTP synchronized: no RTC in local TZ: no DST active: n/a 顯示出是否有 New_York 時區？若有，則請將目前的時區更新一下 查詢是否有 New York 時區timedatectl list-timezones | grep -i new 輸出: America/New_YorkAmerica/North_Dakota/New_Salem 設定時區 timedatectl set-timezone &quot;America/New_York&quot; 確認結果 timedatectl 範例輸出： Local time: Tue 2015-09-01 07:53:24 EDTUniversal time: Tue 2015-09-01 11:53:24 UTC RTC time: Tue 2015-09-01 11:53:28 Timezone: America/New_York (EDT, -0400) 時間點調整 指令 timedatectl set-time &quot;2019-09-30 09:00&quot; 時間格式: yyyy-mm-dd HH:MM ntpdatentpdate tock.stdtime.gov.tw hwclock -w 上述的 tock.stdtime.gov.tw 指的是臺灣地區國家標準實驗室提供的時間服務器，如果你在臺灣本島上，建議使用臺灣提供的時間服務器來更新你的服務器時間， 速度會比較快些～至於 hwclock 則是將正確的時間寫入你的 BIOS 時間記錄內！如果確認可以執行，未來應該可以使用 crontab 來更新系統時間吧！ locale on MacOS 打開 .zshrc, 並貼上以下代碼 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 保存離開 重開一個 terminal 視窗 localectl語法localectl System Locale: LANG=zh_TW.utf8 # 下面這些數據就是“系統語系” LC_NUMERIC=zh_TW.UTF-8 LC_TIME=zh_TW.UTF-8 LC_MONETARY=zh_TW.UTF-8 LC_PAPER=zh_TW.UTF-8 LC_MEASUREMENT=zh_TW.UTF-8 VC Keymap: cn X11 Layout: cn X11 Options: grp:ctrl_shift_toggle[root@study ~]# localeLANG=zh_TW.utf8 # 下面的則是“當前這個軟件的語系”數據！LC_CTYPE=&quot;en_US.utf8&quot;LC_NUMERIC=&quot;en_US.utf8&quot;.....(中間省略).....LC_ALL=en_US.utf8 範例如何改成英文語系的登陸界面？ localectl set-locale LANG=en_US.utf8systemctl isolate multi-user.targetsystemctl isolate graphical.target dpkg列出所有 dpkg 安裝的套件dpkg -l | less teetee 可以讓 standard output 轉存一份到文件內並將同樣的數據繼續送到屏幕去處理！ 這樣除了可以讓我們同時分析一份數據並記錄下來之外，還可以作為處理一份數據的中間暫存盤記錄之用！ tee 這傢伙在很多選擇/填充的認證考試中很容易考呢！ 語法[dmtsai@study ~]$ tee [-a] file選項與參數：-a ：以累加 (append) 的方式，將數據加入 file 當中！[dmtsai@study ~]$ last | tee last.list | cut -d &quot; &quot; -f1# 這個範例可以讓我們將 last 的輸出存一份到 last.list 文件中；[dmtsai@study ~]$ ls -l /home | tee ~/homefile | more# 這個範例則是將 ls 的數據存一份到 ~/homefile ，同時屏幕也有輸出訊息！[dmtsai@study ~]$ ls -l / | tee -a ~/homefile | more# 要注意！ tee 後接的文件會被覆蓋，若加上 -a 這個選項則能將訊息累加。 sed語法[dmtsai@study ~]$ sed [-nefr] [動作]選項與參數：-n ：使用安靜(silent)模式。在一般 sed 的用法中，所有來自 STDIN 的數據一般都會被列出到屏幕上。 但如果加上 -n 參數後，則只有經過 sed 特殊處理的那一行(或者動作)才會被列出來。-e ：直接在命令行界面上進行 sed 的動作編輯；-f ：直接將 sed 的動作寫在一個文件內， -f filename 則可以執行 filename 內的 sed 動作；-r ：sed 的動作支持的是延伸型正則表達式的語法。(默認是基礎正則表達式語法)-i ：直接修改讀取的文件內容，而不是由屏幕輸出。動作說明： [n1[,n2]]functionn1, n2 ：不見得會存在，一般代表“選擇進行動作的行數”，舉例來說，如果我的動作 是需要在 10 到 20 行之間進行的，則“ 10,20[動作行為] ”function 有下面這些咚咚：a ：新增， a 的後面可以接字串，而這些字串會在新的一行出現(目前的下一行)～c ：取代， c 的後面可以接字串，這些字串可以取代 n1,n2 之間的行！d ：刪除，因為是刪除啊，所以 d 後面通常不接任何咚咚；i ：插入， i 的後面可以接字串，而這些字串會在新的一行出現(目前的上一行)；p ：打印，亦即將某個選擇的數據印出。通常 p 會與參數 sed -n 一起運行～s ：取代，可以直接進行取代的工作哩！通常這個 s 的動作可以搭配正則表達式！ 例如 1,20s/old/new/g 就是啦！ 範例範例一將 /etc/passwd 的內容列出並且打印行號，同時，請將第 2~5 行刪除！ nl /etc/passwd | sed &#x27;2,5d&#x27; 輸出： 1 root:x:0:0:root:/root:/bin/bash6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 原本應要下達 sed -e ，沒有 -e 也行 sed 後面接的動作，請務必以 ‘’ 兩個單引號括住 如果只要刪除第 2 行，可以使用 nl /etc/passwd | sed &#39;2d&#39; 若是要刪除第 3 到最後一行，則是 nl /etc/passwd | sed &#39;3,$d&#39; 範例二承上題，在第二行後(亦即是加在第三行)加上“drink tea?”字樣！ nl /etc/passwd | sed &#x27;2a drink tea&#x27; 輸出： 1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologindrink tea3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 如果是要在第二行前呢？ nl /etc/passwd | sed &#39;2i drink tea&#39; 範例三在第二行後面加入兩行字，例如“Drink tea or …..”與“drink beer?” nl /etc/passwd | sed &#x27;2a Drink tea or ......\\&gt; drink beer ?&#x27; 輸出: 1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologinDrink tea or ......drink beer ?3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 可以新增好幾行”但是每一行之間都必須要以反斜線 \\ 範例四搜尋檔案中有 gzip_ 的每一行, 將該行中的 # 取代為空白, 簡單來說, 就是 uncomment 啦 sed -i &#x27;/gzip_/ s/#\\ //g&#x27; /etc/nginx/nginx.conf 結果前後比較： 替換變量的值將變量中的 sbin 替換成 SBIN echo $&#123;PATH//sbin/SBIN&#125; route[root@www ~]# route [-n]選項與參數：-n ： 將主機名稱以 IP 的方式顯示 [root@www ~]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.0.0 * 255.255.255.0 U 0 0 0 eth0127.0.0.0 * 255.0.0.0 U 0 0 0 lodefault 192.168.0.254 0.0.0.0 UG 0 0 0 eth0 [root@www ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo0.0.0.0 192.168.0.254 0.0.0.0 UG 0 0 0 eth0# 上面輸出的資料共有八個欄位，你需要注意的有幾個地方：# Destination ：其實就是 Network 的意思；# Gateway ：就是該介面的 Gateway 那個 IP 啦！若為 0.0.0.0 表示不需要額外的 IP；# Genmask ：就是 Netmask 啦！與 Destination 組合成為一部主機或網域；# Flags ：共有多個旗標可以來表示該網域或主機代表的意義：# U：代表該路由可用；# G：代表該網域需要經由 Gateway 來幫忙轉遞；# H：代表該行路由為一部主機，而非一整個網域；# Iface ：就是 Interface (介面) 的意思。 jq 取得來源 object 裡的一個 property, 並轉為 raw 輸出node test.js | jq -r &#x27;.propertyName&#x27; arp語法[root@www ~]# arp -[nd] hostname[root@www ~]# arp -s hostname(IP) Hardware_address選項與參數：-n ：將主機名稱以 IP 的型態顯示-d ：將 hostname 的 hardware_address 由 ARP table 當中刪除掉-s ：設定某個 IP 或 hostname 的 MAC 到 ARP table 當中 範例 列出目前主機上記載的 IP/MAC 對應的 ARP 表格arp -n Address HWtype HWaddress Flags Mask Iface192.168.1.100 ether 00:01:03:01:02:03 C eth0192.168.1.240 ether 00:01:03:01:DE:0A C eth0192.168.1.254 ether 00:01:03:55:74:AB C eth0 將 192.168.1.100 那部主機的網卡卡號直接寫入 ARP 表格中arp -s 192.168.1.100 01:00:2D:23:A1:0E SBIT語法chmod 1xxx directoryName 或是建立時給予權限 insatll -d -o ownerName -g groupName -m 1xxx directoryName 只對目錄有效 一般來說, 任意的使用者, 只要對該目錄有 wx 的權限, 都可以 進去該資料夾 以及 刪除該資料夾內的檔案(資料夾) 加上 SBIT 的屬性之後, 只有 該目錄的擁有者, root, 檔案的建立者 才可以刪除該目錄內的檔案(或資料夾) ifconfig語法ifconfig &#123;interface&#125; &#123;up|down&#125; &lt;== 觀察與啟動介面ifconfig interface &#123;options&#125; &lt;== 設定與修改介面選項與參數：interface：網路卡介面代號，包括 eth0, eth1, ppp0 等等options ：可以接的參數，包括如下： up, down ：啟動 (up) 或關閉 (down) 該網路介面(不涉及任何參數) mtu ：可以設定不同的 MTU 數值，例如 mtu 1500 (單位為 byte) netmask ：就是子遮罩網路； broadcast：就是廣播位址啊！ 範例 範例一：觀察所有的網路介面(直接輸入 ifconfig)[root@www ~]# ifconfigeth0 Link encap:Ethernet HWaddr 08:00:27:71:85:BD inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 inet6 addr: fe80::a00:27ff:fe71:85bd/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:2555 errors:0 dropped:0 overruns:0 frame:0 TX packets:70 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:239892 (234.2 KiB) TX bytes:11153 (10.8 KiB) eth0： 就是網路卡的代號，也有 lo 這個 loopback ；HWaddr： 就是網路卡的硬體位址，俗稱的 MAC 是也；inet addr： IPv4 的 IP 位址，後續的 Bcast, Mask 分別代表的是 Broadcast 與 netmask 喔！inet6 addr： 是 IPv6 的版本的 IP ，我們沒有使用，所以略過；MTU： 就是第二章談到的 MTU 啊！RX： 那一行代表的是網路由啟動到目前為止的封包接收情況， packets 代表封包數、errors 代表封包發生錯誤的數量、 dropped 代表封包由於有問題而遭丟棄的數量等等TX： 與 RX 相反，為網路由啟動到目前為止的傳送情況；collisions： 代表封包碰撞的情況，如果發生太多次， 表示你的網路狀況不太好；txqueuelen： 代表用來傳輸資料的緩衝區的儲存長度；RX bytes, TX bytes： 總接收、傳送的位元組總量 範例二：暫時修改網路介面，給予 eth0 一個 192.168.100.100/24 的參數 [root@www ~]# ifconfig eth0 192.168.100.100# 如果不加任何其他參數，則系統會依照該 IP 所在的 class 範圍，自動的計算出# netmask 以及 network, broadcast 等 IP 參數，若想改其他參數則：[root@www ~]# ifconfig eth0 192.168.100.100 \\&gt; netmask 255.255.255.128 mtu 8000 # 設定不同參數的網路介面，同時設定 MTU 的數值！[root@www ~]# ifconfig eth0 mtu 9000# 僅修改該介面的 MTU 數值，其他的保持不動！[root@www ~]# ifconfig eth0:0 192.168.50.50# 仔細看那個介面是 eth0:0 喔！那就是在該實體網卡上，再模擬一個網路介面，# 亦即是在一張網路卡上面設定多個 IP 的意思啦！[root@www ~]# ifconfigeth0 Link encap:Ethernet HWaddr 08:00:27:71:85:BD inet addr:192.168.100.100 Bcast:192.168.100.127 Mask:255.255.255.128 inet6 addr: fe80::a00:27ff:fe71:85bd/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:9000 Metric:1 RX packets:2555 errors:0 dropped:0 overruns:0 frame:0 TX packets:70 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:239892 (234.2 KiB) TX bytes:11153 (10.8 KiB)eth0:0 Link encap:Ethernet HWaddr 08:00:27:71:85:BD inet addr:192.168.50.50 Bcast:192.168.50.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:9000 Metric:1# 仔細看，是否與硬體有關的資訊都相同啊！沒錯！因為是同一張網卡嘛！# 那如果想要將剛剛建立的那張 eth0:0 關閉就好，不影響原有的 eth0 呢？[root@www ~]# ifconfig eth0:0 down# 關掉 eth0:0 這個介面。那如果想用預設值啟動 eth1：『ifconfig eth1 up』即可達成 範例三：將手動的處理全部取消，使用原有的設定值重建網路參數:[root@www ~]# /etc/init.d/network restart# 剛剛設定的資料全部失效，會以 ifcfg-ethX 的設定為主！ apt route語法[root@www ~]# route [-nee][root@www ~]# route add [-net|-host] [網域或主機] netmask [mask] [gw|dev][root@www ~]# route del [-net|-host] [網域或主機] netmask [mask] [gw|dev]觀察的參數： -n ：不要使用通訊協定或主機名稱，直接使用 IP 或 port number； -ee ：使用更詳細的資訊來顯示增加 (add) 與刪除 (del) 路由的相關參數： -net ：表示後面接的路由為一個網域； -host ：表示後面接的為連接到單部主機的路由； netmask ：與網域有關，可以設定 netmask 決定網域的大小； gw ：gateway 的簡寫，後續接的是 IP 的數值喔，與 dev 不同； dev ：如果只是要指定由那一塊網路卡連線出去，則使用這個設定，後面接 eth0 等 範例單純的觀察路由狀態 指令1 route -n 範例輸出1 Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 eth00.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0 指令2 route 範例輸出2 Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.0 * 255.255.255.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 192.168.1.254 0.0.0.0 UG 0 0 0 eth0 路由的增加與刪除[root@www ~]# route del -net 169.254.0.0 netmask 255.255.0.0 dev eth0# 上面這個動作可以刪除掉 169.254.0.0/16 這個網域！# 請注意，在刪除的時候，需要將路由表上面出現的資訊都寫入# 包括 netmask , dev 等等參數喔！注意注意[root@www ~]# route add -net 192.168.100.0 \\&gt; netmask 255.255.255.0 dev eth0# 透過 route add 來增加一個路由！請注意，這個路由的設定必須要能夠與你的網路互通。# 舉例來說，如果我下達底下的指令就會顯示錯誤：# route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.200.254# 因為我的主機內僅有 192.168.1.11 這個 IP ，所以不能直接與 192.168.200.254# 這個網段直接使用 MAC 互通！這樣說，可以理解嗎？[root@www ~]# route add default gw 192.168.1.250# 增加預設路由的方法！請注意，只要有一個預設路由就夠了喔！# 同樣的，那個 192.168.1.250 的 IP 也需要能與你的 LAN 溝通才行！# 在這個地方如果你隨便設定後，記得使用底下的指令重新設定你的網路# /etc/init.d/network restart 輸出資訊意義 Destination, Genmask：這兩個玩意兒就是分別是 network 與 netmask 啦！所以這兩個咚咚就組合成為一個完整的網域囉！ Gateway：該網域是通過哪個 gateway 連接出去的？如果顯示 0.0.0.0 表示該路由是直接由本機傳送，亦即可以透過區域網路的 MAC 直接傳訊；如果有顯示 IP 的話，表示該路由需要經過路由器 (通訊閘) 的幫忙才能夠傳送出去。 Flags：總共有多個旗標，代表的意義如下： U (route is up)：該路由是啟動的； H (target is a host)：目標是一部主機 (IP) 而非網域； G (use gateway)：需要透過外部的主機 (gateway) 來轉遞封包； R (reinstate route for dynamic routing)：使用動態路由時，恢復路由資訊的旗標； D (dynamically installed by daemon or redirect)：已經由服務或轉 port 功能設定為動態路由 M (modified from routing daemon or redirect)：路由已經被修改了； ! (reject route)：這個路由將不會被接受(用來抵擋不安全的網域！) Iface：這個路由傳遞封包的介面。 ip語法[root@www ~]# ip [option] [動作] [指令]選項與參數：option ：設定的參數，主要有： -s ：顯示出該裝置的統計數據(statistics)，例如總接受封包數等；動作：亦即是可以針對哪些網路參數進行動作，包括有： link ：關於裝置 (device) 的相關設定，包括 MTU, MAC 位址等等 addr/address ：關於額外的 IP 協定，例如多 IP 的達成等等； route ：與路由有關的相關設定 traceroute語法[root@www ~]# traceroute [選項與參數] IP選項與參數：-n ：可以不必進行主機的名稱解析，單純用 IP ，速度較快！-U ：使用 UDP 的 port 33434 來進行偵測，這是預設的偵測協定；-I ：使用 ICMP 的方式來進行偵測；-T ：使用 TCP 來進行偵測，一般使用 port 80 測試-w ：若對方主機在幾秒鐘內沒有回聲就宣告不治...預設是 5 秒-p 埠號：若不想使用 UDP 與 TCP 的預設埠號來偵測，可在此改變埠號。-i 裝置：用在比較複雜的環境，如果你的網路介面很多很複雜時，才會用到這個參數； 舉例來說，你有兩條 ADSL 可以連接到外部，那你的主機會有兩個 ppp， 你可以使用 -i 來選擇是 ppp0 還是 ppp1 啦！-g 路由：與 -i 的參數相仿，只是 -g 後面接的是 gateway 的 IP 就是了。 範例偵測本機到 yahoo 去的各節點連線狀態[root@www ~]# traceroute -n tw.yahoo.comtraceroute to tw.yahoo.com (119.160.246.241), 30 hops max, 40 byte packets 1 192.168.1.254 0.279 ms 0.156 ms 0.169 ms 2 172.20.168.254 0.430 ms 0.513 ms 0.409 ms 3 10.40.1.1 0.996 ms 0.890 ms 1.042 ms 4 203.72.191.85 0.942 ms 0.969 ms 0.951 ms 5 211.20.206.58 1.360 ms 1.379 ms 1.355 ms 6 203.75.72.90 1.123 ms 0.988 ms 1.086 ms 7 220.128.24.22 11.238 ms 11.179 ms 11.128 ms 8 220.128.1.82 12.456 ms 12.327 ms 12.221 ms 9 220.128.3.149 8.062 ms 8.058 ms 7.990 ms10 * * *11 119.160.240.1 10.688 ms 10.590 ms 119.160.240.3 10.047 ms12 * * * &lt;==可能有防火牆裝置等情況發生所致 tcpdump語法[root@www ~]# tcpdump [-AennqX] [-i 介面] [-w 儲存檔名] [-c 次數] \\ [-r 檔案] [所欲擷取的封包資料格式]選項與參數：-A ：封包的內容以 ASCII 顯示，通常用來捉取 WWW 的網頁封包資料。-e ：使用資料連接層 (OSI 第二層) 的 MAC 封包資料來顯示；-nn：直接以 IP 及 port number 顯示，而非主機名與服務名稱-q ：僅列出較為簡短的封包資訊，每一行的內容比較精簡-X ：可以列出十六進位 (hex) 以及 ASCII 的封包內容，對於監聽封包內容很有用-i ：後面接要『監聽』的網路介面，例如 eth0, lo, ppp0 等等的介面；-w ：如果你要將監聽所得的封包資料儲存下來，用這個參數就對了！後面接檔名-r ：從後面接的檔案將封包資料讀出來。那個『檔案』是已經存在的檔案， 並且這個『檔案』是由 -w 所製作出來的。-c ：監聽的封包數，如果沒有這個參數， tcpdump 會持續不斷的監聽， 直到使用者輸入 [ctrl]-c 為止。所欲擷取的封包資料格式：我們可以專門針對某些通訊協定或者是 IP 來源進行封包擷取， 那就可以簡化輸出的結果，並取得最有用的資訊。常見的表示方法有： &#x27;host foo&#x27;, &#x27;host 127.0.0.1&#x27; ：針對單部主機來進行封包擷取 &#x27;net 192.168&#x27; ：針對某個網域來進行封包的擷取； &#x27;src host 127.0.0.1&#x27; &#x27;dst net 192.168&#x27;：同時加上來源(src)或目標(dst)限制 &#x27;tcp port 21&#x27;：還可以針對通訊協定偵測，如 tcp, udp, arp, ether 等 還可以利用 and 與 or 來進行封包資料的整合顯示呢！ 範例以 IP 與 port number 捉下 eth0 這個網路卡上的封包，持續 3 秒[root@www ~]# tcpdump -i eth0 -nntcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes17:01:47.360523 IP 192.168.1.101.1937 &gt; 192.168.1.100.22: Flags [.], ack 196, win 65219, 17:01:47.362139 IP 192.168.1.100.22 &gt; 192.168.1.101.1937: Flags [P.], seq 196:472, ack 1,17:01:47.363201 IP 192.168.1.100.22 &gt; 192.168.1.101.1937: Flags [P.], seq 472:636, ack 1,17:01:47.363328 IP 192.168.1.101.1937 &gt; 192.168.1.100.22: Flags [.], ack 636, win 64779,&lt;==按下 [ctrl]-c 之後結束6680 packets captured &lt;==捉下來的封包數量14250 packets received by filter &lt;==由過濾所得的總封包數量7512 packets dropped by kernel &lt;==被核心所丟棄的封包 17:01:47.362139：此封包被擷取的時間，『時:分:秒』的單位； IP：透過的通訊協定是 IP ； 192.168.1.100.22 &gt; ：傳送端是 192.168.1.100 這個 IP，而傳送的 port number 為 22，大於 (&gt;) 的符號指的是封包的傳輸方向 192.168.1.101.1937：接收端的 IP 是 192.168.1.101， 主機開啟 port 1937 來接收； [P.], seq 196:472：這個封包帶有 PUSH 的資料傳輸標誌， 且傳輸的資料為整體資料的 196~472 byte； ack 1：ACK 的相關資料。 簡單來說, 該封包是由 192.168.1.100 傳到 192.168.1.101，透過的 port 是由 22 到 1937 ， 使用的是 PUSH 的旗標，而不是 SYN 之類的主動連線標誌 只取 port 21[root@www ~]# tcpdump -i eth0 -nn port 21tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes01:54:37.96 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: . ack 1 win 6553501:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: P 1:21(20) ack 1 win 584001:54:38.12 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: . ack 21 win 6551501:54:42.79 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: P 1:17(16) ack 21 win 6551501:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: . ack 17 win 584001:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: P 21:55(34) ack 17 win 5840 封包的傳遞都是雙向的， client 端發出『要求』而 server 端則予以『回應』 監聽本地 localhost 試驗我們先在一個終端機視窗輸入『 tcpdump -i lo -nn 』 的監聽，再另開一個終端機視窗來對本機 (127.0.0.1) 登入『ssh localhost』 [root@www ~]# tcpdump -i lo -nn 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes 3 11:02:54.253777 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: S 933696132:933696132(0) win 32767 &lt;mss 16396,sackOK,timestamp 236681316 0,nop,wscale 2&gt; 4 11:02:54.253831 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: S 920046702:920046702(0) ack 933696133 win 32767 &lt;mss 16396,sackOK,timestamp 236681316 236681316,nop, wscale 2&gt; 5 11:02:54.253871 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 1 win 8192 &lt;nop, nop,timestamp 236681316 236681316&gt; 6 11:02:54.272124 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: P 1:23(22) ack 1 win 8192 &lt;nop,nop,timestamp 236681334 236681316&gt; 7 11:02:54.272375 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 23 win 8192 &lt;nop, nop,timestamp 236681334 236681334&gt; 第 3 行顯示的是『來自 client 端，帶有 SYN 主動連線的封包』， 第 4 行顯示的是『來自 server 端，除了回應 client 端之外(ACK)，還帶有 SYN 主動連線的標誌； 第 5 行則顯示 client 端回應 server 確定連線建立 (ACK) 第 6 行以後則開始進入資料傳輸的步驟。 nmap語法[root@www ~]# nmap [掃瞄類型] [掃瞄參數] [hosts 位址與範圍]選項與參數：[掃瞄類型]：主要的掃瞄類型有底下幾種： -sT：掃瞄 TCP 封包已建立的連線 connect() ！ -sS：掃瞄 TCP 封包帶有 SYN 標籤的資料 -sP：以 ping 的方式進行掃瞄 -sU：以 UDP 的封包格式進行掃瞄 -sO：以 IP 的協定 (protocol) 進行主機的掃瞄[掃瞄參數]：主要的掃瞄參數有幾種： -PT：使用 TCP 裡頭的 ping 的方式來進行掃瞄，可以獲知目前有幾部電腦存活(較常用) -PI：使用實際的 ping (帶有 ICMP 封包的) 來進行掃瞄 -p ：這個是 port range ，例如 1024-, 80-1023, 30000-60000 等等的使用方式[Hosts 位址與範圍]：這個有趣多了，有幾種類似的類型 192.168.1.100 ：直接寫入 HOST IP 而已，僅檢查一部； 192.168.1.0/24 ：為 C Class 的型態， 192.168.*.* ：嘿嘿！則變為 B Class 的型態了！掃瞄的範圍變廣了！ 192.168.1.0-50,60-100,103,200 ：這種是變形的主機範圍啦！很好用吧！ 範例使用預設參數掃瞄本機所啟用的 port (只會掃瞄 TCP)[root@www ~]# yum install nmap[root@www ~]# nmap localhostPORT STATE SERVICE22/tcp open ssh25/tcp open smtp111/tcp open rpcbind 同時掃瞄本機的 TCP/UDP 埠口[root@www ~]# nmap -sTU localhostPORT STATE SERVICE22/tcp open ssh25/tcp open smtp111/tcp open rpcbind111/udp open rpcbind &lt;= 透過 ICMP 封包的檢測，分析區網內有幾部主機是啟動的[root@www ~]# nmap -sP 192.168.1.0/24Starting Nmap 5.21 ( http://nmap.org ) at 2011-07-20 17:05 CSTNmap scan report for www.centos.vbird (192.168.1.100)Host is up.Nmap scan report for 192.168.1.101 &lt;==這三行講的是 192.168.101 的範例！Host is up (0.00024s latency).MAC Address: 00:1B:FC:58:9A:BB (Asustek Computer) Nmap scan report for 192.168.1.254Host is up (0.00026s latency).MAC Address: 00:0C:6E:85:D5:69 (Asustek Computer)Nmap done: 256 IP addresses (3 hosts up) scanned in 3.81 seconds dig語法[root@www ~]# dig [options] FQDN [@server]選項與參數：@server ：如果不以 /etc/resolv.conf 的設定來作為 DNS 查詢，可在此填入其他的 IPoptions：相關的參數很多，主要有 +trace, -t type 以及 -x 三者最常用 +trace ：就是從 . 開始追蹤，在 19.1.2 裡面談過了！回頭瞧瞧去！ -t type：查詢的資料主要有 mx, ns, soa 等類型，相關類型 19.4 來介紹 -x ：查詢反解資訊，非常重要的項目！ 範例使用預設值查詢 linux.vbird.org[root@www ~]# dig linux.vbird.org; &lt;&lt;&gt;&gt; DiG 9.7.0-P2-RedHat-9.7.0-5.P2.el6_0.1 &lt;&lt;&gt;&gt; linux.vbird.org;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37415;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 0;; QUESTION SECTION: &lt;==提出的問題的部分;linux.vbird.org. IN A;; ANSWER SECTION: &lt;==主要的回答階段linux.vbird.org. 600 IN A 140.116.44.180;; AUTHORITY SECTION: &lt;==其他與此次回答有關的部分vbird.org. 600 IN NS dns.vbird.org.vbird.org. 600 IN NS dns2.vbird.org.;; Query time: 9 msec;; SERVER: 168.95.1.1#53(168.95.1.1);; WHEN: Thu Aug 4 14:12:26 2011;; MSG SIZE rcvd: 86 查詢 linux.vbird.org 的 SOA 相關資訊[root@www ~]# dig -t soa linux.vbird.org; &lt;&lt;&gt;&gt; DiG 9.7.0-P2-RedHat-9.7.0-5.P2.el6_0.1 &lt;&lt;&gt;&gt; -t soa linux.vbird.org;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 57511;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0;; QUESTION SECTION:;linux.vbird.org. IN SOA;; AUTHORITY SECTION:vbird.org. 600 IN SOA dns.vbird.org. root.dns.vbird.org. 2007091402 28800 7200 720000 86400;; Query time: 17 msec;; SERVER: 168.95.1.1#53(168.95.1.1);; WHEN: Thu Aug 4 14:15:57 2011;; MSG SIZE rcvd: 78 rsync範例： 同步 A 資料夾的內容到 B 資料夾, 不要同步 .git 資料夾rsync -avz --exclude .git sourceDirectory/ targetDirectory -a: 同步權限 -v: 顯示過程詳細訊息 -z: 過程中壓縮 Q&amp;A apt 底層包的是？ dpkg dpkg 安裝 package 時, 會將 *.deb 放在? /var/cache/apt/archives/ 路由的排列有順序之分嗎？ 有哦 路由排列的規則？ 由小網域到大網域 修改 default system editor到 ~/.bashrc export SYSTEMD_EDITOR=vim 然後到 visudo 中 sudo visudo 加入以下 Defaults env_keep += &quot;SYSTEMD_EDITOR&quot; 大功告成","link":"/zh-tw/Linux/"},{"title":"利用 Hexo 來建立一個 多語系 部落格","text":"前言這幾天為了建立一個個人部落格，真是沒少折騰了！個人除了對程式分享有熱愛之外，對語言也很有愛，像是英日語等等，所以一直以來，就想建一個多語系的部落格，除了可以讓分享的受眾更廣之外，另一方面也可以強制練習自己的語言！在請教 Google 大神無數次之後，大概歸納出以下三種可行的方法： 利用 i18n ，再透過修改源碼的方式 建兩個站點，一個中文，一個英文 利用 Hexo 的 minos 主題 在花了一些時間研究之後，毅然決然的選擇第三種，原因如下： 原本我是使用 Hexo 的 Next 主題，可惜該主題在這方面並沒有支援，需要特別去修改源碼。 這代表，維護成本會相當可觀，每修改一個地方，就需要修改兩份檔案，看你有幾種語言就得修改幾份檔案 所以，本篇會針對 Hexo 的 minos 主題來做分享 安裝 Hexo 安裝 NodeJS ，會連帶安裝 npm 套件管理器 brew install node 透過 npm 安裝 Hexo 主程式 npm install hexo-cli -g 在指定資料夾內，建立一個 Hexo 網站需要的檔案 hexo init folderName 安裝 minos 主題 進到資料夾 cd folderName 從官方 GitHub上clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos 原始資料夾，預設只有 _config.yml.example ，所以 copy 或 rename 為 _config.yml ，並於檔案中，搜尋 theme ，並設為 minos 開始配置配置 Hexo 配置檔 config(配置檔)又分為 Hexo 本身的，以及主題的，以下先針對 Hexo 配置檔做說明，以下為必要設定的選項，其餘都維持預設即可: language: [&#x27;en&#x27;, &#x27;zh-tw&#x27;] //這邊的配置，表示默認以English語系為主，並以Taiwan語系為輔 url: https://tn710617.github.io/ (此為你的網站地址) permalink: :title/ deploy: type: git repo: https://github.com/tn710617/tn710617.github.io.git (此為你在GitHub上的資料夾clone地址) branch: master 主題配置檔內的設定都跟多語系無直接關係，所以這邊不特別做說明，大家依照官方文件以及個人喜好設定完成即可。 配置網頁語系檔 配置完 Hexo 的配置檔後，我們需要先新建一個自己國家的語系檔，如果主題內原本就已經有的話就不必，以本篇例子來說，我需要一個 Taiwan 語系，但是主題內的配置沒有，所以我必須要自己建一個。這個檔案的功用為，當切換到指定語系時， Hexo 會去讀指定語系的配置檔，就是這個檔案，並且依照這個語系檔裡面的內容來顯示 到 minos 的 languages 資料夾內，新建一個檔名為zh-tw.yml的檔案 內容可以比照其他國家的格式，如下：name: &#x27;繁體中文&#x27;common: archives: &#x27;歸檔&#x27; category: &#x27;分類&#x27; tag: &#x27;標籤&#x27; categories: &#x27;分類&#x27; tags: &#x27;標籤&#x27;nav: next: &#x27;下一頁&#x27; prev: &#x27;上一頁&#x27; search: &#x27;搜尋&#x27; toc: &#x27;目錄&#x27;article: read_more: &#x27;點擊閱讀&#x27; read: &#x27;讀完&#x27; about: &#x27;大概&#x27; words: &#x27;字&#x27; comments: &#x27;留言&#x27; contents: &#x27;目錄&#x27;search: hint: &#x27;站內搜尋&#x27;insight: hint: &#x27;站內搜尋&#x27; posts: &#x27;文章&#x27; pages: &#x27;頁面&#x27; categories: &#x27;分類&#x27; tags: &#x27;標籤&#x27; untitled: &#x27;(無標題)&#x27; 配置主題下的語系導向檔案 語系檔設定完成後，複製這個主題配置檔，並創立另外兩份配置檔。這幾個檔案的作用為，當我們切換到指定語系，網頁會依照這個檔案內配置的路徑來開啟相對應的檔案，比方說，中文開中文的檔案，英文開英文的檔案。 _config.zh-tw.yml _config.en.yml 先針對’en’配置檔做以下配置： // 這邊的配置可以依照個人需求menu: Archives: /archives Categories: /categories Tags: /tags Schedule: /schedule About: /about Friends: /friends 再來針對’zh-tw’配置檔做以下配置： menu: 歸檔: /zh-tw/archives 分類: /zh-tw/categories 標籤: /zh-tw/tags 行程: /zh-tw/schedule 關於: /zh-tw/about 好友: /zh-tw/friends 大家可能會注意到，這三個檔案內有著重複的配置。規則是這樣的，當我們切換到該語系的網頁時，默認會套用該語系的配置檔裡頭的配置，若該語系配置檔裡頭沒有這個配置，會自動套用主題原本的配置檔裡面的配置，所以這邊可以很靈活的針對不同語系的網頁來做配置調整。 view檔案的配置 現在我們開始針對view的檔案來做配置， minos 的規則是，除了源碼以及主體架構之外，所有的檔案根據語系的數量來配置，簡單來說，有幾種語系，該檔案就要有幾份。這也很合理，不然透過機器翻譯的文章你敢貼出來嗎？ 現在開始針對source底下的檔案來做配置: _posts上圖應該不會很難理解吧？ 簡單來說，_posts資料夾下面放的，是默認語系的檔案，以本篇例子來說，就是英文語系。而在_posts資料夾下面，建立一個名為zh-tw的資料夾，裡頭放著自然是中文語系的檔案 其他的：檔案配置就跟上圖一樣，是不是簡單到言語無法形容了？ 語言切換選單位置調整 以我個人來說，當我進到一個網頁，如果密密麻麻的都是我看不懂的語言，我希望我第一個可以找到的就是語言切換的按鈕（如果有的話啦），以目前Ray使用的minos主題版本來說，切換語言的選單默認是在最下面的，所以我希望把它調整到一個顯眼的地方 到footer.ejs中，找到以下的代碼 &lt;%- partial(&#x27;common/languages&#x27;) %&gt; 把它剪下之後，貼到navbar.ejs檔案的最下方&lt;/body&gt;上面 如果現在從今整理頁面，應該已經可以看到語言切換選單已經換到上頭去了！可是呢… 怎麼是向上開啟選單的ＸＤ，根本無法選啊！所以我們還要再做一些調整。找到layout裡頭的languages.ejs檔案，並在裡頭找到下面這一行，並加入style=&quot;top:100%&quot; &lt;div class=&quot;dropdown-menu has-text-left&quot; role=&quot;menu&quot; style=&quot;top:100%&quot;&gt; 結語照著上面配置，大概就可以實現雙語系網站了，效果可以看看我的 blog 若有說的不對的地方，歡迎指教歡迎轉載，但請註明出處，謝謝！","link":"/zh-tw/buildABilingualBlog/"},{"title":"Character Sets, Collations, Unicode (MySQL 官方文件原子化翻譯)","text":"# 前言本篇主要為細讀官方文件後, 整理為 Q&amp;A 的原子化翻譯筆記 # Character Sets and Collations in GeneralMySQL 中, 我們說 character set 是 symbols 以及 encodings 的組合, 那在以下的 example 中, 誰是 symbols, 誰是 encodings? Example:A = 0, B = 1, a = 2, b = 3 Answer:A, B, a, b 是 symbols, 0, 1, 2, 3 是 encodings MySQL 中, 若說 character set 是一組 symbols 以及 collations, 那 collations 是什麼？比較 character set 的規則 在以下的 MySQL character set example 中, 若要比較 symbols 的大小, collation 的規則該是? Example:A = 0, B = 1, a = 2, b = 3 Answer:b &gt; a &gt; B &gt; A, 透過比較 encoding 的大小 # Character Sets and Collations in MySQLMySQL 中, 預設的 character set 以及 collation 是？MySQL 預設使用 character sets utf8mb4 以及 collations utf8mb4_0900_ai_ci 以下的 MySQL example command 的意思是？ Example:SHOW CHARACTER SET LIKE &#x27;utf%&#x27;; Answer:列出支援的 character sets, 若不加 LIKE 則列出所有 以下的 MySQL example command 的意思是？ Example:SHOW COLLATION Answer:列出所有支援的 collations # Character Set Repertoirecharacter set 的 repertoire (字元表) 是這個 character set 中 character 的集合一般來說, string 的 repertoire 可分為兩種: ASCII: U+0000 to U+007F UNICODE: U+0000 to u+10FFFF, 含所有 character ASCII 範圍是 UNICODE 範圍的子集, 所以 string 有著 ASCII repertoire 可以安全地被 UNICODE repertoire 涵蓋, 也可安全的轉換成任何 ASCII 的 superset (除了 swe7, 任何 MySQL 的 character set 都是 ASCII 的 superset) 正是因為 repertoire 的使用, string 才得以在多種不同的 character set 之間轉換 repertoire 會隨著 string 的內容變換, 且可能會跟 character set 的 repertoire 有所不同 SET NAMES utf8mb4; SELECT &#x27;abc&#x27;;SELECT _utf8mb4&#x27;def&#x27;; 從上面的 example 可以看到, 雖說 character set 設定 utfmb4, 照理來說 repertoire 該是 UNICODE, 但因為 ‘abc’, 以及 ‘def’ 並未超出 ASCII 的範圍, 因此其 repertoire 還是定在 ASCII 再來看看下面的 example, column c1 以及 c2 雖然有不同的 character set, 但因為 value ‘a’, ‘b’ 的 repertoire 都沒有超出 ASCII 的範圍, 所以 CONCAT 不會有錯誤 CREATE TABLE t1 ( c1 CHAR(1) CHARACTER SET latin1, c2 CHAR(1) CHARACTER SET ascii);INSERT INTO t1 VALUES (&#x27;a&#x27;,&#x27;b&#x27;);SELECT CONCAT(c1,c2) FROM t1; 而當一個 function 有一個 string argument, 則 repertoire 繼承自該 string比方說, UPPER(_utf8mb4’abc’) 的 repertoire 為 ASCII, 因為 ‘abc’ 有著 ASCII repertoire (儘管有著 “_utf8mb4”, 但 ‘abc’ 的 character 範圍並沒有超出 ASCII) 那如果是返回 string 結果的 function, 但卻沒有 argument 輸入呢？ 那 function 會使用 character_set_connection 的設定 如果 function 有多個 args, 那會使用多個 args 中範圍最廣的 repertoire, 如下 example: CONCAT(_ucs2 X&#x27;0041&#x27;, _ucs2 X&#x27;0042&#x27;)CONCAT(_ucs2 X&#x27;0041&#x27;, _ucs2 X&#x27;00C2&#x27;) 上面的 example 中可以看到, 第一個 CONCAT function 的結果為 ASCII, 因為兩個 args 的 character 都在 ASCII 的範圍內, 而第二個 function 則為 UNICODE, 因為第二個 args 超出了 ASCII 範圍 function 的 repertoire 只會被會對結果造成影養的 args 所影響, 別誤會, 我沒有在唱饒舌歌, 看看下面的 example IF(column1 &lt; column2, &#x27;smaller&#x27;, &#x27;greater&#x27;) 上面的 example 中可以看到, 雖然有三個 args, 但實際上會對結果造成影響的是 2 跟 3, arg1 雖然也是 string 表達, 但因為對結果輸出的 repertoire 沒有影響, 因為不會被列入 repertoire 的決定因素內 UTF8 For MetadataMySQL 中, 什麼是 metadata?任何形容資料庫的都稱為 metadata, 像是, column name, database name, user names, version names, SHOW 的輸出, 還有 INFORMATION_SCHEMA table 的內容 MySQL 中, metadata 以哪種 character set 儲存?UTF-8 以下的 MySQL example command 的意思是？ Example:SHOW VARIABLES LIKE &#x27;character_set_system&#x27;; Answer:顯示 character_system_set system variable, 為 metadata 的 character set 以下的 MySQL example 中, column1 的 column name 的 character set 取決於？ Example:SELECT column1 FROM t Answer:character_set_results, 預設為 utf8mb4 MySQL 中, 預設回傳的 column name character set 為 utf8mb4, 如果我想變更, 可以使用哪一個 command?SET NAMES MySQL 中, 預設回傳的 column name character set 為 utf8mb4, 如果想要變更, 最佳的解決方案是在 server 端轉換還是在 client 端轉換？client MySQL 中, 如果 character_set_results 設為 NULL, 那 return metadata 的 character set 會參照？character_set_system 以下的 MySQL example 中, character set 是如何轉換的？ Example:SELECT * FROM t1 WHERE USER() = latin1_column; Answer:USER() return 的值為 metadata, 預設為 utf8mb4, 所以 MySQL 會自動將 latin1_column 轉成 utf8mb4 以下的 MySQL example 中, character set 是如何轉換的？ Example:INSERT INTO t1 (latin1_column) SELECT USER(); Answer:USER() return 的值為 metadata, 預設為 utf8mb4, 但因為要存入的 column ‘latin1_column’ 的 character set 為 latin, 所以 USER() 會自動被轉換為 ‘latin1’ # Specifying Character Sets and CollationsMySQL 中, character sets 以及 collations 有哪四個等級server, database, table, column # Collation Naming Conventions從以下的 example 中的 collations 命名方式, 可知道其分別與什麼 character set 相關？ Example:latin1_swedish_ciutf8mb4_general_ci Answer:latin1utf8mb4 MySQL character set 中的 binary, 共對應幾種 collation?1 種, 就是 binary collation, 且無後綴 從以下的 example 中的 collations 命名, 可知道其差異是？ Example:utf8mb4_hungarian_ciutf8mb4_turkish_ci Answer:使用 hugarian 規則來排序 utf8mb4 character set使用 turkish 規則來排序 utf8mb4 character set 以下的 collation 後面的 _ci 代表的意思是？ Example:utf8mb4_turkish_ci Answer:代表 sort 規則是 case insensitive 以下的 collation 後面的 _ai 代表的意思是？ Example:utf8mb4_turkish_ai Answer:代表 sort 規則是 accent insensitive 以下的 collation 後面的 _as 代表的意思是？ Example:utf8mb4_turkish_as Answer:代表 sort 規則是 accent sensitive 以下的 collation 後面的 _cs 代表的意思是？ Example:utf8mb4_turkish_cs Answer:代表 sort 規則是 case sensitive 以下的 collation 後面的 _ks 代表的意思是？ Example:utf8mb4_japanese_ks Answer:代表 sort 規則是 kana sensitive (只用在日語), 代表會將 katakana 跟 hiragana 做區隔, 若無 ks 則會一視同仁 以下的 collation 後面的 _bin 代表的意思是？ Example:utf8mb4_japanese_bin Answer:代表 sort 規則是 binary, 依 binary code 來排列 collation 以 _ci 結尾的, 是 accent sensitive 還是 insensitive?accent insensitive collation 以 _cs 結尾的, 是 accent sensitive 還是 insensitive?accent sensitive collation 中, UCA 的全寫是？Unicode Collation Algorithm collation utf8mb4_0900_ai_ci 中的 0900 的意思是？UCA 版本號 collation utf8mb4_unicode_520_ci 中的 520 的意思是？UCA 版本號 collation utf8mb4_unicode_ci 中, 並無標示版本號, 所以會使用哪一個版本？UCA 4.0.0 # Server Character Set and Collation以下的 MySQL example code 的意思是? Example:mysqld --character-set-server=utf8mb4 \\ --collation-server=utf8mb4_0900_ai_ci Answer:啟動 mysql daemon, 並指定 server character set 以及 collation 以下的 cmake example code 的意思是? Example:cmake . -DDEFAULT_CHARSET=latin1 \\ -DDEFAULT_COLLATION=latin1_german1_ci Answer:使用 cmake 來指定 MySQL server 的 character set 以及 collation MySQL 中, 當我建立資料庫但並未指定 character set 或 collation 時, 預設會使用？會使用 character_set_server 以及 collation_server system variable # Database Character Set and Collation以下的 MySQL example code 的意思是? Example:CREATE DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name]ALTER DATABASE db_name [[DEFAULT] CHARACTER SET charset_name] [[DEFAULT] COLLATE collation_name] Answer:建立資料庫時指定 character set 以及 collation更改資料庫的 character set 以及 collationdefault 值為 character_set_server 以及 collation_server MySQL 中, 如果 character_set_database 有特別指定, 但 collation 沒指定, 那該 database 會使用哪個 collation與該 character set 相關的預設 collation, 可使用 SHOW COLLATION 取得詳細資料 MySQL 中, 如果 collation_database 有特別指定, 但 character_set_database 沒指定, 那該 database 會使用哪個 character set會使用與該 collation 相關的 character set 以下的 MySQL example code 的意思是? Example:USE db_name;SELECT @@character_set_database, @@collation_database; Answer:取得 database db_name 的 character_set 以及 collation 以下的 MySQL example code 的意思是? Example:SELECT DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAMEFROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = &#x27;db_name&#x27;; Answer:取得 database db_name 的 character_set 以及 collation MySQL 中, 如果 table character_set 或 collation 未指定, 其預設值為？character_set_database, collation_database MySQL 中, 當使用 LOAD DATA Statement, 若無特別指定, 預設使用哪個 character set?character_set_database # Table Character Set and Collation以下的 MySQL example code 的意思是? Example:CREATE TABLE tbl_name (column_list) [[DEFAULT] CHARACTER SET charset_name] [COLLATE collation_name]]ALTER TABLE tbl_name [[DEFAULT] CHARACTER SET charset_name] [COLLATE collation_name] Answer:設定或修改 table 的 character set 及 collation MySQL 中, 如果 character_set_table 有特別指定, 但 collation 沒指定, 那該 table 會使用哪個 collation與該 character set 相關的預設 collation若要取得預設 collation 的詳細資料, 可使用 SHOW COLLATION MySQL 中, 如果 collation_table 有特別指定, 但 character_set_table 沒指定, 那該 database 會使用哪個 character set會使用與該 collation 相關的 character set MySQL 中, 如果 character_set_table 與 collation_table 都沒有特別指定, 那預設會使用？character_set_database 與 collation_database # Column Character Set and Collation以下的 MySQL example code 的意思是? Example:CREATE TABLE t1( col1 VARCHAR(5) CHARACTER SET latin1 COLLATE latin1_german1_ci);ALTER TABLE t1 MODIFY col1 VARCHAR(5) CHARACTER SET latin1 COLLATE latin1_swedish_ci; Answer:CREATE TABLE t1( # 定義 col1 的 character set 以及 collation col1 VARCHAR(5) CHARACTER SET latin1 COLLATE latin1_german1_ci);ALTER TABLE t1 MODIFY # 修改 col1 的 character set 以及 collation col1 VARCHAR(5) CHARACTER SET latin1 COLLATE latin1_swedish_ci; MySQL 中, 如果 character_set_table 有特別指定, 但 collation 沒指定, 如下 example, 那該 database 會使用哪個 collation? Example:CREATE TABLE t1( col1 CHAR(10) CHARACTER SET utf8) CHARACTER SET latin1 COLLATE latin1_bin; Answer:與該 character set 相關的預設 collation若要取得預設 collation 的詳細資料, 可使用 SHOW COLLATION MySQL 中, 如果 collation_table 有特別指定, 但 character_set_table 沒指定, 如下 example, 那該 column 會使用哪個 character set? Example:CREATE TABLE t1( col1 CHAR(10) COLLATE utf8_polish_ci) CHARACTER SET latin1 COLLATE latin1_bin; Answer:會使用與該 collation 相關的 character set MySQL 中, 如果 character_set_column 與 collation_column 都沒有特別指定, 如下 example, 那預設會使用？ Example:CREATE TABLE t1( col1 CHAR(10)) CHARACTER SET latin1 COLLATE latin1_bin; Answer:character_set_table 與 collation_table MySQL 中, 如果修改一個 column 的 character set, 但現存內容與指定的 character set 並不相容, 那可能會造成什麼後果？資料丟失 # Character String Literal Character Set and Collation以下的 MySQL example code 分別使用哪個 character set 及 collation? Example:SELECT &#x27;abc&#x27;;SELECT _latin1&#x27;abc&#x27;;SELECT _binary&#x27;abc&#x27;;SELECT _utf8mb4&#x27;abc&#x27; COLLATE utf8mb4_danish_ci; Answer:# 使用 character_set_connection system variableSELECT &#x27;abc&#x27;;# 使用 latin1 character set, 以及其 default 的 collationSELECT _latin1&#x27;abc&#x27;;# 使用 binary character set, 以及其 default 的 collationSELECT _binary&#x27;abc&#x27;;# 使用 utf8mb4 character set, 以及 utf8mb4_danish_ci collationSELECT _utf8mb4&#x27;abc&#x27; COLLATE utf8mb4_danish_ci;# 使用 character_set_connection system variable, 如果與指定的 collation 不相容, 則報錯SELECT &#x27;Müller&#x27; COLLATE utf8mb4_general_ci; 以下的 MySQL example code 中, escaping 都會由哪個 character set 解析？ Example:SELECT HEX(&#x27;à\\n&#x27;), HEX(_sjis&#x27;à\\n&#x27;); Answer:會由 character_set_connection 解析 # The National Character Set以下的 MySQL example description 的意思相同嗎? Example:VARCHAR(10) CHARACTER SET utf8NATIONAL VARCHAR(10)NVARCHAR(10)NCHAR VARCHAR(10)NATIONAL CHARACTER VARYING(10)NATIONAL CHAR VARYING(10) Answer:相同, MySQL 的預設 national character set 為 utf8 以下的 MySQL example query 所使用的 character set 相同嗎? Example:SELECT N&#x27;some text&#x27;;SELECT n&#x27;some text&#x27;;SELECT _utf8&#x27;some text&#x27;; Answer:相同, MySQL 的預設 national character set 為 utf8 以下的 MySQL example query 所使用的 character set 相同嗎? Example:CREATE TABLE t1 (f1 CHAR(N) UNICODE);CREATE TABLE t1 (f1 CHAR(N) CHARACTER SET ucs2); Answer:相同 # Connection Character Sets and Collations# Connection Character Set and Collation System VariablesMySQL statement 的 character set 是?character_set_client 在 MySQL server 收到來自 client 的 statement 後, 會將 character_set_client 轉換成哪一種 variable?MySQL server 會將 statement 從 character_set_client 轉換成 character_set_connection 在 MySQL server 預設會將 client 的 statement 轉換成 character_set_connection, 那如果是 literal string with introducer, 會以哪個為準會以 introducer 為先 MySQL 中, collation_connection 會被使用來比較 literal string 嗎？會的 MySQL 中, collation_connection 會被使用來比較 column value string 嗎？不會, 會使用 collation_column MySQL 中, MySQL server 會將 query 的結果轉換成哪種 character set 並回傳給 client?character_set_result 以下的 MySQL example code 的意思是? Example:SET character_set_results = NULL;SET character_set_results = binary; Answer:MySQL Server 預設會將 query result 轉換成 character_set_result, 若不希望這個轉換行為, 可將 character_set_result 設為 null 以下的 MySQL example code 的意思是? Example:SELECT * FROM performance_schema.session_variablesWHERE VARIABLE_NAME IN (&#x27;character_set_client&#x27;, &#x27;character_set_connection&#x27;,&#x27;character_set_results&#x27;, &#x27;collation_connection&#x27;) ORDER BY VARIABLE_NAME; Answer:取得跟 Server 與 Client 之間 session 有關的 character set 以及 collation system variable 以下的 MySQL example code 的意思是? Example:SHOW SESSION VARIABLES LIKE &#x27;character\\_set\\_%&#x27;;SHOW SESSION VARIABLES LIKE &#x27;collation\\_%&#x27;; Answer:列出所有與 session 有關的 variable # Impermissible Client Character SetsMySQL 中, 下面幾種 character set 可以被設為 character_set_client 嗎？ Example:ucs2utf16utf16leutf32 Answer:不行 MySQL 中, 當我嘗試使用以下 statement 來設定 ucs2, utf16, utf16le, utf32 為 character set 都會 error, 原因是？ Example:mysql --default-character-set=character_nameSET NAMES &#x27;charset_name&#x27;SET CHARACTER SET &#x27;charset_name&#x27; Answer:因為這些 statement 或 flag 都會嘗試將上述的 character_set 設定給 character_set_client # Client Program Connection Character Set ConfigurationMySQL 中, 預設 server 是依據什麼資料來設定 character_set_client, character_set_results, 以及 character_set_connection使用者的 default collation MySQL 中, 如果 server 不支援使用者要求的 character_set 或 collation, server 會使用哪一種 character set?server character set and collation MySQL 中, compiled-in 的 default character set 是哪一種？utf8mb4 MySQL 中, 如果不考慮其他資訊來源, MySQL client 會使用哪一種 character set?compiled-in character set, 即 utf8mb4 MySQL 中, 如果有開啟 auto-detect character set, client 會使用哪裡的資訊來設定 default character set?OS locale MySQL 中, 如果有開啟 auto-detect character set, client 會使用哪裡的資訊來設定 default character set?OS locale MySQL 中, 如果 OS character set 跟 MySQL character set 的沒有完全一樣, 那會使用哪一種 OS character set?會 map 到最相近的 MySQL character set MySQL 中, 如果在 OS character set 自動 Map 到最相近的 MySQL character set 之後, MySQL Client 並不支援該 character set, 那會使用哪一種 character set?compiled-in character set MySQL 中, 有哪兩種方法可以定義 default character set? 在 my.cnf 檔案設定 每次連線時, 都使用 SET_NAMES ‘charset_name’ # SQL Statements for Connection Character Set Configuration以下的 MySQL example code 又等同哪一句 SQL Statement? Example:SET character_set_client = charset_name;SET character_set_results = charset_name;SET character_set_connection = charset_name; Answer:SET NAMES &#x27;charset_name&#x27; 以下的 MySQL example code 的意思是? Example:SET NAMES &#x27;charset_name&#x27; COLLATE &#x27;collation_name&#x27; Answer:MySQL 預設會依照 character_set_connection 去設定 default 的 collation_connection, 但如果要特別指定的話, 如上 example 以下的 MySQL example code 又等同哪一句 SQL Statement? Example:SET character_set_client = charset_name;SET character_set_results = charset_name;SET collation_connection = @@collation_database; Answer:SET CHARACTER SET &#x27;charset_name&#x27; 以下的 MySQL my.cnf example code 的意思是? Example:[mysql]default-character-set=koi8r Answer:指定每次連線都去修改三個與 connection 相關的 system variable, 同 SET NAMES ‘charset_name’ # Connection Character Set Error Handling# Connect-Time Error Handling","link":"/zh-tw/character-sets-collations-unicode/"},{"title":"在 Linux 上建立一個 SFTP Server","text":"前言本篇記錄如何在 Linux 上建立一個 SFTP Server, 需滿足以下幾點條件： 使用者不可經由 SSH 登入 使用者可經由 SFTP 登入 使用者只可在指定目錄活動 使用者可上傳下載指定目錄內的檔案 環境GCP Ubuntu 18.04以下操作皆默認 root 操作, 請在前面加上 sudo 如果你不是使用 root 操作 建立 SFTP 群組 建立 group group add sftp-users 確認 group 有正確被建立 grep &#x27;sftp-users&#x27; /etc/group 建立 SFTP 使用者 建立使用者 useradd -g sftp-users -d /upload -s /sbin/nologin test -g: 預設 group-d: 預設家目錄-s: 預設 shell, nologin shell 一般用於系統帳號, 表示不可經由 ssh 登入 確認使用者有正確被建立 grep test /etc/passwd 如果使用者早已建立, 可直接更改使用者設定即可 usermod -g sftp-users -d /upload -s /sbin/nologin test SSH 設定 打開 SSH 設定檔 vim /etc/ssh/sshd_config 複製 Subsystem 以作修改用, 並註解原本的 # Subsystem sftp /usr/lib/openssh/sftp-serverSubsystem sftp internal-sftp 指定群組根目錄 Match Group sftp-users ChrootDirectory /home/sftp-users/%u ForceCommand internal-sftp ChrootDirectory: 設定該群組根目錄 %u: user 的意思, 所以任何該群組下的 user 登入之後的根目錄就會變成 user 的名稱, 以這個例子來看, 根目錄就是 /home/sftp-users/test ForceCommand: 強制使用 internal-sftp 以上 Match 的設定, 請置於檔案的最末處, 否則會有語法錯誤。 上傳下載資料夾建立 建立使用者上傳下載用資料夾install -d -o test -g sftp-users /home/sftp-users/test/upload -d: 類型為資料夾-o: owner-g: group 使用者只能在這個剛剛建立的 upload 資料夾裡頭, 才有權限上傳跟下載。根據 SSH 安全規則, chrootDirectory 的 owner 必須是 root 才行, 且權限只有 root 才可以有 w 的權限, 如果這邊沒有設定為 root, 使用者是無法登入的 大功告成","link":"/zh-tw/buildSftpServerOnLinux/"},{"title":"Cloud Functions 初探 - Command Line","text":"概述Google Cloud Functions 是一個用來建立以及連結雲端服務的無伺服器執行環境。 你可以利用 Cloud Functions 來寫簡單，單一用途的 functions, 這些 functions 被附加到雲端基礎設施以及服務的事件上。 當監聽的事件被觸發， Cloud Function 也會被觸發。 你的代碼將在一個完全自動化管理的環境中被執行。 你完全不需要提供任何的基礎設施或管理任何的伺服器。 Cloud Functions 由 Javascript 所編寫，並且執行在 Google Cloud Platform 的 Node.js 環境。 你可以讓你的 Cloud Functions 運行在任何的 Node.js 執行階段上，這不只攜帶輕便，而且更讓本地測試非常簡單。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 連結並且延伸雲端服務Cloud Functions 提供一個邏輯的連結層，它可以讓你在上面寫代碼來連接並且延伸雲端服務。 監聽並且回應 Cloud Storage 的檔案上傳事件，一個紀錄改變事件，或是 Cloud Pub/Sub 的訊息觸發事件。 Cloud Functions 擴大已經存在的雲端服務，並且允許使用客制的程式邏輯來處理越來越多的使用情境。 Cloud Functions 擁有 Google Service Account credential 的存取權，因此可以無縫接軌大部分的 Google Cloud Platform 服務，像是 Datastore, Cloud Spanner, Cloud Translation API, Cloud Vision API, 以及很多很多其他的服務。 並且，很多的 Node.js client libraries 都有支援 Cloud Functions, 這更是簡化了這些服務之間的整合。 事件以及觸發 (Events and Triggers)雲端事件是發生在雲端環境的事。 像是資料庫的資料有所改變，檔案被上傳到儲存區，或是一台新的虛擬機背建立。 不管你是否選擇回應，事件都會發生。 你可以使用 trigger 來建立對一個事件的回應。 Trigger 是一個宣告，對那些你有興趣的特定的或是一連串事件的宣告。 將一個 function 連結到 trigger 讓我們可以捕捉，並且隨著事件的發生有所動作。 更多有關建立 trigger 並且將它與 function 關聯的資訊，請參考 Events and Triggers 無伺服器Cloud Functions 幫我們拿掉了這些工作，像是伺服器管理，軟體設置，框架更新，作業系統更新。 你只需要專注在代碼的部分，因為 Google 完全地幫你管理軟體以及基礎設施的部分。 再者，資源會隨著事件的回應自動地被提供。 這代表說，你完全不需要做任何事就可以讓一個 function 從一天幾次的調用，到一天好幾百萬次的調用。 使用情境異步的工作量像是輕量化的 ETL, 或是雲端自動化像是應用被觸發而自動建立，不再需要獨立的伺服器以及開發者的維護。 你只要簡單的部署 Cloud Function 並且和你想要的事件做連結。 Cloud Functions 的這些細緻的，立即提供的特質讓它非常適合輕量化的 API 以及 webhooks。 再者，當你部署一個 HTTP Function，該 HTTP endpoints 將會自動地被提供，這代表你不再需要像其他服務的複雜設置。 下面的表格列出了一些額外的常用 Cloud Function 的使用情境： 使用情境 | 敘述— |Data Processing / ETL | 監聽並且回應 Cloud Storage 事件像是當一個檔案被建立，被改變，或是被移除了。 處理圖片，影片編譯，資料驗證及轉換，以及從 Cloud Functions 上觸發任何網路上的服務。Webhooks | 經由簡單的 HTTP trigger, 回應那些來自第三方的事件，像是 GitHub, Slack, Stripe, 或是任何可以發 HTTP requests 的來源。輕量化 APIs | 使用輕量化、不緊密相依、快速建立，以及立即可調整大小的邏輯來建構你的應用。 你的 functions 可以被事件驅動或者是直接通過 HTTP/S 觸發可攜式後端 | 使用 Google 專為 App 開發者的可攜式平台, Firebase, 以及在 Cloud Functions 建構你自己的移動後端。 監聽以及回應來自於 Firebase Analytics, Realtime Database, Authentication, 以及 Storage 的事件。IoT | 想像一個數以萬計的裝置串流資料到 Cloud Pub/Sub, 然後啟動 Cloud Functions 來處理，轉換，並且儲存資料。 Cloud Functions 讓你使用完全無伺服器的方式來做到這些事。 這個手把手的教程將會教你如何使用 Google Cloud 主控台來建立，部署，並且測試 Cloud Function 你將會做什麼？ 建立一個 cloud function 部署並且測試這個 function 檢視紀錄 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個 function首先，你將會建立一個名為 helloWorld 的簡單 function。 這個 function 會寫一段訊息到 Cloud Functions 的紀錄。 它被 cloud function 事件所觸發，並且當這個 function 成功執行完成, 可以執行一個回呼函式 在本教程中, cloud function 事件會是一個 cloud pub / sub topic 事件。 Cloud Pub / Sub 是一種「發佈/訂閱 (Pub / Sub) 服務」：將訊息傳送者與訊息接收者分離的訊息傳遞服務。 若欲了解更多有關 pub / sub 的資訊，可以參考文件 執行以下指令來建立一個 cloud function: 在 Cloud Shell 命令列視窗中, 建立一個置放 function 代碼的資料夾 mkdir gcf_hello_world 移動到 gcf_hello_world 資料夾 cd gcf_hello_world 建立並且打開編輯 index.js vim index.js 將以下的代碼複製貼上到 index.js /** * Cloud Function. * * @param &#123;object&#125; event The Cloud Functions event. * @param &#123;function&#125; callback The callback function. */exports.helloWorld = function helloWorld (event, callback) &#123; console.log(`My Cloud Function: $&#123;JSON.stringify(event.data.message)&#125;`); callback();&#125;; 輸入 :wq 儲存並且離開檔案 建立一個 cloud storage bucket (儲存區)使用以下指令來為你的 function 建立一個新的 cloud 儲存區 cloudgsutil mb -p [PROJECT_ID] gs://[BUCKET_NAME] PROJECT_ID 為此教程中的 GCP Project ID, 如下圖。 如果你沒有使用 Qwiklab, 此 Project ID 為你 GCP 帳號下的 Project ID BUCKET_NAME 是你給予這個儲存區的名稱。 它必須是獨一無二的名字。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 部署你的 function當部署一個新的 function, 你必須要指令 --trigger-topic, --trigger-bucket, 或 --trigger-http。 當你更新現有的 function 時, 觸發條件不會更改, 除非你有另外指定。 在本教程中, 你將會設定 hello_world 為 --trigger-topic 部署這個 function, 並使用 pub / sub 為觸發事件, 名稱為 hello_world, 將以下的 [BUCKET_NAME] 替換成你的儲存區名稱 cloudgcloud functions deploy helloWorld \\ --stage-bucket [BUCKET_NAME] \\ --trigger-topic hello_world \\ --runtime nodejs6 核對 function 的狀態cloudgcloud functions describe helloWorld 狀態 ACTIVE 顯示這個 function 已經被成功部署 entryPoint: helloWorldeventTrigger: eventType: providers/cloud.pubsub/eventTypes/topic.publish failurePolicy: &#123;&#125; resource:...status: ACTIVE... 每一條由這個主題發布的訊息都將觸發這個 function, 訊息內容為輸入的資料 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 測試部署上去的 function在你部署這個 function 上去, 並且知道它的狀態是 active 之後，讓我們來測試看看這個 function 會不會再偵測到事件之後寫一段訊息到 cloud 紀錄 輸入以下指令來建立一個訊息, 測試這個 function gcloud functions call helloWorld --data &#x27;&#123;&quot;message&quot;:&quot;Hello World!&quot;&#125;&#x27; cloud 工具返回了一個此 function 的 execution ID, 這表示訊息已經被寫到紀錄了 範例輸出： executionId: 3zmhpf7l6j5b 檢視紀錄來確認有這個 execution ID 的訊息記錄 檢視紀錄檢視歷史紀錄 gcloud functions logs read helloWorld 如果 function 成功地被執行, 訊息記錄會被列出，如下： LEVEL NAME EXECUTION_ID TIME_UTC LOGD helloWorld 3zmhpf7l6j5b 2017-12-05 22:17:42.585 Function execution startedI helloWorld 3zmhpf7l6j5b 2017-12-05 22:17:42.650 My Cloud Function: Hello World!D helloWorld 3zmhpf7l6j5b 2017-12-05 22:17:42.666 Function execution took 81 ms, finished with status: &#x27;ok&#x27; 你的應用已經完成部署, 測試, 並且你可以檢視紀錄 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 答案: true","link":"/zh-tw/cloudFunctionsQwikStartCommandLine/"},{"title":"Cloud Functions 初探 - 主控台","text":"概述Google Cloud Functions 是一個用來建立以及連結雲端服務的無伺服器執行環境。 你可以利用 Cloud Functions 來寫簡單，單一用途的 functions, 這些 functions 被附加到雲端基礎設施以及服務的事件上。 當監聽的事件被觸發， Cloud Function 也會被觸發。 你的代碼將在一個完全自動化管理的環境中被執行。 你完全不需要提供任何的基礎設施或管理任何的伺服器。 Cloud Functions 由 Javascript 所編寫，並且執行在 Google Cloud Platform 的 Node.js 環境。 你可以讓你的 Cloud Functions 運行在任何的 Node.js 執行階段上，這不只攜帶輕便，而且更讓本地測試非常簡單。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 連結並且延伸雲端服務Cloud Functions 提供一個邏輯的連結層，它可以讓你在上面寫代碼來連接並且延伸雲端服務。 監聽並且回應 Cloud Storage 的檔案上傳事件，一個紀錄改變事件，或是 Cloud Pub/Sub 的訊息觸發事件。 Cloud Functions 擴大已經存在的雲端服務，並且允許使用客制的程式邏輯來處理越來越多的使用情境。 Cloud Functions 擁有 Google Service Account credential 的存取權，因此可以無縫接軌大部分的 Google Cloud Platform 服務，像是 Datastore, Cloud Spanner, Cloud Translation API, Cloud Vision API, 以及很多很多其他的服務。 並且，很多的 Node.js client libraries 都有支援 Cloud Functions, 這更是簡化了這些服務之間的整合。 事件以及觸發 (Events and Triggers)雲端事件是發生在雲端環境的事。 像是資料庫的資料有所改變，檔案被上傳到儲存區，或是一台新的虛擬機背建立。 不管你是否選擇回應，事件都會發生。 你可以使用 trigger 來建立對一個事件的回應。 Trigger 是一個宣告，對那些你有興趣的特定的或是一連串事件的宣告。 將一個 function 連結到 trigger 讓我們可以捕捉，並且隨著事件的發生有所動作。 更多有關建立 trigger 並且將它與 function 關聯的資訊，請參考 Events and Triggers 無伺服器Cloud Functions 幫我們拿掉了這些工作，像是伺服器管理，軟體設置，框架更新，作業系統更新。 你只需要專注在代碼的部分，因為 Google 完全地幫你管理軟體以及基礎設施的部分。 再者，資源會隨著事件的回應自動地被提供。 這代表說，你完全不需要做任何事就可以讓一個 function 從一天幾次的調用，到一天好幾百萬次的調用。 使用情境異步的工作量像是輕量化的 ETL, 或是雲端自動化像是應用被觸發而自動建立，不再需要獨立的伺服器以及開發者的維護。 你只要簡單的部署 Cloud Function 並且和你想要的事件做連結。 Cloud Functions 的這些細緻的，立即提供的特質讓它非常適合輕量化的 API 以及 webhooks。 再者，當你部署一個 HTTP Function，該 HTTP endpoints 將會自動地被提供，這代表你不再需要像其他服務的複雜設置。 下面的表格列出了一些額外的常用 Cloud Function 的使用情境： 使用情境 | 敘述— |Data Processing / ETL | 監聽並且回應 Cloud Storage 事件像是當一個檔案被建立，被改變，或是被移除了。 處理圖片，影片編譯，資料驗證及轉換，以及從 Cloud Functions 上觸發任何網路上的服務。Webhooks | 經由簡單的 HTTP trigger, 回應那些來自第三方的事件，像是 GitHub, Slack, Stripe, 或是任何可以發 HTTP requests 的來源。輕量化 APIs | 使用輕量化、不緊密相依、快速建立，以及立即可調整大小的邏輯來建構你的應用。 你的 functions 可以被事件驅動或者是直接通過 HTTP/S 觸發可攜式後端 | 使用 Google 專為 App 開發者的可攜式平台, Firebase, 以及在 Cloud Functions 建構你自己的移動後端。 監聽以及回應來自於 Firebase Analytics, Realtime Database, Authentication, 以及 Storage 的事件。IoT | 想像一個數以萬計的裝置串流資料到 Cloud Pub/Sub, 然後啟動 Cloud Functions 來處理，轉換，並且儲存資料。 Cloud Functions 讓你使用完全無伺服器的方式來做到這些事。 這個手把手的教程將會教你如何使用 Google Cloud 主控台來建立，部署，並且測試 Cloud Function 你將會做什麼？ 建立一個 cloud function 部署並且測試這個 function 檢視紀錄 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 建立一個 function在這個步驟，你將使用主控台建立一個 cloud function 在主控台，點擊 Navigation menu &gt; Cloud Functions 點擊 Create function 在 Create function 對話框，輸入以下的值欄位 | 值 — |Name | GCFunctionMemory allocated | DefaultTrigger | HPPT triggerSource code | Inline editor (使用預設被提供給 index.js 的 **helloWorld function 實作) 在下個章節部署 function 部署 function還是在 Create function 對話框，在底部點擊 Create 來部署 function 在你點擊 Create 後，主控台會重導向 Cloud Functions Overview 頁面 當 function 正被部署時，旁邊的小圖案會顯示轉圈圈，當部署完畢，會變成一個打勾的圖案 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 測試 function測試這個被部署上去的 function 在 Cloud Functions Overview 頁面，從右邊三個小點的選單處點擊 Test function 在 Triggering event 欄位，在大括號 &#123;&#125; 之間輸入以下代碼並且點擊 Test the function &quot;message&quot;:&quot;Hello World!&quot; 在 output 欄位，你應該可以看到一段訊息 Success: Hello World! 在 Logs 欄位，一段狀態碼 200 顯示成功。 (紀錄出現可能會需要幾分鐘的時間) View logs (檢視紀錄)從 Cloud Functions Overview 頁面檢視紀錄 點擊藍色箭頭來回到 Cloud Functions Overview 頁面 在 Cloud Functions Overview 頁面，從右邊三個小點的選單處點擊 View logs 紀錄歷史範例如下： 你的應用已經被部署，被測試，而且你已經可以檢視它的紀錄 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： true HTTP 恭喜你已經完成本教程","link":"/zh-tw/cloudFunctionsQwikStartConsole/"},{"title":"Cloud IAM - 初探","text":"概述Google Cloud 身份與存取權管理 (IAM)，提供了為 GCP 資源建立且管理權限。 Cloud IAM 統一 GCP 眾多服務的存取權限控制，且提供一致性的操作。 在本教程中，你將會學到如何賦予使用者角色權限，或是移除 IAM 相關角色權限。 更確切的說，在此教程中登入兩組帳密來體驗權限的允許與廢除在 GCP Owner 與 Viewer 上是如何運作的。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 必要條件這是入門級的教程，如果你對 Cloud IAM 沒有經驗，或只有一點點經驗的話，這個教程會蠻適合你的。 如果你有 Cloud Storage 的經驗，會可能會讓你比較容易完成這個教程，但是如果沒有也沒關係，因為這不是必須的。 要完成本教程，你必須要可以建立 .txt 檔，或者 .html 檔。 如果你在找更進階一點的 Cloud IAM 課程，一定不要錯下面這個： IAM Custom Roles 設定兩個使用者如同早先提到的，本教程提供兩組帳號密碼來模擬 IAM 政策以及特定的角色有什麼樣的權限 在教程頁面的左方，你可以看到帳號密碼列表，代表如下： 注意到，有兩組帳號密碼: Username1 還有 Username2。 分別代表 不同的 Cloud IAM，每一個 IAM 都有各自被分配到的存取權限。 這些 GCP “roles” 根據被分配的權限限制哪些資源你可以存取，哪一些不行 用第一個 user 登入 GCP 主控台 點擊 Open Google Console 按鈕。 這會打開一個新的瀏覽視窗。 如果你被要求 Choose an account, 點擊 Use another account 打開 GCP 登入頁面，複製代表 googlexxxxxx_student@qwiklabs.net 的第一使用者帳號，然後貼到 “Email or phone” 欄位 從 “Connection Details” 複製密碼，然後貼到 Google 登入密碼欄位 點擊 Next 然後 Accept 服務條款。 Google Cloud Platform 主控台開啟。 Agree 服務條款，以及在 Email updates 處勾選 No 用第二個使用者登入 GCP 主控台 再次點擊 Open Google Console 按鈕。 這會打開一個新的瀏覽視窗。 如果你被要求 Choose an account, 點擊 Use another account 打開 GCP 登入頁面，複製代表 googlexxxxxx_student@qwiklabs.net 的第二使用者帳號，然後貼到 “Email or phone” 欄位 從 “Connection Details” 複製密碼，然後貼到 Google 登入密碼欄位 點擊 Next 然後 Accept 服務條款。 Google Cloud Platform 主控台開啟。 Agree 服務條款，以及在 Email updates 處勾選 No 現在你應該要有兩個 GCP Console 視窗是在你的瀏覽器打開的，一個是使用者 1, 一個是使用者 2 在瀏覽視窗重置或者檢視使用者有時候，一個使用者可能會被另一個使用者覆蓋掉，這時候可能會讓你很疑惑目前登入的使用者是哪一個 要知道目前確切登入的使用者是誰，將滑鼠停在大頭貼處，你就可以看到目前的 username 如果你要重置目前登入的使用者 點擊你的 Avatar, 然後點擊 Sign out 來登出 在 Connection Details 面板處，點擊 Open Google Console, 然後再用對的帳號密碼登入一次 IAM 主控台以及專案等級角色 到 Username 1 的 GCP 主控台頁面 選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM 。你現在已經在 “IAM &amp; admin” 主控台 在頁面上方點擊 +ADD 按鈕, 從下拉選單探索與專案相關的角色 你應該會看到 Browser (瀏覽者), Editor (編輯者), Owner (擁有者), 還有 Viewer (檢視者) 角色。 這四種在 GCP 被熟知為 原始角色 (primitive roles) 。 原始角色設定專案等級的權限，並且，除非有特別指定，否則他們的存取管理權限範圍涵蓋所有的 GCP 服務 下面表格中的角色從 GCP roles documentation 提取定義，給予瀏覽者，編輯者，擁有者，以及檢視者權限的簡單概述 角色名稱 | 權限——- |角色/檢視者 | 擁有不影響狀態的 只讀 權限，例如檢視 (但不可修改) 已存在的資源或檔案角色/編輯者 | 擁有檢視者的所有權限，外加修改的權限，例如可以改變已存在的資源角色/擁有者 | 擁有編輯者的所有權限，外加以下的權限 管理專案內所有角色的權限設定專案的帳單角色/瀏覽者 (beta) | 擁有可以瀏覽專案階層關係的權限，包含資料夾，組織，以及 Cloud IAM 政策。 但此角色不包含檢視專案內資源的權限 因為我們可以管理這個專案的角色以及全縣，所以 Username 1 有專案擁有者的權限 點擊 CANCEL 離開 “Add member” 面板 探索編輯者角色現在切換到 Username 2 主控台 移動到 IAM &amp; admin 主控台，選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM 在表格內搜尋一下 Username 1 以及 Username 2, 然後看一下他們被賦予的角色，你應該可以看到如下圖: 你應該會看到: Username 2 有 “檢視者” 的角色 頁面上方的 +ADD 按鈕是反灰的 - 如果你試圖點擊它，你會看到以下的訊息 這是一個範例，展示了 IAM 角色影響決定了你在 GCP 專案中哪些可以做，哪些不能做 下一步，我們切換到 Username 1 主控台 準備一個資源來測試存取確定你在 Username 1 的主控台 建立一個儲存區 建立一個 GCS 儲存區，給予一個獨特的名字。 從主控台，選擇 Navigation menu &gt; Storage &gt; Browser 點擊 Create bucket 注意: 如果出現一個儲存區建立的權限錯誤，先登出再使用 Username 1 登入 更新以下的欄位，沒提到的留為預設 注意儲存區的名字，之後會用到 點擊 Create 注意: 如果出現一個儲存區建立的權限錯誤，先登出再使用 Username 1 登入 上傳一個範例檔案 在儲存區的細節頁面，點擊 Upload files 按鈕 瀏覽你的電腦，找一個可以使用的檔案，任何 text 或 html 檔都可以 在檔案那一行的行末，點擊三個小點的圖案，然後點擊 Rename 更新檔名為 sample.txt 點擊 Rename 點擊 Check my progress 來核對目前進度 核對專案檢視者存取權限現在切換到 Username 2 主控台 從主控台： 選擇 Navigation menu &gt; Storage &gt; Browser 。 核對這個使用者可以看到這個儲存區 Username 2 被賦予 “檢視者” 角色，這個角色有不影響狀態的 “只讀” 權限。 這個範例說明了這個功能 - 在權限範圍內的 GCP 專案，他們可以檢視 Cloud Storage 儲存區，以及檔案 移除專案存取權限現在切換到 Username 1 主控台 移除 Username 2 的專案檢視權限 選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM , 然後點擊 Username2 旁的鉛筆圖案 你可以要將螢幕變寬來看到鉛筆圖案 點擊角色名稱旁邊的垃圾桶圖案來移除 Username 2 的檢視者權限, 然後點擊 SAVE 注意到這個使用者已經從清單上消失了，這個使用者現在已經沒有存取權了 備註: 這個動作要完全生效到所有的服務，可能會需要最多 80 秒的時間，更多資訊請參考這裏 核對 Username 2 已經沒有存取權了 切換到 Username 2 主控台。 確認一下目前是 Username 2 登入狀態，而且 Username 2 在生效之後還沒被登出, 如果登出了，在登入一次。 選擇 Navigation menu &gt; Home 點擊 Navigation menu &gt; Storage &gt; Browser 來移動到 Cloud Storage 你應該會看到錯誤如下： 備註： 如同之前提到的，變更生效大概需要最多 80 秒。 如果你沒有收到權限錯誤，等兩分鐘之後再重整一下頁面 點擊 Check my progress 來和對目前進度都有完成 增加儲存權限 從 “Connection Details” 面板複製 Username 2 切換到 Username 1 主控台。 確認一下目前是 Username 2 登入狀態，而且 Username 2 在生效之後還沒被登出, 如果登出了，在登入一次。 選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM 點擊 +ADD 然後貼上 Username 2 的名字到 member field 在角色欄位，從下拉選單選擇 Storage &gt; Storage Object Viewer 點擊 SAVE 核對存取權 切換到 Username 2 主控台Username 2 沒有專案檢視者的角色，所以使用者不能在主控台看到專案或者任何專案的資源。但是，這個使用者對 Cloud Storage 有特別的存取權，讓我們來驗證一下 點擊 Activate Cloud Shell 圖案來打開 Cloud Shell 命令列 打開 Cloud Shell 視窗，輸入以下的指令，記得用我們一開始建立的儲存區名字來將指令中的 [YOUR_BUCKET_NAME] 取代掉 gsutil ls gs://[YOUR_BUCKET_NAME] 你應該會收到類似下面的輸出 gs://[YOUR_BUCKET_NAME]/sample.txt 如你所見，你已經給了 Username 2 Cloud Storage 儲存區的檢視權限 點擊 Check my progress 來和對目前進度都有完成 恭喜你已經完成本教程！","link":"/zh-tw/cloudIAMQwikStart/"},{"title":"Cloud Storage 初探 - CLI/SDK","text":"概述Google Cloud Storage 提供世界級的儲存服務並且你可以在任何時間取回任何大小的資料。 Google Cloud Storage 提供了很多的使用情況, 包含網站內容, 歸檔類型或是災後復原類型的資料儲存, 或是提供使用者大檔案物件直接下載的方式。 在這個手把手教程中, 你將會學習到如何使用 Google Cloud Platform 命令列工具 來建立一個儲存區, 然後上傳物件, 建立資料夾以及子資料夾, 以及讓這些物件可被公開存取。 在本教程中, 你將能夠在主控台的 Navigation menu &gt; Storage 核對你的進度。 你只需要在每一個指令之後重整你的瀏覽器來檢視你建立的新項目 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個儲存區執行 gsutil mb 指令並取代 unique name 來建立一個儲存區 gsutil mb gs://YOUR-BUCKET-NAME/ 命名規則： 不要有機敏資訊，因為儲存區的名字是公開可被大家看到的 儲存區的名字一定只可以有 小寫字母 ,數字, -, _, ., 若是名字含有 ., 需要驗證 儲存區的名字必須由數字或字母來開始以及結束 儲存區的名字必須含有 3 到 63 的字元，含有 . 的名字最多 222 個字元，但是每個被 . 分開的字元，最多不可超過 63 字元。 儲存區的名字不可以帶點十進制的方式表示，像是 IP 位址 (例如, 192.168.5.4) 儲存區的名字不可由 goog 開頭 儲存區的名字不可含有 google 或近似字串 還有，為了符合 DNS 命名規則以及之後的相容性，不可使用 _, 或是兩個 . 相連，或與 dash 相連，例如 .., 或 -., 或 .-, 這些都不符合 DNS 命名規則 如果成功執行，回應如下： Creating gs://YOUR-BUCKET-NAME/... 你已經建立一個可以用來儲存你的東西的儲存區備註: 如果名字已經被使用了，可能是你或別人，回應如下 Creating gs://YOUR-BUCKET-NAME/... ServiceException: 409 Bucket YOUR-BUCKET-NAME already exists. 用別的名字在試一次 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 每個儲存區中，都有一個預設的儲存類別，你可以在建立的時候指定它 true false 上傳一個物件到你的儲存區現在上傳一個物件到你的儲存區 先下載這個圖片到暫時性的 instance (ada.jpg) 到 Cloud Shell wget --output-document ada.jpg https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Ada_Lovelace_portrait.jpg/800px-Ada_Lovelace_portrait.jpg 使用 gsutil cp 指令, 從本地儲存的位置上傳圖片到你建立的儲存區中： gsutil cp ada.jpg gs://YOUR-BUCKET-NAME 訣竅: 當你輸入你的儲存區的名字, 可以使用 tab 來自動補齊你可以從 Command Line 看到圖片被上傳了，你已經完成了儲存一個物件在你的儲存區中!現在讓我們刪掉它 rm ada.jpg 從儲存區下載物件使用 gsutil cp 指令, 將你存在儲存區的圖片下載到 Cloud Shell gsutil cp -r gs://YOUR-BUCKET-NAME/ada.jpg . 如果成功的話，應會回傳如下： Copying gs://YOUR-BUCKET-NAME/ada.jpg.../ [1 files][299.6 KiB/299.6 KiB]Operation completed over 1 objects/299.6 KiB. 你剛剛已經完成了從儲存區下載圖片！ 複製一個物件到儲存區內的一個資料夾使用 gsutil cp 指令來建立一個名為 image-folder 的資料夾，並且將圖片（ada.jpg) 複製過去 gsutil cp gs://YOUR-BUCKET-NAME/ada.jpg gs://YOUR-BUCKET-NAME/image-folder/ 備註: 與本地的文件系統相比，在 Google Cloud Storage 的資料夾有一些限制, 但很多相同的操作是都有支援的。 如果成功的話，應該會回傳如下： Copying gs://YOUR-BUCKET-NAME/ada.jpg [Content-Type=image/png]...- [1 files] [ 299.6 KiB/ 299.6 KiB]Operation completed over 1 objects/299.6 KiB 現在，圖片已經被複製到儲存區內的新的資料夾內 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功上傳物件到 cloud storage 的資料夾的話，你將看到一個評定的分數 列出儲存區或資料夾內的內容gsutil ls gs://YOUR-BUCKET-NAME 如果成功，回傳應如下： gs://YOUR-BUCKET-NAME/ada.jpggs://YOUR-BUCKET-NAME/image-folder/ 這些是目前在儲存區內的東西 列出物件的細節使用 gsutil ls 指令, 配合 -l flag 來取得我們上傳圖片的細節資訊： gsutil ls -l gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，應會回傳： 306768 2017-12-26T16:07:570Z gs://YOUR-BUCKET-NAME/ada.jpgTOTAL: 1 objects, 30678 bytes (299.58 KiB) 現在你知道圖片的大小和建立的日期了 讓物件可被公開存取使用 gsutil acl ch 指令來給予全部使用者對儲存區內的物件有讀的權限 gsutil acl ch -u AllUsers:R gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，應該會回傳： Updated ACL on gs://YOUR-BUCKET-NAME/ada.jpg 你的圖片目前已經可被公開存取 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功的從 cloud storage 分享物件，你將看到一個評定的分數 驗證你的圖片是否公開可被存取。 到 Navigation menu &gt; Storage , 然後點擊你的儲存區。 你應會看到你圖片的公開存取格子是有被打勾的，點擊檔案，然後圖片將會在瀏覽器的新視窗被開啟 測試你的理解程度底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 存取控制清單 Access Control List (ACL) 是一種可用來定義誰可以存取你的儲存區的一種機制 true false 移除公開存取權限若要移除被存取的權限，使用以下指令 gsutil acl ch -d AllUsers gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，回傳應像是： Updated ACL on gs://YOUR-BUCKET-NAME/ada.jpg 現在你已經移除對這物件的公開存取權限，你可以驗證看看，點擊控制面板中的 Refresh 按鈕。打勾符號將會被移除，這時如果你重新整理圖片，會出錯 測試你的理解程度底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧你可以藉由移除什麼樣的權限屬性來停止公開分享物件： allUsers 移除 project owner role 更新儲存區類別 刪除物件使用 gsutil rm 來移除一個物件 - 在儲存區中的圖片 gsutil rm gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，回傳應會如下： Removing gs://YOUR-BUCKET-NAME/ada.jpg... 重新刷新面板。 複製的圖片檔案已經不存在 Cloud Storage 了 （儘管複製在 image-folder 資料夾內還是存在唷） 恭喜!你已經完成本教程","link":"/zh-tw/cloudStorageQwikStartCLISDK/"},{"title":"Kubernetes - Health Check","text":"概述本篇會示範如何設定 liveness probe(存活探針), readiness probe(就緒探針), 以及 startup probe(啟動探針)。 kubelet 使用 liveness probe 來決定何時重啟容器, 舉例來說, 當你的應用處於運行中, 但是卻無法處理 request。 kubelet 使用 readiness probe 來決定這個容器是否已經準備就緒, 可以接收流量了。 當一個 Pod 內的所有容器都就緒了, 該 Pod 才算是就緒。 如果一個 Pod 尚未就緒, 它將會從 Service 負載平衡的後端清單中被移除。kubelet 使用 startup probe 來決定一個容器應用是否已經成功啟動了。 當 startup probe 判定為 success 之前, liveness probe 跟 readiness probe 是沒有作用的。 這可以用在某些會花比較久時間來啟動的應用, 這樣就不會在還沒啟動完成前就因為 liveness 判定失敗而給殺掉了。 本篇主要是個人學習 Kubernetes health check 的一篇筆記, 內容你會看到很多很多的 Q&amp;A, 因為 Ray 個人習慣將長篇的理論知識切割成零碎 Q&amp;A, 適合我個人學習吸收, 考試都考 100 分呢！ 定義存活探針指令許多應用長時間運行後, 就陷入一個壞掉的狀態, 這時候唯有重啟才可恢復。 Kubernetes 提供了 liveness probe 來偵測並且排除這樣的狀況讓我們啟動一個 Pod, 這個 Pod 會運行 k8s.gcr.io/busybox 鏡像, 以下是該 Pod 的設定檔: apiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-execspec: containers: - name: liveness image: k8s.gcr.io/busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 這邊針對上面的 yaml file 做解說： periodSeconds: liveness probe 多久檢查一次 initialDelaySeconds: 首次啟動後, 要延遲多久在執行 cat /tmp/healthy: livenessProbe 會執行這段執行, 如果成功則回傳 0, 其他都是失敗。 當容器啟動時, 會執行 /bin/sh -c &quot;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&quot;, 會先建立 /tmp/healthy, 然後 sleep 30 秒, 所以在這 30 秒間, /tmp/healthy 是存在的。 30 秒後會把 /tmp/healthy 砍了, 然後 sleep 600 秒, 在這 600 秒間, 指令會回傳錯誤 接著來實際操作一回: 建立 Pod kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml 頭 30 秒, 執行以下指令檢視 Pod 事件： kubectl describe pod liveness-exec 輸出未顯示 liveness probe 失敗 FirstSeen LastSeen Count From SubobjectPath Type Reason Message--------- -------- ----- ---- ------------- -------- ------ -------24s 24s 1 &#123;default-scheduler &#125; Normal Scheduled Successfully assigned liveness-exec to worker023s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulling pulling image &quot;k8s.gcr.io/busybox&quot;23s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulled Successfully pulled image &quot;k8s.gcr.io/busybox&quot;23s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Created Created container with docker id 86849c15382e; Security:[seccomp=unconfined]23s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Started Started container with docker id 86849c15382e 35 秒後, 在檢視一次 kubectl describe pod liveness-exec 輸出可以看到, liveness probe 失敗了 FirstSeen LastSeen Count From SubobjectPath Type Reason Message--------- -------- ----- ---- ------------- -------- ------ -------37s 37s 1 &#123;default-scheduler &#125; Normal Scheduled Successfully assigned liveness-exec to worker036s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulling pulling image &quot;k8s.gcr.io/busybox&quot;36s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulled Successfully pulled image &quot;k8s.gcr.io/busybox&quot;36s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Created Created container with docker id 86849c15382e; Security:[seccomp=unconfined]36s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Started Started container with docker id 86849c15382e2s 2s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Warning Unhealthy Liveness probe failed: cat: can&#x27;t open &#x27;/tmp/healthy&#x27;: No such file or directory 在等 30 秒, 看容器有沒有被重啟 kubectl get pod liveness-exec 看來是重啟了, 並且重啟次數加一 NAME READY STATUS RESTARTS AGEliveness-exec 1/1 Running 1 1m 定義 liveness HTTP requestliveness probe 另外一種方式為 HTTP request, 以下設定檔為運行鏡像 k8s.gcr.io/liveness 的 Pod apiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-httpspec: containers: - name: liveness image: k8s.gcr.io/liveness args: - /server livenessProbe: httpGet: path: /healthz port: 8080 httpHeaders: - name: Custom-Header value: Awesome initialDelaySeconds: 3 periodSeconds: 3 針對以上的設定檔做解釋: periodSeconds: 每 3 秒檢查一次 initialDelaySeconds: 容器啟動後, 要延遲 3 秒再開始探針 這次探針實施的方式為傳送 HTTP GET request 到 server 的 port 8080 如果 /haalthz 回傳 200~399, 則表示成功, 其餘都失敗 如果有興趣可以去看此鏡像的原始碼, 如以下程式碼, 10 秒後開始回傳 500, 10 秒內回傳 200http.HandleFunc(&quot;/healthz&quot;, func(w http.ResponseWriter, r *http.Request) &#123; duration := time.Now().Sub(started) if duration.Seconds() &gt; 10 &#123; w.WriteHeader(500) w.Write([]byte(fmt.Sprintf(&quot;error: %v&quot;, duration.Seconds()))) &#125; else &#123; w.WriteHeader(200) w.Write([]byte(&quot;ok&quot;)) &#125;&#125;) kubelet 會在容器啟動後 3 秒開始探測, 所以一開始的健康健康會是 success 的, 但是 10 秒後就會開始 fail, 然後 kubelet 會把容器殺掉並且重啟 以下實際試試 HTTP liveness check 建立 Pod kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml 10 秒後, 檢視 liveness probe 事件, 可以發現已經失敗並且又重啟了 kubectl describe pod liveness-http 在版本 v1.13 之前 (包含 v1.13), 如果在 node 有設定 http_proxy (或 HTTP_PROXY) 環境變數, 則 HTTP liveness 會使用這個 proxy, v1.13 之後的版本不會影響 HTTP liveness probe 定義 TCP liveness probe第三種 liveness probe 使用 TCP Socket, 如下設定檔, kubelet 會嘗試在你容器上的一個特定的 port 開啟一個 socket, 如果可以建立連線, 則成功, 反之則視為失敗 apiVersion: v1kind: Podmetadata: name: goproxy labels: app: goproxyspec: containers: - name: goproxy image: k8s.gcr.io/goproxy:0.1 ports: - containerPort: 8080 readinessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 periodSeconds: 10 livenessProbe: tcpSocket: port: 8080 initialDelaySeconds: 15 periodSeconds: 20 以下依序來解釋上面設定檔的步驟： TCP 檢查跟 HTTP 檢查很類似 這個範例同時使用了 readiness probe 以及 liveness probe 容器啟動五秒後, kubelet 會發送第一個 readiness 探測 readiness 探測會嘗試連結 goproxy 容器的 port 8080, 如果成功, 表示該容器 ready kubelet 會持續的每十秒做一次檢查 kubelet 會在容器啟動十五秒後, 發送第一個 liveness 探測 liveness 探測會嘗試連結 goproxy 容器的 port 8080, 如果失敗, 容器會被重新啟動 liveness probe 每二十秒探測一次 以下可以實際操作看看： 建立 Pod kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml 十五秒後, 檢視 Pod 事件來看看 liveness 的狀態: kubectl describe pod goproxy 使用命名 port在 HTTP 或 TCP liveness 檢查中, 你可以使用一個命名過的 port, 如下 ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port 使用 startup probes 來保護啟動較慢的容器某些時候, 你可能會碰到會花較久時間在容器首次啟動的應用, 這個時候你不需要提高 liveness probe 的失敗門檻, 你可以使用 startup probe, 重點就是, 設定 failureThreshold * periodSeconds 的時間, 這個時間要長於正常應用啟動可能耗費的最大時間, 如下範例： ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 以下針對上面的配置檔做解說: 應用會有最長五分鐘的啟動時間 (30 * 10 = 300s) 一旦 startup probe 被判定為成功, liveness probe 會接手, 從原本擁有高容許失敗門檻啟動偵測變成一次失敗就重啟的卡死偵測 如果 startup probe 一直失敗, 那超過 300s 後, 容器會被殺掉, 並視乎 restartPolicy 看是否重啟 定義 readiness probes某些時候, 應用會暫時的無法處理流量, 舉例來說, 當在啟動時載入大量資料或是設定檔時, 或是在啟動後依賴外部服務時。 在這些情況下, 你不需要殺掉容器, 但你需要暫時的不將請求送往這些容器。 Kubernetes 提供了 readiness probe 來解決這個問題, 如果一個 Pod 被 readiness probe 回報 not ready 的話, 那該 Pod 將不會收到來自於 Kubernetes Services 的流量Readiness probe 的運行是不間斷的Readiness probe 的設定基本上跟 liveness probe 差不多, 只差在 readinessProbe 換成 livenessProbe, 如下： readinessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 Readiness probe 跟 liveness probe 可以一起使用, 避免一些狀況, 例如說該容器暫時還無法處理流量, 但還收到 Service 的請求, 這時候 liveness probe 探測失敗, 就直接將容器殺掉了。 設置 Probes以下介紹幾個 Probes 的 field, 更精確的控制 livenss 跟 readiness 的檢查行為 intialDelaySeconds: 在容器首次啟動時, 控制 liveness probe 或 readiness probe 開始探測的延遲時間, 預設為 0 秒, 最小為 0 periodSeconds: 多久探測一次, 預設 10 秒, 最短 1 秒 timeoutSeconds: 幾秒沒收到回應時判斷為失敗, 預設 1 秒, 最短 1 秒 successThreshold: 在檢查被判定失敗後, 接下來要多少次連續判定成功才算成功, 預設 1 次, liveness 必須設為 1 次, 最小可設為 1 次 failureThreshold: 當 Pod 被偵測到失敗時, Kubernetes 會持續嘗試直到滿足此欄位設定的次數, 這樣才算失敗, 套用在 liveness probe 上就是重啟容器, 而套用在 readiness probe 上就是標示該容器為 unready, 預設為 3 次, 最小可設為 1 次 以下介紹幾個 HTTP probes, 可設在 httpGet 的欄位： host: 要連結的 host name, 預設為 pod IP, 相比在 httpHeaders 中設定, 你可能會想要使用這一個欄位來設定 scheme: 連接到 host 的 scheme (HTTP 或 HTTPS), 預設為 HTTP path: 存取 HTTP server 的路徑 httpHeaders: 客製化設定請求的 header, HTTP 允許重複的 header port: 可以使用 port number 或已命名的 port, 如果是 port number, 範圍須介於 1 ~ 65535 針對上面的 HTTP probes 行為做補充解釋: 如果使用 HTTP probe, kubelet 會發送 HTTP 請求到指定的 path 以及 port 來做檢查 kubelet 預設使用 pod 的 IP 位址, 除非在 host 欄位有特別指定 如果 scheme 欄位設為 HTTPS, 則 kubelet 會發送 HTTPS 請求, 並且略過憑證檢查 大部分的情況, 你不會去設定 host 欄位, 除非以下特殊情況 假如你的容器監聽 127.0.0.1, 然後 pod 的 hostNetwork 欄位為 true, 那 httpGet 下的 host 欄位需設定為 127.0.0.1 如果你的 pod 取決於 virtual hosts, 你不可使用 host 欄位, 而是要設定 httpHeaders 欄位中的 Host header TCP probe 中, kubelet 是在 node 中建立連線, 不是在 pod 中, 所以 host 欄位中不可使用 service name, 否則 kubelet 將無法解析它 參考資料 官方文件 Fantastic Probes And How To Configure Them — A Kubernetes Story Q&amp;A Kubernetes 中, 當我使用 TCP probe 時我無法在 httpGet 下的 host 使用 service name, 為什麼？因為 kubelet 是在 node 建立 connection, 並非在 pod Kubernetes 中, 如果我將 httpGet 下的 scheme 欄位設置為 HTTPS, 那會怎麼樣？kubelet 會發送 HTTPS 請求且會略過憑證驗證 Kubernetes 中, 預設 httpGet 下的 host 是什麼？pod 的 ip kubernetes 中, failureThreshold 預設為幾次?3 次 kubernetes 中, successthreshold 在 liveness probe 必須設為多少？1 Kubernetes 中, 健康檢查可以設定最短多久檢查一次？1 秒 Kubernetes 中, 健康檢查預設幾秒檢查一次？10 秒 Kubernetes 中, startup probe 解決了什麼問題？對於啟動時間較長的應用可以有高容許失敗門檻, 一旦啟動完成後, 切換成低失敗容許門檻的 liveness probe Kubernetes 中, liveness probe 可以解決什麼問題？一個 container 有在運行, 但是卻無法正常運作 Kubernetes 中, 如果一個 pod 裡頭有一個 container 沒通過 readiness probe, 那這個 pod 算 ready 嗎？不算 Kubernetes 中, readiness probe 的作用是？決定容器是否已準備開始接受流量 Kubernetes 中, 一個尚未通過 readiness probe 的 container, 會被列在 service load balancers 的後端之一嗎？不會 Kubernetes 中, startup probe 的作用是？判斷一個容器何時完成啟動 Kubernetes 中, 如果 startup probe 尚未通過, readiness probe 或 liveness probe 會開始運作嗎？不會哦 請試著解釋以下 kubernetes yaml file 中的每一條 directive ？ yaml file:apiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-execspec: containers: - name: liveness image: k8s.gcr.io/busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 Answer:# API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 labels, 可被 selector 選擇, 為 key/value pair labels: test: liveness # 該 pod 的 name name: liveness-exec# 該 pod 運行的規格spec: # 定義容器 containers: # 容器名稱 - name: liveness # 鏡像名稱 image: k8s.gcr.io/busybox # 容器啟動後運行的指令 args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 # 存活探針 livenessProbe: # 探測方式為 exec, 執行指定的 command, 若回傳值非為 0, 則視為失敗 exec: # 定義 command command: - cat - /tmp/healthy # 首次啟動容器時, 探針延遲 5 秒, 以等待所有資源準備就緒 initialDelaySeconds: 5 # 每五秒探測一次 periodSeconds: 5 Kubernetes 中, health check 有哪三種探針？ startup probe liveness probe readiness probe 試著解釋以下 kubernetes yaml file 中的每一條 directive yaml file:apiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-httpspec: containers: - name: liveness image: k8s.gcr.io/liveness args: - /server livenessProbe: httpGet: path: /healthz port: 8080 httpHeaders: - name: Custom-Header value: Awesome initialDelaySeconds: 3 periodSeconds: 3 Answer:# API 版本apiVersion: v1# 種類為 podkind: Pod# 該 pod 的 metadatametadata: # 該 pod 的 label, 可被選擇器選擇, 為自定義 key/value pair labels: test: liveness # 該 pod 的 name name: liveness-http# 該 pod 運行規格spec: # 定義容器 containers: # 容器名稱 - name: liveness # 鏡像名稱 image: k8s.gcr.io/liveness # 容器啟動後執行的指令 args: - /server # 存活探針 livenessProbe: # 探測類型為 httpGet, 就像是透過呼叫一支 API 並取得回應來判斷是否運作正常 httpGet: # API 位址 path: /healthz # API port 號 port: 8080 # 定義 header httpHeaders: # header name - name: Custom-Header # header value value: Awesome # 首次啟動時, delay 3 秒以待資源就緒 initialDelaySeconds: 3 # 每 3 秒探測一次 periodSeconds: 3 Kubernetes liveness probe 中, 若使用 httpGet, 怎樣的回應算是成功？status code 200 &gt;= 成功 &lt; 400 試著解釋以下的 Kubernetes yaml file 中的每一條 directive yaml file: apiVersion: v1kind: Podmetadata: name: goproxy labels: app: goproxyspec: containers: - name: goproxy image: k8s.gcr.io/goproxy:0.1 ports: - containerPort: 8080 readinessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 periodSeconds: 10 livenessProbe: tcpSocket: port: 8080 initialDelaySeconds: 15 periodSeconds: 20 Answer:# API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 pod 的 name name: goproxy # 該 pod 的 label, 可被 selector 選擇, 為自定義的 key/value pair labels: app: goproxy# 該 pod 的運行規格spec: # 定義容器 containers: # 容器名稱 - name: goproxy # 鏡像名稱 image: k8s.gcr.io/goproxy:0.1 # 定義 port ports: # 容器 port 為 8080 - containerPort: 8080 # 定義 readiness 探針 readinessProbe: # 探測類型為 tcpSocket tcpSocket: # 探測的 port port: 8080 # 首次啟動容器時, 延遲 5 秒 initialDelaySeconds: 5 # 每 10 秒探測一次 periodSeconds: 10 # 定義存活探針 livenessProbe: # 探測方式為 tcpSocket tcpSocket: # 探測的 port 為 8080 port: 8080 # 首次啟動容器時, 延遲 15 秒 initialDelaySeconds: 15 # 每 20 秒探測一次 periodSeconds: 20 請解釋以下的 Kubernetes yaml file 中的 directives yaml file:ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port Answer:# 定義 portports: # port name- name: liveness-port # port 號 containerPort: 8080 # 宿主機 port 號 hostPort: 8080# 定義存活探針livenessProbe: # 定義類型為 httpGet httpGet: # API 位址 path: /healthz # 使用定義好的 port port: liveness-port Kubernetes 中, 如果我有一個應用可能啟動需要長一點啟動時間, 舉例來說, 可能容器啟動之後, 應用還需要一段時間才會正常運作, 那我可以使用什麼 probe 來讓 liveness probe 可以在應用啟動完成後馬上開始探測？使用 startup probe 以下的 Kubernetes yaml file 中, 如果超過了 300 秒都沒有成功, Kubernetes 會如何處置這個 pod? yaml file:ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 Answer:該容器會被砍掉 以下的 Kubernetes yaml file 中, 如果 startupProbe 成功了, Kubernetes 會如何處置這個 pod? yaml file:ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 Answer:livenessProbe 會開始運作, 接手探測工作 請解釋以下 Kubernetes yaml file 中的每一條 directive yaml file:ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 Answer:# 定義 portports: # port name- name: liveness-port # 容器 port containerPort: 8080 # 宿主機 port hostPort: 8080# 定義存活探針livenessProbe: # 定義 httpGet 方式 httpGet: # 呼叫的 path path: /healthz # 呼叫的 port, 使用上面定義的 port port: liveness-port # 失敗一次就算失敗 failureThreshold: 1 # 每 10 秒探測一次 periodSeconds: 10# 定義 startup 探針startupProbe: # 定義 httpGet httpGet: # 探測 path path: /healthz # 探測 port port: liveness-port # 失敗 30 次才算失敗 failureThreshold: 30 # 每 10 秒探測一次 periodSeconds: 10 Kubernetes 中, 當 readiness probe 失敗, 會怎麼樣？將不會從 Kubernetes Service 收到 traffic Kubernetes 中, 當我使用 httpGet 探測方式時, 該探測行為在 pod 還是在 node?pod Kubernetes 中, 當我使用 tcpSocket 探測方式時, 該探測行為在 pod 還是在 node?node Kubernetes 中, 當 startup probe 失敗, 會怎麼樣？該 pod 會被 killed","link":"/zh-tw/config-liveness-readiness-startup-probes/"},{"title":"Cloud Storage 初探 - 主控台","text":"概述Google Cloud Storage 提供世界級的儲存服務並且你可以在任何時間取回任何大小的資料。 Google Cloud Storage 提供了很多的使用情況, 包含網站內容, 歸檔類型或是災後復原類型的資料儲存, 或是提供使用者大檔案物件直接下載的方式。 在這個手把手教程中, 你將會學習到如何使用 Google Cloud Platform 主控台來建立一個儲存區, 然後上傳物件, 建立資料夾以及子資料夾, 以及讓這些物件可被公開存取。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 建立一個儲存區在控制面板，到 Navigation menu &gt; Storage &gt; Browser, 點擊建立儲存區 名字： 為你的儲存區建立一個特別的名字命名規則： 不要有機敏資訊，因為儲存區的名字是公開可被大家看到的 儲存區的名字一定只可以有 小寫字母 ,數字, -, _, ., 若是名字含有 ., 需要驗證 儲存區的名字必須由數字或字母來開始以及結束 儲存區的名字必須含有 3 到 63 的字元，含有 . 的名字最多 222 個字元，但是每個被 . 分開的字元，最多不可超過 63 字元。 儲存區的名字不可以帶點十進制的方式表示，像是 IP 位址 (例如, 192.168.5.4) 儲存區的名字不可由 goog 開頭 儲存區的名字不可含有 google 或近似字串 還有，為了符合 DNS 命名規則以及之後的相容性，不可使用 _, 或是兩個 . 相連，或與 dash 相連，例如 .., 或 -., 或 .-, 這些都不符合 DNS 命名規則 儲存種類： 多區域地區: United States 如果你已經設定好你的儲存區，按下建立 就這麼簡單，你已經建立了一個 Cloud Storage 儲存區 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 在整個 Cloud Storage 的命名空間裡，每個儲存區都要有一個獨一無二的名字 true false Cloud Storage 提供以下哪四種儲存區類別？ Nearline Storage Local storage Multi-Regional Storage Cross region storage Regional Storage Coldline Storage 上傳一個物件到儲存區在這個章節中，你將在儲存區中增加一個物件，在這個 lab 中，這個物件是一個圖片 取得圖片。 點擊這個 Ada Lovelace 的連結, 然後儲存圖片到你的本地電腦 儲存區的細節畫面應還會開著，將圖片拖曳到細節畫面處， Drop files here 你應該可以看到圖片被列在儲存區清單中 從儲存區中刪除圖片，勾選檔名旁的空格然後點擊 Delete, 然後再按一次 Delete 確認刪除 在上傳一次檔案，這次點擊 Upload files 從本地電腦中找到圖片，然後點擊 Open 你應該會看到圖片被列在儲存區清單中 重新命名檔案。點擊下拉式清單（三個平行的點） 在圖片列的最右邊，然後點擊 rename 你可能需要變寬你的瀏覽器視窗來顯示下拉式清單 上傳檔案，更名為 ada.jpg, 然後點擊 RENAME 你應會看到 ada.jpg 在你的儲存區中 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 物件的名稱只需要在一個儲存區中獨一無二 true false 公開分享物件點擊下拉式清單來取得這個物件的公開存取連結 從下拉式選單中，選擇 Edit permission 在出現的對話格中，點擊 + Add item 按鈕 完成以下的操作來開放權限給所有人 為此實體選擇 User 名字輸入 AllUsers 存取部分選擇 Reader 然後點擊 Save 一旦公開分享，一個連結的圖案會出現在公開存取欄位-點擊連結在新的視窗打開檔案 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 建立資料夾在這個章節中，你將建立資料夾 在接近頁面頂端，點擊 Create Folder 連結 取名為 folder1, 然後點擊 Create 你應會看到資料夾出現在儲存區中，而且以不同的圖示來與物件作區分 建立子資料夾現在你將在 folder1 當中建立一個資料夾，並且上傳一個檔案 點擊 folder1, 在頁面頂端處點擊 create Folder 命名為 folder2, 並點擊 Create 點擊剛剛建立的 folder2 將圖片 Ada Lovelace 從本地電腦拖過去 Drop files here 上傳後，你將看到這個圖片列在 subfolder 中 重新命名檔案為 ada.jpg 點擊下拉式清單來取得這個物件的公開存取連結 從下拉式選單中，選擇 Edit permission 在出現的對話格中，點擊 + Add item 按鈕 完成以下的操作來開放權限給所有人 為此實體選擇 User 名字輸入 AllUsers 存取部分選擇 Reader 然後點擊 Save 一旦公開分享，一個連結的圖案會出現在公開存取欄位-點擊連結在新的視窗打開檔案 刪除資料夾在這個章節中，你將從儲存區中移除 folder1 還有他的內容 移動回 Buckets/[你的儲存區]。 你將看到 folder1 列在儲存區內容清單 勾選檔名旁的空格然後點擊 Delete, 然後再按一次 Delete 確認刪除 folder1 還有他的內容將永遠從你的儲存區中刪除 Congratulations!你已經完成本課程。","link":"/zh-tw/cloudStorageQwikStartConsole/"},{"title":"在 GCP 上建立一個 persistent disk","text":"概述Google Compute Engine 讓你在 Google 的基礎設施上建立以及運行虛擬機。 你可以在建立運行著不同作業系統的虛擬機，包含不同偏好的 Linux (Debian, Ubuntu, Suse, Red Hat, CoreOS) 以及 Windows Server Google Compute Engine 提供 persistent disks, 這是虛擬機上的主要儲存空間。 就像是實體的硬碟一樣， persistent disks 可獨立存在於你的虛擬機 - 如果一台虛擬機被刪除了，附加的 persistent disk 將可以持續將資料留住，並且可以附加到其他的虛擬機上。 Persistent disks 有兩種： 一般persistent diskSSD persistent disk 更多兩者差異的資訊，可以參考 Storage Options 。 兩種類型的 persistent type 有其不同的容量限制，更多資訊請參考 Persistent Disk 官方文件 本篇將會做什麼？ 建立一個新的 VM instance ，然後在其新增 persistent disk 掛載並格式化 persistent disk 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記原文請參閱Refer to official link 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 VM instance 建立一個名為 ‘gcelab’ 的新虛擬機 instance gcloud compute instances create gcelab --zone us-central1-c 新建的VM instance將有內建10GB的初始化disk 建立新的 persistent disk 在 Cloud Shell 中輸入以下指令，注意 zone 參數需與 VM instance 一致gcloud compute disks create mydisk --size=200GB --zone us-centrall-c 在運轉中的 VM instance 上新增剛建立的 persistent diskgcloud compute instances attach-disk gcelab --disk mydisk --zone us-central1-c 在 VM instance 上找到剛剛新增的 persistent disk SSH 到 virtual machine gcloud compute ssh gcelab --zone us-central1-c 輸入y繼續 如果需要設定密碼，可以輸入密碼 在 /dev/disk/by-id/ 下找到 disk 裝置 ls -l /dev/disk/by-id/ 找到預設裝置名稱如下: scsi-0Google_PersistentDisk_persistent-disk-1. 如果你想要一個不一樣的裝置名稱，當你在新增 disk 時，你可以加入裝置名稱參數 gcloud compute instances attach-disk gcelab --disk mydisk --device-name yourDeviceName --zone us-central1-c 格式化，並且掛載 persistent disk 在找到裝置後，我們可以將 disk 分區，格式化，並且掛載 建立一個掛載點sudo mkdir /mnt/mydisk 使用 mkfs 工具，格式化 disk 為 ext4 格式，這個指令將會刪除指定 disk 下的所有資料sudo mkfs.ext4 -F -E lazy_itable_init=0,lazy_journal_init=0,discard /dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 利用 mount 工具，掛載 disksudo mount -o discard,defaults /dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 /mnt/mydisk 設定自動掛載 預設值中，在 VM instance 重新啟動之後， persistent disk 並不會自動掛載，我們需要在/etc/fstab檔案中增加一些輸入sudo vim /etc/fstab 在開頭是 UUID 那段程式碼之後，加入：/dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 /mnt/mydisk ext4 defaults 1 1 此時，你的 /etc/fstab 應該看起來要像這樣:UUID=e084c728-36b5-4806-bb9f-1dfb6a34b396 / ext4 defaults 1 1/dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 /mnt/mydisk ext4 defaults 1 1 按 :wq 小習題： Can you prevent the destruction of an attached persistent disk when the instance is deleted? No, attached persistent disks are always associated with the lifetime of the instance. Yes, deselect the option Delete boot disk when instance is deleted when creating an instance Yes, use the -keep-disks option with the gcloud compute instances delete command For migrating data from a persistent disk to another region, reorder the following steps in which they should be performed: Attach disk Create disk Create snapshot Create instance Unmount file system(s) (4, 1, 2, 3, 5) (2, 3, 1, 4, 5) (1, 3, 2, 4, 5) (5, 3, 2, 4, 1) 非必要指令 顯示活躍中帳戶gcloud auth list 顯示project idgcloud config list project","link":"/zh-tw/createAPersistentDisk/"},{"title":"使用 Spinnaker 在 Kubernetes Engine 中實作持續交付管道","text":"# 概述在本教程中, 你將會學到如何使用 Google Kubernetes Engine, Google Cloud Source Repositories, Google Cloud Container Builder, 以及 Spinnaker 來建立持續交付管道。 在你建立範例應用之後, 你將設定這些服務, 使他們可以自動建立, 測試, 以及部署。當你修改了應用的程式碼, 這個變更會觸發持續交付管道, 使用新的版本來重新建立, 測試, 以及部署。 # 目標 藉由啟動 Google Cloud Shell 來設定你的環境, 在裡面建立 Kubernetes Engine 叢集, 設定你的身份以及使用者管理方案 下載範例應用, 建立一個 Git 倉庫, 然後上傳到 Google Cloud Source Repository 使用 Helm 將 Spinnaker 部署到 Kubernetes Engine 建立你的 Docker 鏡像 建立觸發者, 當你的應用變更時, 會建立 Docker 鏡像 設定 Spinnaker 管道來可靠的, 持續地將應用部署到 Kubernetes Engine 部署一個變更過的程式碼, 觸發管道, 然後檢視滾動更新到正式環境的過程 # 管道結構你需要一個能夠可靠的建立, 測試, 以及更新軟體的自動化的程序來持續地將你的應用更新到使用者手上。 程式碼變更需要全自動化的經由一個管道, 這個管道包含成品建立, 單元測試, 功能測試, 以及正式環境部署。在某些情況下, 你會想要一個程式碼更新只作用到某部分的用戶, 這樣一來, 這個更新就可以在應用到所有用戶之前實際的先跑過了一次。 如果其中一個 canary 發佈確定不太適合, 你的自動化程序必須要能夠很快的將它回復到更新前的版本。 使用 Kubernetes Engine 以及 Spinnaker, 你可以建立一個可信賴的持續交付流程, 這個流程可以幫你確保你的軟體在開發以及核對之後, 可正確的被交付。 儘管快速部署是我們的最終目標, 但在更新的版次成為正式環境的選項之一之前, 我們必須確保它通過了所有的自動化驗證。 當更新通過了所有的自動化驗證, 你也可以再進行手動驗證, 以及更進一步的實施發布前的測試。 在你的團隊確定這個應用已經可以上正式環境了, 團隊中的其中一個成員可以手動核准這次的正式環境部署。 # 應用交付管道在本教程中, 你將建立一個如下圖般的持續交付管道 # 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 # 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 **注意：** 按下左上方位於 `Google Cloud Platform` 隔壁的 `Navigation menu`, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 # 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview # 設定環境設定本教程中需要的基礎設施以及身份。 首先, 你將建立 Kubernetes Engine 叢集來部署 Spinnaker 以及範例應用 設定預設 zone gcloud config set compute/zone us-central1-f 使用 Spinnaker 教學範例, 建立一個 Kubernetes Engine gcloud container clusters create spinnaker-tutorial \\ --machine-type=n1-standard-2 這個部署將會耗費 5 到 10 分鐘。 你可能會看到一個預設範圍的警告, 你可以忽略他們, 因為對本教程沒有影響。 等待部署完成。 完成之後, 你會看到一些細節資訊, 像是名稱, 地區, 版本, ip-address, 機器類型, node 版本, node 數量, 以及叢集的狀態顯示該叢集已經處於運行中 # 設定身份以及存取管理建立一個 Cloud Identity Access Management (Cloud IAM) service account 來賦予 Spinnaker 權限, 允許它可以將資料存到 Cloud Storage 。 Spinnaker 將管道資料儲存到 Cloud Storage 以確保可靠度以及復原能力。 如果你的 Spinnaker 部署無預期的失敗了, 你可以利用存取相同管道內的資料, 在幾分鐘內建立一個相同的部署。 經由以下步驟來上傳啟動腳本到 Cloud Storage 建立 service account: gcloud iam service-accounts create spinnaker-account \\--display-name spinnaker-account 將 service account 的 email 以及目前的專案 ID 存到環境變數, 之後的指令會用到 export SA_EMAIL=$(gcloud iam service-accounts list \\ --filter=&quot;displayName:spinnaker-account&quot; \\ --format=&#x27;value(email)&#x27;) export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;) 賦予 service account storage.admin 的角色 gcloud projects add-iam-policy-binding $PROJECT \\--role roles/storage.admin \\--member serviceAccount:$SA_EMAIL 下載 service account 的 key 。 在之後的步驟, 你將會安裝 Spinnaker 以及上傳這個 key 到 Kubernetes Engine: gcloud iam service-accounts keys create spinnaker-sa.json \\--iam-account $SA_EMAIL (輸出) created key [12f224e036437704b91a571792462ca6fc4cd438] of type [json] as [spinnaker-sa.json] for [spinnaker-account@qwiklabs-gcp-gcpd-f5e16da10e5d.iam.gserviceaccount.com] # 設定 Cloud Pub/Sub 來觸發 Spinnaker 管道 建立 Cloud Pub/Sub 主題來接收 Container Registry 的通知 gcloud pubsub topics create projects/$PROJECT/topics/gcr 建立一個訂閱, 所以 Spinnaker 可以讀取並接收到鏡像已被推送的通知 gcloud pubsub subscriptions create gcr-triggers \\--topic projects/$&#123;PROJECT&#125;/topics/gcr 給予 Spinnaker 的 service account 權限, 所以它可以讀取 gcr-triggers 的訂閱 export SA_EMAIL=$(gcloud iam service-accounts list \\--filter=&quot;displayName:spinnaker-account&quot; \\--format=&#x27;value(email)&#x27;) gcloud beta pubsub subscriptions add-iam-policy-binding gcr-triggers \\ --role roles/pubsub.subscriber --member serviceAccount:$SA_EMAIL # 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成環境設定，你將獲得一個評價分數。 # 使用 Helm 部署 Spinnaker在本節中, 你會使用 Helm 從 Charts 倉庫來部署 Spinnaker 。 Helm 是一個套件管理器, 你可以用它來設定以及部署 Kubernetes applications # 安裝 Helm 下載以及安裝 helm 二進制檔 wget https://storage.googleapis.com/kubernetes-helm/helm-v2.10.0-linux-amd64.tar.gz 解壓縮到本地系統 tar zxfv helm-v2.10.0-linux-amd64.tar.gz cp linux-amd64/helm . 給予 Tiller 在叢集中 cluster-admin role 的權限, Tiller 是 Helm 的伺服器端 kubectl create clusterrolebinding user-admin-binding \\--clusterrole=cluster-admin --user=$(gcloud config get-value account) kubectl create serviceaccount tiller \\--namespace kube-system kubectl create clusterrolebinding tiller-admin-binding \\--clusterrole=cluster-admin --serviceaccount=kube-system:tiller 賦予 Spinnaker cluster-admin 的權限, 所以 Spinnaker 可以部署資源到所有的命名空間上 kubectl create clusterrolebinding --clusterrole=cluster-admin \\--serviceaccount=default:default spinnaker-admin 安裝 Helm 以及 Tiller 到叢集, Tiller 是 Helm 的 Server 端 ./helm init --service-account=tiller ./helm repo update 輸入以下指令, 確定 Helm 已經正確安裝了。 如果 Helm 安裝正確, client 端及 server 端都會輸出 v2.10.0./helm version (輸出) Client: &amp;version.Version&#123;SemVer:&quot;v2.10.0&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;&#125;Server: &amp;version.Version&#123;SemVer:&quot;v2.10.0&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;&#125; # 設定 Spinnaker 還是在 Cloud Shell, 建立一個儲存區讓 Spinnaker 可以儲存管道設定資料 export PROJECT=$(gcloud info \\--format=&#x27;value(config.project)&#x27;) export BUCKET=$PROJECT-spinnaker-config gsutil mb -c regional -l us-central1 gs://$BUCKET 輸入以下指令來建立 spinnaker-config.yaml 檔, 該檔告訴 Helm 該如何安裝 Spinnaker export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFgcs: enabled: true bucket: $BUCKET project: $PROJECT jsonKey: &#x27;$SA_JSON&#x27;dockerRegistries:- name: gcr address: https://gcr.io username: _json_key password: &#x27;$SA_JSON&#x27; email: 1234@5678.com# Disable minio as the default storage backendminio: enabled: false# Configure Spinnaker to enable GCP serviceshalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_gcs_artifacts.sh: |- \\$HAL_COMMAND config artifact gcs account add gcs-$PROJECT --json-path /opt/gcs/key.json \\$HAL_COMMAND config artifact gcs enable enable_pubsub_triggers.sh: |- \\$HAL_COMMAND config pubsub google enable \\$HAL_COMMAND config pubsub google subscription add gcr-triggers \\ --subscription-name gcr-triggers \\ --json-path /opt/gcs/key.json \\ --project $PROJECT \\ --message-format GCREOF # 部署 Spinnaker chart 使用 Helm 命令列介面, 用設定檔來部署 chart ./helm install -n cd stable/spinnaker -f spinnaker-config.yaml \\--timeout 600 --version 1.1.6 --wait 這個指令大概會需要 5~6 分鐘 完成 在指令完成後, 輸入以下指令來設定從 Cloud Shell 到 Spinnaker 的 port 轉發規則 export DECK_POD=$(kubectl get pods --namespace default -l &quot;cluster=spin-deck&quot; \\-o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;) kubectl port-forward --namespace default $DECK_POD 8080:9000 &gt;&gt; /dev/null &amp; 這個指令會花好幾分鐘完成。 再繼續之前, 確認他已經完成了。 點擊 Cloud shell 視窗上方的 Web Preview 圖案, 並選擇 Preview on port 8080 來打開 Spinnaker 使用者介面 會先看到歡迎畫面, 然後是 Spinnaker 使用者介面 保持這個視窗開啟, 這是我們存取 Spinnaker UI 的地方 # 測試進度點擊 Check my progress 來確認目前的進度。如果你已經正確的使用 Kubernetes Helm 部署 Spinnaker chart，你將獲得一個評價分數。 # 建立 Docker 鏡像在本節中, 你將設定 Cloud Build 來偵測程式碼變更, 建立 Docker 鏡像, 然後推送到 Container Registry # 建立源碼倉庫 在 Cloud Shell, 下載範例應用源碼 wget https://gke-spinnaker.storage.googleapis.com/sample-app-v2.tgz 解壓縮 tar xzfv sample-app-v2.tgz 進到源碼目錄 cd sample-app 設定在 Git 當中的 username 以及 email, 將 [USERNAME] 替換成你自己的 git config --global user.email &quot;$(gcloud config get-value core/account)&quot; git config --global user.name &quot;[USERNAME]&quot; 做第一個 commit git init git add . git commit -m &quot;Initial commit&quot; 建立源碼倉庫 gcloud source repos create sample-app 如果看到你可能會被收費的訊息, 請無視 git config credential.helper gcloud.sh 將剛剛建立的源碼倉庫設為遠端 export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;) git remote add origin https://source.developers.google.com/p/$PROJECT/r/sample-app 推送程式碼到新的倉庫的 master 分支 git push origin master 在主控台點擊 Navigation Menu &gt; Source Repositories, 確認你可以看到你的源碼 點擊 sample-app # 設定建立觸發者設定 Container Builder, 所以每次你推送 Git tags 到你的源碼倉庫時, 會自動建立以及推送 Docker 鏡像。 Container Builder 會自動切換到你的程式碼, 依照你倉庫中的 Dockerfile 來建立 Docker 鏡像, 然後推送鏡像到 Google Cloud Container Registry 在 Cloud Platform 主控台, 點擊 Navigation menu &gt; Cloud Build &gt; Triggers 點擊 Create trigger 選擇 Cloud Source Repository, 然後點擊 Continue 選擇你新建立的 sample-app 倉庫, 然後點擊 Continue 設定以下的觸發設定 Name: sample-app-tags Trigger type: Tag Tag (regex): v.* Build configuration: Cloud Build configuration file (yaml or json) cloudbuild.yaml location: /cloudbuild.yaml 點擊 Create trigger 從現在開始, 只要你推送一個帶有前綴為 “v” 的 Git tag 到你的源碼倉庫, Container Builder 會自動的建立並推送應用的 Docker 鏡像到 Container Registry # 準備將使用在 Spinnaker 的 Kubernetes Manifests (Kubernetes 的部署文件)要部署到你的集群, Spinnaker 需要存取你的 Kubernetes manifests 。 本節中會建立一個 Cloud Storage 儲存區, 這個儲存區會在 Cloud Build 的 CI 過程中載入 manifest 。 當你的 manifest 被存在 Cloud Storage 之後, Spinnaker 可以在整個管道執行過程中, 下載以及應用它 建立儲存區 export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)gsutil mb -l us-central1 gs://$PROJECT-kubernetes-manifests 啟用儲存區的 versioning (物件版本管理), 所以我們將有整個 manifests 的歷史 gsutil versioning set on gs://$PROJECT-kubernetes-manifests 在 Kubernetes deployment manifests 中設定正確的 project ID sed -i s/PROJECT/$PROJECT/g k8s/deployments/* 提交 commit 到倉庫 git commit -a -m &quot;Set project ID&quot; # 建立鏡像按照以下步驟, 推送你的第一個鏡像 在 Cloud Shell, sample-app 資料夾, 建立一個 Git tag: git tag v1.0.0 推送 tag git push --tags (輸出) To https://source.developers.google.com/p/qwiklabs-gcp-ddf2925f84de0b16/r/sample-app* [new tag] v1.0.0 -&gt; v1.0.0 到 GCP 主控台。 在 Cloud Build, 點擊左方面板的 History, 確認 build 是否已經被觸發。 若否, 確認在之前的章節中, trigger 有正確的被設定 先在此頁面等待, 待 build 完成, 再到下一個章節 # 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Docker 鏡像，你將獲得一個評價分數。 # 設定部署管道現在你的鏡像已經自動地被建立, 你需要將他們部署到 Kubernetes 叢集部署到規模縮減的環境來實施整合測試。 整合測試通過後, 手動核准這次的變更來將代碼部署到正式生產服務。 # 安裝 spin CLI 來管理 Spinnakerspin 是用來管理 Spinnaker 的應用以及管道的命令列工具 下載 1.6 版本的 spin curl -LO https://storage.googleapis.com/spinnaker-artifacts/spin/1.6.0/linux/amd64/spin 使 spin 可執行 chmod +x spin # 建立部署管道 使用 spin, 在 Spinnaker 建立一個叫做 sample 的應用。 設定使用者 email./spin application save --application-name sample \\ --owner-email &quot;$(gcloud config get-value core/account)&quot; \\ --cloud-providers kubernetes \\ --gate-endpoint http://localhost:8080/gate 請忽略 Cloud not read configuration file... 輸出訊息 接下來, 建立一個持續交付管道。 在本教程中, 管道被設定偵測, 當一個前綴為 “v” 的 tag 被推送到我們的 Container Registry 在 sample-app 程式碼資料夾, 執行以下命令來更新範例管道到 Spinnaker instanceexport PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)sed s/PROJECT/$PROJECT/g spinnaker/pipeline-deploy.json &gt; pipeline.json./spin pipeline save --gate-endpoint http://localhost:8080/gate -f pipeline.json 請忽略 Cloud not read configuration file... 輸出訊息 # 手動觸發以及檢視你的管道執行狀況當有鏡像被推送且有符合規則的新標籤時, 我們剛剛建立的設定會觸發 Spinnaker 管道。 在之前的步驟中, 我們推送一個標籤到 Cloud Source Repositories, 然後觸發 Cloud Build 來建立以及推送我們的鏡像到 Container Registry 。 要核准這個管道, 手動觸發它 在 Spinnaker UI 介面, 在螢幕最上方點擊 Application 來檢視被管理應用的清單。 sample 是我們的應用。 如果你沒看到 sample, 嘗試重刷新 Spinnaker Application 頁面 點擊 sample 來檢視你的應用部署 在上方點擊 Pipelines 來檢視你的應用管道狀態 點擊 Start Manual Execution 來首次觸發管道 點擊 Run 點擊 Details 來檢視管道進度的更多資訊 進度條顯示部署管道的狀態以及階段 藍色部分為目前正在運行中, 綠色為已經成功完成, 紅色為已經失敗的 點擊一個階段來看細節資訊在 3 ~ 5 分鐘 後, 整合測試階段完成, 且管道需要手動核准來持續部署 在游標停在黃色的”人形”圖案上, 並且點擊 Continue 你的推送持續的到正式環境的前端以及後端部署。 它在幾分鐘後完成。 在 Spinnaker UI 的上方選擇 **Infrastructure &gt; Load Balancers 來檢視 app 下捲 load balancers 清單並且在 service sample-frontend-production 下點擊 Default 在右方 details 面板下捲並且在 Ingress IP 點擊 clipboard 按鈕來複製你的 app IP 位址。 Spinnaker UI 頁面的 ingress IP 預設為 HTTPS, 儘管應用是被設定使用 HTTP 將位址貼到一個新的視窗來檢視應用的正式版本 現在你已經手動的觸發管道建立, 測試, 以及部署你的應用 # 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立服務平衡負載，你將獲得一個評價分數。 # 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功部署鏡像到正式環境，你將獲得一個評價分數。 # 從程式碼變更來觸發你的管道現在讓我們改變程式碼, 推送一個 Git 標籤, 以及檢視管道執行的回應來從端對端的測試管道。 藉由推送前綴為 “v” 的 Git 標籤來觸發 Container Builder 建立一個新的 Docker 鏡像, 然後將它推送到 Container Registry 。 Spinnaker 將偵測是否有新的有著 Git 標籤為 “v” 的鏡像被推送, 然後觸發管道來部署鏡像到 canaries, 運行 tests, 然後推送一樣的鏡像到所有 deployment 中的所有 pods 在 sample-app 資料夾, 將 app 的顏色從 orange 改成 blue sed -i &#x27;s/orange/blue/g&#x27; cmd/gke-info/common-service.go 將變更的 commit 貼上標籤並且推送到程式碼倉庫 git commit -a -m &quot;Change color to blue&quot;git tag v1.0.1git push --tags 在主控台, Cloud Build &gt; History, 等待幾分鐘待新的 build 完成。 到下一個步驟之前, 你可能需要重整你的頁面, 等待新的 build 完成 回到 Spinnaker UI 並點擊 Pipelines 來檢視管道正開始部署。 自動被觸發的管道將需要幾分鐘才會顯示在頁面上, 你可能需要重刷新頁面。 # 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功從程式碼變更觸發管道，你將獲得一個評價分數。 # 觀察 canary 部署 當部署停下, 等待推送到正式環境時, 我們回到網頁顯示運行中的應用並且重整頁面。 後端中有 四個正運行之前版本的應用, 而只有一個後端運行 canary 。 你可以看到那個藍色新版本的應用大概每重整五次會出現一次 在測試完成後, 回到 Spinnaker 頁面, 點擊 Continue 來核准部署 當管道完成後, 你的 app 看起來會像以下的截圖一樣。 注意到顏色都已經變成藍色因為你的程式碼變了, 而且 Version 欄位目前顯示 production 你已經成功地將你的 app 推送到整個正式環境 你也可以藉由取消當前版本來取消變更。 取消當前版本並且新增一個標籤, 然後經由同一個管道部署 git revert v1.0.1git tag v1.0.2git push --tags 當 build 以及管道完成, 點擊 Infrastructure &gt; Load Balancers 來核准這次的回滾, 然後點擊 service sample-frontend-canary Default, 然後複製 Ingress IP 位址到新的視窗 現在你的應用已經回到橘色, 且你可以看到 canary 的版本號 # 恭喜你已經完成本教程 # Q&amp;A以下的 gcloud command 的意思是？ Example:gcloud iam service-accounts create spinnaker-account \\--display-name spinnaker-account Answer:建立一個名為 spinnaker-account 的 service account--display-name: 好記的名稱為 spinnaker-account 以下 gcloud 指令的意思?export SA_EMAIL=$(gcloud iam service-account list \\--filter=&quot;displayName:spinnaker-account&quot; \\--format=&#x27;value(email)&#x27;) - `export`: 將 SA_EMAIL 的值變成環境變數 - `--filter`: 取得 displayName 為 spinnaker-account 的那一行 - `--format`: 取得上面那行 email 的值 以下 gcloud 指令的意思?export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;) - `--format`: 取得 info 輸出中的 config property 下的 project - 可使用 --format=json 來檢視, 會比較清楚 以下 gcloud 指令的意思?gcloud projects add-iam-policy-binding $PROJECT \\--role roles/storage.admin \\--member serviceAccount:$SA_EMAIL - 在指定專案中, 新增 add-iam-policy-binding - policy 是 binding 的集合 - binding 綁定了一個或多個 member 到一個單獨的 role - `--role`: 賦予 roles/storage.admin 的角色 - `--member`: 透過 service account 綁定這個 member 到這個專案 以下的 gcloud command 的意思是？ Example:gcloud iam service-accounts keys create spinnaker-sa.json \\--iam-account $SA_EMAIL Answer:建立一把 service account 的 private keyspinnaker-sa.json 為輸出的 key name--iam-account 為指定 service account 的 email 以下 gcloud 指令的意思?gcloud pubsub topics create projects/$PROJECT/topics/gcr - 建立一個 topic, 名為 project/$PROJECT/topics/gcr 以下 gcloud 指令的意思?gcloud pubsub subscriptions create gcr-triggers \\--topic projects/$&#123;PROJECT&#125;/topics/gcr - 建立一個 subscriptions, 名為 gcr-triggers - 接收的 topic 為 project/$&#123;PROJECT&#125;/topics/gcr 以下 gcloud 指令的意思?gcloud beta pubsub subscriptions add-iam-policy-binding gcr-triggers \\ --role roles/pubsub.subscriber --member serviceAccount:$SA_EMAIL - 在 gcr-triggers 這個 subscriptions 建立一個政策繫結 - role 為 pubsub 的 subscriber - member 為 spinnaker 的 service account 以下 kubectl 指令的意思?kubectl create clusterrolebinding user-admin-binding \\--clusterrole=cluster-admin --user=$(gcloud config get-value account) - 建立一個叢集角色綁定, 名為 user-admin-binding - 叢集角色為 cluster-admin, 為系統內建角色 - user 為預設帳號的擁有者 tiller 跟 helm 的關係？如下圖, Helm 為 client 端, Tiller 為 server 端 以下 kubectl 指令的意思?kubectl create clusterrolebinding --clusterrole=cluster-admin \\--serviceaccount=default:default spinnaker-admin - 建立一個叢集角色綁定 - 綁定的角色的叢集預設的 cluster-admin - serviceaccount 為 default 命名空間下的 default service account - 該綁定的名稱為, spinnaker-admin 以下 helm 指令的意思?./helm init --service-account=tiller - 安裝 tiller 到 server 端 - 使用 service-account 名為 tiller 以下 gsutil 指令的意思?gsutil mb -c regional -l us-central1 gs://$BUCKET - `gsutil`: google storage utility - `mb`: make a bucket - `-c`: class, 儲存空間等級 - `-l`: location, 位置 - `gs://$BUCKET`: 儲存區的名稱 以下的 spinnaker 的 yaml 檔中, gcs 的區塊部分代表什麼意思？設定預設儲存後端為 gcs, 可參考官方文件 export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFgcs: enabled: true bucket: $BUCKET project: $PROJECT jsonKey: &#x27;$SA_JSON&#x27; 以下的 spinnaker 的 yaml 檔中, dockerRegistries 的區塊部分代表什麼意思？設定 docker registry 為 Google Container Registry, 可參考官方文件 export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFdockerRegistries:- name: gcr address: https://gcr.io username: _json_key password: &#x27;$SA_JSON&#x27; email: 1234@5678.com Spinnaker 的預設儲存服務為？minio, 可參考文件 Spinnaker 的 artifact 是什麼？代表一個參考外部資源的物件, 可參考文件 以下的 Spinnaker 指令是什麼意思？- 啟用 GCP pubsub 服務 - 增加一個名為 gcr-trigger 的 subscription 到 pubsub - subscription 的 name 為 gcr-trigger - 可參考[文件](https://www.spinnaker.io/reference/halyard/commands/#hal-config-pubsub-google-subscription-add) export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFhalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_pubsub_triggers.sh: |- \\$HAL_COMMAND config pubsub google enable \\$HAL_COMMAND config pubsub google subscription add gcr-triggers \\ --subscription-name gcr-triggers \\ --json-path /opt/gcs/key.json \\ --project $PROJECT \\ --message-format GCREOF 以下的 Spinnaker 指令是什麼意思？- 啟用 GCS 服務 - 增加一個 artifact account 到 GCS provider - 可參考[文件](https://www.spinnaker.io/reference/halyard/commands/#hal-config-artifact-gcs-account-add) export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFhalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_gcs_artifacts.sh: |- \\$HAL_COMMAND config artifact gcs account add gcs-$PROJECT --json-path /opt/gcs/key.json \\$HAL_COMMAND config artifact gcs enableEOF 以下的指令中, |- 代表什麼意思？- `|` 為 Block Style Indicator, literal style, 如果 string 當中有空行, 會被保留下來 - `-` 為 Block Chomping Indicator, strip style, 在 string 結尾不保留任何空行 - 可參考[文件](https://yaml.org/spec/1.2/spec.html#id2794534) - 可參考 [Stackoverflow](https://stackoverflow.com/questions/3790454/how-do-i-break-a-string-over-multiple-lines) - 可參考[範例](https://yaml-multiline.info/) export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFhalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_gcs_artifacts.sh: |- \\$HAL_COMMAND config artifact gcs account add gcs-$PROJECT --json-path /opt/gcs/key.json \\$HAL_COMMAND config artifact gcs enable enable_pubsub_triggers.sh: |- \\$HAL_COMMAND config pubsub google enable \\$HAL_COMMAND config pubsub google subscription add gcr-triggers \\ --subscription-name gcr-triggers \\ --json-path /opt/gcs/key.json \\ --project $PROJECT \\ --message-format GCREOF 以下的 helm 指令是什麼意思？./helm install -n cd stable/spinnaker -f spinnaker-config.yaml \\--timeout 600 --version 1.1.6 --wait - **-n**: namespace 為 cd - **-f**: file 為 spannaker-config.yaml - **--timeout**: timeout 600 秒 - **--version**: 版本 1.1.6 - **--wait**: helm 會等待所有的 Pods 都 ready, PVCs 掛載, 部署有達到最小數量, 狀態為 ready 的 Pods, server 有 IP 位址, 可參考[文件](https://helm.sh/docs/intro/using_helm/#helpful-options-for-install-upgrade-rollback) 以下指令的意思是？export DECK_POD=$(kubectl get pods --namespace default -l &quot;cluster=spin-deck&quot; \\-o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;) - **export**: 將輸出設為環境變數 - **--namespace**: 取得該 namespace 中的資源 - **-l**: selector(label) - **-o**: 指定輸出格式 以下指令的意思是？kubectl port-forward --namespace default $DECK_POD 8080:9000 &gt;&gt; /dev/null &amp; - **port-forward**: 轉發 port 指令 - **--namespace**: 指定命名空間 - **$DECK_POD**: port 的名稱 - **8080:9000**: 指定外面的 8080 port 到 pod 的 9000 port, 再將輸出隱藏。 以下指令的用途是？git config credential.helper gcloud.sh 正常來說, 新增一個遠端 git 倉庫會需要設定 ssh 金鑰, 上面指令可以省略這個步驟, 讓我們可以使用我們在 gcloud 的 key 來做到這件事 以下指令的意思是？sed -i s/PROJECT/$PROJECT/g k8s/deployments/* 找到 PROJECT, 並把他替換成 $PROJECT, $PROJECT 為事先設好的變數, 尋找對象為 k8s/deployments/ 下面所有的檔案 Spinnaker 中, spin 是什麼？spinnaker 的 CLI 管理工具 以下的程式碼代表什麼意思?export PROJECT=$(gcloud info --format=&#x27;value(config.project)&#x27;)sed s/PROJECT/$PROJECT/g spinnaker/pipeline-deploy.json &gt; pipeline.json./spin pipeline save --gate-endpoint http://localhost:8080/gate -f pipeline.json - 利用 gcloud 指令取得 project, 在帶入變數 PROJECT 並將之變成環境變數 - sed 指令將 pipeline-deploy.json 檔案中的 PROJECT 替換為上一部取得的 $PROJECT 變數的值, 在複製一份到新檔案 pipeline.json - 使用 spin 建立一個 pipeline, 參數為上一部建立的檔案 pipeline.json, gate-endpoint 會通往遠端部署 spinnaker 的機器 以下的 cloud build 設定黨的意思是？steps:- name: &#x27;gcr.io/cloud-builders/docker&#x27; args: [&#x27;build&#x27;, &#x27;--tag=gcr.io/$PROJECT_ID/sample-app:$TAG_NAME&#x27;, &#x27;.&#x27;]- name: &#x27;gcr.io/cloud-builders/docker&#x27; args: [&#x27;run&#x27;, &#x27;gcr.io/$PROJECT_ID/sample-app:$TAG_NAME&#x27;, &#x27;go&#x27;, &#x27;test&#x27;]- name: &#x27;gcr.io/cloud-builders/gsutil&#x27; args: [&#x27;cp&#x27;, &#x27;-r&#x27;, &#x27;k8s/*&#x27;, &#x27;gs://$PROJECT_ID-kubernetes-manifests&#x27;]images: [&#x27;gcr.io/$PROJECT_ID/sample-app:$TAG_NAME&#x27;] - steps: 建構執行步驟 - name: 雲端建構工具, 可參考[文件](https://cloud.google.com/cloud-build/docs/build-config?hl=zh-tw#build_steps), 以及[文件](https://cloud.google.com/cloud-build/docs/cloud-builders?hl=zh-tw) - args: 會被傳送至 `name` 欄位參照的建構工具。 若建構工具擁有進入點, 則 args 為 args, 若否, 則第一個 args 為進入點。 - images: 要傳送到 Container Registry 的鏡像, 可參考[文件](https://cloud.google.com/cloud-build/docs/build-config?hl=zh-tw#images) 以及 [文件](https://cloud.google.com/cloud-build/docs/configuring-builds/store-images-artifacts?hl=zh-tw) 以下的 gsutil 指令是什麼意思？gsutil versioning set on gs://$PROJECT-kubernetes-manifests - 啟用物件版本管理功能, 啟用後, 每當物件的使用中版本遭到複寫或刪除, Cloud Storage 會為該物件建立一個[封存版本](https://cloud.google.com/storage/docs/object-versioning?hl=zh-tw), 可參考[文件](https://cloud.google.com/storage/docs/using-object-versioning?hl=zh-tw)","link":"/zh-tw/continuousDeliveryPipelinesWithSpinnakerAndKubernetesEngine/"},{"title":"使用 Jenkins 在 Kubernetes Engine 中實作持續交付","text":"概述在本教程中, 你將學習到如何在 Kubernetes engine 中, 使用 Jenkins 來設定持續交付管道。 Jenkins 是一個開發者們經常會使用到的自動化 server, 這些開發者們會經常的需要將他們的程式碼整合到一個共同分享的倉庫中… 在本教程中你將建立一個解決方案, 如下方圖表： 你可以在這裡找到更多在 Kubernetes 中運行 Jenkins 的資訊 你將會做什麼？在本教程中, 你將會完成以下的任務： 提供一個 Jenkins 應用到 Kubernetes Engine 叢集中 使用 Helm Package Manager 來設定你的 Jenkins 應用 探索 Jenkins application 的功能 建立以及運作 Jenkins 管道 先決條件這是一個進階等級的教程。 在我們開始之前, 你應該要會基礎的 shell 程式, Kubernetes, 以及 Jenkins 。 這裡有一些 Qwiklabs 的課程可以讓你達到應有的速度： Introduction to Docker Hello Node Kubernetes Managing Deployments Using Kubernetes Engine Setting up Jenkins on Kubernetes Engine 如果你已經準備好了, 往下拉, 學習更多 Kubernetes, Jenkins, 以及持續交付。 Kubernetes Engine 是什麼？Kubernetes Engine 是由 GCP 所管理的 Kubernetes 版本 - 一個強大的叢集管理器以及容器編排系統。 Kubernetes 是一個開源的專案, 可以運行在很多不同的環境上, 從筆電到高可用的多主機叢集; 從公開的雲端到人為部署; 從虛擬機到裸機 如上所敘, Kubernetes 應用建立在 容器上 - 有一些含有所有 dependencies 以及 libraries 的輕量化應用來運行 Kubernetes 應用。 這些底層的架構讓 Kubernetes 更加的高可用, 安全, 以及快速部署 - 這是雲端開發者理想中的框架 Jenkins 是什麼？Jenkins 是一個開源的自動化 server, 它可以讓你更靈活的編排你的 build, test, 以及部署管道。 Jenkins 讓開發者可以更快速的迭代專案, 不需擔心由持續交付所造成的問題 什麼是持續交付 / 持續部署？當你需要設定 continuous delivery (CD) pipeline (持續交付管道), 部署 Jenkins 到 Kubernetes Engine 相比傳統一般的 VM 部署, 提供了巨大的好處 當你使用容器來運行 build 程序, 虛擬主機可以在多作業系統上運行 jobs 。 Kubernetes Engine ephemeral build executors (暫時性的 build 執行者) - 他們只有當 builds 需要運行時才會被使用到, 這個機制可以將資源留給其他有需要的叢集任務, 像是批量處理的工作。 另外一個 ephemeral build executors 的好處是它的速度 - 啟動只是幾秒鐘的事 Kubernetes Engine 也內建了 Google 全球平衡負載, 你可以利用它來將流量自動化的導向你的機器。 平衡負載提供了 SSL 處理端點, 以及使用一個由 Google 的基礎網路設定的全球 IP - 與你的前端配合, 這個平衡負載將建立一條在你的服務與使用者之間最有效率的通道 現在你已經知道一點 Kubernetes, Jenkis, 以及兩者之間如何在 CD 管道中互動的知識, 是時候來自己做一個了。 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 複製倉庫一開始, 在 Cloud Shell 開啟一個新的視窗, 執行以下的指令來設定 zone 為 us-east1-d gcloud config set compute/zone us-east1-d 複製本教程的範例程式碼： git clone https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes.git 切換到正確的資料夾內: cd continuous-deployment-on-kubernetes 提供 Jenkins建立一個 Kubernetes 叢集現在執行以下的指令來建立一個 Kubernetes 叢集 gcloud container clusters create jenkins-cd \\--num-nodes 2 \\--machine-type n1-standard-2 \\--scopes &quot;https://www.googleapis.com/auth/source.read_write,cloud-platform&quot; 這個步驟會耗費幾分鐘完成。 額外的 scopes 讓 Jenkins 可以存取 Cloud Source Repositories 以及 Google Container Registry 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Kubernetes 叢集, 你將獲得一個評價分數。 在開始前, 使用以下指令來確認你的叢集有在正常運行中 gcloud container clusters list 現在, 取得叢集的憑證 gcloud container clusters get-credentials jenkins-cd Kubernetes Engine 使用這些憑證來存取你新建立的叢集 - 使用以下指令來確認你可以連接它 kubectl cluster-info 安裝 Helm在本教程中, 你將會使用 Helm, 從 Charts 倉庫來安裝 Jenkins 。 Helm 是一個套件管理器, 他讓設定以及部署 Kubernetes 應用更加的簡單。 一旦你安裝了 Jenkins 到你的叢集, 你將可以設定你的 CD/CD 管道。 下載以及安裝 helm 二進制檔 wget https://storage.googleapis.com/kubernetes-helm/helm-v2.14.1-linux-amd64.tar.gz 在 Cloud Shell 中解壓縮檔案 tar zxfv helm-v2.14.1-linux-amd64.tar.gzcp linux-amd64/helm . 把你自己加到叢集的 RBAC 中, 身份為叢集管理者, 所以你將可以在叢集中賦予 Jenkins 權限 kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account) Tiller 是 server side 的 Helm, 在叢集中賦予它叢集管理的角色 kubectl create serviceaccount tiller --namespace kube-systemkubectl create clusterrolebinding tiller-admin-binding --clusterrole=cluster-admin --serviceaccount=kube-system:tiller 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Tiller 服務帳戶, 你將獲得一個評價分數。 初始化 Helm 。 這確保了 server side 的 Helm 已經正確的安裝到你的叢集./helm init --service-account=tiller./helm update 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功的初始化 Helm, 以及安裝 Tiller, 你將獲得一個評價分數。 執行以下指令來確保 Helm 已經正確的被安裝。 你應該會看到 server 端以及 client 端的版本號:./helm version 範例輸出 Client: &amp;version.Version&#123;SemVer:&quot;v2.14.1&quot;, GitCommit:&quot;5270352a09c7e8b6e8c9593002a73535276507c0&quot;, GitTreeState:&quot;clean&quot;&#125;Server: &amp;version.Version&#123;SemVer:&quot;v2.14.1&quot;, GitCommit:&quot;5270352a09c7e8b6e8c9593002a73535276507c0&quot;, GitTreeState:&quot;clean&quot;&#125; 設定並安裝 Jenkins你將使用一個客製的檔案來增加一個必要的 GCP 插件, 要使用 service account 憑證來存取 Cloud Source Repository, 這個插件是必要的 使用 Helm CLI 來根據設定部署 chart./helm install -n cd stable/jenkins -f jenkins/values.yaml --version 1.2.2 --wait 這個指令可能會花幾分鐘完成 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功設定好 Jenkins chart, 你將獲得一個評價分數。 一旦指令完成了, 確保 Jenkins pod 是處於正常運行狀態, 並且容器是 READY 的狀態 kubectl get pods 範例輸出: NAME READY STATUS RESTARTS AGEcd-jenkins-7c786475dd-vbhg4 1/1 Running 0 1m 設定 Jenkins 服務帳號, 讓它可以部署應用到叢集上 kubectl create clusterrolebinding jenkins-deploy --clusterrole=cluster-admin --serviceaccount=default:cd-jenkins 你應該會收到以下輸出： clusterrolebinding.rbac.authorization.k8s.io/jenkins-deploy created 執行以下指令來設定 port forwarding, 將本機的 port 映射到 Jenkins UI export POD_NAME=$(kubectl get pods --namespace default -l &quot;app.kubernetes.io/component=jenkins-master&quot; -l &quot;app.kubernetes.io/instance=cd&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)kubectl port-forward $POD_NAME 8080:8080 &gt;&gt; /dev/null &amp; 現在, 確認 Jenkins 服務已經被成功建立： kubectl get svc 範例輸出: NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGEcd-jenkins 10.35.249.67 &lt;none&gt; 8080/TCP 3hcd-jenkins-agent 10.35.248.1 &lt;none&gt; 50000/TCP 3hkubernetes 10.35.240.1 &lt;none&gt; 443/TCP 9h 你正使用 Kubernetes Plugin, 所以我們的 builder nodes 當有需要時, Jenkins master 會發請求給他們, 而這些 nodes 會自動地被啟動。當這些 nodes 完成了工作, 他們會被自動關閉, 而他們的資源會回到叢集的資源池 注意到這個服務暴露了任何符合 selector 規則的 pods 的 ports 8080 以及 50000 。 這將在叢集內暴露 Jenkins web UI 以及 builder/agent 註冊 ports 。 另外, jenkins-ui 服務是使用 ClusterIP 暴露, 所以不可從叢集外部被存取。 連接到 Jenkins Jenkins chart 會自動幫你建立一個管理者密碼。 執行以下指令來取得它: printf $(kubectl get secret cd-jenkins -o jsonpath=&quot;&#123;.data.jenkins-admin-password&#125;&quot; | base64 --decode);echo 如下圖, 在 cloud shell 點擊 Web Preview 按鈕, 然後點擊 “Preview on port 8080” 來連接到 Jenkins 使用者介面: 現在你應該能夠使用 username admin, 以及自動產生的密碼登入現在你已經在叢集中設定好 Jenkins, 在下一個章節使用 Jenkins 來管理我們的 CI/CD 管道 理解應用你將在持續部署的管道中部署範例應用 gceme 。 這個應用由 GO 語言所編寫, 位於 sample-app 資料夾底下。 當你在 Computer Engine instance 運行這個 gceme 二進制檔, 這個應用將會該 instance 的資訊如下圖般的形式顯示出來: 這個應用藉由支援兩個運作模式來模擬一個微服務 在 後端模式: gceme 監聽 port 8080, 並且以 JSON 格式返回 Computer Engine instance 的 metadata 在 前端模式: gceme 向後端發請求, 並在使用者介面渲染收到的 JSON 部署應用你將部署應用到兩種不同的環境： Production: 使用者使用的正式環境 Canary: 一個規模小一點的網站, 它只會收到一定比例的使用者流量。 在我們將它發佈到所有的使用者之前, 使用這個環境來使用正式流量驗證你的軟體的正確性。 在 Google Cloud Shell, 到範例的資料夾內: cd sample-app 建立 Kubernetes 的命名空間來邏輯性的區隔不同的部署 kubectl create ns production 使用 kbectl apply 指令建立 production, canary 部署, 以及服務 kubectl apply -f k8s/production -n productionkubectl apply -f k8s/canary -n productionkubectl apply -f k8s/services -n production 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立部署, 你將獲得一個評價分數。 預設來說, 前端只有一個 replica 被部署。 使用 kubectl scale 指令來確保至少有 4 個 replicas 同時運行執行以下指令來擴大 production 環境的前端 kubectl scale deployment gceme-frontend-production -n production --replicas 4 現在確認一下, 你將會有 5 個 pods 運行前端, 4 個運行 production 流量, 1 個運行 canary (canary 的變更只會影響到 1/5, 20% 的使用者) kubectl get pods -n production -l app=gceme -l role=frontend 再確認 2 pods 運行後端, 1 個運行 production 然後一個是 canary kubectl get pods -n production -l app=gceme -l role=backend 取得 production 服務的外部 IP kubectl get service gceme-frontend -n production 備註: 這邊可能需要幾分鐘的時間讓平衡負載外部 IP 顯示出來 範例輸出: NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEgceme-frontend LoadBalancer 10.79.241.131 104.196.110.46 80/TCP 5h 在瀏覽器貼上 External IP 來檢視 info card 如下: 現在, 將前端服務的平衡負載外部 IP 記到一個變數, 稍等會用到: export FRONTEND_SERVICE_IP=$(kubectl get -o jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot; --namespace=production services gceme-frontend) 在瀏覽器打開外部 IP, 確認兩個服務都運作正常。 輸入以下指令確認版本(應該要是 1.0.0)： curl http://$FRONTEND_SERVICE_IP/version 你已經成功地部署了範例應用, 接下來, 你將設定一個管道以持續的, 可靠的部署你的變更。 建立 Jenkins 管道建立一個程式碼倉庫來存放範例 app 程式碼建立一份 gceme 範例 app 的複製, 然後推送到 Cloud Source Repository: gcloud source repos create default 如果看到警告請忽略, 你將不會被請款 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立代碼倉庫, 你將獲得一個評價分數。 git init 初始化範例 app 資料夾並設定 Git 倉庫: git config credential.helper gcloud.sh 執行以下指令： git remote add origin https://source.developers.google.com/p/$DEVSHELL_PROJECT_ID/r/default 設定 Git commit 的 username 以及 email 。 請將 [EMAIL_ADDRESS] 及 [USERNAME] 替換成你自己的 git config --global user.email &quot;[EMAIL_ADDRESS]&quot;git config --global user.name &quot;[USERNAME]&quot; 將變更的內容加到 stage area, 提交 commit, 並推送到 Git 倉庫 git add .git commit -m &quot;Initial commit&quot;git push origin master 增加你的服務帳戶憑證設定你的憑證, 讓 Jenkins 可以存取你的程式碼倉庫。 Jenkins 將會使用你的叢集服務帳戶憑證從 Cloud Source Repositories 下載程式碼 Step 1: 在 Jenkins 的使用者介面, 在左邊導覽介面點擊 CredentialsStep 2: 點擊 Jenkins Step 3: 點擊 Global credentials (unrestricted)Step 4: 在左側導航介面點擊 Add CredentialsStep 5: 從 KIND 的下拉式窗點擊 Google Service Account from metadata 並點擊 OK 全域憑證已經被加入。 憑證的名字為 CONNECTION DETAILS 區塊的 GCP Project ID 建立 Jenkins job到你的 Jenkins 使用者介面並依造以下的步驟設定管道工作 Step 1: 左側點擊 Jenkins &gt; New Item Step 2: 將專案取名為 sample-app, 然後選擇 Multibranch Pipeline 選項, 點擊 OK Step 3: 在下一頁, Branch Sources 區塊, 點擊 Add Source 然後選擇 git Step 4: 在 Project Repository 欄位貼上 sample-app 資料夾在 Cloud Source Repositories 的 HTTPS clone URL 。 請將 [PROJECT_ID] 替換成你的 GCP Project ID: https://source.developers.google.com/p/[PROJECT_ID]/r/default Step 5: 在 Credentials 下拉選單, 選擇之前增加服務帳戶時所建立的憑證名稱 Step 6: 在 Scan Multibranch Pipeline Triggers 區塊下, 勾選 Periodically if not otherwise run, 並設定 Interval 為 1 分鐘 Step 7: 你的 job 設定應該看起來會如下： Step 8: 其餘選項留為預設, 點擊 Save在你完成這些步驟之後, 一個叫做 “Branch indexing” 的 job 會運行。 這個 meta-job 會辨識你的倉庫中的分支, 並且確保變更沒有出現在現存的分支中。 如果你在左上方點擊 sample-app, 你該會看到 master job 備註： master 的第一次運行應該會失敗, 直到你再下一個步驟提交一些程式變更 你已經成功地建立了一個 Jenkins 管道, 接下來, 你將會建立一個持續整合的開發環境 建立開發環境開發分支是在我們提交整合到正式環境之前, 讓開發者們用來測試程式碼變更的環境。 這個環境是應用的縮小規模版本, 但需要比較正式環境完全相同的機制下部署。 建立一個開發分支你可以推送分支到 Git server, 讓 Jenkins 來部署你的環境, 藉此建立從功能分支來建立一個開發環境建立一個開發分支並且推送到 Git server git checkout -b new-feature 修改管道定義定義管道的 Jenkinsfile 是由 Jenkins Pipeline Groovy syntax 所編寫。 使用 Jenkinsfile, 可以藉由僅僅一個檔案來敘述整個的 build 管道程序。管道支援強大的功能, 像是並行化, 以及使用者手動核准 要讓管道如預期般運作, 我們需要修改 Jenkinsfile 來設定我們的 project ID 在 terminal 打開 Jenkinsfile vim Jenkinsfile 開始修改 i 將 REPLACE_WITH_YOUR_PROJECT_ID 替換成你的 PROJECT_ID 。 你可以在這個教程的 CONNECTION DETAILS 區塊找到你的 PROJECT_ID, 也可以輸入 gcloud config get-value project 來取得它 def project = &#x27;REPLACE_WITH_YOUR_PROJECT_ID&#x27;def appName = &#x27;gceme&#x27;def feSvcName = &quot;$&#123;appName&#125;-frontend&quot;def imageTag = &quot;gcr.io/$&#123;project&#125;/$&#123;appName&#125;:$&#123;env.BRANCH_NAME&#125;.$&#123;env.BUILD_NUMBER&#125;&quot; 儲存並退出 Jenkinsfile 檔案 :wq 修改網站要展示應用的變更, 你需要改變 gceme cards 的顏色, 從 藍色 改為 橘色 打開 html.go: vim html.go 開始編輯 i 改變兩個位置的 &lt;div class=&quot;card blue&quot;&gt; &lt;div class=&quot;card orange&quot;&gt; 儲存 html.go 檔案, 按下 Esc, 然後： :wq 打開 main.io: vim main.io 開始編輯: i 版本被定義在這一行 const version string = &quot;2.0.0&quot; 再次儲存 main.go, 按下 Esc, 然後： :wq 開始部署提交 commit 並推送變更 git add Jenkinsfile html.go main.gogit commit -m &quot;Version 2.0.0&quot;git push origin new-feature 這將會開始一個開發環境的建立 在變更被推送到 Git repository 後, 到 Jenkins 使用者介面可以看到針對 new-feature 分支的建立已經開始。 大概會需要 1 分鐘完成 在 build 開始運行後, 點擊 build 旁, 位於左手邊的下拉箭頭, 選擇 Console output: 花幾分鐘的時間來追蹤 build 的輸出然後可以看到 kubectl --namespace=new-feature apply... 訊息開始。 你的 new-feature 分支將開始被部署到叢集上。 備註: 在開發情境中, 你不會使用面向公開的平衡負載。 你可以使用 kubectl proxy 來讓你的應用更安全。 這個代理 (proxy) 會自己使用 kubernetes API 來驗證, 並且代理從你本機發出到叢集中的服務的請求, 不須將你的服務暴露到網路上。 如果你沒有看到 Build Executor 裡有任何東西, 別擔心。 到 Jenkins homepage -&gt; sample app 。 確認 new-feature 管道已經被建立 一旦全部的工作都完成後, 開始在背景開啟代理 kubectl proxy &amp; 如果有錯誤, 按下 ctrl + c 來退出。 發一個請求到你的 localhost, 並讓 proxy 幫你轉發到你的服務, 確認你的應用是可被存取的。 curl \\http://localhost:8001/api/v1/namespaces/new-feature/services/gceme-frontend:80/proxy/version 你應該會看到回應 2.0.0, 這是目前運行中的版本 如果你收到類似錯誤如下： &#123; &quot;kind&quot;: &quot;Status&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: &#123; &#125;, &quot;status&quot;: &quot;Failure&quot;, &quot;message&quot;: &quot;no endpoints available for service \\&quot;gceme-frontend:80\\&quot;&quot;, &quot;reason&quot;: &quot;ServiceUnavailable&quot;, &quot;code&quot;: 503 這代表你的前端端點還沒有準備好。 等待一下下, 用 curl 指令再試一次。 如果你收到以下的輸出, 那我們可以繼續往下了。 2.0.0 你已經設定好開發環境了！ 接下來, 你將會建立你之前所學到的, 部署一個金絲雀發佈 (canary release) 來測試一個新功能 部署一個金絲雀發佈 (Canary Release)你已經確認過你的應用目前正在開發環境運行著最新的程式碼, 所以現在部署這些程式碼到金絲雀環境 建立一個 canary 分支, 然後推送到 Git server: git checkout -b canarygit push origin canary 在 Jenkins 中, 你應該會看到 canary 管道已經啟動。 一旦它完成了, 你可以確認看看服務的 URL, 確保一些流量已經是由新的版本服務。 每五個請求中應該會有一個請求會返回 version 2.0.0 (無特定的順序) export FRONTEND_SERVICE_IP=$(kubectl get -o \\jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot; --namespace=production services gceme-frontend) while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; done 如果你一直看到 1.0.0, 試著再次運行上面的指令。 一但你確認 Okay 了, 按下 Ctrl-c 來結束指令 就是這樣！ 你已經部署了金絲雀發佈。 現在你將部署新版到正式環境 部署到正式環境現在我們的金絲雀發佈已經成功, 且沒有收到任何客戶的抱怨, 可以部署到其他的地方了！ 建立一個金絲雀分支, 然後推送到 Git server git checkout mastergit merge canarygit push origin master 在 Jenkins 中, 你應該會看到 master 管道已經啟動。 一旦它完成了(可能會花個幾分鐘), 你可以確認看看服務的 URL, 確保所有流量都是由 version 2.0.0 所服務 export FRONTEND_SERVICE_IP=$(kubectl get -o \\jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot; --namespace=production services gceme-frontend) while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; done 如果你一直看到 1.0.0, 試著再次運行上面的指令。 一但你確認 Okay 了, 按下 Ctrl-c 來結束指令 範例輸出: gcpstaging9854_student@qwiklabs-gcp-df93aba9e6ea114a:~/continuous-deployment-on-kubernetes/sample-app$ while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; done2.0.02.0.02.0.02.0.02.0.02.0.0^C 你可以到 gceme 應用的網站上, 顯示 info cards 的地方去看看, card 的顏色已經從藍色變為橘色。 以下的指令可以取得外部 IP 位置 kubectl get service gceme-frontend -n production 範例輸出 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 你已經完成了！幹得好, 你已經成功地將你的應用部署到正式環境！ 恭喜你已經完成本教程！","link":"/zh-tw/continuousDeliveryWithJenkinsInKubernetesEngine/"},{"title":"資料結構 - Binary Search Tree (二元搜尋樹) - PHP 實作","text":"# 前言強者朋友說: 演算法不熟情有可原, 但是資料結構不懂就是你的錯了。如果對 Tree 資料結構不是很了解, 建議可以先參考Tree 的簡介 # BST 概念解說關於 BST 的解說, 可以從上面的連結去了解一下, 下面就直接用範例來解說 # 範例# Node下面會針對 Node class, 以及各個 method 做概念上的解說 # Node classnode 會有幾個 property $data 為此 node 持有的值 $left 為 left child node $right 為 right child node $parent 為 parent node 如下 example: &lt;?phpclass Node &#123; public $data; public $left; public $right; public $parent; public function __construct(int $data = NULL, Node $parent = NULL) &#123; $this-&gt;data = $data; $this-&gt;parent = $parent; $this-&gt;left = NULL; $this-&gt;right = NULL; &#125; &#125; # min找到自當前 node 以下的 BST 中的最小值。 BST 的規則中, 每個 node &gt; left child node, 因此, 若我要取得該 tree 下最小的 node, 那該 node 必定位於該 tree 的最左最底層如下 example: &lt;?phppublic function min() &#123; $node = $this; while($node-&gt;left) &#123; $node = $node-&gt;left; &#125; return $node; &#125; # max找到自當前 node 以下的 BST 中的最大值。 BST 的規則中, 每個 node &lt; right child node, 因此, 若我要取得該 tree 下最大的 node, 那該 node 必定位於該 tree 的最右最底層如下 example: &lt;?phppublic function max() &#123; $node = $this; while($node-&gt;right) &#123; $node = $node-&gt;right; &#125; return $node; &#125; # successor (繼承者)Tree 當中, 依大小來看, 比當前 node 大的下一個值又稱為 successor (繼任者)。從 BST 規則我們知道, node &lt; right child node, 所以, right child node 此 subtree 下的最小值, 便是 node 的 successor如下 example: &lt;?phppublic function successor() &#123; $node = $this; if($node-&gt;right) return $node-&gt;right-&gt;min(); else return NULL; &#125; # predecessor (前任)Tree 當中, 依大小來看, 比當前 node 小的上一個值又稱為 predecessor (前任, 不是前男友)。從 BST 規則我們知道, node &gt; left child node, 所以, left child node 此 subtree 下的最大值, 便是 node 的 predecessor如下 example: &lt;?phppublic function predecessor() &#123; $node = $this; if($node-&gt;left) return $node-&gt;left-&gt;max(); else return NULL;&#125; # BST現在來講講 BST class, 一樣會從 BST class 到各個 method 做概念上的解說 # BST classBST 只有一個 property $root, 代表此 BST 的 root node &lt;?phpclass BST &#123; public $root = NULL; public function __construct(int $data) &#123; $this-&gt;root = new Node($data); &#125; &#125; # isEmpty這個比較簡單, 判斷該 BST 是否為 empty tree如下 example: &lt;?phppublic function isEmpty(): bool &#123; return $this-&gt;root === NULL; &#125; # insert程式碼看起來有點長, 但其實邏輯與概念都不複雜。BST 的排列規則為 node &gt; left child node, node &lt; right child node, 因此, 不停的拿 node 與 data 循著此規則比較並往下, 便可以找到適合 insert data 的位置如下 example: &lt;?phpfunction insert(int $data)&#123; if ($this-&gt;isEmpty()) &#123; $node = new Node($data); $this-&gt;root = $node; return $node; &#125; $node = $this-&gt;root; while ($node) &#123; if ($data &gt; $node-&gt;data) &#123; if ($node-&gt;right) &#123; $node = $node-&gt;right; &#125; else &#123; $node-&gt;right = new Node($data, $node); $node = $node-&gt;right; break; &#125; &#125; elseif ($data &lt; $node-&gt;data) &#123; if ($node-&gt;left) &#123; $node = $node-&gt;left; &#125; else &#123; $node-&gt;left = new Node($data, $node); $node = $node-&gt;left; break; &#125; &#125; else &#123; break; &#125; &#125; return $node;&#125; # traverse (遍歷)traverse 的概念主要利用二個特性, 使用遞迴來找到並 echo 出每個 node 的 data BST 的排列規則 每個 node 與及 parent 以及 child 都有著 linked list 的特性&lt;?phppublic function traverse(Node $node) &#123; if ($node) &#123; if ($node-&gt;left) $this-&gt;traverse($node-&gt;left); echo $node-&gt;data . &quot;\\n&quot;; if ($node-&gt;right) $this-&gt;traverse($node-&gt;right); &#125;&#125; # removeremove 概念上很單純, 找到該 node, 然後刪除會用到 Node class 的 search, delete method, 可先往下看, 等到理解完 search 以及 delete method, 自然無痛領悟 remove method &lt;?phppublic function remove(int $data) &#123; $node = $this-&gt;search($data); if ($node) $node-&gt;delete();&#125; # search細細一看, 有沒有發現概念上其實跟 insert 類似？ 差異處在於, insert 找到位置後執行 insert 動作, 而 search 是 return 該 node一樣是循著 BST 的規則往下找, 找到後 return 該 node (以 break 方式結束 loop), 若沒找到則會 return null (找到底部還沒找到, 所以 $node 為 false 而結束 loop) &lt;?phppublic function search(int $data) &#123; if ($this-&gt;isEmpty()) &#123; return FALSE; &#125; $node = $this-&gt;root; while ($node) &#123; if ($data &gt; $node-&gt;data) &#123; $node = $node-&gt;right; &#125; elseif ($data &lt; $node-&gt;data) &#123; $node = $node-&gt;left; &#125; else &#123; break; &#125; &#125; return $node; &#125; # deleteDelete 在所有 method 當中, 邏輯是最為複雜的。首先, 我們先歸納出幾種可能性 要被刪除的 node 沒有 child node 要被刪除的 node 只有左或右一個 child node 要被刪除的 node 有左右 child node 示意圖如下： 如果情況是 1, 那最單純, 直接刪除就可 如果情況是 2, 那概念上也很簡單, 我們只需要將 parent 跟 child 連起來, 而一旦 parent 跟 child 的連結變更了, 那當前 node 也就等於不存在了 (因為沒有 node 可以連結到他)因此, 我們需要判斷該 node 是其 parent 的 left 或 right child node, 這樣我們才可以修改 parent 上對應的 property, 不然改錯可是會 GG 的。 以及該 node 所擁有的 child node 是 left 還是 right, 概念同 parent 如果情況是 3, 那依照 BST 的規則, node &gt; left child node, node &lt; right child node, 因此我們必須將一個合乎這個規則的 node 移動到被刪除 node 原本的位置上, 這樣才會符合 BST 規則怎麼做呢？ 如果上面有認真看過上面解說的朋友就知道, 我們可以使用 successor 或 predecessor 取得合適的 node, 兩者都可, 以下 example 會使用 successor 好啦, 基本上就是這三種概念, 釐清概念之後讀 example code 就簡單很多啦!那接下來就請參考以下的 example: &lt;?phppublic function delete() &#123; $node = $this; if (!$node-&gt;left &amp;&amp; !$node-&gt;right) &#123; if ($node-&gt;parent-&gt;left === $node) &#123; $node-&gt;parent-&gt;left = NULL; &#125; else &#123; $node-&gt;parent-&gt;right = NULL; &#125; &#125; elseif ($node-&gt;left &amp;&amp; $node-&gt;right) &#123; $successor = $node-&gt;successor(); $node-&gt;data = $successor-&gt;data; $successor-&gt;delete(); &#125; elseif ($node-&gt;left) &#123; if ($node-&gt;parent-&gt;left === $node) &#123; $node-&gt;parent-&gt;left = $node-&gt;left; $node-&gt;left-&gt;parent = $node-&gt;parent; &#125; else &#123; $node-&gt;parent-&gt;right = $node-&gt;left; $node-&gt;left-&gt;parent = $node-&gt;parent; &#125; $node-&gt;left = NULL; &#125; elseif ($node-&gt;right) &#123; if ($node-&gt;parent-&gt;left === $node) &#123; $node-&gt;parent-&gt;left = $node-&gt;right; $node-&gt;right-&gt;parent = $node-&gt;parent; &#125; else &#123; $node-&gt;parent-&gt;right = $node-&gt;right; $node-&gt;right-&gt;parent = $node-&gt;parent; &#125; $node-&gt;right = NULL; &#125;&#125; # 實際跑跑看下面我們來實際跑跑看, 首先是 insert &lt;?php$tree = new BST(10); $tree-&gt;insert(12); $tree-&gt;insert(6); $tree-&gt;insert(3); $tree-&gt;insert(8); $tree-&gt;insert(15); $tree-&gt;insert(13); $tree-&gt;insert(36); $tree-&gt;traverse($tree-&gt;root); 這時的 BST 看起來應該會像這樣： 輸出: 3681012131536 接著來試試 search &lt;?phpecho $tree-&gt;search(14) ? &quot;Found&quot; : &quot;Not Found&quot;;echo &quot;\\n&quot;;echo $tree-&gt;search(36) ? &quot;Found&quot; : &quot;Not Found&quot;; 輸出: Not FoundFound 最後來試試 remove &lt;?phppublic function remove(int $data) &#123; $node = $this-&gt;search($data); if ($node) $node-&gt;delete();&#125;$tree-&gt;remove(15);$tree-&gt;traverse($tree-&gt;root); 輸出: 36810121336 # Traverse不曉得有沒有朋友想過一個問題, 那就是為什麼 traverse method 會讓結果自動排序？ 到底是什麼黑魔法？其實, 依照不同的順序, traverse 又分為三種, 分別是 in-order, pre-order, 跟 post-order讓我們一一觀來！ # in-orderIn-order traverse 會在每一個 node 當中, 依循下面的邏輯順序： traverse left child node echo node data traverse right child node 如果是使用 in-order, 那會照 node 的大小順序 echo # pre-orderpre-order traverse 會在每一個 node 當中, 依循下面的邏輯順序： echo node data traverse left child node traverse right child node # post-orderpost-order traverse 會在每一個 node 當中, 依循下面的邏輯順序： traverse left child node traverse right child node echo node data 只是 echo 的順序不同, 卻會讓結果完全的不同呀！ 這個 Ray 思考了一下, 發現很難用文字去解釋, 程式邏輯在遞迴中的執行順序其實跟不在遞迴中也一樣, 只是多了遞迴的概念, 嗯… 我好像在說廢話, 哈哈不過這邊有個推薦的網站可以模擬並圖示化 BST 的行為, 有興趣的朋友可以去玩玩看！Binary Tree Visualiser # 總結 送君千里, 終須一別。天下無不散的宴席。 本篇文章到此就結束啦, 希望對你/妳有幫助！ # 參考來源 PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/data-structure-binary-search-tree-php-implementation/"},{"title":"在 GCP 上開立一台虛擬機","text":"本篇將會做什麼？ 利用 GCP 主控台建立一個 virtual machine 利用 gcloud command line 建立一個 virtual machine 在 virtual machine 上部署一個 web server 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記原文可參閱Refer to official link 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 理解 Regions 和 Zones 特定的 Compute Engine 資源位於特定的 regions 或 zones. Region 表示一個你可以運行你的資源的特定地理位置。 每個 region 都有一個或多個 zones，舉例來說，us-central1 region 位於 Central United States，並且下面有 us-central1-a, us-central1-b, us-central1-c, us-central1-f 這些 zones 位於 zone 的資源算是 zonal 資源。 Virtual machine instance 還有 persistent disk 都位於 zone, 如果要在一個 virtual machine 上加一個 persistent disk，那兩者必須位於同一個 zone 很類似的，如果你要分配一個 static IP 位址到一個 instance，這個 instance 必須要跟這個 static IP 同一個 region 從 Cloud Console 建立一個新的 instance Navigation menu &gt; Compute Engine &gt; VM instance 按 create 欄位 值 額外資訊 name gcelab region us-central1(Iowa) or asia-south1(Mumbai) 更多regions的資訊 zone us-central1-c or asia-south1-c 注意：記住你選擇的 zone, 待會會用到 更多zone的資訊 Machine Type 2 vCPUs 這是一個(n1-standard-1), 1-CPU, 3.75GB RAM instance 有很多種類型可以選擇，從基礎型的到 32-core/208GB RAM 的都有，更多資訊可以參考機型種類文件 一個新專案有所謂的resource quota, 他會限制可以開立的機型規格。我們可以要求更高規格的機型在此 lab 之外 Boot Disk New 10 GB standard persistent disk OS Image: Debian GNU/Linux 9 (Stretch) 有很多種類的 images 可以選擇，包含 Debian, Ubuntu, CoreOS，以及一些高級的iamges，像是 RedHat Enterprise, Linux，和 Windows Server, 更多資訊可以參考作業系統文件 Firewall 勾選 Allow HTTP traffic 勾選這個選項，所以我們等等才能存取安裝好的 server 注意：這會自動建立防火牆規則，容許 HTTP 80 port 通道 點擊 Create 點擊 SSH, 經由瀏覽器連到 virtual machine 注意：更多資訊可以參考文件 安裝 NGINX web server 經由 SSH 連接 virtual machine 之後，先取得 root 權限sudo su - 更新 OSapt-get update 安裝 NGINXapt-get install nginx -y 確認 NGINX 正常運行中ps auwx | grep nginx 現在我們可以經由點擊 Cloud Console 上的 External IP 連結按鈕，或者直接在瀏覽器上輸入http://EXTERNAL_IP/ IP位址來連結到 Server 的網頁 使用 gcloud 來建立一個 instance 除了使用 GCP 主控台之外，我們也可以使用 gcloud 的 command line 工具來建立一個 virtual machine instance, 這個工具已經事先被安裝在 Google Cloud Shell 中了。 Cloud Shell 是一台以 Debian 為基礎的 virtual machine, 預載有所有你需要的開發工具 (gcloud, git, 還有其他的等等), 並且提供 5GB persistent disk 的 home 目錄 如果你之後想要在自己的機器上嘗試看看，可以參考[gcloud command line tool guide](https://cloud.google.com/sdk/gcloud/) 在 Cloud Shell, 利用 command line gloud 工具建立一台新的 virtual machine instance gcloud compute instances create gcelab2 --zone us-central1-c 建立的 instance 將會有以下的預設值 最新的 Debian 9 image n1-standard-1 machine type, 在這個 lab 中，你可以選擇其他的 machine type, 像是 n1-highmen-4 或 n1-highcpu-4, 如果你在做這個 lab 之外的專案，你可以選擇客製化的 machinee type 預設的 persistent disk 名稱將與此 instance 一樣，並自動加到此 instance 使用 gcloud compute instances create --help 檢視所有預設 如果你總是使用同一個區域，你可以將指定的地區設為預設，這樣就不需要每次都要使用--zone參數 gcloud config set compute/zone gcloud config set compute/region 檢視你的 instance, Navigation menu &gt; Compute Engine &gt; VM instances 最後，你可以使用 gcloud 經由 SSH 連線到你的 instance, 當你在連接時，確定一下後面的 zone 是跟你當初建的時候指定的一樣，或者如果你已經使用的上述的指定默認指令，那就不需要在指定一次。 gcloud compute ssh gcelab2 --zone us-central1-c 選 y 繼續 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： Through which of the following ways you can create a VM instance in Google Compute Engine(GCE)? Through web console The gcloud command line tool.","link":"/zh-tw/createAVirtualMachineInGCP/"},{"title":"建立紀錄指標並基於紀錄指標建立警告","text":"概述Logs-based metrics (紀錄指標) 是由 Stackdriver Monitoring 提供的, 基於記錄數據內容的指標。 他可以幫你發現動向, 從紀錄中取出數字數據, 還有建立一個特定的指標來完成事件觸發, 這樣當特定的記錄數據出現時, 就可以發出警告。 在 Stackdriver Monitoring 服務中, 你可以同時使用系統提供的指標, 或是使用者自定義的紀錄指標來建立圖表以及警告政策。 紀錄指標是由紀錄的資料產生的時間序列, 在本教程中你將會動手實作上面所提到的。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立本教程所需的資源本教程中所需的第一個資源是一個產生紀錄的 app。 你將會部署一個 App 到 App Engine, 然後建立一些 url 的運作時間檢查讓 App 紀錄使用以下的指令來複製 app 的範例到你的 GCP 專案中： git clone https://github.com/GoogleCloudPlatform/appengine-guestbook-python cd appengine-guestbook-python/ cloudgcloud app create 輸入號碼來選擇你希望這個 app 被部署到哪一個 region 的 App Engine接下來, 執行: cloudgcloud app deploy --version 1 輸入 Y 繼續 cloudgcloud datastore indexes create index.yaml 輸入 Y 繼續 監控索引 (Monitor indexes)到主控台的 Datastore &gt; Indexes 。 會需要幾分鐘的時間設定。 使用視窗上方的 “Refresh” 按鈕。 目前的狀態應該會是 “Serving” 準備安裝 Stackdriver Monitoring當你開始 Qwiklab 上的教程時, 一台虛擬機會自動被建立。 如果你不是使用 Qwiklab, 可以自己建立一台虛擬機。 下一個步驟，你將會需要安裝 monitoring agent (監視代理程式)。 到 Compute Engine &gt; VM instances 準備安裝吧！ 建立一個 Stackdriver 工作區要使用 Stackdriver, 你的專案必須有一個 Stackdriver 帳號。 以下的步驟會建立一個新的 Stackdriver 免費試用帳號 在 Google Cloud Platform 主控台, 點擊 Navigation Menu &gt; Monitoring當你看到 Stackdriver 的顯示面板, 這代表你的 Stackdriver 工作區已經準備好了 在上層的橫幅點擊 Install Agents 從 VM Instance 使用 SSH 到虛擬機裡, 然後執行以下的指令來安裝 Stackdriver 監控代理以及 Stackdriver 紀錄代理 Stackdriver 代理程式設定 Stackdriver 代理程式Stackdriver 代理讓你更了解你的基礎設施以及應用。 安裝兩種代理到你想要獲取更多資訊的環境。 監控代理Stackdriver Monitoring 代理程式是一個以 collectd 為基礎的 Daemon，可從虛擬機器執行個體收集系統與應用程式指標，並將其傳送至 Monitoring。根據預設，Monitoring 代理程式會收集磁碟、CPU、網路與處理程序指標。您可以將 Monitoring 代理程式設定為監控第三方應用程式，以取得代理程式指標的完整清單。更多資訊 安裝監控代理 curl -sSO https://dl.google.com/cloudagents/install-monitoring-agent.shsudo bash install-monitoring-agent.sh Logging 代理在預設設定中，Stackdriver Logging 代理程式會將記錄從常見第三方應用程式與系統軟體串流至 Stackdriver Logging；請參閱預設記錄的清單。您可以設定代理程式，使其串流其他記錄。如要瞭解代理程式設定與作業，請參閱設定 Stackdriver Logging 代理程式一文。 最佳做法是在所有 VM 執行個體上執行 Stackdriver Logging 代理程式。代理程式會在 Linux 與 Windows 下執行。如要安裝 Stackdriver Logging 代理程式，請參閱安裝記錄代理程式一文。 更多資訊 安裝 logging 代理 curl -sSO https://dl.google.com/cloudagents/install-logging-agent.shsudo bash install-logging-agent.sh 點擊 Monitoring Overview 回到顯示面板 本教程額外的資源因為本教程需要使用紀錄, 所以你需要產生一些有趣的紀錄。 本教程將會使用運作時間確認以及 VM 建立來產生紀錄 建立一些運作時間確認現在你將針對這個目前運作在 App Engine 上的應用, 建立一些運作時間確認。 運作時間確認將會模擬應用載入。 App Engine 將會自動地從所有的請求當中捕捉紀錄, 然後會每分鐘產生紀錄, 所以等等你就會有可以分析的資料了。 回到 GCP 主控台並且點擊 Navigation menu &gt; App Engine 。 點擊右上方的連結, 然後複製你的應用的連結。 你會需要這個來建立一個運行時間確認。 回到 Stackdriver 視窗, 在 Overview 頁面, Uptime Checks 區塊, 點擊 Create Selected Checks 按鈕並且則預設專案 (預設沒勾選), 然後點擊 Create Check 你也可以從左手邊選單的 Uptime Checks 選擇 Uptime Checks Overview , 然後在新視窗點擊 Add Uptime Check 使用以下資訊來編輯 New Uptime Check:Title: pizza checkCheck type: HTTPResource Type: URLHostname: 貼上我們應用的 URL。 從 URL 中移除掉 https:// 以及結尾的 /Path: /?food=pizzaCheck every: 1 min 點擊 Test 來核對 uptime check 有在正常運作中。 當你看到一個綠色的打勾符號, 這表示有在正確運作中。 點擊 Save 你將會看到如下： 勾選 “Don’t ask again” 方塊匡, 然後點擊 “No thanks” 來跳過 uptime check 的警告政策建立 再建立兩個 uptime check 點擊第一個 uptime check 的三個點的圖案, 選擇 “copy” 將名稱變更為 “burger check”, 然後改變 path 到 “/?food=burger” 再複製 uptime check 一次 更名為 “cake check”, 然後 path 變更為 “/?food=cake” 你可以在顯示面板上看到所有增加的 uptime check 系統定義紀錄指標以及使用者定義紀錄指標紀錄指標又分為系統定義以及使用者自定義 系統定義紀錄指標系統定義紀錄指標馬上就可以使用, 這些系統定義指標包含： 收到的紀錄的指標 Byte_count: 收到的記錄項目位元組總數。 被細分為監控資源類型, 紀錄串流名稱, 以及嚴重等級。 被排除的紀錄的指標 Excluded_byte_count: 排除的記錄項目位元組總數。 被細分為監控資源類型 Excluded_log_entry_count: 排除的記錄項目總數。 被細分為監控資源類型。 紀錄指標的指標 Dropped_log_entry_count: 不要看這個名字這樣, 事實上這個不是被 Stackdriver 放棄的紀錄數據, 而是因為遲到了, 所以未被歸進紀錄指標的紀錄項目總數 Log_entry_count: 有被歸進紀錄指標的紀錄項目總數, 所以 dropped_log_entry_count + log_entry_count 為 Stackdriver Logging 收到的紀錄項目總數 Metric_throttled: 顯示數據點是否因為超過時間順序限制而被紀錄指標放棄 Time_series_count: 在紀錄指標中, 活躍的時間序列項目總數的估計值 大部分的系統紀錄指標都是計數器指標。 Counter metrics(計數器指標) 計算符合進階紀錄篩選器的記錄數據數量。 現在, 你將更進一步的看看系統產生的紀錄指標： Log_entry_count 在 Stackdriver 主控台, 點擊 Resources &gt; Metrics Explorer: 開始輸入 “GCE”, 然後選擇 “GCE VM Instance” 為你的資源。 指標的話則是輸入 “log” 以及選擇 “Log entries”: 呈現在你眼前的是一台機器的記錄數據圖表, 這台機器從這個教程開始時就開啟了, 是你的眾多資源之一。 使用者定義的紀錄指標你可以使用已經存在的紀錄來建立你自己的紀錄指標。 他們被稱為使用者定義紀錄指標。 現在你將使用記錄數據來建立一個指標。 在 Stackdriver 主控台, 從左側選單點擊 Logging 現在你已經在紀錄頁面, 在這裡你可以篩選結果 在第一個下拉選單選擇 GCE VM Instance 然後在第二個下拉選單選擇 cloudaudit.googleapis.com/activity , 然後點擊 OK 在其中一筆數據點擊 “insert” 標籤, 然後選擇 Show matching entries 進階篩選器現在已經被啟動並且顯示這個指標的標準 第三行的 protoPayload.methodName 讓你可以經由很多方式來篩選, 更多資訊可以參考這裏 在螢幕上方點擊 Create Metrics 在指標編輯器將你的指標命名為 “newVM” , 然後點擊 Create Metric 你將可以看到你的使用者自定義紀錄指標被加到紀錄指標頁面 針對 VM 建立指標建立警告政策現在你將建立一個警告, 當一個新的 VM 被加到專案時, 你會收到提醒 在 Stackdriver 主控台, 重整螢幕, 然後點擊 Alerting &gt; Create a Policy 加入以下資訊：Condition: 點擊 **Add Condition。 開始輸入 “logging” 以及將 Resource Type 更新為 “logging/user/newVM”, 以及 Condition 設為 “is above” 0 For 1 minute 。 現在點擊 Save Notification: 將你的個人信箱加到 email 欄位, 你才能收到 email 通知 Name this Policy: 輸入 “New Virtual Machine” 點擊 Save 建立一台新的機器現在讓我們來觸發剛剛建立的警告, 建立一台新的機器吧！ 在 GCP 主控台的顯示面板, 到 Navigation menu &gt; Compute Engine &gt; VM instances , 然後在螢幕上方點擊 Create Instance 將你的虛擬機取名為 “instance2”, 然後在允許 HTTP 以及 HTTPs 流量的框框打勾。 剩下的都預設值即可。 點擊 Create 等待幾分鐘讓機器啟動。 3~5 分鐘內, 你應會在 Stackdriver 主控台看到一個事件。 繼續本教程, 我們可以在最後確認結果 標籤 (Labels) 以及使用者自定義指標 (user defined metrics)當你建立指標時, 使用者自定義標籤可以被建立。 每一個配置的標籤都需要一個提取器表達式來告訴 Stackdriver Logging, 如何從紀錄中提取數據, 並且將他們置於標籤數據。 你無法在系統定義指標中加入標籤。 現在你將建立一個含有標籤的使用者定義指標 在 Stackdriver 視窗頁面, 點擊 Logging 篩選紀錄為 GAE Application 以及 appengine.googleapis.com/request_log &gt; OK 在螢幕上方點擊 Create Metric 將指標命名為 “Foodcount”, 然後如果你想要的話也可以加入敘述 再來點擊 Add item 來建立一個標籤 標籤Labels 讓紀錄指標可以含有多個時間序列 - 每一個標籤值。 所有的紀錄指標都有一些預設的標籤。 在本教程中, 你將會建立一個指標, 條件為當一個 uptime check 的紀錄產生, 且這個紀錄含有 “food” 標籤 如果你還沒完成這件事情, 點擊 Add Item 填入以下資訊： Name: foods Label Type: String Field Name: search for “resource” and choose “protoPayload.resource” 點擊 Build 按鈕, 然後輸入表達式: /?food=(.*) 點擊 Done 注意： 要確定你有仔細的設定好標籤值提取器。 一個錯誤可能會導致很大量的活躍時間序列。 超過時間序列限制會導致指標被限制住, 圖表表現下降, 以及額外的時間序列超時成本 點擊 Create Metric 現在你將會看到你的使用者定義指標被加到紀錄指標的畫面 建立 Foodcount 警告政策現在你將建立一個 Foodcount 的警告政策, 就是那個你剛建立的指標在 Stackdriver 主控台, 重整螢幕, 然後點擊 Alerting &gt; Create a Policy 你也可以從 Google Cloud 主控台, 到 Stackdriver 區塊然後點擊 Logging , 然後一樣照著上面的動作來建立 設定以下的條件： 條件: 點擊 Add Condition 。 在 Find Resource 欄位輸入 “logging/user/“ 然後選擇 “logging/user/Foodcount” 。 門檻為 0 以及 1 分鐘, 然後 save 通知: 輸入你的個人信箱到 email 欄位來接收 email 通知 命名這個政策: 輸入 “food alert” 點擊 save 當下一輪的 uptime check 發生, 門檻一定會高於 1 分鐘, 所以警告會被觸發, 且你將會看到一個事件出現在 Monitoring Overview 頁面 分布 (Distribution) 以及延遲 (latency) 指標分佈指標 從符合篩選的數據中累積數字資料。 指標含有一個 Distribution 物件的時間序列, 每一個都含有以下的東西: 在分佈中, 數值的數量累積 數值的平均 偏差值平方的總和 一組直方 buckets 以及 每個 bucket 中都有數值的總和。 你可以使用預設的 bucket 設計, 或是選擇你自己想要的 一個分佈指標常見的使用情境是追蹤延遲。 當接收到每一筆記錄數據, 延遲值會從記錄數據中被取出, 並且加到分佈中。 在規律的間隔下, 累積的分佈被寫到 Stackdriver Monitoring。 接下來你將建立一個追蹤延遲的指標 到 Logs-based Metric 視窗 在 Logs Viewer 控制列上, 在你的指標, 你可以建立一個只會計算你想要的記錄數據的篩選器。 在頁面上方, 點擊 Create Metric 在 Metric Editor 控制列, 填入以下欄位 Name: AppLatency 將 Type 變更為 “Distribution” Field name 為 “latency”, 並選擇 “protoPayload.latency” 點擊 Create Metric 你的新指標出現在 Logs Viewer 指標的列表中, 並且立即出現在相關的 Stackdriver Monitoring 選單 在紀錄指標頁面, 點擊 AppLatency 指標旁的三個小點圖案, 然後選擇 **View in Metrics Explorer 來檢視分佈指標的結果。 你可能需要重整 Stackdriver 的頁面 在圖表上方的下方選單改變圖表的風格為 heatmap Metric Explorer 的結果大概會需要 3~5 分鐘。 你可以一些時候再回到這個頁面來核對結果 你也可以從 Stackdriver 主控台, 到 Resources &gt; Metrics Explorer 輸入你的指標名稱 heatmap 客製顯示面板建立一個客製的面板來顯示特定的指標是一個檢視資料很好的方式。 接下來你會建立一個客製面板來顯示你方才使用的延遲指標 在 Stackdriver 主控台, 點擊 Dashboard &gt; Create Dashboard , 然在右手邊點擊 Add Chart Resource type: GAE ApplicationMetric: Response latency 圖表將會以你使用的指標自我命名, 你可以將他更名為任何你想要的 - 在這個範例中為 “Heatmap” 在螢幕下方點擊 Save 面板需要一個名字 - 點擊 Untitled 然後命名它為 “App Response” 確認警告事件回到 Stackdriver 的 Monitoring Overview 檢視 uptime check 政策的警告。 你也可以回到 Resource 頁面的 Metrics Explorer 點擊 Alerting &gt; Policies overview, 然後點擊政策的名字來更清楚的檢視 newVM 警告。 因為問題已經自我解決了, 點擊 Resolved 視窗, 然後你可以看到 new VM 發生的事件通知 如果你有設定任何 email 通知, 收信並確認核對收到的警告。 這個可能會花更久的時間, 但沒關係, 就算這個教程結束了, 你還是可以收到。 別忘了點擊 Metrics Explorer 視窗並重整頁面來檢視 heatmap 恭喜！你已經完成本教程！","link":"/zh-tw/creatingAndAlertingOnLogsBasedMetrics/"},{"title":"資料結構 - Binary Tree (二元樹) - PHP 實作","text":"# 前言強者朋友說: 演算法不熟情有可原, 但是資料結構不懂就是你的錯了。如果對 Tree 資料結構不是很了解, 建議可以先參考Tree 的簡介 # Binary Node首先, 在 Binary Tree 當中, 每個 node 都需具有容納以下三個元素 left node right node data 如下 Example: &lt;?phpclass BinaryNode &#123; public $data; public $left; public $right; public function __construct(string $data = NULL) &#123; $this-&gt;data = $data; $this-&gt;left = NULL; $this-&gt;right = NULL; &#125; public function addChildren(BinaryNode $left, BinaryNode $right) &#123; $this-&gt;left = $left; $this-&gt;right = $right; &#125;&#125; 上面的 Example 可以看到, $data 用來儲存該 node 的資料的, 而 $left 跟 $right 為紀錄 left child node 以及 right child node 的地方, 可透過 addChildren method 定義 # Binary Tree廢話不多說, 直接看以下範例：Example: &lt;?phpclass BinaryTree &#123; public $root = NULL; // 帶入的那個 node 會被定義為 root, 可自此往下 traverse public function __construct(BinaryNode $node) &#123; $this-&gt;root = $node; &#125; // $level 一開始為 0, 用意為區別不同的階層 // 此為遞迴函數, 會一直往下直到最底層 public function traverse(BinaryNode $node, int $level = 0) &#123; // 如果 $node 非為 null 的話, 先印出 $node 的 data, 再繼續往下 if ($node) &#123; echo str_repeat(&quot;-&quot;, $level); echo $node-&gt;data . &quot;\\n&quot;; // 若有 left child node, 將 $level + 1, 遞迴往下 if ($node-&gt;left) $this-&gt;traverse($node-&gt;left, $level + 1); // 若有 right child node, 將 $level + 1, 遞迴往下 if ($node-&gt;right) $this-&gt;traverse($node-&gt;right, $level + 1); &#125; &#125; &#125; # 實際運行# Example&lt;?php$root = new BinaryNode(&quot;root&quot;); $tree = new BinaryTree($root); $level_one_left = new BinaryNode(&quot;level-one-left&quot;); $level_one_right = new BinaryNode(&quot;level-one-right&quot;); $level_two_1 = new BinaryNode(&quot;level-two-1&quot;); $level_two_2 = new BinaryNode(&quot;level-two-2&quot;); $level_two_3 = new BinaryNode(&quot;level-two-3&quot;); $level_two_4 = new BinaryNode(&quot;level-two-4&quot;); $level_one_left-&gt;addChildren($level_two_1, $level_two_2); $level_one_right-&gt;addChildren($level_two_3, $level_two_4); $root-&gt;addChildren($level_one_left, $level_one_right); $tree-&gt;traverse($tree-&gt;root); # 結果root-level-one-left--level-two-1--level-two-2-level-one-right--level-two-3--level-two-4 # 結論以上就是 PHP 簡單實作 Binary Tree好像有點空虛… # 參考來源 PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/data-structure-binary-tree-php-implementation/"},{"title":"資料結構 - Heap - PHP 實作","text":"# Introduction最近在解 Leetcode Top K Frequent Elements 題目時, 會需要使用到 priorityqueue, 而 priority queue 的實作便是使用 Heap, 因此就有了這一篇 # 概念 Heap 的概念大概如上圖, 主要規則如下： root 為 index 0 的位置 parent 比 child 小的稱為 Min Heap, 而 parent 比 child 大的稱為 Max Heap, 比如上圖的 root 0 的值為 1, 小於 3 以及 6, 以此往下類推, index 1 值為 3 小於 5以及 9 Heap 必須是一個 complete binary tree child 的 index 會剛好等於 parent index * 2 or parent index * 2 + 1, 比如上圖中的 index 0, 其 child 剛好等於 1, 2 # 實作 binary heap# create &amp; insert 先建立一個 class, 建立一個 array 代表 heap, 一個 count 代表目前 heap 內有多少 node, 這邊可以看到, 為什麼是 $size + 1 呢？ 因為我們要讓 heap 的 index 是從 1 開始的, 這樣才能使用 2n &amp; 2n+1 來取得 left &amp; right child &lt;?phpclass MinHeap &#123; public $heap; public $count; public function __construct(int $size) &#123; $this-&gt;heap = array_fill(0, $size + 1, 0); $this-&gt;count = 0; &#125; &#125; 接下來實作 create &amp; insert, 簡單來說, 當我們新增一個 node 到 heap 中, 我們首先將它置於 heap 的最後一個 index, 然後我們開始拿它跟它的 parent 比較, 如果它小於它的 parent, 則把兩個位置互換, 重複這個動作, 直到該 node 被置於正確的位置 (符合上面介紹的 heap 的規則) &lt;?phppublic function create(array $arr = []) &#123; if ($arr) &#123; foreach ($arr as $val) &#123; $this-&gt;insert($val); &#125; &#125; &#125; public function insert(int $i) &#123; if ($this-&gt;count == 0) &#123; $this-&gt;heap[1] = $i; $this-&gt;count = 2; &#125; else &#123; $this-&gt;heap[$this-&gt;count++] = $i; $this-&gt;siftUp(); &#125; &#125; public function siftUp() &#123; $currentPos = $this-&gt;count - 1; $parentPos = intval($currentPos / 2); while ($currentPos &gt; 0 &amp;&amp; $this-&gt;heap[$parentPos] &gt; $this-&gt;heap[$currentPos]) &#123; $this-&gt;swap($currentPos, $parentPos); $currentPos = intval($parentPosPos / 2); $parentPos = intval($currentPos / 2); &#125; &#125; public function swap(int $a, int $b) &#123; $parentPos = $this-&gt;heap[$a]; $this-&gt;heap[$a] = $this-&gt;heap[$b]; $this-&gt;heap[$b] = $parentPos; &#125; # 取出最小值: 取得 root index 的值, 並將原先排在 heap 最後 index 的值拉到第一個 然後依序檢查新的 root index 的值是否有小於兩個 children 把 root index 換成三個 node 裡面最小的值 然後回到與之交換的 child, 重複上面的步驟, 直到整個 heap 符合規則&lt;?phppublic function extractMin() &#123; $min = $this-&gt;heap[1]; $this-&gt;heap[1] = $this-&gt;heap[$this-&gt;count - 1]; $this-&gt;heap[--$this-&gt;count] = 0; $this-&gt;siftDown(1); return $min; &#125;public function siftDown(int $k) &#123; $smallest = $k; $left = 2 * $k; $right = 2 * $k + 1; if ($left &lt; $this-&gt;count &amp;&amp; $this-&gt;heap[$smallest] &gt; $this-&gt;heap[$left]) &#123; $smallest = $left; &#125; if ($right &lt; $this-&gt;count &amp;&amp; $this-&gt;heap[$smallest] &gt; $this-&gt;heap[$right]) &#123; $smallest = $right; &#125; if ($smallest != $k) &#123; $this-&gt;swap($k, $smallest); $this-&gt;siftDown($smallest); &#125;&#125; # binary heap 時間 &amp; 空間複雜度 # Questions and Answers以下的 image 是屬於哪一種資料結構？ Example: Answer:max-heap heap 資料結構中, 如果 root 小於 child nodes, 又稱為？min-heap heap 資料結構中, 如果 root 大於 child nodes, 又稱為？max-heap","link":"/zh-tw/data-structure-heap-php-implememtation/"},{"title":"Kubernetes - 部署 WordPress 應用","text":"# 前言本文為部署 WordPress 應用到 Kubernetes cluster內容非 Production 標準, 若要使用在 Production 環境尚有許多地方要改進 # 環境Ray 是使用 KIND 當練習環境, 是個利用容器模擬出多 multi-node cluster 的應用 因為本文會用到 Metric Server, KIND 並不會安裝, 所以需要到 Metric server 官方頁面 來安裝 如果有遇到 x509: cannot validate certificate for ... because it doesn&#39;t contain any IP SANs 錯誤訊息, 請到 Metric server 官方 Github 下載 component yaml, 然後加入一個 arg --kubelet-insecure-tls # 目標 部署 WordPress 應用到 Kubernetes Cluster 部署 MySQL 資料庫到 Kubernetes Cluster WordPress 應用跟 MySQL 資料庫需可相通 對 WordPress 應用做狀態檢查 對 WordPress 應用建立 HPA 控管, 若負載高於定義, 需自動擴展 # 實作步驟 建立特定 Namespace 編寫 WordPress Deployment yaml file 編寫 WordPress Service yaml file 編寫 MySQL Deployment yaml file 編寫 MySQL Service yaml file 編寫 HPA yaml file 部署 功能測試 HPA 測試 # 建立 Namespace首先, 我們先建立一個 namespace, 本次練習中建立的物件都會部署到該 namespace apiVersion: v1kind: Namespacemetadata: name: wordpress # WordPress Deployment接著, 要來撰寫 WordPress 的 Deployment yamlDeployment 作用主要是 Pod 的管理器為什麼不用 Pod 呢？ 因為如果我們要具有水平擴展的能力的話, 那當流量大時, 1 個 Pod 可能並不足以應付, 所以我們使用 Deployment 來管理 Pod, 可視情況擴縮直接來看 yaml apiVersion: apps/v1kind: Deploymentmetadata: name: wordpress-deployment namespace: wordpress labels: app: wordpress-deploymentspec: minReadySeconds: 5 strategy: type: RollingUpdate rollingUpdate: maxSurge: 40% maxUnavailable: 40% selector: matchLabels: app: wordpress-pod template: metadata: labels: app: wordpress-pod spec: initContainers: - name: check-db-ready image: imega/mysql-client command: - &#x27;sh&#x27; - &#x27;-c&#x27; - &#x27;until mysqladmin ping -h mysql-service &amp;&gt; /dev/null; do echo waiting; sleep 2; done&#x27; containers: - name: wordpress image: wordpress imagePullPolicy: IfNotPresent ports: - containerPort: 80 name: wp-pod-port env: - name: WORDPRESS_DB_HOST value: mysql-service:3306 - name: WORDPRESS_DB_USER value: wordpress - name: WORDPRESS_DB_PASSWORD value: wordpress - name: WORDPRESS_DB_NAME value: wordpress resources: limits: cpu: 200m memory: 200Mi requests: cpu: 100m memory: 200Mi startupProbe: tcpSocket: port: wp-pod-port initialDelaySeconds: 5 failureThreshold: 60 timeoutSeconds: 3 periodSeconds: 10 livenessProbe: tcpSocket: port: wp-pod-port failureThreshold: 3 periodSeconds: 10 timeoutSeconds: 3 readinessProbe: tcpSocket: port: wp-pod-port periodSeconds: 3 timeoutSeconds: 3 媽媽咪啊, 一大串 yaml 檔, 誒誒, 先別走啊！ 你心裡是不是在想 是想搞死誰啊？ 甭緊張, 我們一個一個來嘛… # strategystrategy: type: RollingUpdate rollingUpdate: maxSurge: 40% maxUnavailable: 40% RollingUpdate, 如字面上的意思為滾動更新, 那為什麼要滾動呢？ 如果今天我們觸發一個更新, 但 Deployment 把所有的 Pod 都給砍了, 一次性的啟動新的 Pod, 那服務當場就死翹翹了所以凡事不要急, 要一個一個來, 心急吃不了熱豆腐！ 至於 maxSurge 跟 maxUnavailable, 如果我現有的 Pod 是 100%, maxSurge 40% 表示最多可以啟動新的 Pod 到 140%, 而 maxUnavailable 也是同樣, 最多可減少到 60%所以這兩個設定不可同時設為 0, 阿不然不能多也不能少, 是要滾動個鬼啊？ 滾, 都給我滾… 更多細節部分可參考這篇, 或是官方文件 # selectorselector: matchLabels: app: wordpress-pod selector 主要是定義 Deployment 所管理的 Pod 對象, 所以會跟 template 裡頭的 app: wordpress-pod 一樣 # initContainersinitContainers: - name: check-db-ready image: imega/mysql-client command: - &#x27;sh&#x27; - &#x27;-c&#x27; - &#x27;until mysqladmin ping -h mysql-service &amp;&gt; /dev/null; do echo waiting; sleep 2; done&#x27; 因為 wordpress 服務會用到 MySQL, 如果 MySQL Pod 啟動好之前, wordpress 服務就先好了, 那就使用者端可是會出錯的。所以這邊啟動一個 mysql-client 的 container, 目的在於確定 MySQL 是否 ready, 話說這 image 我隨便弄弄找一個可以用的, 為了可用性, production 可是要把 image 自己準備好, 不然要是人家刪了 image 你就哭哭 # envenv: - name: WORDPRESS_DB_HOST value: mysql-service:3306 - name: WORDPRESS_DB_USER value: wordpress - name: WORDPRESS_DB_PASSWORD value: wordpress - name: WORDPRESS_DB_NAME value: wordpress env 我說了不算, 請參考 DockerHub WordPress # resourcesresources: limits: cpu: 200m memory: 200Mi requests: cpu: 100m memory: 200Mi resources 簡單來說, requests 就是定義 Node 需要多少 resource 才可以放置這個 Pod, 而 limits 就是這個 Pod 最多可使用這個 Node 的多少資源媽媽咪啊我怎麼有辦法說得這麼淺顯易懂, 我真是太帥了細節可參考這篇文章 # Health CheckstartupProbe: tcpSocket: port: wp-pod-port initialDelaySeconds: 5 failureThreshold: 60 timeoutSeconds: 3 periodSeconds: 10livenessProbe: tcpSocket: port: wp-pod-port failureThreshold: 3 periodSeconds: 10 timeoutSeconds: 3readinessProbe: tcpSocket: port: wp-pod-port periodSeconds: 3 timeoutSeconds: 3 這麼多 probe, 簡單來說…有些應用啟動時間比較久, 這時就可以用 startup probe而 livenessProbe 如果是用來確定該 Pod 是否可用, 不可用可是會把 Pod 殺掉的！readinessProbe 如果檢測沒過, 那 service 就不會把 traffic 往這個 Pod 送啦！ tcpSocket 只是檢測的一種方法之一, 也可使用 httpGet 或者 exec 細節部分可以參考這篇文章 好啦, 到這邊 wordpress-deployment 的部份我們都講完了, 下面繼續講, 不過如果有重複的我就不贅述囉！ # WordPress Serviceservice 的作用為將流量導向複數 Pods 的一個 endpoint, 可被其他的 kubernetes cluster 內的服務存取, 也可被外部存取 (需透過 mapping)這個是不是短到有點沒存在感？ 喂～ 我說的是 yaml 長度 apiVersion: v1kind: Servicemetadata: name: wordpress-service namespace: wordpressspec: type: NodePort selector: app: wordpress-pod ports: - port: 80 targetPort: wp-pod-port name: wordpress-service-port nodePort: 30000 protocol: TCP 首先, selector 會 select 出名稱為 wordpress-pod 的 Pods接下來, 定義 service 本身的 port 為 80, 目標的 port 為 wp-pod-port, 還記得嗎？ 這是定義在 wordpress-deployment 的 Pod port再來, 定義此 service 的 port 為 wordpress-service-port類型為 NodePort, 並定義確切的 Portprotocol 為 TCP, 預設值也是 TCP NodePort 的作用在於將此 service map 到 Node 的 port, 所以我們就可以透過存取 Node 的 30000 port 來存取此 service, 這樣理解吧？ # MySQL DeploymentMySQL 是有狀態的服務, 基本上本文中的部署方式絕非 production 適用的 apiVersion: apps/v1kind: Deploymentmetadata: name: mysql-deployment namespace: wordpress labels: app: mysql-deploymentspec: selector: matchLabels: app: mysql-pod template: metadata: labels: app: mysql-pod spec: containers: - name: mysql image: mysql:8.0 imagePullPolicy: IfNotPresent args: - --default_authentication_plugin=mysql_native_password - --character-set-server=utf8mb4 - --collation-server=utf8mb4_unicode_ci ports: - containerPort: 3306 name: mysql-pod-port env: - name: MYSQL_ROOT_PASSWORD value: mysql_root_password - name: MYSQL_DATABASE value: wordpress - name: MYSQL_PASSWORD value: wordpress - name: MYSQL_USER value: wordpress volumeMounts: - mountPath: /var/lib/mysql name: mysql-db volumes: - name: mysql-db hostPath: path: /var/lib/mysql 媽媽咪啊, 現在都流行一大串的 yaml 啊？ 上面講過的我這邊就不會再贅述囉, 讓我們一個一個來！ # argargs: - --default_authentication_plugin=mysql_native_password - --character-set-server=utf8mb4 - --collation-server=utf8mb4_unicode_ci 這個主要是定義資料庫的起始設定, 可參考官方 Dockerhub # env同上, env 也是定義這個資料庫的一些設定, 這邊要特別注意, wordpress env 會定義使用的 DB_HOST … 等等的各項資訊, 所以我們在建立資料庫時, 也要跟 wordpress env 定義的一樣, 這樣 wordpress 啟動之後才可以跟 MySQL 接上 env: - name: MYSQL_ROOT_PASSWORD value: mysql_root_password - name: MYSQL_DATABASE value: wordpress - name: MYSQL_PASSWORD value: wordpress - name: MYSQL_USER value: wordpress # volumevolumeMounts: - mountPath: /var/lib/mysql name: mysql-dbvolumes: - name: mysql-db hostPath: path: /var/lib/mysql 跟 volume 有關的就一次解決, 注意這邊的 example 格式是不對的啊！ 只是為了解說讓他們同排, 正確的請參考 yaml這邊主要是做數據持久化, 將 Pod 中的 data 掛載到 Node 當中mountPath 為 pod 中的 data 位置, 至於為什麼是這個位置？ 你問我我問誰去… 不是啦哈哈, 可參考 官方 DockerHub, 或者也可以自己進到 container 去看看 volumes 為定義一個位置, 這個 volumes 可以讓 Pod 掛載到 Pod 內的任意位置, volumes 的種類有很多種, 這邊使用 hostPath 是定義在 Node 內的一個位置, 當然這不是一個好的做法, 因為當我 MySQL 重啟後, 是否還會被 schedule 到同一個 Node 是未知數, 所以這邊應該還要加個 Node selector 的設定, 不過暫且先這樣吧！ 所以掛載後, Pods 內的 /var/lib/mysql 就會跟 Node 的 /var/lib/mysql 數據同步, 只要 Node disk 沒掛資料就可以持久化保存 # MySQL ServiceapiVersion: v1kind: Servicemetadata: name: mysql-service namespace: wordpressspec: selector: app: mysql-pod ports: - port: 3306 name: mysql-service-port protocol: TCP targetPort: mysql-pod-port 還是 service 比較可愛, 短小精悍！基本上跟 wordpress service 相同, 這邊不贅述 # HPAapiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata: name: wordpress-hpaspec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: wordpress-deployment minReplicas: 1 maxReplicas: 15 targetCPUUtilizationPercentage: 50 假設今天流量突然暴增, 那我原本只有一個 wordpress pod, 怎麼辦？ 使用者端畫面肯定會整個卡住, 因為光是一個 pod 無法處理這麼多 requests, 這時我們就可以使用 HPA 簡單來說, 他設定了最少一個 Pod, 最多 15 個 Pod, 如果目前每個 Pod 的 CPU 負載量超過 50% 的話, 那就再啟動一個 Pod, 直到負載量低於 50% 或者已達 15 個 Pod # 部署接下來就到了部署的時刻啦！ 接下來只要將上面介紹的 yaml 檔案一個一個 apply 就可以完成部署啦, 為求簡單化, 我會將全部的 yaml 寫成一個 yaml, 並放在本文最下方接下來只要部署此 yaml 檔就行啦！ kubectl apply -f all-in-one-yaml # 功能測試完成部署後, 我們訪問 yourNodeIp:30000 就可以看到 WordPress 的首頁啦！ 然後就可以進去玩耍一番！ # HPA 測試接著, 我們要對首頁來發出大量的 request, 看看 HPA 是否運作正常 while true; do wget -q -O- localhost:30000; done 然後耐心地看看 HPA 狀態 kubectl get hpa wordpress-hpa -n wordpress 好像沒在動？ 給點耐心嘛！ 哇靠！ 有了有了！ 接下來, 看看 Pod 是否有變多了 kubectl get pods -A 有了有了！ 等到 autoscale 完成, 再去刷刷頁面, 會發現不會卡了呢！ # 結論本文就到此告一段落啦！ 我們下次見！ # Questions and Answers以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata: name: wordpress-hpaspec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: wordpress-deployment minReplicas: 1 maxReplicas: 15 targetCPUUtilizationPercentage: 50 Answer:建立一個 auto scaler, 最少一個 Pod, 最多 15 個 Pod, 當所有 Pod 的平均 CPU 使用量達到 50% 時觸發 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: v1kind: Servicemetadata: name: wordpress-service namespace: wordpressspec: type: NodePort selector: app: wordpress-pod ports: - port: 80 targetPort: wp-pod-port name: wordpress-service-port nodePort: 30000 protocol: TCP Answer:apiVersion: v1kind: Servicemetadata: name: wordpress-service namespace: wordpressspec: type: NodePort # 要導向的 Pod selector: app: wordpress-pod ports: # service 的 port - port: 80 # 目標 Pod 的 port, 可直接使用 name mapping targetPort: wp-pod-port # 此 service port 的 name name: wordpress-service-port # map 到 Node 上的 port nodePort: 30000 protocol: TCP 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: apps/v1kind: Deploymentmetadata: name: wordpress-deployment namespace: wordpress labels: app: wordpress-deploymentspec: minReadySeconds: 5 selector: matchLabels: app: wordpress-pod template: metadata: labels: app: wordpress-pod spec: containers: - name: wordpress image: wordpress imagePullPolicy: IfNotPresent ports: - containerPort: 80 name: wp-pod-port env: - name: WORDPRESS_DB_HOST value: mysql-service:3306 - name: WORDPRESS_DB_USER value: wordpress - name: WORDPRESS_DB_PASSWORD value: wordpress - name: WORDPRESS_DB_NAME value: wordpress Answer:定義 env, 可參考 WordPress DockerHub 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: apps/v1kind: Deploymentmetadata: name: wordpress-deployment namespace: wordpress labels: app: wordpress-deploymentspec: minReadySeconds: 5 selector: matchLabels: app: wordpress-pod template: metadata: labels: app: wordpress-pod spec: initContainers: - name: check-db-ready image: imega/mysql-client command: - &#x27;sh&#x27; - &#x27;-c&#x27; - &#x27;until mysqladmin ping -h mysql-service &amp;&gt; /dev/null; do echo waiting; sleep 2; done&#x27; containers: - name: wordpress image: wordpress imagePullPolicy: IfNotPresent ports: - containerPort: 80 name: wp-pod-port Answer:使用 mysqladmin 確定 MySQL 已可提供服務後, 再啟動 wordpress container 以下的 Kubernetes Deployment code, selector 的對象是？ Example:selector: matchLabels: app: wordpress Answer:該 Deployment 所管理的 Pod # all-in-one YAMLapiVersion: v1kind: Namespacemetadata: name: wordpress---apiVersion: apps/v1kind: Deploymentmetadata: name: mysql-deployment namespace: wordpress labels: app: mysql-deploymentspec: selector: matchLabels: app: mysql-pod template: metadata: labels: app: mysql-pod spec: containers: - name: mysql image: mysql:8.0 imagePullPolicy: IfNotPresent args: - --default_authentication_plugin=mysql_native_password - --character-set-server=utf8mb4 - --collation-server=utf8mb4_unicode_ci ports: - containerPort: 3306 name: mysql-pod-port env: - name: MYSQL_ROOT_PASSWORD value: mysql_root_password - name: MYSQL_DATABASE value: wordpress - name: MYSQL_PASSWORD value: wordpress - name: MYSQL_USER value: wordpress volumeMounts: - mountPath: /var/lib/mysql name: mysql-db volumes: - name: mysql-db hostPath: path: /var/lib/mysql---apiVersion: v1kind: Servicemetadata: name: mysql-service namespace: wordpressspec: selector: app: mysql-pod ports: - port: 3306 name: mysql-service-port protocol: TCP targetPort: mysql-pod-port---apiVersion: apps/v1kind: Deploymentmetadata: name: wordpress-deployment namespace: wordpress labels: app: wordpress-deploymentspec: minReadySeconds: 5 strategy: type: RollingUpdate rollingUpdate: maxSurge: 2 maxUnavailable: 25% selector: matchLabels: app: wordpress-pod template: metadata: labels: app: wordpress-pod spec: initContainers: - name: check-db-ready image: imega/mysql-client command: - &#x27;sh&#x27; - &#x27;-c&#x27; - &#x27;until mysqladmin ping -h mysql-service &amp;&gt; /dev/null; do echo waiting; sleep 2; done&#x27; containers: - name: wordpress image: wordpress imagePullPolicy: IfNotPresent ports: - containerPort: 80 name: wp-pod-port env: - name: WORDPRESS_DB_HOST value: mysql-service:3306 - name: WORDPRESS_DB_USER value: wordpress - name: WORDPRESS_DB_PASSWORD value: wordpress - name: WORDPRESS_DB_NAME value: wordpress resources: limits: cpu: 200m memory: 200Mi requests: cpu: 100m memory: 200Mi startupProbe: tcpSocket: port: wp-pod-port initialDelaySeconds: 5 failureThreshold: 60 timeoutSeconds: 3 periodSeconds: 10 livenessProbe: tcpSocket: port: wp-pod-port failureThreshold: 3 periodSeconds: 10 timeoutSeconds: 3 readinessProbe: tcpSocket: port: wp-pod-port periodSeconds: 3 timeoutSeconds: 3---apiVersion: v1kind: Servicemetadata: name: wordpress-service namespace: wordpressspec: type: NodePort selector: app: wordpress-pod ports: - port: 80 targetPort: wp-pod-port name: wordpress-service-port nodePort: 30000 protocol: TCP---apiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata: name: wordpress-hpaspec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: wordpress-deployment minReplicas: 1 maxReplicas: 15 targetCPUUtilizationPercentage: 50","link":"/zh-tw/deploy-wordpress-on-kubernetes/"},{"title":"資料結構 - Tree - 不同類型的 Binary Tree","text":"# 前言本篇主要針對不同類型的 Binary Tree 做簡介, 專有名詞部分依照英文呈現不另外做翻譯, 如果對一些特別的 term 不熟悉的, 可以參考 Tree 的簡介 # Full Binary Tree每一個 node 都有 0 個或 2 個 child node, 也就是說要嘛就不要有 child node, 要嘛就是 2 個, 沒有那種 1 個的。 又稱為 proper tree 或 plane binary tree示意圖: # Complete Binary Tree除了最後一個 level 之外, 所有的 level 都要是填滿的, 而最後一個 level 如果沒有滿, 則從左邊開始補滿示意圖: # Perfect Binary Tree所有的 internal node 都要有 2 個 child node, 而所有的 leave node 的 level 或 depth 都要相同示意圖: # Balanced Binary Tree每個 node 的左右 subtree 的 height, 最多差值為 1示意圖: # Degenerate Binary Tree每個 node 都只會有一個 child node示意圖: # 參考資料 PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP Anand K Parmar’s Medium Post","link":"/zh-tw/different-categories-of-binary-tree/"},{"title":"Self, this, static 在 PHP 中的差異","text":"前言俗話說的好, 今天你不弄死他, 改天他就弄死你。 同理可證, 今天你不搞懂它, 改天你照樣會在讀自己或別人寫的 code 時被弄死。就讓我們一起一次搞懂它吧！ Static Variable曾幾何時, 我也幻想, 如果可以不看 example code 就可以理解 OOP, 那該是多好的一件事啊！ 如果你也跟我有同樣的想法, 那… 醒醒吧, 別作夢了！ 蛤？ 你說你很清醒？ 那趕快洗洗睡吧, 這裡沒你什麼事了…一般來說, 變數在 function 執行完畢時就會釋放, 如下面的 example: &lt;?phpfunction test()&#123; $var = 0; $var += 1; echo $var . PHP_EOL;&#125;function testtest()&#123; $var = 0; $var += 1; echo $var . PHP_EOL;&#125;test(); // 1test(); // 1test(); // 1testtest(); // 1testtest(); // 1testtest(); // 1?&gt; 然而, 我們只需在變數前面加上 static, 它就會變成 static variable, static variable 會將值保留下來, 如下 example, 不同的 function 中的 static variable 會分別各自累加上一次的結果 Example:&lt;?phpfunction test()&#123; static $var; $var += 1; echo $var . PHP_EOL;&#125;function testtest()&#123; static $var; $var += 1; echo $var . PHP_EOL;&#125;test(); // 1test(); // 2test(); // 3testtest(); // 1testtest(); // 2testtest(); // 3?&gt; 從上面的 example 可以看到, 不同 function 中定義的 static variable 是不會互相影響的, 但若是定義為 class property, 那作用範圍便是套用到全部的 method, 如下 example, 不同 method 的執行結果會累加到 static variable Example:&lt;?phpclass A&#123; static $var; public static function test() &#123; self::$var += 1; echo self::$var . PHP_EOL; &#125; public static function testtest() &#123; self::$var += 1; echo self::$var . PHP_EOL; &#125;&#125; A::test(); // 1 A::test(); // 2 A::test(); // 3 A::testtest(); // 4 A::testtest(); // 5 A::testtest(); // 6?&gt; Static, this, self下面的 example 有點大包, 其實我原本參照的資料來源更大包。 但其實只是字多了一點, 沒有複雜的 method 傳遞, 並且註解有詳述原理, 不經一番寒徹骨, 焉得梅花撲鼻香啊！ Example:&lt;?phpclass A &#123; protected $name = &#x27;A&#x27;; static $alias = &#x27;a&#x27;; const HASH = &#x27;md5&#x27;; public function dd() &#123; echo $this-&gt;name; echo &#x27;--&#x27;; echo static::$alias; echo &#x27;--&#x27;; echo static::HASH; echo &#x27;--&#x27;; echo self::$alias; echo &#x27;--&#x27;; echo self::HASH; echo &#x27;--&#x27;; var_dump(new self); echo &#x27;--&#x27;; var_dump($this); echo &#x27;--&#x27;; var_dump(new static); echo &#x27;&lt;br&gt;&#x27;; &#125;&#125; class B extends A &#123; protected $name = &#x27;B&#x27;; static $alias = &#x27;b&#x27;; const HASH = &#x27;sha1&#x27;;&#125; // $this-&gt;name = A, $this 代表當前 instance, 而當前 instance 為 // class A 的 instance, 故為 class A 中的 protected variable // static::$alias = a, static 為 forwarding call, static 的 forwarding call // 下面會詳述。 呼叫的 instance 的 class 為 class A, 所以取 class A 中定義的 static variable // static::HASH = md5, 原理同上 // self::$alias = a, self 表示當前 method 歸屬的 class, 此處為 class A, // 因此使用 class A 中定義的 static variable // self::HASH = md5, 原理同上 // new self = class A, 如同上面提到的, 當前 method 所在的 class 為 class A // $this = class A, 原理同上, $this 為 class A 的 instance, 所以是 class A // new static = 同上, 原始被呼叫的 class 為 class A, 所以為 class A(new A)-&gt;dd(); // 輸出為: A--a--md5--a--md5--object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // --object(A)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // --object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // $this-&gt;name = B, $this 代表當前 instance, 也就是 class B // static::$alias = b, static 為 forwarding call, static 的 forwarding call 下面會詳述。 // 呼叫的 instance 的 class 為 class B, 所以取 class B 中定義的 static variable // static::HASH = sha1, 原理同上 // self::$alias = a, self 表示當前 method 歸屬的 class, 因 class B 使用的 test() method 是 // 繼承自 class A 的, 實際上 self 為 class A, 所以使用定義在 class A 的 alias // self::HASH = md5, 原理同上 // new self = class A, 如同上面提到的, 當前 method 定義於 class A // $this = class B, 原理同上, $this 為 class B 的 instance, 所以是 class B // new static = 同上, 原始被呼叫的 class 為 class B, 所以為 class B (new B)-&gt;dd(); // 輸出為: B--b--sha1--a--md5--object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // --object(B)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;B&quot; &#125; // --object(B)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;B&quot; &#125; self首先, 先來看看 self 吧！ self 代表著當下的 class, 跟 __class__ 是一樣的。 啥？ 看無？ 都說了, 要看 example code 嘛！ Example:&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; self::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();// 輸出為 A// 因為 B 本身沒有 test(), 所以調用 A 的 test(), 而 test() 中的 // self 代表 test() 歸屬的 class, 即 A, 所以會調用 A 的 who()?&gt; static上面看完 self, 接下來瞧瞧 static, static:: 代表上一個調用 non-forwarding call 的 class, 不懂沒關係, 這個特性叫做 Late Static Bindings, 下面會詳述。 一樣看一段 example Example:&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; // 唯一跟上一個 example 不同之處, 把 self 換成了 static static::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test();// 輸出為 B// static 代表著上一個調用 non-forwarding call 的 class, 即 B// 下面會針對 forwarding call 以及 non-forwarding call 詳述?&gt; Late Static Bindings這幾個字看似玄乎, 可其實就嚇嚇沒耐心的人而已！ static method 都會有 Late Static Bindings 的特性, 而這個特性是什麼呢？static method 會把最後一次調用 non-forwarding call 的 class name 記錄下來, 也就是說, static 代表的 class 就是上一次呼叫 non-forwarding call 的 class那什麼是 forwarding call 呢？ 下面幾種都算： self:: static:: parent:: forward_static_call() 上面這些都是 forwarding call, 那 non-forwarding call 呢？ 比如 A::test(), 這就是 non-forwarding call, 而 A 就是呼叫 non-forwarding call 的 class看不懂對吧？ 哈哈, 你一撅屁股我就知道你要拉什麼屎! 這樣你就看得懂那你就是天才了, 我自己寫的人都看不太懂了。所以我開頭說了嘛, 想不讀 example code 就想了解 OOP, 根本是癡人說夢啊！還是乖乖認命地在看幾段 example code 吧！ 看完 example code 之後再上來看這一段, 就懂了！ Example: &lt;?phpclass A &#123; public static function foo() &#123; // who() 為 echo called class name, 因此 static 代表什麼, 決定著輸出 static::who(); &#125; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;class B extends A &#123; public static function test() &#123; // 上面有提到 A:: 算 non-forwarding call, 所以假如後面有呼叫 static:: 的話, static 就會代表 A A::foo(); // 上面有提到, parent:: 算 forwarding call, 而上一個 non-forwarding call // 為 C::test(), 因此如果後面有使用 static::, static 表示 C parent::foo(); // 同上 self::foo(); &#125; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;C::test();// A C C// A::foo() 輸出 A, 如上所述, A:: 為 non-forwarding call, // 因此 static::who() 這邊的 static 代表 A// parent::foo() 輸出 C, 如上所述, parent:: 為 forwarding call, // 因此 foo() 中的 static 還是代表上一個 non-forwarding call, 即 C// self::foo() 輸出為 C, 同上?&gt; 看完上面的 example, 是不是比較看得懂 Late Static Bindings 特性以及 forwarding call 跟 non-forwarding call 的差異了呢？ 下面繼續聊聊 self 跟 static 的差異 self 與 staticself 與 static 都可以做到以下的事 取用 static property 取用 constant 取用 static method 差別處在於 self 代表當前 method 所歸屬的 class static 代表上一個 non-forwarding 調用的 class 這樣是不是清楚又明瞭呢？接下來, 我們來看看在 non-static 的狀況下, 又會有什麼特別的行為 $this 與 static在進到 non-static 環境之前, 先來看看 $this 跟 static 有何差異相同處： 原則上, 兩者指向的 class 都相同, 除非調用 static 之前有呼叫 non-forwarding call 而變更了 static 的指向, 這個上面有詳述, 還有點模糊的話再上去看一次。 不同處： $this 不可調用 static property, constant, 以及 static method; 反之, static 也不可調用 non-static property $this 指向的是實際調用的 instance, 而 static 指向的是調用的 class, 原則上兩者會是同一個 class, 但不同的 object 好啦, 接下來就來看看在 non-static context 中, $this 與 static 不同的行為 non-static context (非靜態環境)首先, 先看看以下兩點 $this 與 static 不同的行為, 再對照下面的 example code 就會更明白 static 會先到 它指向的 class 中找尋 private method, 在尋找 public method, 如果沒找到, 再去 調用 static 的 method 所在的 class 中尋找 private method, 然後是 public method, 如果存在就調用, 並停止找尋。 $this 會先到 調用 $this 的 method 所在的 class 中尋找 private method, 再到 它指向的 instance 的 class 中尋找 private method, 然後是 public method, 再來是在 調用 $this 的 method 所在的 class 中尋找 public method, 只要找到就調用, 並停止找尋 Example &lt;?phpclass A &#123; private function foo() &#123; echo __class__ . PHP_EOL; &#125; public function test() &#123; $this-&gt;foo(); static::foo(); &#125;&#125;class B extends A &#123; // foo() 是從 A copy 過來 B 的, 因此它的 scope 依然是 A&#125;class C extends A &#123; private function foo() &#123; // 這個 foo() 覆蓋了 class A 的 foo(), 所以新的 scope 為 C &#125;&#125;$b = new B();// $this-&gt;foo() 輸出為 A, 如上所述, class B 本身沒有 test(), 所以會調用 class A 的// 而 $this 會先到 &quot;調用 $this-&gt;foo()&quot; 的 method, 即 test(), 所在的 class, 即 class A, // 中尋找 private method, 你可以試試在 class B 中新增一個一模一樣的 private method foo(),// 結果還是會先調用 class A 的 foo()// static::foo() 輸出為 A, 同上, 但 class B 並沒有 foo(), 所以調用了 class A 的 foo()// 可以試試在 class B 新增一個 private method foo(), 這樣會報錯, 因為 static 會先從實際調用// class, 即 class B, 尋找 private method, 這樣就變成從 class A 去呼叫 class B 的 private// method, private method 只可從所屬的 class 中才可調用, 當然, 如果改成 public method, // 那輸出就會變成 B$b-&gt;test();$c = new C();// $this-&gt;foo() 輸出是 A, 這點同上, 不加贅述// static::foo() 會 fail, 因為 static 會到實際調用的 class 中尋找 private method, 而// class C 中確實定義了 private method foo(), 這樣就變成了從 class A 的 scope 去調用// class C 的 private method, 所以錯了// 可以試試把 class C 中的 foo() 改成 public, 且輸入跟 class A foo() 一樣的內容// 這樣輸出就會變成 C 了$c-&gt;test(); ?&gt; 結語寫這篇寫了兩天, 這兩天只有上帝跟我知道我在寫什麼, 所以我盡可能地把它寫的詳盡, 一方面也是取之於網路, 回饋於網路。另一方面是, 我不想幾個禮拜之後只剩上帝知道這篇在寫什麼。 搞不好祂也不知道嗚嗚嗚。若內容有錯誤, 請不吝指教, 我當立即修正以避免誤導大家。 歡迎轉載, 但請註明出處！ 參考來源PHP-Late Static BindingsCSDN lamp_yang_3533 的部落格程式狂想筆記","link":"/zh-tw/difference-between-self-this-static-in-php/"},{"title":"GCP Deployment Manager - 正式環境","text":"概述在本教程中, 你將會使用一個叫做 Deployment Manager 的基礎設施策劃工具來啟動一個服務, 並且使用 Stackdriver 來監控這個服務。 在 Stackdriver, 你將會使用 Stackdriver 主控台來設定基礎的黑盒子監控, 並且建立一個運行時間確認 (Uptime Check) 來觸發事件通知 (alert notification) 更精確的說, 你將會： 使用 Deployment Manager 範本來安裝並且設定一個進階的的 deployment 啟動 Stackdriver monitoring 設定 Stackdriver 運行時間確認以及通知 設定 Stackdriver 主控台, 設定兩個圖表, 一個顯示 CPU 使用率, 另一個顯示 ingress 流量 實施一個負載測試以及模擬服務斷供 Stackdriver Monitoring 提供性能, 運行時間, 以及雲端執行應用的健康度的資訊。 Stackdriver 從 Google Cloud Platform, Amazon Web Service, 被管理的運行時間探測, 應用儀表, 以及包含 Cassandra, Nginx, Apache Web Server, Elasticsearch, 等等的多樣的常用應用元件搜集指標, 事件, 以及中繼資料。Stackdriver 攝入這些資料, 進而經由顯示面板, 圖表, 以及警告輸出讓使用者可以更理解的資訊。 Stackdriver 的警告功能讓你更簡單地與 Slack, PagerDuty, HipChat, Campfire, 以及更多的應用做整合。 目標在本教程中, 你將會學習： 從一系列的範本啟動一個雲端服務 設定一個應用的基礎黑盒子監控 建立一個運行時間確認來發現喪失功能的服務 建立一個警告政策來觸發事件回應程序 建立以及設定顯示面板, 進而做到動態更新的圖表 給予應用負載, 進而測試監控以及警告規則 模擬一個服務中斷, 進而測試監控以及警告規則 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 **注意：** 按下左上方位於 `Google Cloud Platform` 隔壁的 `Navigation menu`, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個虛擬環境執行以下指令來下載以及安裝套件清單 sudo apt-get update Python 虛擬環境被使用來隔離系統內的套件安裝 sudo apt-get install virtualenv 如果 [Y/n] 彈出視窗, 按下 Enter virtualenv -p python3 venv 啟動虛擬環境 source venv/bin/activate 複製 Deployment Manager 範本Google 提供一組優秀的 Deployment 範本, 你可以從中學習並且在之上建立 在 Cloud Shell 輸入下面的指令來建立一個置放範本的資料夾, 並且複製範本 mkdir ~/dmsamples 到資料夾內 cd ~/dmsamples 複製範本 git clone https://github.com/GoogleCloudPlatform/deploymentmanager-samples.git 範例輸出: remote: Counting objects: 1917, done.remote: Compressing objects: 100% (31/31), done.remote: Total 1917 (delta 11), reused 29 (delta 7), pack-reused 1874Receiving objects: 100% (1917/1917), 426.86 KiB | 0 bytes/s, done.Resolving deltas: 100% (1060/1060), done. 探索範例檔案我們剛下載了一組範本到資料夾內, 讓我們更進一步地探索它們 列出範例範本執行以下指令來導向並且列出 version2 的範例： cd ~/dmsamples/deploymentmanager-samples/examples/v2 ls 你應該會看到輸出如下： access_context_manager cloud_functions common folder_creation iam_custom_role internal_lb_haproxy quick_start ssl vm_with_disksaccess_control cloudkms container_igm gke igm-updater metadata_from_file regional_igm step_by_step_guide vpn_auto_subnetbigtable cloud_router container_vm ha-service image_based_igm nodejs saltstack template_modules waiterbuild_configuration cloudsql custom_machine_type htcondor instance_pool nodejs_l7 single_vm vlan_attachmentcloudbuild cloudsql_import dataproc iam internal_lb project_creation sqladmin vm_startup_script 不是所有的子資料夾都是獨立的專案。 例如說, 叫做 common 的資料夾含有會被使用在多個專案的範本。 如果你打算之後逐個研究, 使用 README 來當作導引吧。 nodejs 資料夾含有所有你在本教程中會需要的東西。 請注意這裡有 nodejs 資料夾以及 nodejs_17 資料夾, 使用 nodejs 列出並檢視 Nodejs deployment導向並列出 version2 範例： cd nodejs/python ls 範例輸出： frontend.py frontend.py.schema nodejs.py nodejs.py.schema nodejs.yaml Deployment Manager 主要的設定檔是 nodejs.yaml 。 它使用了範本來產生基礎設施。 其他的檔案是範本。 範本使用了被定義在 nodejs.yaml 檔案中的變數來產生自訂義的結果。 frontend.pyfrontend.py 包含 frontend.py.schema, 它依據 container_instance_template.y 建立了一個 instance 範本。 這個範本被用來建立一個 managed instance group 以及一個 autoscaler 。 範本也建立了一個含有單一公開 IP 轉發規則的負載平衡器。 它也將建立： 一個指向 managed instance group 的 target pool 附加在 target pool 的健康檢查 nodejs.pynodejs.py 包含 nodejs.py.schema, 他帶來了前端以及後端的範本。 注意, 前端的是 frontend.py 後端是 /common/python/container_vm.py 這是一個運行著 MySQL Docker 容器的 VM, 所以他不需要客制範本 其他檔案 /common/python/container_instance_template.py /common/python/container_vm.py /common/python/container_helper.py 客制 Deployment現在你已經下載了, 也檢視過了 nodejs Deployment Manager 範本, 讓我們開始來客制 deployment 指定 zonenodejs.yaml 需要輸入一個 zone, 讓我們加一個 輸入以下指令來打開 zone 列表： gcloud compute zones list 複製 zone 的名字, 在設定檔會用到 用 vim 打開 nodejs.yaml, 所以你可以編輯 zone 值vim nodejs.yaml nodejs.yaml 檔案包含 resources:- name: nodejs type: nodejs.py properties: zone: ZONE_TO_RUN 將 ZONE_TO_RUN 更換成靠近你的地區, 然後退出 vim 並儲存檔案 這個範例顯示 ZONE_TO_RUN 設定成 us-east1-d resources:- name: nodejs type: nodejs.py properties: zone: us-east1-d 修改 instance group 中的最大 instance 數量編輯 nodejs.py 檔案 使用 vim 打開 nodejs.py vim nodejs.py 在 nodejs.py 檔案中, 核對 frontend 的擴充限制 &#123; &#x27;name&#x27;: frontend, &#x27;type&#x27;: &#x27;frontend.py&#x27;, &#x27;properties&#x27;: &#123; &#x27;zone&#x27;: context.properties[&#x27;zone&#x27;], &#x27;dockerImage&#x27;: &#x27;gcr.io/deployment-manager-examples/nodejsservice&#x27;, &#x27;port&#x27;: application_port, # Define the variables that are exposed to container as env variables. &#x27;dockerEnv&#x27;: &#123; &#x27;SEVEN_SERVICE_MYSQL_PORT&#x27;: mysql_port, &#x27;SEVEN_SERVICE_PROXY_HOST&#x27;: &#x27;$(ref.&#x27; + backend + &#x27;.networkInterfaces[0].networkIP)&#x27; &#125;, # If left out will default to 1 &#x27;size&#x27;: 2, # If left out will default to 1 &#x27;maxSize&#x27;: 20 &#125; &#125;, 目前的擴充限制是 20 (參考 maxSize) 修改 maxSize 然後設成 4:&#123; &#x27;name&#x27;: frontend, &#x27;type&#x27;: &#x27;frontend.py&#x27;, &#x27;properties&#x27;: &#123; &#x27;zone&#x27;: context.properties[&#x27;zone&#x27;], &#x27;dockerImage&#x27;: &#x27;gcr.io/deployment-manager-examples/nodejsservice&#x27;, &#x27;port&#x27;: application_port, # Define the variables that are exposed to container as env variables. &#x27;dockerEnv&#x27;: &#123; &#x27;SEVEN_SERVICE_MYSQL_PORT&#x27;: mysql_port, &#x27;SEVEN_SERVICE_PROXY_HOST&#x27;: &#x27;$(ref.&#x27; + backend + &#x27;.networkInterfaces[0].networkIP)&#x27; &#125;, # If left out will default to 1 &#x27;size&#x27;: 2, # If left out will default to 1 &#x27;maxSize&#x27;: 4 &#125; &#125;, 儲存並離開 vim 執行應用現在你將使用 Deployment Manager 來部署並使他運行。 這將會建立基礎設施, 但是它不允許流量。 在 Deployment Manager 設定好基礎設施後, 你可以採用服務標籤。 部署應用輸入以下指令, 使用 nodejs.yaml 設定檔建立一個名為 advanced-configuration 的應用 gcloud deployment-manager deployments create advanced-configuration --config nodejs.yaml 輸出： The fingerprint of the deployment is PiYc6OsIFkWzQpCDklHvaA==Waiting for create [operation-1529913842103-56f72d31872d9-90070017-aec5761d]...done.Create operation operation-1529913842103-56f72d31872d9-90070017-aec5761d completed successfully.NAME TYPE STATE ERRORS INTENTadvanced-configuration-application-fw compute.v1.firewall COMPLETED []advanced-configuration-backend compute.v1.instance COMPLETED []advanced-configuration-frontend-as compute.v1.autoscaler COMPLETED []advanced-configuration-frontend-hc compute.v1.httpHealthCheck COMPLETED []advanced-configuration-frontend-igm compute.v1.instanceGroupManager COMPLETED []advanced-configuration-frontend-it compute.v1.instanceTemplate COMPLETED []advanced-configuration-frontend-lb compute.v1.forwardingRule COMPLETED []advanced-configuration-frontend-tp compute.v1.targetPool COMPLETED [] 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 確認 instance 的最大數量： 到 Compute Engine &gt; Instance groups 點擊 advanced-configuration-frontend-igm 點擊 Detail tab, 然後確認最大 instance 數量 你將看到它已經被設定成 4 確認應用正常運作中應用會需要幾分鐘啟動。 你可以從 Deployment Manager 的主控台 (Navigation menu &gt; Deployment Manager), 或從 Compute Engine 的主控台看到 instance (Navigation menu &gt; Compute Engine &gt; VM) 要確認應用正在運作中, 你將打開瀏覽器, 存取 port 8080, 然後檢視服務。 因為當 Deployment Manager 實作全球轉發規則時 (被指定在範本中), IP 會動態的被建立, 所以我們需要取得 IP 來測試應用是否正常 取得實作全球轉發規則的平衡負載 IP 在 Cloud Shell 輸入以下指令來取得轉發規則gcloud compute forwarding-rules list 範例輸出 在輸出中, IP_ADDRESS 就是轉發 IP 。 記得把他複製下來, 在本教程中你會使用它好幾次 http://&lt;your IP address&gt;:8080 類似如下圖, 你會看到一個空白頁面 服務要正常運作會需要幾分鐘。 如果你看到一個錯誤, 像是 404, 等兩分鐘再試一次。 現在, 從 IP 輸入紀錄訊息http://&lt;your forwarding IP address&gt;:8080/?msg=&lt;enter_a_message&gt; 將 enter_a_message 更換為任何一段訊息 下面是記錄訊息範例 - 你的 IP 會跟它的不同 http://35.196.56.153:8080/?msg=my dog has spots 在你輸入紀錄之後, 瀏覽器回返回 added 到 http://&lt;your IP address&gt;:8080 來檢視紀錄。 例如： 繼續建立更多的訊息記錄, 然後到 http://&lt;your IP address&gt;:8080 來檢視他們 建立 Stackdriver 工作區在 Navigation menu, 點擊 Monitoring 當你看到 Stackdriver 顯示面板時, 你的工作區已經準備就緒了。 在 Stackdriver 設定一個運行時間確認以及警告政策現在 Stackdriver 已經在運行中了, 你經設定警告以及顯示面板 設定運行時間確認 在 Stackdriver 視窗, 點擊 **Uptime Checks &gt; Uptime Checks Overview 。 點擊 Add Uptime Check 指定數值如下： 點擊 Test 來測試這個確認 如果測試失敗, 確認服務正常運作中, 且防火牆規則正確且存在。 測試成功後, 點擊 Save 在儲存 Uptime Check 之後, Stackdriver 提供建立一個警告政策的選項 設定警告政策以及通知 點擊 Create Alerting Policy 為政策取名, 點擊 Save 在 Notification 選擇 “email”, 以及加入你的個人 email 在之後的步驟, 你將會觸發事件, 事件會經由 email 來通知你 為政策取名 點擊 Save 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 在顯示面板設定幾個有用的圖表設定顯示面板 在 Stackdriver 視窗, 點擊 Dashboards &gt; Create Dashboard 點擊 Untitled Dashboard, 然後更名為 DMDash 點擊 Auto Refresh 圖案, 所以變更會自動顯示 點擊 Add Chart 設定圖表如下： 點擊 Save 點擊 Add Chart, 使用以下屬性, 增加另一個圖表到顯示面板: 點擊 Save, DMDash 看起來應該如下： 建立設有 ApacheBench 的測試 VM現在, 你已經在指定的地區, 設定一個針對流量的監控, 看看有沒有正常運作。 你將安裝並且使用 ApacheBench 來施加三種等級的負載到你的服務, 然後從你已經設定好的 Stackdriver 顯示面板來檢視 建立一台 VM 在 Cloud Console, 點擊 Compute Engine &gt; VM instances 點擊 Create Instance, 在 Create an instance 對話框, 使用所有的預設設定。 點擊 Create 安裝 ApacheBench 還是在 VM Instance 視窗, 點擊 instance-1 的 SSH 按鈕來 SSH 連線到你剛剛建立的 VM 輸入以下指令來安裝最新版的 ApacheBench: sudo apt-get update sudo apt-get -y install apache2-utils 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 施加負載以及監控現在你將使用 ApacheBench 來施加負載到你的服務。 檢視 Stackdriver 的 DMDash 顯示面板來監控 CPU 使用率以及 Network Inbound Traffic 。 你也將能夠藉由將滑鼠移到線上來追蹤 instance 的數量, 或者到 Cloud 主控台 (Navigation menu &gt; Compute Engine &gt; VM) 在 SSH 視窗, 輸入這個指令讓 ApacheBench 來施加負載到服務。 將 Your_IP 替換成你的轉發 IP 。 執行以下的指令兩到三次來創造流量。 ab -n 1000 -c 100 http://&lt;Your_IP&gt;:8080/ 範例輸出 This is ApacheBench, Version 2.3 &lt;$Revision: 1757674 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking 35.196.195.26 (be patient)Completed 100 requestsCompleted 200 requestsCompleted 300 requestsCompleted 400 requestsCompleted 500 requestsCompleted 600 requestsCompleted 700 requestsCompleted 800 requestsCompleted 900 requestsCompleted 1000 requestsFinished 1000 requestsServer Software:Server Hostname: 35.196.195.26Server Port: 8080Document Path: /Document Length: 40 bytesConcurrency Level: 100Time taken for tests: 0.824 secondsComplete requests: 1000Failed requests: 0Total transferred: 140000 bytesHTML transferred: 40000 bytesRequests per second: 1213.57 [#/sec] (mean)Time per request: 82.402 [ms] (mean)Time per request: 0.824 [ms] (mean, across all concurrent requests)Transfer rate: 165.92 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 36 37 0.5 37 40Processing: 36 43 8.7 38 73Waiting: 36 43 8.7 38 73Total: 73 80 9.1 75 112Percentage of the requests served within a certain time (ms) 50% 75 66% 78 75% 81 80% 84 90% 95 95% 101 98% 106 99% 110 100% 112 (longest request) 等幾分鐘, 然後將負載提升到 5000 執行以下的指令兩到三次來創造流量。 ab -n 5000 -c 100 http://&lt;Your_IP&gt;:8080/ 等幾分鐘, 將負載提升到 10000 執行以下的指令兩到三次來創造流量。ab -n 10000 -c 100 http://&lt;Your_IP&gt;:8080/ 現在讓我們來看看, 當我們降低每台 instance 的 CPU 使用率時, 會發生什麼事 在 cloud 主控台, 點擊 Navigation menu &gt; Compute Engine &gt; Instance group 點擊你的 instance group 名稱, 然後 “Edit Group” 將 Target CPU usage 變更為 20 點擊 Save target CPU usage 是在這一個 instance group 當中的每一台 VM 的總使用率。 它控制何時自動擴充啟動。 在正式生產環境中, 通常你至少會設定 60% 。 在這個案例中, 你將會暫時性地將它設定成 20% 來更快地檢視自動擴充行為 執行以下的指令兩到三次來創造流量。ab -n 10000 -c 100 http://&lt;Your_IP&gt;:8080/ 可預測的行為: 當負載消耗了超過 20% 的群組累積 CPU, 將觸發自動擴充。 一個新的 instance 會被建立 現在看看當你把自動擴充關閉後, 會發生什麼事 到 Compute Engine &gt; Instance groups 點擊你的 instance group 名稱, 點擊 Edit Group 將 Autoscaling 變更為 Off 點擊 Save 等幾分鐘, 然後執行以下指令來創造流量 ab -n 10000 -c 100 http://&lt;Your_IP&gt;:8080/ 可預測的行為: 當 autoscaling 處於關閉狀態, 新的 instance 不會被建立, 所以累積 CPU 將會上升 結果Stackdriver 顯示面板大概會有五分鐘的延遲才會看到改變 模擬服務中斷移除防火牆規則來模擬服務中斷 點擊 Navigation menu &gt; VPC Network &gt; Firewall rules 勾選防火牆規則 allow-8080 旁邊的方格, 然後在頁面上方點擊 Delete 你將會在 15 到 30 分鐘後收到通知 email 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 恭喜你已經完成本教程！","link":"/zh-tw/deploymentManagerFullProduction/"},{"title":"Recursion (遞迴) - 不同類型的遞迴","text":"# 前言本文沒有 example, 主要為簡單介紹一下不同類型的遞迴 # Linear recursion (線性遞迴)這是最常被使用的 recursion 之一, 當一個 function 在每一輪都呼叫自己一次, 就稱為 linear recursion就像是之前介紹過的 factorial example, 當我們將大問題一步步的分解成小問題, 朝終點前進的這段過程, 又稱為 Winding (纏繞), 而從終點處一路 return 回來, 這段又稱為 Unwinding (解纏繞) # Binary recursion (二元遞迴)在 binary recursion 當中, function 每一輪都會呼叫自己兩次。 每一輪的結果來自兩個不同的 recursion 計算後而得之, 可以參考之前介紹過的 Fibonacci sequencebinary recursion 被使用在非常多的地方, 像是 binary search (二元搜尋), divide and conquer (分治法), merge sort (合併搜尋法) … 等。示意圖如下： # Tail recursion簡單來說, 就是當 recursion 跑到終點時, 不需要將終點得到的結果再反向的一路計算回來, 例如我們之前介紹過的 GCDTail recursion 也是 linear recursion 的一種 # Mutual recursion簡單來說, 就是交替式的呼叫兩個不同的 recursion method, 比方說, 這一輪呼叫 function B, 下一輪又呼叫 function A, 下一輪又回到 function B, 依序輪流的呼叫直到終點 # Nested recursion當一個 recursion function 呼叫了它自己, 並且 recursion function 的 args 之一也是這個 recursion function, 這樣就稱為 Nested recursion馬的怎麼有點像繞口令, 如下示意圖：在 A() 當中, A() 呼叫了 A(), 並且將 A() 當成參數帶入, 這樣就稱為 Nested recursion # 結語啊哈, recursion 種類介紹就到此結束啦, 接下來我們來介紹一些 recursion 應用實例我們下次見！ # Questions and Answers何謂 linear recursion?recursion method 在每一輪都呼叫自己一次, 直到終點 recursion 中, 朝向終點的遞迴過程又稱為？winding (纏繞) recursion 中, 從終點返回計算的過程又稱為unwinding (解纏繞) 何謂 binary recursion?在 binary recursion 當中, function 每一輪都會呼叫自己兩次。 每一輪的結果來自兩個不同的 recursion 計算後而得之 何謂 Tail recursion?簡單來說, 就是當 recursion 跑到終點時, 不需要將終點得到的結果再反向的一路計算回來 &lt;?phpfunction gcd(int $a, int $b): int &#123; if ($b == 0) &#123; return $a; &#125; else &#123; return gcd($b, $a % $b); &#125; &#125; 何謂 Mutual recursion簡單來說, 就是交替式的呼叫兩個不同的 recursion method, 比方說, 這一輪呼叫 function B, 下一輪又呼叫 function A, 下一輪又回到 function B, 依序輪流的呼叫直到終點 何謂 Nested recursion當一個 recursion function 呼叫了它自己, 並且 recursion function 的 args 之一也是這個 recursion function, 這樣就稱為 Nested recursion","link":"/zh-tw/different-types-of-recursions/"},{"title":"Docker 技術筆記","text":"前言這是一份未整理過的 Docker 學習筆記 環境GCP - ubuntu 18.04 安裝移除舊版本sudo apt-get remove docker docker-engine docker.io containerd runc 安裝前設定更新 aptsudo apt-get update 使 apt 可以經由 HTTPS 使用倉庫 安裝以下套件，使 apt 可以經由 HTTPS 使用倉庫sudo apt-get install -y \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 增加 Docker 的正式 GPG 密鑰curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 核對一下我們現在擁有含有 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 指印的密鑰，我們可以搜尋最後八碼 sudo apt-key fingerprint 0EBFCD88 理應得到輸出如下： pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;sub rsa4096 2017-02-22 [S] 設定 Docker 倉庫版本 將 Docker 倉庫 設定為 stable 版，若要設定為 nightly 或 test 版，可在以下的指令中自由取代 stablesudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 安裝 Docker 安裝最新的 Docker CE 版本 sudo apt-get install docker-ce docker-ce-cli containerd.io -y 你也可以安裝特定版本的 Docker: 列出版本 apt-cache madison docker-ce 應該會得到輸出如下： docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 18.06.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages ... 使用上面輸出的第二欄位版本號，結合下面的指令來安裝特定版本 sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io 運行鏡像 hello-world 來驗證 Docker CE 是否已經正確安裝 sudo docker run hello-world 如果要使用非 root 身份運行 Docker 的話，可以把你的使用者加到 Docker 群組 sudo usermod -aG docker your-user 解除安裝 解除安裝 Docker CE sudo apt-get purge docker-ce 刪除所有的 image, containers, volumes, 可以使用以下指令。慎用！此指令適合解除安裝後使用。 sudo rm -rf /var/lib/docker/ docker 列出 Docker 的指令docker docker version 查看 Docker 版本docker version Docker info 查看 Docker 完美安裝資訊docker info docker network列出 networkdocker network ls 查看 networkdocker network inspect networkName 建立 networkdocker network create -d driverType networkName docker volume列出 volume 清單docker volume ls 列出特定 volume 訊息docker volume inspect volumeName 刪除 volumedocker volume rm volumeName 清除所有未掛載的 volumedocker volume prune docker container exec以 root 登入容器docker exec -it --user root &lt;container id&gt; /bin/bash 連接還在運行中的 containerdocker container exec -it yourContainerIDOrContainerName bash exec 在運行中的 container 中運行一個新的程序 docker cp傳檔案進 containerdocker cp file containerName:/location 確認 Docker daemon 運行狀況service docker status systemctl is-active docker Docker container run運行 containerdocker container run -it ubuntu:latest /bin/bash Docker container run 告訴 Docker daemon 開始一個新的 container -i 告訴 Docker daeman 讓 container 可以互動 -t 使目前的 terminal 視窗連接 container 的 shell ubuntu:latest 為開始這個 container 的 image /bin/bash 指定了我們想要運行 container 裡頭的哪一個程序 docker container run -d \\--name web1 \\ -p 8080:8080 \\test:latest -d 表示讓 container 運行在背景 ， 與 -it 相反，無法共存--name 指定 container 的名稱-p 指定 port ， 左邊的是外部可以從瀏覽器存取的 port ，右邊的是 container 向外暴露的 port 架設一個私有倉庫docker run -d -p 5000:5000 registry 我們也可以將上傳的映像檔備份一份到容器外docker run -d -p 5000:5000 -v outsideAddress:insideAddress registry 備份容器的 volume 比方說, 先建立一個容器叫做 dbstore, 並且內建一個匿名 volume, 掛在容器內的 /dbdata 位址 docker run -v /dbdata --name dbstore ubuntu /bin/bash 接下來, 備份的步驟如下： 建立一個新容器, 並且掛載 dbstore 上的 volume, 下面指令中的 --volumes-from 達成這一項 將本機的一個資料夾掛到容器中的 /backup, 下面指令中的 -v $(pwd):/backup 達成這一項 接下來, 我們要把從 dbstore 掛載過來的, 容器內的 /dbdata 資料夾備份到容器外, 下面指令中的 tar cvf /backup/backup.tar /dbdata 達成這一項 當備份完成後, 該容器內沒有其他執行的任務, 所以該容器關閉, --rm 會讓關閉後的容器自行銷毀 docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata 掛載一個 volumedocker run -d --name mysql2 -v mysql:/var/lib/mysql -p 3310:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql:5.7 -v: 外部建立一個 volume 叫做 mysql, 並且掛載到容器內部的 /var/lib/mysql 位置-p: 映射內外 port-e: 環境變數-d: 背景執行 連接到一個指定的容器docker run --name test2 --link test1 -d busybox /bin/sh -c &quot;while true; do echo hello; sleep 10; done&quot; 指定一個 networkdocker run --name test3 --network demo -d busybox /bin/bash --network: 指定連接到 demo network 與該 container 共享網路docker run --name test3 --network container:test2 -d busybox /bin/bash docker system查看 Docker 真實系統佔用空間 docker system df 離開 container 但不關掉它CTRL + PQ docker container ls 列出運行中的 container docker container ls 列出所有的 container ， 包含已停止的 docker container ls -a or docker ps -a docker container stop 停止 containerdocker container stop containerIdOrContainerName docker container start 重新開始停止中的 containerdocker container start containerName docker rm 刪除 container docker rm containerID 刪除所有的 container docker rm $(docker container ls -aq) -f docker commit 將現有的 container 存成一個新的 imagedocker commit -m &#x27;imageMessage&#x27; -a &#x27;AuthorName&#x27; containerSHA imageName:imageTag Multi Stage (多階段構建) Multi Stage Build 範本# 給予該層一個名字, storefrontFROM node:latest AS storefront# 指定目前工作目錄WORKDIR /usr/src/atsea/app/react-app# 複製 context 中的 react-app 到當前目錄, 即上一行指令的 react-appCOPY react-app .# 執行 npm installRUN npm install# 執行 npm run buildRUN npm run build# 給予該層一個名字, 即 appserverFROM maven:latest AS appserver# 指定目前的工作目錄, 即 /usr/src/atseaWORKDIR /usr/src/atsea# 複製 context 中的 pom.xml 到當前位置, 即 atseaCOPY pom.xml .# 執行以下指令RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency:resolve# 複製 context 中的所有檔案到容器內的當前目錄下, 即 atseaCOPY . .# 執行以下指令RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests# 該是最終鏡像了, 沒給 aliasFROM java:8-jdk-alpine# 執行以下命令RUN adduser -Dh /home/gordon gordon# 指令當前工作目錄WORKDIR /static# 從上面建構 storefront 中, 複製 /usr/src/atsea/app/react-app/build/ 當中的所有資料到當前工作目錄, 即 /staticCOPY --from=storefront /usr/src/atsea/app/react-app/build/ .# 指令當前工作目錄, 即 /appWORKDIR /app# 從上面建構的 appserver 中, 複製 /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar 到當前工作目錄, 即 appserverCOPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .# 指令 ENTRYPOINT, 該命令為容器啟動後默認一定會執行的命令, 無法被替換ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app/AtSea-0.0.1-SNAPSHOT.jar&quot;]# CMD 在這個位置的角色為上面的 ENTRYPOINT 的 flag, 若在容器啟動指令輸入其他命令, 該 CMD 將會被替換掉CMD [&quot;--spring.profiles.active=postgres&quot;] -t 用來指定 image 的名字-f 可以用來指定名稱不是 Dockfile 的 DockerfileFrom 指定基礎 image 來源RUN 可以在 image 內執行 command 並建立新的 layer ，每一個 RUN 都會建立一層 layerCOPY 可以增加複製檔案到你的 image 內EXPOSE 暴露 APP 用的 portENTRYPOINT 設定當 image 被啟動為一個 container 時，預設執行的指令 Docker image pull 拉下 image docker image pull ubuntu:latest 根據 digests 拉下 image docker image pull imageNane@sha256:specificDigests docker image ls 列出下載過的 image docker image ls 列出下載過的 image 以及 digest docker image ls --digests docker rmi 刪除 image docker rmi imageID 刪除所有的 image docker image rm $(docker image ls -q) -f docker build 建立 image docker image build -t imageName:tagName . docker image inspect 列出一個 image 的結構docker image inspect inamgeID docker save 將 image 存成映像檔docker save -o outputFileName imageName:imageTag -o 代表 output docker logs 查 logdocker logs -f containerID Docker push 首先， tag 本地的 image 一個可以用來推上 DockerHub 的名字 docker tag localImageName:localTagName userAccount/toBeTaggedImageName:toBeTaggedImageTagName 推上 DockerHub docker push userAccount/taggedImageName:taggedImageTag Docker-Compose安裝 docker-compose 安裝 Docker Compose, 儘管我們可以從官方的 ubuntu 倉庫 安裝 Docker Compose ，但因為最新的版本中有很多細小的版本差異，所以我們從 Docker GitHub 來安裝。 先到官方頁面確認版本，並且視需求更新下面指令的版本號。 sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 設定權限 sudo chmod +x /usr/local/bin/docker-compose 確認 Docker-compose 版本 docker-compose --version 建立 yaml 檔案 vim docker-compose.yml 輸入內容如下： my-test:image: hello-world 建立一個 container docker-compose up 輸出理應如下： 建立一個 Swarm 開啟 docker swarm 模式docker swarm init \\--advertise-addr 0.0.0.1:8080 \\--listen-addr 0.0.0.1:8080 上面的 IP 跟 PORT 自己訂的--advertise-addr: 指定別的節點要連接這個 manager 時該使用的 IP 以及 port。這不是個必要的選項，但是你可以對哪個 IP 被使用有完全的控制權，並且你也可以訂一個不存在於節點上的 IP ，像是負載平衡的 IP --listen-addr: 讓你可以指定用來聽 swarm traffic 的 IP 以及 port ，通常他會跟 --advertise-addr 相同，但如果你想要限制 swarm 在特定的 IP，就特別有用。 還有一種情況，當 advertise-addr 是一個遠端的 IP ，像是平衡負載器，那這個也是必要的。 建議總是使用兩個附加選項。 從一個 node 開始 swarm mode ，並且設為 leader docker swarm init \\--advertise-addr yourInternalIP:yourPort \\--listen-addr yourInternalIP:yourPort 取得新增 manager 的 token docker swarm join-token manager 輸出大概如下： docker swarm join \\token SWMTKN-1-0uahebax...c87tu8dx2c \\10.0.0.1:2377 取得新增 worker 的 tokendocker swarm join-token token 輸出大概如下： docker swarm join \\token SWMTKN-1-0uahebax...c87tu8dx2c \\10.0.0.1:2377 重新產生 token docker swarm join-token --rotate managerOrWorker 開啟並且登入一台新的 instance ， 輸入上面的 token 還有自己的 IP 位址 docker swarm join \\token SWMTKN-1-0uahebax...c87tu8dx2c \\10.0.0.1:2377 \\advertise-addr yourInternalIP:yourPort \\listen-addr yourInternalIP:yourPort 不管你是想加入成為 manager 或是 workder ，只要輸入相對應的 token 就可以加入。 在 Leader 的 node 上可以查看 swarm 的詳細資料 docker swarm node ls 離開當前的 swarm docker swarm leave --force 開啟一個 SERVICE 要開立 service 首先必須確定， swarm 已建立。docker service create --name web-fe \\-p 8080:8080 \\--replicas 5 \\nigelpoulton/pluralsight-docker-ci docker service create: 建立一個 service--name: 指定 service 的名稱-p: 指定 container 內以及連接外部的 port--replicas: 在這個服務內，至少要有 5 個 containernigelpoulton/pluralsight-docker-ci: image 以及 tag 開立 service 之後， swarm 會一直的監看真實的狀態是否跟我的理想的狀態一致，如果一致的話那很好，如果不， swarm 會採取相對應的動作。舉例來說，如果五個 container 裡面有一個關閉了， swarm 會自動在啟動一個 查看 service 清單 docker service ls 查看 service 內的任務狀態 docker service ps serviceName 更詳盡的資訊 docker service inspect --pretty serviceName 擴展規模 docker service scale web-fe=10 刪除 service docker service rm web-fe 建立一個 overlay network docker network create -d overlay uber-net 連接到相同 overlay network 的 container ， 儘管他們的 docker host 連接的網路不同，彼此也可以互相溝通連接。 列出 network 資料 docker network ls 刪除一個 network docker network rm networkName 依據指定的 network 建立一個新的服務 docker service create --name uber-svc \\--network uber-net \\-p 80:80 --replicas 12 \\nigelpoulton/tu-demo:v1 --network: 指定 network 滾動升級 rolling update 滾動升級運行中的服務 docker service update \\--image nigelpoulton/tu-demo:v2 \\--update-parallelism 2 \\--update-delay 20s uber-svc docker service update: 升級 service--image: 升級的 image 來源--update-parallelism 2: 一次升級兩個 container--update-delay 20s uber-svc: 每批次的等待時間為 20 秒 ， 需等當前批次的升級完成，時間才會開始計算。 最後指定要升級的 service 名稱 查看上次升級的參數 docker service inspect --pretty serviceName 如上圖，前一次升級的參數都會被保留下來，除非你再次升級去覆蓋它 Composer 利用 container 安裝 Composer docker run --rm -v $(pwd):/app composer install --rm: 當 container 關閉後，自動刪除-v: 使用 volumes$(pwd):/app: $(pwd) 表示當前資料夾, /app 表示 container 裡頭一個叫做 app 的資料夾, 所以這個指令代表 : 前後的兩個資料夾會在 container 關閉之前，同步所有資料composer install: 安裝 composer 所以這個指令實際上做的事情，就是從 Docker Hub 拉下官方的 composer image ，然後開啟一個 container 並執行安裝， composer 會依照資料夾內 composer.json 或 composer.lock 來安裝相對應的 package 。 package 會被安裝在 app 這個資料夾內，但因為 volumes 的關係，所以兩個資料夾會同步， $(pwd) 內也會有安裝的 package 。 當安裝結束後， container 關閉，因為 --rm 的作用， container 會自動刪除。 利用 Docker-compose 部署 Laravel安裝 docker-compose 環境為 Ubuntu 18.04 安裝 Docker Compose, 儘管我們可以從官方的 ubuntu 倉庫 安裝 Docker Compose ，但因為最新的版本中有很多細小的版本差異，所以我們從 Docker GitHub 來安裝。 先到官方頁面確認版本，並且視需求更新下面指令的版本號。 sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 設定權限sudo chmod +x /usr/local/bin/docker-compose 利用 Docker 來安裝環境MySQL 安裝 MySQL ， 並指定連接一個外部不同的 port 號 ， 像是 52000 docker run --name serviceName -e MYSQL_ROOT_PASSWORD=yourPassword -d -p 52000:3306 mysql:5.7 docker run: 啟動一個 container--name: 指定這個服務的名稱-e MYSQL_ROOT_PASSWORD: 指定環境參數-d: 使這個服務跑在 container 當中-p: 指定外跟內的 port 號， container 內部的 3306 連接外部的 52000mysql:5.7: 指定 image 以及 tag 連接本地安裝的 MySQL 以及 Docker container 內的 MySQL 本地安裝的 sudo mysql -uroot Docker Container mysql -h 127.0.0.1 -uroot -p2434 -P52000 製作 Docker image 時區問題我的第一個目標，是利用 Docker commit 來做一個專屬的 image。簡單來說，就是起一個純淨的 container ，然後在這個 container 裡頭部署完之後，再使用 docker commit 將這個 container 變成一個 image ， 結果發現在安裝 php7.2-imagick 中會出現 Configuring tzdata ，會彈出一個視窗並要求選擇時區，如下圖 後來找到解決方法，是在安裝 php7.2-imagick 之前就把時區設定好，所以在一開始就加入 export DEBIAN_FRONTEND=noninteractive &amp;&amp; apt-get install -y tzdata &amp;&amp; ln -fs /usr/share/zoneinfo/Asia/Taipei /etc/localtime &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata MySQL 問題接下來，又遇到一個問題，在我利用我製作好的 image 開一個 container 時， MySQL 無法成功啟動，會一直出現 Failed後來的解決方法非常的奇怪，我是到 /var/www/mysql/mysql 中，下 chown -R mysql:mysql . 的指令，然後它就好了…可問題是，我仔細地確認過，在我下這指令之前，這個資料夾下的所有 user 以及 group 早就已經是 mysql:mysql 了 Apache 以及 MySQL 無法設定自動重啟的問題 所以我們必須要在 container 裏頭啟動這些服務，需要啟動的服務如下： Apache MySQL 所以從目前的進度看來， container 啟動之後，我們必須要執行三個指令，如下： chown -R mysql:mysql /var/www/mysql/mysqlservice apache restartservice mysql restart 沒想到實際執行之後，我們遇到了一個新的問題… Container 自動退出的問題Container 的特性，是只要 command 執行完畢後，就會自動退出。 container 一旦退出了，我們原本建構的環境當然也就不在了。我們怎麼可以容許這種事情發生呢？因此，我們需要給 container 一個會一直持續存在的指令，好比是 /bin/bash 該怎麼樣讓 container 在啟動的時候又執行多個指令呢？在 container 啟動時， 我們需要執行多個指令來啟動 container 裡面的服務，但是 entrypoint 只能帶一個指令進去，所以我們要寫一個 shell script ，然後當 container 開啟之後去執行這個 shell script ，當然，這個 shell script 裡頭的指令就是上述提到的指令，如下： chown -R mysql:mysql /var/www/mysql/mysqlservice apache2 restartservice mysql restart/bin/bash 假設這個 shell script 叫做 test.sh ，然後放在 /usr/sbin/ 之下，那我們的 docker 指令如下： docker run -dt --entrypoint &quot;/usr/sbin/test.sh&quot; -p 8880:80 --name containerName yourAccount/imageName:tagName ENV man 指令Docker 為了縮小 image 大小，預設不產生 man 說明文件。 在安裝 man 以及 man-pages 之前，需要先將此設定改掉 修改設定Docker 為了縮小 image 大小，預設不產生 man 說明文件。 在安裝 man 以及 man-pages 之前，需要先將此設定改掉vi /etc/yum.conf 將以下這行 comment 掉 tsflags=nodocs 安裝 yum install man-pages -y; yum install man -y 更新 mandb mandb 安裝 vim 套件測試 yum install vim 測試 man vim 可以用了 Q &amp; A 當執行 Docker build 時, 如果不想要 context 中的某些資料夾或檔案被上傳到 docker daemon 去, 可以怎麼做？ 建立一個 dockerignore 檔案, 並將不想上傳的檔案或資料夾加進去 如果不想使用預設的 dockerfile, 可以怎麼做？ docker -t -f dockerFileNameYouWant . 在 Docker CLI, 哪一個 flag 可以指定環境變數？ -e 在 Docker CLI, 哪一個 MYSQL 的 flag 可以允許空的密碼？ -e MYSQL_ALLOW_EMPTY_PASSWORD=yes 在 Docker CLI, 哪一個 flag 可以指定 volume？ -v 如何列出 volume 清單？ docker volume ls 如何列出指定 volume 訊息？ docker volume inspect volumeName Docker 中, 預設的網路模式是？ Bridge 可透過何種方式證明 Docker 預設容器可互聯互通？ 在容器內取得 ip, 並使用 ping 當使用 –link 來連接到一個容器時, 實際上容器做了什麼事, 讓我們可以直接使用名字連接？ Docker 在 /etc/hosts 裡頭將 IP 以及該容器名稱做連結 Docker 當中, --link 是單向還是雙向的？ 單向 Docker 當中, --network 是單向還是雙向的？ 雙向 docker –network host 只在哪一個 OS 上有用 Linux docker –network container 的效果? 與指定的 container 共用網路 docker –network host 的效果? 與當前宿主機同網路, 換言之, 不需 port binding docker –network none 的效果？ 不為容器配置任何網路 以下的 Docker command 會輸出什麼？ Hello, Cloud Man 。 環境變量 name 已經被值 Cloud Man 替換掉了 ENV name Cloud ManENTRYPOINT echo &quot;Hello, $name&quot; 以下的 Docker command 會輸出什麼？ Hello, $name 。 環境變量沒有被替換 ENV name Cloud Man ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;] 以下的 Docker command 中, 如果要使輸出使用環境變量, 該怎麼修改？ 在 /bin/echo 跟 Hello, $name 之間新增 command -c ENV name Cloud Man ENTRYPOINT [&quot;/bin/echo&quot;, &quot;Hello, $name&quot;] Docker 中, apt-get update 和 apt-get install 建議放在同一個 RUN 指令中執行, 為什麼？ Docker 會使用 Cache 如果指令沒有改變的話。 要是將這兩個指令分開了, 當執行到 apt-get update 時, 由於指令沒有變更, 所以 docker 使用緩存, 但是 apt-get install 這層的指令變了, 可能會變成使用很久之前的緩存來安裝新的套件的情況, 這樣就找不到套件了。 Docker 中, CMD 允許被使用者替換嗎？ 允許 Docker 中, 如果 CMD 已有設定, 但 docker run 之後沒有指令命令, 那 container 會執行哪一個命令？ CMD 如果 Dockerfile 中有多個 CMD, 哪一個為準？ 只有最後一個 CMD 有效 CMD 有幾種格式？ 三種 CMD 有哪三種格式？ exec, shell, CMD [“param1”, “param2”] 在 Docker image 中, CMD 設定為 [“/bin/echo”, “Hello World”], 執行 docker run -it [image] /bin/bash 時, 會怎麼樣？ 會只執行 /bin/bash Docker 中, ENTRYPOINT 有幾種格式？ 兩種？ Docker 中, ENTRYPOINT 有哪兩種格式？ exec, shell Docker 中, ENTRYPOINT 的參數可以被動態替換掉嗎？ 不行 在 Docker image 中, ENTRYPOINT 的設定為 [“/bin/echo”, “Hello”], CMD 為[“world”], 當我執行容器 docker run -it [image], 輸出為？ Hello world 在 Docker image 中, ENTRYPOINT 的設定為 [“/bin/echo”, “Hello”], CMD 為[“world”], 當我執行容器 docker run -it [image] Ray, 輸出為？ Hello Ray 在 Docker image 中, ENTRYPOINT 為 shell 格式時, CMD 跟 docker run 的參數會？ 被無視 在 Dockerfile 中, 哪三個指令會增加新的層數？ RUN, ADD, COPY 在多階段構建中, 如何從指定層數 COPY 東西過來當層 藉由 AS 給該層一個名字, 然後使用 COPY --from NAME 在 Docker 中, 如何使用 ENV 來更新 PATH 環境變量？ 如下 ENV PATH /new/directory:$PATH 在 Docker 中, 當 COPY 的內容變了, 緩存是否會失效？ 會哦 使用 docker-compose 部署 Laravel-LEMP下載專案並安裝依賴 下載專案 git clone https://github.com/laravel/laravel.git laravel-app 進到資料夾 cd laravel-app 安裝依賴套件 -v 同步當層目錄與容器內的 /app 執行命令 composer install --rm 當容器關閉時, 自動刪除容器 容器建立時, 外頭的 laravel-app 會與容器內的 /app 同步, 這時候在容器內部的 /app 執行 composer install, 安裝在容器內部 /app 資料夾內的 composer 套件會即時的同步到外頭的 laravel-app 資料夾內。 執行完畢後, 容器沒有其餘的任務, 因此容器會關閉, --rm 會自動刪除容器 更多 docker composer 的應用可參考官方文件 docker run --rm -v $(pwd):/app composer install 更改權限sudo chown -R $USER:$USER ~/laravel-app 建立 Docker Compose 檔案 建立並打開 docker-compose 設定檔 vim ~/laravel-app/docker-compose.yml 在 docker-compose 檔案中, 你將會自定義三個服務： app, webserver, 以及 db 。 在檔案中輸入以下的代碼, 別忘了將 MY_SQL_ROOT_PASSWORD 替換成你自己的密碼 # 版本version: &#x27;3&#x27;services: #PHP Service app: # 這裡建構客製鏡像, Dockerfile 之後會提到 build: # 上下文目錄為當層 context: . # Dockerfile 為當層的 dockerfile dockerfile: Dockerfile # 客製化鏡像的名稱 image: digitalocean.com/php # 容器名稱, 若不指定也可, 但 docker 會用歷史名人命名 container_name: app # 若停止自動重啟 restart: unless-stopped # 為避免容器開啟後即關閉, 設定 tty: true tty: true # 環境變數 environment: SERVICE_NAME: app SERVICE_TAGS: dev # 當前工作目錄 working_dir: /var/www # 持久化數據 volumes: # 將當層目錄與容器內的 /var/www 同步 - ./:/var/www # 將當層目錄下的 php/local.ini 與容器內的 /usr/local/etc/php/conf.d/local.ini 同步 - ./php/local.ini:/usr/local/etc/php/conf.d/local.ini # 使用的網路為 app-network networks: - app-network #Nginx Service webserver: # 使用官方 nginx:alpine 鏡像 image: nginx:alpine # 容器名稱, 若不指定也可, 但 docker 會用歷史名人命名 container_name: webserver # 若停止自動重啟 restart: unless-stopped # 為避免容器開啟後即關閉, 設定 tty: true tty: true # 將容器內的 80, 443 port 跟宿主機的 80, 443 port 對接 ports: - &quot;80:80&quot; - &quot;443:443&quot; # 持久化數據 volumes: # 將當層目錄與容器內的 /var/www 同步 - ./:/var/www # 將當層目錄下的 nginx/conf.d/ 與容器內的 /etc/nginx/conf.d/ 目錄同步 - ./nginx/conf.d/:/etc/nginx/conf.d/ # 使用的網路為 app-network networks: - app-network #MySQL Service db: # 使用官方 mysql:5.7.22 鏡像 image: mysql:5.7.22 # 容器名稱, 若不指定也可, 但 docker 會用歷史名人命名 container_name: db # 若停止自動重啟 restart: unless-stopped # 為避免容器開啟後即關閉, 設定 tty: true tty: true # 將容器內的 3306 port 跟宿主機的 3306 port 對接 ports: - &quot;3306:3306&quot; # 設定環境變數 environment: # 資料庫名稱, 可自定義 MYSQL_DATABASE: laravel # 資料庫密碼, 可自定義 MYSQL_ROOT_PASSWORD: your_mysql_root_password SERVICE_TAGS: dev SERVICE_NAME: mysql # 持久化數據 volumes: # 將自定義的數據卷 dbdata 跟容器內的 /var/lib/mysql/ 目錄做同步 - dbdata:/var/lib/mysql/ # 將當層目錄下的 mysql/my.cnf 跟容器內的 /etc/mysql/my.cnf 做同步 - ./mysql/my.cnf:/etc/mysql/my.cnf # 使用的網路為 app-network networks: - app-network#Docker Networksnetworks: # 定義 network 名稱 app-network: # 定義 network driver 為 bridge, 還有其他類型如 host, none, container 等等... driver: bridge#Volumesvolumes: # 定義數據卷名稱 dbdata: # 定義數據卷類型 driver: local app: 運行 Laravel build 客制鏡像 digitalocean.com/php, 下面會有建立的 dockerfile 使用客製的鏡像 digitalocean.com/php, 將當前工作目錄設在了 /var/www webserver: 使用官方 nginx:aline 鏡像 將容器內的 80 以及 443 port 接到宿主機的 80 以及 443 port db: 使用官方 mysql:5.7.22 鏡像 定義一些環境變數, 包含資料庫名稱, 資料庫密碼, 這部分可以依個人需求更改 將容器內的 3306 接到宿主機的 3306 port 我們把容器名稱跟服務名稱定義成一樣, 如果我們不定義容器名稱, Docker 會自動使用歷史上有名的人物的名稱來命名 我們為不同容器群組定義了專屬的 network, 位於相同 network 下的容器可以互相溝通, 反之則不行, 這確保了高等級的安全性, 不同類型的容器群不可以互相溝通, 像是前端只能跟前端溝通, 後端跟後端 建立 Dockerfile# 使用官方 php:7.3-fpmFROM php:7.3-fpm# 複製 composer.lock 以及 composer.json 從上下文資料夾複製到鏡像內的 /var/www/COPY composer.lock composer.json /var/www/# 設定工作目錄為 /var/wwwWORKDIR /var/www# 安裝依賴# mariadb-clientRUN apt-get update &amp;&amp; apt-get install -y \\ build-essential \\ mariadb-client \\ mysql-client \\ libpng-dev \\ libjpeg62-turbo-dev \\ libfreetype6-dev \\ locales \\ zip \\ jpegoptim optipng pngquant gifsicle \\ vim \\ unzip \\ git \\ curl# 清除 /var/cache/apt/archives 下的所有 deb 檔, 以及清除 /var/lib/apt/lists/ 下的所有安裝檔RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*# 安裝 extensionsRUN docker-php-ext-install pdo_mysql mbstring zip exif pcntlRUN docker-php-ext-configure gd --with-gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ --with-png-dir=/usr/include/RUN docker-php-ext-install gd# Install composerRUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer# 建立 laravel 應用 user# 建立 group www 並指定 GID 為 1001RUN groupadd -g 1001 www# 建立 user www 並指定 UID 為 1001, 將之加入群組 wwwRUN useradd -u 1001 -ms /bin/bash -g www www# 複製檔案以及重新定義權限COPY --chown=www:www . /var/www# 將使用者切換到 wwwUSER www# 暴露 9000 portEXPOSE 9000# 執行 php-fpmCMD [&quot;php-fpm&quot;] PHP 設定檔現在我們需要建一個 PHP 設定檔來同步宿主機以及容器內 建立資料夾 mkdir ~/laravel-app/php 設定檔 vim ~/laravel-app/php/local.ini 設定檔內容範例, 你可以添加其他設定 # 單檔的最大上傳限制upload_max_filesize=40M# 整個 post 的最大限制post_max_size=40M Nginx 設定檔 建立資料夾 mkdir -p ~/laravel-app/nginx/conf.d 建立設定檔 vim ~/laravel-app/nginx/conf.d/app.conf 範例設定檔內容, 可視需求添加 server &#123; # 監聽 80 port listen 80; # 尋找 index.php index.html index index.php index.html; # error log 位置 error_log /var/log/nginx/error.log; # access log 位置 access_log /var/log/nginx/access.log; # 資源的默認位置 root /var/www/public; # 如果請求是 php 結尾的話, 進到 location location ~ \\.php$ &#123; # 尋找 uri, 若沒找到則 404 try_files $uri =404; # fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass app:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; &#125; location / &#123; try_files $uri $uri/ /index.php?$query_string; gzip_static on; &#125;&#125; 設定 MySQL 建立資料夾 mkdir ~/laravel-app/mysql 建立設定檔 vim ~/laravel-app/mysql/my.cnf 輸入設定檔內容, 可自行添加 [mysqld]# 產生 loggeneral_log = 1# log 位址general_log_file = /var/lib/mysql/general.log 運行容器以及修改 env 設定 建立 .env cp .env.example .env 運行容器 docker-compose up -d 查看容器 docker ps 修改 .env 檔 docker-compose exec app vim .env DB_CONNECTION=mysql# DB 容器服務DB_HOST=dbDB_PORT=3306# 上面設定的 databaseNameDB_DATABASE=laravel# 上面設定的 userNameDB_USERNAME=laraveluser# 上面設定的 passwordDB_PASSWORD=your_laravel_db_password 產生 key docker-compose exec app php artisan key:generate 開啟 cache","link":"/zh-tw/docker/"},{"title":"伸縮自如的 git flow","text":"前言今天將分享一個具有以下特性的 git flow: 在開發過程中，可以隨意 commit 測試完成後，即可將相對較友善於開發的 commit 轉換成正式上線標準的 commit 兩個分支檔案內容完全相同，但卻擁有完全不相干的 commit 歷史 以 Ray 來說，我在開發時，習慣畫流程圖，並且將我腦中覺得可行的邏輯一條條寫下來，然後實踐。 通常一個大功能可能會由好幾個邏輯組成，而這個 git flow 讓我可以在一個 feature 分支上，將我的每一個小邏輯都記錄下來，分成一個個 commit 。 最後確定沒有問題了，在轉換成正式上線時需要的大功能 commit 。在實踐這個 git flow 的過程中，我對 git rebase 的熟悉與日俱增，並且訓練自己以更嚴謹的方式來做每一個 commit。以下 Ray 個人覺得這個 git flow 可以帶來的好處： 因為 commit 很小，邏輯單一，不管是在實驗或是除錯方面，都有不可言諭的便利性。 利用小 commit 的方式將邏輯都記錄下來，一方面讓自己的思緒清晰，一方面讓每一個功能的邏輯清清楚楚。 看似複雜的流程，但其實熟悉之後，分支的整理只是一瞬間，可以在開發過程中更加的熟悉 Git 的進階操作。 因為 commit 很小，可以訓練較嚴謹的 commit 風格。 理想的 commit今天提出的 git flow 只是一個舉例，不一定適用於每一個人，但重點是在實現這個 git flow 所需要的概念！ 當我們在本地 commit 時，我們傾向這個 commit 可以越小越好，因為越小越純粹功能越單一的 commit ，不管是在 Debug ，或是邏輯實驗與印證都有不可言傳，只可意會的妙用！ 例如呢？讓我們具體一點! 當今天你在 Debug ，發現印出來的東西不如你的預期。你嘗試不同的方式來測試，直到印出的數據是你想要的！ 如果你的 commit 有符合上面的原則，在這個時候呢，在每一次失敗的嘗試之後，你不需要繁複的修修改改。你只需要簡單的 git reset --hard 就算你一個 commit 邏輯整個錯了，如果你的 commit 功能夠單一，要拿掉這個 commit ，你只需要 git reset @^ --hard 我們想要的是什麼？然而，正式上線的 git flow 不容許我們這樣做。正式上線的 git flow 通常會要求推上去的每一個 commit 都要’指定的功能正常’。意思可以理解說，如果要將 commit 最小化，那很有可能我們會需要多個最小化的 commit 來組成一個正式上線公司所需要的大功能。 需求整理 開發時： 我們需要隨時可以 commit 的靈活度，功能越單一越好 正式上線後： 我們需要每一個 commit 都符合公司指定的要求，功能正常 該選哪一種？人家說，魚與熊掌，不可兼得，真的是這樣嗎？可以兩種都要嗎？ 歸納具體需求那先來歸納一下，我們具體上，需要的東西 我們需要一支本地開發的 develop 分支，在這分支上，只要你爽，你想怎麼 commit 就怎麼 commit 我們需要一支正式要推上線的 master 分支，在這分支上，每個 commit 都代表著公司指定的功能 上面兩個分支，被 commit 的檔案內容是完全一樣 (選擇性)以上兩個分支我都要保留其各自獨特的歷史 具體看起來是？如下圖可以看到，左邊是檔案內容，右邊是 commit ，大家可以看到，在 develop branch 上，每個 small function 都對應到相應的檔案，這只是範例，表達我們所要的最小 commit 的概念。 master 分支:接下來，如下圖我們來看看實際上線時， commit 應該是什麼樣子。我們可以看到，在 master branch 上，我們只有4個 commit ，而每個 commit 都包含了4個檔案(除了 .gitignore 的 commit 之外)。這只是範例，表達正式上線時所需求的 commit 標準往往比我們理想的最小 commit 還要大。 範例連結 實作一切的起點通常 .gitignore 會是一切的起點！ 使用 vim 建立 .gitignore 檔案，然後輸入想要 ignore 的檔案，再按 :wq 離開。vim .gitignore 完成第一個 commitgit add .ignore; git commit -m &#x27;Added .gitignore&#x27;; develop 分支接下來，我們將以 master branch 為基礎，建立 develop branch ，如同前面敘述的， develop branch 上面的 commit 會是最細最小的，而 master branch 上的 commit 會是符合正式上線標準的。 首先，從已經設定好 .gitignore 的 master 分支為基礎，建立 develop 分支 git checkout -b develop feature 分支然後呢，我們要開始開發了！ 建立一個 feature 分支 這個 feature 分支代表當前正在開發的功能 這邊所說的功能，是依照正式上線的標準 所以，一個功能等於一個 feature 分支git checkout -b feature; 自由的 commit 在 feature branch 上，我們可以隨便 commit ，可以完全依照我們本身的 commit 習慣，把 commit 做到最細小，以享受在開發以及測試過程中帶來的方便 建立檔案1~4，然後每個檔案分別代表一個最細小的 committouch &#123;1..4&#125;;git add 1;git commit 1 -m &#x27;small function 1&#x27;;git add 2;git commit 2 -m &#x27;small function 2&#x27;;git add 3;git commit 3 -m &#x27;small function 3&#x27;;git add 4;git commit 4 -m &#x27;small function 4&#x27;; 功能完成了 在測試完成之後，確定沒有問題了！現在我們要把我們 commit 的標準轉換成正式上線的標準 如同前面提過的， feature branch 的開發範圍，是以正式上線的一個功能為單位 所以呢？我們要將一整個 feature branch ，濃縮成一個 commit 因為我們要保有兩個分支，所以我們不可以直接在 feature branch 幹這件事，因為 develop branch 會需要它！ 這邊特別說明一下，其實以這個 git flow 來說，開發過程中的 develop 分支不見得需要保留，但本篇範例會以如果你需要保留的狀況下來實作。如果開發用的 develop 不須保留的話，程序上會簡化很多。 用來 merged 的分支 為正式上線的 master branch 來建一個一次性的 toBeMerged branch git checkout -b toBeMerged 接下來，要把 toBeMerged branch 變成符合被 master branch merge 的狀態 git rebase -i master 壓縮、重新命名 commit 然後，我們剛剛有說過，我們要將多個開發流程中的最小 commit 壓縮成一個正式上線的 commit ，對吧？所以我們要將所有的 commit 往前壓縮，可以利用 fixup 這個選項，再來，正式上線的 commit 名稱肯定會跟我們開發時的 commit 名稱不同，所以這邊我們要重新命名這個壓縮後的 commit ，如下： reword 96c6c18 small function 1fixup 1dd84d2 small function 2fixup 1a71401 small function 3fixup f9c90c6 small function 4 接下來，我們將這個壓縮過後的 commit 命名為 big function 1 然後:wq存檔離開 此時使用git log來看看，看起來會像是下圖那樣 git log merge 讓我們回到 master 來把它 merge 掉吧！ git checkout master;git merge toBeMerged; 接下來，切到 develop ，並且 merge feature branch git checkout develop;git merge feature; 最後，把已經被 merge 完成的 feature branch 以及 toBeMerge branch 刪掉吧！ git branch -D feature toBeMerged 複習一下，還記得我們要的是什麼嗎？ 在 develop 分支上，是最小的 commit 在 master 分支上，是正式上線標準的 commit 兩個分支的檔案內容必須要一模一樣 (選擇性的)同時保有兩個分支 看看我們的現在的 master 分支是否跟我們要的一樣？ git checkout master;git log 看看檔案內容ls 看看 develop 分支的 commit git checkout develop;git tag &#x27;bigFunction1&#x27;git log 看看檔案內容 ls 第二階段 一樣的流程，建立 feature branch ，然後是 toBeMerge branch git checkout develop;git checkout -b feature;touch &#123;5..8&#125;;git add 5;git commit -m &#x27;small function 5&#x27;;git add 6;git commit -m &#x27;small function 6&#x27;;git add 7;git commit -m &#x27;small function 7&#x27;;git add 8;git commit -m &#x27;small function 8&#x27;;git checkout -b toBeMerged; 重點來了，這時我們不能使用傳統的 rebase 來改造 toBeMerged branch ，因為 toBeMerged branch 的歷史不曾存在於 master branch 。 讓我們想想，toBeMerged branch 應該要是什麼樣子才符合我們要的，適合被 master branch merge ？ 兩者要有共同的歷史(同sha1值) 先前已經被 merge 過的，未壓縮過的 commit 不可以重複出現。簡單來說， samll function 14 早就被壓縮成 big function 1 了，所以 small funciton 14 不可以再出現 master branch 上面沒有的內容，要壓縮成一個 commit 完成以上條件之後， toBeMerged branch 就可以被 master merge 了 第二次 rebase 與壓縮 所以具體該怎麼操作？ 我們將會使用到 git rebase 的進階應用 git rebase --onto 。我們 rebase toBeMerged branch 到 master branch 上，然後只要是 develop branch 上已經存在的 commit ，我們都不要，最後，將被 rebase 的 branch 叫做 toBeMerged，照這個順序往下排列，就成了以下的指令。 git rebase --onto 的用法，可以參考官方的文件 git rebase -i --onto master develop toBeMerged 然後同上，將最小的 commit 壓縮成一個正式上線的 commit reword 3668e72 small function 5fixup fd05fa1 small function 6fixup 3a87c08 small function 7fixup c38957e small function 8 壓縮後的 commit ，名稱為big function 2 重複之前步驟，該 merge 的 merge ，該刪的刪 來看看當前 develop 分支上的 commit 狀態，以及檔案內容 git checkout develop;git tag bigFunction2;git log --oneline develop 分支上的 commit ls develop 分支上的檔案內容 來看看當前 master 分支上的 commit 狀態，以及檔案內容 git checkout master;git log develop 分支上的 commit ls develop 分支上的檔案內容 總結此範例中的git flow，可以讓我們在開發過程中以最小的 commit 來進行，甚至是以任何我們喜歡的方式來進行，而不需因為正式上線的 commit 標準有所犧牲。過程看似複雜，看就 Ray 的使用經驗，如果相關原理都已經非常熟悉，其實指令輸入很快就完成了。範例中的 develop 分支不一定需要保留，因為日後若正式上線的 commit 有錯誤的話還是得從正式上線的 commit 來做修正，當然如果保留的話，應該還可以衍生一些其他的變化以及應用，這些就留待各位自己去發掘啦！若大家有任何想法歡迎在下面留言，我相信意見想法的交流是進步的捷徑。","link":"/zh-tw/flexibleGitFlow/"},{"title":"使用 vsftpd 在 GCP VM 上部署 FTP Server","text":"前言本篇將分享： vsftpd 的設定細節 建立一個特定的 FTP user 使用 gcloud command line 開啟相對應的防火牆 環境 GCP VM ubuntu 18.04 安裝 vsftpdsudo apt install vsftpd 設定檔 打開設定檔 sudo vim /etc/vsftpd.conf 設定參數如下： # 如果不想跑在預設的 21 port, 這個必須要打開listen=YES# 承上，如果 listen 為 yes, 這個必須是 NOlisten_ipv6=NO# 是否允許匿名者登入，預設是 NO。此例子中，我們只允許我們設定的 user 存取 server, 所以設定為 NOanonymous_enable=NO# 本篇目的是要建立一個特定使用者，並且只允許這位使用者登入，所以須為 YESlocal_enable=YES## 允許寫入的權限write_enable=YES# 該使用者的預設 umasklocal_umask=002# 在每個資料夾內，我們可以建一個檔名為 `.mssage` 的檔案，裡頭輸入訊息，當登入者進到這個資料夾實，就會顯示這則訊息dirmessage_enable=YES# 使用當地時間use_localtime=YES# 當登入者上傳或下載檔案時，都將之記錄下來xferlog_enable=YES# 檔案傳輸的 port 為 20, 我們用被動模式, 所以選 NOconnect_from_port_20=NO# 啟用被動模式pasv_enable=YES# xferlog 的位置，可以更改xferlog_file=/var/log/vsftpd.log# 是否使用正式格式。 選擇 NO 的話會比較易讀，但若有使用 log 分析軟體，建議選 YESxferlog_std_format=YES# 當使用者登入時，會顯示的歡迎訊息ftpd_banner=&quot;Welcome to QCDN&#x27;s FTP server, feel free to upload whatever you would like to deploy on Website.&quot;# chroot 意思就是 change root，是否要將使用者預設就限制在自己的根目錄內，為了安全性考量，此選項建議打開, 否則登入者就被允許在你的 server 裡面閒晃chroot_local_user=YES# 允許這項功能的話，我們可以建立一個列表，列表裡頭的使用者將被允許可以離開自己的根目錄chroot_list_enable=YES# 乘上，該列表位置chroot_list_file=/etc/vsftpd.chroot_list# 須為一個名稱為 empty 的資料夾，且使用者不可對該資料夾有寫入的權限。當使用者未獲得檔案存取權限之前，會被限制在這個資料夾內secure_chroot_dir=/var/run/vsftpd/empty# 這是用來管理使用者權限的一個檔案，檔案位於 /etc/pam.d/vsftpd, 裡頭可以找到一個被限制存取的列表, /etc/ftpusers, 如果你不想讓哪一位使用者存取，你只要把他的帳號加到這個檔案裡頭就行了pam_service_name=vsftpd## 利用 TLS 加密傳輸的資料，本篇不使用rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NO# 為了要指定每個不同登入者的家目錄，這邊取得登入者的變數user_sub_token=$USER# 指定本地登入者的 root 位置, 若指定在別的位置，會跟 chroot 相衝突，如果要將使用者限制在自己的根目錄，需指定此路徑local_root=/home/$USER/ftp# 如果不想使用預設的 21 port, 可以自己指定 port 號listen_port=21212# 預設0, 使用任何 port 號。 這邊是一個被動模式的 port 使用範圍。 當伺服器端收到使用者端的被動模式要求，伺服器端會從這個區間內回覆使用者端一個用來傳輸資料的 port 供資料傳輸使用pasv_min_port=40000# 預設0, 使用任何 port 號。 這邊是一個被動模式的 port 使用範圍。 當伺服器端收到使用者端的被動模式要求，伺服器端會從這個區間內回覆使用者端一個用來傳輸資料的 port 供資料傳輸使用pasv_max_port=50000# 啟用 userlist 功能來限制可以存取的使用者，其功能基本上跟 pam 是類似的，是另外一種方式, 若要啟用，為 YESuserlist_enable=YES# 當此值為 YES, 則填入下一個設定檔中的帳號為禁止存取。 當此值為 NO, 為嚴格模式，只有被加入檔案的使用者可以存取userlist_deny=NO# 呈上，為使用者限制的列表檔案userlist_file=/etc/vsftpd.userlist# 每秒存取的最大流量 bytslocal_max_rate=10000000# 是否允許被限制在 chroot 的使用者有寫入的權限，因為我們要允許使用者上傳檔案，所以為 YESallow_writeable_chroot=YES# 預設為0, 表示無限制。 最大允許連線 server 的用戶端數量max_clients=50# 預設為0, 表示無限制。 來自同 ip 的最大允許連線數量max_per_ip=5# 是否使用 TCP Wrappers。TCP wrappers 是透過用戶端想要連結的程式檔名，然後分析用戶端的 IP ，看看是否需要放行tcp_wrappers=YES# 是否允許紀錄兩種不同格式的 logdual_log_enable=YES# log 的位置vsftpd_log_file=/var/log/vsftpd.log 建立 usersudo adduser test 之後再輸入密碼，假設為 1234 建立相關設定檔sudo touch /etc/vsftpd.chroot_list &amp;&amp; sudo mkdir /home/test/ftp &amp;&amp; sudo touch /etc/vsftpd.userlist &amp;&amp; sudo touch /var/log/vsftpd.log 權限設定 我架設這個 FTP Server 主要是要讓前端可以簡單地利用上傳來做簡單的部署，所以下面才會有 www-data 的相關權限設定。 有興趣可以看看，不然跳過也沒關係，因為這跟 FTP Server 沒有很直接的關係 建立共同群組此資料夾，預設只有該使用者以及 nginx 的 www-data 可以存取，所以先建立共同群組 sudo groupadd ftp_access 將 ftp 使用者以及 www-data 加入此群組 sudo usermod -a -G ftp_access test &amp;&amp; sudo usermod -a -G ftp_access www-data 設定權限 sudo find /home/test/ftp -type d -exec chmod 2770 &#123;&#125; \\; &amp;&amp; sudo find /home/test/ftp -type f -exec chmod 0664 &#123;&#125; \\; &amp;&amp; sudo chmod /home/test/ftp test:ftp_access 設定允許存取者echo &#x27;test&#x27; &gt; /etc/vsftpd.userlist GCP 防火牆設定給機器加 tag 我個人習慣用 gcloud shell, 可以選擇以下兩種方式 從官網安裝SDK 可參考 GCP 提供的 gcloud shell 網頁版, 快速教學 在此 若你對 gcloud 不熟，也可以選擇使用網頁 UI 操作 登入跟開機器的部分就略過，因為不在本篇主題範圍內 給機器加 taggcloud compute instances add-tags instanceName \\--tags test 開啟防火牆 依據指定的 tag 來開啟防火牆，這樣才不會開到所有的機器上 開啟連線 portgcloud compute firewall-rules create ftp-communication --allow tcp:21212 --target-tags test 開啟 passive port 的範圍gcloud compute firewall-rules create ftp-dataportrange --allow tcp:40000-50000 --target-tags test FTP 連線安裝 macbrew install inetutils ubuntu應該已經有了 重啟sudo service vsftpd restart;sudo service vsftpd status 應該要是 running 連線ftp -p yourIP 21212 輸入我們設定 user: test 輸入密碼: 1234 試試上傳一個檔案put whateverFile 結論沈浸在技術研究的感覺總是令人沈醉，雖然當遇到難題時，還真的想大醉一場有設定到 www-data 的部分，那是因為其實這個 FTP server 是架設來讓前端可以做簡單的部署，只要把 code 上傳，我的 NginX 會有一個 config 是反向代理這個資料夾, 不過因為跟本篇較無關係，看看就好！ 參考資料 我心目中的 Linux 之神，鳥哥大http://linux.vbird.org/linux_server/0410vsftpd.php Digital Ocean 的大神https://www.digitalocean.com/community/questions/proper-permissions-for-web-server-s-directory","link":"/zh-tw/ftpServer/"},{"title":"Front-end layout","text":"# IntroductionMy front-end layout practice records # Cat Photo App GitHub link Link # Cafe Menu GitHub Link # Colored Marker GitHub Link # Survey Form GitHub Link # Registration Form GitHub Link # Rothko Painting GitHub Link # CSS Flexbox Photo Gallery GitHub Link # Nutrition Facts GitHub Link","link":"/zh-tw/frontendLayout/"},{"title":"串接 Facebook graph API","text":"前言 本篇將分享如何使用 JavaScript SDK 讓用戶登入並取得 token, 然後利用 PHP SDK 向 Facebook 發請求, 進而取得使用者的資訊。 到FB的開發者頁面, 申請一個帳號, 並且在主控台的地方, 新增一個應用程式 到應用程式內的基本資料裡頭, 複製應用程式編號以及應用程式密鑰創建 Laravel 專案laravel new Facebook 初始化 Gitgit init 安裝 Facebook PHP SDK 於專案目錄下composer require facebook/graph-sdk 建立一個稍後用來向 FB 拿資料的 Controllerphp artisan make:controller FBController 建立一個 getFacebookResources function 複製 Facebook SDK 首頁的範例程式碼,並貼在這個 function 裏頭 require_once __DIR__ . &#x27;/vendor/autoload.php&#x27;; // change path as needed$fb = new \\Facebook\\Facebook([ &#x27;app_id&#x27; =&gt; &#x27;&#123;app-id&#125;&#x27;, &#x27;app_secret&#x27; =&gt; &#x27;&#123;app-secret&#125;&#x27;, &#x27;default_graph_version&#x27; =&gt; &#x27;v2.10&#x27;, //&#x27;default_access_token&#x27; =&gt; &#x27;&#123;access-token&#125;&#x27;, // optional]);// Use one of the helper classes to get a Facebook\\Authentication\\AccessToken entity.// $helper = $fb-&gt;getRedirectLoginHelper();// $helper = $fb-&gt;getJavaScriptHelper();// $helper = $fb-&gt;getCanvasHelper();// $helper = $fb-&gt;getPageTabHelper();try &#123; // Get the \\Facebook\\GraphNodes\\GraphUser object for the current user. // If you provided a &#x27;default_access_token&#x27;, the &#x27;&#123;access-token&#125;&#x27; is optional. $response = $fb-&gt;get(&#x27;/me&#x27;, &#x27;&#123;access-token&#125;&#x27;);&#125; catch(\\Facebook\\Exceptions\\FacebookResponseException $e) &#123; // When Graph returns an error echo &#x27;Graph returned an error: &#x27; . $e-&gt;getMessage(); exit;&#125; catch(\\Facebook\\Exceptions\\FacebookSDKException $e) &#123; // When validation fails or other local issues echo &#x27;Facebook SDK returned an error: &#x27; . $e-&gt;getMessage(); exit;&#125;$me = $response-&gt;getGraphUser();echo &#x27;Logged in as &#x27; . $me-&gt;getName(); 填入應用程式編號以及應用程式密鑰 上頭的範例中, 在以下地方填入我們從 FB 開發者帳號中得到的資訊$fb = new \\Facebook\\Facebook([ &#x27;app_id&#x27; =&gt; &#x27;應用程式編號&#x27;, &#x27;app_secret&#x27; =&gt; &#x27;應用程式密鑰&#x27;, &#x27;default_graph_version&#x27; =&gt; &#x27;目前版本&#x27;, //&#x27;default_access_token&#x27; =&gt; &#x27;&#123;access-token&#125;&#x27;, // optional]); 建立使用者登入按鈕 使用者要先登入進而拿到 token, 我們才可以使用 token 來做事 於 routes/web.php 檔案中, 新建一個給登入頁面使用的 route Route::get(&#x27;/FBToken&#x27;, function()&#123;return view(&#x27;FBToken&#x27;);&#125;); 於 resources/views/ 資料夾底下, 新增 FBToken.blade PHP 檔, 然後在裡頭貼上以下的 JS code&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Facebook Login JavaScript Example&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // This is called with the results from from FB.getLoginStatus(). function statusChangeCallback(response) &#123; console.log(&#x27;statusChangeCallback&#x27;); console.log(response); // The response object is returned with a status field that lets the // app know the current login status of the person. // Full docs on the response object can be found in the documentation // for FB.getLoginStatus(). if (response.status === &#x27;connected&#x27;) &#123; // Logged into your app and Facebook. testAPI(); &#125; else &#123; // The person is not logged into your app or we are unable to tell. document.getElementById(&#x27;status&#x27;).innerHTML = &#x27;Please log &#x27; + &#x27;into this app.&#x27;; &#125; &#125; // This function is called when someone finishes with the Login // Button. See the onlogin handler attached to it in the sample // code below. function checkLoginState() &#123; FB.getLoginStatus(function(response) &#123; statusChangeCallback(response); &#125;); &#125; window.fbAsyncInit = function() &#123; FB.init(&#123; appId : &#x27;&#123;your-app-id&#125;&#x27;, cookie : true, // enable cookies to allow the server to access // the session xfbml : true, // parse social plugins on this page version : &#x27;&#123;api-version&#125;&#x27; // The Graph API version to use for the call &#125;); // Now that we&#x27;ve initialized the JavaScript SDK, we call // FB.getLoginStatus(). This function gets the state of the // person visiting this page and can return one of three states to // the callback you provide. They can be: // // 1. Logged into your app (&#x27;connected&#x27;) // 2. Logged into Facebook, but not your app (&#x27;not_authorized&#x27;) // 3. Not logged into Facebook and can&#x27;t tell if they are logged into // your app or not. // // These three cases are handled in the callback function. FB.getLoginStatus(function(response) &#123; statusChangeCallback(response); &#125;); &#125;; // Load the SDK asynchronously (function(d, s, id) &#123; var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = &quot;https://connect.facebook.net/en_US/sdk.js&quot;; fjs.parentNode.insertBefore(js, fjs); &#125;(document, &#x27;script&#x27;, &#x27;facebook-jssdk&#x27;)); // Here we run a very simple test of the Graph API after login is // successful. See statusChangeCallback() for when this call is made. function testAPI() &#123; console.log(&#x27;Welcome! Fetching your information.... &#x27;); FB.api(&#x27;/me&#x27;, function(response) &#123; console.log(&#x27;Successful login for: &#x27; + response.name); document.getElementById(&#x27;status&#x27;).innerHTML = &#x27;Thanks for logging in, &#x27; + response.name + &#x27;!&#x27;; &#125;); &#125;&lt;/script&gt;&lt;!-- Below we include the Login Button social plugin. This button uses the JavaScript SDK to present a graphical Login button that triggers the FB.login() function when clicked.--&gt;&lt;fb:login-button scope=&quot;public_profile,email&quot; onlogin=&quot;checkLoginState();&quot;&gt;&lt;/fb:login-button&gt;&lt;div id=&quot;status&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同樣, 在上面的程式碼中需填入編號及版本號, 如下FB.init(&#123; appId : &#x27;編號&#x27;, cookie : true, // enable cookies to allow the server to access // the session xfbml : true, // parse social plugins on this page version : &#x27;版本&#x27; // The Graph API version to use for the call&#125;); 熟悉 FB graph API 工具 利用 FB graph API 測試工具,我們可以找到我們需要的 API 客製 endpoint 因為之後我們可能會直接複製經由 graph API 工具 取得的 endpoint, 如下： 所以我們可以把 endpoint 這段移到 .env 中, 如下： $endpoint = env(&#x27;FBEndpoint&#x27;);try&#123; // Get the \\Facebook\\GraphNodes\\GraphUser object for the current user. // If you provided a &#x27;default_access_token&#x27;, the &#x27;&#123;access-token&#125;&#x27; is optional. $response = $fb-&gt;get($endpoint, $token); 然後 .env 裡頭 FBEndpoint=me?fields=id,name,email 如此一來, 之後我們只要直接複製 graph API 取得的值, 貼到 .env, 打完收工！ 修改錯誤回傳值 PHP SDK 預設錯誤時, 會依照錯誤狀況回傳錯誤訊息, 可我只需知道 true or false, 就行了, token 無效有可能是因為以下幾種狀況 根本沒帶 帶的是錯的 過期了 不管是哪一種, 我都需要回傳錯誤訊息給前端, 並要求前端再去跟 FB 要一次, 拿對的來, 所以說, 我必須要判斷 PHP SDK 的輸出, 有沒有錯誤, 若錯做一件事, 對也做一件事, 因此我們需要修改原本錯誤訊息輸出的地方, 改成簡單的 true or false, 如下： catch (\\Facebook\\Exceptions\\FacebookResponseException $e) &#123; return false;// echo &#x27;Graph returned an error: &#x27; . $e-&gt;getMessage();// exit; &#125; 取得 public url 使用 ngrok 取得用來拿 token, HTML 頁面的 public url 登入開發者應用程式 =&gt; 找到產品 Facebook 登入 =&gt; 快速入門 =&gt; 網站 =&gt; 貼上 public url 登入取得 token將 token 打到 Laravel 裡的 FBController 裡頭的 getFacebookResources將取得的資料,存入資料庫,完成會員建檔打完收工","link":"/zh-tw/getINFOViaFBToken/"},{"title":"Git - Template","text":"# 前言紀錄如何利用 Git template 來管理並規範你的 git commit message # 正文# 建立touch .gitmessage.txt # 放到你喜歡的位置cp .gitmessage.txt whereverYouLike # 設定如我想要這份模板的範圍是 global 的, 就使用 --global, 若希望範圍只在某個專案, 就在該專案內使用下這行指令並使用 --local git config --global commit.template ~/.gitmessage.txt # template example下面是我使用的模板 example, 團隊可自訂適用於該團隊的 # commit log 請遵造以下格式，並注意冒號後面有一個空格# # &lt;[type]&gt;: &lt;subject&gt; &#123;必要, 請參考下面的解說&#125;# # &lt;body&gt; &#123;非必要, 請參考下面的解說&#125;# # &lt;footer&gt; &#123;非必要, 請參考下面的解說&#125;# # 範例:# [feat]: 實作 login api function## 完成登入功能, 並串接 Line Login## Closes OR-xxxx # # &lt;Type&gt;# 請遵守下列標籤# feat: 新功能# fix: Bug修復# config: 設定檔改變# docs: 文檔改變# style: 代碼格式改變# refactor: 功能重構# perf: 性能優化# test: 增加測試代碼# build: 改變build工具# ci: 與ci相關的設定# add: 增加一些跟功能無關的檔案# 3rd: 增加第三方# db: 有關資料庫的修改## &lt;Subject&gt;# 用來簡要描述影響本次變動，概述即可# # &lt;Body&gt;# 具體的修改訊息，越詳細越好# # &lt;Footer&gt;# 如果是要關閉特定 Issue 或 Bug. 可以使用 Closes PROJECT-1 or Resolves PROJECT-1 or Fixes PROJECT-1 # 具體清參考 https://docs.gitlab.com/ee/user/project/integrations/jira.html","link":"/zh-tw/git-template/"},{"title":"Git 學習筆記","text":"前言Git 學習筆記, 學什麼記什麼！ Q&amp;A 如何在新建的檔案中, git add 部分的程式碼? git add -N new_filegit add -i Git 中, 如何指定 git 指令作用的目錄？ 比方說, 我目前的目錄不是 ~/code/project, 但我想要 git commit 作用的範圍在 ~/code/project? git -C `~/code/project` commit -m &#x27;whatever&#x27;` Git 中, 如何取得當前 branch 最新的 commit 的 message? git log --oneline --format=%B -n 1 | cat %B: 輸出 subject + 主體 %s: subject %b: 主體 -n: 只顯示最新的幾筆 commit, 後面接數字, 也可使用 -(n) 方式","link":"/zh-tw/git/"},{"title":"Git-從哪裡開始？","text":"嗨大家好，我是Ray! 如上一篇提到，Git對於一個coder來說可以說是不可或缺的，今天我就來分享一下Git的基本操作 首先呢，讓我們先來創一個範例資料夾，名稱就叫做my-git-repository吧！ 到Command Line cd 你想要這個資料夾在哪的路徑/ 輸入 mkdir my-git-repository 然後 cd code/my-git-repository 進到資料夾內，code是我自己的母資料夾，各位請輸入你們自己的路徑 進到資料夾的位置，如下圖：￼ 讓我們在裡面建立一個檔案 touch example1.html 然後在該檔案裡面添加以下內容： &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 輸入 git init ￼ 然後輸入 git status ￼ 如上圖所示，我們已經可以開始使用git的相關功能，目前example1的檔案還處於untracked狀態，在建立任何存擋點之前，我們必須要先將檔案加入追蹤，就好像我們在FB上追蹤那些名人一樣！ 輸入 git add example1.html 如下圖：￼ 再來輸入 git commit 看起來如下：￼ 應該會出現以下的畫面￼ 接著我們隨便輸入first example當作這個存擋點的訊息記錄 接著我們按 :wq 儲存並離開視窗 輸入 git status 看起來如上圖： 輸入 git log 然後你應該可以看到一串代表著此次commit，獨一無二的號碼。￼ 你應該會看到以下的commit，commit 的號碼每個人都不同，所以如果你的號碼跟我的不同是正常的，不用覺得奇怪！ 這樣一來就算是完成了一次的存擋啦！之後我們可以隨時回到這個狀況只要我們想要的話！ 今天的分享就先到這啦，之後若有機會會再做進一步的介紹！","link":"/zh-tw/gitInit/"},{"title":"Stackdriver Logging 的根本應用","text":"概述Stackdriver Logging 是 Google Cloud Platform (GCP) Stackdriver 套裝產品的一部分。 它包含紀錄的儲存，一個使用者介面名為 Logs Viewer, 還提供 API 讓你可程式化的去管理紀錄. 使用 Stackdriver logging 來讀寫紀錄, 搜尋以及篩選紀錄, 匯出紀錄, 以及建立記錄指標 在這個練習中, 你將學習如何使用 Stackdriver Logging, 在同一個地方累積應用的 logs, 通過篩選來取得實際上需求的 紀錄, 理解如何建立紀錄指標來進行更進階的分析, 稽核紀錄 的使用案例, 以及匯出紀錄如果有更進階分析的需要 你需要做什麼？ 部署一個 Google App Engine 應用的範例來產生紀錄 使用 Stackdriver Logging 主控台來對應用產生的紀錄做相關操作 建立 Stackdriver monitoring 記錄指標 建立 Stackdriver logs 的 Export 至 Google BigQuery 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 部署應用使用 Cloud Shell 命令行工具來部署 guestbook, 一個 Google App Engine 的範例應用。 這個網頁應用將會產生我們需要的紀錄 從遠端 Clone guestbook 應用 git clone https://github.com/GoogleCloudPlatform/appengine-guestbook-python.git 移動到 clone 下來的資料夾內 cd appengine-guestbook-python/ 部署 guestbook 應用 gcloud app deploy app.yaml index.yaml 選擇離你較近的地區 Please choose the region where you want your App Engine application located: [1] europe-west2 (supports standard and flexible) [2] us-east1 (supports standard and flexible) [3] us-east4 (supports standard and flexible) [4] asia-northeast1 (supports standard and flexible) [5] asia-south1 (supports standard and flexible) [6] australia-southeast1 (supports standard and flexible) [7] southamerica-east1 (supports standard and flexible) [8] us-central (supports standard and flexible) [9] europe-west3 (supports standard and flexible) [10] europe-west (supports standard and flexible) [11] cancelWhen prompted to continue type &quot;Y&quot;:Do you want to continue (Y/n)? Y 輸入 “Y” 繼續。幾分鐘後，應用將會被完全部署完畢 檢視以及搜尋紀錄移動到 Stackdriver Logs Viewer 設置要檢視的紀錄 選擇Navigation menu &gt; Logging &gt; Logs Viewer Stackdriver Logging 主控台有以下功能： (1) 服務篩選器： 根據資源種類篩選 (2) 紀錄篩選器： 根據選擇的資源的特定類型來篩選 (3) 紀錄等級篩選器： 篩選特定紀錄等級 (4) 日期篩選器： 根據特定日期篩選來檢視之前發生的問題 (5) 切換持續串流 (6) 一個搜索框，可以根據文字，標籤，正則，進階篩選器來搜尋 產生紀錄 造訪早前建立的 Google App Engine 應用 (guestbook) 來產生用來檢視的紀錄 在一個新的網頁視窗，打開 guestbook 應用，應用的 URL 如下： https://&lt;PROJECT_ID&gt;.appspot.com 用位於 lab 左方面板上的GCP Project ID來替換 或者，你也可以從 Cloud Shell (當你部署 App Engine app 時的輸出) 複製完整的 URL，然後在新的網頁視窗貼上 如果你看到Internal Server Error, 那是因為 Datastore Index 還沒準備好，等個一分鐘再重新整理瀏覽器 預測該有的結果： 當你在你的瀏覽器視窗看到 App Engine Guestbook, 這代表你的 App Engine 應用已經部署且驗證完畢，讓我們來產生一些紀錄吧 重整瀏覽器幾次，並且輸入一些名字到 Guestbook 應用來產生一些紀錄 回到 Stackdriver Logs Viewer 篩選器Logs Viewer 提供多樣化的基本篩選以及進階篩選的搜尋功能 基礎篩選 一樣在 Logs Viewer，在第一個下拉式窗 (服務選擇器)，選擇GAE Application &gt; Default Service &gt; All version_id, 表示我們想要檢視該服務的紀錄。這會顯示 guestbook 的所有紀錄 在下一個下拉選單 (紀錄選擇器), 選擇All logs 在下一個下拉選單 (紀錄等級選擇器), 選擇Any log level 其他下拉選單為默認值, 你的 Basic Filter 應該看起來是像這樣 注意，當你更換選擇時紀錄清單會自動重整 進階篩選器使用進階篩選器來進一步訂做你的搜尋 在Filter by label or text search下拉選單，選擇Covert to advanced filter 注意，你選擇的基礎篩選器已經在進階篩選器被轉譯成查詢表達式 在進階篩選器的輸入文字區塊，加上下面新的一行。 輸入新的一行來看自動完成功能 protoPayload.latency&gt;=0.01s 這行顯示所有延遲大於或等於 0.01 秒的 GAE app 紀錄 點擊Submit Filter然後檢視更新過的紀錄資料，可看到所有延遲超過 0.01 秒的紀錄 回到基礎篩選模式。點擊右上方，位於進階篩選器文字區塊區中的箭頭，在下拉選單選擇Clear filters and return to basic mode 紀錄指標紀錄指標是根據於紀錄的內容的 Stackdriver Monitoring 指標。 因此，你的紀錄不會只坐在那什麼事情也不做就等著別人來發現錯誤; Stackdriver Monitoring 會自動地監控你的紀錄，監控那些你定義的事件以及指標。由此可見，紀錄指標真是一個監控你客製化應用的一個絕佳的好方式。如果你的應用可以寫紀錄到 VM 的文件系統，你可以在那之上建立監控系統。 Stackdriver Monitoring 提供兩種使用者定義的紀錄指標 - Counter 以及 Distribution 計數器指標 (Counter Metrics)計數器指標計數那些符合進階紀錄篩選器的紀錄內容。舉例來說，一種指標，計數著那些，在特定資源中，代表某些類型的錯誤的紀錄內容。當很多拜訪你網頁的使用者收到了 HTTP 500 錯誤，想要收到警告嗎？ 計數器指標可以幫到你 分佈指標分布指標從紀錄中，累積那些符合篩選器的數據資料並且做數學運算。來說說一個分佈指標的普遍運用，像是追蹤一段時間的延遲模式/趨勢。當收到每一筆紀錄，延遲的數據會從紀錄中被取出並且加到分佈。累積的分佈將會有規律間隔的被寫到 Stackdriver Monitoring 建立計數器指標在此節中，你將建立一個計數器指標來計數成功拜訪網站的次數 - 在這個例子中，所有帶的 HTTP 200 的紀錄都算 依然在 Logs Viewer, 在select service的下拉選單中，選擇GAE Application &gt; Default Service 在log level selector下拉選單中，選擇All logs, 你的篩選器應該看起來如下： 在紀錄清單中，點擊狀態 “200” (任何列有 200 就行) 然後選擇Show matching entries 你將會看到 清單只會列出狀態 200 的紀錄 在進階的篩選編輯器中，一條進階的篩選條件已經自動地被建立了 protoPayload.status=200 根據你的篩選器建立一個監控指標 點擊Create Metric 來建立監控指標，根據你的進階篩選器 在指標編輯器中，根據下圖賦值，其他的欄位留為預設值就可 點擊Create Metric 下滑紀錄指標清單來檢視剛剛建立的回應 200 的指標, 你的新指標被列在最尾端， User-defined Metrics 的區塊中 在下圖三點圖案處點擊，選擇 View in Metrics Explorer 來檢視回應 200 的指標 在 Metrics Explorer 視窗打開 Stackdriver 主控台大概會需要一分鐘的時間 在 Metric Explorer, 點擊 GAE Application 資源類型，應該在數秒後會被自動增添進去 如果在資源類型選項中你沒有看到 GAE Application 關閉 Metrics Explorer 視窗 重整你的 guestbook app 幾次，來產生紀錄數據 等待一分鐘，等你的記錄數據被添載進去 (在你重整 App Engine app 之後), 很有可能會花 2 到 3 分鐘 點擊三個點圖案，選擇View in Metrics Explorer 一旦紀錄有被吃到，你將會看到 GAE Application 出現在Resource types 選擇器當中 這個指標已經準備好可以監控並且分析你應用的行為 建立一個分佈指標在此節中，你將會建立一個分佈計數器來監控 guestbook 應用的延遲 回到 Stackdriver Logging Console &gt; Logs Viewer, 建立一個篩選器來選擇GAE Application &gt; Default Service, All Logs, 以及 Any Log Level, 如下圖: 在頁面上方點擊Create Metrics 在指標編輯器的面板中，設定如下圖中的值 點擊Create Metric 核對延遲指標已經被建立在使用者定義的指標中 產生更多紀錄。重整 guestbook 應用多次，給指標 1 到 2 分鐘去取得以及累積新的紀錄資料 點擊三個點的圖案，然後點擊View In Metrics Explorer, 如下圖: 跟之前一樣，從resource type點擊GAE Application, 然後確認一下指標是你剛剛建立的那一個 如果GAE Application沒有自動載入 關閉 Metrics Explorer 視窗 重整你的 guestbook app 幾次，來產生紀錄數據 等待一分鐘，等你的記錄數據被添載進去 (在你重整 App Engine app 之後), 很有可能會花 2 到 3 分鐘 點擊三個點圖案，選擇View in Metrics Explorer 一旦紀錄有被吃到，你將會看到 GAE Application 出現在Resource types 選擇器當中 在 Stackdriver 監控主控台中檢視紀錄指標Stackdriver Monitoring Overview 視窗提供監控資源縱覽，紀錄指標就被列在圖表中 Stackdriver 會用這四種格式的其中一種來顯示圖表資料: Line, Stacked Bar, Stacked Area, 或是 HeatMap, 如果你想要指定格式： 在其中一個圖表點擊三個點的圖案，然後點擊Edit 在格式的下拉選單中，選擇一種格式 點擊Save把四種格式都試試看，看哪一種可以最好的呈現延遲指標 也試試其他圖表 稽核紀錄GCP 默認為所有的 GCP 資源提供稽核。稽核紀錄提供了 “誰做的？什麼時候做的？”, 讓我們來看看稽核紀錄吧，讓我們從建立一台 VM 開始。 開啟一台 VM 算是稽核權限活動的一種，所以會產生紀錄 開啟一台 VM 來產生稽核紀錄事件 在 GCP 主控台，選擇Navigation menu &gt; Compute Engine &gt; VM Instances 等待 Compute Engine 服務初始化 點擊Create 依下圖設定相關欄位中的值，其餘的保留預設 點擊Create 在活動檢視器中檢視稽核紀錄GCP Dashboard 的活動檢視器提供快速檢視稽核紀錄的功能 點擊主控台視窗上方的Google Cloud Platform來回到 GCP Dashboard 切到 ACTIVITY 視窗，你可能要點擊Navigation menu來關閉選單，所以才能看到ACTIVITY視窗 檢視最近的稽核紀錄數據，可以看到在最上面，有很多跟建立 VM 相關的數據 在上面的截圖，注意到四筆紀錄數據記錄著 VM 的建立以及與之相關的 HTTP 防火牆規則 點擊其他行來看看他們說明些什麼。是否有認出這好像是在本教程中我們先前做過的動作 從 Stackdriver 記錄檢視器來檢視稽核紀錄在 Stackdriver 記錄檢視器中，就像在活動檢視器一樣，你可以看到稽核紀錄數據。不同的是，記錄檢視器提供了更多功能，像是進階的篩選器以及其他的記錄管理功能 從 GCP 主控台回到 Stackdriver 記錄檢視器 (Navigation menu &gt; Logging &gt; Logs Viewer) 在service selector, 選擇 GCE VM Instance &gt; All instance_id 在 logs selector 下拉選單，選擇cloudaudit.googleapis.com/activity, 然後點擊OK 檢視與Create VM 以及 Completed對應的兩筆稽核紀錄, 以及在活動檢視器看到的Create VM紀錄 看看基本篩選器是怎麼呈現的，對比進階篩選器。從標籤或文字搜尋下拉視窗，點擊篩選器，並且轉換成進階篩選器，看看進階篩選器的代碼如下： 進階篩選器只顯示 GCE instance 的被稽核的活動 放寬範圍來看看 GCP 服務的所有稽核紀錄。 移除第一行，第一行限制了稽核紀錄的範圍，然後點擊Submit Filter 檢視所有在 Google Cloud Platform 上被使用者所執行的活動 在任何一行，點擊你的 Qwiklabs 使用者名稱（信箱）, 然後點擊Show matching entries 這增加了一行新的規則到進階篩選器中，限制只顯示被你所執行的活動 匯出紀錄Stackdriver Logging 保留 30 天的記錄，超過就刪除。如果你要保留紀錄久一點，你可以將他們會出到其他的儲存系統，或者 sink, 像是 BigQuery 。 Stackdriver Logging 可以讓你設定自動化的匯出腳本，所以所有的紀錄都會自動地被匯出。 紀錄也可以在你選擇的接收器被進一步的分析 建立一個匯出工作設定一個匯出工作來發送所有的稽核紀錄到 BigQuery 來長期儲存與分析。 在 Stackdriver 記錄檢視器的視窗，從進階篩選器移除第二行，然後點擊Submit Filter, 然後你可以檢視 GCP Project 所有的稽核紀錄 在頁面的上方，點擊Create Export，然後依照下圖輸入值 點擊Create Sink。 點擊Close離開接收器建立確認視窗 在 BigQuery 檢視稽核紀錄 開啟 BigQuery, 選擇Navigation menu &gt; BigQuery 關閉歡迎標語 在左邊面板處，點擊 Project ID 旁邊的箭頭來展開 GCP 專案名稱，來看新的 AuditLogs 資料 注意到 AuditLogs 之下還沒有任何的表格。 Log Exporting 會再匯出作業建立之後，開始發送資料到接受器。 Log Exporting 會產生一些稽核記錄數據，然後會再接受器建立表格，並且開始存入資料 回到 VM instance 視窗 (Navigation menu &gt; Compute Engine &gt; VM instances) 點擊 GCE VM instance 來檢視細節 點擊上方的Edit, 對 VM 做兩個小變更 (1) 勾選Enable connection to serial ports 的小格子，來允許連續 port 的連線 (2) 往下滑，勾選Allow HTTPS Traffic來允許 HTTPS 連線 點擊Save 到主要 GCP Dashboard 的 Activity 視窗，你應會看到一些 Audit Log 數據，包含一個叫做 “Set metadata on VM (設定 VM 的中繼資料)”, 另一個叫做 “Create firewall rule (建立防火牆規則)”, 還有一些其他跟 VM 變更有關的。 你將會看到一個叫做 “Create Table (建立表格)” 的事件，顯示 BigQuery 接收器已經被建立 約一分鐘後(你可能需要重整頁面), 你將會看到 Audit Log 數據，顯示 BigQuery 的表格已經被更新了，更新資料為我們剛剛變更 VM 之後而產生的新的 Audit Log 數據。 看一下時間戳記來辨認所有 BigQuery 有接收到，那些與這次 VM 變更有關的數據資料 回到 BigQuery 主控台，展開 AuditLog 資料組。你可能需要重整頁面。 你應會看到新的 cloudaudit 表格已經被建立了，點擊它 使用 BigQuery 來探查稽核紀錄 點擊新的 cloudaudit 表格, 然後點擊 Query Table 按鈕 Query Editor 的輸入文字處已經事先仔入一部分的 SQL query, 且游標置於 “SELECT”, 以及 “FROM” 在 “SELECT” 以及 “FROM” 之間輸入 *, 然後點擊 Run 幾分鐘後，查詢完成了，你會在下方的結果處看到 Audit Log 數據, 有很多欄位, 裡頭有些是巢狀的 點擊結果視窗的任何地方，然後使用方向鍵來左右移動，可以看到稽核紀錄非常的詳細 現在定義一個範圍小一點的查詢來檢視每個稽核數據的大概 (1) 在右上方點擊 Compose New Query (2) 複製下面的 code, 貼到查詢編輯器 SELECTtimestamp,resource.type,protopayload_auditlog.authenticationInfo.principalEmail,protopayload_auditlog.methodNameFROM `&lt;your-project-ID&gt;.AuditLogs.&lt;your_audit_log_table_name&gt;`WHERE protopayload_auditlog.authenticationInfo.principalEmail = &quot;&lt;your_qwiklabs_username_email&gt;&quot;LIMIT 1000 (3) 上面有些參數，參照下圖的表格內資訊替換 (4) 點擊 Run 來開始查詢。 你應會看到小一點的欄位，根據我們做的操作做限制，結果應會跟下圖相似: 這個簡單的查詢只是使用 BigQuery 來產生客制紀錄的一個範例，你可以建構任何數量的 SQL queries 來分析你的稽核紀錄來符合你的需求 恭喜，你已經完成本教程","link":"/zh-tw/fundamentalsOfStackdriverLogging/"},{"title":"推錯了Commit該怎麼辦？","text":"有時我們把功能做好並且推上公共資料夾之後才發現，靠...我commit好像推錯了... 別緊張，這時候我們可以使用git revert 來取消我們的commit。 現在讓我來為各位做個示範： 建立一個本地遠端資料夾 因為有些朋友可能沒有網路，所以本篇範例將創立一個在本地的遠端資料夾 到你一般存放專案的資料夾底下 mkdir git_demonstration git_demonstration_central cd git_demonstration_central git init --bare git_demonstration_central將會是本篇範例中的遠端資料夾 建造本地測試環境 進到本範例本地資料夾 cd ../git_demonstration 初始化git git init 建立名為test的檔案 touch test 在檔案內增加內容1 cat 1 &gt; test 將test檔案加到git追蹤清單 git add test 針對目前檔案以及內容做一個commit名為1 git commit -m&#39;1&#39; 在檔案test中增加數字2，並做一個新的commit名為2 cat 2 &gt;&gt; test;git commit -am&#39;2&#39; 在檔案test中增加數字3，並做一個新的commit名為3 cat 3 &gt;&gt; test;git commit -am&#39;3&#39; 建立遠端branchBuild remote branch 將我們一開始建立的位於本地的模擬遠端資料夾加到當前測試環境的遠端 git remote add origin /user/yourUserName/yourDirectory/git_demonstration_central 將目前master branch 推到此遠端，並將遠端新增的分支設為本地的上游分支 git push -u origin master 到遠端資料夾看一下，目前狀況 cd ../git_demonstration_central;git log Revert已存在的commit 假設今天我們要將commit 3的內容移除 git revert f06550f7 更新到遠端 git push 看一下檔案test的內容是否已變更 cat test 得值1 2，原本數字3已經在revert之後被移除了 確認遠端歷史狀況 cd ../git_demonstration_central;git log 總結 有些剛接觸git的人可能會跟我當初有同樣的疑問，那為啥不要整個git的log紀錄都抹掉就好，為啥要多一個commit？ 這邊跟大家解釋一下，如果今天我們已經把我們完成的進度推到共同資料夾了，我們就不建議去修改歷史了，因為你一但修改了歷史再往上推，整個共同資料夾的歷史就會改變，共同資料夾的紀錄相當於所有協作者的紀錄，所以如果你單方面變動了歷史，很可能會造成所有協作者的歷史都跟你的不一致，甚至在commit的過程中會有衝突，這在多人協作是相當不建議的。 我們要拿掉的，是我們檔案內的一段有commit紀錄的code，所以實際上我們要取消的是code，不是歷史，而在多人協作中，歷史是可以增加，不建議修改的。你可以新增一個commit明確說明我這段commit是新增或者拿掉了什麼東西，但是不建議單方面地把東西拿掉並且去修改你的歷史紀錄，因為你改的東西只有你自己知道，對於其他的協作者來說他們並不知道在你的電腦上發生了什麼事。 簡單來說，在你上傳到共同資料夾之前，你可以對你的歷史做任何事（這邊僅限於還未上傳的部分，已經上傳的不建議去修改），但是一但上傳之後，就不建議去修改歷史。如果你要對檔案內容做任何修改，請新增一個commit說明修改的內容，這樣才不會造成其他協作者的疑惑以及大家的git歷史有衝突。 以上就是今天的分享，我們明天見！","link":"/zh-tw/gitRevert/"},{"title":"一下子敏感, 一下子不敏感, Git 你搞得我好亂啊","text":"概述在一個因緣際會之下, 我與 Git 有場美麗的邂逅, 殊不知, 對我這個情場處子來說, Git 就像一隻貓, 忽遠忽近, 忽冷忽熱, 忽上忽下, 忽快忽慢… 一下子敏感, 一下子又不敏感, 那個… 我說的是大小寫。 故事開始什麼是 case-sensitive 與 case-insensitive? 就是大小寫敏感 以及 大小寫不敏感! 不同的作業系統對於 case-sensitiveness 這件事情會有不同的設定, 拿 case-sensitive 的 Linux 來說, 在同一個資料夾我可以有檔案 a 跟檔案 A, 但是在 case-insensitive 的 MacOS 中, 檔案 a 即 A 試想, 在 Linux 中我在一個資料夾內有兩個檔案為 a 跟 A, 並且我都上了 commit 並推上遠端, 那這時在 MacOS 上將如何呈現這件事呢？macOS 視角: Commit 裡面有幾個我不管, 對我來說只有 一個 檔案, 因為 a 即 A 媽媽樂勒, 你搞得我好亂啊！ 該如何解決這件事情呢？ 我們可以使用 git 指令 git config [--local/--global] core.ignorecase true/false 這個指令是在幹什麼的勒？它可以決定 Git 的世界是 如何看待 case-sensitiveness(大小寫敏感度) 這件事。 舉例來說, 在一個 git 專案中, 當我們今天設定為 true, 代表 case-insensitive git config --local core.ignorecase true 這時候如果我們在 macOS 中變更檔名: mv a A 將原本控管中的一個 a 更名為 A, 這時候呢, 對 case-insensitive 的 macOS 來說檔案還是只有一個, 只是檔名變了, 所以什麼事都沒有改變。 同理, 對此設定的 Git 來說也是一樣的; 資料夾中不管是 A 還是 a, 對 Git 來說都是一個檔案, 因為目前的設定是 case-insensitive(大小寫不敏感), 所以如果我們使用以下指令檢查狀態: git status 我們是不會看到有任何 modified 的檔案的 但如果這時 Git 的設定為 false, 即 case-sensitive(大小寫敏感), 老天爺… 那就是完全不一樣的事了。先設定： git config --local core.ignorecase false 再改個檔名： mv a A 然後看個狀態： git status 這時我們會發現, 多了一個 new file A ! 因為這時 Git 的角度是 case-sensitive(大小寫敏感), a 對我來說是一個檔案, A 是另一個檔案, 所以我的 commit 中並不存在 A 這個檔案。 更有趣的事情, 使用 git add . 然後新增一個 commit: git commit -m &#x27;Add A&#x27; 這時在變更一次檔名： mv A a 然後檢視狀態： git status 此時我們可以發現, 已經不會有任何提示 modified 了, 因為此時在 Git 的 commit 中存有兩個檔案, 一個是 a, 一個是 A, 所以兩個我都有, 自然不會出現 modified 了 若要驗證這一點, 可以先在 GitHub 建立一個 repo, 然後將目前這個分支推上 GitHub, 再到 GitHub 上去看, 會發現… 傻眼貓咪勒… 我的資料夾內明明就只有一個檔案, 怎麼上了 GitHub 之後變兩個了? 再來, 我們試著變更這個檔案: vim a 隨便加個 “123” 之類的, 然後儲存並離開: :wq 再檢視一下狀態： git status 嚇死寶寶, 竟然發現同時出現了 modified: A 以及 modified: a!!! 因為此時在 Git 的世界中是有兩個檔案的, 兩個都對應到資料夾中的檔案 a 有興趣的話, 你可以再做個實驗, 如果你有 Linux 系統的主機的話, 可以開一個專案, 使用以下指令來建立兩個檔案： touch a A 初始化 Git git init 做一個 commit git add .git commit -m &#x27;init&#x27; 先在 GitHub 上面開一個 repo, 然後推到遠端: git remote add origin yourRepoURLgit push -u origin master 這時候你可以到遠端看看, 遠端的資料夾內應該是確實會有 a 跟 A 兩個檔案, 因為 Linux 系統是 case-sensitive(大小寫敏感) 現在找一台 macOS 的電腦來 clone 專案： git clone yourRepoURL 進到專案內 cd yourProject 檢視資料夾內容： ls 林周公勒！ 我剛剛明明就有看到兩個檔案, 阿怎麼少了一個？你應該只會看到 a 檔案, 因為 macOS 檔案系統是 case-insensitive 的 綜合以上所得, 我歸納出以下幾點： 佛曰一沙一世界, 獨自開發時, 請務必讓你的 Git config case-sensitiveness 的設定跟你的作業系統是一致的, 這樣至少兩邊行為一樣, 才不會把自己搞到精神錯亂啊! 如果 Git 設定為 case-insensitive, 那麼儘管你實際上有兩個大小寫不同, 但檔名相同的檔案, Git 只會視為一個。 如果 Git 設定為 case-sensitive, 那麼儘管你只是使用 mv 做小寫更名成大寫的動作, Git 還是會當作是有兩個不同的檔案 一個專案如果參與的開發者們橫跨了不同的作業系統, 那請一定要在這一點上有共識, 同一個資料夾內不要有同檔名但大小寫不同的檔案, 不然是想逼死誰？ 如果遇到需要重新命名檔名的話, 記得確保修改的是 commit 內 的檔名, 務必使用 git mv currentFileName newFileName Q&amp;A這邊將一些概念歸納成 Q&amp;A 的方式, 希望可以幫助理解 在 Git 中, 當我們設定 git config --local core.ignorecase true 時, 此時 git 為 case-sensitive 或 case-insensitive?case-insensitive 在 Git 中, 當我們設定 git config --local core.ignorecase false 時, 此時 git 為 case-sensitive 或 case-insensitive?case-sensitive macOS 的檔案系統是 case-insensitive 還是 case-sensitive?case-insensitive Linux 的檔案系統是 case-insensitive 還是 case-sensitive?case-sensitive 為什麼 Git 的 case-sensitiveness 跟作業系統的視角要一致？這樣才會兩邊的行為一致 結論天下無不散的宴席, 送君千里終須一別, 將琴寄語兮, 予以相將…不好意思讓你們聽到髒東西… 大家新年快樂！ 最後人非聖賢, 孰能無過… 阿不是, 是人非草木, 豈能無情…你清脆的掌聲於我, 有如浪頭與衝浪者的關係！ 讓我找到存在的價值… 拍 1 下: 來都來了, 刻個到此一遊吧！拍 10 下: 覺得小生寫得還可以, 馬馬虎虎普普通通淒淒慘慘戚戚...拍 20~30 下: 這篇文章有幫助到你, 讓你的概念清晰了百分之零點零零一拍 40~50 下: 看完覺得心情愉悅, 或是覺得 Ray 很帥","link":"/zh-tw/gitSensitiveness/"},{"title":"Git-標注一個版本號碼","text":"哈囉大家好，我是Ray！ 今天我將跟大家分享git tag，如何建立一個版本號。 當我們接二連三地完成了專案裡的一些功能，一系列的功能可能代表著一個版本的產生，比方來說，大家都玩過線上遊戲吧？ 每次改版時，常常都是釋出一些新的功能，這個版本號常常意味著，除了這些功能開發完成之外，並且都正常的運作著。 這個版本號對於開發者來說非常方便與重要，這樣來解釋，一系列的小功能構成一個大功能，而這個大功能的完成也代表著新版本的推出。 當每一次我們完成了一個小功能，我們使用git commit把它記錄下來，而當我們陸陸續續完成一系列的小功能而構成一個大功能時，我們使用git tag來標注，代表著一個版本的釋出。若日後我們需要回到這一版來做相關的一些測試的話，非常的方便！ 輸入 git log --oneline 以上是我們還沒有tag之前的樣子。 輸入git tag -a v1.0 -m “The stable version of example” 如上圖你可以看到我們剛剛加入的版本號 v1.0 輸入 git tag 可以看到我們至今tag的任何版本號 現在讓我們新增一個檔案，example2.html，並且新增以下的code: &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the experimental file created after reversion v1.0&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 然後輸入 Git add example2.htmlgit commit -am “An example2 file after v1.0”Git log --oneline 如上圖，我們目前在第六個commit，而我們的版本是在第五個commit 當我們想要回到v1.0的版本時，我們不需要checkout第五個commit的名稱，我們只需要輸入版本編號即可，如下輸入： Git checkout v1.0Git log --oneline 如上圖，我們已經回到版本v1.0的紀錄了 希望我今天的文章對你有所幫助！","link":"/zh-tw/gitTag/"},{"title":"Gitlab 學習筆記","text":"前言個人 Gitlab 學習筆記，內容未整理過。 Event 通知Project =&gt; Settings =&gt; Integrations =&gt; Slack notifications","link":"/zh-tw/gitlab/"},{"title":"利用 Gitlab CI/CD 部署專案到 GCP virtual machine","text":"前言本篇將分享如下： 利用 gcloud 開立一台 GCP instance 如何利用 gcloud 在 instance 上匯入 ssh key 利用 Daemon 使服務常駐 利用 gitlab pusher 部署專案到 GCP virtual machine 上 環境建立開啟一台 GCP 虛擬機以下是個人做法，不需要照做 Ray 使用 Mac 所以我在本地端安裝了 Google Cloud SDK, 安裝方式可以參考官方文件 建立一台 VM 建立一台機器, 叫做 example-instance-1 開機碟的空間為 10GB 從 ubuntu-os-cloud, 來 pull 我們需要的 image 我們使用 ubuntu-1804-lts 的 image 版本, 這會自動使用這個版本的最新版 硬碟類型為 pd-stand, 不知道類型可以跑 gcloud compute disk-types list 來看看 機器型號為 f1-micro, 不知道類型可以跑 gcloud compute machine-types list 來看看 tags 用來當作該 instance 的一個識別，等等開防火牆的時候會用到 zone 指定該 instance 的地區, 有些資源只有相同 zone 或者 region 可以取用，要注意 如下: gcloud compute instances create example-instance-1 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=10GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=example-instance-1,http-server,https-server \\--zone=asia-east1-a 開啟後，我們先來產 key ssh-keygen -t rsa -b 4096 -C &quot;root@example&quot; 假設 key 的名稱為 example cat example.pub &gt; instanceSSHConfig &amp;&amp; vim instanceSSHList 在最前面加上 root, 格式如下： [USERNAME]:ssh-rsa [KEY] [USERNAME] 我們只有一把 key 獲得 instance 名稱 gcloud compute instances list 新增 public key 到 instance(這邊請注意，這個指令會替換掉這個 instance 在 GCP 的 SSH key, 換言之，這個檔案裡面沒有的 key 都會消失) gcloud compute instances add-metadata instanceName --metadata-from-file ssh-keys=instanceSSHList 安裝以下主要是安裝 nvm, node 版本v12.1.0, 以及 npm, 細節可以參考官方文件 apt-get update -y &amp;&amp; apt-get install curl -y &amp;&amp; curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash &amp;&amp; export NVM_DIR=&quot;$HOME/.nvm&quot; &amp;&amp; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; &amp;&amp; [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; &amp;&amp; nvm install v12.1.0 &amp;&amp; apt-get install npm -y Daemon接下來，以下為 Daemon 設定, 我們將使用 Daemon 來幫我們跑我們的服務，並且讓我們的服務在斷開的時候可以自動重啟 sudo vim /etc/init.d/serviceName #!/bin/sh### BEGIN INIT INFO# Provides: yourServiceName (optional)# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start daemon at boot time# Description: Enable service provided by daemon.### END INIT INFOdir=&quot;yourProjectLocation&quot;cmd=&quot;theCommandItRequiresToStartYourService&quot;user=&quot;root&quot;name=`basename $0`pid_file=&quot;/var/run/$name.pid&quot;stdout_log=&quot;/var/log/$name.log&quot;stderr_log=&quot;/var/log/$name.log&quot;get_pid() &#123; cat &quot;$pid_file&quot;&#125;is_running() &#123; [ -f &quot;$pid_file&quot; ] &amp;&amp; ps -p `get_pid` &gt; /dev/null 2&gt;&amp;1&#125;case &quot;$1&quot; in start) if is_running; then echo &quot;Already started&quot; else echo &quot;Starting $name&quot; cd &quot;$dir&quot; export NODE_ENV=test if [ -z &quot;$user&quot; ]; then sudo $cmd &gt;&gt; &quot;$stdout_log&quot; 2&gt;&gt; &quot;$stderr_log&quot; &amp; else sudo -u &quot;$user&quot; $cmd &gt;&gt; &quot;$stdout_log&quot; 2&gt;&gt; &quot;$stderr_log&quot; &amp; fi echo $! &gt; &quot;$pid_file&quot; if ! is_running; then echo &quot;Unable to start, see $stdout_log and $stderr_log&quot; exit 1 fi fi ;; stop) if is_running; then echo -n &quot;Stopping $name..&quot; kill `get_pid` for i in 1 2 3 4 5 6 7 8 9 10 # for i in `seq 10` do if ! is_running; then break fi echo -n &quot;.&quot; sleep 1 done echo if is_running; then echo &quot;Not stopped; may still be shutting down or shutdown may have failed&quot; exit 1 else echo &quot;Stopped&quot; if [ -f &quot;$pid_file&quot; ]; then rm &quot;$pid_file&quot; fi fi else echo &quot;Not running&quot; fi ;; restart) $0 stop if is_running; then echo &quot;Unable to stop, will not attempt to start&quot; exit 1 fi $0 start ;; status) if is_running; then echo &quot;Running&quot; else echo &quot;Stopped&quot; exit 1 fi ;; *) echo &quot;Usage: $0 &#123;start|stop|restart|status&#125;&quot; exit 1 ;;esacexit 0 若發現找不到 service 的話，那需要重新載入 daemon sudo systemctl daemon-reload 記得更改權限，讓 deamon 可以執行 sudo chmod 755 serviceName 開啟自動重啟，當 VM 重啟時，服務會跟著重啟 sudo systemctl enable serviceName Daemon 的名稱在此範例中，會設置的跟專案名稱一樣 CI/CDGitlab variables setting 我們將使用 Gitlab 的 pusher 來做 CI/CD 的部分，所以這邊先建立一組 ssh key, 並且在 gitlab 中設定為 $SSH_PRIVATE_KEY ssh-keygen -t rsa -b 4096 -C &quot;root@deploy&quot; Gitlab yaml config file下面我們會開始設定 Gitlab 的 pusher config yaml 檔案在我們的專案中： vim .gitlab-ci.yml # This file is a template, and might need editing before it works on your project.# Official framework image. Look for the different tagged releases at:# https://hub.docker.com/r/library/node/tags/# 在 Docker 內部，我們要使用的環境 imageimage: node:8# This folder is cached between builds# http://docs.gitlab.com/ce/ci/yaml/README.html#cache# cache 可以讓我們使用在所有的 buildcache: paths: - node_modules/stages:- build- deploy# 只是個名字npm-build: stage: build script: # 刪掉 node_modules, 安裝最新版的 npm, 並更新 project 裡頭的 npm 套件 - rm -rf node_modules/ &amp;&amp; npm i npm@latest -g &amp;&amp; npm install # 只是個名字depoly-test:# 將在 `deploy` stage 做以下的事 stage: deploy script: # cfr. https://docs.gitlab.com/ee/ci/ssh_keys/README.html # Install ssh-agent if not already installed, it is required by Docker. # (change apt-get to yum if you use a CentOS-based image) # 如果 ssh-agent 不存在，更新 apt-get 並且安裝 openssh-client - &#x27;which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )&#x27; # Run ssh-agent (inside the build environment) # 當運行 ssh-agent -s 時，會輸出一些 command, 但是他們並還沒有被執行，所以必須使用 eval ，他可以用來執行迭代運算 - eval $(ssh-agent -s) # Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store # 將 $SSH_PRIVATE_KEY 加到 ssh agent - ssh-add &lt;(echo &quot;$SSH_PRIVATE_KEY&quot;) # For Docker builds disable host key checking. Be aware that by adding that # you are suspectible to man-in-the-middle attacks. # WARNING: Use this only with the Docker executor, if you use it with shell # you will overwrite your user&#x27;s SSH config. #- mkdir -p ~/.ssh #- &#x27;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&#x27; # In order to properly check the server&#x27;s host key, assuming you created the # SSH_SERVER_HOSTKEYS variable previously, uncomment the following two lines # instead. # 在 docker container 中，建立 .ssh 資料夾, 並設立權限 - mkdir -m 700 -p /root/.ssh # 使用 gz 格式來將位於當層的專案資料夾整個壓縮，並將壓縮檔丟到上一層目錄去 - tar zcf ../$CI_PROJECT_NAME.tar.gz ./ # 將壓縮檔丟到指定機器上的指定目錄 - scp -o StrictHostKeyChecking=no ../$CI_PROJECT_NAME.tar.gz root@35.201.171.244:/locationYouPrefer # 接下來，我們利用 ssh 到指定的機器，然後開始做以下的事 # 建立一個跟專案同名的資料夾 # 將剛剛打包好的檔案，解壓縮到這個資料夾內，並不顯示解壓縮訊息 # 更改專案資料夾的權限 # 進到資料夾中, npm rebuild, 並且打開事先設定好的 daemon service - ssh root@yourIP &quot;rm -rf /locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; mkdir -p locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; tar zxf locationYouPrefer/$CI_PROJECT_NAME.tar.gz -C locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; chmod -R 655 locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; cd locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; npm rebuild &amp;&amp; /etc/init.d/$CI_PROJECT_NAME restart&quot; # 以上的 deploy stage 唯有在你指定的 branch 觸發 only: - branchYouPrefer 結論到這邊，當我們 git push 到指定的 branch 時，就會觸發 gitlab 的 pusher 來達成自動部署。","link":"/zh-tw/gitlabCICDOnGCP/"},{"title":"Google Cloud Pub/Sub 初探 - Command Line","text":"概述Google Cloud Pub/Sub 是一個可以讓你再不同的應用以及服務之間交換事件資料的訊息服務。 藉由分離發送者以及接收者, 它提供了一個在獨立、不同的應用之間的安全、高可用的訊息傳遞服務。 Google Cloud Pub/Sub 遞送低延遲/持久的訊息服務, 並且被開發者們廣泛地使用在實作異步工作流程, 分派事件通知, 以及不同的程序以及裝置的資料串流。 在本教程中, 你將會實作以下動作。 學習 Pub/Sub 的基礎 建立, 刪除, 以及列出 Pub/Sub 主題 建立, 刪除, 以及列出 Pub/Sub 訂閱 發布訊息到一個主題 使用提取訂閱者來輸出各自的主題訊息 使用提取訂閱者以及不同的 flag 來輸出多個訊息 前提這是一個入們級別的教程。 如果你只有一點 Pub/Sub 的相關經驗或是完全沒有經驗都是 okay 的, 且本教程會教你基本的設定以及使用 GCP 服務 在本教程之前, 評估一下你 Pub/Sub 的熟練度。以下是一些更有挑戰性的教程, 他們可以讓你使用你的 Pub/Sub 的知識在不同的 GCP 服務以及使用情境。 Dataflow: Qwik Start - Templates Building an IoT Analytics Pipeline with Google Cloud Platform Scanning User-generated Content Using the Cloud Video Intelligence and Cloud Vision APIs如果你想要從 Google Cloud 主控台使用 Pub/Sub, 別錯過這個教程： Google Cloud Pub/Sub: Qwik Start - Console 一旦你準備好了, 往下滑並且依照以下的步驟來設定你的教程環境。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Pub/Sub 基礎如同先前提到的, Google Cloud Pub/Sub 是一個異步的全同訊息服務。 這是三個會常出現在 Pub/Sub 用語： topics (主題), publishing (發佈), 以及 subscribing (訂閱) topic 是一個被分享的字串, 允許應用間通過一個共同的鏈來連結彼此。 發布者推送 (或 publish) 一條訊息到 Cloud Pub/Sub 主題 訂閱者向 topic 訂閱, 訂閱可以從訂閱來提取訊息, 或者可通過 webhooks 來推送訂閱。 每一個訂閱者必須在收到訊息後, 在一段設定的時間內給予確認 簡單來說, 一個生產者發布訊息到一個主題, 然後消費者對這個主題建立一個訂閱, 並且從這個訂閱收取訊息 Pub/Sub topic (主題)Pub/Sub 已被事先安裝在 Google Cloud Shell, 所以要使用這個服務不需要再安裝一次。 執行以下指令來建立一個主題, 名為 myTopic: cloudgcloud pubsub topics create myTopic 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 為了更佳的測試, 在建立兩個主題, 名為 Test1 以及 Test2 cloudgcloud pubsub topics create Test1 cloudgcloud pubsub topics create Test2 執行以下指令來檢視剛剛建立的主題： cloudgcloud pubsub topics list 輸出應會如下： name: projects/qwiklabs-gcp-3450558d2b043890/topics/myTopic---name: projects/qwiklabs-gcp-3450558d2b043890/topics/Test2---name: projects/qwiklabs-gcp-3450558d2b043890/topics/Test1 清除的時間到了。 執行以下指令來刪除 Test1 以及 Test2 cloudgcloud pubsub topics delete Test1 cloudgcloud pubsub topics delete Test2 再執行 gloud pubsub topics list 指令一次來確認主題已經被刪除了 cloudgcloud pubsub topics list 輸出應會如下： ---name: projects/qwiklabs-gcp-3450558d2b043890/topics/myTopic Pub/Sub subscription (訂閱)現在你已經準備好可以建立, 檢視, 刪除主題, 是時候試試看訂閱了 執行以下指令來建立對主題 myTopic 的訂閱, 名為 mySubscription cloudgcloud pubsub subscriptions create --topic myTopic mySubscription 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 再多增加兩個對 myTopic 的訂閱, 執行以下指令來建立 Test1 以及 Test2 訂閱 cloudgcloud pubsub subscriptions create --topic myTopic Test1 cloudgcloud pubsub subscriptions create --topic myTopic Test2 執行以下指令來列出對 topic 的訂閱 cloudgcloud pubsub topics list-subscriptions myTopic 輸出應會如下： --- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/Test2--- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/Test1--- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/mySubscription 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 現在刪除 Test1 以及 Test2 訂閱，執行以下指令: cloudgcloud pubsub subscriptions delete Test1 cloudgcloud pubsub subscriptions delete Test2 確認 Test1 以及 Test2 以及被刪除了, 再次執行 list-subscriptions cloudgcloud pubsub topics list-subscriptions myTopic 輸出應會如下： --- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/mySubscription Pub/Sub 發布以及提取單一訊息接下來, 你將會學習如何發布一個訊息到 Pub/Sub 主題 執行以下指令來發布訊息 &quot;hello&quot; 到你剛剛建立的主題 (myTopic): cloudgcloud pubsub topics publish myTopic --message &quot;Hello&quot; 再發布一些訊息到 myTopic。 執行以下指令 (將 &lt;YOUR NAME&gt; 替換成你的名字, 以及 &lt;FOOD&gt; 替換成一種你喜歡吃的食物): cloudgcloud pubsub topics publish myTopic --message &quot;Publisher&#x27;s name is &lt;YOUR NAME&gt;&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher likes to eat &lt;FOOD&gt;&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher thinks Pub/Sub is awesome&quot; 接下來, 使用 pull 指令來從主題取得訊息。 pull 是基於訂閱的指令, 也就是說這應該會運作正常, 因為早些時候你已經設定好了對主題 myTopic 的訂閱 mySubscription 使用以下指令來提取你剛剛從 Pub/Sub 主題發布的訊息 cloudgcloud pubsub subscriptions pull mySubscription --auto-ack 輸出應會如下： 在最後一個章節, 你將會學習如何使用 flag 來從主題提取多個訊息 Pub/Sub 從訂閱提取所有訊息因為在上一個範例中, 你已經從你的主題提取了所有的訊息, 所以現在加載更多訊息到主題 myTopic 執行以下指令： cloudgcloud pubsub topics publish myTopic --message &quot;Publisher is starting to get the hang of Pub/Sub&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher wonders if all messages will be pulled&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher will have to test to find out&quot; 增加一個 flag 到你的指令, 所以你可以在一個請求中輸出所有三筆訊息。 你可能沒有注意到, 但事實上你一直都在使用 flag: pull 指令中的 --auto-ack 就是一個你剛剛才用過的可以將你的訊息格式化成整齊的視窗的一個指令 limit 是另外一個 flag, 可以設定提取訊息數量的最高限制 cloudgcloud pubsub subscriptions pull mySubscription --auto-ack --limit=3 輸出應會如下： 現在你已經知道如何加 flag 到 Pub/Sub 的指令上來輸出大量的訊息, 你已經走在成為 Pub/Sub 大師的路上。 恭喜在本教程中, 你學到了 Pub/Sub 主題, 訂閱, 以及提取指令和 flag 的指令","link":"/zh-tw/googleCloudPubSubQwikStartCommandLine/"},{"title":"Google Cloud Pub/Sub 初探 - 控制面板","text":"概述Google Cloud Pub/Sub 是一個訊息服務，提供在不同的應用或服務之間，傳遞事件資料，資料的產生者發佈訊息到 Cloud Pub/Sub topic, 訂閱者可以經由訂閱拉回訊息，或是設定好，當某事件被觸發時，就觸發訂閱。 每個訂閱者必須在可設定的一段時間內確認收到訊息 你將會做什麼？ 設定一個 topic 來存放資料 訂閱一個 topic 來存取資料 發佈，然後經由訂閱者來消耗訊息 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 設定 Pub/Sub你可以使用 Google Cloud Shell 主控台來操作 Google Cloud Pub/Sub 要使用 Pub/Sub, 你建立一個 topic 來存放資料，以及一個訂閱來存取被發佈到 topic 的資料 點擊 Navigation menu &gt; Pub/Sub &gt; Topics 點擊Create a topic topic 必須是一個獨一無二的名字，在這個 lab 中，將你的 topic 取名為 MyTopic. 在 Create a topic 視窗中： 將你的 topic 取名為 MyTopic 將 Encryption 留為默認值 點擊 CREATE TOPIC 你已經建立了 topic 測試任務是否完成點擊Check my progress 來和對目前任務進度。如果你已經成功建立 Cloud Pub/Sub topic, 你會得到評價的分數 增加一個訂閱現在你將建立一個訂閱來存取 topic 在左邊的控制列點擊 Topics 回到 Topics 對話框, 在我們剛剛建立的 topic，在三個點的圖案處按一下，然後點擊 Create subscription 在 Add subscription to topic 對話框： 輸入 subscription 的名字，例如 MySub 將 Delivery type 設為 Pull 將其他選項都留為預設值 點擊 Create 你的訂閱被列在訂閱清單中 測試任務是否完成點擊Check my progress 來和對目前任務進度。如果你已經成功建立 Cloud Pub/Sub topic, 你會得到評價的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 一個發佈者的的應用，建立並且傳送訊息到 ___. 訂閱者的應用建立一個 ___ 到 topic 來取得訊息 topic, subscription topic, topic subscription, subscription subscription, topic Cloud Pub/Sub 是一個被設計為高度可靠以及可規模化的異步訊息服務 發佈訊息到 topic 在 Topics details 對話框的上方，點擊 PUBLISH MESSAGE。 你可能需要調寬瀏覽器的視窗來檢視 PUBLISH MESSAGE 選項 在 Message 欄位中輸入 Hello World, 然後點擊 Publish 檢視訊息要檢視訊息，你將需要使用 subscription (MySub) 來從 topic (MyTopic) 取得訊息 (Hello World) 在命令行輸入以下指令 gcloud pubsub subscriptions pull --auto-ack MySub 訊息將會出現在輸出的 DATA 欄位 你建立了 Pub/Sub topic，並且發佈到這個 topic, 建立了 subscription, 然後使用 subscription 來取得在 topic 的資料 恭喜完成本教程！","link":"/zh-tw/googleCloudPubSubQwikStartConsole/"},{"title":"如何在 AWS 上部署多個專案？","text":"建立一個AWS EC2 instance, 本文章使用的instance型號為 Amazon Linux 2 AMI (HVM), SSD Volume Type - ami-0d7ed3ddb85b521a6 連結到你的EC2 instance, 輸入：sudo vim /etc/httpd/conf.d/yourProjectName.conf 貼上下面的code &lt;VirtualHost *:443&gt; # port 443，給https用的 ServerName letussleep.space # 你的Domain名稱 DocumentRoot &quot;/var/www/html/yourLaravelProjectName/public&quot; # 你在EC2上的專案絕對路徑 SSLEngine on SSLCertificateFile /whateverLocationYouWant/certificate.crt SSLCertificateKeyFile /whateverLocationYouWant/private.key SSLCertificateChainFile /whateverLocationYouWant/ca_bundle.crt # 簽署SSL簽證，分別對應你從從簽證網站上面取得的簽證檔案&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; # port 80 給 http用的 ServerName letussleep.space DocumentRoot &quot;/var/www/html/yourLaravelProjectName/public&quot; redirect / Https://letussleep.space # 當使用者使用http連接，重新導向到https&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;ServerName oldletussleep.space # 在同一個conf檔案裡頭，其實就可以部署不同的專案，只要把Domain name區分好DocumentRoot &quot;/var/www/html/yourProjectName/public&quot;&lt;/VirtualHost&gt; 雖然在同一個config檔案裡頭，只要設好domain name 以及不同的專案路徑就可以完成多專案部署，但是這樣難免混亂，所以個人偏好一個專案一個conf檔案。 所以只要重複上面的步驟，創一個新的config檔，並且輸入相對應的資訊，最後輸入sudo service httpd restart 連到你的Domain, 應該已經沒問題了！","link":"/zh-tw/howToDeployMultipleProjectOnAWS/"},{"title":"如何設置Git的個人資訊？","text":"大家好，我是Ray! 今天要來跟大家分享，如何配置Git的基本資訊。 讓我們新增一行敘述在現有的example1.html 的檔案裡，如下： &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;p&gt;This is the example commit for git commit -am&lt;/p&gt;&lt;p&gt;This is the example1 for git configuration&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Git commit -am “Before configuration” Git log 各位可以看一下上面我們我們剛剛所commit的Author 資料。 現在加入另一段敘述在example1.html檔案內，如下： &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;p&gt;This is the example commit for git commit -am&lt;/p&gt;&lt;p&gt;This is the example1 for git configuration&lt;/p&gt;&lt;p&gt;This is the example after git configuration&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 現在讓我們來定義git 配置的使用者資訊： 輸入 Git config --global user.name RayGit config --global user.email example@email.com 上面的Ray以及example@email欄位請填你們自己的！ 接下來輸入 Git commit -am “after configuration” Git log 由上面的截圖可以看到，我們已經成功的配置的使用者的名稱還有信箱改掉了！ 這邊補充說明，這裡使用–global進行配置，所以這裡的設定是全域通用的，簡單來說，你電腦內的所有資料夾都套用這個資料，之後有機會我們再介紹如何針對單一資料夾進行更改。 今天的分享就到這裡了，我們明天見！","link":"/zh-tw/howToConfigureGit/"},{"title":"怎麼在 Laravel 中, 利用 AWS SES 發郵件?","text":"# 前言你好, 我是不學會死的後端工程師, Ray 本篇記錄如何使用 Laravel 與 AWS SES 來發送 email 版本: Laravel 8 # 申請 SES (Simple Email Service) 服務 # 驗證 EmailSES Service 在剛使用時, 會處於 SandBox 狀態, 在此狀態下, 除了會有每日發送 email 數量以及頻率的限制之外, 所有收件方都必須經過驗證, 因此先將自己的信箱輸入, 接著會收到確認信, 點擊確認後該信箱就可以作為之後測試用了 到 AWS SES 主控台, 左方 Email Addresses, 然後進去點選 verify a new email address 進行驗證 # 建立擁有 SES 權限的 IAM User要使用 Laravel 存取 SES 服務, 必須要有相對應的身份以及權限才行, 這樣 AWS 才知道你是誰, 用超過才可以跟你收錢所以需要建立一個擁有 (SES Full Access) 的 IAM 使用者 新增使用者 命名使用者, 並只勾選程式設計方式存取即可, 因為該 IAM User 並不需要登入 從現有政策中, 賦予該 IAM User SES Full Access 在建立 User 後, 下載 Access ID 以及 Access Secret, 之後設定 Laravel env 檔時會用到 # 申請移出沙盒提交‘移出沙盒’申請, 約24小時內會解封。否則寄信數量跟頻率都會被很大程度上限制住, 且任何收件人都必須要經過AWS驗證。 在沙盒內時, 各方面會受到限制 申請移出沙盒, 不過需要經過審查, 有越來越嚴格的趨向 QQ 若審核成功, 會變成 Production Enabled 的狀態 # Laravel 專案# 套件安裝composer require guzzlehttp/guzzlecomposer require aws/aws-sdk-php # .env 設定MAIL_MAILER=sesMAIL_HOST=smtp.mailtrap.ioMAIL_PORT=2525MAIL_USERNAME=nullMAIL_PASSWORD=nullMAIL_ENCRYPTION=nullMAIL_FROM_ADDRESS=發送方信箱MAIL_FROM_NAME=&quot;$&#123;APP_NAME&#125;&quot;AWS_ACCESS_KEY_ID=yourAwsAccessIdAWS_SECRET_ACCESS_KEY=yourAwsAccessSecretAWS_DEFAULT_REGION=yourAwsDefaultRegion # 測試這邊採用 php artisan tinker 來測試 php artisan tinker;// 輸入Mail::send(&#x27;welcome&#x27;, [], function($message) &#123; $message-&gt;to(&#x27;receiverEmail&#x27;)-&gt;subject(&#x27;Testing mails&#x27;);&#125;); # 碰到的問題當串接金流時, 使用 ngrok 來測試, 在收到金流服務商的 callback 時, 只要執行到發送 mail 的地方就報錯, 錯誤訊息如下： &quot;message&quot;: &quot;Expected response code 250 but got code \\&quot;530\\&quot;, with message \\&quot;530 5.7.1 Authentication required\\r\\n\\&quot;&quot;,&quot;exception&quot;: &quot;Swift_TransportException&quot;,&quot;file&quot;: &quot;/Users/ray/code/FacebookOptimizedSellingSystem/vendor/swiftmailer/swiftmailer/lib/classes/Swift/Transport/AbstractSmtpTransport.php&quot;,&quot;line&quot;: 457,&quot;trace&quot;: [ 後來使用 valet share, 就不會有這個問題, 原本是使用 php artisan serve --port=myPort, 然後 ngrok http myport 雖然最後問題解決了, 但原因未明, 若有高人知曉, 希望可以給個學習機會。","link":"/zh-tw/howToSendMailViaAWSSES/"},{"title":"如何經由 PHP 導入中文到 MySQL 而不會出現亂碼？","text":"如何正確的導入中文而不會出現亂碼？ 大家好, 我是 Ray!今天我想跟大家分享 CSV 檔案匯入 MySQL 的更多細節部分, 像是如何正確的導入中文字而不會出現亂碼。 首先, 先講 PHP 的部分： &lt;?phpmysqli_set_charset($dbc,&quot;utf8&quot;); 在連接資料庫之後, 請記得一定要加入上面的 code, 目的是明確來往資料庫的資料編碼格式。 檔案部分： 首先, 打開 Excel, 然後開啓新檔案 接下來, 點選 Data, 並且選取 From text 這邊請選擇使用分界符號 這裏選擇使用逗號來做分隔 最後選擇一般即可 接下來爲, 資料庫部分： 如果你是使用 Sequel Pro, 那請務必在創建表格時點選 UTF-8, 如下圖 如果你是使用終端機部分, 如下圖, 請記得要在創立表格的同時賦予 utf8 的編碼。 如果依然在匯入之後顯示亂碼, 請確認 column 的編碼是否爲 utf-8 基本上如果以上的細節都有注意到, 應該就可以順利的導入中文, 並且成功的在資料庫內顯示中文, 如下圖： 大家寫code愉快！","link":"/zh-tw/howToImportChineseIntoDatabaseWithoutGarble/"},{"title":"如何省略 git add?","text":"大家好，我是Ray! 今天要跟大家分享，git commit -am 如之前的文章跟大家分享的，每次在commit 之前，我們需要使用git add來明確要commit 的進度，然後commit的同時我們需要留下屬於該commit的訊息。 有些人覺得這樣的設計很好，然而有些則不然，他們覺得這樣有點麻煩。 不管您是屬於哪一派，今天我要跟大家分享，如何將這兩個步驟化為一個動作。 首先，讓我們新增一行code在我們現有的檔案example1.html，如下： &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;p&gt;This is the example commit for git commit -am&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 現在輸入 git status 如下圖，example1.html已經被修改了，必且如果要commit，我們需要先git add來明確要commit的進度。 依照之前的文章分享，我們需要先git add，然後git commit，並留下屬於此次commit的訊息來完成這次的commit。 現在讓我們來試試看比較簡單一點的方法吧！ 輸入git commit -am &quot;example for git commit -am&quot; 輸入git status 確認狀況 輸入Git log 如下圖，我們已經成功的commit了！ 這邊要跟大家更進一步解釋一下git add的功能。 當我們今天新增一個新的檔案時，我們需要將該檔案加入“追蹤”的檔案清單中，我們使用git add 來達到這個功能。 當“已經入追蹤”的檔案有更改，且我們要做commit時，我們需要更新該檔案將被commit記錄下來的進度！簡單來說，就是訂出將被commit的資料範圍，而這時我們也是使用git add來更新這個進度。 所以說啦，如果今天我們新增一個檔案，且該檔案從未被加入“追蹤”清單中，那這個時候git commit -am 是不會對這個檔案起作用的！ 有一點請大家注意，-a 在這裡代表automatic，它會自動的更新”所有已經加入追蹤清單且有更改”的檔案！ 看完今天的分享，大家是不是對git有更進一步地瞭解了呢？ 我們明天見！","link":"/zh-tw/howToSkipGitAdd/"},{"title":"如何使用 git checkout","text":"大家好，我是Ray! 還記得我們上次到了哪裡了嗎？看完上面的圖片有沒有讓你回想些什麼呢？ 沒錯，上次的git介紹我們從初始化開始，並且建立一個名為example1.html的檔案，然後完成了我們第一個存擋！ 如同之前提到的，我說git讓我們再存擋後，如果我們有需要的話，我們可以隨時地回到任何一個我們用git做的存擋點，今天我將跟大家分享如何回到存擋點，並且在存擋點之間自由的切換。 現在，讓我們在檔案內加入下面highlight的一段 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 然後我們到command line，輸入git status 你應該會看到如下圖，如下圖所示，git 顯示example1.html已經被修改過了。 如上一篇提到的，再做存擋之前，我們必須要先使用git add 來指定我們想要存擋的進度，所以 輸入git add example1.html 輸入git status 如上圖，我們已經指定了要存擋的進度 現在輸入git commit 並記錄訊息”New paragraph added in example1.html file” 完成後輸入git status確認一下狀態 然後git log 現在我們可以看到我們的第二個commit如下圖： 好啦，接下來我們來切換回第一個記錄點 git log 的功能是顯示我們所有記錄點的歷史，我們可以經由log裡面提供的資料自由的切換於不同的紀錄點。 輸入 git checkout b45934852da471efbbbc52b5a119e8723fb01866 這是我的版本，你們的版本會是一串不同的數字 如下圖所示，我們現在已經在一個第一個記錄點。 現在可以打開我editor查看，我們新增加的We add a new paragraph on the first example 已經不見了，此時版本恢復到我們第一個記錄點的狀態，不管我們是否有另外在editor做任何的紀錄。 那要如何回到我們的最新的紀錄點呢？ 輸入git checkout master 如上圖，我們現在已經回復到我們最新的紀錄點啦！ 現在打開我們的editor做確認，登登！ 原本消失的new paragraph 又出現啦！ 是不是很神奇呢？ 以上是今天的分享，希望可以讓大家對Git有更深的了解，我們明天見！","link":"/zh-tw/howToUseCheckout/"},{"title":"HTTP 學習筆記","text":"# 前言身為一名非本科後端工程師, 如果只會開發, 連網路的全貌都看不清的話, 那也太遜了吧？ 其實每個人興趣都不同, 上面跟大家開個小玩笑, Ray 豈敢在眾大神面前造次？ 本篇主要是 HTTP 的學習筆記, 所以不會分什麼章節, 會直接以最原始的 Q &amp; A 的形式把知識記錄下來 # 參考書目 HTTP: The Definitive Guide MDN web docs 網路 # Questions and AnswersHTTP CORS 當中, 當我 Access-Control-Allow-Origin 不是使用 wildcard, 而是指定一個特定的 origin, 並且這個 origin 可能會變動時, 需要加上 vary header 如下 example, 為什麼？ Example:Access-Control-Allow-Origin: https://mozilla.orgVary: Origin Answer:防止 browser cache HTTP CORS 當中, 當 server side 要定義允許的 header 時, 可使用哪個 header?Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Headers HTTP CORS 當中, 當 request 的 header 帶著 cookie 時, server side 的 Access-Control-Allow-Origin, 必須要設為什麼, 可設為 * 嗎？要有明確的 origin, 不可設為 * HTTP CORS 當中, 當 request 為帶著 cookie 的 simple request 時, 如果 server side 的 response 少了哪個 header, 瀏覽器會 reject 這個 response？Access-Control-Allow-Credentials: true HTTP CORS 當中, 下面的 header 意思是？ Example:Access-Control-Allow-Origin: http://foo.exampleAccess-Control-Allow-Methods: POST, GET, OPTIONSAccess-Control-Allow-Headers: X-PINGOTHER, Content-TypeAccess-Control-Max-Age: 86400 Answer:// 允許的來源Access-Control-Allow-Origin: http://foo.example// 允許的 methodAccess-Control-Allow-Methods: POST, GET, OPTIONS// 允許的 headerAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type// 回給此 preflight request 的 response 將會 cache 多久, 意思就是在此時間內不需在發 preflightAccess-Control-Max-Age: 86400 HTTP CORS 當中, 對於 server 端來說, 如果要允許任何 domain 都可以存取資源, 需要定義哪一個 header?Access-Control-Allow-Origin:* HTTP CORS 當中, 哪三種 content type 符合 simple request? application/x-www-form-urlencoded mutipart/form-data text/plain HTTP CORS 當中, 哪三種 HTTP method 符合 simple request? GET HEAD POST HTTP CORS 當中, 若 client 與 server 不同源, 在真正的 client request 之前, Browser 會發一個什麼 request 來取得 server side 允許非同源的各項要求？option request HTTP CORS 當中, ORIGIN 由哪三樣定義? domain protocol port request 的 content/type 中, application/x-www-form-urlencoded 會將所有的參數都視為甚麼型別？？string request 的 content/type 中, application/json vs application/x-www-form-urlencoded, 最大的差異是？型別 request 的 content/type 中, application/json 每次都會發送 preflight request, 為什麼？因為不在 CORS simple request 的 scope 內 request 的 content/type 中, application/json vs application/x-www-form-urlencoded, 哪種的字元數較節省？application/json request 的 content/type 中, application/json vs application/x-www-form-urlencoded, 哪種格式較為複雜？application/x-www-form-urlencoded request 的 content/type 中, application/json vs application/x-www-form-urlencoded, 哪種較為被大公司使用？application/x-www-form-urlencoded request 的 content/type 中, application/json vs application/x-www-form-urlencoded, 哪種不在 CORS 的 simple request scope 內？application/json 當我在 http://test.com, 但其中一個按鈕的動作如下 example code, 它的意思是？ Example:&lt;iframe style=&quot;display:none&quot; name=&quot;csrf-frame&quot;&gt;&lt;/iframe&gt;&lt;form method=&#x27;POST&#x27; action=&#x27;https://small-min.blog.com/delete&#x27; target=&quot;csrf-frame&quot; id=&quot;csrf-form&quot;&gt; &lt;input type=&#x27;hidden&#x27; name=&#x27;id&#x27; value=&#x27;3&#x27;&gt; &lt;input type=&#x27;submit&#x27; value=&#x27;submit&#x27;&gt;&lt;/form&gt;&lt;script&gt;document.getElementById(&quot;csrf-form&quot;).submit()&lt;/script&gt; Answer:是 CSRF attack按下按鈕後, 會執行 form 的 POST, 刪除 https://small-min.blog.com 網站的 id 3, 但因為 target 是 name 為 csrf-frame 的 iframe, 而 iframe 的 style 為 display:none, 所以使用者不會發現有什麼異常 防範 CSRF 的方法中, 何謂 Double Submit Cookie?由 server 產生一組隨機的 token, 同時也讓 client side 設定一個名叫 csrftoken 的 cookie, 值也是同一組 token。當使用者按下 submit 的時候，server 比對 cookie 內的 csrftoken 與 form 裡面的 csrftoken, 檢查是否相等假設現在攻擊者想要攻擊，他可以隨便在 form 裡面寫一個 csrf token，這當然沒問題，可是因為瀏覽器的限制，他並不能在他的 domain 設定 small-min.blog.com 的 cookie 啊！所以他發上來的 request 的 cookie 裡面就沒有 csrftoken，就會被擋下來。 防範 CSRF 的方法中, 當我今天是 SPA 架構時, 如何實施 Double Submit Cookie?由 client 端產生一個 token 寫到 form, 也將這個 token 寫到 cookie, 當 server 端收到 request 後, 同時驗證 request 跟 cookie 內的 token 是否相同如果是第三方送出 request 的話, 他或許可以自己在 request 中生成 token, 但他猜不到 cookie 中的 token, 也無法改變 cookie 的值, 因此可防範 CSRF JWT token 主要含有哪三大部分？header, payload, signature, 用 . 串接起來 JWT token 的 header 通常包含哪兩個資訊？type, algorithm JWT token 的 header 以及 payload 會使用哪種格式編碼？base64Url JWT token 的 signature 如何產生？將 encoded header, encoded payload, 以及一段自定義的 secret, 用 header 中指定的 algorithm 加密而得 JWT token 的 signature 作用為何？驗證 JWT token 是否有被更動過, 當 server 端收到後會使用 server 才有的 secret 以及 header 以及 payload, 透過 header 中指定的 algorithm 加密, 如果得到的 signature 與 request 帶上的 signature 一樣, 代表內容沒有被更動過, 要是結果不相符, 要嘛是 header 或 payload 被更動過, 要嘛是 secret 不正確 Browser 中, cookie 可以使用 JS 存取嗎？驗證 JWT token 是否有被更動過, 當 server 端收到後會使用 server 才有的 secret 以及 header 以及 payload, 透過 header 中指定的 algorithm 加密, 如果得到的 signature 與 request 帶上的 signature 一樣, 代表內容沒有被更動過, 要是結果不相符, 要嘛是 header 或 payload 被更動過, 要嘛是 secret 不正確 JWT token 的 claim 又分為哪三種？registered claim, public claim, private claim","link":"/zh-tw/http/"},{"title":"Tree 實作 in PHP","text":"# 前言出來混總是要還的, 當本科生在學校學習資料結構時, 我壓根兒就沒聽過這東西。 不過俗話說的好 Genius is 1% inspiration and 99% perspiration 缺了不要緊, 補著補著, 早晚有一天補回來。 # 概念介紹在開始之前, 如果你從未接觸過 Tree, 那可以參考 Tree 簡介 # 情境模擬假設, 我們有一間公司, 公司裡頭有不同階層職位的員工最上面是 CEO, 再往下是 CXO 等級(像是 CTO, CFO, CMO, UFO …等等, 咦？)的, 而在往下是其他等級的在此, 我們並未限制 node 的 degree (不知道 degree 是啥的麻煩參閱一下上面 Tree 簡介), 即每個 node 都可以有多個 children不囉唆, 直接看範例： # 實作範例# Tree Node exampleclass TreeNode &#123; public $data = NULL; public $children = []; public function __construct(string $data = NULL) &#123; $this-&gt;data = $data; &#125; public function addChildren(TreeNode $node) &#123; $this-&gt;children[] = $node; &#125; &#125; 在上面的 example, 我們 implement 了 PHP 版本的 tree node, 也就是 tree 中眾多 node 的其中一個 $data property 表示此 node 儲存的 data, 可供顯示或辨別用 $children property 表示此 node 的 children 都是哪一些 node addChildren method 可以讓每個 node 都有能力建立自己的 children # Node exampleclass Tree &#123; // 帶入一個 node, 必須是 TreeNode 的 instance, 便可以 travserse 此 node // 以下的所有 children 以及 descendent public $root = NULL; public function __construct(TreeNode $node) &#123; $this-&gt;root = $node; &#125; public function traverse(TreeNode $node, int $level = 0) &#123; if ($node) &#123; // $level 為多少, 前面就會有幾個 &quot;_&quot;, 以表示階層 echo str_repeat(&quot;-&quot;, $level); echo $node-&gt;data . &quot;\\n&quot;; // 取出當前 node 的所有 children // 並重複 traverse 這個 method, 沒錯, 這是一個遞迴 // 每往下一層, 會將 $level + 1, 以表示階層 foreach ($node-&gt;children as $childNode) &#123; $this-&gt;traverse($childNode, $level + 1); &#125; &#125; &#125; &#125; 在上面的 example 中, 我們使用 PHP implement 簡單的 Tree class 任何帶入該 Tree class 的 node, 便是該 tree 的 root node 透過 traverse method, 我們可以列出自 root node 以下所有的 descendent nodes # Illustrating example&lt;?php// 建立一個 tree node, 並儲存 data &quot;CEO&quot; 以作之後識別$ceo = new TreeNode(&quot;CEO&quot;); // 如上所敘, $ceo 現在為 $tree 的 root node$tree = new Tree($ceo); // 分別建立多個 tree node$cto = new TreeNode(&quot;CTO&quot;); $cfo = new TreeNode(&quot;CFO&quot;); $cmo = new TreeNode(&quot;CMO&quot;); $coo = new TreeNode(&quot;COO&quot;); // 這邊建立階層關係, 將多個 tree node 加入 $ceo 的 children property 當中$ceo-&gt;addChildren($cto); $ceo-&gt;addChildren($cfo); $ceo-&gt;addChildren($cmo); $ceo-&gt;addChildren($coo); // 繼續建立更多 tree node$seniorArchitect = new TreeNode(&quot;Senior Architect&quot;); $softwareEngineer = new TreeNode(&quot;Software Engineer&quot;); $userInterfaceDesigner = new TreeNode(&quot;User Interface Designer&quot;); $qualityAssuranceEngineer = new TreeNode(&quot;Quality Assurance Engineer&quot;); // 替新的 tree node 分派階層關係$cto-&gt;addChildren($seniorArchitect); $seniorArchitect-&gt;addChildren($softwareEngineer); $cto-&gt;addChildren($qualityAssuranceEngineer); $cto-&gt;addChildren($userInterfaceDesigner); // 最後, traverse 會將階層關係列出$tree-&gt;traverse($tree-&gt;root); 執行結果: CEO-CTO--Senior Architect---Software Engineer--Quality Assurance Engineer--User Interface Designer-CFO-CMO-COO # 結語蛤？ 你還在啊？ 哦哦, 你以為下面還有是吧？ 沒有了啦哈哈。 我們已經完成了 PHP 版本的簡單 Tree 實作 # 參考來源PHP 7 Data Structures and Algorithms","link":"/zh-tw/implement-tree-with-php/"},{"title":"利用 PayPal 付款標準版 (PayPal Payment Standard) 以及 PayPal 即時付款通知 (PayPal IPN) 方式結帳付款","text":"前言有嘗試串接過 PayPal 的人都知道， PayPal 提供了好幾種方式供使用者串接使用。本篇記錄了： 如何使用 PayPal 付款標準版 (PayPal Payment Standard) 來付款結帳。 如用使用 PayPal 即時付款通知 (PayPal IPN) 來驗證付款結果。 如何在 PayPal 付款標準版 (PayPal Payment Standard) 中，自定義多個商品以及每個商品的明細，包含名稱、單價、數量。 在本文章中，我使用的是PHP的框架，Laravel因為此篇文章主要紀錄我這個專案大概的一個流程，雖說主題是金流部分，但難免會記錄到一些跟金流無關的部分。可以直接從’建金流訂單’的部分開始看即可。 驗證此節是整個流程的一個程序，跟金流較無關係，可以跳過。 $toBeValidatedCondition = [ &#x27;order_id&#x27; =&gt; &#x27;required|array&#x27;,];$failMessage = Helpers::validation($toBeValidatedCondition, $request);if ($failMessage) return Helpers::result(false, $failMessage, 400);if (!Helpers::checkIfIDExists($request, new Order(), &#x27;order_id&#x27;)) return Helpers::result(false, &#x27;The orders doesn\\&#x27;t exist&#x27;, 400);if (!Helpers::checkIfBelongToTheUser($request, new Order(), &#x27;order_id&#x27;)) return Helpers::result(false, &#x27;The order doesn\\&#x27;t belong to this user&#x27;, 400);$orders = Order::whereIn(&#x27;id&#x27;, $request-&gt;order_id)-&gt;get();if (Order::checkIfOrderPaid($orders)) return Helpers::result(false, &#x27;The order has already been paid&#x27;, 400);if (Order::checkIfOrderExpired($orders)) return Helpers::result(false, &#x27;The order has expired&#x27;, 400);if ($recipient-&gt;user_id !== User::getUserID($request)) return Helpers::result(false, &#x27;The recipient doesn\\&#x27;t belong to the user&#x27;, 400); 收集必要資訊因為我在做這個專案時，前端的時間比較吃緊一點，所以後端這邊決定除必要資訊之外，後端這邊將所有資訊搞定，盡量讓前端帶最少的資料，做最多的事。 $toBeSavedInfo = [ &#x27;total_amount&#x27; =&gt; Order::getTotalAmountForPayments($orders), &#x27;orders_name&#x27; =&gt; Order::getOrdersNameForPayments($orders), &#x27;merchant_trade_no&#x27; =&gt; time() . Helpers::createAUniqueNumber(), &#x27;merchant_trade_date&#x27; =&gt; date(&#x27;Y/m/d H:i:s&#x27;), &#x27;trade_desc&#x27; =&gt; &#x27;BuyBuyGo&#x27;, &#x27;quantity&#x27; =&gt; 1, &#x27;user_id&#x27; =&gt; User::getUserID($request), &#x27;payment_service&#x27; =&gt; $thirdPartyPaymentService, &#x27;expiry_time&#x27; =&gt; (new Carbon())-&gt;now()-&gt;addDay(1)-&gt;toDateTimeString(), &#x27;orders&#x27; =&gt; $orders, &#x27;mc_currency&#x27; =&gt; &#x27;TWD&#x27;, &#x27;ClientBackURL&#x27; =&gt; $request-&gt;ClientBackURL]; 分流點因為這個專案接了兩家金流，所以會需要一個地方來判定金流服務商 switch ($thirdPartyPaymentService-&gt;id)&#123; case 1: $error = (new AllPay)-&gt;make($toBeSavedInfo, $request, $recipient); if($error) return Helpers::result(false, $error,400); return (new AllPay())-&gt;send($toBeSavedInfo, $request); break; case 2: $error = (new PayPal)-&gt;make($toBeSavedInfo, $request, $recipient); if($error) return Helpers::result(false, $error, 400); $url = (new PayPal)-&gt;send($toBeSavedInfo, $request, $recipient); return Helpers::result(true, $url, 200); break;&#125; 建金流訂單在使用者按下付款之後，一張臨時的金流訂單會被建立。此訂單只介於你與你與 PayPal 之間，使用者不會接觸到這張訂單。因為會一次性的寫入兩張 table ，所以這邊會特別使用 Laravel 的 Transaction 來將資料處理，如果對 Laravel Transaction 有興趣的，可以參考我在另外一篇文章中，有一小段針對 Laravel Transaction 的解說 public function make(Array $toBeSavedInfo, Request $request, Recipient $recipient)&#123; DB::beginTransaction(); try &#123; $PayPal = new self(); $PayPal-&gt;user_id = $toBeSavedInfo[&#x27;user_id&#x27;]; $PayPal-&gt;payment_service_id = $toBeSavedInfo[&#x27;payment_service&#x27;]-&gt;id; $PayPal-&gt;expiry_time = $toBeSavedInfo[&#x27;expiry_time&#x27;]; $PayPal-&gt;merchant_trade_no = $toBeSavedInfo[&#x27;merchant_trade_no&#x27;]; $PayPal-&gt;total_amount = $toBeSavedInfo[&#x27;total_amount&#x27;]; $PayPal-&gt;trade_desc = $toBeSavedInfo[&#x27;trade_desc&#x27;]; $PayPal-&gt;item_name = $toBeSavedInfo[&#x27;orders_name&#x27;]; $PayPal-&gt;mc_currency = $toBeSavedInfo[&#x27;mc_currency&#x27;]; $PayPal-&gt;recipient_id = $recipient-&gt;id; $PayPal-&gt;save(); foreach ($toBeSavedInfo[&#x27;orders&#x27;] as $order) &#123; $order_relations = new OrderRelations(); $order_relations-&gt;payment_service_id = $toBeSavedInfo[&#x27;payment_service&#x27;]-&gt;id; $order_relations-&gt;payment_service_order_id = $PayPal-&gt;id; $order_relations-&gt;order_id = $order-&gt;id; $order_relations-&gt;save(); &#125; &#125; catch (Exception $e) &#123; DB::rollBack(); return &#x27;something went wrong with DB&#x27;; &#125; DB::commit();&#125; 建立提交付款申請的 URL這邊會用到很多 PayPal 付款標準版 (PayPal Payment Standard) 的 變量 (variable)，各種變量的使用可以參考這篇文章另外，因為 Ray 在做這個案子時，前端的時間上比較吃緊，所以 Ray 將所以非必要的資料全部由後端這邊處理，前端只帶入先前已建立的使用者訂單，後端從資料庫內調出所有的資料並提供給 PayPal public function send(Array $toBeSavedInfo, Request $request, Recipient $recipient)&#123; // 如果你是使用測試環境的話，請選 true $enableSandbox = env(&#x27;PAYPAL_SANDBOX_ENABLESANDBOX&#x27;); $paypalUrl = $enableSandbox ? &#x27;https://www.sandbox.paypal.com/cgi-bin/webscr&#x27; : &#x27;https://www.paypal.com/cgi-bin/webscr&#x27;; $data = []; // 設定PayPal 帳號, 請先到以下網址申請測試者帳號，商家跟一般用戶都要申請，這邊填入的是商家的帳號，所以買家付款後，金額會直接匯入這個帳號 // https://developer.paypal.com/developer/accounts/ // Set the PayPal account $data[&#x27;business&#x27;] = env(&#x27;PAYPAL_SANDBOX_MAIL&#x27;); // 此數值為前端帶入，使用者完成付款後，將可以經由此URL返回原本的服務中 // Set the PayPal return addresses, after the transaction is completed, the user could be back via this URL. $data[&#x27;return&#x27;] = $toBeSavedInfo[&#x27;ClientBackURL&#x27;]; // 在付款過程中，使用者可以選擇取消，並且經由此URL回到我們的服務 // During the transaction process on PayPal&#x27;s site, the user could cancel the transaction and go back via this URL. $data[&#x27;cancel_return&#x27;] = env(&#x27;PAYPAL_SANDBOX_CANCEL_URL&#x27;); // 在使用者完成交易之後， PayPal 會發一封 IPN 到我們在這邊指定的 listener ，然後我們可以依據此 IPN 來判定付款是否成功，然後做相對應的事 // After the transaction is completed, PayPal will send IPN message to this URL. $data[&#x27;notify_url&#x27;] = env(&#x27;PAYPAL_SANDBOX_NOFITY_URL&#x27;); // 這邊我們指定了每一樣商品的明細，包含單價，名稱，數量。 這邊要將這些明細顯示在 PayPal 的付款頁面上 // Set the details about the products being purchased, including the price for every individual // and currency so that these aren&#x27;t overridden by the form data. $i = 1; foreach ($toBeSavedInfo[&#x27;orders&#x27;] as $order) &#123; $data[&quot;item_name_$i&quot;] = $order-&gt;item_name; $data[&quot;item_number_$i&quot;] = $order-&gt;quantity; $data[&quot;amount_$i&quot;] = $order-&gt;total_amount; $i++; &#125; // 這邊指定了幣別，細節部分可以參考官網資料 // https://developer.paypal.com/docs/classic/api/currency_codes/ $data[&#x27;currency_code&#x27;] = $toBeSavedInfo[&#x27;mc_currency&#x27;]; // 這邊我們可以帶一個任何我們想要的值過去給 PayPal ，然後 PayPal 會再回傳 IPN 時一併帶回來，以本篇例子，我帶入的是我金流訂單的編號 // Add any custom fields for the query string. $data[&#x27;custom&#x27;] = $toBeSavedInfo[&#x27;merchant_trade_no&#x27;]; // 這邊我指定了收件人，否則 PayPal 會顯示測試帳號上的假的收件人資料。 在這邊設定後，我們可以在 PayPal 上顯示任何我們想要的收件人資料 // Add recipient&#x27;s information $data[&#x27;address_override&#x27;] = 1; $data[&#x27;country&#x27;] = $recipient-&gt;country_code; $data[&#x27;city&#x27;] = $recipient-&gt;city; $data[&#x27;address1&#x27;] = $recipient-&gt;others; $data[&#x27;zip&#x27;] = $recipient-&gt;postcode; $data[&#x27;first_name&#x27;] = $recipient-&gt;name; // 這邊的設定允許了我們上傳多個商品到 PayPal 的購物車裡面，所以可以分成多個商品並且一次性結帳。 // This setting allow to add multiple items with IPN method $data[&#x27;upload&#x27;] = &#x27;1&#x27;; $data[&#x27;cmd&#x27;] = &quot;_cart&quot;; // Add charset $data[&#x27;charset&#x27;] = &#x27;utf-8&#x27;; // 產生 query string // Build the query string from the data. $queryString = http_build_query($data); // 產生最終的要在 PayPal 建立付款請求的 URL，我們只需要將此URL回傳給前端，前端就可以直接利用這個 URL 將使用者導向付款頁面 // Build the URL to PayPal $url = $paypalUrl . &#x27;?&#x27; . $queryString; return $url; &#125; 使用者付款 使用者經由我們上面產出的 URL 到達 PayPal 付款頁面，這邊請先去申請測試帳號 到達付款頁面 這邊可以看到我們指定的商品明細，以及金額，選擇繼續 這邊可以看到我們指定的住址 交易成功，這邊可以看到全部的細節 驗證付款狀態使用者完成付款程序後， PayPal 會發一封 IPN 給我們，有關於 IPN 的規格可以參考官方文件 首先，我們先安裝 PayPal 的 官方 IPN CODE SAMPLES git clone https://github.com/paypal/ipn-code-samples 進到 php 的資料夾內 cd ipn-code-samples/php 接下來，我們複製PaypalIPN.php到我們的專案內， Ray 是把它放到 App 底下。 接著，在把 ipn-code-samples 裡頭的 cert 整個資料夾也放到 App 底下，大概如下圖 再來，我們到composer.json檔案中，在autoload-dev底下的files加入PaypalIPN.php這個檔案，如果沒有files的可能要自己建一個 &quot;autoload-dev&quot;: &#123; &quot;psr-4&quot;: &#123; &quot;Tests\\\\&quot;: &quot;tests/&quot; &#125;, &quot;files&quot;: [ &quot;app/Helpers.php&quot;, &quot;app/AllPay.Payment.Integration.php&quot;, &quot;app/PaypalIPN.php&quot; ]&#125;, 重新執行composer，在terminal的專案資料夾底下，執行 composer install 萬事俱備，只欠東風！ 接下來讓我們將example_usage_advanced.php的檔案裡頭的內容複製到你想要的地方，可以是你的Controller，也可以是你的某個class下面的一個function，如下：下面的 code 有點長，可以不必全看，除了我中文有特別解釋的地方之外，大概跟原本的sample一樣。 public function listen(Request $request) &#123; // 因為官方sample是去接 $_POST，所以這邊直接將Laravel的輸入轉成 POST ，想要自己改的人也可以哦 $_POST = $request-&gt;post(); // 這個資訊代表是否該交易已付款 $payment_status = $_POST[&#x27;payment_status&#x27;]; // 還記得我們之前帶過去的金流訂單號碼嗎？ $merchant_trade_no = $_POST[&#x27;custom&#x27;]; // 很重要，等等會用到 $txn_id = $_POST[&#x27;txn_id&#x27;]; $txn_type = $_POST[&#x27;txn_type&#x27;]; // 付款時間 $payment_date = Carbon::parse($_POST[&#x27;payment_date&#x27;])-&gt;setTimezone(&#x27;UTC&#x27;); // 總付款金額 $mc_gross = $_POST[&#x27;mc_gross&#x27;]; // 幣別 $mc_currency = $_POST[&#x27;mc_currency&#x27;]; $enable_sandbox = env(&#x27;PAYPAL_SANDBOX_ENABLESANDBOX&#x27;);// 這邊表示收款人的email，如果IPN裡頭的收款人不在這個清單裡面的話，驗證將會失敗// Use this to specify all of the email addresses that you have attached to paypal: $my_email_addresses = array(env(&#x27;PAYPAL_SANDBOX_MAIL&#x27;));// Set this to true to send a confirmation email: $send_confirmation_email = env(&#x27;PAYPAL_SANDBOX_SEND_CONFIRMATION_EMAIL&#x27;); $confirmation_email_address = &quot;buybuybuygogo@gmail.com&quot;; $from_email_address = &quot;test@gmail.com&quot;;// 選true的話，會自動記log// Set this to true to save a log file: $save_log_file = env(&#x27;PAYPAL_SANDBOX_SAVE_LOG_FILE&#x27;); $log_file_dir = storage_path() . &quot;/app/payment_logs&quot;;// Here is some information on how to configure sendmail:// http://php.net/manual/en/function.mail.php#118210// 這邊就是主要驗證的function $ipn = new PaypalIPN(); if ($enable_sandbox) &#123; $ipn-&gt;useSandbox(); &#125; $verified = $ipn-&gt;verifyIPN(); $data_text = &quot;&quot;; foreach ($_POST as $key =&gt; $value) &#123; $data_text .= $key . &quot; = &quot; . $value . &quot;\\r\\n&quot;; &#125; $test_text = &quot;&quot;; if ($_POST[&quot;test_ipn&quot;] == 1) &#123; $test_text = &quot;Test &quot;; &#125;// 上面提到的mail，就在這邊確認// Check the receiver email to see if it matches your list of paypal email addresses $receiver_email_found = false; foreach ($my_email_addresses as $a) &#123; if (strtolower($_POST[&quot;receiver_email&quot;]) == strtolower($a)) &#123; $receiver_email_found = true; break; &#125; &#125; date_default_timezone_set(&quot;America/Los_Angeles&quot;); list($year, $month, $day, $hour, $minute, $second, $timezone) = explode(&quot;:&quot;, date(&quot;Y:m:d:H:i:s:T&quot;)); $date = $year . &quot;-&quot; . $month . &quot;-&quot; . $day; $timestamp = $date . &quot; &quot; . $hour . &quot;:&quot; . $minute . &quot;:&quot; . $second . &quot; &quot; . $timezone; $dated_log_file_dir = $log_file_dir . &quot;/&quot; . $year . &quot;/&quot; . $month; $paypal_ipn_status = &quot;VERIFICATION FAILED&quot;; if ($verified) &#123; // 進到下面的if之後，表示已經驗證成功了，我們可以在驗證成功之後做一些該做的事 $paypal_ipn_status = &quot;RECEIVER EMAIL MISMATCH&quot;; if ($receiver_email_found) &#123; $paypal_ipn_status = &quot;Completed Successfully&quot;; $PayPal = (new PayPal())-&gt;where(&#x27;merchant_trade_no&#x27;, $merchant_trade_no)-&gt;first(); // 這邊檢查了幾項，大概如下： // 1. 檢查txn_id，為了避免這筆交易之前就已經有處理過。所以資料庫裡面如果已經有這個txn_id，將不予理會 // 2. 檢查mc_gross，總金額必須與我們金流訂單裡頭的金額相等 // 3. 檢查幣別，幣別必須與我們金流訂單裡頭的幣別相同 // 4. 檢查payment_status，該交易必需已經付款完成 if ((!PayPal::checkIfTxnIdExists($txn_id)) &amp;&amp; ($mc_gross == $PayPal-&gt;total_amount) &amp;&amp; ($mc_currency == $PayPal-&gt;mc_currency) &amp;&amp; ($payment_status == &#x27;Completed&#x27;)) &#123; // 將該txd_id新增到該金流訂單內，並更新該訂單數據，主要可被識別為已結單。 $PayPal-&gt;update([&#x27;txn_id&#x27; =&gt; $txn_id, &#x27;txn_type&#x27; =&gt; $txn_type, &#x27;payment_date&#x27; =&gt; $payment_date, &#x27;status&#x27; =&gt; 1, &#x27;expiry_time&#x27; =&gt; null]); $recipient = $PayPal-&gt;recipient; $orderRelations = $PayPal-&gt;orderRelations-&gt;where(&#x27;payment_service_id&#x27;, 2); // 更新完金流訂單後，根據該金流訂單取得相對應的使用者訂單，並更新使用者訂單狀態。 Order::updateStatus($orderRelations, $recipient); // 付款完成，寄mail通知使用者 Helpers::mailWhenPaid($PayPal, $orderRelations); &#125; &#125; &#125; elseif ($enable_sandbox) &#123; if ($_POST[&quot;test_ipn&quot;] != 1) &#123; $paypal_ipn_status = &quot;RECEIVED FROM LIVE WHILE SANDBOXED&quot;; &#125; &#125; elseif ($_POST[&quot;test_ipn&quot;] == 1) &#123; $paypal_ipn_status = &quot;RECEIVED FROM SANDBOX WHILE LIVE&quot;; &#125; if ($save_log_file) &#123; // Create log file directory if (!is_dir($dated_log_file_dir)) &#123; if (!file_exists($dated_log_file_dir)) &#123; mkdir($dated_log_file_dir, 0777, true); if (!is_dir($dated_log_file_dir)) &#123; $save_log_file = false; &#125; &#125; else &#123; $save_log_file = false; &#125; &#125; // Restrict web access to files in the log file directory $htaccess_body = &quot;RewriteEngine On&quot; . &quot;\\r\\n&quot; . &quot;RewriteRule .* - [L,R=404]&quot;; if ($save_log_file &amp;&amp; (!is_file($log_file_dir . &quot;/.htaccess&quot;) || file_get_contents($log_file_dir . &quot;/.htaccess&quot;) !== $htaccess_body)) &#123; if (!is_dir($log_file_dir . &quot;/.htaccess&quot;)) &#123; file_put_contents($log_file_dir . &quot;/.htaccess&quot;, $htaccess_body); if (!is_file($log_file_dir . &quot;/.htaccess&quot;) || file_get_contents($log_file_dir . &quot;/.htaccess&quot;) !== $htaccess_body) &#123; $save_log_file = false; &#125; &#125; else &#123; $save_log_file = false; &#125; &#125; if ($save_log_file) &#123; // Save data to text file file_put_contents($dated_log_file_dir . &quot;/&quot; . $test_text . &quot;paypal_ipn_&quot; . $date . &quot;.txt&quot;, &quot;paypal_ipn_status = &quot; . $paypal_ipn_status . &quot;\\r\\n&quot; . &quot;paypal_ipn_date = &quot; . $timestamp . &quot;\\r\\n&quot; . $data_text . &quot;\\r\\n&quot;, FILE_APPEND); &#125; &#125; if ($send_confirmation_email) &#123; // Send confirmation email mail($confirmation_email_address, $test_text . &quot;PayPal IPN : &quot; . $paypal_ipn_status, &quot;paypal_ipn_status = &quot; . $paypal_ipn_status . &quot;\\r\\n&quot; . &quot;paypal_ipn_date = &quot; . $timestamp . &quot;\\r\\n&quot; . $data_text, &quot;From: &quot; . $from_email_address); &#125;// Reply with an empty 200 response to indicate to paypal the IPN was received correctly header(&quot;HTTP/1.1 200 OK&quot;); &#125; 結語以上大概就是整個利用 PayPal 付款標準版 (Payment Standard) 來付款 ，然後經由 IPN 驗證的流程，流程大概如下： 買家完成付款 PayPal 發送 IPN Message 到 Listener Listener 回饋 HTTP 200 Response 到 PayPal Listener 將剛剛收到的 IPN Message 原封不動的回傳到 PayPal PayPal 驗證無誤後，回傳 Verified ，若驗證失敗，回傳 Invalid","link":"/zh-tw/implementATransactionViaPayPalIPN/"},{"title":"利用 Jenkins 在 AWS 上達到 CI","text":"前言以下為本篇記錄重點： 部署 jenkins 到 AWS EC2 的 Amazon Linux 2 AMI (HVM) 部署 jenkins 到 AWS EC2 的 Amazon Linux AMI 2018.03.0 (HVM) 當GitHub 上的進度有更新時，自動在 AWS EC2 執行 git pull 並與 GitHub 上的進度同步， 建立 EC2 instance 利用 SSH 連結到 AWS EC2 點擊 Connect ，並遵照指示操作 Amazon Linux 2 AMI (HVM)安裝sudo yum install java-1.8.0 sudo yum update -y sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key sudo yum install jenkins -y 設定sudo vim /etc/sysconfig/jenkins 並更改如右邊的參數 JENKINS_USER=&quot;root&quot; sudo service jenkins start sudo systemctl enable jenkins.service sudo vim /etc/sysconfig/jenkins 在瀏覽器設定 Jenkins 於瀏覽器輸入 http://yourPublicDNS:8080 於終端機輸入 sudo cat /var/lib/jenkins/secrets/initialAdminPassword 複製密碼以登入 安裝建議的插件 創立帳號 存檔並登入 到Jenkins管理頁面 安裝GitHub插件 開始一個自由專案 到設定的地方 輸入專案 url 選取 git , 並填入 git 資料夾的 url 勾選 GitHub hook trigger for GITScm polling 輸入客製化的shell script如果你的 jenkins 跟你的專案在同一台電腦的話 ssh -i /root/.ssh/yourKey.pem ec2-user@127.0.0.1 &quot;cd /var/www/html/yourProjectName;git reset @^ --hard;git pull;/usr/local/bin/composer install;php artisan migrate --force;&quot; 設定 GitHub 到 GitHub 的設定頁面 建立一個 webhook ，如下: Amazon Linux AMI 2018.03.0 (HVM)安裝sudo yum update -y sudo yum remove java-1.7.0-openjdk sudo yum install java-1.8.0 sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key sudo yum install jenkins -y 設定sudo vim /etc/sysconfig/jenkins 修改為 JENKINS_USER=&quot;root&quot; sudo service jenkins start 當 Server 重啟時，自動啟動 jenkinssudo chkconfig jenkins on 在瀏覽器設定 Jenkins 於瀏覽器輸入 http://yourPublicDNS:8080 於終端機輸入 sudo cat /var/lib/jenkins/secrets/initialAdminPassword 複製密碼以登入 安裝建議的插件 創立帳號 存檔並登入 到 Jenkins 管理頁面 安裝 GitHub 插件 開始一個自由專案 到設定的地方 輸入專案url 選取 git , 並填入 git 資料夾的 url 勾選 GitHub hook trigger for GITScm polling 輸入客製化的 shell script如果你的 jenkins 跟你的專案在同一台電腦的話 ssh -i /root/.ssh/yourKey.pem ec2-user@127.0.0.1 &quot;cd /var/www/html/yourProjectName;git reset @^ --hard;git pull;/usr/local/bin/composer install;php artisan migrate --force;&quot; 設定 GitHub 到 GitHub 的設定頁面 建立一個 webhook ，如下:","link":"/zh-tw/implementCIWithJenkinsOnAWS/"},{"title":"InfluxDB 學習筆記","text":"前言InfluxDB 學習筆記，內容未整理，學到什麼記什麼 CLICLI 中使用 where clausemeasurement 的 double quotes &quot; 是必要的，但需要 escape influx -execute &quot;select * from \\&quot;netdata.ipv4.packets.delivered\\&quot; WHERE host = &#x27;netdata&#x27; AND time &gt; now() - 1m&quot; -database &#x27;opentsdb&#x27; 定時清理資料庫可將以下的 command 寫成 shell script, 用 crontab 執行 influx -execute &quot;delete WHERE time &lt; now() - 1h&quot; -database &#x27;opentsdb&#x27; 串接 Node.js安裝npm install --save influx 串接檔範例module.exports = (() =&gt; &#123; const Influx = require(&#x27;influx/lib/src/index&#x27;); const Netdata = new Influx.InfluxDB(&#123; database: &#x27;opentsdb&#x27;, username: &#x27;&#x27;, password: &#x27;&#x27;, // 預設 port 號會自動設定為 8086 hosts: [&#123; host: &#x27;IP&#x27; &#125;], &#125;); // 在設定檔中新增 method Netdata.getData = async (measurement, host, time = &#x27;1m&#x27;) =&gt; &#123; let toBeReturnedObject = []; let result = await Netdata.query( `select * from &quot;$&#123;measurement&#125;&quot; WHERE host = &#x27;$&#123;host&#125;&#x27; AND time &gt; now() - $&#123;time&#125;` ); result.map(dot =&gt; &#123; let object = &#123; host: dot.host, value: dot.value, time: Number(dot.time.getNanoTime()) &#125;; toBeReturnedObject.push(object); &#125;); return toBeReturnedObject; &#125;; return Netdata;&#125;); require 串接檔 後面需加上 ();const Netdata = require(&#x27;../models/netdatadb&#x27;)(); SHOWSHOW TAG VALUESSHOW TAG VALUES FROM &quot;measurement&quot; WITH KEY = &quot;host&quot; SHOW TAG KEYSSHOW TAG KEYS on DBName from &quot;measurement&quot; SHOW FIELD KEYSSHOW FIELD KEYS ON &quot;database&quot; FROM &quot;measurement&quot; Downsampling and data retention定義 Continuous query (QC): 自動且規律性的執行, 可以用來降低採樣率。 文件 Retention policies (RP): InfluxDB 資料結構的一部分, 決定 InfluxDB 要保留資料多長的時間 文件 建立 retention policies 語法範例 CREATE RETENTION POLICY &quot;two_hours&quot; ON &quot;food_data&quot; DURATION 2h REPLICATION 1 DEFAULT 在資料庫 food_data 中, 建立一個 RETENTION POLICY two_hours, 並設定他的 DURATION 為 2h, REPLICATION 1 為保留一台 node 的資料, DEFAULT 為此資料庫的預設 RP 當我們建立一個新的資料庫時, InfluxDB 會自動地產生一個 RP 叫做 autogen。 當我們建立另外一個 RP 並且設為 default 之後, autogen 將會被取代掉 建立 continuous query 語法範例 CREATE CONTINUOUS QUERY &quot;cq_30m&quot; ON &quot;food_data&quot; BEGIN SELECT mean(&quot;website&quot;) AS &quot;mean_website&quot;,mean(&quot;phone&quot;) AS &quot;mean_phone&quot; INTO &quot;a_year&quot;.&quot;downsampled_orders&quot; FROM &quot;orders&quot; GROUP BY time(30m)END 在資料庫 food_data 中建立一個 QC 名為 cq_30m 將 website 以及 phone 欄位的資料從 measurement orders 將上一行的資料匯入 retention policy a_year 中的 measurement downsampled_orders 計算區隔為每 30 分鐘 Retention PolicyDuration單位 | 解釋— |ns | nanoseconds (1 billionth of a second)u or µ | microseconds (1 millionth of a second)ms | milliseconds (1 thousandth of a second)s | secondm | minuteh | hourd | dayw | week 開啟身份驗證 開啟身份驗證之前, 請先建立至少一個 admin user 如果開啟了身份驗證, 但是沒有任何 admin user 的話, InfluxDB 將不會強制執行身份驗證, 並只會接受建立新的 admin user的 query 打開設定檔 vim /etc/influxdb/influxdb.conf 將 [http] 中的 auth-enabled 更改為 true [http] enabled = true bind-address = &quot;:8086&quot; auth-enabled = true # ✨ log-enabled = true write-tracing = false pprof-enabled = false https-enabled = true https-certificate = &quot;/etc/ssl/influxdb.pem&quot; 重新啟動 InfluxDB systemctl restart influxdb 使用者權限管理建立 admin 使用者語法CREATE USER &lt;username&gt; WITH PASSWORD &#x27;&lt;password&gt;&#x27; WITH ALL PRIVILEGES 範例CREATE USER paul WITH PASSWORD &#x27;timeseries4days&#x27; WITH ALL PRIVILEGES 給予現存使用者 admin 權限語法GRANT ALL PRIVILEGES TO &lt;username&gt; 範例GRANT ALL PRIVILEGES TO &quot;todd&quot; 顯示目前所有使用者是否為 adminSHOW USERS 建立一般使用者語法CREATE USER &lt;username&gt; WITH PASSWORD &#x27;&lt;password&gt;&#x27; 範例CREATE USER todd WITH PASSWORD &#x27;influxdb41yf3&#x27; 給予一般使用者非 admin 權限語法GRANT [READ,WRITE,ALL] ON &lt;database_name&gt; TO &lt;username&gt; 範例GRANT READ ON &quot;NOAA_water_database&quot; TO &quot;todd&quot; 廢除一般使用者非 admin 權限語法REVOKE [READ,WRITE,ALL] ON &lt;database_name&gt; FROM &lt;username&gt; 範例REVOKE ALL ON &quot;NOAA_water_database&quot; FROM &quot;todd&quot; 列出使用者權限語法SHOW GRANTS FOR &lt;user_name&gt; 範例SHOW GRANTS FOR &quot;todd&quot; 重新設定使用者密碼語法SET PASSWORD FOR &lt;username&gt; = &#x27;&lt;password&gt;&#x27; 範例SET PASSWORD FOR &lt;username&gt; = &#x27;&lt;password&gt;&#x27; 刪除使用者語法DROP USER &lt;username&gt; 範例DROP USER &quot;todd&quot;","link":"/zh-tw/influxdb/"},{"title":"如何將 CSV 檔, 經由 PHP 導入 MYSQL？","text":"大家好, 我是 Ray！我將跟大家分享如何使用 PHP 來將 CSV 檔案的內容導入 MySQL 資料庫。首先, 一個 CSV 檔如下： 以下爲 PHP 腳本, 請將 csv 的檔案跟腳本放在同一個資料夾內 &lt;?php// 連接資料庫$dbc = mysqli_connect(&#x27;Your location&#x27;, &#x27;Your MySQL user_name&#x27;, &#x27;Your MySQL password&#x27;, &#x27;Your Database Name&#x27;);// 設定編碼爲 utf8mysqli_set_charset($dbc,&quot;utf8&quot;);// 利用 fopen 功能讀取檔案$handle = fopen(&quot;The file name.csv&quot;, &quot;r&quot;);// 設定變數 i, 之後會用到$i=0;// 使用 fgetcsv 功能, 配合 while 迴圈, 可以拿到檔案內的每一行資料while (($data = fgetcsv($handle, 1000, &#x27;,&#x27;)))&#123; //如圖片所示, 第一行是行的名稱, 我們不想要將這行導入資料庫, 所以我們設定條件句, //當變數 i 爲 0 正是跑到第一行, 進入條件句內, 變數 i 變爲 1, 並且 continue 使迴圈將之後的 code 都跳掉, //直接回到迴圈的最上面在開始跑, 此時變數i已經是1, 所以將不會在進到條件句中。如此一來我們就完成我們的目標, //只跳掉第一行。 if($i == 0) &#123; $i++; continue; &#125; // 如 csv 的圖片所示, 降雨量那一行中有出現非數字的 NaN 字串, // 但我們又想要將這一行的屬性設爲 float 或 decimal 方便之後若有需要用到計算。 // 要避免資料匯入出錯, 我們必須將非數字的字串轉換爲數字, // 因此利用條件句, 當 $data array 裏面的當三項爲 NaN 時, 替換爲0 if($data[2] == &#x27;NaN&#x27;) &#123; $data[2] = 0; &#125; // 最後, 將資料導入資料庫 $query = &#x27;INSERT INTO rainfall (district, date, rainfall)VALUES (&quot;&#x27;.$data[0] . &#x27;&quot;, &quot;&#x27; . $data[1] . &#x27;&quot;, &quot;&#x27; . $data[2].&#x27;&quot;)&#x27;; echo $query; $result = mysqli_query($dbc, $query); if ($result == false) &#123; echo &#x27;Error description &lt;br/&gt;&#x27; . mysqli_error($dbc); &#125;&#125;?&gt; 最後, 在終端機中執行該腳本, php -f 腳本名稱, 完成！","link":"/zh-tw/importDataFromCSVIntoMySQLDatabaseViaPHP/"},{"title":"Kubernetes - Dashboard - 使用自定義 Service Account 登入","text":"# 前言本篇主要紀錄如何在 Kubernetes 中安裝 Dashboard, 並建立 Server Account, 然後使用該 Service Account 的 token 登入 Dashboard # 安裝 Dashboard首先, Dashboard 是一個套件, 作用是可以讓使用者透過 Web UI 介面取代指令的管理 Kubernetes 安裝 Dashboard, 可參考 官方 Github 依照官方 Github 的步驟, 需要使用 kube proxy 來存取 Dashboard, 也可另外建立一個 nodePort service kind: ServiceapiVersion: v1metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboardspec: ports: - port: 443 targetPort: 8443 selector: k8s-app: kubernetes-dashboard type: NodePort 我們先來看看 Dashboard 的一些詳細資料, 本篇查看 Pod, 查看 Deployment 也可 取得 Dashboard pod 名稱 kubectl get pods -n kubernetes-dashboard 查看 Dashboard 的詳細資料 kubectl describe pod yourDashboardPodName -n kubernetes-dashboard 從 description 中可看到 Dashboard Pod 是 Listen 8443 port, 因此我們 yaml 中才會 listen 8443 port 建立 service kubectl apply -f nodePortServiceName 查看 nodePort kubectl get services -n kubernetes-dashboard 這時應該看到我們剛剛建立的 service, 後面會有一個 port binding, 像是 443:31831/TCP, 這就表示該 service 已經跟 Node 的 31831 port 對應了, 這時只要用瀏覽器開啟 http://myNodeIp:31831, 就可以進入 dashboard 登入頁面了 # 使用自定義的 service account 登入本文中會使用 token 的方式登入Kubernetes 中, 每個 service account 都會綁定一個 secret 資源, 而 secret 中會有一組 base64 加密的 token, 所以我們接下來要做的事情如下： 建立擁有 cluster-admin 權限的 cluster role 建立一個 service account 將擁有 cluster admin 權限的 cluster role, 與該 service account 綁定 取得該 service account 的 token 登入 那就一步一步來吧！ # 建立 role因為 Kubernetes 預設就幫我們建立了 cluster-admin 這個 role, 所以我們就不用再自己另外建立, 直接使用即可 # 建立 service account那我們就建立一個 service account, 名為 cluster-admin-ray kubectl create sa cluster-admin-ray -n kube-system # 建立 role binding接下來我們要綁定上面提到的系統預設的 cluster role, 與上面建立 service account cluster-admin-ray 綁定, 這樣 cluster-admin-ray 就可以擁有該 cluster role 的權限 建立 yaml 檔 kind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata: name: cluster-admin-binding annotations: rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;roleRef: # 這邊我們並沒有特別建立這個 cluster role, 因為這是 Kubernetes 預設建立的 kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.iosubjects:- kind: ServiceAccount name: cluster-admin-ray namespace: kube-system 建立 clusterRoleBinding kubectl create -f yourYamlName # 取得 Server Account 的 token上面已經完成綁定, 接下來我們便要取得 service account 的 token 首先, 我們先來看看 service accountkubectl get sa cluster-admin-ray -n kube-system -o=yaml 輸出如下： 從上面的圖片可以看到, service account 中有一個 secrets 接下來, 我們來看看這個 secretkubectl get secret cluster-admin-ray-token-rtnnh -n kube-system -o=yaml 可以看到 secret 的詳細資料, 由於太多資料我就不貼圖了裡頭有個 token 就是我們要的 所以, 我們來取得 token kubectl get secret cluster-admin-ray-token-rtnnh -o jsonpath=&#123;.data.token&#125; -n kube-system 然而, 之前提過, Kubernetes secret 的內容會使用 base64 encode, 因此, 我們需要對 token 做 base64 decode kubectl get secret cluster-admin-ray-token-rtnnh -o jsonpath=&#123;.data.token&#125; -n kube-system | base64 -d 若是你是使用 MacOS, 也可以使用下面一行搞定, 不過請記得將 service account 改成你自己的 SECRET=`kubectl get serviceAccount yourServiceAccountName -n kube-system -o jsonpath=&#123;.secrets\\[0\\].name&#125;` &amp;&amp; kubectl get secret $SECRET -n kube-system -o jsonpath=&#123;.data.token&#125;|base64 -d|pbcopy # 登入這一步很簡單, 使用上面拿到的 token, 使用 token 方式登入就行了 # 結語至於 Dashboard 有什麼功能就讓大家自行玩耍啦！ 本文到此告一段落, 下台一鞠躬！ # 參考資源官方文件JSONPath Syntax # Questions and Answers以下的 Kubernetes example command 代表什麼意思？ Example:kubectl get secret cluster-admin-ray-token-rtnnh -o jsonpath=&#123;.data.token&#125; -n kube-system | base64 -d Answer:取得 secret cluster-admin-ray-token-rtnnh 的 token","link":"/zh-tw/install-dashboard-on-kubernetes/"},{"title":"Recursion (遞迴) 簡介 - PHP 範例","text":"前言還記得某強者朋友 Chris 曾說… 遞迴只應天上有, 凡人還請用迴圈 嗯… 用不用我們再慢慢研究, 但了解一下總是可以的吧？ # 簡介Recursion (遞迴) 是一種透過將大問題分成小問題, 在逐一突破解決的方法, 就跟我們面對人生的困難一樣, 總是要先尋找小確幸, 再從小確幸中找到前進的勇氣, 然後再一點一點的逐一突破困難… 就跟追女朋友一樣, 總是要先… 咦, 不是要講 recursion 嗎？ 哦! 不好意思離題了。通常, recursion 又被稱為 呼叫自己的 function, 沒錯, 我也覺得很怪！ 那你可能會問, 阿不停的呼叫自己, 有完沒完？ 沒錯！ 所以當我們在寫一個 recursion function 時, 必須具有以下要點： 每一次的 recursion 呼叫, 都必須要把問題變得更小, 聽不懂? 那下面看範例會比較清楚。 必須要為 recursion function 設定一個終點, 且這個終點是不需要任何的 recursion 呼叫就可以解決自己的問題, 不然就沒完沒了了 不可以有循環出現, 這也是上一個要點所要避免的事情, 不然就跟無限 loop 一樣, 死機了 接下來我們來舉幾個範例, 如果看不懂可以跳過去, 挑看得懂的看, 因為我一開始看也是一臉矇逼, 比你還矇 # 實例# factorial“factorial” (階乘) 在數學中相當熱門, factorial of 5, 在數學中又寫成 5!, 等於 5 * 4 * 3 * 2 * 1 以此類推:4! 會等於 4 * 3 * 2 * 13! 會等於 3 * 2 * 12! 會等於 2 * 11! 會等於 1 眼尖的你是否發現了什麼？ 沒發現嗎？ 好, 我當初也沒發現, 沒事沒事…這樣你都能發現？ 哇靠, 你真是有 programmer 的 DNA 啊！ 不, 簡直是 圖靈 在世！ 馬的我就是一個廢物, 我都沒發現。那就是 5! = 5 * 4! 以此類推:4! = 4 * 3!3! = 3 * 2!2! = 2 * 1!1! = 1 * 0!0! = 1 等等… 為啥 0! = 1 ? 這不太合理吧？ 馬的沒錯我當初也是這樣想… 不過研究了一下才知道人家數學家定義這個叫做 empty product, 值就是 1 沒得說, 不要問原因無可奉告, 可以參考一下 Wiki 好這不是重點, 重點是你又發現了嗎？ 那就是從上面的規則中, 可以歸納出n! = n * (n-1)! 好, 規則出現了！ 現在我們來寫一個 PHP 的 recursion function 來求得 factorial function factorial(int $n): int &#123; if ($n == 0) return 1; return $n * factorial($n - 1);&#125; 還記得上面提到的 recursion 要點 (1) 嗎？ 在每一次的 recursion, 問題都會變小, 上面的 example 就可以呈現這一點 在每一次的 recursion, $n 都會減 1 而 $n == 0 的 if 判斷正是要點 (2), 設定一個終點, 以避免無限循環 假設我們使用 factorial(3), 那大概會依序拆成以下步驟 3! = 3 X 2! (將問題 break 並往下 pass, return 3 * factorial(3 - 1)) 2! = 2 X 1! (將問題 break 並往下 pass, return 2 * factorial(2 - 1)) 1! = 1 X 0! (將問題 break 並往下 pass, return 1 * factorial(1 - 1)) 0! = 1 (到達終點, 回傳 1) 1! = 1 X 1 = 1 (回傳結果 1 給上一個 recursion) 2! = 2 X 1 = 2 (回傳結果 2 給上一個 recursion) 3! = 3 X 2 = 6 (執行 3 * 2 = 6, 最終結果) 如下示意圖: 好啦, 那你問, 我用 loop 行不行? 非得要 recursion? 的確, 使用 loop 也是可以求得 factorial 的 &lt;?phpfunction factorial(int $n): int &#123; $result = 1; for ($i = $n; $i &gt; 0; $i--) &#123; $result *= $i; &#125; return $result; &#125; 那, 為什麼要使用 recursion 呢？ recursion 是用來解決更複雜的問題, 比如說, 你想要列出某個資料夾底下的所有資料夾, 包含子資料夾, 但是你並不知道共有幾層, 這就是一個非常適合用 recursion 來解決的問題。 然而, recursion 是使用 call stack 來管理 function call, 也就是像 Stack 資料結構一樣, LIFO (last in first out), 這使得 recursion 會比 loop 使用更多的 memory 以及時間 並且, loop 的每一個 step 都會有其結果, 但 recursion 會需要跑到最後一次的 recursion, 再依序往前推 (first in last out) # FibonacciFibonacci 數列是一組特別的整數順序, 每一個數都可由前兩個數計算得來, 數列中全部都是質數, 例如 1, 2, 3, 5, 7, 11 …而 Fibonacci 有個公式, 如下： 可以寫成一個 PHP function &lt;?phpfunction fibonacci(int $n): int &#123; if ($n == 0) &#123; return 1; &#125; else if ($n == 1) &#123; return 1; &#125; else &#123; return fibonacci($n - 1) + fibonacci($n - 2); &#125; 沒錯, 我們在一個 function 裡頭呼叫了兩個 recursion function 之後我們再來討論不同類型的 recursion # GCDGCD (Greatest Common Division), 最大公因數, 比如 12 的因數有 1, 2, 3, 4, 6, 而 8 的因數有 1, 2, 4, 那 12 跟 8 的最大公因數就是 4 抱歉, 我知道這節不是數學課, 其實我是講給我自己聽的, 哈哈哈哈哈哈！ 所以在數學中若要求得兩數的最大公因數, 有個公式如下： 那如果用 PHP 來寫的話, 如下： &lt;?phpfunction gcd(int $a, int $b): int &#123; if ($b == 0) &#123; return $a; &#125; else &#123; return gcd($b, $a % $b); &#125; &#125; 這又是另外一種類型的 recursion, 我們不從終點一路 return 回起點, 反之, 直接在終點 return 了 value這也是比較理想的 recursion 方式 # 結論本篇 recursion 的簡介就到此結束, 接下來我們會講不同類型的 recursion # 參考來源 PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP # Questions and Answers何謂質數?大於 1 的自然數中, 無法被除了 1 和自身之外的數整除, 稱為質數 何謂 Fibonacci Sequence?一組由質數所組成的數列 何謂 GCD (Greatest Common Division)?最大公因數, 比如 12 的因數有 1, 2, 3, 4, 6, 而 8 的因數有 1, 2, 4, 那 12 跟 8 的最大公因數就是 4","link":"/zh-tw/introduction-on-recursion-with-php-example/"},{"title":"Tree 資料結構簡介","text":"# 前言本篇主要針對 Tree 這個資料結構做基本介紹, 沒有 example code, 無聊沈悶又乏味, 但是看完就會對 Tree 這個資料結構有個大概了解, 當在英文技術文章中出現一些專有名詞時, 也比較不會一臉矇逼。 # Tree 的基本概念 在以下的介紹, 一些名詞會以保留英文, 像是 nodes(節點), edges(連結), parent(父母), child(子), siblings(兄弟姐妹), descendent(後代), ancestor(祖先), leaf(樹葉), path(路徑), height(高度), subtree(子樹), level(等級), depth(深度), forest(森林), traverse(遍歷), 等等… Tree 是一種很好表現階層的資料結構, 如下圖, 主要由 nodes 以及 edges 所構成 下圖中的每個節點, 像是 A, B, C, 稱為 nodes, 抑或 vertices, 而連接 nodes 之間的線, 稱為 edges Tree 不像 linked list, 並沒有循環的概念 兩個相同 parent 的 nodes 之間不會有 edges 存在 除了 top node 之外, 每個 node 都會有一個 parent node top node 又稱為 root node, 而每個 tree 都只會有一個 root node 每個 node 可以有 0 個或多個 child node 下圖中, A 為 root node, 而 B, C, D 為 A 的 child node, 也可以說 A 是 B, C, D 的 parent node B, C, D 彼此互為 siblings, 因為他們都是 A 的 child nodes 沒有 child nodes 的 node 又稱為 leaf, 如上圖中的 K, L, F, G, M, I, J, leaf 又稱為 external(外部) node 或 terminal(終點) node 除了 root 之外, 且至少有一個 child node 的 nodes, 又稱為 internal(內部) node 上圖中, 如果從 C node 持續的往下尋找, 可以找到 M node, 因此 M 為 C 的 Descendent 上圖中, 如果從 L node 持續的往上追朔, 可以找到 B node, 因此 B 為 L 的 Ancestor 一個 node 的 child node 總數量, 又稱為 Degree, 如上圖, A 的 degree 為 3, B 的 degree 為 1, C 的 degree 為 3 從一個 node 到另外一個 node 經過的 nodes 與 edges 的順序又稱為 Path, 而 path 的長度為經過的 node 總數量, 如上圖 A - M 會經過的 node 為 A-C-H-M, 所以此 path 的長度為 4 Level 又被來形容 node 是第幾代的, A 的 level 為 0, B, C, D 的 level 為 1, 以此類推 node 內用來被搜尋用的 value, 又稱為 Keys # 不同類型的 Tree# Binary Tree (二元樹)Binary tree 算是最基本的 tree 結構, 每個 node 最多只能有兩個 child node, 又稱為 left node 以及 right node, 如下示意圖： # Binary Search Tree (二元搜尋樹)Binary search tree 是 binary tree 的一種特別型態, child node 的限制與 binary tree 相同, 不同的是, 每個 node 會以排列過的方式儲存, 排列規則如下：一個 node 必須比它的 left child node 大或相等, 而比它的 right child node 小, 每個 node 都必須要符合這個規則因為每個 node 都以特別的順序排列, 因此從 binary search tree 中搜尋特定 node 的演算法又被稱為 binary search algorithm (二元搜尋演算法), 它通常會比 linear search (線性搜尋) 更有效率如下示意圖: # Self-balanced Binary Search Tree (平衡樹)self-balanced binary search tree, 又稱為 height-balance binary search tree, 靠名字有夠長, 是 binary search tree 的一種特殊類型, 差異在於它會自動調整 node 的排列, 以讓它自身的 height 盡可能的小, 請參考 示意圖 如下： height-balanced binary search tree 的效率會比一般的 BST 還好, 下列列出一些比較熱門的 self-balanced binary search tree 一些不同實作: AA tree AVL tree Red-black tree Scapegoat tree Splay tree 2-3 tree Treap # AVL tree (AVL 樹)上面有提到, AVL tree 是 self-balancing binary search tree 的一種, 規則是, 每一個 node 的兩個 child subtree(子樹) 的高度差最大為 1, 以下為示意圖： # Red-black tree (紅黑樹)紅黑樹是 self-balanced binary search tree 的一種, 但有著一些特別的屬性: 顏色。 每個 node 都額外儲存一些資訊, 紅色或黑色。 就像 AVL tree, red-black tree 也被使用在即時應用上, 因為它的平均以及最差時間複雜度都是 O(log n), 以下為示意圖: # B-tree (B 樹)B-tree 是一種 self-balanced, 特別類型的 binary tree, 跟 self-balanced binary search tree 的最大不同之處在於 B-tree 可以擁有不限數量的 child node, 而不是只限兩個。 B-tree 常被用在處理大量的資料中, 主要使用在檔案系統以及資料庫, 其時間複雜度為 O(log n) # K-way tree (K 元樹)K-way tree 是一種特別的樹, 其 node 可以有最多 K 個 child node, 又稱為 N-ary tree 或 M-ary tree可以說, binary tree 是一種 N 為 2 的 N-ary tree # 複雜度 # 參考資料PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/introduction-on-tree/"},{"title":"k6 - 使用筆記","text":"# 前言使用 k6 來測試高併發 # 安裝# Linuxsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69echo &quot;deb https://dl.k6.io/deb stable main&quot; | sudo tee /etc/apt/sources.list.d/k6.listsudo apt-get updatesudo apt-get install k6 # Fedora/CentOSsudo dnf install https://dl.k6.io/rpm/repo.rpmsudo dnf install k6 # MacOSbrew install k6 # 使用概述 default function 內的為 test 的內容 import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;export default function () &#123; http.get(&#x27;https://test.k6.io&#x27;); sleep(1);&#125; init code 每個 vu 只會執行一次, vu code 會一直執行, 假如 vus=10, iterations=100, 那 init code 只會跑 10 次, 而每個 vu 都會執行 script 10 次 (100/10) // init codeexport default function () &#123; // vu code&#125; 可以使用 options 或 CLI, 效果一樣 import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;export const options = &#123; vus: 10, duration: &#x27;30s&#x27;,&#125;;export default function () &#123; http.get(&#x27;http://test.k6.io&#x27;); sleep(1);&#125;// or CLIk6 run --vus 10 --duration 30s script.js 可在 test 中定義不同的階段, import http from &#x27;k6/http&#x27;;import &#123; check, sleep &#125; from &#x27;k6&#x27;;export const options = &#123; stages: [ // 30 秒內達到 20 VUs &#123; duration: &#x27;30s&#x27;, target: 20 &#125;, // 1m30s 降到 10 VUs &#123; duration: &#x27;1m30s&#x27;, target: 10 &#125;, // 20s 降到 0 VUs &#123; duration: &#x27;20s&#x27;, target: 0 &#125;, ],&#125;;export default function () &#123; const res = http.get(&#x27;https://httpbin.org/&#x27;); check(res, &#123; &#x27;status was 200&#x27;: (r) =&gt; r.status == 200 &#125;); sleep(1);&#125; output 預設會顯示多種資訊, 可從 CLI flag summary-trend-stats, summary-time-unit 控制輸出的資訊, 假如 CLI 中不出現 min, 那 output 就不會有 min k6 run --summary-trend-stats=&quot;min,avg,med,p(99),p(99.9),max,count&quot; --summary-time-unit=ms script.js 可將 output 輸出指定格式到檔案, 或輸出到外部服務 k6 run \\ --out json=test.json \\ --out influxdb=http://localhost:8086/k6 # 使用詳解# HTTP Requests# GET request exampleimport http from &#x27;k6/http&#x27;;export default function () &#123; http.get(&#x27;http://test.k6.io&#x27;);&#125; # POST request exampleimport http from &#x27;k6/http&#x27;;export default function () &#123; const url = &#x27;http://test.k6.io/login&#x27;; const payload = JSON.stringify(&#123; email: &#x27;aaa&#x27;, password: &#x27;bbb&#x27;, &#125;); const params = &#123; headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#125;, &#125;; http.post(url, payload, params);&#125; # 可用 method method 解釋 batch() 可併行發出複數 request del() delete request get() get request options() options request patch() patch reqeust post() post request put() put request request() issue 任何 type 的 request # HTTP Request Tags k6 會自動給每個 request 上 tag, 可以利用 tag 來 filter 結果作分析 tags 解釋 expected_response 預設 200~399 為 true, 可使用 setResponseCallback 修改 group 如果 request 運行在某個 group 內, 那此 tag 為該 group name, 預設為 empty name 預設為 url, 下面會講怎麼修改 method 使用的 HTTP method scenario 如果 request 運行在某個 group 內, 那此 tag 為該 group name, 預設為 default status response status url default 為 request url 範例 response 如下：&#123; &quot;type&quot;: &quot;Point&quot;, &quot;metric&quot;: &quot;http_req_duration&quot;, &quot;data&quot;: &#123; &quot;time&quot;: &quot;2017-06-02T23:10:29.52444541+02:00&quot;, &quot;value&quot;: 586.831127, &quot;tags&quot;: &#123; &quot;expected_response&quot;: &quot;true&quot;, &quot;group&quot;: &quot;&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;name&quot;: &quot;http://test.k6.io&quot;, &quot;scenario&quot;: &quot;default&quot;, &quot;status&quot;: &quot;200&quot;, &quot;url&quot;: &quot;http://test.k6.io&quot; &#125; &#125;&#125; # URL Grouping 預設, name tag 值為 url, 如下： import http from &#x27;k6/http&#x27;;for (let id = 1; id &lt;= 100; id++) &#123; http.get(`http://example.com/posts/$&#123;id&#125;`);&#125;// tags.name=\\&quot;http://example.com/posts/1\\&quot;,// tags.name=\\&quot;http://example.com/posts/2\\&quot;, 然而, 可自定義, 不然一個 url 一個 name tag 會不好 filter import http from &#x27;k6/http&#x27;;for (let id = 1; id &lt;= 100; id++) &#123; http.get(`http://example.com/posts/$&#123;id&#125;`, &#123; tags: &#123; name: &#x27;PostsItemURL&#x27; &#125;, &#125;);&#125;// tags.name=\\&quot;PostsItemURL\\&quot;,// tags.name=\\&quot;PostsItemURL\\&quot;, output 如下: &#123; &quot;type&quot;:&quot;Point&quot;, &quot;metric&quot;:&quot;http_req_duration&quot;, &quot;data&quot;: &#123; &quot;time&quot;:&quot;2017-06-02T23:10:29.52444541+02:00&quot;, &quot;value&quot;:586.831127, &quot;tags&quot;: &#123; &quot;method&quot;:&quot;GET&quot;, &quot;name&quot;:&quot;PostsItemURL&quot;, &quot;status&quot;:&quot;200&quot;, &quot;url&quot;:&quot;http://example.com/1&quot; &#125; &#125;&#125;// and&#123; &quot;type&quot;:&quot;Point&quot;, &quot;metric&quot;:&quot;http_req_duration&quot;, &quot;data&quot;: &#123; &quot;time&quot;:&quot;2017-06-02T23:10:29.58582529+02:00&quot;, &quot;value&quot;:580.839273, &quot;tags&quot;: &#123; &quot;method&quot;:&quot;GET&quot;, &quot;name&quot;:&quot;PostsItemURL&quot;, &quot;status&quot;:&quot;200&quot;, &quot;url&quot;:&quot;http://example.com/2&quot; &#125; &#125;&#125; # Metrics# 內建 metrics 預設輸出如下 k6 run script.js /\\ |‾‾| /‾‾/ /‾‾/ /\\ / \\ | |/ / / / / \\/ \\ | ( / ‾‾\\ / \\ | |\\ \\ | (‾) | / __________ \\ |__| \\__\\ \\_____/ .io execution: local script: http_get.js output: - scenarios: (100.00%) 1 scenario, 1 max VUs, 10m30s max duration (incl. graceful stop): * default: 1 iterations for each of 1 VUs (maxDuration: 10m0s, gracefulStop: 30s)running (00m03.8s), 0/1 VUs, 1 complete and 0 interrupted iterationsdefault ✓ [======================================] 1 VUs 00m03.8s/10m0s 1/1 iters, 1 per VU data_received..................: 22 kB 5.7 kB/s data_sent......................: 742 B 198 B/s http_req_blocked...............: avg=1.05s min=1.05s med=1.05s max=1.05s p(90)=1.05s p(95)=1.05s http_req_connecting............: avg=334.26ms min=334.26ms med=334.26ms max=334.26ms p(90)=334.26ms p(95)=334.26ms http_req_duration..............: avg=2.7s min=2.7s med=2.7s max=2.7s p(90)=2.7s p(95)=2.7s &#123; expected_response:true &#125;...: avg=2.7s min=2.7s med=2.7s max=2.7s p(90)=2.7s p(95)=2.7s http_req_failed................: 0.00% ✓ 0 ✗ 1 http_req_receiving.............: avg=112.41µs min=112.41µs med=112.41µs max=112.41µs p(90)=112.41µs p(95)=112.41µs http_req_sending...............: avg=294.48µs min=294.48µs med=294.48µs max=294.48µs p(90)=294.48µs p(95)=294.48µs http_req_tls_handshaking.......: avg=700.6ms min=700.6ms med=700.6ms max=700.6ms p(90)=700.6ms p(95)=700.6ms http_req_waiting...............: avg=2.7s min=2.7s med=2.7s max=2.7s p(90)=2.7s p(95)=2.7s http_reqs......................: 1 0.266167/s iteration_duration.............: avg=3.75s min=3.75s med=3.75s max=3.75s p(90)=3.75s p(95)=3.75s iterations.....................: 1 0.266167/s vus............................: 1 min=1 max=1 vus_max........................: 1 min=1 max=1 預設 metrics 敘述 METRIC NAME TYPE 敘述 vus Gauge Current number of active virtual users vus_max Gauge Max possible number of virtual users (VU resources are pre-allocated, to ensure performance will not be affected when scaling up the load level) iterations Counter VUs 總共執行 default function 幾次, 不是單一 VU 執行的次數, 而是總數 iteration_duration Trend 執行完畢 default function 所耗費的時間 dropped_iterations Counter 無法開始的 iteration 數量, 可能因為缺少 VUs, 或缺少時間 data_received Counter 收到的檔案數量, example 來 track 特定的 request 的 data_received data_sent Counter 發出的檔案數量, 可參考 example 來 track 特定的 request 的 data_sent checks Rate The rate of successful checks. HTTP-specific 預設 metrics 敘述 METRIC NAME TYPE 敘述 http_reqs Counter k6 共產生多少 HTTP request, 總數 http_req_blocked Trend block 的時間, 即開始一個 request 前, 等待可用的 TCP connection slot 的時間 http_req_connection Trend 與 remote host 建立 TCP connection 所耗費的時間 http_req_tls_handshaking Trend 與 remote host tls handshaking 所耗費的時間 http_req_sending Trend 傳送 data 到 remote host 所耗費的時間 http_req_waiting Trend 從 remote host 收到第一筆資料所等待的時間 http_req_receiving Trend 從 remote host 接收資料, 從第一筆到完整結束所耗費的時間 http_req_duration Trend http_req_sending + http_req_waiting + http_req_receiving 的時間, 即發出一個 request 到完整接收 response 完畢所耗費的時間 http_req_failed Rate failed request rate # 取得指定 request 的 HTTP metric 可使用 res.timings object, 有以下的 method 可以用： METHOD NAME 敘述 blocked 同 http_req_blocked connecting 同 http_req_connection tls_handshaking 同 http_req_tls_handshaking sending 同 http_req_sending waiting 同 http_req_waiting receiving 同 http_req_receiving duration 同 http_req_duration script 範例如下： import http from &#x27;k6/http&#x27;;export default function () &#123; const res = http.get(&#x27;http://httpbin.org&#x27;); console.log(&#x27;Response time was &#x27; + String(res.timings.duration) + &#x27; ms&#x27;);&#125; 輸出範例 k6 run script.js INFO[0001] Response time was 337.962473 ms source=console # Custom metrics script example: import http from &#x27;k6/http&#x27;;import &#123; Trend &#125; from &#x27;k6/metrics&#x27;;const myTrend = new Trend(&#x27;waiting_time&#x27;);export default function () &#123; const r = http.get(&#x27;https://httpbin.org&#x27;); myTrend.add(r.timings.waiting); console.log(myTrend.name); // waiting_time&#125; output example: k6 run script.js ... INFO[0001] waiting_time source=console ... iteration_duration.............: avg=1.15s min=1.15s med=1.15s max=1.15s p(90)=1.15s p(95)=1.15s iterations.....................: 1 0.864973/s waiting_time...................: avg=265.245396 min=265.245396 med=265.245396 max=265.245396 p(90)=265.245396 p(95)=265.245396 # Metric types 類型 METRIC TYPE 敘述 Counter 會將值累計相加 Gauge 存最小及最大值, 以及最後一個值 Rate 計算 non-zero 的累計 percentage Trend 計算累計值取得統計資料, min, max, average, percentiles counter script example import &#123; Counter &#125; from &#x27;k6/metrics&#x27;;const myCounter = new Counter(&#x27;my_counter&#x27;);export default function () &#123; myCounter.add(1); myCounter.add(2);&#125; counter 輸出 example k6 run script.js ... iteration_duration...: avg=16.48µs min=16.48µs med=16.48µs max=16.48µs p(90)=16.48µs p(95)=16.48µs iterations...........: 1 1327.67919/s my_counter...........: 3 3983.037571/s Gauge script example import &#123; Gauge &#125; from &#x27;k6/metrics&#x27;;const myGauge = new Gauge(&#x27;my_gauge&#x27;);export default function () &#123; myGauge.add(3); myGauge.add(1); myGauge.add(2);&#125; Gauge output example: k6 run script.js ... iteration_duration...: avg=21.74µs min=21.74µs med=21.74µs max=21.74µs p(90)=21.74µs p(95)=21.74µs iterations...........: 1 1293.475322/s my_gauge.............: 2 min=1 max=3 Trend script example: import &#123; Trend &#125; from &#x27;k6/metrics&#x27;;const myTrend = new Trend(&#x27;my_trend&#x27;);export default function () &#123; myTrend.add(1); myTrend.add(2);&#125; Trend output example: k6 run script.js ... iteration_duration...: avg=20.78µs min=20.78µs med=20.78µs max=20.78µs p(90)=20.78µs p(95)=20.78µs iterations...........: 1 1217.544821/s my_trend.............: avg=1.5 min=1 med=1.5 max=2 p(90)=1.9 p(95)=1.95 Rate script example: import &#123; Rate &#125; from &#x27;k6/metrics&#x27;;const myRate = new Rate(&#x27;my_rate&#x27;);export default function () &#123; myRate.add(true); myRate.add(false); myRate.add(1); myRate.add(0);&#125; Rate output example: k6 run script.js ... iteration_duration...: avg=22.12µs min=22.12µs med=22.12µs max=22.12µs p(90)=22.12µs p(95)=22.12µs iterations...........: 1 1384.362792/s my_rate..............: 50.00% ✓ 2 ✗ 2 # Checkschecks 跟 assertion 類似, 不同之處在於它不會停止, 而是會記下 check 結果, 並繼續執行 檢查 HTTP response code import &#123; check &#125; from &#x27;k6&#x27;;import http from &#x27;k6/http&#x27;;export default function () &#123; const res = http.get(&#x27;http://test.k6.io/&#x27;); check(res, &#123; &#x27;is status 200&#x27;: (r) =&gt; r.status === 200, &#125;);&#125; 檢查 response body import &#123; check &#125; from &#x27;k6&#x27;;import http from &#x27;k6/http&#x27;;export default function () &#123; const res = http.get(&#x27;http://test.k6.io/&#x27;); check(res, &#123; &#x27;verify homepage text&#x27;: (r) =&gt; r.body.includes(&#x27;Collection of simple web-pages suitable for load testing&#x27;), &#125;);&#125; 檢查 body size import &#123; check &#125; from &#x27;k6&#x27;;import http from &#x27;k6/http&#x27;;export default function () &#123; const res = http.get(&#x27;http://test.k6.io/&#x27;); check(res, &#123; &#x27;body size is 11,105 bytes&#x27;: (r) =&gt; r.body.length == 11105, &#125;);&#125; check output example: k6 run script.js ... ✓ is status 200 ... checks.........................: 100.00% ✓ 1 ✗ 0 data_received..................: 11 kB 12 kB/s 檢查多項 import &#123; check &#125; from &#x27;k6&#x27;;import http from &#x27;k6/http&#x27;;export default function () &#123; const res = http.get(&#x27;http://test.k6.io/&#x27;); check(res, &#123; &#x27;is status 200&#x27;: (r) =&gt; r.status === 200, &#x27;body size is 11,105 bytes&#x27;: (r) =&gt; r.body.length == 11105, &#125;);&#125; output example k6 run checks.js ... ✓ is status 200 ✓ body size is 11,105 bytes ... checks.........................: 100.00% ✓ 2 ✗ 0 data_received..................: 11 kB 20 kB/s # Thresholds若有任一 threshold 失敗, 則該 test 被視為 failed threshold script example import http from &#x27;k6/http&#x27;;export const options = &#123; thresholds: &#123; http_req_failed: [&#x27;rate&lt;0.01&#x27;], // http errors should be less than 1% http_req_duration: [&#x27;p(95)&lt;200&#x27;], // 95% of requests should be below 200ms &#125;,&#125;;export default function () &#123; http.get(&#x27;https://test-api.k6.io/public/crocodiles/1/&#x27;);&#125; threshold output example, 若上面的兩個 thresholds 有任何一個失敗, 則 http_req_failed 會等於 1 ✓ http_req_duration..............: avg=151.06ms min=151.06ms med=151.06ms max=151.06ms p(90)=151.06ms p(95)=151.06ms &#123; expected_response:true &#125;...: avg=151.06ms min=151.06ms med=151.06ms max=151.06ms p(90)=151.06ms p(95)=151.06ms✓ http_req_failed................: 0.00% ✓ 0 ✗ 1 example, 90% 的 request 必須在 400ms 內結束 import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;export const options = &#123; thresholds: &#123; // 90% of requests must finish within 400ms. http_req_duration: [&#x27;p(90) &lt; 400&#x27;], &#125;,&#125;;export default function () &#123; http.get(&#x27;https://test-api.k6.io/public/crocodiles/1/&#x27;); sleep(1);&#125; example, error rate 必須在 1% 以下 import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;export const options = &#123; thresholds: &#123; // During the whole test execution, the error rate must be lower than 1%. // `http_req_failed` metric is available since v0.31.0 http_req_failed: [&#x27;rate&lt;0.01&#x27;], &#125;,&#125;;export default function () &#123; http.get(&#x27;https://test-api.k6.io/public/crocodiles/1/&#x27;); sleep(1);&#125; example, 90% request 必須在 400ms 完成, 95% 在 800ms 完成, 99.9% 在 2s 內完成 import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;export const options = &#123; thresholds: &#123; // 90% of requests must finish within 400ms, 95% within 800, and 99.9% within 2s. http_req_duration: [&#x27;p(90) &lt; 400&#x27;, &#x27;p(95) &lt; 800&#x27;, &#x27;p(99.9) &lt; 2000&#x27;], &#125;,&#125;;export default function () &#123; const res1 = http.get(&#x27;https://test-api.k6.io/public/crocodiles/1/&#x27;); sleep(1);&#125; example, 指定 group 內的 request 必須平均在 200ms 內完成 import http from &#x27;k6/http&#x27;;import &#123; group, sleep &#125; from &#x27;k6&#x27;;export const options = &#123; thresholds: &#123; &#x27;group_duration&#123;group:::individualRequests&#125;&#x27;: [&#x27;avg &lt; 200&#x27;], &#x27;group_duration&#123;group:::batchRequests&#125;&#x27;: [&#x27;avg &lt; 200&#x27;], &#125;, vus: 1, duration: &#x27;10s&#x27;,&#125;;export default function () &#123; group(&#x27;individualRequests&#x27;, function () &#123; http.get(&#x27;https://test-api.k6.io/public/crocodiles/1/&#x27;); http.get(&#x27;https://test-api.k6.io/public/crocodiles/2/&#x27;); http.get(&#x27;https://test-api.k6.io/public/crocodiles/3/&#x27;); &#125;); group(&#x27;batchRequests&#x27;, function () &#123; http.batch([ [&#x27;GET&#x27;, `https://test-api.k6.io/public/crocodiles/1/`], [&#x27;GET&#x27;, `https://test-api.k6.io/public/crocodiles/2/`], [&#x27;GET&#x27;, `https://test-api.k6.io/public/crocodiles/3/`], ]); &#125;); sleep(1);&#125; Syntax example import http from &#x27;k6/http&#x27;;import &#123; Trend, Rate, Counter, Gauge &#125; from &#x27;k6/metrics&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;// 這邊定義各個 custom metric 的名稱, 以及其 typeexport const TrendRTT = new Trend(&#x27;RTT&#x27;);export const RateContentOK = new Rate(&#x27;Content OK&#x27;);export const GaugeContentSize = new Gauge(&#x27;ContentSize&#x27;);export const CounterErrors = new Counter(&#x27;Errors&#x27;);// 這裡用上面定義的 custom metric 來定義 thresholdsexport const options = &#123; thresholds: &#123; // 99% request response time 需低於 300 ms, 70% &lt; 250 ms, avg &lt; 200 ms, median &lt; 150 ms, min &lt; 100 ms &#x27;RTT&#x27;: [&#x27;p(99)&lt;300&#x27;, &#x27;p(70)&lt;250&#x27;, &#x27;avg&lt;200&#x27;, &#x27;med&lt;150&#x27;, &#x27;min&lt;100&#x27;], // content 正確率必須 &gt; 95% &#x27;Content OK&#x27;: [&#x27;rate&gt;0.95&#x27;], // returned content &lt; 4000 bytes &#x27;ContentSize&#x27;: [&#x27;value&lt;4000&#x27;], // content can&#x27;t have been bad more than 99 times &#x27;Errors&#x27;: [&#x27;count&lt;100&#x27;], &#125;,&#125;;// 在 default function 中, 實際對 custom metric 做操作export default function () &#123; const res = http.get(&#x27;https://test-api.k6.io/public/crocodiles/1/&#x27;); const contentOK = res.json(&#x27;name&#x27;) === &#x27;Bert&#x27;; TrendRTT.add(res.timings.duration); RateContentOK.add(contentOK); GaugeContentSize.add(res.body.length); CounterErrors.add(!contentOK); sleep(1);&#125; Thresholads on tags import http from &#x27;k6/http&#x27;;import &#123; sleep &#125; from &#x27;k6&#x27;;import &#123; Rate &#125; from &#x27;k6/metrics&#x27;;export const options = &#123; thresholds: &#123; // 使用 tag 定義 thresholds &#x27;http_req_duration&#123;type:API&#125;&#x27;: [&#x27;p(95)&lt;500&#x27;], // threshold on API requests only &#x27;http_req_duration&#123;type:staticContent&#125;&#x27;: [&#x27;p(95)&lt;200&#x27;], // threshold on static content only &#125;,&#125;;export default function () &#123; // 定義 tags const res1 = http.get(&#x27;https://test-api.k6.io/public/crocodiles/1/&#x27;, &#123; tags: &#123; type: &#x27;API&#x27; &#125;, &#125;); // 定義 tags const res2 = http.get(&#x27;https://test-api.k6.io/public/crocodiles/2/&#x27;, &#123; tags: &#123; type: &#x27;API&#x27; &#125;, &#125;); const responses = http.batch([ // 定義 tags [&#x27;GET&#x27;, &#x27;https://test-api.k6.io/static/favicon.ico&#x27;, null, &#123; tags: &#123; type: &#x27;staticContent&#x27; &#125; &#125;], // 定義 tags [ &#x27;GET&#x27;, &#x27;https://test-api.k6.io/static/css/site.css&#x27;, null, &#123; tags: &#123; type: &#x27;staticContent&#x27; &#125; &#125;, ], ]); sleep(1);&#125; 當 threshold 達標, 停止 test, abortOnFail 為 boolean, 代表達標時是否 abort, delayAbortEval 代表達標後, delay 多少時間才 abort export const options = &#123; thresholds: &#123; metric_name: [ &#123; threshold: &#x27;p(99) &lt; 10&#x27;, // string abortOnFail: true, // boolean delayAbortEval: &#x27;10s&#x27;, // string /*...*/ &#125;, ], &#125;,&#125;; 使用 checks 搭配 thresholds 來 fail test, 若 checks 沒通過, 則該 request 視為 failed request import http from &#x27;k6/http&#x27;;import &#123; check, sleep &#125; from &#x27;k6&#x27;;export const options = &#123; vus: 50, duration: &#x27;10s&#x27;, thresholds: &#123; // the rate of successful checks should be higher than 90% checks: [&#x27;rate&gt;0.9&#x27;], &#125;,&#125;;export default function () &#123; const res = http.get(&#x27;http://httpbin.org&#x27;); check(res, &#123; &#x27;status is 500&#x27;: (r) =&gt; r.status == 500, &#125;); sleep(1);&#125; 給 checks 定義 tag, 在用 tag 來定義 thresholds 也行 import http from &#x27;k6/http&#x27;;import &#123; check, sleep &#125; from &#x27;k6&#x27;;export const options = &#123; vus: 50, duration: &#x27;10s&#x27;, // 使用 tag 定義的 thresholds thresholds: &#123; &#x27;checks&#123;myTag:hola&#125;&#x27;: [&#x27;rate&gt;0.9&#x27;], &#125;,&#125;;export default function () &#123; let res; res = http.get(&#x27;http://httpbin.org&#x27;); check(res, &#123; &#x27;status is 500&#x27;: (r) =&gt; r.status == 500, &#125;); res = http.get(&#x27;http://httpbin.org&#x27;); // 給 check 上一個 tag check( res, &#123; &#x27;status is 200&#x27;: (r) =&gt; r.status == 200, &#125;, &#123; myTag: &#x27;hola&#x27; &#125; ); sleep(1);&#125;","link":"/zh-tw/k6/"},{"title":"Docker 實戰入門","text":"概述Docker 是一個提供開發, 運送, 以及運行應用的開放平台。 妥善地使用 Docker, 你可以將你的應用從基礎設施分離, 並且如管理應用般的管理基礎設施。 Docker 可讓你更快速的輸送你的程式碼, 更快速的測試, 以及更快速的部署, 讓開發到運行之間的週期更加縮短。 Docker 藉由使用工作流程以及工具來融合 kernel 容器化功能, 讓你可以管理以及部署你的應用。 Docker 容器可以直接地被使用在 Kubernetes, 這讓 Docker 可以很簡單的被運行在 Kubernetes Engine, 在學習 Docker 的一些重要的核心知識後, 你將擁有可以開始開發 Kubernetes 以及容器化應用的技能組合。 學習目標在本教程中, 你將會學習到以下： 如何建立, 運行, 以及 debug Docker 容器 如何從 Docker Hub 以及 Google Container Registry 拉下 Docker 鏡像 如何將 Docker 鏡像推上 Google Container Registry 事前準備這是個入門等級的教程。 只有一點點, 或是完全沒有 Docker 相關知識也是 okay 的。 建議熟悉 Cloud Shell 以及其命令列工具, 但非必要。 如果你在尋找在一個範圍內更進階的學習素材的話, 可以參考以下的教程： App Dev: Deploying the Application into Kubernetes Engine - Python Hello Node Kubernetes Managing Deployments Using Kubernetes Engine 如果你已經準備好了, 往下滑開始設定教程環境吧 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 **注意：** 按下左上方位於 `Google Cloud Platform` 隔壁的 `Navigation menu`, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Hello World打開 Cloud Shell 並輸入以下指令來運行一個 hello world 容器 docker run hello world (輸出) Unable to find image &#x27;hello-world:latest&#x27; locallylatest: Pulling from library/hello-world9db2ca6ccae0: Pull completeDigest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdcStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.... 這個簡單的容器回傳 Hello from Docker! 到你的螢幕上。 儘管指令很簡單, 但仔細看看在輸出中, 執行步驟的數量。 Docker daemon 搜尋名為 hello-world 的鏡像, 但沒有在本地端找到, 所以從名為 Docker Hub 的公開 registry 拉下這個鏡像, 並且使用這個鏡像建立了容器, 最後運行容器。 執行以下的指令檢視從 Docker Hub 拉下的 Docker 鏡像 docker images (輸出) REPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest 1815c82652c0 6 days ago 1.84 kB 這是一個從 Docker Hub 公開 registry 被拉下的鏡像。 鏡像 ID 為 SHA256 加密 格式 - 這個欄位明確的指定被提供的鏡像。 當 docker daemon 無法在本地端找到鏡像, 預設會自動地從公開 registry 尋找鏡像。 讓我們再次運行容器： docker run hello-world (輸出) Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps:... 注意到, 當你第二次執行這個指令, docker daemon 在本地端找到了這個鏡像並且使用這個鏡像運行容器。 不需要再從 Docker Hub 拉下鏡像。 最後, 執行以下指令來檢視運行中的容器： docker ps (輸出) CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 目前並沒有運行中的容器。 你之前運行的 hello-world 容器已經退出了。 如果要檢視所有的容器, 包含已經結束運行的容器, 可以執行 docker ps -a: docker ps -a (輸出) CONTAINER ID IMAGE COMMAND ... NAMES6027ecba1c39 hello-world &quot;/hello&quot; ... elated_knuth358d709b8341 hello-world &quot;/hello&quot; ... epic_lewin 這會顯示 Container ID, 這是一個由 Docker 建立的 UUID, 用以辨識容器, 除此之外, 還有一些容器的資訊。 容器的 Names 也是隨機產生的, 但你也可以使用 docker run --name [container-name] hello-world 來指定它 建立現在讓我們來建立一個基於 node 簡單應用的 Docker 鏡像。 執行以下指令來建立並且切換到這個名為 test 的資料夾 mkdir test &amp;&amp; cd test 建立一個 Dockerfile: cat &gt; Dockerfile &lt;&lt;EOF# Use an official Node runtime as the parent imageFROM node:6# Set the working directory in the container to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Make the container&#x27;s port 80 available to the outside worldEXPOSE 80# Run app.js using node when the container launchesCMD [&quot;node&quot;, &quot;app.js&quot;]EOF 這個檔案指示 Docker daemon 該怎樣建立這個鏡像 第一行指定了基礎鏡像, 在這個範例中為 node 版本 6 的官方 Docker 鏡像 第二行, 我們指定了容器內的工作(目前)目錄 第三行, 我們當層資料夾內的內容(容器外), 複製到容器內 最後, 我們暴露了容器的 port, 所以此容器可經由該 port 被存取, 然後運行 node 的指令來運行應用 花一些時間看一下 Dockerfile command references 來了解 Dockerfile 中每一行的意思 現在, 你將寫入 node 應用, 且在那之後你將建立鏡像 執行以下指令來建立 node 應用 cat &gt; app.js &lt;&lt;EOFconst http = require(&#x27;http&#x27;);const hostname = &#x27;0.0.0.0&#x27;;const port = 80;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;); res.end(&#x27;Hello World\\n&#x27;);&#125;);server.listen(port, hostname, () =&gt; &#123; console.log(&#x27;Server running at http://%s:%s/&#x27;, hostname, port);&#125;);process.on(&#x27;SIGINT&#x27;, function() &#123; console.log(&#x27;Caught interrupt signal and will exit&#x27;); process.exit();&#125;);EOF 這是一個簡單的 HTTP server, 監聽 port 80 且回傳 “Hello world.” 現在讓我們來建立鏡像吧 再次注意, &quot;.&quot; 這個符號代表目前的資料夾為止, 所以你必須要在有 Dockerfile 的資料夾底下運行這個指令 docker build -t node-app:0.1 . 這個指令可能會花個幾分鐘才會執行完畢。 當它執行結束, 你的輸出應會如下： Sending build context to Docker daemon 3.072 kBStep 1 : FROM node:66: Pulling from library/node.........Step 5 : CMD node app.js ---&gt; Running in b677acd1edd9 ---&gt; f166cd2a9f10Removing intermediate container b677acd1edd9Successfully built f166cd2a9f10 -t 是為使用 name:tag 語法來命名鏡像的 tag, 鏡像名稱為 node-app, tag 為 0.1, 高度建議當建立鏡像時一定要使用 tag 。 如果你沒指定 tag, tag 將預設為 latest, 這會讓你更難分辨新舊鏡像。 也請注意到, 在鏡像被建立的過程中, Dockerfile 中的每一行指令在中間的容器層中造成什麼樣的結果。 現在, 執行以下指令來檢視建立的鏡像： docker images 輸出應如下： REPOSITORY TAG IMAGE ID CREATED SIZEnode-app 0.1 f166cd2a9f10 25 seconds ago 656.2 MBnode 6 5a767079e3df 15 hours ago 656.2 MBhello-world latest 1815c82652c0 6 days ago 1.84 kB 注意到, node 為基礎鏡像, 而 node-app 為你建立的鏡像。 在移除 node 鏡像之前, 你必須要先移除 node-app 。 鏡像的大小跟虛擬機比起來的話小了非常多。 其他版本的 node 鏡像, 像是 node:slim 以及 node:alpine 提供了更小的體積, 更好的攜帶性。 降低鏡像大小的主題, 你可探索更進階的主題。 你可以在 官方倉庫 檢視所有的版本 運行在這個章節中, 執行這個程式碼, 使用之前建立的鏡像運行容器: docker run -p 4000:80 --name my-app node-app:0.1 (輸出) Server running at http://0.0.0.0:80/ --name flag 讓你可以自由的命名你的容器。 -p 指定容器映射本機端的 port 4000 到容器內的 port 80, 而現在你應可經由 http://localhost:4000 存取 server。 如果沒有做 port 映射, 你將無法經由 localhost 來存取容器 打開另外一個終端機 (在 Cloud Shell, 點擊 + icon), 然後測試 server curl http://localhost:4000 (輸出) Hello World 第一個終端機視窗開啟多久, 這個容器就會運行多久。 如果你想要將容器運行在背景中 (不會綁住終端機), 你需要指定 -d flag 關閉第一個終端機視窗, 然後執行以下指令來停止並移除容器： docker stop my-app &amp;&amp; docker rm my-app 現在執行以下指令來開始在背景運行另外一個容器： docker run -p 4000:80 --name my-app -d node-app:0.1docker ps (輸出) CONTAINER ID IMAGE COMMAND CREATED ... NAMESxxxxxxxxxxxx node-app:0.1 &quot;node app.js&quot; 16 seconds ago ... my-app 從 docker ps 的輸出, 我們可以看到容器正在運行中。 你可以執行 docker logs [container_id] 指令來檢視 logs 小技巧: 你不需要完整的容器 ID, 只要前幾個字是獨一無二足以代表這個容器。 舉例來說, 你可以執行 docker ps 17b, 如果你的容器 ID 是 17bcaca6f... docker logs [container_id] (輸出) Server running at http://0.0.0.0:80/ 現在讓我們來修改應用。 在 Cloud Shell, 打開之前建立的 test 資料夾： cd test 使用你的編輯器 (比如 namo 或 vim) 來編輯 app.js, 然後將 “Hello World” 替換成其他字串: ....const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;); res.end(&#x27;Welcome to Cloud\\n&#x27;);&#125;);.... 建立這個新的鏡像, 並給予 tag 0.2: docker build -t node-app:0.2 . (輸出) Step 1/5 : FROM node:6 ---&gt; 67ed1f028e71Step 2/5 : WORKDIR /app ---&gt; Using cache ---&gt; a39c2d73c807Step 3/5 : ADD . /app ---&gt; a7087887091fRemoving intermediate container 99bc0526ebb0Step 4/5 : EXPOSE 80 ---&gt; Running in 7882a1e84596 ---&gt; 80f5220880d9Removing intermediate container 7882a1e84596Step 5/5 : CMD node app.js ---&gt; Running in f2646b475210 ---&gt; 5c3edbac6421Removing intermediate container f2646b475210Successfully built 5c3edbac6421Successfully tagged node-app:0.2 注意到, 在 step 2我們使用了以存在的緩存層。 從 step 3 開始, 層被修改了因為我們在 app.js 中做了一些變更 使用新的鏡像版本啟動另外一個容器。 注意到我們是如何的映射本機端的 port 8080, 而不是 port 80, 我們不能在使用 port 4000 因為它已經在使用中了。 docker run -p 8080:80 --name my-app-2 -d node-app:0.2docker ps (輸出) CONTAINER ID IMAGE COMMAND CREATED xxxxxxxxxxxx node-app:0.2 &quot;node app.js&quot; 53 seconds ago ...xxxxxxxxxxxx node-app:0.1 &quot;node app.js&quot; About an hour ago ... 測試容器 curl http://localhost:8080 (輸出) Welcome to Cloud 現在測試第一個容器 curl http://localhost:4000 (輸出) Hello World Debug現在我們已經熟悉如何建立以及運行容器, 來學習一下一些 debugging 的方法。你可以使用 docker logs [container_id 來檢視容器的日誌, 如果你想要檢視即時的日誌輸出的話, 可以使用 -f 選項 docker logs -f [container_id] (輸出) Server running at http://0.0.0.0:80/ 有時, 你可能會想要啟動一個容器內的 Bash, 你可以使用 docker exec 來做到這件事。 打開另外一個終端機 (在 Cloud Shell, 點擊 + 圖示), 然後執行以下指令: docker exec -it [container_id] bash -it flags 讓你可以分配一個虛擬的 TTY 給容器, 保持輸入開啟並與之互動。 注意到目前 bash 正運行在 Dockerfile 內指定的 WORKDIR 資料夾 (/app), 現在你有一個容器內的互動式的 shell 可以用來 debug 了 (輸出) root@xxxxxxxxxxxx:/app# 檢視資料夾 ls (輸出) Dockerfile app.jsroot@xxxxxxxxxxxx:/app# 若要離開 Bash, 在 Bash 中輸入 exit: exit 你可以使用以下指令來檢視容器的元資料 docker inspect [container_id] (輸出) [ &#123; &quot;Id&quot;: &quot;xxxxxxxxxxxx....&quot;, &quot;Created&quot;: &quot;2017-08-07T22:57:49.261726726Z&quot;, &quot;Path&quot;: &quot;node&quot;, &quot;Args&quot;: [ &quot;app.js&quot; ],... 使用 --format 從回傳的 JSON 當中檢查特定的欄位。 例如說： docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; [container_id] (輸出) 192.168.9.3 務必到以下的連結去參考更多有關 debugging 的資訊 Docker inspect reference Docker exec reference 發佈現在, 你將推送你的鏡像到 Google Container Registry (gcr)。 在那之後, 你將會將本地的容器以及鏡像都刪除來模擬一個全新的環境, 然後從遠端拉取鏡像並啟動容器。 這將是 Docker 容器可攜性的最佳示範。 要推送鏡像到你的私人 gcr 的 registry, 你需要 tag registry 的名稱到這個鏡像。 格式就像是 [hostname]/[project-id]/[image]:[tag] GCR 的格式： [hostname] = gcr.io [project-id] = 你的 project ID [image] = 你的鏡像名稱 [tag] = 你選擇的 tag, 若無特別指定, 預設為 “latest” 你可以執行以下指令來找到你的 project ID gcloud config list project (輸出) [core]project = [project-id]Your active configuration is: [default] 給予 tag node-app:0.2, 並將 [project-id] 替換成你的設定 docker tag node-app:0.2 gcr.io/[project-id]/node-app:0.2 docker images (輸出) REPOSITORY TAG IMAGE ID CREATEDnode-app 0.2 76b3beef845e 22 hours agogcr.io/[project-id]/node-app 0.2 76b3beef845e 22 hours agonode-app 0.1 f166cd2a9f10 26 hours agonode 6 5a767079e3df 7 days agohello-world latest 1815c82652c0 7 weeks ago 將這個鏡像推送到 gcr, 記住要將 [project-id] 替換成你的設定 docker push gcr.io/[project-id]/node-app:0.2 (輸出) The push refers to a repository [gcr.io/[project-id]/node-app]057029400a4a: Pushed342f14cb7e2b: Pushed903087566d45: Pushed99dac0782a63: Pushede6695624484e: Pushedda59b99bbd3b: Pushed5616a6292c16: Pushedf3ed6cb59ab0: Pushed654f45ecb7e3: Pushed2c40c66f7667: Pushed0.2: digest: sha256:25b8ebd7820515609517ec38dbca9086e1abef3750c0d2aff7f341407c743c46 size: 2419 從瀏覽器拜訪鏡像位址來確認鏡像已存在於 gcr, 你可以從主控台到 Tools &gt; Container Registry 或是拜訪 http://gcr.io/[project-id]/node-app, 顯示頁面應如下： 現在讓我們測試這個鏡像。 你可以開啟一個新的 VM, ssh 到這個 VM, 然後安裝 gcloud, 但為求簡單化, 我們將簡單的移除所有的容器以及鏡像來模擬一個全新的環境。 停止並刪除所有的容器： docker stop $(docker ps -q)docker rm $(docker ps -aq) 在移除 node 鏡像之前, 你必須要移除它的子鏡像 (node:6 的), 運行已下指令, 記得將 [project-id] 替換成你自己的 docker rmi node-app:0.2 gcr.io/[project-id]/node-app node-app:0.1docker rmi node:6docker rmi $(docker images -aq) # remove remaining imagesdocker images (輸出) REPOSITORY TAG IMAGE ID CREATED SIZE 現在你應該有一個虛擬全新的環境。 拉取並運行鏡像。 記得將 [project-id] 替換成你自己的 docker pull gcr.io/[project-id]/node-app:0.2docker run -p 4000:80 -d gcr.io/[project-id]/node-app:0.2curl http://localhost:4000 (輸出) Welcome to Cloud 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功發布容器鏡像到 Container Registry, 你將獲得一個評價分數。 在這裏, 我們示範了容器的可攜帶性。 只要機器上有安裝 Docker (實機或虛擬機), 你可以從公開或私人的 registries 拉取鏡像並運行容器。 在你的機器上除了 Docker, 你不需要再安裝其他的應用相依。 恭喜你已經完成本教程","link":"/zh-tw/introductionToDocker/"},{"title":"<未完成> kubernetes - Storage Classes","text":"概述StorageClass 提供給管理者一個方法, 一個管理者可用來描述儲存空間的 classes","link":"/zh-tw/kubernetes-concepts-storage-storage-classes/"},{"title":"<未完成> Kubernetes - Volumes","text":"前言本篇為 Kubernetes 筆記, 內容主要參照官方文件, 考量到時間成本不會逐字翻譯, 但會將重要的資訊翻譯出來 容器中, 紀錄在硬碟上的檔案是暫時的, 對於運行在容器內的複雜應用來說, 這產生了一些問題。首先, 當容器掛了, kubelet 會重啟它, 但檔案會丟失, 因為容器會以一個乾淨的狀態重啓。再來, Pod 內的容器常常會需要共享一些檔案。 Kubernetes Volume 抽象可以解決這兩個問題。建議對 Pod 熟悉。 BackgroundKubernetes Volume 的生命週期與所屬的 Pod 一樣長, 所以說, volume 不受 Pod 內容器的重啓影響。本質上來說, volume 只是個可被 Pod 內容器存取的資料夾。 而這個資料夾是怎麼來的, 什麼方式產生的, 有什麼樣的內容, 這些都取決於使用什麼樣的 volume 類型Pod 的 .spec.volume 欄位指定了要使用什麼 volume, 而 .spec.container[*].volumMounts 欄位指定了要掛載這些 volume 到容器裡的位置Volumes 無法掛載到其他 volumes 或硬連結到其他的 volumes, Pod 內的每一個容器都必須要獨立的指令要將 volume 掛載到哪個位置 Types of VolumesawsElasticBlockStoreawsElasticBlockStore volume 掛載一個 Amazon Web Services (AWS) EBS Volume 到你的 Pod。 跟 emptyDir 不同, 當 Pod 被移除時, EBS volume 的內容不會被移除, 而是會被保留, 僅僅是不掛載而已。 這表示 EBS volume 可以被預先載入資料, 然後這個資料可以在 Pods 之間傳遞注意: 使用 EBS 之前, 需先使用 aws ec2 create-volume 來建立 EBS volume 當使用 awsElasticBolckStore volume 時有幾個限制： Pods 所運行的 Nodes 必須要是 AWS EC2 instances 這些 instances 必須要跟 EBS volume 同 region 以及 zone EBS 只支援掛載一個 volume 的 EC2 instance 建立一個 EBS volume在 Pod 使用 EBS volume 之前, 你需要先建立它 aws ec2 create-volume --availability-zone=eu-west-1a --size=10 --volume-type=gp2 AWS EBS 範例設定檔apiVersion: v1kind: Podmetadata: name: test-ebsspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /test-ebs name: test-volume volumes: - name: test-volume # This AWS EBS volume must already exist. awsElasticBlockStore: volumeID: &lt;volume-id&gt; fsType: ext4 emptyDir emptyDir volume 當 Pod 被指派給 Node 時建立 emptyDir 的存活時間跟該 Pod 在該 Node 的時間一樣長 emptyDir 一開始是空的 所有在該 Pod 內的容器都可以 讀 以及 寫 該 emptyDir 中的同一個檔案 emptyDir 可以被掛載到每個容器中的不同路徑 當 Pod 從 Node 移除, emptyDir 中的資料會永久刪除 一個容器掛掉並不會將 Pod 從 Node 移除, 所以容器掛掉這件事不會影響到 emptyDir 中的資料 預設上, emptyDir 會儲存在支援該 Node 的媒體, 可能是 disk, 或 SSD, 或網路儲存 emptyDir 也可透過 emptyDir.medium 欄位設定成 Memory, 掛載到 tmpfs (RAM 支援的檔案系統) 每當 node 重啟, tmpfs 會被清除 tmpfs 上的使用量會算在該容器的 memory limits 範例 PodapiVersion: v1kind: Podmetadata: name: test-pdspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /cache name: cache-volume volumes: - name: cache-volume emptyDir: &#123;&#125; gcePersistentDiskgcePersistentDisk volume 掛載一個 Gogole Compute Engine (GCE) Persistent Disk 到你的 Pod。 跟 emptyDir 不同, 當 Pod 被移除時, PD 的內容不會被移除, 而是會被保留, 僅僅是不掛載而已。 這表示 PD 可以被預先載入資料, 然後這個資料可以在 Pods 之間傳遞注意: 使用 PD 之前, 需先使用 gcloud 或 GCE API 或 UI 來建立 PD 當使用 gcePersistentDisk volume 時有幾個限制： Pods 運行所在的 Nodes 必須要是 GCE VMs PD 跟 VMs 需位於同一個 GCE project 以及 zone PD 的一個特色是, 當被多方存取時, 只可使用 read-only 掛載。 這代表說, 你可以預載入資料, 然後讓多個 Pod 使用它。 不幸的是, PD 當掛載為 read-write 模式時, 並不支援多方存取。 若在一個由 ReplicationController 控制的 Pod 上使用 PD 將會失敗, 除非這個 PD 是 read-only, 或是 replica 為 0 或 1 建立 PD在 Pod 使用 GCE PD 之前, 要先建立 gcloud compute disks create --size=500GB --zone=us-central1-a my-data-disk 範例 PodapiVersion: v1kind: Podmetadata: name: test-pdspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /test-pd name: test-volume volumes: - name: test-volume # This GCE PD must already exist. gcePersistentDisk: pdName: my-data-disk fsType: ext4 Regional Persistent DisksRegional Persistent Disk 功能讓 Persistent Disks 可以在不同的 zone, 相同的 region 內可用。 要使用這個功能, volume 必須要以 PersistentVolume 的方式提供, 直接從 Pod 來參照 volume 的方式並不被支援 手動提供 Regional PD PersistentVolume使用 StorageClass for GCE PD 是可能的。 建立 PersistentVolume 之前, 先要建立 PD gcloud beta compute disks create --size=500GB my-data-disk --region us-central1 --replica-zones us-central1-a,us-central1-b 範例 PersistentVolume 設定檔： apiVersion: v1kind: PersistentVolumemetadata: name: test-volume labels: failure-domain.beta.kubernetes.io/zone: us-central1-a__us-central1-bspec: capacity: storage: 400Gi accessModes: - ReadWriteOnce gcePersistentDisk: pdName: my-data-disk fsType: ext4 hostPath hostPath volume 從 host node 的 filesystem 中, 掛載檔案或資料夾到 Pod 除了 path property 之外, hostPath volume 還可以使用 optional field type type 沒設或為空時, 預設不在掛載 hostPath volume 之前做任何檢查 type 為 DirectoryOrCreate 時, 如果該路徑是空的, 一個權限為 755, group 跟 owner 跟 kubelet 相同的空資料夾將會被建立 type 為 Directory 時, path 中一定要存在一個 directory type 為 FileOrCreate 時, 如果該路徑是空的, 一個權限為 644, group 跟 owner 跟 kubelet 相同的空檔案將會被建立 type 為 File 時, path 中一定要存在一個 file type 為 Socket 時, path 中一定要存在一個 UNIX socket type 為 CharDevice 時, path 中一定要存在一個 character device type 為 BlockDevice 時, path 中一定要存在一個 Block device 一樣設定的 Pods 可能會也不一樣的行為, 因為 node 不同, 而不同 node 可能有不同的檔案 建立於 host 的檔案或資料夾只有 root 可以寫。 可以使用 privileged Container 來存取 root 身份, 或在 host 修改檔案權限 範例 PodapiVersion: v1kind: Podmetadata: name: test-pdspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /test-pd name: test-volume volumes: - name: test-volume hostPath: # directory location on host path: /data # this field is optional type: Directory 注意: FileOrCreate mode 不會建立檔案的上層資料夾。 如果掛載檔案的上層資料夾不存在, Pod 會無法開始。 要確保沒問題, 可以分開掛載資料夾以及檔案, 如下： Pod FileOrCreate 範例apiVersion: v1kind: Podmetadata: name: test-webserverspec: containers: - name: test-webserver image: k8s.gcr.io/test-webserver:latest volumeMounts: - mountPath: /var/local/aaa name: mydir - mountPath: /var/local/aaa/1.txt name: myfile volumes: - name: mydir hostPath: # Ensure the file directory is created. path: /var/local/aaa type: DirectoryOrCreate - name: myfile hostPath: path: /var/local/aaa/1.txt type: FileOrCreate local local volume 代表一個本地儲存裝置, 像是硬碟, 分區, 或資料夾 local volume 只能以 PersistentVolume 的方式被使用 local volume 跟 hostPath volume 的不同之處, 在於 local volume 不需要手動的指定 Pod 到特定的 node 上 如果 node 掛了, local volume 也無法被存取, 且使用該 local volume 的 Pod 也無法運行 以下為使用 local volume 以及 nodeAffinity 的 PersistentVolume 範例： apiVersion: v1kind: PersistentVolumemetadata: name: example-pvspec: capacity: storage: 100Gi volumeMode: Filesystem accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Delete storageClassName: local-storage local: path: /mnt/disks/ssd1 nodeAffinity: required: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/hostname operator: In values: - example-node PersistentVolume nodeAffinity 當使用 local volume 時為必要的。 它啟動 Kubernetes scheduler 正確的分配有使用 local volume 的 Pod 到正確的 Node 上 PersistentVolume volumeMode 也可以設成 “Block” Questions and AnswerKubernetes persistentVolume 中, nodeAffinity field 的作用是？限制該 persistentVolume 只可從哪個 node 上被存取, 所以有定義使用該 persistentVolume 的 Pod 會被分配到該 node Kubernetes 中, 當使用 local volume 時, 哪一個 field 是必要的？nodeAffinity 解釋以下 Kubernetes example ExampleapiVersion: v1kind: PersistentVolumemetadata: name: example-pvspec: capacity: storage: 100Gi volumeMode: Filesystem accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Delete storageClassName: local-storage local: path: /mnt/disks/ssd1 nodeAffinity: required: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/hostname operator: In values: - example-node AnswerapiVersion: v1kind: PersistentVolumemetadata: name: example-pvspec: capacity: storage: 100Gi # volume 的系統格式 volumeMode: Filesystem # 這個 volume 可以被掛載到一個 node 上, read and write accessModes: - ReadWriteOnce # 當這個 persistentVolume 被 claim 釋放時, 刪除該 persistentVolume persistentVolumeReclaimPolicy: Delete storageClassName: local-storage # 使用 local volume local: path: /mnt/disks/ssd1 # 限制該 persistentVolume 只可從哪個 node 存取, 也就是說, 有定義存取該 persistentVolume 的 Pod 都會被分配到該 node nodeAffinity: required: nodeSelectorTerms: # 目標 node, key kubernetes.io/hostname, 其 value 須為 example-node - matchExpressions: - key: kubernetes.io/hostname operator: In values: - example-node Kubernetes 中, local volume 需要手動的指定 Pod 要分配到的 Node 嗎？不需要 Kubernetes 中, local volume 只能以什麼形式被使用？Persistent Volume Kubernetes 中, local volume 代表本地儲存裝置, 比如說？硬碟, 分區, 資料夾 Kubernetes 中, 當使用 hostPath 時, host 下的檔案只有 root 可以寫, 要怎麼解決這個問題呢？ 使用 privileged container 修改 host 下檔案權限 解釋以下的 Kubernetes example Example:apiVersion: v1kind: Podmetadata: name: test-webserverspec: containers: - name: test-webserver image: k8s.gcr.io/test-webserver:latest volumeMounts: - mountPath: /var/local/aaa name: mydir - mountPath: /var/local/aaa/1.txt name: myfile volumes: - name: mydir hostPath: # Ensure the file directory is created. path: /var/local/aaa type: DirectoryOrCreate - name: myfile hostPath: path: /var/local/aaa/1.txt type: FileOrCreate Answer:apiVersion: v1kind: Podmetadata: name: test-webserverspec: containers: - name: test-webserver image: k8s.gcr.io/test-webserver:latest volumeMounts: - mountPath: /var/local/aaa name: mydir - mountPath: /var/local/aaa/1.txt name: myfile volumes: # 要確保資料夾跟檔案都有掛載, 所以分開掛載兩個 - name: mydir hostPath: # Ensure the file directory is created. path: /var/local/aaa type: DirectoryOrCreate - name: myfile hostPath: path: /var/local/aaa/1.txt type: FileOrCreate Kubernetes 中, type field 為 BlockDevice 時, 預設效果是？type 為 BlockDevice 時, path 中一定要存在一個 Block device Kubernetes 中, type field 為 CharDevice 時, 預設效果是？type 為 CharDevice 時, path 中一定要存在一個 character device Kubernetes 中, type field 為 Socket 時, 預設效果是？type 為 Socket 時, path 中一定要存在一個 UNIX socket Kubernetes 中, type field 為 File 時, 預設效果是？type 為 File 時, path 中一定要存在一個 file Kubernetes 中, type field 為 FileOrCreate 時, 預設效果是？type 為 FileOrCreate 時, 如果該路徑是空的, 一個權限為 644, group 跟 owner 跟 kubelet 相同的空檔案將會被建立 Kubernetes 中, type field 為 Directory 時, 預設效果是？type 為 Directory 時, path 中一定要存在一個 directory Kubernetes 中, type field 為 DirectoryOrCreate 時, 預設效果是？如果該路徑是空的, 一個權限為 755, group 跟 owner 跟 kubelet 相同的空資料夾將會被建立 Kubernetes 中, type field 為空或沒設時, 預設效果是？預設不會在掛載 hostPath volume 之前針對 path 做任何檢查 Kubernetes 中, hostPath volume 除了 path field 之外, 還能使用哪一個 optional field？type field Kubernetes 中, hostPath volume 的作用是？從 host node 的 filesystem 中, 掛載檔案或資料夾到 Pod 解釋以下 Kubernetes example Example:apiVersion: v1kind: PersistentVolumemetadata: name: test-volume labels: failure-domain.beta.kubernetes.io/zone: us-central1-a__us-central1-bspec: capacity: storage: 400Gi accessModes: - ReadWriteOnce gcePersistentDisk: pdName: my-data-disk fsType: ext4 Answer:apiVersion: v1# 定義 PersistentVolumekind: PersistentVolumemetadata: name: test-volume labels: failure-domain.beta.kubernetes.io/zone: us-central1-a__us-central1-bspec: capacity: # 容量定義為 400Gi storage: 400Gi # 定義存取模式 accessModes: - ReadWriteOnce # 使用 gcePersistentDisk gcePersistentDisk: # 輸入 pdName pdName: my-data-disk # file system 類型 fsType: ext4 Kubernetes volume 中, 若要使用 Regional Persistent Disk, volume 要以什麼形式提供？PersistentVolume 解釋以下 Kubernetes example Example:apiVersion: v1kind: Podmetadata: name: test-pdspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /test-pd name: test-volume volumes: - name: test-volume # This GCE PD must already exist. gcePersistentDisk: pdName: my-data-disk fsType: ext4 Answer:apiVersion: v1kind: Podmetadata: name: test-pdspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /test-pd name: test-volume volumes: - name: test-volume # This GCE PD must already exist. # 使用 GCP Persistent Disk gcePersistentDisk: pdName: my-data-disk fsType: ext4 Kubernetes volume 中, 當使用 GCE Persistent Disk 時, read-write 模式支援多方存取嗎？不支援 Kubernetes volume 中, 當使用 GCE Persistent Disk 時, read-only 模式支援多方存取嗎？支援 Kubernetes volume 中, 當使用 GCE Persistent Disk 時, Persistent Disk 與 VMs 需位於怎麼樣的條件？ 同一個 GCE project 同一個 zone Kubernetes volume 中, 當使用 GCE Persistent Disk 時, Pods 所運行的 Node 必須要是 GCE VMs, 是或不是？是 Kubernetes volume 中, Persistent Disk 可以預先載入, 被多個 Pod 使用嗎？可以 Kubernetes volume 中, 當我使用 Persistent Disk 為 volume 時, 當 Pod 被移除時, PD 的資料會被移除嗎？不會 Kubernetes 中, emptyDir 的存活時間為多久？emptyDir 的存活時間跟該 Pod 在該 Node 的時間一樣長 Kubernetes 中, emptyDir volume 剛建立時裡頭有什麼東西？emptyDir 一開始是空的 Kubernetes 中, 同個 Pod 內的不同容器可否讀寫同一個 emptyDir volume 的檔案？可 Kubernetes 中, emptyDir 可否被掛載到不同容器中不同路徑？可 Kubernetes 中, 當 Pod 從 Node 被移除, emptyDir 中的資料還會存在嗎？不會, 會被永久刪除 Kubernetes 中, 如果一個 Pod 中有一個容器 crashes, 那會影響到 emptyDir volume 中的資料嗎？不會 Kubernetes 中, 預設上, emptyDir 會被儲存在什麼地方？該 Node 所在的 medium Kubernetes 中, emptyDir 可以被掛載到 tmpfs 嗎？可以 Kubernetes 中, 若要掛載 emptyDir 到 tmpfs, 需使用哪一個欄位？？emptyDir.medium Kubernetes 中, 當 Node reboot, tmpfs 中的資料會如何？會被清除 Kubernetes 中, tmpfs 是？RAM based filesystem Kubernetes 中, tmpfs 的用量會算在 memory limits 嗎？會哦 Kubernetes 中, emptyDir volume 是在什麼時候被建立的？當 Pod 被分配給一個 Node 時 解釋以下 Kubernetes example ExampleapiVersion: v1kind: Podmetadata: name: test-pdspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /cache name: cache-volume volumes: - name: cache-volume emptyDir: &#123;&#125; AnswerapiVersion: v1kind: Podmetadata: name: test-pdspec: containers: - image: k8s.gcr.io/test-webserver name: test-container volumeMounts: - mountPath: /cache name: cache-volume volumes: - name: cache-volume # 定義一個 emptyDir 類型的 volume emptyDir: &#123;&#125; Kubernetes 中, volume 可以硬連結到另一個 volume 嗎？不行 Kubernetes 中, volume 可以掛載到另外一個 volume 裡嗎？不行 Kubernetes 中, 一般來說, volume 的周命週期與什麼相同？Pod","link":"/zh-tw/kubernetes-concepts-storage-volumes/"},{"title":"Kubernetes - Container Lifecycle Hooks","text":"概述如許多的程式語言框架, 如 Angular, 有著元件生命週期 hooks, Kubernetes 也為容器提供了生命週期 hooks。 Hooks 使容器在管理的生命週期間可以意識到事件的發生, 並且當對應的生命週期 hook 被觸發時, 執行在 handler 中實作的程式碼。 簡單來說呢, 就是 Kubernetes 內建兩種 hook, 在兩個特殊的時機點會被觸發, 而我們可以針對這兩點 hook, 也就是這兩個時機點去設定 handler, 當這個時機點到了, 你希望執行什麼程式碼, 做些什麼事, 等等…比如說, 你可以在 Nginx 容器退出時, 在其 PreStop hook handler 加上一段 nginx -s quit 來優雅退出 此處 hooks 中文翻譯為鉤子, 但是 Ray 個人覺得有點彆扭, 可能是 Ray 已經習慣原文 hook, 所以在本篇中不會特別翻譯 前言Kubernetes 的學習筆記, 內文可能會有大量的 Q&amp;A, 因為這是 Ray 的獨特學習方式！ 就像是獨孤求敗之於獨孤九劍一樣～ 容器 hooks共有兩種 hooks, PostStart 以及 PreStop PostStart 在容器啟動之後, 會立即的觸發 PostStart hook, 但是無法保證 PostStart 會先被觸發, 或者是容器的 ENTRYPOINT 會先被觸發, 因為這個動作是非同步的 PreStop 在容器被結束之前, 會觸發 PreStop, 這個動作是同步的, 所以 PreStop 必須在刪除容器的請求送出之前先完成 Hook handler 實作容器可以存取一個 hook, 藉由實作以及註冊一個 handler 給這個 hook。 可以在容器中被實作的 hook handler 有兩種： Exec - 在 cgroups 以及命名空間中, 執行一個特定的指令, 像是 pre-stop.sh。 這個指令消耗的資源會被算在這個容器上 HTTP - 在容器的一個特定端點執行一個 HTTP 請求 執行 hook handler當 hook 被觸發, Kubernetes 管理系統會執行註冊給該 hook 的 handlerHook handler 的呼叫在裝有這個容器的 Pod 當中是同步的, 這表示說, PostStart hook 的觸發, 以及該容器的 ENTRYPOINT 是非同步的。然而, 如果 hook 耗費太久的時間運行或僵在那, 容器便無法進到 running 狀態, 類似的行為也套用在 PreStop hook 上, 如果 hook 一直卡在執行中, Pod 會一直處於 Terminating 階段, 然後在 terminationGracePeriodSeconds 時間過後會被砍掉, terminationGracePeriodSeconds 是預設的優雅退出的秒數。 如果 PostStart 或 PreStop hook 失敗了, 容器會被 killed使用者應該盡可能地讓 hook handler 越輕量化越好。 然而, 有時候執行一些長的指令還是必要的, 像是在停止容器之前儲存狀態 Hook 交付保證通常 hook 至少會被交付一次, 這表示, 依據不同的事件, hook 有可能被呼叫多次, 像是 PostStart 或 PreStop通常 hook 只會交付一次, 但在一些少數的例子中會重複交付, 例如, kubelet 在傳送一個 hook 的途中被重啟, 那當 kubelet 重啟完成後, 這個 hook 可能會被再次傳送 Debugging Hook handlerHook handler 的 logs 並不會被暴露在 Pod 事件中。 如果一個 handler 因為某些原因失敗了, 它會廣播一個事件。 如果 PostStart 失敗了, 那就是 FailedPostStartHook 事件, 如果是 PreStop, 那就是 FailedPreStopHook 事件, 你可以執行 kubectl describe pod podName 來檢視這些事件, 以下是這個指令取得的一些事件範例： Events: FirstSeen LastSeen Count From SubObjectPath Type Reason Message --------- -------- ----- ---- ------------- -------- ------ ------- 1m 1m 1 &#123;default-scheduler &#125; Normal Scheduled Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Pulling pulling image &quot;test:1.0&quot; 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Created Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined] 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Pulled Successfully pulled image &quot;test:1.0&quot; 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Started Started container with docker id 5c6a256a2567 38s 38s 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Killing Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1 37s 37s 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Killing Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1 38s 37s 2 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; Warning FailedSync Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;main&quot; with RunContainerError: &quot;PostStart handler: Error executing in Docker Container: 1&quot; 1m 22s 2 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Warning FailedPostStartHook 範例實作PostStart hook以下 yaml 依照順序執行以下動作, 讓我們一步步來解釋: 啟動一個 nginx 容器 在啟動之後, 執行一段指定的 command 將 Hello this is post-start-demo-hook-handler 這一段話 echo 到 /demo-messages 檔案 接著我們使用 kubectl exec -it post-start-demo-hook-handler /bin/bash 進到這個容器 執行 cat demo-message, 可看到上面我們 echo 進去的 string 這代表說, postStart hook handler 確實有在容器啟動之後執行 apiVersion: v1kind: Podmetadata: name: post-start-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: post-start-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: postStart: exec: command: - &quot;/bin/bash&quot; - &quot;-c&quot; - &quot;echo &#x27;Hello this is post-start-demo-hook-handler&#x27; &gt; /demo-message&quot; PreStop hook以下的步驟將會示範 PreStop hook, 請依照以下步驟操作 執行 kubectl apply -f fileName 來建立一個 nginx pod, yaml 檔如下 執行 kubectl delete pod pre-stop-demo-hook-handler, 把 pod 刪除 因為有設定 preStop lifecycle hook, 所以 pod 會在刪除前執行設定好的 hook handler hook handler 為執行一段 command, 會將 Hello this is the pre-stop-demo-hook-handler 這段 string echo 到 /demo/message 這個檔案中 因為這個 pod 馬上就要關閉了, 如果關閉了自然 pod 內的 /demo/message 也會銷毀, 所以我們在外頭定義一個 volume, 並掛在到容器裡, 這樣當 string 被 echo 到 /demo/message 時, 也會同步到外面來 最後執行 cat var/tmp/demo/message, 成功印出 Hello this is the pre-stop-demo-hook-handler, 代表在容器結束前, 確實有執行 preStop handler apiVersion: v1kind: Podmetadata: name: pre-stop-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: pre-stop-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: preStop: exec: command: - &quot;bin/bash&quot; - &quot;-c&quot; - &quot;echo &#x27;Hello this is the pre-stop-demo-hook-handler&#x27; &gt; /demo/message&quot; volumeMounts: - mountPath: /demo/ name: demo volumes: - name: demo hostPath: path: /var/tmp/demo Q&amp;A請解釋以下的 kubernetes yaml file 中的每一條 directive yaml file:apiVersion: v1kind: Podmetadata: name: post-start-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: post-start-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: postStart: exec: command: - &quot;/bin/bash&quot; - &quot;-c&quot; - &quot;echo &#x27;Hello this is post-start-demo-hook-handler&#x27; &gt; /demo-message&quot; Answer:# API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # Pod name name: post-start-demo-hook-handler # 定義 label labels: app: life-cycle-hook# 定義 pod 規格spec: # 定義容器 containers: # 定義容器名稱 - name: post-start-demo-hook-handler # 定義鏡像名稱 image: nginx # 定義 ports ports: # 容器內 port - containerPort: 80 # port name name: demo-port # 定義 lifecycle lifecycle: # 定義 postStart hook, 會自容器啟動後執行 postStart: # hook handler 類型為 exec exec: # 執行以下指令 command: - &quot;/bin/bash&quot; - &quot;-c&quot; - &quot;echo &#x27;Hello this is post-start-demo-hook-handler&#x27; &gt; /demo-message&quot; 請解釋以下的 Kubernetes yaml file 中的每一條 directive yaml file:apiVersion: v1kind: Podmetadata: name: pre-stop-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: pre-stop-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: preStop: exec: command: - &quot;bin/bash&quot; - &quot;-c&quot; - &quot;echo &#x27;Hello this is the pre-stop-demo-hook-handler&#x27; &gt; /demo/message&quot; volumeMounts: - mountPath: /demo/ name: demo volumes: - name: demo hostPath: path: /Users/ray/code/kubernetes/demo Answer:# API 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod name name: pre-stop-demo-hook-handler # 定義 label labels: app: life-cycle-hook# Pod 運行的規格spec: # 定義容器 containers: # 容器名稱 - name: pre-stop-demo-hook-handler # 鏡像名稱 image: nginx # 定義 ports ports: # 容器 port - containerPort: 80 # port name name: demo-port # 定義生命週期 lifecycle: # 定義 hook preStop: # 定義 handler 類型 exec: # 執行指令 command: - &quot;bin/bash&quot; - &quot;-c&quot; - &quot;echo &#x27;Hello this is the pre-stop-demo-hook-handler&#x27; &gt; /demo/message&quot; # 掛載 volume volumeMounts: # 掛載到容器內的位置 - mountPath: /demo/ # volume 內, 需先定義 name: demo # 定義 volume volumes: # volume 名稱 - name: demo # volume 在外部 host 的位置 hostPath: # 路徑 path: /Users/ray/code/kubernetes/demo 以下的 Kubernetes example command 的意思是？ Example:kubectl delete pod podName --grace-period=0 --force=true Answer:立即強制刪除一個 pod, 不等待預設的 30 秒 grace shutdown Kubernetes 中, 當使用 kubectl delete pod podName 時, 預設會等待幾秒, 才會強制刪除？30 秒 Kubernetes 中, 當使用 kubectl delete pod podName 時, 事實上使用了 docker stop, 它會發送一個什麼信號？SIGTERM Kubernetes 中, 當使用 kubectl delete pod podName, 事實上是使用了哪一個 docker 的指令？docker stop Kubernetes 中, 如果 PostStart hook 失敗了, 會廣播什麼事件？FailedPostStartHook Kubernetes 中, 如果 PreStop hook 失敗了, 會廣播什麼事件？FailedPreStopHook Kubernetes 中, 要如何檢視 pod 的事件？kubectl describe pod podName Kubernetes 中, 如果 hook handler 失敗了, 會發生什麼事？會廣播一個事件 Kubernetes 中, 什麼情況下 hook 有可能被呼叫兩次？當呼叫 hook 到一半時, kebelet 被重啟 Kubernetes 中, hook 有可能被呼叫兩次嗎？有可能 Kubernetes 中, 如果 PostStart 或 PreStop hook 失敗了, 會發生什麼事？容器會被 killed Kubernetes 中, 如果 PreStop 一直卡在執行中, 會發生什麼事？pod 會在 terminationGracePeriodSeconds 之後被砍掉 為什麼 Kubernetes PostStart hook 跟容器的 ENTRYPOINT 是非同步的？因為 PostStart hook 跟裝有該容器的 Pod 是同步的 Kubernetes hook handler 的呼叫與哪個元件來說是同步的？pod Kubernetes hook handler 中, HTTP 做了什麼事？在容器的一個特定端點執行一個 HTTP request Kubernetes hook handler 中, Exec 消耗的資源算在哪裡？該容器上 Kubernetes hook handler 中, Exec 具體來說是什麼？執行一個特定的指令 Kubernetes 中, 可被實作的 hook handler 是哪兩種？ Exec HTTP Kubernetes 中, PreStop hook 跟刪除容器的請求, 哪一個要先完成?PreStop hook Kubernetes 中, PreStop hook 觸發時機為?容器被結束前 Kubernetes 中, PostStart hook 和 container entrypoint 哪一個會先觸發？不一定, 是非同步的 Kubernetes 中, 共有哪兩種 container hooks?- **PostStart** - **PreStop** Kubernetes 中, PostStart hook 觸發時機為？容器啟動後","link":"/zh-tw/kubernetes-container-lifecycle-hooks/"},{"title":"Kubernetes - RBAC - 建立一個只允許存取特定權限的使用者","text":"# 前言本篇主要紀錄 Kubernetes RBAC 的部分使用方法 # 目標 在 cluster 內建立一個 user, 該 user 只可通過 client 端的 private key 以及 certificate 方可存取 限制 cluster 內特定 user 只可存取特定的 namespace 在本文中, 我們會建立一個 user ray, group learnordie, 只可訪問 namespace kube-system # 建立用戶憑證# 建立一個 private key, 名稱為 ray.keyopenssl genrsa -out ray.key 2048 # 建立一個 csr, 並定義 user name 以及 user groupopenssl req -new -key ray.key -out ray.csr -subj &quot;/CN=ray/O=learnordie&quot; # 生成最終 crt 文件預設 Kubernetes CA 文件位置為 /etc/kubernetes/pki/ 目錄下 openssl x509 -req -in ray.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ray.crt -days 500 # 建立 user 及 context上面我們生成了由 Kubernetes CA 所簽署的 crt, 接下來我們使用這個 crt 來建立 user, 以及 context # 建立 userkubectl config set-credentials ray --client-certificate=ray.crt --client-key=ray.key # 建立 context可以擁有多個 context, 用於記住不同操作對象的整套資訊, 例如 user ray, cluster 為 ray-cluster, 預設的 namespace 為 ray-namespace, 可使用 kubectl config use-context 來設定預設的 context, 可使用 kubectl config current-context 取得預設 context kubectl config set-context demo-context --cluster=yourClusterName --namespace=kube-system --user=ray # 建立 role 以及 rolebinding依照上面的步驟, 已經建立了 user 以及 context, 這時如果我們使用此 context 來取得資訊, 將會出錯, 因為此時的 user ray 並沒有任何的權限 kubectl get pods --context demo-context 因此, 接下來我們要建立代表權限的 role, 以及用來綁定 user 以及 role 的 role binding # 建立 role建立以下 yaml file, 名為 demo-role.yaml apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: name: demo-role namespace: kube-systemrules:- apiGroups: [&quot;&quot;, &quot;apps&quot;] resources: [&quot;pods&quot;, &quot;replicasets&quot;, &quot;deployments&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;] 從 demo-role.yaml 建立該 role kubectl apply -f demo-role.yaml # 建立 role binding建立以下 yaml file, 名為 demo-role-binding.yaml apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: demo-rolebinding namespace: kube-systemsubjects: - kind: User name: ray apiGroup: &quot;&quot;roleRef: kind: Role name: demo-role apiGroup: &quot;&quot; 從 demo-role-binding.yaml 建立該 role binding kubectl apply -f demo-role-binding.yaml 這時如果可以看看 role 以及 role binding 有沒有出現在 kube-system kubectl get role -n kube-systemkubectl get rolebinding -n kube-system # 驗證沒意外的話, 現在使用 demo-context 來取得 namespace 為 kube-system 的 resources pods, deployments, replicasets 都是沒有問題的 kubectl get pods --context demo-context 每次使用 demo-context, Kubernetes 都會去檢查當初簽署的 ray.csr 以及 ray.crt, 換言之, 要是少了這兩樣東西, 便無法以 ray 這個 user 對 cluster 做操作, 若要變更檢查金鑰的目錄, 可修改 config 檔案, 預設位置為 ~/.kube/config # 參考來源官方文件官方文件官方文件man openssl # Questions and Answers以下的 openssl example command 的意思是？ Example:openssl genrsa -out ray.key 2048 Answer:生成一個 private key, -out 代表指定輸出檔案的檔名, 2048 表示要生成幾 bit 的 private key 以下的 openssl example command 的意思是？ Example:openssl req -new -key ray.key -out ray.csr -subj &quot;/CN=ray/O=learnordie&quot; Answer: req: 代表建立一個 csr-new: 產生一個新的 csr file-key: 指定 private key-out: 輸出 csr 名稱-subj: 定義 subject field 的值, 格式通常為 /type0=value0/type1=value1/type2=... 以下的 openssl example command 的意思是？ Example:openssl x509 -req -in ray.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out ray.crt -days 500 Answer: x509: 有多種用途, 這邊為生成 crt-req: 指定輸入檔案為 csr, 而非 crt-in: 要讀取的檔案-CA: 要使用的 CA 證書。 當使用此 flag 時, x509 用途 mini CA, issuer name 為 CA subject name, 且使用 CA private key 數位簽署 csr-CAkey: 指定用來簽名的 CA private keyCAcreateserial: 建立一個 ca.srl 的序號檔, 用來記錄 CA 簽了多少個 crt, 如果已經有了就可以直接使用 CAserial 指定檔案-out: 輸出檔案名稱-days: 證書有效期限 以下的 kubernetes example command 的意思是？ Example:kubectl config set-credentials ray --client-certificate=ray.crt --client-key=ray.key Answer:建立一個 Kubernetes user, 並指定 crt 以及 private key 以下的 kubernetes example command 的意思是？ Example:kubectl config set-context demo-context --cluster=yourClusterName --namespace=kube-system --user=ray Answer:可以擁有多個 context, 用於記住不同操作對象的整套資訊, 例如 user ray, cluster 為 ray-cluster, 預設的 namespace 為 ray-namespace, 可使用 kubectl config use-context 來設定預設的 context, 可使用 kubectl config current-context 取得預設 context","link":"/zh-tw/kubernetes-create-a-user-can-only-access-a-specific-namespace/"},{"title":"kubernetes - Secrets","text":"Kubernetes Secrets 讓你可以儲存敏感資訊, 像是密碼 OAuth tokens, 以及 ssh keys。 將機密資訊儲存在 Secret 比一字不差的存在 Pod 定義 yaml 檔或容器鏡像中安全也靈活的多。 更多資訊可以參考 Secrets design document 概述Secret 是一個物件, 它含有小量的敏感資訊, 像是密碼, OAuth toke, 或是 key。 這些資訊也可能被放在 Pod 的 specification 或 image 當中。 使用者可以建立 secrets, 而系統也可以建立 secrets。要使用 secret, Pod 必須 reference secret。 Secret 有兩種方式可與 Pod 一起使用。 可以以檔案的形式存在於 volume, volume 可掛載到一個或多個容器 當拉取鏡像時, 為 kubelet 所使用 內建的 SecretesService account 自動建立並且將 API 機敏資訊加到 Secrets 當中Kubernetes 自動建立 secrets, 這些 secretes 含有存取 API 所需的機敏資訊, 以及自動的修改 Pods 來使用這些 secret這些自動建立並且使用 API 機敏資訊可以被取消, 並且如果想要的話也可以覆蓋這些規則。 然而, 如果你想要安全的存取 API server 的話, 這個 workflow 會是比較建議的。更多有關 service account 的資訊可以參考 ServiceAccount 文件 建立你自己的 Secrets使用 kubectl 建立 SecretSecrets 可以包含 Pod 存取 database 時所需要的帳密。 比方說, 資料庫連線包含的 username 以及 password。 你可以將 username 存到本機的 ./username.txt 檔案, 以及 password 存到 ./password.txt 檔案 # 建立需要的檔案, 之後的範例會用到echo -n &#x27;admin&#x27; &gt; ./username.txtecho -n &#x27;1f2d1e2e67df&#x27; &gt; ./password.txt kubectl create secret 指令會打包這些檔案到 Secret 並且在 API server 當中建立這個物件。 執行指令:kubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txt 輸出類似:secret &quot;db-user-pass&quot; created 注意:特殊符號像是 $, \\, *, 以及 ! 會被你的 shell 轉換, 所以會需要 escape。 在大部分的 shell 當中, escape password 最簡單的方法就是用 single quote (&#39;) 把 string 包住。 舉例來說, 如果你的密碼是 S!B\\*d$zDsb, 你應執行指令如下： 執行指令:kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password=&#x27;S!B\\*d$zDsb&#x27; 類似輸出:kubectl get secrets 類似輸出:NAME TYPE DATA AGEdb-user-pass Opaque 2 51s 你可以檢視 secret 的描述 執行指令: kubectl describe secrets/db-user-pass 類似輸出： Name: db-user-passNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Type: OpaqueData====password.txt: 12 bytesusername.txt: 5 bytes 注意: 指令 kubectl get 以及 kubectl describe 預設上會避免顯示 secret 的內容, 這是為了防止旁觀者看到內容, 或是避免內容被儲存到 terminal 的 log 中 可參考 decoding a secret 有關如何檢視 secret 內容。 手動建立 Secret你也可以從檔案建立 Secret, 可以是 JSON 或是 YAML 格式, 然後建立這個物件。 Secret 包含兩種 maps: data 以及 stringData。 data 欄位用來儲存任意的資料, 使用 base64 加密。 stringData 讓你可以提供未加密的 string舉例來說, 使用 data 欄位來儲存兩個 string, 將 string 如下轉為 base64 執行指令echo -n &#x27;admin&#x27; | base64 輸出類似YWRtaW4= 執行指令echo -n &#x27;1f2d1e2e67df&#x27; | base64 輸出類似MWYyZDFlMmU2N2Rm 建立一個 Secret YAML file 如下： apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: username: YWRtaW4= password: MWYyZDFlMmU2N2Rm 然後使用 kubectl apply 來建立 執行指令kubectl apply -f ./secret.yaml 輸出類似secret &quot;mysecret&quot; created 某些情況之下, 你可能會需要使用 stringData 欄位。 這個欄位讓你可以輸入一個未經 base64 加密的 string, 然後這個 string 會在 Secret 被建立或更新時自動加密 一個例子是, 當你在部署一個應用, 這個應用使用 Secret 來儲存設定檔, 然後你想要在部署過程中載入設定檔中的部份資訊 舉例來說, 你的應用使用以下設定檔 apiUrl: &quot;https://my.api.com/api/v1&quot;username: &quot;user&quot;password: &quot;password&quot; 你可以使用以下的定義來將這個設定檔儲存到 Secret apiVersion: v1kind: Secretmetadata: name: mysecrettype: OpaquestringData: config.yaml: |- apiUrl: &quot;https://my.api.com/api/v1&quot; username: &#123;&#123;username&#125;&#125; password: &#123;&#123;password&#125;&#125; 你的部署工具可以在執行 kubectl apply 之前將 &#123;&#123;username&#125;&#125; 以及 &#123;&#123;password&#125;&#125; 範本變數替換掉 stringData 欄位是只允許寫的欄位, 當你在存取 Secrets 時, 它是不會輸出的。 舉例來說, 如果你執行以下指令: 執行指令:kubectl get secret mysecret -o yaml 類似輸出：apiVersion: v1kind: Secretmetadata: creationTimestamp: 2018-11-15T20:40:59Z name: mysecret namespace: default resourceVersion: &quot;7225&quot; uid: c280ad2e-e916-11e8-98f2-025000000001type: Opaquedata: config.yaml: YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19 如果有一個欄位, 舉例來說, username, 同時指定到 data 以及 stringData, 那將會使用 stringData。 舉例來說, 以下的範例 Secret 定義： apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: username: YWRtaW4=stringData: username: administrator 結果輸出如下： apiVersion: v1kind: Secretmetadata: creationTimestamp: 2018-11-15T20:46:46Z name: mysecret namespace: default resourceVersion: &quot;7579&quot; uid: 91460ecb-e917-11e8-98f2-025000000001type: Opaquedata: username: YWRtaW5pc3RyYXRvcg== YWRtaW5pc3RyYXRvcg== 經過 base64 解密後為 administrator。data 以及 stringData 的 key 需含有 alphanumeric 符號, -, _, 或 . 注意: 有序列的 JSON 以及 YAML secret data 值會被加密成 base64 string。 在這些 string 中, Newlines 是不合法的且必須要忽略。 當在 Darwin/macOS 中使用 base64 時, 使用者須避免使用 -b 選項來分開長行。 相反的, Linux 使用者需加入 -w 0 選項 到 base64 指令, 如果 -w 不可獲得, 那可以使用 base64 | tr -d &#39;\\n&#39; 使用 generator 建立 Secret從 Kubernetes v1.14 開始, kubectl 支援 使用 kustomize 管理物件。 kustomize 提供了 resource Generators (資源產生器) 來建立 Secret 以及 ConfigMaps。 Kustomize generators 需被指定在 kustomization.yaml 檔案, 而這個檔案需位於一個資料夾內。 在產生 Secret 後, 你可以使用 kubectl apply 來在 API server 中建立 Secret 物件 從檔案產生 Secret你可以定義 secretGenerator 從檔案 ./username.txt 以及 ./password.txt 產生 Secret, 如下： cat &lt;&lt;EOF &gt;./kustomization.yamlsecretGenerator:- name: db-user-pass files: - username.txt - password.txtEOF Apply 含有 kustomization.yaml 檔資料夾來建立 Secret: kubectl apply -k . 輸出類似： secret/db-user-pass-96mffmfh4k created 經由以下指令確認 secret 已建立 kubectl get secrets 輸出類似： NAME TYPE DATA AGEdb-user-pass-96mffmfh4k Opaque 2 51s 輸入指令 kubectl describe secrets/db-user-pass-96mffmfh4k 類似輸出： Name: db-user-passNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Type: OpaqueData====password.txt: 12 bytesusername.txt: 5 bytes 解密 SecretSecret 可以透過 kubectl get secret 取得。 比方說, 你可以執行 以下指令來檢視已建立的 secret: 執行指令 kubectl get secret mysecret -o yaml 輸出類似： apiVersion: v1kind: Secretmetadata: creationTimestamp: 2016-01-22T18:41:56Z name: mysecret namespace: default resourceVersion: &quot;164619&quot; uid: cfee02d6-c137-11e5-8d73-42010af00002type: Opaquedata: username: YWRtaW4= password: MWYyZDFlMmU2N2Rm 解密 password 欄位 echo &#x27;MWYyZDFlMmU2N2Rm&#x27; | base64 --decode 輸出類似： 1f2d1e2e67df 編輯 Secret可使用以下指令編輯 Secret 執行 kubectl edit secrets mysecret 這將會打開預設編輯器, 並且可以更新在 data 欄位的 base64 加密的 Secret 值: # 更新以下物件, # 開頭的行會被忽略# 若檔案為空會終止這次編輯。 若儲存檔案時有錯, 則會回應相關錯誤。apiVersion: v1data: username: YWRtaW4= password: MWYyZDFlMmU2N2Rmkind: Secretmetadata: annotations: kubectl.kubernetes.io/last-applied-configuration: &#123; ... &#125; creationTimestamp: 2016-01-22T18:41:56Z name: mysecret namespace: default resourceVersion: &quot;164619&quot; uid: cfee02d6-c137-11e5-8d73-42010af00002type: Opaque 使用 SecretSecret 可被以 data volume 的方式掛載, 或是以環境變數的方式被 Pod 中的容器使用。 Secret 亦可非直接地暴露給 Pod, 由系統的其他部分所使用。 舉例來說, 一些系統的其他部分會代表你與外部系統互動, 而 Secret 可儲存其中會使用到的機敏資訊。 以 Pod 中檔案的方式使用 Secret在 Pod 的 volume 中使用 Secret: 建立 secret 或使用現有的。 多個 Pod 可使用同一個 secret 修改 Pod 定義, 在 .spec.volumes[] 下增加一個 volume。 娶個任意的名字, 讓 .spec.volumes[].secret.secretName 欄位與 Secret 物件的名稱相同 增加 .spec.container[].volumeMounts[] 到需要 secret 的每個容器。 指定 .spec.container[].volumeMounts[].readOnly = true 以及 spec.container[].volumeMounts[].mountPath 到一個未使用的資料夾名稱, 你想要 secret 會出現在這個資料夾內 修改鏡像或指令, 所以程式會在這個資料夾尋找檔案。 每個 secret data 中的 key 都會變成是 mountPath 下的一個檔案 以下是掛載 Secret 到 Pod volume 範例： apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret 每個你想要使用的 Secret 都必須在 .spec.volumes 中被 reference如果在 Pod 中有很多容器, 那麼每一個容器都需要各自的 volumeMounts 區塊, 但 .spec.volumes 每一個 Secret 只需要一個你可以將多個檔案打包到一個 secret, 或使用多個 secret, 取決於你覺得方便。 投射 Secret keys 到指定的路徑在 secret key 投射的 volume 內, 你也可以控制其路徑。 你可以使用 .spec.volumes[].secret.items 欄位來改變每個 key 的目標路徑 範例apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username 預計行為： username secret 被儲存在 /etc/foo/my-group/my-username 檔案, 而不是 /etc/foo/username password secret 未被投射 如果 .spec.volumes[].secret.items 被使用, 那只有被指定在 items 中的 key 會被投射。 如果要使用所有的 keys, 那所有的 keys 都要被列在 items 欄位下。 所有被列在 items 內的 key 必須存在於對應的 Secret 下, 否則跟 volume 不會被建立。 Secret 檔案權限你可以為每一個 Secret key 設定存取權限。 如果你沒特別指定, 預設使用 0644。 你也可以設定一個預設權限給整個 Secret volume, 而如果有需要的話, 可以複寫個別的 key舉例來說, 預設權限如下： apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; volumes: - name: foo secret: secretName: mysecret defaultMode: 256 然後, 這個 secret 將會被掛載到 /etc/foo, 且所有由此 secret volume 建立的檔案權限皆為 0400注意到, 因為 JSON 格式並不支援八進制符號, 所以使用 256 來代表 0400 權限。 如果你使用 YAML 而不是 JSON 的話, 你可以直接使用八進制來指定權限, 這樣看起來更自然。 如之前的範例, 你也可以使用 mapping 來針對不同的檔案指定不同的權限, 如下： apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username mode: 511 在這個範例中, 檔案 /etc/foo/my-group/my-username 的權限將會是 0777。 因為 JSON 的限制, 所以你必須以十進位的方式指定注意到, 權限的值在你待會讀到的範例中, 會以十進位方式呈現 從 volumes 中使用 Secret在我掛載 secret volume 的容器內, secret key 以檔案的形式存在, 且其值為 base64 解密過, 存愛這些檔案內。 以下是在容器內執行指令的結果 執行指令: ls /etc/foo/ 類似輸出: usernamepassword 執行指令: cat /etc/foo/username 類似輸出: admin 執行指令 cat /etc/foo/password 類似輸出： 1f2d1e2e67df 容器內的程式將會負責讀取這些代表 secret 的檔案 掛載的 Secret 會自動更新當被 volume 所使用的 Secret 更新了, 投射的 key 最終也會跟著更新。 Kubelet 會週期性的確認掛載的 Secret 是最新的。 然而, Kubelet 使用本地的 cache 來取得 Secret 當前的值。 cache 的類型為 KubeletConfiguration struct 的 ConfigMapAndSecretChangeDetectionStrategy 欄位所定義。 Secret 可以由 watch (預設) 傳播, 或 ttl-based, 或簡單的轉發所有 requests 到 API server。 結果就是, 從 Secret 被更新那刻開始到新的 key 被投射到 Pod 的總時間會等於 Kubelet 同步週期 + cache 傳播延遲時間, 而 cache 傳播延遲時間取決於選擇的 cache type (相當於 watch 傳播延遲時間, ttl of cache, 或 0 相對延遲) 注意: 以 subPath volume 掛載方式使用 Secret 的容器將不會收到 Secret 通知 以環境變數的方式使用 Secret若要以 環境變數 的方式在 Pod 中使用 Secret 的話: 建立一個 secret, 或使用現存的。 多個 Pod 可使用同一個 Secret 修改 Pod 的定義, 在 Pod 中的每一個你希望使用 secret 值得容器內, 為每個 secret key 增加環境變數。 使用 secret key 的環境變數必須在 env[].valueFrom.secretKeyRef 欄位中載入 secret name 以及 key 修改鏡像 以及/或 命令行, 讓程式使用指定的環境變數 以下為從環境變數中使用 secrets 的範例: apiVersion: v1kind: Podmetadata: name: secret-env-podspec: containers: - name: mycontainer image: redis env: - name: SECRET_USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password restartPolicy: Never 從環境變數來使用 Secret 值在把 secret 當成環境變數來使用的容器中, secret key 以一般的環境變數方式存在, 這些環境變數的值為 base64 解密後 secret 的值。 以下是一些在容器內指令執行後的結果： 執行echo $SECRET_USERNAME 結果admin 執行echo $SECRET_PASSWORD 結果1f2d1e2e67df 使用 imagePullSecretsimagePullSecrets 欄位唯一系列 Secret 的指向。 你可以使用 imagePullSecrets 來將含有 Docker (或其他類型) 鏡像 registry 密碼這些資料傳給 kubelet。 Kubelet 會使用這些資訊來代替 Pod 拉取私人鏡像。 更多有關 imagePullSecrets 欄位的資訊可以參考 PodSpec API 手動指定 imagePullSecret從 容器鏡像文件 可以學到如何指定 ImagePullSecrets 自動附加 imagePullSecret你可以手動建立 imagePullSecrets, 並且從 ServiceAccount 來參照。 任何由這個 ServiceAccount 所建立的 Pod, 或是預設由這個 ServiceAccount 建立的 Pod 都會將 imagePullSecrets 欄位設為此 ServiceAccount。 更多資訊可參考 將 ImagePullSecrets 加到 ServiceAccount 自動掛載手動建立的 Secret手動建立的 secrets (比如說, 一個含有存取 GitHub 帳號 token 的 secret) 可以被自動附加到 Pods, 依據他們的 service account。 更多的資訊可以參考 使用 PodPreset 來將資訊注入 Pods Details限制Secret volume 的來源會被驗證, 以確保指定的參照物件確實指向一個 Secret 物件。 因此, 在使用 Secret 到任何 Pods 之前, 需要先建立 Secret。 Secret 資源隸屬於 namespace。 Secret 只可被在同一個 namespace 下的 Pod 參照 每個 secret 最大可 1MiB。 這是為了避免建立一個很大的 Secret, 這很可能會耗盡 API server 以及 kubelet 的 memory。 然而, 如果建立很多小的 secret 一樣會吃光 memory kubelet 只支援在 Pods 中使用 secrets 當 secret 是從 API server 獲得。 這包含任何使用 kubectl 建立的 Pods, 或間接透過 replication controller。 這不包含使用 kubelet --manifest-url flag, --config flag, 或 REST API 所建立的 Pod 除非有特別指定 optional, 否則在 Secret 位於 Pods 中被使用為環境變數之前, 需先建立。 如果參照的 secret 不存在, 那這個 Pod 將不會開始。 參照的 keys (secretKeyRef 欄位) 如果不存在, 那 Pod 一樣不會開始 如果 secret 被使用於環境變數載入 envFrom 欄位, 那被視為不合法的環境變數名稱將會被忽略, Pod 可以開始。 如果有不合法的 key 被忽略, 那麼對應的事件 InvalidVariableNames 以及訊息將會產生。 不合法的 key, 像是 :1badkey 以及 2alsobad 這時如果執行:kubectl get events 輸出類似:0s 0s 1 dapi-test-pod Pod Warning InvalidEnvironmentVariableNames kubelet, 127.0.0.1 Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names. Secret 以及 Pod 生命週期的互動當 Pod 經由呼叫 Kubernetes API 被建立, 這時並不會去確認參照的 secret 是否存在。 一旦 Pod 被分配了, kubelet 將會試圖取得 secret 值, 如果 secret 無法被取得, 因為它並不存在或者是暫時性的與 API server 失去連線, 那 kubelet 將會週期性的重試。 同時 kubelet 也會回報事件, 解釋 Pod 尚未開始的原因。 一旦 secret 被取得, kubelet 將會建立並掛載含有 secret 的 volume。 在 Pod 的 volume 成功掛載之前, 該 Pod 下的任何一個容器都不會開始。 使用情境使用情境：Pod 及 ssh keys 建立包含一些 ssh key 的 secret: kubectl create secret generic ssh-key-secret \\--from-file=ssh-privatekey=/path/to/.ssh/id_rsa \\--from-file=ssh-publickey=/path/to/.ssh/id_rsa.pub 輸出類似： secret &quot;ssh-key-secret&quot; created 你也可以建立一個 kustomization.yaml 檔案, 在其 secretGenerator 欄位定義 ssh keys 注意: 在送出你的 ssh keys 之前要三思而後行： 叢集中的其他使用者或許可以存取這個 secret。 使用一個你想要可以被叢集中的其他使用者存取的 service account, 這樣當有什麼狀況時, 你也方便取消這個 service account 現在你可以建立一個 Pod, 這個 Pod 參照一個有 ssh key 的 secret 且以 volume 的方式使用這個 secret apiVersion: v1kind: Podmetadata: name: secret-test-pod labels: name: secret-testspec: volumes: - name: secret-volume secret: secretName: ssh-key-secret containers: - name: ssh-test-container image: mySshImage volumeMounts: - name: secret-volume readOnly: true mountPath: &quot;/etc/secret-volume&quot; 當容器的指令執行後, key 將會在以下的地方可用： /etc/secret-volume/ssh-publickey/etc/secret-volume/ssh-privatekey 然後該容器將可使用 secret 資料來建立一個 ssh 連線 使用情境： 含有 prod / test 資訊的 Pods這個範例演示了一個使用含有 production 敏感資訊的 secret 的 Pod, 以及另外一個使用含有 test 敏感資訊的 secret 的 Pod 你可以使用 kustomization.yaml 檔案中的 secretGenerator 欄位來執行 kubectl create secret 指令 kubectl create secret generic prod-db-secret \\--from-literal=username=produser \\--from-literal=password=Y4nys7f11 輸出類似: secret &quot;prod-db-secret&quot; created 執行: kubectl create secret generic test-db-secret \\--from-literal=username=testuser \\--from-literal=password=iluvtests 輸出類似： secret &quot;test-db-secret&quot; created 注意:特殊符號像是 $, \\, *, 以及 ! 會被你的 shell 轉換, 所以會需要 escape。 在大部分的 shell 當中, escape password 最簡單的方法就是用 single quote (&#39;) 把 string 包住。 舉例來說, 如果你的密碼是 S!B\\*d$zDsb, 你應執行指令如下： kubectl create secret generic dev-db-secret \\--from-literal=username=devuser \\--from-literal=password=&#x27;S!B\\*d$zDsb&#x27; 如果使用 --from-file 的話, 你不需要 escape 特殊符號 建立該 pod.yaml cat &lt;&lt;EOF &gt; pod.yamlapiVersion: v1kind: Listitems:- kind: Pod apiVersion: v1 metadata: name: prod-db-client-pod labels: name: prod-db-client spec: volumes: - name: secret-volume secret: secretName: prod-db-secret containers: - name: db-client-container image: myClientImage volumeMounts: - name: secret-volume readOnly: true mountPath: &quot;/etc/secret-volume&quot;- kind: Pod apiVersion: v1 metadata: name: test-db-client-pod labels: name: test-db-client spec: volumes: - name: secret-volume secret: secretName: test-db-secret containers: - name: db-client-container image: myClientImage volumeMounts: - name: secret-volume readOnly: true mountPath: &quot;/etc/secret-volume&quot;EOF 將 pod.yaml 加到 kustimization.yaml file cat &lt;&lt;EOF &gt;&gt; kustomization.yamlresources:- pod.yamlEOF 使用以下指令來 apply 這些物件到 API server kubectl apply -k . 兩個容器在各自的檔案系統中都會有以下檔案, 檔案的值為各自容器的環境 /etc/secret-volume/username/etc/secret-volume/password 注意到, 兩個 Pods 的 specs 只有一個欄位不同。 它從一個共同的 Pods template 當中使用不同資料來建立 Pods你可以更進一步的簡化 Pod specification, 藉由使用兩個 service account prod-user 含有 prod-db-secret test-user 含有 test-db-secret 簡化後的 Pod 規格像是： apiVersion: v1kind: Podmetadata: name: prod-db-client-pod labels: name: prod-db-clientspec: serviceAccount: prod-db-client containers: - name: db-client-container image: myClientImage 使用情境: secret volume 中的 dotfile你可以讓你的檔案變成隱藏檔, 藉由定義 key 時, 使用 (.) 開頭定義。這個 key 代表一個 dotfile, 或隱藏檔。 舉例來說, 當以下的 secret 被掛載到 volume, secret-volume apiVersion: v1kind: Secretmetadata: name: dotfile-secretdata: .secret-file: dmFsdWUtMg0KDQo=---apiVersion: v1kind: Podmetadata: name: secret-dotfiles-podspec: volumes: - name: secret-volume secret: secretName: dotfile-secret containers: - name: dotfile-test-container image: k8s.gcr.io/busybox command: - ls - &quot;-l&quot; - &quot;/etc/secret-volume&quot; volumeMounts: - name: secret-volume readOnly: true mountPath: &quot;/etc/secret-volume&quot; 這個 volume 將會只含有一個檔案, .secret-file, 然後 dotfile-test-container 將會印出 /etc/secret-volume/.secret-file 注意: 檔案若為 dot 開頭的話, 用 ls -l 是印不出來的, 要使用 ls -la 使用情境： Secret 只被 Pod 中的一個容器看見試想, 當一個應用需要處理 HTTP requests, 一些複雜的商業邏輯, 然後使用 HMAC 來對一些訊息做簽名。因為它具有複雜應用邏輯, 可能會讓一些軟體讀取 server 中的檔案, 這很可能會暴露 private key所以這個應用可以分成兩個容器兩個程序: 一個前端容器, 負責處理使用者互動以及商業邏輯, 但不可看到 private key; 以及另外一個 signer 容器, 它可以看到 private key, 回應來自於前端容器的簡單簽名請求。 (舉例來說, 經由 localhost 網路)經由這個分離的方法, 攻擊者必須要駭進 server 之後, 還要做更細微的控制, 跟單純的讀取檔案動作相比, 這明顯難多了。 最佳實踐使用 Secret API 的 Clients當部署一個與 Secret API 有互動的應用時, 應該要使用 authorization policies, 像是 RBAC, 來限制存取權 Secret 很常會含有重要資訊, 其中有很多都會在 Kubernetes 內到外部系統造成很大的影響。 儘管每個 App 都可聲明各自需要的 Secret, 但其他在同一個命名空間下的 App 依然可以非法的獲得該 Secret 因為以上這些原因, 在一個 namespace 下, watch 以及 list 的請求具有極大的權限, 應該被避免, 因為 listing secret 將允許客戶端檢視所有位於該 namespace 下的 secret 值。 可以 watch 以及 list 叢集下所有 secrets 的能力, 應該要被限制, 唯有最高權限或系統等級的元件可以獲得。 需要存取 Secret API 的應用應該要對其需要的 secrets 使用 get 請求。 這讓管理者可以限制所有 secrets 的存取權, 只開放白名單給應用程式需要的 instance 使用 white-listing access to individual instances 比 get 更好的方式, 客戶端可以設計參照 secret 的資源, 然後 watch 這個資源, 當參照有變更時, 重新對 secret 發請求。 另外, bulk watch API 讓客戶端可以 watch 每一個被提交的資源, 並且可能會在近期由 Kubernetes 發佈。 Security properties因為 secretes 可以獨立的被建立, 不受限於使用他們的 Pods, 所以在建立, 檢視, 以及編輯 Pods 的過程中暴露 secrets 的風險算是比較低的。 系統也可以採取額外的防護措施, 例如避免將 secret 寫入 disk secret 唯有當 Pod 需要時才會被送往該 Pod 所在的 node。 kubelet 會將 secret 儲存在 tmpfs, 所以 secret 不會被寫入 disk 儲存區。 一旦有需要該 secret 的 Pod 被刪除了, kubelet 將會從本地複製區刪除該 secret 在一個 node 當中可能會有許多 Pods 會用到的 secret, 然而, secret 只對那些有用到他們的 pod 來說是可見的, 換句話說, 一個 Pod 是無法存取另外一個 Pod 的 secret 在一個 Pod 內可能會有很多容器, 然而, 每個容器都必須對各自 volumeMounts 中的 secret 發請求, 這樣 secret 對該容器來說才會是可見的。 這可被用來建立有用的 security partitions at Pod level (Pod 層級的安全分區) 在多數的 Kubernetes distributions 當中, 使用者和 API server 之間, 以及 API server 到 kubelets 的通訊都由 SSL/TLS 所保護著。 Secret 經由這些通道傳輸時也被保護著。 FEATURE STATE: kubernetes v1.13 你可以針對 secret 資料開啟 encryption at rest, 所以 secret 不會被明碼存進 etcd Risks在 API server 中, secret 資料被存在 etcd; 因此： 管理者須針對叢集資料啟動 encryption at rest (從 v1.13 開始以及之後的版本有要求) 管理者須限制到 etcd 以及 admin users 的存取 當原本由 etcd 使用的 disk 不再被使用後, 須將資料清理掉 當叢集中運行 etcd, 管理者務必確保在 etcd 點對點傳輸時有使用 SSL/TLS 如果你透過 manifest (JSON 或 YAML) 檔案配置 secret, 這個 secret 有著 base64 編碼的資料, 那麼分享這個檔案或是將它置於 source repository 代表 secret 將處於風險中。 Base64 編碼並不算是一種加密的方法, 其實跟沒編碼前一樣都是赤裸裸的文字。從 volume 讀取到 secret 值後仍須注意其安全性, 例如不可意外的將它記到 log 中或是傳送到不被信任的地方如果使用者可以建立一個使用 secret 的 Pod, 那麼這個使用者將可以看到這個 secret 的值。 儘管 API server 政策不允許這個使用者讀取 secret, 這個使用者可以透過運行 Pod 來暴露 secret現階段, 任何具有 root 權限的都可在任何一個 node 經由 kubelet 從 API server 讀取任何 secret。 目前有一個計劃中的功能是只會將 secret 送到真正會用到它的 node, 這樣就可以限制 root 在一個 node 上可以造成的影響 Questions and AnswersKubernetes 中, 如果一個 secret 在一個 node 當中只被一個 pod 使用, 現在該 pod 被刪除了, kubelet 會如何處置這個 secret?刪除 local copy Kubernetes 中, kubelet 不會將 secret 儲存到 disk storage, 反之, 會存在哪？tmpfs Kubernetes 中, kubelet 會將 secret 儲存到 disk storage 嗎？不會 Kubernetes 中, secret 在什麼情況下會被送往一個 node?當該 node 被分配到一個需要該 secret 的 Pod Kubernetes 中, 什麼情況之下我可能會需要讓 Pod 中特定的容器才可看到 private key?提高安全性 Kubernetes 中, 如果我要讓 secret 檔案掛載後的檔案是隱藏檔, 我可以怎麼做？在定義 secret key 時, 以 (.) 開頭 解釋以下的 Kubernetes example Example:apiVersion: v1kind: Secretmetadata: name: dotfile-secretdata: .secret-file: dmFsdWUtMg0KDQo= Answer:apiVersion: v1kind: Secretmetadata: name: dotfile-secretdata: // 指定該檔案為 dotfile, 代表該 data 掛載的檔案會是隱藏檔 .secret-file: dmFsdWUtMg0KDQo= 以下的 Kubernetes configuration file 中的 Kind:List 是？: Configuration file:cat &lt;&lt;EOF &gt; pod.yamlapiVersion: v1kind: Listitems:- kind: Pod apiVersion: v1 metadata: name: prod-db-client-pod labels: name: prod-db-client spec: volumes: - name: secret-volume secret: secretName: prod-db-secret containers: - name: db-client-container image: myClientImage volumeMounts: - name: secret-volume readOnly: true mountPath: &quot;/etc/secret-volume&quot;- kind: Pod apiVersion: v1 metadata: name: test-db-client-pod labels: name: test-db-client spec: volumes: - name: secret-volume secret: secretName: test-db-secret containers: - name: db-client-container image: myClientImage volumeMounts: - name: secret-volume readOnly: true mountPath: &quot;/etc/secret-volume&quot;EOF Answer:可定義多個 Pod Kubernetes Secret 中, 當我要建立含有敏感資訊, 像是 ssh keys 時, 最好採用什麼樣的 service account?可以建立一個 service account, 你可以跟叢集中的其他使用者分享, 萬一情況不對你可以取消這個 service account Kubernetes Secret 中, 在 Pod 的 volume 被掛載之前, 不相干的容器可以先開始嗎？不行 Kubernetes Secret 中, 哪個元件會去確認 secret 是否存在？kubelet Kubernetes Secret 中, 什麼時候會去確認 secret 是否存在？當 Pod 已被建立, 並且被分配後 Kubernetes Secret 中, 當 Pod 經由呼叫 API server 被建立時, 此時會去確認參照的 secret 是否存在嗎？不會 Kubernetes 中, 1badkey 以及 2alsobad 是合法的嗎？不合法的 Kubernetes 中, 一個 secret 的 size 最大是多少？1 MiB Kubernetes 中, 如果我要自動的附加 imagePullSecret, 我可以把這個家 imagePullSecret 附加到哪一個元件上？service account Kubernetes 中, 如果我要自動的掛載手動建立的 secret 到 Pods 上, 我可以使用哪一個元件？PodPreset 解釋以下 Kubernetes example code Example:apiVersion: v1kind: Podmetadata: name: foo namespace: awesomeappsspec: containers: - name: foo image: janedoe/awesomeapp:v1 imagePullSecrets: - name: myregistrykey Answer:apiVersion: v1kind: Podmetadata: name: foo namespace: awesomeappsspec: containers: - name: foo image: janedoe/awesomeapp:v1 # 指定 pull 鏡像時要使用哪一個 Docker server, 包含帳號密碼等等資訊... imagePullSecrets: - name: myregistrykey 解釋以下的 Kubernetes CLI Examplekubectl create secret docker-registry &lt;name&gt; \\--docker-server=DOCKER_REGISTRY_SERVER \\--docker-username=DOCKER_USER \\--docker-password=DOCKER_PASSWORD \\--docker-email=DOCKER_EMAIL Answer:# 建立拉取私人鏡像會用到的 secretkubectl create secret docker-registry &lt;name&gt; \\# 指定 Docker registry server--docker-server=DOCKER_REGISTRY_SERVER \\# 指定 Docker username--docker-username=DOCKER_USER \\# 指定 Docker password--docker-password=DOCKER_PASSWORD \\# 指定 Docker email--docker-email=DOCKER_EMAIL 如何用指令的方式來建立 docker-registry 類型的 secret?kubectl create secret docker-registry &lt;name&gt; \\--docker-server=DOCKER_REGISTRY_SERVER \\--docker-username=DOCKER_USER \\--docker-password=DOCKER_PASSWORD \\--docker-email=DOCKER_EMAIL 解釋以下 Kubernetes Secret example Example:apiVersion: v1kind: Podmetadata: name: secret-env-podspec: containers: - name: mycontainer image: redis env: - name: SECRET_USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password restartPolicy: Never Answer:apiVersion: v1kind: Podmetadata: name: secret-env-podspec: containers: - name: mycontainer image: redis env: # 定義 Env - name: SECRET_USERNAME # env 的值來源 valueFrom: # 來自 secret secretKeyRef: # secret name name: mysecret # secret key key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password restartPolicy: Never Kubernetes Secret 中, 怎樣的容器是不會收到 Secret 更新的？使用 subPath volume 掛載的容器 Kubernetes Secret 中, 當我在容器內印出掛載到該容器內的 secret file 時, 其值是 base64 encoded 還是 decoded?decoded 解釋以下的 Kubernetes 設定檔 Example:apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username mode: 511 Answer:apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; volumes: - name: foo secret: secretName: mysecret // 針對 mysecret 內的特定的 key 定義路徑以及權限 items: // 針對 key 為 username - key: username // 路徑為 my-group/my-username, 所以實際 mount 的路徑為 /etc/foo/my-group/my-username path: my-group/my-username // 由該 secret key 所建立的檔案權限為 511 (511 為十進位), 以八進制換算後實際權限為 `0777` mode: 511 Kubernetes Secret 中, 如果我使用 JSON 格式來指定權限的話, 需注意什麼？JSON 格式不支援八進制, 必須以十進位指定 以下的 Kubernetes 範例中, defaultMode 的意思是？ ExampleapiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; volumes: - name: foo secret: secretName: mysecret defaultMode: 256 Answer:整個 secret 的預設權限為 256, 256 為十進位, 以八進制換算後為 0400 Kubernetes secret 權限設置中, 如果沒特別指定, 預設權限是？0644 以下的 Kubernetes example 中, 如果 username 不存在 mysecret 當中, 那會發生什麼事？ ExampleapiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username Answer該 volume 不會被建立 以下的 Kubernetes example 中, Secret 的 key username 的 value 實際上 mount 的路徑是？ ExampleapiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret items: - key: username path: my-group/my-username Answer:/etc/foo/my-group/my-username 解釋以下 Kubernetes example Example:apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: &quot;/etc/foo&quot; readOnly: true volumes: - name: foo secret: secretName: mysecret Answer:apiVersion: v1kind: Podmetadata: name: mypodspec: containers: - name: mypod image: redis volumeMounts: - name: foo # 掛載到 etc 資料夾下的 foo mountPath: &quot;/etc/foo&quot; # 只允許讀 readOnly: true volumes: # 該 volume 名稱為 foo - name: foo # 來源為 secret secret: # Secret 名稱 secretName: mysecret Kubernetes, 如果我想要使用 CLI 來編輯一個 Secret, 可以怎麼做？kubectl edit secret mySecret Kubernetes 中, 如何 decode 下面 example 中的密碼？ Example:apiVersion: v1kind: Secretmetadata: creationTimestamp: 2016-01-22T18:41:56Z name: mysecret namespace: default resourceVersion: &quot;164619&quot; uid: cfee02d6-c137-11e5-8d73-42010af00002type: Opaquedata: username: YWRtaW4= password: MWYyZDFlMmU2N2Rm Answer:echo &#x27;MWYyZDFlMmU2N2Rm&#x27; | base64 --decode Kubernetes Secret 中, 當我在 apply kustomization.yaml file 時, kustomization.yaml 需位於？一個資料夾中 Kubernetes Secret 中, 在 kustomization.yaml 檔案中, 哪一個欄位可以定義如何建立一個 Secret?secretGenerator Kubernetes Secret 中, 當我要在 yaml 檔中定義如何建立 Secret 時, 這個 yaml 的檔名必須是？kustomization.yaml Kubernetes Secret 中, 在 Linux 上, 當使用 base64 加密時, 當使用 base64 -w 0 加密時, 如果 base64 -w 0 不可得, 可使用什麼其他方式？base64 | tr -d &#39;\\n&#39; Kubernetes Secret 中, 在 Linux 上, 當使用 base64 加密時, 需特別使用 base64 的哪個 flag 來避免 line wrapping?-w 0, 可使用 base64 --help 查詢 Kubernetes Secret 中, 當我同時使用 data 以及 stringData 欄位, 如下面範例, 哪一個會被使用？ Example:apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: username: YWRtaW4=stringData: username: administrator Answer:stringData Kubernetes Secret 中, stringData 會在取得 Secret 時輸出嗎？不會 Kubernetes Secret 中, data 與 stringData 的差異是？data 只可輸入 base64 加密後 stringstringData 可接受 plaintext, 然後在建立物件時自動轉為 base64 Kubernetes 中, 當我使用 kubectl get 或 kubectl describe 時, 預設上會不顯示 secret 內容, 主要是要避免哪兩點？ 防止旁觀者看到 防止 terminal 的 log 記住 Kubernetes 中, 當我使用 kubectl create secret generic secretName --from-file 來建立 Secret 時, 如果說我的密碼含有特殊符號, 像是 S!B\\*d$zDsb, 特殊符號需要 escaping 嗎？不需要 Kubernetes 中, 當我使用 kubectl create secret generic secretName --from-literal 來建立 Secret 時, 如果說我的密碼含有特殊符號, 像是 S!B\\*d$zDsb, 特殊符號需要 escaping 嗎？需要 Kubernetes 中, 當我使用 kubectl create secret generic scretName --from-literal 來建立 Secret 時, 如果說我的密碼含有特殊符號, 像是 S!B\\*d$zDsb, 那我需注意什麼？用 single quote 將密碼包住 Kubernetes 中, Secret 有哪三種類型？ Opaque dockerconfigjson service-account-token Kubernetes 中, Opaque 類型的 secret 是什麼編碼格式？base64 Kubernetes 中, dockerconfigjson 類型的 secret 的用途是？用來儲存私人 docker registry 的認證資訊, 可使用在需要從私人雲端拉取鏡像的 Pod 或 Deployment Kubernetes 中, secret 的 value 必須先做過什麼處理？base 64 以下的 Kubernetes 設定檔, 代表什麼意思? 設定檔:apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: username: YWRtaW4= password: YWRtaW4zMjE= Answer:# API versionapiVersion: v1# 種類為 Secretkind: Secret# 此 secret 的 metadatametadata: # 此 secret 的 name name: mysecret# 此 secret 的類型為 Opaquetype: Opaque# 此 secret 內容data: # key 為 username, value 為 base64 編碼後的 string username: YWRtaW4= # key 為 password, value 為 base64 編碼後的 string password: YWRtaW4zMjE= 以下的 Kubernetes 設定檔是什麼意思？ 設定檔:apiVersion: v1kind: Podmetadata: name: secret1-podspec: containers: - name: secret1 image: busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: - name: USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: PASSWORD valueFrom: secretKeyRef: name: mysecret key: password Answer:# API 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod 的 name name: secret1-pod# 運行此 Pod 的規格spec: # 容器規格 containers: # 容器名稱 - name: secret1 # 指定鏡像 image: busybox # 容器啟動後運行的指令 command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] # env, 以下開始定義 env: # env 名稱 - name: USERNAME # env value 的來源 valueFrom: # 使用 secret secretKeyRef: # secret 的 name name: mysecret # secret 的 key key: username # env 名稱 - name: PASSWORD # env value 的來源 valueFrom: # 使用 secret secretKeyRef: # secret 的 name name: mysecret # secret 的 key key: password Kubernetes 的 secret 通常有哪兩種使用方式? 環境變量 掛載 volume 以下的 Kubernetes 設定檔是什麼意思? 設定檔:apiVersion: v1kind: Podmetadata: name: secret2-podspec: containers: - name: secret2 image: busybox command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/secrets&quot;] volumeMounts: - name: secrets mountPath: /etc/secrets volumes: - name: secrets secret: secretName: mysecret Answer:# API 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod 的 name name: secret2-pod# 此 Pod 運行的規格spec: # 容器規格 containers: # 容器名稱 - name: secret2 # 指定鏡像 image: busybox # 容器啟動後運行的指令 command: [&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/secrets&quot;] # 使用 volume, 定義如下: volumeMounts: # 使用名為 secrets 的 volume - name: secrets # 掛載路徑 mountPath: /etc/secrets # 定義 volume 資訊 volumes: # volume 的 name - name: secrets # 使用 secret 為 volume 的 value secret: # secret 的 name secretName: mysecret Kubernetes 中, 如何建立一個 dockerconfigjson 的 secret?kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL Kubernetes 中, 在建立一個 dockerconfigjson 的 secret 之後, 如何取得 output?kubectl get secret secretName -o=yaml/json","link":"/zh-tw/kubernetes-configuration-secrets/"},{"title":"Kubernetes - 建立一個 DaemonSet","text":"# 前言本文會簡單介紹 Kubernetes DaemonSet, 並且實際建立一個 DaemonSet # 簡介DaemonSet 是一種 Pod 控制器, 簡單來說, 我們可以定義所有 或 部分 的 Node 上自動運行 DaemonSet 所定義的 Pod當新的 Node 被加入 Cluster, DaemonSet 所定義的 Pod 會自動 schedule 到該 Node, 而當該 Node 從 Cluster 被移除時, 該 Pod 也會被移除常見的三種應用： 用來運行 Cluster 規模的儲存應用, 像是 Ceph 在每個 Node 上運行 Logs collection 應用, 像是 Fluentd-elasticsearch 在每個 Node 上運行監控應用, 像是 Prometheus # 實作下面我們就依照官方文件簡單的來部署一個 DaemonSet 吧 apiVersion: apps/v1kind: DaemonSetmetadata: name: fluentd-elasticsearch namespace: kube-system labels: k8s-app: fluentd-loggingspec: selector: matchLabels: name: fluentd-elasticsearch template: metadata: labels: name: fluentd-elasticsearch spec: tolerations: # this toleration is to have the daemonset runnable on master nodes # remove it if your masters can&#x27;t run pods - key: node-role.kubernetes.io/master effect: NoSchedule containers: - name: fluentd-elasticsearch image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2 resources: limits: memory: 200Mi requests: cpu: 100m memory: 200Mi volumeMounts: - name: varlog mountPath: /var/log - name: varlibdockercontainers mountPath: /var/lib/docker/containers readOnly: true terminationGracePeriodSeconds: 30 volumes: - name: varlog hostPath: path: /var/log - name: varlibdockercontainers hostPath: path: /var/lib/docker/containers 上面的配置架構基本上跟 Deployment 差不多 resources 為定義 Pod 的資源限制, request 為 將該 Pod 放置到該 Node, 該 Node 需耗費的資源, limit 為 該 Pod 可使用的資源限制, 若有多個 container, 相加之後就等於該 Pod 的資源限制。 詳情可參考 Kubernetes Resources volumeMounts 會將定義的 volume 與 mountPath 定義的位置互相同步 volumes 可使用多種來源, configMap, secret 都是可以的, 這邊使用 hostPath, 為該 Pod 的 Host 位置, 也就試運行該 Pod 的 Node 位置 要特別注意的是 toleration, DaemonSet 預設是不會把 Pod 部署到 master node 上的, 但加了 toleration 的設定後, 就可以解除這個限制 讓我們實際部署吧, 可以 apply 上面的 yaml, 也可以 apply 官網提供的 url kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml 接著讓我們來觀察一下是否每個 Node 都被分配了這個 Pod kubectl get pods -l name=fluentd-elasticsearch -A -o wide 可以看到, 每個 Node 上都被部署了該 DaemonSet 定義的 Pod # 結語風蕭蕭兮易水寒, 壯士一去兮… 不復還…拍謝我自己都不知道自己在工啥小好啦！ 本文就到此結束, 謝謝各位, 我們下次見！ # Questions and Answers以下的 Kubernetes example code 代表什麼意思？ Example:kubectl get pods -l name=fluentd-elasticsearch -A -o wide Answer:取出所有 Namespace 中, labels 為 name=fluentd-elasticsearch 的 Pod, output = wide 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: apps/v1kind: DaemonSetmetadata: name: fluentd-elasticsearch namespace: kube-system labels: k8s-app: fluentd-loggingspec: selector: matchLabels: name: fluentd-elasticsearch template: metadata: labels: name: fluentd-elasticsearch spec: tolerations: - key: node-role.kubernetes.io/master effect: NoSchedule containers: - name: fluentd-elasticsearch image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2 terminationGracePeriodSeconds: 30 Answer:使用 tolerations 來解除 DaemonSet 預設並不會將 Pod 部署到 master node 上 的限制","link":"/zh-tw/kubernetes-create-a-daemonset/"},{"title":"Kubernetes - DaemonSet","text":"# 前言本文為閱讀 Kubernetes DaemonSet 官方文件, 並將重點摘取整理為 Q&amp;A 方式 Kubernetes DaemonSet, Pod 會在什麼時候被 schedule 到 Node 上？所有, 或指定的 Node 被建立時 Kubernetes DaemonSet, Pod 會在什麼時候從 Node 上被移除？當 Node 從 cluster 被移除時, 或刪除 DaemonSet Kubernetes DaemonSet, 有哪三種普遍的應用？ 執行一個 cluster storage daemon 在每一個 Node 上執行 logs collection 在每一個 Node 上執行 monitoring 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: apps/v1kind: DaemonSetmetadata: name: fluentd-elasticsearch namespace: kube-system labels: k8s-app: fluentd-loggingspec: selector: matchLabels: name: fluentd-elasticsearch template: metadata: labels: name: fluentd-elasticsearch spec: tolerations: - key: node-role.kubernetes.io/master effect: NoSchedule containers: - name: fluentd-elasticsearch image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2 resources: limits: memory: 200Mi requests: cpu: 100m memory: 200Mi volumeMounts: - name: varlog mountPath: /var/log - name: varlibdockercontainers mountPath: /var/lib/docker/containers readOnly: true terminationGracePeriodSeconds: 30 volumes: - name: varlog hostPath: path: /var/log - name: varlibdockercontainers hostPath: path: /var/lib/docker/containers Answer:# 結構上跟 Deployment 十分類似# 總結一下, 該 DaemonSet 會在每一個 Node 包含 Master Node# 上部署 fluentd-elasticsearch 做 Log 處理apiVersion: apps/v1kind: DaemonSetmetadata: name: fluentd-elasticsearch namespace: kube-system labels: k8s-app: fluentd-loggingspec: selector: matchLabels: name: fluentd-elasticsearch template: metadata: labels: name: fluentd-elasticsearch spec: tolerations: # DaemonSet 預設不會執行在 Master Node 上, 使用 tolerations 可以允許 # Master Node 運行 DaemonSet pod - key: node-role.kubernetes.io/master effect: NoSchedule containers: - name: fluentd-elasticsearch image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2 resources: limits: memory: 200Mi requests: cpu: 100m memory: 200Mi volumeMounts: - name: varlog mountPath: /var/log - name: varlibdockercontainers mountPath: /var/lib/docker/containers readOnly: true # 當 Pod 要被關閉時, 會有 30 秒的優雅退出 terminationGracePeriodSeconds: 30 volumes: - name: varlog hostPath: path: /var/log - name: varlibdockercontainers hostPath: path: /var/lib/docker/containers # Required Fields何謂 valid DNS subdomain name? 不可超過 253 characters alphanumeric character 開頭 alphanumeric character 結尾 只可含有 lowercase alphanumeric, - 或 . Kubernetes DaemonSet 的 name 必須合乎哪種規範？valid DNS subdomain name # Pod TemplateKubernetes DaemonSet 中, RestartPolicy 必須為？Always","link":"/zh-tw/kubernetes-daemonset/"},{"title":"Kubernetes - Using RBAC Authorization (官方文件原子化筆記)","text":"前言主要會針對官方文件進行翻譯, 並以原子化的概念, 即 Q&amp;A 的方式將文件中的資訊記錄下來 # Using RBAC AuthorizationKubernetes RBAC authorization 是使用哪一個 API Group?rbac.authorization.k8s.io 以下的 Kubernetes example code 代表什麼意思？ Example:kube-apiserver --authorization-mode=Example,RBAC --other-options --more-options Answer:指定 authorization mode 為 RBAC # API objectsRBAC API 宣告了四種 kubernetes 物件 Role ClusterRole RoleBinding ClusterRoleBinding # Role and ClusterRoleKubernetes RBAC 中, permission 是否有 deny 的規則？沒有, permission 預設都是 deny 的, 規則只有添加 Kubernetes RBAC 中, 當我建立一個 Role, 是否需要指定 namespace?需要 Kubernetes RBAC 中, 當我建立一個 ClusterRole, 是否需要指定 namespace?不需要, ClusterRole 可存取跨 namespace 的資源 Kubernetes RBAC 中, ClusterRole 可以將權限定義在特定的 namespace 中嗎？可以 ClusterRoles 有幾種使用方式: 定義 ClusterRole 具有某些 namespaced resources 的特定權限, 並且只在特定 namespace 中有效, 定義 ClusterRole 具有某些 namespaced resources 的特定權限, 並且在所有 namespace 都有效, 定義 該 ClusterRole 具有 cluster 範圍內所有資源的特定權限 # Role example以下的 Kubernetes example code 的意思是？ ExampleapiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: default name: pod-readerrules:- apiGroups: [&quot;&quot;] resources: [&quot;pods&quot;] verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] AnswerapiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: default name: pod-readerrules: # &quot;&quot; 表示 core API Group- apiGroups: [&quot;&quot;] # 允許操作對象為 &quot;pods&quot; resources: [&quot;pods&quot;] # 允許操作動作 verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] # ClusterRole ExampleKubernetes RBAC 中, ClusterRole 也可用在 non-resource endpoints, 例如？/healthz 以下的 Kubernetes example code 的意思是？ ExampleapiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: secret-readerrules:- apiGroups: [&quot;&quot;] resources: [&quot;secrets&quot;] verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] AnswerapiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: # 省略 &quot;namespace&quot;, 因為 ClusterRoles name: secret-readerrules:- apiGroups: [&quot;&quot;] # 允許存取對象為 secret, 換言之, 可存取所有 namespace 中的 secret resources: [&quot;secrets&quot;] # 允許存取動作 verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;] # RoleBinding and ClusterRoleBindingKubernetes 中, RoleBinding 可 bind 哪三種 subject？ users groups service accounts # RoleBinding examples以下的 Kubernetes example code 的意思是？ ExampleapiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: read-pods namespace: defaultsubjects:- kind: User name: jane # &quot;name&quot; is case sensitive apiGroup: rbac.authorization.k8s.ioroleRef: kind: Role #this must be Role or ClusterRole name: pod-reader # this must match the name of the Role or ClusterRole you wish to bind to apiGroup: rbac.authorization.k8s.io AnswerapiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: read-pods namespace: default# subjects 表示要跟 role 連結的對象, 換言之, role 代表權限# 而通過 role binding 連結後, subject 即對象就有了該 role 的權限subjects:# subjects 可以指定多個- kind: User # jame 是大小寫敏感的 name: jane apiGroup: rbac.authorization.k8s.io# &quot;roleRef&quot; 表示要連結的 roleroleRef: # 可指定 Role 或 ClusterRole kind: Role # 也就是說, 我們已經有定義好一個 Role, name 為 pod-reader name: pod-reader apiGroup: rbac.authorization.k8s.io 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: read-secrets namespace: developmentsubjects:- kind: User name: dave apiGroup: rbac.authorization.k8s.ioroleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io Answer:apiVersion: rbac.authorization.k8s.io/v1# 允許 user dave 具有 read secret 的權限, 但僅限於 &quot;development&quot; namespace# ClusterRole &quot;secret-reader&quot; 需事先定義kind: RoleBindingmetadata: name: read-secrets # 在 RoleBinding 指定 namespace 限制了該權限作用的 namespace namespace: developmentsubjects:- kind: User name: dave # name 是大小寫敏感的 apiGroup: rbac.authorization.k8s.ioroleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io # ClusterRoleBinding examples以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: read-secrets-globalsubjects:- kind: Group name: manager apiGroup: rbac.authorization.k8s.ioroleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io Answer:apiVersion: rbac.authorization.k8s.io/v1# 允許任何在 manager Group 中的 user, 可以 read 所有 namespace 的 secretkind: ClusterRoleBindingmetadata: name: read-secrets-globalsubjects:- kind: Group name: manager # Name 大小寫敏感 apiGroup: rbac.authorization.k8s.ioroleRef: kind: ClusterRole name: secret-reader apiGroup: rbac.authorization.k8s.io Kubernetes RBAC 中, 當我建立了一個 RoleBinding 之後, 可以變更 roleRef 裡頭的設定嗎？不行 Kubernetes RBAC 中, 當我建立了一個 RoleBinding 之後, 預設不給變更 roleRef 的 binding, 那如果真有變更的需求, 該怎麼做？建一個新的, 砍掉舊的 # Referring To resources以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: default name: pod-and-pod-logs-readerrules:- apiGroups: [&quot;&quot;] resources: [&quot;pods&quot;, &quot;pods/log&quot;] verbs: [&quot;get&quot;, &quot;list&quot;] Answer:apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: default name: pod-and-pod-logs-readerrules:- apiGroups: [&quot;&quot;] ## 允許 read pods, 以及 pods 的 log, log 為 pods 的 subresource ## API 像這樣 GET /api/v1/namespaces/&#123;namespace&#125;/pods/&#123;name&#125;/log resources: [&quot;pods&quot;, &quot;pods/log&quot;] verbs: [&quot;get&quot;, &quot;list&quot;] 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: default name: configmap-updaterrules:- apiGroups: [&quot;&quot;] resources: [&quot;configmaps&quot;] resourceNames: [&quot;my-configmap&quot;] verbs: [&quot;update&quot;, &quot;get&quot;] Answer:apiVersion: rbac.authorization.k8s.io/v1kind: Rolemetadata: namespace: default name: configmap-updaterrules:- apiGroups: [&quot;&quot;] # 只允許存取名為 &quot;my-configmap&quot; 的 &quot;configmaps&quot; 資源 resources: [&quot;configmaps&quot;] resourceNames: [&quot;my-configmap&quot;] verbs: [&quot;update&quot;, &quot;get&quot;] # Aggregated ClusterRoles以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: monitoringaggregationRule: clusterRoleSelectors: - matchLabels: rbac.example.com/aggregate-to-monitoring: &quot;true&quot;rules: [] Answer:aggregated ClusterRole, 所有 label 符合 selector 的 ClusterRole 都會被附加到 aggregated ClusterRole 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: monitoring-endpoints labels: rbac.example.com/aggregate-to-monitoring: &quot;true&quot;rules:- apiGroups: [&quot;&quot;] resources: [&quot;services&quot;, &quot;endpoints&quot;, &quot;pods&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] Answer:該 ClusterRole 會被附加到符合其 selector 的 aggregated ClusterRole, 如下：aggregationRule: clusterRoleSelectors: - matchLabels: rbac.example.com/aggregate-to-monitoring: &quot;true&quot; 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: aggregate-cron-tabs-edit labels: # Add these permissions to the &quot;admin&quot; and &quot;edit&quot; default roles. rbac.authorization.k8s.io/aggregate-to-admin: &quot;true&quot; rbac.authorization.k8s.io/aggregate-to-edit: &quot;true&quot;rules:- apiGroups: [&quot;stable.example.com&quot;] resources: [&quot;crontabs&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;]---kind: ClusterRoleapiVersion: rbac.authorization.k8s.io/v1metadata: name: aggregate-cron-tabs-view labels: # Add these permissions to the &quot;view&quot; default role. rbac.authorization.k8s.io/aggregate-to-view: &quot;true&quot;rules:- apiGroups: [&quot;stable.example.com&quot;] resources: [&quot;crontabs&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] Answer:只需要在預設的管理等級的 ClusterRole, 例如 admin, edit, 或 view 加上 selector, 那之後有新的 custom resource 時, 只需加上在 labels 加上 aggregated-to-對象, 這樣預設的管理等級 ClusterRole 就也擁有這個權限 # Role examples以下的 Kubernetes example code 代表什麼意思？ Example:rules:- apiGroups: [&quot;&quot;] resources: [&quot;pods&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] Answer:允許 read pods 的權限 以下的 Kubernetes example code 代表什麼意思？ Example:rules:- apiGroups: [&quot;extensions&quot;, &quot;apps&quot;] # # at the HTTP level, the name of the resource for accessing Deployment # objects is &quot;deployments&quot; resources: [&quot;deployments&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;] Answer:允許讀/寫 Deployment 資源, 範圍為 “extension” 以及 “apps” groups 以下的 Kubernetes example code 代表什麼意思？ Example:rules:- apiGroups: [&quot;&quot;] # # at the HTTP level, the name of the resource for accessing Pod # objects is &quot;pods&quot; resources: [&quot;pods&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]- apiGroups: [&quot;batch&quot;, &quot;extensions&quot;] # # at the HTTP level, the name of the resource for accessing Job # objects is &quot;jobs&quot; resources: [&quot;jobs&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;] Answer:允許 read pods, 範圍為 API group, 允許 read/write jobs, 範圍為 batch, extensions 以下的 Kubernetes example code 代表什麼意思？ Example:rules:- apiGroups: [&quot;&quot;] resources: [&quot;configmaps&quot;] resourceNames: [&quot;my-config&quot;] verbs: [&quot;get&quot;] Answer:允許 read 名為 ‘my-config’ 的 ConfigMap 資源, 範圍 API group, 必須使用 RoleBinding 來限制單一 ConfigMap 單一 namespace 以下的 Kubernetes example code 代表什麼意思？ Example:rules:- apiGroups: [&quot;&quot;] resources: [&quot;nodes&quot;] verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;] Answer:允許 read nodes 資源的權限, 範圍為 core group, 因為 nodes 屬於 cluster-scoped 的資源, 因此必須使用 ClusterRole 以及 ClusterRoleBinding 以下的 Kubernetes example code 代表什麼意思？ Example:rules:- nonResourceURLs: [&quot;/healthz&quot;, &quot;/healthz/*&quot;] # &#x27;*&#x27; in a nonResourceURL is a suffix glob match verbs: [&quot;get&quot;, &quot;post&quot;] Answer:允許對非資源類別的 endpoint /healthz 以及其所有子路徑發 GET 以及 POST 請求的權限, 需使用 ClusterROle 以及 ClusterRoleBinding # Referring to subjects以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: User name: &quot;alice@example.com&quot; apiGroup: rbac.authorization.k8s.io Answer:對象為名為 “&#x61;&#x6c;&#105;&#99;&#x65;&#x40;&#x65;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;“ 的 user 以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: Group name: &quot;frontend-admins&quot; apiGroup: rbac.authorization.k8s.io Answer:RoleBinding 的 subjects, 對象為 Group “frontend-admins” 內的所有對象 以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: ServiceAccount name: default namespace: kube-system Answer:RoleBinding 的 subjects, 對象為 ‘kube-system’ namespace 內的 ‘default’ service account 以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: Group name: system:serviceaccounts:qa apiGroup: rbac.authorization.k8s.io Answer:RoleBinding 的 subjects, 對象為 ‘qa’ namespace 中的所有 service accounts 以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: Group name: system:serviceaccounts apiGroup: rbac.authorization.k8s.io Answer:RoleBinding 的 subjects, 對象為任何 namespace 中的所有 service accounts 以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: Group name: system:authenticated apiGroup: rbac.authorization.k8s.io Answer:RoleBinding 的 subjects, 對象為所有的 authenticated user 以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: Group name: system:unauthenticated apiGroup: rbac.authorization.k8s.io Answer:RoleBinding 的 subjects, 對象為所有的 unauthenticated user 以下的 Kubernetes example code 代表什麼意思？ Example:subjects:- kind: Group name: system:authenticated apiGroup: rbac.authorization.k8s.io- kind: Group name: system:unauthenticated apiGroup: rbac.authorization.k8s.io Answer:RoleBinding 的 subjects, 對象為所有 user # Default roles and role bindingsKubernetes RBAC 中, 修改有著 system: 前綴的 ClusterRole 以及 ClusterRoleBinding object 要特別小心, 為什麼？可能會造成整個 cluster 功能失常 # Auto-reconciliationKubernetes RBAC 中, default ClusterRole 中的 rbac.authorization.kubernetes.io/autoupdate 代表的意思是？又稱為 auto-reconciliation預設 Kubernetes 會在每次啟動都更新 default cluster role 可能缺少的 permissions, 以及 default cluster role binding 可能缺少的 subjects, 如果設為 false, 則會停止這個動作, 可能會造成 cluster 失常 # API discovery rolesKubernetes RBAC 中, 如果在 API server 加入 –anonymous-auth=false, 意思是？預設的 role binding 會授權給 unauthenticated 以及 authenticated user 一些被認為可被公開存取的安全資訊, 若要完全拒絕 anonymous unauthenticated 存取, 便可設為 false需注意, 每次 API server restart, auth-reconciliation 會覆寫設定, 因此要嘛就不要手動更改預設值, 要嘛就停用 auto-reconciliation # User-facing rolesKubernetes RBAC 中, 有著 system 前綴的 default role 跟沒有 system 前綴的 default role 差別在於?前者為 cluster control plane 管理, 後者為使用者面向的 default role # Privilege escalation prevention and bootstrappingKubernetes RBAC 中, 必須符合哪兩種條件, 該 user 才可以 create/update 一個 role 或 role binding object? 該 user 本身已經擁有 要賦予該 role 的權限, 即如果想建立一個 role 有 ‘watch’ 的權限, 該 user 要先擁有 特別指定 rbac.authorization.k8s.io 的資源建立權限給該 user 以下的 Kubernetes example code 代表什麼意思？ Example:apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata: name: role-grantorrules:- apiGroups: [&quot;rbac.authorization.k8s.io&quot;] resources: [&quot;rolebindings&quot;] verbs: [&quot;create&quot;]- apiGroups: [&quot;rbac.authorization.k8s.io&quot;] resources: [&quot;clusterroles&quot;] verbs: [&quot;bind&quot;] # omit resourceNames to allow binding any ClusterRole resourceNames: [&quot;admin&quot;,&quot;edit&quot;,&quot;view&quot;]---apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: role-grantor-binding namespace: user-1-namespaceroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: role-grantorsubjects:- apiGroup: rbac.authorization.k8s.io kind: User name: user-1 Answer:apiVersion: rbac.authorization.k8s.io/v1## 定義 cluster role, 擁有此 cluster role 權限的 user 將具有 建立 role binding 以及 bind role 的權限, 但沒有建立 role 的權限kind: ClusterRolemetadata: name: role-grantorrules: ## 此 apiGroup 代表賦予該 role &quot;RBAC&quot; 相關權限- apiGroups: [&quot;rbac.authorization.k8s.io&quot;] ## 資源為 &quot;rolebindings&quot;, 所以該 role 具有建立 role binding 的權限 resources: [&quot;rolebindings&quot;] verbs: [&quot;create&quot;]- apiGroups: [&quot;rbac.authorization.k8s.io&quot;] ## 資源為 &quot;rolebindings&quot;, 所以該 role 具有建立 bind role 的權限 resources: [&quot;clusterroles&quot;] verbs: [&quot;bind&quot;] ## 若不指定 resourceNames, 則該 role 可 bind 任何 clusterRole # omit resourceNames to allow binding any ClusterRole resourceNames: [&quot;admin&quot;,&quot;edit&quot;,&quot;view&quot;]---# 將上面定義的 role bind 到 user-1, 所以之後 user-1 就具有上述的權限apiVersion: rbac.authorization.k8s.io/v1kind: RoleBindingmetadata: name: role-grantor-binding namespace: user-1-namespaceroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: role-grantorsubjects:- apiGroup: rbac.authorization.k8s.io kind: User name: user-1 # Command-line utilities# kubectl create role以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create role pod-reader --verb=get --verb=list --verb=watch --resource=pods Answer:建立一個名為 pod-reader 的 role, 該 role 允許 users 對 pod 執行 get, watch, list 動作 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create role pod-reader --verb=get --resource=pods --resource-name=readablepod --resource-name=anotherpod Answer:建立一個名為 pod-reader 的 role, 該 role 允許 users 對 pod 執行 get 動作, 並指定了 resource name 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create role foo --verb=get,list,watch --resource=replicasets.apps Answer:建立一個名為 foo 的 role, 該 role 允許 users 對 replicasets 執行 get, watch, list 動作, 並指定 resource 的 api groups 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create role foo --verb=get,list,watch --resource=pods,pods/status Answer:建立一個名為 foo 的 role, 該 role 允許 users 對 pods 以及 pod 的 subsource pods/status 執行 get, watch, list 動作 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create role my-component-lease-holder --verb=get,list,watch,update --resource=lease --resource-name=my-component Answer:建立一個名為 my-component-lease-holder 的 role, 該 role 允許 users 對名為 my-component 的 lease 資源執行 get, watch, list, update 動作 # kubectl create clusterrole以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods Answer:建立一個名為 pod-reader 的 cluster role, 該 cluster role 允許 user 對 pods 資源執行 get, watch, list 動作 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrole pod-reader --verb=get --resource=pods --resource-name=readablepod --resource-name=anotherpod Answer:建立一個名為 pod-reader 的 cluster role, 該 cluster role 允許 users 對 pods 執行 get 動作, 並指定了 resource name 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrole foo --verb=get,list,watch --resource=replicasets.apps Answer:建立一個名為 pod-reader 的 cluster role, 該 cluster role 允許 users 對 pods 執行 get 動作, 並指定了 resource name 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrole foo --verb=get,list,watch --resource=pods,pods/status Answer:建立一個名為 foo 的 cluster role, 該 cluster role 允許使用者對 pods, 以及 pods 的 subresource pods/status 執行 get, list, watch 動作 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrole &quot;foo&quot; --verb=get --non-resource-url=/logs/* Answer:建立一個名為 foo 的 cluster role, 該 cluster role 允許使用者對非 resource 類型的 url /logs/* 執行 get 動作 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrole monitoring --aggregation-rule=&quot;rbac.example.com/aggregate-to-monitoring=true&quot; Answer:建立一個名為 monitoring 的 cluster role, 該 cluster role 為 aggregation-rule, 也就是說任何 label aggregate-to-monitoring=true 的 rule 都會累加到 monitoring cluster role 上 # kubectl create rolebinding以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create rolebinding bob-admin-binding --clusterrole=admin --user=bob --namespace=acme Answer:在 namespace acme 中, 將 cluster role admin 賦予給 user bob 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create rolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp --namespace=acme Answer:在 namespace acme 中, 將 cluster role view 賦予給 acme namespace 中的 service account myapp # kubectl create clusterrolebinding以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --user=root Answer:將 cluster role cluster-admin 賦予給 user root 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrolebinding kube-proxy-binding --clusterrole=system:node-proxier --user=system:kube-proxy Answer:將 cluster role system:node-proxier 的權限賦予給 user system:kube-proxy 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp Answer:將 cluster role view 的權限賦予給 namespace 為 acme 的 service account myapp # kubectl auth reconcile以下的 Kubernetes example command 代表什麼意思？ Example:kubectl auth reconcile -f my-rbac-rules.yaml --remove-extra-subjects --remove-extra-permissions Answer:使用 manifest 檔案來更新 rbac.authorization.k8s.io/v1 API object現存的 role 會被更新以包含定義的權限 –remove-extra-subjects 會將檔案內沒有定義的 subjects 都移除–remove-extra-permissions 會將檔案內沒有定義的 permissions 都移除 Kubernetes 中, 如果沒有指定一個 application, 例如 Helm, service account, 那預設會使用哪一個 service account?位於 kube-system 的 default service account 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create clusterrolebinding add-on-cluster-admin \\ --clusterrole=cluster-admin \\ --serviceaccount=kube-system:default Answer:建立一個 clusterrolebinding, 目的在於將一個預設的 cluster role cluster-admin bind to kube-system 的 default service account, 所以 add-on 就具有需要的權限 以下的 Kubernetes example command 代表什麼意思？ Example:kubectl create rolebinding serviceaccounts-view \\ --clusterrole=view \\ --group=system:serviceaccounts:my-namespace \\ --namespace=my-namespace Answer:建立一個 rolebinding serviceaccounts-view, 將預設的 cluster role view bind to my-namespace 中的所有 service accounts Kubernetes RBAC 中, 由最安全到最危險的五種 RBAC 管理方式? 建立一個特定 application 使用的 service account, 在建立一個 role binding 與需求的 role 互相綁定 將需求的 role 與預設的 service account 綁定, 因為如果不指定, Application 預設會使用 default service account 將需求的 role 與特定 namespace 中所有 service accounts 綁定 將需求的 role 與所有 namespace 的 service account 綁定 將最高權限的 role 與所有 namespace 的 service account 綁定 # 建立一個只能訪問特定 namespace 的用戶","link":"/zh-tw/kubernetes-using-rbac-authorization/"},{"title":"Kubernetes Engine - 入門","text":"概述Google Kubernetes Engine (GKE) 提供了一個 Google 管理的環境，這個環境可使用 Google 的基礎設施來部署，管理容器化應用，以及調整容器化應用的規模大小。 Kubernetes Engine 環境包含了多台的機器(這邊專指為 Google Compute Engine 的實例)，形成一個容器的叢集。在這個課程中，你將可以實際操作練習如何建立一個容器，以及在 GKE 上部署你的應用。 前言本篇為 GCP Kubernetes Engine 的學習筆記 Kubernetes Engine 的叢集管理Kunernetes Engine 叢集器由 Kunernetes 開源叢集管理系統所提供。Kubernetes 提供與你的容器叢集互動的機制。使用Kebernetes的指令以及資源來部署、管理你的應用，執行管理任務、制訂政策，以及監控部屬工作量的健康度。 Kubernetes 使用了與目前運行在 Google 熱門服務相同的設計原則，並提供相同的優勢:自動管理, 應用容器的監控以及健康檢查, 自動擴展, 滾動升級, 以及更多…當你在一個容器叢集中運行你的應用, 相當於你使用了 Google 這10幾年正式在容器內上線的經驗來運行你的應用。 Kubernetes on Google Cloud Platform當你使用Kubernetes Engine 叢集，你同時也得到了 Google Cloud Platform 提供的優勢以及進階的叢集管理功能, 如下： Compute Engine 實例的平衡負載 節點池：在叢集內分配子集節點以提升靈活度 叢集節點實例數量的自動擴展 叢集節點軟體的自動升級 節點自動修復:保持節點的健康度以及可用性 使用 Stackdriver 來紀錄與監控，讓您可以掌握叢集的狀態 現在你已經對 Kubernetes 有基本的認識，你將在30分鐘內，學習如何使用 Kubernetes Engine 來部署你的容器化應用。繼續往下看並遵照每一個步驟來設定你的Lab環境。 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 設定一個預設的 compute zone你的 [compute zone] 是一個你的叢集以及其資源大概所在的一個位置。 例如說， us-central1-a 是一個位於 us-central1 region 的 zone 在 Cloud Shell 開始一個新的區塊，並且依照下面的指令來將你的預設 compute zone 設定為 us-central1-a gcloud config set compute/zone us-central1-a 你將會收到以下的輸出 Updated property [compute/zone]. 建立一個 Kubernetes Engine 叢集一個叢集包含至少一個叢集主要機器，以及多台工作機器，稱為 nodes (節點)。 Nodes 是 Compute Engine 虛擬機器實例，運行著 Kubernetes 的必要程序，使他們成為叢集的一部分。 執行以下的 command 來建立一個叢集。以你喜歡的叢集名稱(例如： my-cluster )來取代 command 中的 CLUSTER-NAME 。叢集的名稱必須由一個字母開始，並且需同時包含字母以及數字，且長度不可超過40個字。 gcloud container clusters create [CLUSTER-NAME] 你可以無視輸出裡的任何警告。建立叢集會需要一些時間，很快的你將會收到類似下面的輸出： NAME LOCATION ... NODE_VERSION NUM_NODES STATUSmy-cluster us-central1-a ... 1.10.9-gke.5 3 RUNNING 點擊 Check my progress 來確認目前的進度。 取得叢集的授權證明在建立叢集之後，你需要取得授權證明來進行對叢集的進一步操作執行下面的 command 來授權叢集，並用你自己的叢集名稱取代 command 裡面的 CLUSTER-NAME gcloud container clusters get-credentials [CLUSTER-NAME] 你將會收到類似下面的輸出： Fetching cluster endpoint and auth data.kubeconfig entry generated for my-cluster. 部署應用到叢集上現在你已經建立了一個叢集，你可以部署一個容器化的應用到這上面。在這個 Lab ，你將會部署 hello-app 到你的叢集上 Kubernetes Engine 使用 Kubernetes 物件來建立以及管理你的叢集資源。 Kubernetes 提供 部署 物件來部署無狀態的應用，像是 web server。服務物件定義了從網路上存取你應用的規則，以及負載平衡。 在 Cloud Shell 執行下面的 [kubectl run] 指令，從 hello-app 容器鏡像建立一個新的部署 hello-server kubectl run hello-server --image=gcr.io/google-samples/hello-app:1.0 --port 8080 你應該會收到以下的輸出: deployment.apps &quot;hello-server&quot; created 這一個 Kubernetes 的指令，建立了一個代表 hello-app 的部署物件，在此指令中： --image 指定了一個容器鏡像來部署，在此範例中，這個指令從Google Container Registry儲存區裡，拉下一個範例鏡像。gcr.io/google-samples/hello-app:1.0 表示一個特定的鏡像。如果版本沒有明確標示，最新的版本將會被使用。 --port 指定容器暴露的 port 號 執行以下的 kubectl 暴露指令，建立一個 Kubernetes 的服務，一個 Kubernetes 的資源，讓你暴露你的應用到外部。 kubectl expose deployment hello-server --type=&quot;LoadBalancer&quot; 你應該會收到以下的輸出： service &quot;hello-server&quot; exposed 點擊 Check my progress 來確認目前的進度。 帶入參數 type=&quot;LoadBalancer&quot; ，在容器中建立一個 Compute Engine 平衡負載 執行 kubectl get 來檢查 hello-server 服務 kubectl get service hello-server 你應該會收到類似以下的輸出： NAME TYPE ... EXTERNAL-IP PORT(S) AGEhello-server LoadBalancer ... 35.184.112.169 8080:30840/TCP 2m 備註：外部IP位址的產生，可能需要1分鐘。如果外部IP一直在沒有產生，你可以在執行一次上面的指令 從這個指令的輸出，從 `EXTERNAL-IP 欄位，複製服務的外部 IP 位址。 從瀏覽器，經由外部 IP 還有對應的 port 號來拜訪我們的應用 http://[EXTERNAL-IP]:8080 你的頁面應該看起來如下： 點擊 Check my progress 來確認目前的進度。 清除執行下面的指令來清除叢集 gcloud container clusters delete [CLUSTER-NAME] 當選項跳出，輸入 Y 確認。清除叢集將會花費一些時間。你可以參閱 文件 來獲得更多刪除 Google Kubernetes Engine 叢集 的資訊 點擊 Check my progress 來確認目前的進度。 恭喜你已經完成本教程","link":"/zh-tw/kubernetesEngineQwikStart/"},{"title":"Configure a Pod to Use a ConfigMap","text":"概述本篇為 ConfigMap 的介紹與使用筆記, 參考來源為 官方文件, 除了文件內容翻譯外, 也會有 Questions and Answers 區塊來將重點摘出。 建立 ConfigMap你可以使用 kubectl create configmap 或是 kustomization.yaml 中的 ConfigMap 產生器來建立 ConfigMap。 kubectl 從 1.14 開始支援 kustomization.yaml 使用 kubectl 建立 ConfigMap使用 kubectl create configmap 指令, 從 資料夾, 檔案, 或 輸入值 來建立 ConfigMaps kubectl create configmap &lt;map-name&gt; &lt;data-source&gt; 是你想要給予這個 COnfigMap 的名字, 而 是資料的來源, 可以是資料夾, 檔案, 或是輸入值 當你從檔案建立 ConfigMap, 的 key 預設為檔案名稱, 而 value 為檔案內容 你可以使用 kubectl describe 或是 kubectl get 來取得 ConfigMap 的資訊 從資料夾建立 ConfigMap你可以使用 kubectl create configmap 從一個資料夾裡頭多個檔案來建立 ConfigMap。 當你從資料夾建立 ConfigMap, kubernetes 會辨識出資料夾內合法的檔案名稱, 然後將這些檔案都裝到一個新的 ConfigMap。 所以非 regular 類型的檔案都會被無視 (像是, 子資料夾, 連結, 裝置, 管道, 等等)舉例來說: # 建立本地資料夾mkdir -p configure-pod-container/configmap/# 下載範例檔wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.propertieswget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties# 建立 configmapkubectl create configmap game-config --from-file=configure-pod-container/configmap/ 上面的指令會打包每個檔案, 此範例中為 configure-pod-container/configmap/ 資料夾中的 game.properties 以及 ui.properties, 會裝到 game-config 這個 ConfigMap。 你可以使用下面的指令來顯示 ConfigMap 細節: kubectl describe configmaps game-config 輸出類似這樣： Name: game-configNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30ui.properties:----color.good=purplecolor.bad=yellowallow.textmode=truehow.nice.to.look=fairlyNice config-pod-container/configmap/ 資料夾中的 game.properties 以及 ui.properties 被列在 ConfigMap 中的 data 區塊 執行指令檢視： kubectl get configmaps game-config -o yaml 輸出類似： apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T18:52:05Z name: game-config namespace: default resourceVersion: &quot;516&quot; uid: b4952dc3-d670-11e5-8cd0-68f728db1985data: game.properties: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 ui.properties: | color.good=purple color.bad=yellow allow.textmode=true how.nice.to.look=fairlyNice 從檔案建立 ConfigMaps你可以使用 kubectl create configmap 從單檔或多檔案建立 ConfigMap例如, 執行以下指令: kubectl create configmap game-config-2 --from-file=configure-pod-container/configmap/game.properties 會建立以下 ConfigMap, 執行以下指令檢視： kubectl describe configmaps name-config-2 輸出類似： Name: game-config-2Namespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30 你可以多次使用 --from-file 這個 flag, 藉此從多個檔案建立 ConfigMap: kubectl create configmap game-config-2 --from-file=configure-pod-container/configmap/game.properties --from-file=configure-pod-container/configmap/ui.properties 執行以下指令來顯示 game-config-2 細節資訊 kubectl describe configmaps game-config-2 輸出類似： Name: game-config-2Namespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30ui.properties:----color.good=purplecolor.bad=yellowallow.textmode=truehow.nice.to.look=fairlyNice 使用 --from-env-file 選項, 從 env-file 建立 ConfigMap, 例如以下為 env 範例 # Env-files 含有一系列的環境變數# 以下為語法：# env file 中的每行必須是 VAR=VAL 格式# # 開頭的那行會被忽略 (也就是 comment)# 空白行會被忽略# quotation marks 在 configMap 中不具有特別意義, 也就是說會變成 configMap 的 value 一部分# 下載範例檔案wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties# 範例檔如下：cat configure-pod-container/configmap/game-env-file.propertiesenemies=alienslives=3allowed=&quot;true&quot;# 這個 comment 以及上面的空行會被忽略 執行以下指令： kubectl create configmap game-config-env-file \\ --from-env-file=configure-pod-container/configmap/game-env-file.properties 會產生以下 ConfigMap, 執行以下指令檢視這個 ConfigMap kubectl get configmap game-config-env-file -o yaml 輸出類似： apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2017-12-27T18:36:28Z name: game-config-env-file namespace: default resourceVersion: &quot;809965&quot; uid: d9d1ca5b-eb34-11e7-887b-42010a8002b8data: allowed: &#x27;&quot;true&quot;&#x27; enemies: aliens lives: &quot;3&quot; 注意: 當多次使用 --from-env-file 時, 只有最後一個會被採用 多次使用 --from-env-file 的行為如下： # 下載範例wget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties# 建立 ConfigMapkubectl create configmap config-multi-env-files \\ --from-env-file=configure-pod-container/configmap/game-env-file.properties \\ --from-env-file=configure-pod-container/configmap/ui-env-file.properties 會產生以下的 ConfigMap, 執行以下指令檢視這個 ConfigMap kubectl get configmap config-multi-env-files -o yaml 輸出如下： apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2017-12-27T18:38:34Z name: config-multi-env-files namespace: default resourceVersion: &quot;810136&quot; uid: 252c4572-eb35-11e7-887b-42010a8002b8data: color: purple how: fairlyNice textmode: &quot;true&quot; 當從檔案建立 ConfigMap 時, 自己定義 key當你使用 --from-file 來建立 ConfigMap 時, 你不一定要使用檔名為 key, 你也可以自己定義 key, 如以下語法： kubectl create configmap game-config-3 --from-file=&lt;my-key-name&gt;=&lt;path-to-file&gt; &lt;my-key-name&gt; 為你想要的 key name, 而 &lt;path-to-file&gt; 為檔案來源例如說 kubectl create configmap game-config-3 --from-file=game-special-key=configure-pod-container/configmap/game.properties 以上指令會產生一個 ConfigMap, 執行以下指令來檢視它 kubectl get configmaps game-config-3 -o yaml 輸出類似: apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T18:54:22Z name: game-config-3 namespace: default resourceVersion: &quot;530&quot; uid: 05f8da22-d671-11e5-8cd0-68f728db1985data: game-special-key: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 從輸入值建立 ConfigMap你可以使用 kubectl create configmap 的 --from-literal flag, 從命令行來定義輸入值 kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm 這個 flag 可以使用多次, 每一次都會產生 ConfigMap 中的一個 key / value pair, 輸入以下指令檢視: kubectl get configmaps special-config -o yaml 輸出類似： apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T19:14:38Z name: special-config namespace: default resourceVersion: &quot;651&quot; uid: dadce046-d673-11e5-8cd0-68f728db1985data: special.how: very special.type: charm 從產生器建立 ConfigMap從 1.14 開始, kubectl 支援使用 kustomization.yaml。 你可以使用產生器來建立 ConfigMap 並且在 Apiserver 中建立這個物件。 產生器必須被定義在 kustomization.yaml 檔案中 從檔案建立 ConfigMaps舉例來說, 從 configure-pod-container/configmap/game.properties 這個檔案來建立 ConfigMap # 建立一個有產生器的 kustomization.yaml 檔cat &lt;&lt;EOF &gt;./kustomization.yamlconfigMapGenerator:- name: game-config-4 files: - configure-pod-container/configmap/game.propertiesEOF apply 這個資料夾來建立 ConfigMap 物件 kubectl apply -k .configmap/game-config-4-m9dm2f92bt created 你可以像這樣來確認 ConfigMap 是否有被建立： kubectl get configmapNAME DATA AGEgame-config-4-m9dm2f92bt 1 37skubectl describe configmaps/game-config-4-m9dm2f92btName: game-config-4-m9dm2f92btNamespace: defaultLabels: &lt;none&gt;Annotations: kubectl.kubernetes.io/last-applied-configuration: &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:&#123;&quot;game.properties&quot;:&quot;enemies=aliens\\nlives=3\\nenemies.cheat=true\\nenemies.cheat.level=noGoodRotten\\nsecret.code.p...Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30Events: &lt;none&gt; 可以注意到, 被產生的 ConfigMap name 後面有串 hash 的字串, 這確保每次內容被修改時, 都會建立一個新的 ConfigMap 當從 file 產生 ConfigMap 時, 自定義 key使用 ConfigMap 產生器時, 不一定要使用檔名來當作 key, 你也可以自訂義, 例如說, 從 configure-pod-container/configmap/game.properties 檔案來建立 ConfigMap, 並且使用 game-special-key 當作 key # 使用 kustomization.yaml 定義 ConfigMapGeneratorcat &lt;&lt;EOF &gt;./kustomization.yamlconfigMapGenerator:- name: game-config-5 files: - game-special-key=configure-pod-container/configmap/game.propertiesEOF Apply kustomization.yaml 所在資料夾來建立 ConfigMap 物件 kubectl apply -k .configmap/game-config-5-m67dt67794 created 從輸入值來建立 ConfigMap現在要從輸入值 special.type=charm 以及 special.how=very 來產生 ConfigMap, 先在 kustomization.yaml 檔案定義 ConfigMap 產生器 # Create a kustomization.yaml file with ConfigMapGeneratorcat &lt;&lt;EOF &gt;./kustomization.yamlconfigMapGenerator:- name: special-config-2 literals: - special.how=very - special.type=charmEOF Apply kustomization.yaml 檔所在資料夾來建立 ConfigMap 物件 kubectl apply -k .configmap/special-config-2-c92b5mmcf2 created 使用 ConfigMap 資料來定義容器環境變數使用單一 ConfigMap 定義容器環境變數 建立 configMap kubectl create configmap special-config --from-literal=special.how=very 將 ConfigMap 的 special.how 的值指派給環境變數 SPECIAL_LEVEL_KEY, vim pods/pod-single-configmap-env-variable.yaml 並輸入以下值 apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: # 定義環境變數 - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: # ConfigMap 含有你想要指派給 SPECIAL_LEVEL_KEY 的值 name: special-config # 指定想要指派的 value 的 key key: special.how restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml 現在, 該 Pod 的輸出將包含環境變數 SPECIAL_LEVEL_KEY=very 使用多個 ConfigMap 定義容器環境變數 跟上一個 example 一樣, 建立一個 ConfigMap, vim configmap/configmaps.yaml, 並輸入以下值: apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: special.how: very---apiVersion: v1kind: ConfigMapmetadata: name: env-config namespace: defaultdata: log_level: INFO 建立 ConfigMap kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml 定義一個 Pod 檔, 並定義該 Pod 環境變數, vim pods/pod-multiple-configmap-env-variable.yaml, 輸入以下值: apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: name: special-config key: special.how - name: LOG_LEVEL valueFrom: configMapKeyRef: name: env-config key: log_level restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml 現在, 該 Pod 輸出包含環境變數 SPECIAL_LEVEL_KEY=very 以及 LOG_LEVE=INFO 在 ConfigMap 中配置所有的 key-value pairs 如容器環境變數注意: 這個功能在 Kubernetes 1.6 以及之後版本才可用 建立包含多組 key-value 的 ConfigMap, vim configmap/configmap-multikeys.yaml 並輸入以下內容： apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: SPECIAL_LEVEL: very SPECIAL_TYPE: charm 建立該 ConfigMap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml 使用 envFrom 來將 ConfigMap 中的所有 data 都定義成容器環境變數。 ConfigMap.metadata.name 會成為 .spec.containers.envFrom.configMapRef.name 建立 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml 現在, Pod 的輸出包含了環境變數 SPECIAL_LEVEL=very 以及 SPECIAL_TYPE=charm 在 Pod 的指令選項使用由 ConfigMap 定義的環境變數你可以在 Pod 的 command 區塊使用由 ConfigMap 定義的環境變數, 語法為 $(VAR_NAME), 啥？ 看不懂？ 簡單來說, 如果 env 的 name 是 SPECIAL_LEVEL_KEY, 那你可以在 command 區塊中使用 $(SPECIAL_LEVEL_KEY), 這樣夠清楚明白了吧？ 範例如下： apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&quot; ] env: - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_LEVEL - name: SPECIAL_TYPE_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_TYPE restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml test-container 輸出如下： very charm 將 ConfigMap 資料加到 Volume如同 Create ConfigMaps from files 的解釋, 當你使用 --from-file 建立 ConfigMap, 檔名會變成存在 ConfigMap data 區塊中的 key, 而這個檔案的內容會是該 key 的值 本節中的 ConfigMap 範例為 special-config, 如下： apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: SPECIAL_LEVEL: very SPECIAL_TYPE: charm 建立該 ConfigMap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml 將 ConfigMap 的資料載入到 Volume 中將 ConfigMap 的 name 加到 Pod spec 中的 volumes 區塊。 這會將 ConfigMap 的資料加到由 volumeMounts.mountPath 指定的資料夾 (在本範例中, 為 /etc/config)。 command 列出在該資料中, 符合 ConfigMap key name 的檔案 範例檔： apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;ls /etc/config/&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: # Provide the name of the ConfigMap containing the files you want # to add to the container name: special-config restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml 當該 Pod 運行時, 會執行 ls /etc/config/ 產生以下輸出： SPECIAL_LEVELSPECIAL_TYPE 注意: 如果在 /etc/config 資料夾中有其他檔案的話, 他們會被刪除哦! 將 ConfigMap 資料加到 Volume 中特定的路徑使用 path 欄位來指定特定的 ConfigMap item 到想要的檔案路徑。 在這個例子中, SPECIAL_LEVEL item 將會被掛載到 config-volume volume 中的 /etc/config/keys 範例如下： apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;cat /etc/config/keys&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: special-config items: - key: SPECIAL_LEVEL path: keys restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml 當 Pod 開始運行, 指定 cat /etc/config/keys 會產生以下輸出 very 投射 keys 到指定的路徑以及檔案權限我們可以投射 keys 到指定的路徑以及特定的檔案權限, 根據每個檔案的狀況。 這部分會在 Secrets 有更詳細介紹, 這邊不多家贅述 掛載的 ConfigMap 會被自動更新當已經被掛載到 volume 的 ConfigMap 更新了, 映射的 key 最終也會更新。 kubelet 會每一段時間確認一次掛載的 ConfigMap 是否有更新。 然而, kubelet 使用了 ttl-based cache 來取得 ConfigMap 當下值, 結果就是, 從 ConfigMap 更新之後到新的 key 被投射到 Pod 的延遲時間會等於 kubelet 同步頻率 (預設 1 分鐘) + ttl ConfigMap cache (預設 1 分鐘), 你也可以藉由更新該 pod 的 annotations 來觸發立即刷新注意: 使用 ConfigMap 為 subPath volume 的容器將不會收到 ConfigMap 的更新 理解 ConfigMap 以及 PodsConfigMap API 資源以 key-value pairs 的方式儲存配置資料。 這個資料可以被 pods 所運用, 也可提供給系統元件的配置資料, 像是 controllers。 ConfigMap 跟 Secrets 很類似, 但主要是提供不含敏感資訊的字串用途。 使用者或系統元件可以使用 ConfigMap 儲存配置檔資料 注意: ConfigMap 需參照屬性檔案, 而非取代他們。 想像 ConfigMap 就像是類似 Linux /etc 資料夾以及其內容。 舉例來說, 如果你從 ConfigMap 建立了 Kubernetes Volume, volume 中的每個檔案就代表著 ConfigMap 當中的每一個 data item ConfigMap 的 data 欄位含有設定檔資料。 如以下範例, 它可以很簡單 - 比如說使用 --from-literal 定義每一個 item, 或複雜一點 - 像使用 --from-file 定義一個JSON 格式的配置檔案 apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T19:14:38Z name: example-config namespace: defaultdata: # example of a simple property defined using --from-literal example.property.1: hello example.property.2: world # example of a complex property defined using --from-file example.property.file: |- property.1=value-1 property.2=value-2 property.3=value-3 Restrictions 你必須在 Pod specification 區塊中參考一個 ConfigMap 之間先建立它 (除非你把它標註為 optional)。如果你參考一個不存在的 ConfigMap, 這個 Pod 不會開始。 同樣的, 如果你參考一個不存在的 key, 那 Pod 也是不會開始 如果你使用 envFrom 從 ConfigMaps 定義環境變數, 若 keys 被判斷為不合法的話, 將會被忽略。 Pod 還是可以啟動, 但是不合法的名稱將會被記錄在事件 (InvalidVariableNames)。 log 的訊息會列出每一個忽略的 key, 例如說: kubectl get events 輸出像是： LASTSEEN FIRSTSEEN COUNT NAME KIND SUBOBJECT TYPE REASON SOURCE MESSAGE 0s 0s 1 dapi-test-pod Pod Warning InvalidEnvironmentVariableNames &#123;kubelet, 127.0.0.1&#125; Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names. ConfigMap 隸屬於特定的 Namespace, 且只可被隸屬於同個 namespace 中的 pods 所使用。 ConfigMap 不可被用在 static pods 上, 因為 kubelet 不支援 Questions and AnswersKubernetes ConfigMap 中, ConfigMap 可以被使用在不同 namespace 的 pod 嗎？不行 Kubernetes ConfigMap 中, ConfigMap 可以被使用在 static pod 嗎？不可 Kubernetes ConfigMap 中, 如果我建立了一個 Pod, 並 reference 一個不存在的 ConfigMap 的 key 那會怎麼樣？該 Pod 不會開始 Kubernetes ConfigMap 中, 如果我建立了一個 Pod, 並 reference 一個不存在的 ConfigMap, 那會怎麼樣？該 Pod 不會開始 Kubernetes ConfigMap 中, 如果我要立即觸發 ConfigMap 更新同步的話, 我可以怎麼做？更新該 Pod 的 annotation Kubernetes ConfigMap 中, 使用 ConfigMap 為 subPath volume 的容器會收到 ConfigMap 更新嗎？不會 Kubernetes ConfigMap 中, ttl based cache 預設多久？1 分鐘 Kubernetes ConfigMap 中, kubelet 預設多久會確認一次 ConfigMap 是否有更新？1 分鐘 Kubernetes ConfigMap 中, 當掛載到 volume 的 ConfigMap 更新了, 同步到 Pod 的延遲時間跟哪兩個因素有關？ kubelet 確認變更的頻率 ttl cache 使用的時間 Kubernetes ConfigMap 中, 當掛載到 volume 的 ConfigMap 更新了, 會同步更新到 Pod 嗎？會哦 Kubernetes 中, 如果我要在 Pod 的 command 區塊中使用 env 的話, 假設我 env 的 name 為 SPECIAL_LEVEL_KEY, 那在 command 區塊中的變數為？$(SPECIAL_LEVEL_KEY) **Kubernetes 中, 假設我有 ConfigMap 如下, 我該怎麼樣一次性的將此 ConfigMap 中的所有 data 都設成環境變數？ 該使用哪一個 field? ** Example:apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: SPECIAL_LEVEL: very SPECIAL_TYPE: charm Answer:apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] envFrom: - configMapRef: name: special-config restartPolicy: Never 請解釋以下的 kustomization.yaml 檔案 Example:configMapGenerator:- name: special-config-2 literals: - special.how=very - special.type=charm Answer:# 定義 configMapGeneratorconfigMapGenerator:# 定義 configMap name- name: special-config-2 # 使用 liberals 方式, 並定義 literals: - special.how=very - special.type=charm 以下的 kustomization.yaml 檔案中, 如果我要自定義 key, 我可以怎麼做？ Example:configMapGenerator:- name: game-config-5 files: - configure-pod-container/configmap/game.properties Answer:configMapGenerator:- name: game-config-5 files: - game-special-key=configure-pod-container/configmap/game.properties 以下的 kubernetes kustomization.yaml 代表什麼意思？ Example:configMapGenerator:- name: game-config-4 files: - configure-pod-container/configmap/game.properties Answer:configMapGenerator:# 定義 configMap 物件名稱- name: game-config-4 # 定義 data source files: - configure-pod-container/configmap/game.properties Kubernetes 中, 如果我想要使用產生器來建立 ConfigMap, 我可以在哪個檔案中定義？kustomization.yaml 以下的 Kubernetes ConfigMap 範例中, 如果我不想使用檔名為 key, 我想要自己定義 key 的話, 我可以怎麼修改？ Example:kubectl create configmap game-config-3 --from-file=&lt;path-to-file&gt; Answer:kubectl create configmap game-config-3 --from-file=&lt;my-key-name&gt;=&lt;path-to-file&gt; Kubernetes ConfigMap 中, 當我使用 --from-file flag 來建立 ConfigMap 時, 除了使用檔名為 key 之外, 我可以自己定義 key 嗎？可以 Kubernetes 中, 當我多次使用 --from-env-file 這個 flag 多次, 會發生什麼事？只有最後一個會被採用 Kubernetes 中, 如果我想要從 env 檔來建立 ConfigMap, 我可以使用哪一個 flag?--from-env-file Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, Kubernetes 會如何處理 quotation marks, 像是 &#39;, 或 &quot;？會將他們變成 ConfigMap value 的一部分 Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, Kubernetes 會如何處理 # 開頭的 comment？無視 Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, Kubernetes 會如何處理空行？無視 Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, 內容必須是什麼格式？VAR=VAL 以下的 K8s ConfigMap yaml 檔, 代表什麼意思? yaml 檔:kind: ConfigMapapiVersion: v1metadata: name: cm-demo namespace: defaultdata: data.1: hello data.2: world config: | property.1=value-1 property.2=value-2 property.3=value-3 Answer: data: data.1: 單個屬性, data.1 為 key, hello 為 value data.2: 單個屬性, 同上 config: config 為整個配置文件, 內容如下 | 為 Block Style Indicator, literal style, 如果 string 當中有空行, 會被保留下來, 可參考範例 Kubernetes 中, 當我們不知道要怎麼樣建立一個資源時, 可以使用哪一個指令來檢視範例？kubectl create RESOURCE -h Kubernetes 中, 如果我在 tls 資料夾下有 4 個 檔案(如下), 現在我要建立一個 configMap, 這個 configMap 需同時包含這 4 個檔案, 檔名為 key, value 為檔案內容, 那我可以怎麼做？ 資料夾: Answer:kubectl create configMap configMapName --from-file=./ Kubernetes 中, 如果我要 print 出 configMap 的內容, 我可以使用哪一個指令？kubectl get configMap configMapName -o=format Kubernetes 中, 如果我在 tls 資料夾下有 4 個 檔案(如下), 現在我要建立一個 configMap, 這個 configMap 只包含 key.pem 的內容, 檔名為 key, value 為檔案內容, 那我可以怎麼做？ 資料夾: Answer:kubectl create configMap configMapName --from-file=./key.pem kubectl create configmap 中, --from-file 的 flag 可以重複使用嗎?可以哦 ** 以下的 Kubernetes Pod yaml 配置檔是什麼意思？** 配置檔:apiVersion: v1kind: Podmetadata: name: testcm1-podspec: containers: - name: testcm1 image: busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: - name: DB_HOST valueFrom: configMapKeyRef: name: cm-demo3 key: db.host - name: DB_PORT valueFrom: configMapKeyRef: name: cm-demo3 key: db.port envFrom: - configMapRef: name: cm-demo1 Answer: # API version, 可參考[文件](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#-strong-api-overview-strong-)apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: testcm1-pod# 該 Pod 要實作的規格spec: # 該 Pod 內的容器規格 containers: # 容器名稱 - name: testcm1 # 容器鏡像 image: busybox # 容器開啟後執行的 command command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;env&quot; ] env: # env 的名稱 - name: DB_HOST # env 的值的來源 valueFrom: # 引用 configMap configMapKeyRef: # 引用的 configMap 的名稱 name: cm-demo3 # 引用的 configMap 檔案中的 key key: db.host # 另一個 env 的名稱 - name: DB_PORT # env 的值的來源 valueFrom: # 引用 configMap configMapKeyRef: # 引用的 configMap 的名稱 name: cm-demo3 # 引用的 configMap 檔案中的 key key: db.port # 或者, 也可以直接從一個檔案引用整個 configMap 檔案 envFrom: - configMapRef: name: cm-demo1 以下的 Kubernetes yaml 檔是什麼意思？ yaml 檔:apiVersion: v1kind: Podmetadata: name: testcm3-podspec: containers: - name: testcm3 image: busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /etc/config/redis.conf&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: cm-demo2 Answer:# 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod 的名字 name: testcm3-pod# 該 Pod 的運行規格spec: # 定義容器規格 containers: # 容器名稱 - name: testcm3 # 鏡像名稱 image: busybox # 容器啟動後運行指令 command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;cat /etc/config/redis.conf&quot; ] # mount 一個 volume volumeMounts: # 要 mount 的 volume 的名稱 - name: config-volume # 要將這個 volume mount 到哪個位置 mountPath: /etc/config # 定義 volume volumes: # volume 的名稱 - name: config-volume # volume 來自於 configMap configMap: # configMap 的名稱 name: cm-demo2 以下的 Kubernetes yaml 檔是什麼意思？ yaml 檔:apiVersion: v1kind: Podmetadata: name: testcm4-podspec: containers: - name: testcm4 image: busybox command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;cat /etc/config/path/to/msyql.conf&quot; ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: cm-demo1 items: - key: mysql.conf path: path/to/msyql.conf Answer:# 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: testcm4-pod# 該 Pod 運行的規格spec: # 容器規格 containers: # 容器名稱 - name: testcm4 # 鏡像名稱 image: busybox # 容器啟動後運行的指令 command: [ &quot;/bin/sh&quot;,&quot;-c&quot;,&quot;cat /etc/config/path/to/msyql.conf&quot; ] # 定義掛載 volume volumeMounts: # 要掛載的 volume 的名稱 - name: config-volume # 要掛載到哪一個路徑 mountPath: /etc/config # 定義 volumes volumes: # volume 名稱 - name: config-volume # volume 來源為 configMap configMap: # configMap 的名稱 name: cm-demo1 # 定義要使用該 configMap 下的 key 以及 value 來為路徑 items: # 定義 configMap 內的 key - key: mysql.conf # 定義 value 在此 volume 中的路徑位置 path: path/to/msyql.conf 以下的 Kubernetes yaml 檔是什麼意思？ yaml 檔:apiversion: v1kind: podmetadata: name: testcm2-podspec: containers: - name: testcm2 image: busybox command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $(db_host) $(db_port)&quot; ] env: - name: db_host valuefrom: configmapkeyref: name: cm-demo3 key: db.host - name: db_port valuefrom: configmapkeyref: name: cm-demo3 key: db.port Answer:# 版本apiVersion: v1# 類型為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: testcm2-pod# 該 Pod 運行的規格spec: # 容器規格 containers: # 容器名稱 - name: testcm2 # 鏡像名稱 image: busybox # 容器啟動時運行的指令, 印出變數 command: [ &quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo $(DB_HOST) $(DB_PORT)&quot; ] # 定義變數 env: # 變數名稱為 DB_HOST - name: DB_HOST # 定義 value 來源 valueFrom: # 使用 configMap configMapKeyRef: # configMap 的名稱為 cm-demo3 name: cm-demo3 # 裡頭的 key 為 db.host key: db.host # 定義變數 DB_PORT - name: DB_PORT # value 來源 valueFrom: # 使用 configMap configMapKeyRef: # configMap 名稱為 cm-demo3 name: cm-demo3 # configMap 內的 key 為 db.port key: db.port Kubernetes 中, 如果我要建立一個 configMap, key/value 不經由檔案提供, 而是透過我的指令輸入提供, 那我可以使用哪一個 flag?kubectl create configMap configMapName --from-literal=key1=value --from-literal=key2=value Kubernetes 中, 當我建立 configMap 時, --from-literal 這個 flag 可以重複使用嗎？可以","link":"/zh-tw/kubernetes-tasks-configure-pod-container-configure-pod-configmap/"},{"title":"Kubernetes 學習筆記","text":"# 前言Kubernetes 的學習筆記, 內容未整理 # 環境OS: MacOSHypervisor: VMware Fusion # 安裝官方文件 # 安裝虛擬機 確認 macOS 有無支援虛擬機 sysctl -a | grep -E --color &#x27;machdep.cpu.features|VMX&#x27; 下載並安裝 # 安裝 minikubebrew cask install minikube # 安裝 kubectl參考文件 這邊是直接安裝 gcloud sdk, 參考文件 設定 kubectl auto completion打開 zshrc vim ~/.zshrc 加入設定檔 source &lt;(kubectl completion zsh) # 啟動 minikube參考文件 啟動 minikube start --vm-driver=&lt;driver_name&gt;, 在這個例子中, 就是 minikube start --vm-driver=vmwarefusion # kubectl# config 顯示目前有的 contexts kubectl config get-contexts 取得目前套用的 contexts kubectl config current-contexts 刪除指定 contexts kubectl config delete-contexts 從 kubeconfig 刪除指定叢集 kubectl config delete-cluster 取得 kubeconfig 中定義的叢集 kubectl config get-clusters 從 kubeconfig 檔案中重新命名 context kubectl config rename-context # createcreate -f FILENAME 建立元件 kubectl create component componentName # secret genericgeneric NAME [--type=string] [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run] 建立一個 secret, 基於一個檔案, 資料夾, 或是指定的值 一個單一個 secret 可能會包含一個或多個 key/value 組 當基於檔案建立 secret, key 預設會是檔案名稱, value 為檔案內容 如果檔名是不合法的, 而你希望選擇你自己的, 可以自己指定 當基於資料夾建立 secret 時. 每個資料夾內合法的檔名都會成為一個 key, 被打包進 secret, 任何除了 regular file 之外的內容都會被忽略 (e.g. subdirectories, symlinks, devices, pipes, etc). # configMap # logs 取得 log kubectl logs componentName 取得即時 loglogs [-f] [-p] (POD | TYPE/NAME) [-c CONTAINER] kubectl logs -f componentName # execexec (POD | TYPE/NAME) [-c CONTAINER] [flags] -- COMMAND [args...] # 元件# Pod # Service # Dashboard# 安裝kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml # 開啟kubectl proxy # 取得 tokenkubectl -n kube-system describe secret $(kubectl -n kube-system get secret | awk &#x27;/^deployment-controller-token-/&#123;print $1&#125;&#x27;) | awk &#x27;$1==&quot;token:&quot;&#123;print $2&#125;&#x27; # Kubectl CLI # YAML YAML 檔案支援使用 Tab 縮進嗎？不支援 YAML 檔案中, 什麼是註解？# 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？ &#123; &quot;apiVersion&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;pod&quot;&#125; ---apiVersion: v1kind: Pod 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？ &#123; &quot;apiVersion&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;, &quot;metadata&quot;: &#123; &quot;name&quot;: &quot;kube100-site&quot;, &quot;labels&quot;: &#123; &quot;app&quot;: &quot;web&quot; &#125; &#125;&#125; ---apiVersion: v1kind: Podmetadata: name: kube100-site labels: app: web 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？ &#123; &quot;args&quot;: [&quot;Cat&quot;, &quot;Dog&quot;, &quot;Fish&quot;]&#125; args - Cat - Dog - Fish 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？ &#123; &quot;apiVersion&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;, &quot;metadata&quot;: &#123; &quot;name&quot;: &quot;kube100-site&quot;, &quot;labels&quot;: &#123; &quot;app&quot;: &quot;web&quot; &#125; &#125;, &quot;spec&quot;: &#123; &quot;containers&quot;: [&#123; &quot;name&quot;: &quot;front-end&quot;, &quot;image&quot;: &quot;nginx&quot;, &quot;ports&quot;: [&#123; &quot;containerPort&quot;: 80 &#125;] &#125;, &#123; &quot;name&quot;: &quot;flaskapp-demo&quot;, &quot;image&quot;: &quot;jcdemo/flaskapp&quot;, &quot;ports&quot;: [&#123; &quot;containerPort&quot;: 5000 &#125;] &#125;] &#125;&#125; ---apiVersion: v1kind: Podmetadata: name: kube100-site labels: app: webspec: containers: - name: front-end image: nginx ports: - containerPort: 80 - name: flaskapp-demo image: jcdemo/flaskapp ports: - containerPort: 5000 # 靜態 Pod Kubernetes 中, 靜態 Pod 可以通過 kubectl 管理嗎？不行 Kubernetes 中, 如何建立靜態 pod?在 node 的 /etc/kubernetes/manifests 資料夾中, 新增 YAML 檔 Kubernetes 中, 如何刪除靜態 pod?將該 YAML 檔案移除 Kubernetes 中, 靜態 pod 由誰管理?特定節點上的 kubelet # RBAC Kubernetes 中, RBAC 的全寫是什麼？Role-based access control Kubernetes 中, 如何啟用 RBAC?在 apiserver yaml 檔案中添加 --authorization-mode=RBAC Kubernetes 中, Role 和 ClusterRole 的差別？Role 適用於單個命名空間, ClusterRole 適用於整個叢集 Kubernetes 中, 叢集中有哪三種 subject 資源？User Account, Group, Service Account # Questions and AnswersIn Kubernetes, 如何列出 pods?kubectl get pods In Kubernetes, 如何暴露一個 deployment, 並建立一個外部的平衡負載?kubectl expose deployment nginx –port 80 –type LoadBalancer In Kubernetes, 如何列出 service？kubectl get services In Kubernetes, Pod 內可以裝幾個容器？一個或多個 In Kubernetes, 什麼元件提供了 namespace?Pods In Kubernetes, 一個 Pod 有幾個 IP?一個 In Kubernetes, 如何利用 YAML 檔案建立一個 podkubectl create -f configFile.yaml In Kubernetes, 如何取得物件的更多資訊？kubectl describe component componentName In Kubernetes, 假設我本地的 port 為 10080, Pod 的 port 為 80, 如何將兩個連接起來？kubectl port-forward podName 10080:80 In Kubernetes, 如何取得 logkubectl logs [-f] componentName In Kubernetes, 如何在容器內開一個 shell?kubectl exec podName -c containerName -it –stdin /bin/sh In Kubernetes, Service 的作用？提供端點給 Pods In Kubernetes, Service 如何選擇 Pod?利用 label In Kubernetes, Service 提供給 Pod 的存取等級, 有幾種？三種 In Kubernetes, Service 提供的存取等級中, ClusterIP 有誰可以看見？只能在叢集內部 In Kubernetes, Service 提供的存取等級中, NodePort 有誰可以看見？給予叢集內的節點一個外部可以存取的 IP In Kubernetes, Service 提供的存取等級中, LoadBalancer 有誰可以看見？從雲端提供者那增加一個平衡負載, 將外部流量經由 Service 導向節點 In Kubernetes, Volume 的生命週期？跟 Pod 共存亡 kubernetes 中, 同一個 pod 內的 container 可以啟用相同的 port 嗎？不可, 因為共享一個空間, 若 port 相同會衝突 kubernetes 中, replicaSet 是什麼？Pod 副本的抽象, 用以擴縮 Pod # 參考資料官方文件Medium","link":"/zh-tw/kubernetesNote/"},{"title":"Laravel - The Basics - Middleware (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # IntroductionLaravel 中, 哪個地方可以找到所有的 Middleware?app/Http/Middleware 資料夾 # Defining Middleware以下的 Laravel command example code 的意思是？ Example:php artisan make:middleware MiddewareName Answer:使用 CLI 建立一個 middleware 請解釋以下的 Laravel Middleware example 邏輯 Example&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckAge&#123; public function handle($request, Closure $next) &#123; if ($request-&gt;age &lt;= 200) &#123; return redirect(&#x27;home&#x27;); &#125; return $next($request); &#125;&#125; Answer:如果 age 小於 200, 重導到 home route 去如果 age 大於 200, 通過此 middleware 如果 request 沒有通過 middleware, 可以到達 route 嗎？不行 # Before &amp; After Middleware以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Closure;class AfterMiddleware&#123; public function handle($request, Closure $next) &#123; $response = $next($request); // Perform action return $response; &#125;&#125; Answer:定義一個 middleware, 先取得 $response, 因此 $request 會先由 $next pass 到 controller, 因此順序上會先執行 Controller 的邏輯, 在執行 middleware 的邏輯 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Closure;class BeforeMiddleware&#123; public function handle($request, Closure $next) &#123; // Perform action return $next($request); &#125;&#125; Answer:定義一個 middleware, 順序上會先執行 middleware 邏輯, 再由 $next method 將 $request 帶過去 Controller 那 # Registering Middleware# Global Middleware如果我要定義一個 Global Middleware, 也就是每一個 HTTP request 都會通過它, 那我可以在 哪一個檔案 的 哪一個 property 中加入此 middleware? app/Http/Kernel.php $middleware # Assigning Middleware To Routes以下的 Laravel middleware register example 主要用在什麼地方？ Example:&lt;?php// Within App\\Http\\Kernel Class...protected $routeMiddleware = [ &#x27;auth&#x27; =&gt; \\App\\Http\\Middleware\\Authenticate::class, &#x27;auth.basic&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, &#x27;bindings&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, &#x27;cache.headers&#x27; =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, &#x27;can&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, &#x27;guest&#x27; =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, &#x27;signed&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, &#x27;throttle&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, &#x27;verified&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,]; Answer:註冊在 $routeMiddleware property 中的 middleware, 可視專案需求使用在特定的 route 上 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/&#x27;, function () &#123; //&#125;)-&gt;middleware(&#x27;first&#x27;, &#x27;second&#x27;); Answer:在這個 route 使用 ‘first’, ‘second’ 兩個 middleware 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Http\\Middleware\\CheckAge;Route::get(&#x27;admin/profile&#x27;, function () &#123; //&#125;)-&gt;middleware(CheckAge::class); Answer:以 class name 的方式給這個 route 指派一個 middleware, 任何經過此 route 的 request 都會經過此 middleware # Middleware GroupsLaravel 中, 如果我想要註冊一個 Middleware Group, 該 Group 中可以有多個 Middleware, 而我只需要 assign 這個 group 就等於一次性的附加內含的所有 middleware, 那我可以在 哪一個檔案 中的 哪一個 propery 註冊這個 Middleware Group? app\\Http\\Kernel.php $middlewareGroups Laravel 中, 當我使用 /routes/web.php 時, 默認會使用哪一個 Middleware Group?web # Sorting MiddlewareLaravel 中, 如果我要定義 middleware 執行的順序, 我可以在 哪個 檔案定義？app/Http/Kernel.php Laravel 中, 如果我要定義 middleware 執行的順序, 我可以在 app/Http/Kernel.php 中的哪個 property 定義？$middlewarePriority # Middleware Parameters以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckRole&#123; public function handle($request, Closure $next, $role) &#123; if (! $request-&gt;user()-&gt;hasRole($role)) &#123; // Redirect... &#125; return $next($request); &#125;&#125; Answer:從外部帶入 $role parameter 來供 middleware 使用 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::put(&#x27;post/&#123;id&#125;&#x27;, function ($id) &#123; //&#125;)-&gt;middleware(&#x27;role:editor,author&#x27;); Answer:將 editor 以及 author 以 role middleware 參數的形式帶入 # Terminable Middleware以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate($request, $response) &#123; // Do something here &#125;&#125; Answer:在 StartSession middleware 當中, 定義了 terminate method, 當 return response 之後, 會執行 terminate method 當中的邏輯 Laravel 中, 當我定義好一個 middleware 之後, 有哪幾種註冊方式？ global 註冊 route 註冊 middleware group 註冊 Laravel 中, 當我呼叫 middleware 的 terminate method, 預設會取得原本的那一個 middleware instance 還是一個新的 instance?新的 以下的 Laravel 程式碼的意思是？ Example:&lt;?phpuse App\\Http\\Middleware\\TerminableMiddleware;public function register()&#123; $this-&gt;app-&gt;singleton(TerminableMiddleware::class);&#125; Answer:在 AppServiceProvider 的 register method 中使用 singleton method, 這樣一來, 每次的 terminate method 都會取得同一個 middleware instance","link":"/zh-tw/laravel-basics-middleware/"},{"title":"Laradock 學習筆記","text":"# 前言Laradock 使用筆記 # 安裝 安裝 git (若無) clone 專案, 可參考 官方文件 # Laradock 架構# 已經有一個專案參考 官方文件 # 還沒有專案參考 官方文件 # 多專案可參考 官方文件下面主要針對多專案來解說, 需求是 一個 Laradock 資料夾 N 個專案 可以使用不同的 PHP 版本 可以使用不同類型或版本的 DB (多專案若使用同版本 DB, 共用一個 connection) 可使用 PHP Unit test 支援 PHPStorm unit test 功能 支援 APC cache 可在 container 內呼叫自己, 而非 host (用於 testing) # Laradock 位置位置隨意, 想放哪都可以 # env 檔設定預設不會有 .env file, 要 copy Laradock 資料夾內的 env-example to .env copy env-example .env 接下來, 為了實現多專案, 所以我們建一個資料夾, 裡面專放各個專案的 .env, 即每個不同專案的環境資訊, 這個資料夾放哪都行接著, 在該資料夾內, 除了從預設 env-example 複製過來的 .env, 為了區別預設環境跟各個專案獨有的環境設定, 我們新增一個 .env.custom, 內容如下 #################### 以下為客製化選項###################### 該專案絕對路徑, 該路徑下檔案會被映射到 workspace 內APP_CODE_PATH_HOST=/path/to/yourProject# 資料庫資料的持久化位置, 設哪都行, 如果不同專案使用不同版本的資料庫, 但卻存在同一個位置, 那會有相容性問題, 因此只要是不同類型不同版本的資料庫, 都應該獨立設一個位置DATA_PATH_HOST=/path/to/yourDataLocationPHP_VERSION=7.4MYSQL_VERSION=8.0# 僅有第一次建立 DATA_PATH_HOST 會自動建立, 如果有第二個專案使用的資料庫版本跟之前的一樣, 那此選項無作用MYSQL_DATABASE=yourDBName# 映射到 host 的 port, 所以本機可以通過此 port 連接到 DBMYSQL_PORT=33080# 專案名稱, 會顯示於 container prefixCOMPOSE_PROJECT_NAME=yourProjectName# Nginx 的 log 映射到 host 的位置, 可設定在各專案放 .env 資料夾中NGINX_HOST_LOG_PATH=/path/to/nginxHostLogLocation# 不確定會不會用到, 但有沒裝而爆錯的經驗, 就全裝了WORKSPACE_INSTALL_MYSQL_CLIENT=truePHP_FPM_INSTALL_MYSQL_CLIENT=truePHP_WORKER_INSTALL_MYSQL_CLIENT=true# 這邊為 build container 時預設會執行的 MySQL query, 可用於建立資料庫, 但只有第一次有效, 同 MYSQL_DATABASEMYSQL_ENTRYPOINT_INITDB=./mysql/docker-entrypoint-8.0-initdb.d# 如果有用到 APC, 設為 truePHP_FPM_INSTALL_APCU=true# 若要使用 PHPSTORM 的 unit test 或 debug 功能, 設為 trueWORKSPACE_INSTALL_WORKSPACE_SSH=true 當設定好 .env.custom 後, 可將其內容 append 到預設的 .env, 這樣比較清楚到底改了什麼 cat .env.custom &gt;&gt; .env # MySQL 設定# 若擔心 collation 問題, 可設定 my.cnf, 基本上不需要 my.cnf (與 create.sql 擇一即可) vim laradock/mysql/my.cnf 加入以下設定 [client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]collation-server = utf8_unicode_ciinit-connect=&#x27;SET NAMES utf8&#x27;character-set-server = utf8 # 除了 my.chf, 也可使用 create.sql, 擇一即可 修改 vim laradock/mysql/docker-entrypoint-initdb.d/createdb.sql 內容 SET CHARACTER_SET_CLIENT=utf8mb4;SET CHARACTER_SET_RESULTS=utf8mb4;SET CHARACTER_SET_database= utf8;SET COLLATION_CONNECTION=utf8_unicode_ci; # 驗證方式因為 PHP 7.3 之前的版本並不支援 MySQL 8 的密碼驗證方式, 可參考, 若非得使用舊版本 PHP 新版本 MySQL 的組合的話, 如下設定 修改 my.cnf vim laradock/mysql/my.cnf 內容 [mysqld]default_authentication_plugin= mysql_native_password 如修改無法生效, 需把 MySQL 的檔案刪除重建, 這會把該版本資料庫所有資料都刪除, 慎用, 目標為 .env 中設定的 DATA_PATH_HOST rm -rf /path/to/yourDataLocation # 建立 Database, 只有該版本第一次建立有效 複製範例檔 cp laradock/mysql/docker-entrypoint-initdb.d/createdb.sql.example laradock/mysql/docker-entrypoint-initdb.d/createdb.sql 批量新增資料庫uncomment 以下的設定檔, 並將 dev_db_1 … 換成自己需要的資料庫名字 #CREATE DATABASE IF NOT EXISTS `dev_db_1` COLLATE &#x27;utf8_general_ci&#x27; ;#GRANT ALL ON `dev_db_1`.* TO &#x27;default&#x27;@&#x27;%&#x27; ;#CREATE DATABASE IF NOT EXISTS `dev_db_2` COLLATE &#x27;utf8_general_ci&#x27; ;#GRANT ALL ON `dev_db_2`.* TO &#x27;default&#x27;@&#x27;%&#x27; ;#CREATE DATABASE IF NOT EXISTS `dev_db_3` COLLATE &#x27;utf8_general_ci&#x27; ;#GRANT ALL ON `dev_db_3`.* TO &#x27;default&#x27;@&#x27;%&#x27; ; # 更改帳號密碼, 只有該版本第一次建立有效vim laradock/.env 搜尋 MySQL 並將 default user 的密碼以及 root 的密碼更改 # 專案配置# .env 修改專案的 .env, 非 Laradock .env vim yourProject/.env 更改 DB_HOST 為 mysql 更改 DB_DATABASE 設為該專案使用的資料庫, 如果使用的資料庫版本之前已經有建立過, 只是沒有該資料庫, 那 build 過程是不會主動建立的, 要手動連接到資料庫建立, 方可使用 更改 DB_USERNAME 為 default (可自定義) 更改 DB_PASSWORD # 修改 storage 權限, 預設應該是不用改sudo chmod -R 777 storage bootstrap/cache # Supervisor當我們有使用 queue 或是 scheduler 的功能時, 會需要在背景起一個 process 用來監聽 queue job, 這時便需要使用程序管理器, 像是 supervisor 或 pm2Laradock 已內建 supervisor 可以使用, 相當方便。 # 用法 切換到 Laradock/php-worker 目錄中, 可依據需求修改 Dockerfile 以及 supervisord.conf, 若無需求不需修改 建立 config 檔, cp *.conf.example *.conf 啟動 docker-compose up -d php-worker # 設置 NGINX如果是本地開發的話, 基本上預設即可, 若要用於 production, 需設定相對應 server name # 重導 HTTP 到 HTTPSserver &#123; listen 80; listen [::]:80; server_name yourDomainName; return https://yourDomainName;&#125;server &#123; # For https listen 443 ssl; # listen [::]:443 ssl ipv6only=on; # 這個資料夾預設會跟 host 的 laradock/nginx/ssl/ 資料夾同步, 所以在外面放入正確的 SSL 憑證即可啟動 HTTPS ssl_certificate /etc/nginx/ssl/fullchain.pem; ssl_certificate_key /etc/nginx/ssl/privkey.pem; server_name yourDomainName; # 當使用多專案模式時, /var/www 會與 laradock 同層資料夾同步, 所以與 laradock 資料夾同層的專案都會被同步到這個資料夾內 root /var/www/yourProjectName/public; index index.php index.html index.htm; location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_pass php-upstream; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #fixes timeouts fastcgi_read_timeout 600; include fastcgi_params; &#125; location ~ /\\.ht &#123; deny all; &#125; location /.well-known/acme-challenge/ &#123; root /var/www/letsencrypt/; log_not_found off; &#125;&#125; # network alias 修改如果有跑測試, 可能會需要通過 guzzle 呼叫一些內部才可呼叫的 API, 例如清除 apc cache, 因為在 container 內的 curl localhost 會被指到 host machine 的 localhost, 這樣就無法將 request 導向正確的地方所以必須要在 docker-compose.yml file 做一些修改, 如下, 之後只要在 APP 內呼叫該 domain, 那就會映射到 container 的 localhost ### NGINX Server #### ... 省略 ...networks: frontend: aliases: - project.a - project.b backend: aliases: - project.a - project.b# ... 省略 ... # 啟動 Laradock啟動 Laradock 時, 我們可根據不同的 .env file 來啟動適用於不同專案的 Laradock 環境, 可將下面的冗長指令設定成 alias, 即可透過不同的 alias 來管理不同專案的 Laradock 環境 # build完成一切設定後, 重新 build Laradock, 如果 MySQL connection 已存在, 可以不需重新 build, 如果沒有更動到預設設定的, 也不需 build這邊需針對各個專案來指定 .env docker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv build --parallel --no-cache workspace mysql php-fpm nginx redis php-worker # up結束 build 後, 就可以 up Laradock 環境 docker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv up -d workspace mysql php-fpm nginx redis php-worker # down若要刪除環境, 可使用 down docker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv down # down若要 stop container, 但不刪除 container, 通常專案之間切換環境並不需要刪除 container, stop 就行 (主要避免 workspace 與 nginx port 衝突而已) docker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv stop workspace mysql php-fpm nginx redis php-worker # 執行專案前設置務必要設定好 .env 中的 MySQL_HOST, 以及 Redis_HOST, 都要改成 mysql 以及 redis, 因為 Laravel .env 中預設的 host 位置為 host machine 的通常環境, 但在 container 中, 不同的 container 處於同一個 network, 但並不處於同一個 node, 而 Laradock 是將不同的 container 服務 alias 成 domain name, 所以 mysql 即代表 mysql container 的 IP 位置 # Laradock 環境下的 artisan 以及 composer試想, 如果你的機器非常乾淨, 只裝了用來 pull Laradock 的 Git, 其他什麼都沒裝, 那你電腦中自然也不會有 composer, php, 所以要執行這些 command 就需要透過 docker docker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv exec workspace php artisan key:generatedocker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv exec workspace php artisan migratedocker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv exec workspace php artisan db:seeddocker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv exec workspace php artisan test docker-compose -f /path/to/yoruLaradockLocation/docker.compose.yml --env-file /path/to/yourProjectEnv exec workspace composer install -d /path/to/projectLocationInWorkspace # Unit test 資料庫如果有使用到 TEST, 記得到資料庫中建立一個 for testing 的資料庫, 然後在 .env.test 中設置相對應的參數, 當然, 我們都是使用 container 中的資源, 所以 host, password, user 那些務必都要改成 DB container 的參數 # APC cacheLaradock 只提供了 PHP-FPM 中安裝 APC driver, 但並不支援 workspace 安裝 APC driver, 所以當跑測試時, 測試跑的是 CLI 環境, 並不透過 PHP-FPM, 因此如果有使用到 APC Cache 功能的地方就會噴錯, 因此我們必須手動到 workspace 中安裝 APC Cache apt update &amp;&amp; apt install php-apcu # PHPStormPHPStorm 預設 testing configuration 是使用 Local 的 PHP Interpreter, 但我們 host machine 並沒有安裝 PHP, 只有 Laradock, 再者, 我們會需要 PHPStorm 是在 workspace container 中下達運行, 這樣才會使用到相對應的 DB # SSH 先到 PHPStorm 的 Preference -&gt; Tools -&gt; SSH Configurations, 完成以下設定, 可參考 官網 # PHP Interpreter 接著到 Preference -&gt; Languages &amp; Framework -&gt; PHP 頁面中, 設定 CLI Interpreter, 選取 ..., 如下設定 # PHP Testing Configuration 接著到 Preference -&gt; Languages &amp; Framework -&gt; PHP -&gt; Test Frameworks 設定 CLI Interpreter, composer autoload, phpunit.xml 完成以上設定後, 應該就可以使用 testing 功能, 我的 short cut 是 shift + ctrl + r # Jenkins# 設定簡易個人 side project 用的 CD 可參考 這篇文章 Shell Script 從容器連到欲部署的 Serverssh -i /var/jenkins_home/yourDeployKey root@yourServerIP \\&quot;cd /yourProjectLocation/ &amp;&amp; \\\\git reset @^ --hard &amp;&amp; git pull \\\\&amp;&amp; cd /laradockProjectLocation/ \\\\&amp;&amp; /usr/bin/docker-compose exec -T --user=laradock workspace php /var/www/yourProjectName/artisan migrate --force \\\\&amp;&amp; /usr/bin/docker-compose exec -T --user=laradock workspace composer install -d /var/www/yourProjectName \\\\&amp;&amp; /usr/bin/docker-compose exec -T --user=laradock workspace php /var/www/yourProjectName/artisan queue:restart \\\\&amp;&amp; /usr/bin/docker-compose exec -T --user=laradock workspace php /var/www/yourProjectName/artisan db:seed&quot; # Add Swap Space當部署的機器 Memory 較低時, 常常會把 RAM 耗光, 這時我們可以通過切割一部分沒用到的硬碟給 RAM 作業系統ubuntu 18.04 確認目前 swap 大小, 如果沒有輸出, 代表目前 server 沒有劃分這一塊, 可以加了 sudo swapon --show 建立 Swap 檔案 fallocate: 切割硬碟給檔案 -l: length, 檔案大小 /swapfile: 檔案sudo fallocate -l 1G /swapfile 設定正確的權限 sudo chmod 600 /swapfile 設定 Swap Space mkswap: 建立 swap 區域, 可以是 disk partition, 也可以是一個檔案sudo mkswap /swapfile 輸出： OutputSetting up swapspace version 1, size = 1024 MiB (1073737728 bytes)no label, UUID=f59595fb-754b-47ae-af6b-8dd6e98654d8 啟用 Swap Space sudo swapon /swapfile 確認 swap 是否已可被使用 sudo swapon --show 輸出 OutputNAME TYPE SIZE USED PRIO/swapfile file 1024M 0B -2 確認可用使用量 free -h 輸出 Output total used free shared buff/cache availableMem: 581M 275M 62M 103M 243M 110MSwap: 1.0G 0B 1.0G 使 Swap 永久有效 sudo vim /etc/fstab 增加以下代碼到檔案中 /swapfile swap swap defaults 0 0 設定 swappinessswappiness 為 0 時, kernel 將不會將 data 換到 disk 除非真的有必要, 值越高時 kernel 會盡可能地將 data 放到 swap, 讓 RAM 更空一點所以, 告訴系統盡量不要依賴 swap 可以讓系統運行的快一點 查看目前的 swappiness cat /proc/sys/vm/swappiness 輸出 Output60 將 swappiness 設定為 10 sudo sysctl vm.swappiness=10 輸出 Outputvm.swappiness = 10 持久化 swappiness sudo vim /etc/sysctl.conf 加入下面這一行 vm.swappiness=10 移除 Swap Space sudo swapoff -v /swapfile 從 /etc/fstab 移除上面加入的代碼 /swapfile swap swap defaults 0 0 最後, 刪除 swap 檔案 sudo rm /swapfile # PHP-WORKERLaradock 預設 php-worker 以及 Horizon 都是不支援 MSSQL 的, 所以自己根據專案需求改了一下 php-worker 的 docker file, 目前只測過 php7.4 是可用的, 其他版本沒測過https://github.com/tn710617/laradock # 非正規設置法 (自己弄好玩的, 勿學 XD)以下是個人配置, 旨在利用 Let’s Encrypt Certbot 自動每三個月續簽 SSL 憑證, 並自動套用到每個專案所以會在 Host 處安裝 NGINX + CertBot, 因為自動續簽 SSL 憑證會用到 NGINX 80 port, 所以容器外的 NGINX 會監聽 80 port, 並把符合條件的請求都導向由容器直接監聽的 443 port, 所以會在容器內外都安裝 NGINX # NGINX 配置因為 Let’s Encrypt 在自動續簽的過程中, CertBot 會 restart NGINX, 所以 NGINX 會分成容器內跟容器外 # 容器內 NGINX// 容器外的 NGINX 會將指定 server_name 的流量導向 443 port, 所以這邊不需監聽 80 portserver &#123; # For https listen 443 ssl; # listen [::]:443 ssl ipv6only=on; // 這個資料夾預設會跟 host 的 laradock/nginx/ssl/ 資料夾同步, 所以在外面放入正確的 SSL 憑證即可啟動 HTTPS ssl_certificate /etc/nginx/ssl/fullchain.pem; ssl_certificate_key /etc/nginx/ssl/privkey.pem; server_name yourDomainName; // 當使用多專案模式時, /var/www 會與 laradock 同層資料夾同步, 所以與 laradock 資料夾同層的專案都會被同步到這個資料夾內 root /var/www/yourProjectName/public; index index.php index.html index.htm; location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_pass php-upstream; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #fixes timeouts fastcgi_read_timeout 600; include fastcgi_params; &#125; location ~ /\\.ht &#123; deny all; &#125; // 此層資料夾會跟 laradock/logs/nginx 資料夾同步, 所以需要更名為你的專案名稱, 否則要是有多專案的話, 每個專案的 log 就重疊了 error_log /var/log/nginx/yourProjectName_error.log; access_log /var/log/nginx/yourProjectName_access.log;&#125; # 容器外 NGINX// 容器外相當簡單, 將來自 80 port 的請求導向 443 即可 server &#123; listen 80; server_name *.yourDomainName; return https://$host$request_uri;&#125; # Let’s Encrypt安裝可參考 取得 wildcard SSL 憑證 # 其他配置檔# docker-compose.yaml取拿掉 80 port 對應, 因為 80 port 會由容器外的 NGINX 監聽 ports: - &quot;$&#123;NGINX_HOST_HTTPS_PORT&#125;:443&quot; # Laradock 的 .env// 因為 80 port 沒開, 所以參數也不需設定### NGINX #################################################NGINX_HOST_HTTP_PORT=NGINX_HOST_HTTPS_PORT=443NGINX_HOST_LOG_PATH=./logs/nginx/NGINX_SITES_PATH=./nginx/sites/NGINX_PHP_UPSTREAM_CONTAINER=php-fpmNGINX_PHP_UPSTREAM_PORT=9000NGINX_SSL_PATH=./nginx/ssl/","link":"/zh-tw/laradock/"},{"title":"Laravel - Basics - Session (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # ConfigurationLaravel 中, 如果我前面有掛 Load Balancer, 那我 session 要用什麼方式儲存？ centralized store, 像是 database, redis Laravel 中, 支援哪幾種 session driver? file, cookie, database, memcached / redis, dynamodb, array Laravel 中, session driver array 主要用於哪裡？ 主要用於 testing, 避免 session 持有化數據 # Driver Prerequisites# Database以下的 Laravel example code 的意思是？ Example:&lt;?phpSchema::create(&#x27;sessions&#x27;, function ($table) &#123; $table-&gt;string(&#x27;id&#x27;)-&gt;primary(); $table-&gt;foreignId(&#x27;user_id&#x27;)-&gt;nullable()-&gt;index(); $table-&gt;string(&#x27;ip_address&#x27;, 45)-&gt;nullable(); $table-&gt;text(&#x27;user_agent&#x27;)-&gt;nullable(); $table-&gt;text(&#x27;payload&#x27;); $table-&gt;integer(&#x27;last_activity&#x27;)-&gt;index();&#125;); Answer:當 session driver 使用 database 時, 需建立一張 table 來存放 session records 以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan session:tablephp artisan migrate Answer:當 session driver 使用 database 時, 可使用 CLI 建立存放 session records 的 table # Interacting With The Session# Retrieving Data以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public function show(Request $request, $id) &#123; $value = $request-&gt;session()-&gt;get(&#x27;key&#x27;); // &#125;&#125; Answer:透過 $request 取得 session &#39;key&#39; 的 value 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = $request-&gt;session()-&gt;get(&#x27;key&#x27;, &#x27;default&#x27;);$value = $request-&gt;session()-&gt;get(&#x27;key&#x27;, function () &#123; return &#x27;default&#x27;;&#125;); Answer:從 $request 取得 session &#39;key&#39; 的 value, 若 &#39;key&#39; 不可得, 則 return arg2 的 default 值, 或執行 arg2 closure, 取得 closure return 的值 # The Global Session Helper以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/home&#x27;, function () &#123; $value = session(&#x27;key&#x27;); $value = session(&#x27;key&#x27;, &#x27;default&#x27;); session([&#x27;key&#x27; =&gt; &#x27;value&#x27;]);&#125;); Answer:使用 session global helper從 session 中取得 key 為 &#39;key&#39; 的 value從 session 中取得 key 為 &#39;key&#39; 的 value, 若 &#39;key&#39; 不可得, return &#39;default&#39;將 [&#39;key&#39; =&gt; &#39;value&#39;] 存到 session 中 # Retrieving All Session Data以下的 Laravel example code 的意思是？ Example:&lt;?php$data = $request-&gt;session()-&gt;all(); Answer:取得 session 中的所有資料 # Determining If An Item Exists In The Session以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($request-&gt;session()-&gt;has(&#x27;users&#x27;)) &#123; //&#125; Answer:判斷 session 中是否有 key 為 &#39;users&#39;, 且 value 不為 null 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($request-&gt;session()-&gt;exists(&#x27;users&#x27;)) &#123; //&#125; Answer:判斷 session 是否有 key 為 &#39;users&#39;, value 允許為 null # Storing Data以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;session()-&gt;put(&#x27;key&#x27;, &#x27;value&#x27;);session([&#x27;key&#x27; =&gt; &#x27;value&#x27;]); Answer:使用 $request 或 session global helper 將 [&#39;key&#39; =&gt; &#39;value&#39;] 存到 session # Pushing To Array Session Values以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;session()-&gt;push(&#x27;user.teams&#x27;, &#x27;developers&#x27;); Answer:使用在當要把 item push 到一個 session value 中, 而該 value 是一個 array將 &#39;developers&#39; push 到 session 中的 user.teams, teams 為一個 array # Retrieving &amp; Deleting An Item以下的 Laravel example code 的意思是？ Example:&lt;?php$value = $request-&gt;session()-&gt;pull(&#x27;key&#x27;, &#x27;default&#x27;); Answer:從 session 中取得並刪除該 record, 若不可能, return arg2 的 &#39;default&#39; # Flash Data以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;session()-&gt;flash(&#x27;status&#x27;, &#x27;Task was successful!&#x27;); Answer:使用 flash() 將 [&#39;status&#39; =&gt; &#39;Task was successful!&#39;] 存到 session, 並且可用在下一個 request, 在下一個 request 之後便會自動刪除 以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;session()-&gt;reflash();$request-&gt;session()-&gt;keep([&#x27;username&#x27;, &#x27;email&#x27;]); Answer:預設使用 flash() 儲存的 session 在下一個 request 之後便會自動刪除使用 refresh() 可以延長保存期限, 多一個 request使用 keep() 同上, 但只針對特定的 key 延長期限 # Deleting Data以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;session()-&gt;forget(&#x27;name&#x27;);$request-&gt;session()-&gt;forget([&#x27;name&#x27;, &#x27;status&#x27;]);$request-&gt;session()-&gt;flush(); Answer:使用 forget() 從 session 當中移除指定的 key使用 flush() 會將 session 中資料完全移除 # Regenerating The Session ID以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;session()-&gt;regenerate(); Answer:若使用 Laravel 預設的驗證, 像是 application starter kits 或是 Laravel Fortify, 預設 authenticate user 都會重新產生 session ID然而, 也可手動重新產生 # Session Blocking若要使用 Laravel Session Blocking, 支援哪幾種 session driver?memcached, dynamodb, redis, database 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::post(&#x27;/profile&#x27;, function () &#123; //&#125;)-&gt;block($lockSeconds = 10, $waitSeconds = 10)Route::post(&#x27;/order&#x27;, function () &#123; //&#125;)-&gt;block($lockSeconds = 10, $waitSeconds = 10) Answer:使用 Session BlockLaravel 預設允許同時間處理兩個以上帶有相同 session 的 request, 然而, 在少數的情況下可能會有 session 資料丟失的問題, 比方說, 當 request 同時發向同一個 application 兩個不同的 endpoints, 而這兩個不同的 endpoints 會對 session 進行修改可使用 block() 避免這個問題, 當使用 block() 時, 在當前 request 完成之前, 該 session 會被 lock 住, 直到該 request 完成後, 才允許相同 session 的下一個 requestarg1 表示 lock 的時間, 如果 request 完成會自動 releasearg2 表示新的 request 要嘗試多久來取得新的 session lock, 若超過將會 throw Illuminate\\Contracts\\Cache\\LockTimeoutException兩個 args 預設都是 10 秒 # Adding Custom Session Drivers# Implementing The Driver以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface&#123; public function open($savePath, $sessionName) &#123;&#125; public function close() &#123;&#125; public function read($sessionId) &#123;&#125; public function write($sessionId, $data) &#123;&#125; public function destroy($sessionId) &#123;&#125; public function gc($lifetime) &#123;&#125;&#125; Answer:若要自定義 Session Driver, 可在 App\\Extensions folder 建立一個 class, 並 implement SessionHandlerInterface, 實作這些 method 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface&#123; public function open($savePath, $sessionName) &#123;&#125;&#125; Answer:用在 file based session store system, 因為 Laravel 已經有內建的 file session driver, 所以若要自定義 session driver, 這個 method 可以留空 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface&#123; public function close() &#123;&#125;&#125; Answer:用在 file based session store system, 因為 Laravel 已經有內建的 file session driver, 所以若要自定義 session driver, 這個 method 可以留空 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface&#123; public function read($sessionId) &#123;&#125;&#125; Answer:當自定義 session driver 時需 implement 的 methodread() 需 return session data 的 string version不需要做任何 serialization, 因為 Laravel 預設做完了 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface&#123; public function write($sessionId, $data) &#123;&#125;&#125; Answer:當自定義 session driver 時需 implement 的 methodwrite() 需將與 $sessionId 相關的 $data string 寫到自定義的 storage 中不需要做任何 serialization, 因為 Laravel 預設做完了 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface&#123; public function destroy($sessionId) &#123;&#125;&#125; Answer:當自定義 session driver 時需 implement 的 methoddestroy() 需將與 $sessionId 有關的 data 從 storage 中移除 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;class MongoSessionHandler implements \\SessionHandlerInterface&#123; public function gc($lifetime) &#123;&#125;&#125; Answer:當自定義 session driver 時需 implement 的 methodgc() 需將比 $lifetime 還舊的檔案從 storage 中清掉, 格式為 UNIX timestamp如果是使用 self-expiring 系統, 像是 Memcached 或 Redis, 此 method 可留空 # Registering The Driver以下的 Laravel example code 的意思是？ Example:&lt;?php&lt;?phpnamespace App\\Providers;use App\\Extensions\\MongoSessionHandler;use Illuminate\\Support\\Facades\\Session;use Illuminate\\Support\\ServiceProvider;class SessionServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Session::extend(&#x27;mongo&#x27;, function ($app) &#123; // Return an implementation of SessionHandlerInterface... return new MongoSessionHandler; &#125;); &#125;&#125; Answer:當完成自定義的 session driver implementation class 之後, 可在 SessionServiceProvider 的 boot method 中, 使用 Session::extend() 來註冊新的 session driver, mongo 為 session driver 的名稱, closure 會 return implementation class註冊完成後, 就可以在 config/session.php 使用 mongo session driver","link":"/zh-tw/laravel-basics-session/"},{"title":"Laravel - Database - Getting Started (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # IntroductionLaravel Database 中, 目前 Laravel 支援哪四種資料庫？ MySQL PostgreSQL SQLite SQL Server # ConfigurationLaravel Database 中, 什麼是 Database URL?將 host, port, username, password, 各項參數包含在內的一個 url # Read &amp; Write Connections以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;mysql&#x27; =&gt; [ &#x27;read&#x27; =&gt; [ &#x27;host&#x27; =&gt; [ &#x27;192.168.1.1&#x27;, &#x27;196.168.1.2&#x27;, ], ], &#x27;write&#x27; =&gt; [ &#x27;host&#x27; =&gt; [ &#x27;196.168.1.3&#x27;, ], ], &#x27;sticky&#x27; =&gt; true, &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;, &#x27;database&#x27; =&gt; &#x27;database&#x27;, &#x27;username&#x27; =&gt; &#x27;root&#x27;, &#x27;password&#x27; =&gt; &#x27;&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8mb4&#x27;, &#x27;collation&#x27; =&gt; &#x27;utf8mb4_unicode_ci&#x27;, &#x27;prefix&#x27; =&gt; &#x27;&#x27;,], Answer:&lt;?php&#x27;mysql&#x27; =&gt; [ // 定義 read 的 mysql server &#x27;read&#x27; =&gt; [ &#x27;host&#x27; =&gt; [ &#x27;192.168.1.1&#x27;, &#x27;196.168.1.2&#x27;, ], ], // 定義 write 的 mysql server &#x27;write&#x27; =&gt; [ &#x27;host&#x27; =&gt; [ &#x27;196.168.1.3&#x27;, ], ], //如果一個 request 執行的 write 的動作, 在當次 request 的後續行為中, 如果有 read 的動作, 都將從 write 的機器讀取 &#x27;sticky&#x27; =&gt; true, &#x27;driver&#x27; =&gt; &#x27;mysql&#x27;, &#x27;database&#x27; =&gt; &#x27;database&#x27;, &#x27;username&#x27; =&gt; &#x27;root&#x27;, &#x27;password&#x27; =&gt; &#x27;&#x27;, &#x27;charset&#x27; =&gt; &#x27;utf8mb4&#x27;, &#x27;collation&#x27; =&gt; &#x27;utf8mb4_unicode_ci&#x27;, // table prefix, 如果有多個 application 使用同一個 database 的話, 避免衝突 &#x27;prefix&#x27; =&gt; &#x27;&#x27;,], # Using Multiple Database Connections以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::connection(&#x27;foo&#x27;)-&gt;select(...); Answer:指定使用的 DB # Running Raw SQL Queries# Running A Select Query以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Support\\Facades\\DB;class UserController extends Controller&#123; public function index() &#123; $users = DB::select(&#x27;select * from users where active = ?&#x27;, [1]); return view(&#x27;user.index&#x27;, [&#x27;users&#x27; =&gt; $users]); &#125;&#125; Answer:相當於 select * from users where active = 1, 之所以使用 ? 為 binding 設計, 以避免 SQL injection並 return 到 user.index view page, 像是 views/user/index.blade.php, 將 $user 以 ‘user’ 的方式帶過去該 page, 即可在 user.index page 以 $user 方式取用 # Using Named Bindings以下的 Laravel example code 的意思是？ Example:&lt;?php$results = DB::select(&#x27;select * from users where id = :id&#x27;, [&#x27;id&#x27; =&gt; 1]); Answer:使用 binding 以避免 sql injection, 如果 select() 的 arg2 是一個 numerically indexed array, 那就按順序使用 ? (問號) 即可 # Running An Insert Statement以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::insert(&#x27;insert into users (id, name) values (?, ?)&#x27;, [1, &#x27;Dayle&#x27;]); Answer:insert 到 users table 的 id, name column, value 為 1, ‘Dayle’ # Running An Update Statement以下的 Laravel example code 的意思是？ Example:&lt;?php$affected = DB::update(&#x27;update users set votes = 100 where name = ?&#x27;, [&#x27;John&#x27;]); Answer:使用 update(), 輸入原生 sql 語法以及 binding, 以避免 sql injection # Running A Delete Statement以下的 Laravel example code 的意思是？ Example:&lt;?php$deleted = DB::delete(&#x27;delete from users&#x27;); Answer:在 delete() 內輸入 mysql delete 語法, 刪除 users table 的所有資料 # Running A General Statement以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::statement(&#x27;drop table users&#x27;); Answer:drop table users, 當使用一些不回傳 value 的指令, 可使用 STATEMENT # Listening For Query Events以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot() &#123; DB::listen(function ($query) &#123; // $query-&gt;sql // $query-&gt;bindings // $query-&gt;time &#125;); &#125; Answer:在 AppServiceProvider boot() 中, 使用 DB::listen(), 可取得每一句 query 的實際上 sql query, binding, 以及執行時間 # Database TransactionsLaravel Database 當中, 以下的 example 當中, 什麼情況下 transaction 會 roll back? Example:&lt;?phpDB::transaction(function () &#123; DB::table(&#x27;users&#x27;)-&gt;update([&#x27;votes&#x27; =&gt; 1]); DB::table(&#x27;posts&#x27;)-&gt;delete();&#125;); Answer:當有 exception 被丟出的時候 # Handling Deadlocks以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::transaction(function () &#123; DB::table(&#x27;users&#x27;)-&gt;update([&#x27;votes&#x27; =&gt; 1]); DB::table(&#x27;posts&#x27;)-&gt;delete();&#125;, 5); Answer:使用 transaction, 若失敗會持續嘗試最多 5 次, 5 次後仍然失敗丟出 exception # Manually Using Transactions以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::beginTransaction(); Answer:手動開始一個 transaction 以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::rollback(); Answer:手動 rollback 一個 transaction, 在 DB::beginTransaction() 之後的對資料庫的更動 都會 rollback 以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::commit(); Answer:手動 commit 一個 transaction, 在 DB::beginTransaction() 之後的對資料庫的更動 都會 commit","link":"/zh-tw/laravel-database-getting-started/"},{"title":"Laravel - Carbon","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Laravel Carbon 是 extends 哪個 PHP class?DateTime class 以下的 Laravel example code 的意思是？ Example:&lt;?php$mutable = Carbon::now();$immutable = CarbonImmutable::now();$modifiedMutable = $mutable-&gt;add(1, &#x27;day&#x27;);$modifiedImmutable = CarbonImmutable::now()-&gt;add(1, &#x27;day&#x27;);var_dump($modifiedMutable === $mutable); // bool(true)var_dump($mutable-&gt;isoFormat(&#x27;dddd D&#x27;)); // string(12) &quot;Wednesday 10&quot;var_dump($modifiedMutable-&gt;isoFormat(&#x27;dddd D&#x27;)); // string(12) &quot;Wednesday 10&quot;var_dump($modifiedImmutable === $immutable); // bool(false)var_dump($immutable-&gt;isoFormat(&#x27;dddd D&#x27;)); // string(9) &quot;Tuesday 9&quot;var_dump($modifiedImmutable-&gt;isoFormat(&#x27;dddd D&#x27;)); // string(12) &quot;Wednesday 10&quot;$mutable = CarbonImmutable::now()-&gt;toMutable();var_dump($mutable-&gt;isMutable()); // bool(true)var_dump($mutable-&gt;isImmutable()); // bool(false)$immutable = Carbon::now()-&gt;toImmutable();var_dump($immutable-&gt;isMutable()); // bool(false)var_dump($immutable-&gt;isImmutable()); // bool(true) Answer:Carbon::now() 所取得的 object 可被修改, 即同一個 objectCarbonImmutable::now() 取得的 object 不可被修改, 每次取都是新的mutable 與 immutable 可互相轉換 以下的 Laravel example code, 意思相同嗎？ Example:&lt;?php$time = Carbon::now;$time = new Carbon(); Answer:一樣 以下的 Laravel example code 的意思是？ Example: &lt;?php$now = Carbon::now();$nowInLondonTz = Carbon::now(new DateTimeZone(&#x27;Europe/London&#x27;));$nowInLondonTz = Carbon::now(&#x27;Europe/London&#x27;);echo $nowInLondonTz-&gt;tzName;echo &quot;\\n&quot;;$date = Carbon::now(&#x27;+13:30&#x27;);echo $date-&gt;tzName;echo &quot;\\n&quot;;echo $date-&gt;utcOffset();echo &quot;\\n&quot;;$date-&gt;utcOffset(180);echo $date-&gt;tzName;echo &quot;\\n&quot;;echo $date-&gt;utcOffset(); Answer: &lt;?php$now = Carbon::now(); // 使用 default timezone// 建議使用 UTC, 然後透過轉換時區轉成使用者的時區$nowInLondonTz = Carbon::now(new DateTimeZone(&#x27;Europe/London&#x27;));// 直接設定時區$nowInLondonTz = Carbon::now(&#x27;Europe/London&#x27;);echo $nowInLondonTz-&gt;tzName; // Europe/Londonecho &quot;\\n&quot;;// 直接帶入 offset 設定時區$date = Carbon::now(&#x27;+13:30&#x27;);echo $date-&gt;tzName; // +13:30echo &quot;\\n&quot;;// 取得距 UTC 的 offset (分鐘)echo $date-&gt;utcOffset(); // 810echo &quot;\\n&quot;;// 重設為距 UTC 180 分鐘$date-&gt;utcOffset(180);// timezone 變為距 UTC 180 分鐘, 即 3 小時echo $date-&gt;tzName; // +03:00echo &quot;\\n&quot;;echo $date-&gt;utcOffset(); // 180 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho (new Carbon(&#x27;first day of December 2008&#x27;))-&gt;addWeeks(2);echo &quot;\\n&quot;;echo Carbon::parse(&#x27;first day of December 2008&#x27;)-&gt;addWeeks(2); Answer:都是 // 2008-12-15 00:00:00, 使用 parse 少一個 bracket 以下的 Laravel example code 的意思是？ Example:&lt;?php$string = &#x27;first day of next month&#x27;;if (strtotime($string) === false) &#123; echo &quot;&#x27;$string&#x27; is not a valid date/time string.&quot;;&#125; elseif (Carbon::hasRelativeKeywords($string)) &#123; echo &quot;&#x27;$string&#x27; is a relative valid date/time string, it will returns different dates depending on the current date.&quot;;&#125; else &#123; echo &quot;&#x27;$string&#x27; is an absolute date/time string, it will always returns the same date.&quot;;&#125; Answer:使用 hasRelativeKeywords() 來判斷帶入的 string 是否為 relative 以下的 Laravel example code 的意思是？ Example:&lt;?php$now = Carbon::now();echo $now; // 2021-02-09 18:29:22echo &quot;\\n&quot;;$today = Carbon::today();echo $today; // 2021-02-09 00:00:00echo &quot;\\n&quot;;$tomorrow = Carbon::tomorrow(&#x27;Europe/London&#x27;);echo $tomorrow; // 2021-02-10 00:00:00echo &quot;\\n&quot;;$yesterday = Carbon::yesterday();echo $yesterday; // 2021-02-08 00:00:00 Answer:可使用 Carbon 的 today(), yesterday(), tomorrow() 取得相對應的日期, 也可帶入 timezone 以下的 Laravel example code 的意思是？ Example:&lt;?php$year = 2000; $month = 4; $day = 19;$hour = 20; $minute = 30; $second = 15; $tz = &#x27;Europe/Madrid&#x27;;echo Carbon::createFromDate($year, $month, $day, $tz).&quot;\\n&quot;;echo Carbon::createMidnightDate($year, $month, $day, $tz).&quot;\\n&quot;;echo Carbon::createFromTime($hour, $minute, $second, $tz).&quot;\\n&quot;;echo Carbon::createFromTimeString(&quot;$hour:$minute:$second&quot;, $tz).&quot;\\n&quot;;echo Carbon::create($year, $month, $day, $hour, $minute, $second, $tz).&quot;\\n&quot;; Answer:000-04-19 06:58:092000-04-19 00:00:002021-04-11 20:30:152021-04-11 20:30:152000-04-19 20:30:15createFromDate, 時間為預設createMidnightDate, 時間為 00:00:00createFromTime, 年月日為預設createFromTimeString, 年月日為預設create(), 帶 null 皆為預設 以下的 Laravel example code 的意思是？ Example:&lt;?php$xmasThisYear = Carbon::createFromDate(null, 12, 25);$Y2K = Carbon::create(2000, 1, 1, 0, 0, 0);$alsoY2K = Carbon::create(1999, 12, 31, 24);$noonLondonTz = Carbon::createFromTime(12, 0, 0, &#x27;Europe/London&#x27;);$teaTime = Carbon::createFromTimeString(&#x27;17:00:00&#x27;, &#x27;Europe/London&#x27;);try &#123; Carbon::create(1975, 5, 21, 22, -2, 0); &#125; catch(InvalidArgumentException $x) &#123; echo $x-&gt;getMessage(); &#125;// minute must be between 0 and 99, -2 given// Be careful, as Carbon::createFromDate() default values to current date, it can trigger overflow:// For example, if we are the 15th of June 2020, the following will set the date on 15:Carbon::createFromDate(2019, 4); // 2019-04-15// If we are the 31th of October, as 31th April does not exist, it overflows to May:Carbon::createFromDate(2019, 4); // 2019-05-01// That&#x27;s why you simply should not use Carbon::createFromDate() with only 2 parameters (1 or 3 are safe, but no 2) Answer:&lt;?php$xmasThisYear = Carbon::createFromDate(null, 12, 25); // Year 為 default$Y2K = Carbon::create(2000, 1, 1, 0, 0, 0); // 等同 Carbon::createMidnightDate(2000, 1, 1)$alsoY2K = Carbon::create(1999, 12, 31, 24);$noonLondonTz = Carbon::createFromTime(12, 0, 0, &#x27;Europe/London&#x27;);$teaTime = Carbon::createFromTimeString(&#x27;17:00:00&#x27;, &#x27;Europe/London&#x27;);try &#123; Carbon::create(1975, 5, 21, 22, -2, 0); &#125; catch(InvalidArgumentException $x) &#123; echo $x-&gt;getMessage(); &#125;// minute 需為 0-99, 帶入 -2 會報錯, 若帶 99 為 22 時加上 99 分, 即 23:39// Be careful, as Carbon::createFromDate() default values to current date, it can trigger overflow:// For example, if we are the 15th of June 2020, the following will set the date on 15:Carbon::createFromDate(2019, 4); // 2019-04-15// If we are the 31th of October, as 31th April does not exist, it overflows to May:Carbon::createFromDate(2019, 4); // 2019-05-01// That&#x27;s why you simply should not use Carbon::createFromDate() with only 2 parameters (1 or 3 are safe, but no 2) # Additional以下的 Laravel example code 的意思是？ Example:&lt;?phpecho Carbon::createFromFormat(&#x27;Y-m-d H&#x27;, &#x27;1975-05-21 22&#x27;)-&gt;toDateTimeString(); Answer:// 1975-05-21 22:00:00使用 createFromFormat() 來自定義 format 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho Carbon::create(2000, 1, 35, 13, 0, 0);echo &quot;\\n&quot;;try &#123; Carbon::createSafe(2000, 1, 35, 13, 0, 0);&#125; catch (\\Carbon\\Exceptions\\InvalidDateException $exp) &#123; echo $exp-&gt;getMessage();&#125; Answer:// 2000-02-04 13:00:00// day : 35 is not a valid value.使用 createSafe() 來產生 Carbon exception 以下的 Laravel example code 的意思是？ Example:&lt;?phpCarbon::parse($request-&gt;changed_at)-&gt;setTimezone(config(&#x27;app.timezone&#x27;)); Answer:就算帶入的 string 本身已經是 ISO8601 格式, 如果不特別使用 setTimezone 或 toIso8601String 的話, 存入 MySQL 的 date 是不會根據當前的 timezone 去做轉換的, 也就是 Laravel 會無視 timezone 的部分, 直接將 datetime 的部分存入資料庫, 這樣就失去 ISO8601 註明 timezone 意義了 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function test() &#123; Carbon::setTestNow(Carbon::parse(&#x27;January 1, 2020&#x27;))&#125; Answer:使用 setTestNow() 可以設定 Carbon 的當前時間","link":"/zh-tw/laravel-carbon/"},{"title":"Laravel - Database - Pagination (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Basic Usage# Paginating Query Builder Results以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Support\\Facades\\DB;class UserController extends Controller&#123; public function index() &#123; $users = DB::table(&#x27;users&#x27;)-&gt;paginate(15); return view(&#x27;user.index&#x27;, [&#x27;users&#x27; =&gt; $users]); &#125;&#125; Answer:分頁處理 users table query builder 的結果 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;simplePaginate(15); Answer:paginate users table 的 query 結果, 不顯示分頁頁數, 只提供上一頁跟下一頁的 link, 效能較佳 # Paginating Eloquent Results以下的 Laravel example code 的意思是？ Example:&lt;?php$users = User::where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;paginate(15); Answer:paginate User model Eloquent queries 結果, 每頁 15 筆資料 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = User::where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;simplePaginate(15); Answer:simple paginate User model Eloquent queries 結果, 每頁 15 筆資料, 差別在於不提供頁數號碼, 只提供上一頁跟下一頁的 link # Manually Creating A PaginatorLaravel 中, Paginator 與 LengthAwarePaginator 的差異是？Paginator 不需要知道共有幾筆資料, 所以也無法直接取得最後一筆資料LengthAwarePaginator 需要知道共有幾筆資料 # Displaying Pagination ResultsCustomizing The Paginator URILaravel 中, 以下的 example 的意思是？ Example:&lt;?phpRoute::get(&#x27;users&#x27;, function () &#123; $users = App\\Models\\User::paginate(15); $users-&gt;withPath(&#x27;custom/url&#x27;); //&#125;); Answer:客製化 paginator 的 links, 像是 http://example.com/custom/url?page=N Appending To Pagination LinksLaravel 中, 以下的 example 的意思是？ Example:&lt;?php&#123;&#123; $users-&gt;appends([&#x27;sort&#x27; =&gt; &#x27;votes&#x27;])-&gt;links() &#125;&#125; Answer:將 [&#39;sort&#39; =&gt; &#39;votes&#39;] 附加到 pagination link 的 query Laravel 中, 以下的 example 的意思是？ Example:&lt;?php&#123;&#123; $users-&gt;withQueryString()-&gt;links() &#125;&#125; Answer:將所有的 querystring 都附加到 pagination link Laravel 中, 以下的 example 的意思是？ Example:&lt;?php&#123;&#123; $users-&gt;fragment(&#x27;foo&#x27;)-&gt;links() &#125;&#125; Answer:附加 fragment 到 pagination links, 像是 http://www.example.org/foo.html#foo Displaying Pagination Results以下的 Laravel example code 的意思是？ Example:&lt;?php&lt;div class=&quot;container&quot;&gt; @foreach ($users as $user) &#123;&#123; $user-&gt;name &#125;&#125; @endforeach&lt;/div&gt;&#123;&#123; $users-&gt;links() &#125;&#125; Answer:當 $users 為 Paginator 或 LengthAwarePaginator instance 時, 可使用 link() 取得導向剩下結果的每一頁的 link # Adjusting The Pagination Link Window以下的 Laravel example code 的意思是？ Example:&lt;?php&#123;&#123; $users-&gt;onEachSide(5)-&gt;links() &#125;&#125; Answer:當使用 Paginator 或 LengthAwarePaginator 的 link() 時, 預設會顯示 current page 左右各三頁的 link, 如果要自定義, 可使用 onEachSide() # Converting Results To JSONLaravel 中, 以下的 example 的意思是？ Example:&lt;?phpRoute::get(&#x27;users&#x27;, function () &#123; return App\\Models\\User::paginate();&#125;); Answer:return JSON 格式的 pagination object, 如下 Output:&#123; &quot;total&quot;: 50, &quot;per_page&quot;: 15, &quot;current_page&quot;: 1, &quot;last_page&quot;: 4, &quot;first_page_url&quot;: &quot;http://laravel.app?page=1&quot;, &quot;last_page_url&quot;: &quot;http://laravel.app?page=4&quot;, &quot;next_page_url&quot;: &quot;http://laravel.app?page=2&quot;, &quot;prev_page_url&quot;: null, &quot;path&quot;: &quot;http://laravel.app&quot;, &quot;from&quot;: 1, &quot;to&quot;: 15, &quot;data&quot;:[ &#123; // Record... &#125;, &#123; // Record... &#125; ]&#125; # Customizing The Pagination View以下的 Laravel example code 的意思是？ Example:&lt;?php&#123;&#123; $paginator-&gt;links(&#x27;view.name&#x27;) &#125;&#125;// Passing additional data to the view...&#123;&#123; $paginator-&gt;links(&#x27;view.name&#x27;, [&#x27;foo&#x27; =&gt; &#x27;bar&#x27;]) &#125;&#125; Answer:Laravel Paginator 預設是使用 Tailwind CSS 的, 但如果要自定義的話, 可以 pass 指定的 view, 以及 additional parameters 以下的 Laravel example command 的意思是？ Example:&lt;?phpphp artisan vendor:publish --tag=laravel-pagination Answer:可匯出內建的 Paginator view blade 到 resources/views/vendor/pagination 資料夾, 可編輯其中的 tailwind.blade.php 來修改 pagination HTML 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Pagination\\Paginator;use Illuminate\\Support\\Facades\\Blade;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123; public function boot() &#123; Paginator::defaultView(&#x27;view-name&#x27;); Paginator::defaultSimpleView(&#x27;view-name&#x27;); &#125;&#125; Answer:在 AppServiceProvider boot() 中, 可使用 defaultView 以及 defaultSimpleView 來定義 Paginator, simple paginator 的 default view file name, 可將 view file 置於 resources/views/vendor/pagination/ # Using Bootstrap以下的 Laravel example code 的意思是？ Example:&lt;?php// 位於 AppServiceProvideruse Illuminate\\Pagination\\Paginator;public function boot()&#123; Paginator::useBootstrap();&#125; Answer:Laravel Paginator view 預設是使用 tailwind CSS, 但如果要使用 bootstrap, 可在 AppServiceProvider boot() 中, 使用 useBootstrap() # Paginator Instance Methods以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;count() Answer:取得 current page 有幾個 item 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;currentPage() Answer:取得 current page number 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;firstItem() Answer:取得 first item number 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;getOptions() Answer:取得 paginator options 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;getUrlRange($start, $end) Answer:建立一組指定範圍內的 URLs 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;hasPages() Answer:確認是否有足夠的 item 來形成第二頁 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;hasMorePages() Answer:確認當前頁是否為最後一頁 (是否還有更多 item) 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;items() Answer:取得 current page items 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;lastItem() Answer:取得 current page last item 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;lastPage() Answer:取得 last page number (simple paginator 不適用) 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;nextPageUrl() Answer:取得 next page url 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;onFirstPage() Answer:判斷是否為 first page 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;perPage() Answer:取得每頁有幾個 item 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;previousPageUrl() Answer:取得 previous page url 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;total() Answer:取得 data store item 總數 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;url($page) Answer:取得指定 $page 的 url 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;getPageName() Answer:取得 ‘page’ 的 query string name, Laravel 預設為 ‘page’, 可自己修改, 所以不一定叫做 page, 透過這個 method 可取得 以下的 Laravel example code 的意思是？ Example:&lt;?php$paginator-&gt;setPageName($name) Answer:Laravel paginator 預設 query string 代表第幾頁的為 ‘page’, 例如 example.com/whatever?page=3, 可使用 setPageName 修改, 假設 setPageName(&#39;egap&#39;), 那 url 則為 example.com/whatever?egap=3","link":"/zh-tw/laravel-database-pagination/"},{"title":"Kubernetes - Deployments (官方文件原子化翻譯筆記)","text":"概述Deployment 提供宣告式的方法來更新 Pods 以及 ReplicaSets透過 Deployment 描述希望的狀態, 然後 Deployment Controller 會將目前的狀態改變成希望的狀態, 你可以定義 Deployments 來建立一個新的 ReplicaSets, 或是移除已存在的 Deployments, 然後重新建一個。 建立一個 Deployment以下是 Deployment 的範例, 它建立了一個 ReplicaSet 來啟動三個 nginx Pods: apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment labels: app: nginxspec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 這邊針對上面的範例做解說: 一個叫做 nginx-deployment 的 Deployment 被建立了, 可從 .metadata.name 這裡看到 這個 Deployment 建立了三個 replicated Pods, 可從 replicas 欄位得知 selector field 用於定義 Deployment 管理的 Pods 對象, 本範例中的對象為 template 中定義的 app: nginx template 欄位中又含有以下子欄位： 經由 labels 欄位, 我們給 Pods 貼上標籤 app: nginx 從 .template.spec 欄位, 可以看到 Pods 運行一個容器, nignx, 使用 nginx Docker Hub 鏡像, 版本 1.7.9 建立一個容器, 並透過 name 欄位來命名為 nginx 現在讓我們來建立一個 Deployment 吧： 使用以下指令建立一個 Deployment, 你可以給指定最後加上 --record, 它會將執行的指令寫入資源的 annotation 欄位中 kubernetes.io/change-cause, 這對之後的追蹤十分有用, 比如說, 可用來檢視每個 Deployment 版本執行的指令 kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml 執行 kubectl get deployments 來確認 Deployment 是不是已經建立了。 如果還在建立中, 輸出應如下： 輸出NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 0/3 0 0 1s 如果是在叢集中檢視 Deployments, 會顯示以下欄位 NAME 列出在這個叢集中 Deployments 的名稱 DESIRED 列出宣告的 replicas 的數量, 建立 Deployment 時定義的 CURRENT 顯示目前共有幾個 replicas 在運行 UP-TO-DATE 顯示已被更新來達成期望狀態的 replicas 數量 AVAILABLE 顯示可用的 replicas 數量 AGE 顯示 replica 已運行的時間 replicas 數量的宣告值是根據 .spec.replicas 欄位 執行以下指令來檢視 Deployment rollout status 指令kubectl rollout status deployment.v1.apps/nginx-deployment 預計輸出Waiting for rollout to finish: 2 out of 3 new replicas have been updated...deployment.apps/nginx-deployment successfully rolled out 幾秒後, 在執行以下指令一次 指令kubectl get deployments 預計輸出NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 3/3 3 3 18s 可以看到 Deployment 已經建立了三個 replicas, 且所有的 replicas 都是最新狀態以及可用 檢視被 Deployment 建立的 ReplicaSet (rs) 執行以下指令kubectl get rs 預計輸出NAME DESIRED CURRENT READY AGEnginx-deployment-75675f5897 3 3 3 18s ReplicaSet 的格式為 [DEPLOYMENT-NAME]-[RANDOM-STRING], random string 為隨機產生, 且使用 pod-template-hash 為來源之一 檢視每個 Pod 自動產生的 labels 執行指令kubectl get pods --show-labels 預計輸出NAME READY STATUS RESTARTS AGE LABELSnginx-deployment-75675f5897-7ci7o 1/1 Running 0 18s app=nginx,pod-template-hash=3123191453nginx-deployment-75675f5897-kzszj 1/1 Running 0 18s app=nginx,pod-template-hash=3123191453nginx-deployment-75675f5897-qqcnn 1/1 Running 0 18s app=nginx,pod-template-hash=3123191453 已建立完成的 ReplicaSet 會確保有三個 nginx Pods 這邊要注意的是, 務必要正確的在 Deployment 中指定適當的 selector 以及 Pod template labels (在本範例中, app:nginx), 不要讓 labels 或 selectors 跟其他的 controllers 有重疊 (包含其他的 Deployments 以及 StatefulSets), Kubernetes 不會阻止這件事, 且如果上述情形發生的話, 可能會產生衝突以及一些預期外的行為 Pod-template-hash label注意: 不可改變這個 labelpod-template-hash label 由 Deployment controller 加到每一個它所建立的 ReplicaSet 當中。 Updating a Deployment注意: Deployment 的 rollout 唯有當 Deployment 的 Pod template (也就是 .spec.template) 變更了, 舉例來說, 像是 template 當中的 labels 或是容器鏡像更新了。其他的更新, 例如 Deployment 的擴縮, 不會觸發 rollout 遵循以下步驟來更新你的 Deployment: 將 nginx Pods 從鏡像版本 nginx:1.7.9 更新成 nginx:1.9.1 執行以下指令kubectl --record deployment.apps/nginx-deployment set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 或是簡化版本的kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1 --record 輸出應如下：deployment.apps/nginx-deployment image updated 又或者, 你也可以使用 edit 指令, 到編輯器中將 .spac.template.spec.container[0].image 的版本從 nginx.1.7.9 變更為 nginx:1.9.1kubectl edit deployment.v1.apps/nginx-deployment 輸出應如下：deployment.apps/nginx-deployment edited 檢視 rollout status 執行指令kubectl rollout status deployment.v1.apps/nginx-deployment 或是簡化版kubectll rollout status deployment nginx-deployment 輸出應如下:Waiting for rollout to finish: 2 out of 3 new replicas have been updated... 或deployment.apps/nginx-deployment successfully rolled out 從更新後的 Deployment 取得更多細節： 檢視 rollout 成功的 Deployment 執行kubectl get deployments 輸出NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 3/3 3 3 36s 檢視 ReplicaSets 執行kubectl get rs 輸出NAME DESIRED CURRENT READY AGEnginx-deployment-1564180365 3 3 3 6snginx-deployment-2035384211 0 0 0 36s 下一次你想要更新這些 Pod 的話, 你只需要再次更新 Deployment 的 Pod template 就行了Deployment 確保更新過程中只會有一定數量的 Pods 是不可用的。預設, 最少要有 75% 的 Pod 要處於運行中, 最多 25% 的 Pod 可容許不可用Deployment 同時確保在升級過程中同時只有一定數量的 Pod 會被建立, 預設最多 Pod 的 125% 期望數量可被運行 (最多 25% 增加)舉例來說, 如果你仔細的檢視 rollout 的過程, 你會發現, 首先 Deployment 會先建立一個新的 Pod, 然後殺掉某個舊的 Pod, 然後建立一個新的。 它不會等到新的 Pod 都已經足夠了才殺掉舊的 Pod, 也不會等到舊的 Pod 已經被砍到一個足夠的數量才去建立新的 Pod, 它確保至少有兩個 Pods 可用, 而最多四個 Pods 可用 檢視 Deployment 的細節資訊: 執行kubectl describe deployments 輸出Name: nginx-deploymentNamespace: defaultCreationTimestamp: Thu, 30 Nov 2017 10:56:25 +0000Labels: app=nginxAnnotations: deployment.kubernetes.io/revision=2Selector: app=nginxReplicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template:Labels: app=nginx Containers: nginx: Image: nginx:1.9.1 Port: 80/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailableOldReplicaSets: &lt;none&gt;NewReplicaSet: nginx-deployment-1564180365 (3/3 replicas created)Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 2m deployment-controller Scaled up replica set nginx-deployment-2035384211 to 3 Normal ScalingReplicaSet 24s deployment-controller Scaled up replica set nginx-deployment-1564180365 to 1 Normal ScalingReplicaSet 22s deployment-controller Scaled down replica set nginx-deployment-2035384211 to 2 Normal ScalingReplicaSet 22s deployment-controller Scaled up replica set nginx-deployment-1564180365 to 2 Normal ScalingReplicaSet 19s deployment-controller Scaled down replica set nginx-deployment-2035384211 to 1 Normal ScalingReplicaSet 19s deployment-controller Scaled up replica set nginx-deployment-1564180365 to 3 Normal ScalingReplicaSet 14s deployment-controller Scaled down replica set nginx-deployment-2035384211 to 0 這邊可以看到, 一開始當你建立了 Deployment, 它建立了一個 ReplicaSet (nginx-deployment-2035384211), 然後直接擴增到 3 個 replicas, 而當你更新 Deployment, 它建立了一個新的 ReplicaSet (nginx-deployment-1564180365) 並且擴增到 1 個然後將舊的 ReplicaSet 縮為 2, 所以最少有 2 個 Pods 是可用的, 最多可以有 4 個 Pods 是啟動的。 之後, 遵循著相同的滾動升級策略, 它持續的擴縮, 最後, 你會有三個新的 replicas, 然後 0 個舊的 Replicas Rollover (aka multiple updates in-flight)每次 Deployment controller 觀察到有新的 Deployment 時, 一個新的 ReplicaSet 會被建立來提供期望數量的 Pods。 如果說 Deployment 被更新了, 那 label 有符合 .spec.selector 但 template 不符合 .spec.replicas 的已存在 ReplicaSet 會開始縮減數量。 最後, 新的 ReplicaSet 會擴增到符合 .spec.replicas 的數量, 然後所有舊的 ReplicaSets 都縮減為 0如果你在滾動升級途中更新一個 Deployment, Deployment 會建立一個新的 ReplicaSet 並開始擴容, 同時縮減原本擴容到一半的 ReplicaSet, 它會被加到舊的 ReplicaSets 清單, 並且開始縮減舉例來說, 假如你建立了一個 Deployment 來建立 5 個 nginx:1.7.9 replicas, 但是當只有 3 個 replicas 的 nginx:1.7.9 被建立完成時, 你將這個 Deployment 更新成 5 個 nginx:1.9.1 的 replicas。 在這個範例中, Deployment 會立即的開始砍掉這三個 nginx:1.7.9 的 Pods, 並開始建立 nginx:1.9.1 的 Pods。 他不會等到 5 個 nginx:1.7.9 的 replicas 都建好之後, 再改變狀態 Label selector 更新通常不建議修改 label selector, 且 selector 建議在一開始就規劃好。 不管怎樣, 如果你需要更新 label selector, 那請一定要很小心, 並且確保你已經掌握任何它可能會造成的影響。注意: 在 API 版本 apps/v1, Deployment 的 label selector 在建立之後就無法變更了。 Selector 的增加需要也更新 Deployment spec 中的 Pod template labels, 否則會回傳 validation error。 這個變更是不可覆蓋的, 這表示說, 新的 selector 不會去選擇舊的 selector 建立的 ReplicasSet 以及 Pods, 所以結果會是, 建立了新的 ReplicaSet, 然後所有舊的 ReplicaSets 都成了孤兒。 Selector 的更新改變了 selector key 的現存 value - 造成的結果跟增加 selector 相同 Selector 的刪除會從 Deployment selector 中移除已經存在的 key - 這不需要 Pod template labels 有任何改變。 已經存在的 ReplicaSets 也不會變成孤兒, 也不會有新的 ReplicaSets 會被建立。 但被移除的 label 還是存在於現存的 Pods 以及 ReplicaSets 之中。 回滾 Deployment有時, 你可能會想要回滾 Deployment; 例如說, 當一個 Deployment 並不穩定, 一直的 crash looping。 預設, 所有的 Deployment rollout 歷史都會被記錄下來, 所以任何時候你都可以回滾 (你可以修改版本歷史限制來改變這一個特性)Note: 當 Deployment 的 rollout 被觸發時, 會建立一個 Deployment revision。 這表示唯有當 Deployment 的 Pod template (.spec.template) 改變了, 例如你更新了 template 的 labels 或 container images, 這樣 revision 才會被建立。 其他更新, 像是擴容 Deployment 並不會建立 Deployment revision, 所以你可以無礙的手動或自動的擴縮 Deployment。 這表示說, 當你回滾到一個早些的版本, 只有 Deployment 的 Pod template 部分會被回滾。 假如你在更新 Deployment 時打錯字, 把 nginx:1.9.1 打成 nginx:1.91: 執行指令kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=true 輸出deployment.apps/nginx-deployment image updated 這時 rollout 卡住了, 確認一下： 執行kubectl rollout status deployment.v1.apps/nginx-deployment 輸出Waiting for rollout to finish: 1 out of 3 new replicas have been updated... 按下 Ctrl-C 來停止 rollout status 輸出, 可以參考這裏, 有更多 rollout 卡住的資訊 可以看到舊的 replicas nginx-deployment-1564180365 跟 nginx-deployment-2035384211 的數量是 2, 然後新的 replicas (nginx-deployment-3066724191) 是 1 執行kubectl get rs 輸出NAME DESIRED CURRENT READY AGEnginx-deployment-1564180365 3 3 3 25snginx-deployment-2035384211 0 0 0 36snginx-deployment-3066724191 1 1 0 6s 從建立的 Pods 可以看到這個由新的 ReplicaSet 建立的 Pod 卡在 image pull loop 執行kubectl get pods 輸出NAME READY STATUS RESTARTS AGEnginx-deployment-1564180365-70iae 1/1 Running 0 25snginx-deployment-1564180365-jbqqo 1/1 Running 0 25snginx-deployment-1564180365-hysrc 1/1 Running 0 25snginx-deployment-3066724191-08mng 0/1 ImagePullBackOff 0 6s 注意: Deployment controller 自動停止了錯誤的 rollout, 並且停止擴容新的 ReplicaSet。 這取決於你定義的 rollingUpdate 的參數 (更準確的說, maxUnavailable), Kubernetes 的預設值為 25% 取得 Deployment 描述 執行kubectl describe deployment 輸出Name: nginx-deploymentNamespace: defaultCreationTimestamp: Tue, 15 Mar 2016 14:48:04 -0700Labels: app=nginxSelector: app=nginxReplicas: 3 desired | 1 updated | 4 total | 3 available | 1 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template: Labels: app=nginx Containers: nginx: Image: nginx:1.91 Port: 80/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True ReplicaSetUpdatedOldReplicaSets: nginx-deployment-1564180365 (3/3 replicas created)NewReplicaSet: nginx-deployment-3066724191 (1/1 replicas created)Events: FirstSeen LastSeen Count From SubObjectPath Type Reason Message --------- -------- ----- ---- ------------- -------- ------ ------- 1m 1m 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-2035384211 to 3 22s 22s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-1564180365 to 1 22s 22s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled down replica set nginx-deployment-2035384211 to 2 22s 22s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-1564180365 to 2 21s 21s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled down replica set nginx-deployment-2035384211 to 1 21s 21s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-1564180365 to 3 13s 13s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled down replica set nginx-deployment-2035384211 to 0 13s 13s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-3066724191 to 1 要解決這個問題, 你需要回滾到前一個穩定的 Deployment reversion 確認 Deployment 的 Rollout 歷史照著以下步驟來確認 rollout 歷史: 確認 Deployment reversion 執行kubectl rollout history deployment.v1.apps/nginx-deployment 輸出deployments &quot;nginx-deployment&quot;REVISION CHANGE-CAUSE1 kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=true2 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true3 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=true CHANGE-CAUSE 是當 revisions 建立時, 從 Deployment 的 annotation kubernetes.io/change-cause 複製到你的 revisions, 你也可以藉由以下方法指定 CHANGE-CAUSE 的 message: 輸入指令kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause=&quot;image updated to 1.9.1&quot; 當我們在做資源變更時, 最後加入 --record 的 flag 手動編輯資源的 manifest 檔案, 就是 yaml 檔 若要檢視每個 revision 的細節資訊： 執行kubectl rollout history deployment.v1.apps/nginx-deployment --revision=2 輸出deployments &quot;nginx-deployment&quot; revision 2 Labels: app=nginx pod-template-hash=1159050644 Annotations: kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true Containers: nginx: Image: nginx:1.9.1 Port: 80/TCP QoS Tier: cpu: BestEffort memory: BestEffort Environment Variables: &lt;none&gt; No volumes. 版本回滾照著以下步驟將 Deployment 從目前的版本回滾到之前的版本, 之前的版本為版本2 取消當前版本並回滾到之前版本 執行kubectl rollout undo deployment.v1.apps/nginx-deployment 輸出deployment.apps/nginx-deployment 或使用 --to-revision 指定要回滾至的版本kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2 輸出deployment.apps/nginx-deployment 更多關於 rollout 的指令可以參考kubectl rolloutDeployment 目前已經回滾到之前的穩定版本, 所以你可以看到, Deployment 產生了一個 DeploymentRollback 的事件, 代表回滾到版本 2 要確定 rollback 有成功並且 Deployment 如預期般的正常運行: 執行kubectl get deployment nginx-deployment 輸出NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 3/3 3 3 30m 取得 Deployment 的細節描述 執行kubectl describe deployment nginx-deployment 輸出Name: nginx-deploymentNamespace: defaultCreationTimestamp: Sun, 02 Sep 2018 18:17:55 -0500Labels: app=nginxAnnotations: deployment.kubernetes.io/revision=4 kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=trueSelector: app=nginxReplicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template: Labels: app=nginx Containers: nginx: Image: nginx:1.9.1 Port: 80/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailableOldReplicaSets: &lt;none&gt;NewReplicaSet: nginx-deployment-c4747d96c (3/3 replicas created)Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 12m deployment-controller Scaled up replica set nginx-deployment-75675f5897 to 3 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-c4747d96c to 1 Normal ScalingReplicaSet 11m deployment-controller Scaled down replica set nginx-deployment-75675f5897 to 2 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-c4747d96c to 2 Normal ScalingReplicaSet 11m deployment-controller Scaled down replica set nginx-deployment-75675f5897 to 1 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-c4747d96c to 3 Normal ScalingReplicaSet 11m deployment-controller Scaled down replica set nginx-deployment-75675f5897 to 0 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-595696685f to 1 Normal DeploymentRollback 15s deployment-controller Rolled back deployment &quot;nginx-deployment&quot; to revision 2 Normal ScalingReplicaSet 15s deployment-controller Scaled down replica set nginx-deployment-595696685f to 0 擴縮 Deployment使用以下指令擴縮 Deployment: 執行kubectl scale deployment.v1.apps/nginx-deployment --replicas=10 輸出deployment.apps/nginx-deployment scaled 假設 水平 Pod 自動擴縮 在你的叢集中是有打開的, 可以設定擴縮你的 Deployment 依據給予的 Pods 最大及最小數量, 以及 CPU 的使用率 執行 kubectl autoscale deployment.v1.apps/nginx-deployment --min=10 --max=15 --cpu-percent=80 輸出 deployment.apps/nginx-deployment scaled 比例擴縮滾動升級 Deployment 支援同時運行不同版本的應用。 當一個 Deployment 正處於 rollout 狀態 (在途中或暫停狀態), 此時你或者是自動調節器又發出一個擴縮請求, Deployment controller 會將額外增加的 replicas 成比例的分配到目前運作中的 ReplicaSets (有啟動 Pods 的 ReplicaSets) 以降低風險。 這樣的行為稱為比例擴縮 (proportional scaling), 例如說, 你正運行著有 10 個 replicas 的 Deployment, maxSurge=3, maxUnavailable=2 確保 Deployment 下的 10 個 replicas 都有在運行 執行kubectl get deploy 輸出NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEnginx-deployment 10 10 10 10 50s 將鏡像版本更新成無法被解析的版本 執行kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:sometag 輸出deployment.apps/nginx-deployment image updated 這個鏡像的更新會啟動一個新的 rollout 以及 ReplicaSet nginx-deployment-1989198191, 但它會因為上面提到的 maxUnavailable 而被阻塞住 執行kubectl get rs 輸出NAME DESIRED CURRENT READY AGEnginx-deployment-1989198191 5 5 0 9snginx-deployment-618515232 8 8 8 1m 這時再將數量提升到 15 個 執行kubectl scale deployment nginx-deployment --replicas=15 此時, Deployment controller 需要決定要把這新的 5 個 replicas 使用哪一個 replicaSet 來啟動。 如果你沒有使用比例擴縮的話, 所有 5 個都會使用新的 ReplicaSet。 使用比例擴縮, 你將額外的 replicas 散佈到所有的 ReplicaSets, 比較多的 replicas 會被分配給擁有比較多 replica 的 replicaSet, 而比較少的 replicas 會被分配給擁有比較少 replica 的 replicaSet, 而擁有 0 個 replica 的 replicaSet 將不會被分配任何 replica 執行以下指令確認目前狀態kubectl get deploy 輸出NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEnginx-deployment 15 18 7 8 7m 執行指令確認 rs 狀態kubectl get rs 輸出NAME DESIRED CURRENT READY AGEnginx-deployment-1989198191 7 7 0 7mnginx-deployment-618515232 11 11 11 7m 如果最後 rollout 恢復正常, replica 恢復健康的話, 所有的 replica 都會被移動到新的 ReplicaSet 暫停以及恢復一個 Deployment你可以在觸發一個或多個更新之前先暫停 Deployment, 然後再恢復。 這讓你可以進行多個更新, 並避免掉不必要的 rollout 比如說, 取得剛建立的 Deployment 資訊： 執行kubectl get deploly 輸出NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEnginx 3 3 3 3 1m 取得 rollout 狀態kubectl get rs 輸出NAME DESIRED CURRENT READY AGEnginx-2142116321 3 3 3 1m 使用以下指令停止 執行kubectl rollout pause deployment.v1.apps/nginx-deployment 輸出deployment.apps/nginx-deployment paused 更新鏡像 執行kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 輸出deployment.apps/nginx-deployment image updated 可以看到 rollout 完全沒有開始 執行kubectl rollout history deployment.v1.apps/nginx-deployment 輸出deployments &quot;nginx&quot;REVISION CHANGE-CAUSE1 &lt;none&gt; 取得 rollout status 確保 Deployment 已經有成功更新 執行kubectl get rs 輸出NAME DESIRED CURRENT READY AGEnginx-2142116321 3 3 3 2m 你可以盡可能地建立你需要的更新, 例如說, 更新資源: 執行kubectl set resources deployment.v1.apps/nginx-deployment -c=nginx --limits=cpu=200m,memory=512Mi 輸出deployment.apps/nginx-deployment resource requirements updated 在暫停前的 Deployment 狀態將會保持運作, 只要 Deployment 是處於暫停的狀態, 那你所建立的更新都不會對目前狀態有任何影響。 最後, 恢復 Deployment 並且觀察新的 ReplicaSet 進行所有新的更新 執行kubectl rollout resume deployment.v1.apps/nginx-deployment 輸出deployment.apps/nginx-deployment resumed 觀察 rollout 的狀態直到結束 執行kubectl get rs -w 輸出NAME DESIRED CURRENT READY AGEnginx-2142116321 2 2 2 2mnginx-3926361531 2 2 0 6snginx-3926361531 2 2 1 18snginx-2142116321 1 2 2 2mnginx-2142116321 1 2 2 2mnginx-3926361531 3 2 1 18snginx-3926361531 3 2 1 18snginx-2142116321 1 1 1 2mnginx-3926361531 3 3 1 18snginx-3926361531 3 3 2 19snginx-2142116321 0 1 1 2mnginx-2142116321 0 1 1 2mnginx-2142116321 0 0 0 2mnginx-3926361531 3 3 3 20s 取得最新 rollout 狀態 執行kubectl get rs 輸出NAME DESIRED CURRENT READY AGEnginx-2142116321 0 0 0 2mnginx-3926361531 3 3 3 28s Deployment 狀態Deployment 的生命週期中有很多種狀態, progressing 當建立一個新的 ReplicaSet, 又或者是 complete 或 fail to progress 進行中的 Deployment當以下任務在進行中時, Kubernetes 會將 Deployment 標註為 progressing 當 Deployment 建立新的 ReplicaSet 當 Deployment 正在擴容 ReplicaSet 當 Deployment 正在縮減 ReplicaSet 有新的 Pod 可用, 至少 (就緒時間打 MinReadySeconds 定義) 你可以使用 kubectl rollout status 來監控 Deployment 狀態 完成 Deployment有以下特點時, Kubernetes 會將 Deployment 標註為 complete 所有此 Deployment 的 replicas 都已更新到指定的最新版本, 代表說任何要求的更新都已經完成。 所有與此 Deployment 相關的 replicas 都可用 此 Deployment 下沒有舊的 replicas 在運行中 若要確認 Deployment 狀態是否為 completed, 可使用 kubectl rollout status。 如果 rollout 成功完成, kubectl rollout status 回應一個值為 0 的 exit code執行 kubectl rollout status deployment.v1.apps/nginx-deployment 輸出 Waiting for rollout to finish: 2 of 3 updated replicas are available...deployment.apps/nginx-deployment successfully rolled out$ echo $?0 失敗的 Deployment以下原因可能造成 rollout 卡住： 資源配額不足 Readiness 探測結果失敗 拉取鏡像錯誤 權限不足 資源限制 應用 runtime 配置錯誤 偵測這個情況的一個方法就是在 Deployment 的 spec (.spec.progressDeadlineSeconds), 這是個時間, 表示 Deployment controller 會在 Deployment 卡住多久之後回報這個異常 使用 kubectl 指令來設定 progressDeadlineSeconds 讓 controller 會在卡住 10 分鐘之後回報異常 執行kubectl patch deployment.v1.apps/nginx-deployment -p &#x27;&#123;&quot;spec&quot;:&#123;&quot;progressDeadlineSeconds&quot;:600&#125;&#125;&#x27; 輸出deployment.apps/nginx-deployment patched 一旦超過設定的 deadline, Deployment controller 在 Deployment 的 .status.confitions 增加一個具有下面內容的 DeploymentCondition 屬性 Type=Progressing Status=False Reason=ProgressDeadlineExceeded 更多有關 [status conditions] 的資訊可以參考 Kubernetes API conventions 注意: Kubernetes 對異常的 Deployment 除了回報 Reason=ProgressDeadlineExceeded 之外, 不會有其他動作。 更高階層的調節器可以利用這個訊息做相對應的動作, 比方說, 將 Deployment 回滾到之前的版本 注意: 如果你暫停 Deployment, Kubernetes 就不會確認你指定的 deadline, 你可以放心的暫停以及恢復 rollout, 不用擔心會因此而觸發 deadline 有時你可能會遇到暫時性的 Deployment 錯誤, 可能是因為你設了過短的 timeout 或是其他被認為是短暫的。 例如說, 你沒有足夠的資源。 如果你 describe Deployment, 你會看到以下： 執行kubectl describe deployment nignx-deployment 輸出&lt;...&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True ReplicaSetUpdated ReplicaFailure True FailedCreate&lt;...&gt; 如果你執行 kubectl get deployment nginx-deployment -o yaml, Deployment status 如下： status: availableReplicas: 2 conditions: - lastTransitionTime: 2016-10-04T12:25:39Z lastUpdateTime: 2016-10-04T12:25:39Z message: Replica set &quot;nginx-deployment-4262182780&quot; is progressing. reason: ReplicaSetUpdated status: &quot;True&quot; type: Progressing - lastTransitionTime: 2016-10-04T12:25:42Z lastUpdateTime: 2016-10-04T12:25:42Z message: Deployment has minimum availability. reason: MinimumReplicasAvailable status: &quot;True&quot; type: Available - lastTransitionTime: 2016-10-04T12:25:39Z lastUpdateTime: 2016-10-04T12:25:39Z message: &#x27;Error creating: pods &quot;nginx-deployment-4262182780-&quot; is forbidden: exceeded quota: object-counts, requested: pods=1, used: pods=3, limited: pods=2&#x27; reason: FailedCreate status: &quot;True&quot; type: ReplicaFailure observedGeneration: 3 replicas: 2 unavailableReplicas: 2 最後, 一旦 Deployment progress deadline 超過, Kubernetes 會將 status 以及 reason 更新: Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing False ProgressDeadlineExceeded ReplicaFailure True FailedCreate 你可以藉由擴縮 Deployment 或是增加資源配額到你的命名空間來解決資源配額不足的問題。 只要你滿足了資源配額, Deployment controller 會自動完成 Deployment rollout, 你將會看到 Deployment 的 status 會更新為 Status=True 以及 Reason=NewReplicaSetAvailable Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable Type=Available 配上 Status=True 表示你的 Deployment 已具有最小可用性。 最小可用性是由 Deployment strategy 的設定來決定。 Type=Progressing 配上 Status=true 表示你的 Deployment 正在 rollout 途中, 或者是 process 已完成, 且心 replicas 的最低需求已滿足 (詳細資料可以查看 condition 的 reason - 在我們的案例中, Reason=NewReplicaSetAvailable, 這代表這個 Deployment 已經完成)你可以使用 kubectl rollout status 確認 Deployment 是否有 process 失敗, 如果 Deployment 以及超出 procession deadline 的話, 會回傳一個值為非 0 的 exit code 執行 kubectl rollout status deployment.v1.apps/nginx-deployment 輸出 Waiting for rollout to finish: 2 out of 3 new replicas have been updated...error: deployment &quot;nginx&quot; exceeded its progress deadline$ echo $?1 在失敗的 Deployment 上的操作所有你可以在完成的 Deployment 上做的操作也可以使用在失敗的 Deployment 上。 你可以對它擴縮容, 回滾到之前的版本, 或是暫停, 如果你需要對這個 Deployment 的 Pod template 做多次的調整的話 Clean up Policy你可以在 Deployment 中的欄位 .spec.revisionHistoryLimit 指定你想要保留的舊的 ReplicaSets 的數量, 超出這個數量的會在背景被垃圾回收掉, 預設值為 10 注意: 如果你特別將這個欄位設為 0, 所有的 history 都會被清理掉, 因此你將會無法回滾你的 Deployment Canary Deployment如果你想要使用 Deployment 發佈 release 到不同的使用者群或伺服器群, 你可以建立多個 Deployment, 每個發佈都有各自的 Deployment, 更多有關金絲雀 (Canary) 部署的描述, 請參考managing resources 撰寫 Deployment Spec跟所有其他的 Kubernetes 配置檔一樣, Deployment 也需要 apiVersion, kind, 以及 metadata 欄位。 一些通用的資訊可以參考 應用部署, 設置容器, 以及 使用 kubectl 管理資源 文件Deployment 也需要 .spec 區塊 Pod Template.spec.template 以及 .spec.selector 是 .spec 中唯一要求的欄位.spec.template 為 Pod template。 它跟 Pod 有完全相同的配置, 唯一的不同處是它不需要 apiVersion 以及 kind, 以及它被包在另外一個一個物件內除了 Pod 中要求的欄位之外, 在 Deployment 中的 Pod template 必須指定合適的 labels 以及 restart policy。 不可與其他 controller 重疊 labels, 可參考 selector .spec.template.spec.restartPolicy 只被允許設為 Always, 這也是默認值 Replicas.spec.replicas 可填可不填, 用來指定想要啟動的 Pod 的數量, 預設為 1 Selector.spec.selector 是一個必要的欄位, 它指定了一個 label selector, 定義這個 Deployment 的目標 Pods .spec.selector 必須符合 .spec.template.metadata.labels, 否則將被 API 拒絕。 在 API 版本 apps/v1, .spec.selector 以及 .metadata.labels 預設並非 .spec.template.metadata.labels, 所以他們必須被明確的設定。 再者, .spec.selector 在 app/v1 中, 建立後就不可再更改 如果 Pods 的 template 跟 Deployment 的 .spec.template 不同, 又或者 Pods 的總數量超過了 .spec.replicas 定義的數量, Deployment 可能會將 label 符合該 Deployment selector 的 Pods 結束掉。 如果 Pods 的數量小於 Deployment 定義期望的數量, Deployment controller 會依照 .spec.template 開啟新的 Pods 注意: 不可重複建立 label 符合這個 selector 的 Pod, 或透過 Deployment 建立, 又或者透過其他的 controller, 像是 ReplicaSet 或 ReplicationController。 如果你這麼做了, 第一個 Deployment 依然會認為是她建立了這些其他的 Pods, 且 Kubernetes 也不會阻止你這麼做。 如果你有多個 controller, 彼此的 selector 都有重疊, 那這些 controller 將會互相打架而無法正確運作。 Strategy.spec.strategy 指定了更新 Pod 時採用的策略.spec.strategy.type 可以是 “Recreate” 或 “RollingUpdate”, 預設為 “RollingUpdate” Recreate Deployment當使用 .spec.strategy.type==Recreate 時, Kubernetes 會先將所有的 Pod 都殺掉, 在建立新的 Rolling Update Deployment上面有介紹過 RollingUpdate 的方式, 可參考 Rolling Date。 當 .spec.strategy.type==RollingUpdate 時, 你可以指定 maxUnavailable 以及 maxSurge 來控制滾動升級的步驟 Max Unavailable.spec.strategy.rollingUpdate.maxUnavailable 是一個選擇性的選項, 它指定了在更新的過程中, Pod 不可用的容許最大數量。 值可以是確切的數字 (像是 5), 或是比例 (像是 10%)。 如果使用比例的話, 會計算出絕對數字, 然後無條件去位。 spec.strategy.rollingUpdate.maxSurge 以及 .spec.strategy.rollingUpdate.maxUnavailable 不可同時設為 0, 後者預設為 25%比如說, 當我把值設為 30%, 那在滾動升級過程中舊的 ReplicaSet 最多可以縮容到期望可用 Pod 數量的 70%。 一旦新的 Pod 擴容了並且可用了, 舊的 ReplicaSet 才可以進一度的縮容, 確保在更新的過程中, Pods 的可用數量保持在 70% 的期望數量以上 Max Surge.spec.strategy.rollingUpdate.maxSurge 是一個選擇性的選項, 它指定了在更新的過程中, 可用 Pods 的容許最大數量。 值可以是確切的數字 (像是 5), 或是比例 (像是 10%)。 如果使用比例的話, 會計算出絕對數字, 然後在無條件進位。 spec.strategy.rollingUpdate.maxSurge 以及 .spec.strategy.rollingUpdate.maxUnavailable 不可同時設為 0, 後者預設為 25%比如說, 當我把值設為 30%, 那在滾動升級過程中舊的 ReplicaSet 最多可以擴容到期望可用 Pod 數量的 130%。 一旦舊的 Pod 被殺掉了, 新的 ReplicaSet 才可以進一度的擴容, 確保在更新的過程中, Pods 的可用數量保持在最多 130% 的期望數量 Progress Deadline Seconds.spec.progressDeadlineSeconds 是一個選擇性的欄位, 它指定了當 process 卡住的時候, Kubernetes 需要等待多久時間才回報failed progressing, 回報 Type=Progressing, Status=False, 以及 Reason=ProgressDeadlineExceeded 到 資源的 status.condition 中。 Deployment controller 會持續嘗試這個 Deployment。 在未來, 如果有實施自動回滾機制的話, Deployment controller 會自動地回滾 Deployment 當偵測到這樣的情況。如果有指定的話, 那這個欄位必須要大於 .spec.minReadySeconds 欄位 Min Ready Seconds.spec.minReadySeconds 是一個選擇性的配置欄位, 它指定了一個秒數, 一個新建立的 Pod, 被認定為可用, 並且沒有任何容器 crashing 的最低秒數。 默認為 0 (Pod 被建立就被認定是可用的), 更多關於 Pod 何時會被認為是 ready 的資訊, 可參考 Container Probes Rollback To.spec.rollbackTo 這個欄位已經在 API 版本 extensions/v1beta1 以及 apps/v1beta1 就被廢棄了, 並且在 apps/v1beta2 已經不再被支援。 取而代之的, kubectl rollout undo, 可參考 Rolling Back to a Previous Revision, 將被使用。 Revision History LimitDeployment 的 revision history 被儲存在它所控制的 ReplicaSet 中。.spec.revisionHistoryLimit 是一個可選配置項, 它指定了舊的 ReplicaSets 的保留數量, 所以之後可以回滾。 這些舊的 ReplicaSets 會消耗 etcd 中的資源, 以及會塞滿 kubectl get rs 的輸出。 Deployment 的不同版本的配置都被儲存在 ReplicaSets, 因此, 一旦舊的 ReplicaSet 被刪除了, 你將無法再回滾到該版本的 Deployment。 預設會保留 10 個舊的 ReplicaSet, 然而最佳的數量取決於新版 Deployment 的頻率以及穩定性更準確的說, 若將這個欄位設為 0, 代表所有舊的 ReplicaSets 都會被清理掉, 所以新版的 Deployment 將無法回退。 Paused.spec.paused 是一個可選配置選項, 其值為 boolean, 它表示了該 Deployment 是否是 paused 的狀態。 狀態是否為 paused 的唯一不同之處在於, 如果我對 PodTemplateSpec 的內容作修改, 那當狀態是 paused 時, 將不會觸發新的 rollout。 Deployment 預設狀態是 not paused Alternative to Deploymentskubectl rolling-updatekubectl rolling-update 可以使用類似的模式更新 Pods 以及 ReplicationControllers, 但還是建議使用 Deployment 的方式, 因為 Deployment 是宣告式的, 並且是 server side 的, 以及有額外的功能, 例如可以回滾到之前的版本。 Q&amp;A Kubernetes 中, kubectl rolling-update 與 Deployment 的方式, 在官方文件中比較推薦使用哪一種？Deployment Kubernetes 中, .spec.paused true 或 false 的唯一不同之處在於？ paused 時, 不會觸發 rollout not paused 時, 會觸發 rollout Kubernetes 中, Old replicaSets 的數量會消耗哪個元件的資源？etcd Kubernetes 中, 不同版本的 Deployment 實際上都儲存在哪裡？ReplicaSets Kubernetes 中, spec.progressDeadlineSeconds 務必要大於哪一個欄位？.spec.minReadySeconds Kubernetes 中, 當 spec.strategy.rollingUpdate.maxUnavailable 的值為 70% 時, 假如算出來的數字非整數, Kubernetes 會怎麼做？無條件去掉小數點成整數 Kubernetes 中, spec.strategy.rollingUpdate.maxUnavailable 與 spec.strategy.rollingUpdate.maxSurge 的值可以同時設為 0 嗎？不可 Kubernetes 中, spec.strategy.rollingUpdate.maxUnavailable 的值可以是哪兩種方式？ 絕對數字 比例 Kubernetes, 當我使用 .spec.strategy.type==Recreate 時, 會怎樣的更新 Pod?先把舊的全都殺掉, 再建立新的 Kubernetes 時, 更新 Pod 預設的 strategy 是？RollingUpdate Kubernetes Deployment 中, .spec.replicas 預設值為多少?1 Kubernetes Deployment 中, .spec.template.spec.restartPolicy 預設值為?Always Kubernetes Deployment 中, .spec.template.spec.restartPolicy 只可設為什麼?Always Kubernetes deployment 中, .spec 中唯一要求哪兩個欄位？ .spec.template .spec.selector Kubernetes 中, 如果我將 .spec.revisionHistoryLimit 的值設為 0, 會發生什麼事？所有 revision history 都會被回收掉, Deployment 會無法回滾 Kubernetes 中, .spec.revisionHistoryLimit 預設的值為多少？10 個 Kubernetes 中, 可使用哪一個欄位來設定要保留的舊的 revision 數量？.spec.revisionHistoryLimit Kubernetes 中, 當我在 progress 途中使用 pause, 會計算 deadline 的時間嗎？不會 Kubernetes 中, 當 ProgressDeadlineExceeded 被觸發, Deployment 除了回報狀況以外, 還會做什麼事情嗎？不會 Kubernetes 中, 如果 Deployment progress 卡住超過指定的 deadline, Deployment controller 會在 DeploymentCondition 屬性中增加什麼內容？ Type=Progressing Status=False Reason=ProgressDeadlineExceeded Kubernetes 中, 如果 Deployment progress 卡住超過指定的 deadline, Deployment controller 會在什麼地方增加一個 DeploymentCondition 屬性？.status.conditions Kubernetes 中, 哪一個屬性可以決定 process 卡住之後多久會回報異常？.spec.progressDeadlineSeconds Kubernetes 中, 如何使用 CLI 來設定資源限制kubectl set resources deployment/deploymentName -c=nginx --limits=cpu=200m,memory=512Mi Kubernetes 中, 如何 resume 一個 deployment?kubectl rollout resume deployment/deploymentName Kubernetes 中, 如何 pause 一個 deployment?kubectl rollout pause deployment/deploymentName Kubernetes 中, 如果我 pause 一個 Deployment, 那它還會保持運作嗎？會哦, 只是會鎖住目前的版本而已 Kubernetes 中, 當我暫停一個 Deployment 時, 我可以回滾它嗎？不行哦 Kubernetes 中, pause 跟 resume 可以帶來什麼好處？有時要進行多個修正時, 可以避免不必要的 rollout Kubernetes 當中, 假如現在正 rollout 到一半, 這時有新的擴容需求被呼叫, 那如果我有使用 proportional scaling 的話, 新的 replica 會被加到新的 replicaSet 還是舊的 replicaSet?會照比例分配, 擁有多個 replica 的 replicaSet 會被分配多組, 反之亦然 Kubernetes 當中, 假如現在正 rollout 到一半, 這時有新的擴容需求被呼叫, 那如果我沒有使用 proportional scaling 的話, 新的 replica 會被加到新的 replicaSet 還是舊的 replicaSet?新的 以下的 Kubernetes CLI 的意思是？ CLIkubectl autoscale deployment.v1.apps/nginx-deployment --min=10 --max=15 --cpu-percent=80 Answer: 最少 10 個 pod 最多 15 個 pod 當 CPU 使用超過 80% 時, 多開一個 Pod Kubernetes 中, 假如我要指定自動擴縮 Deployment 的範圍以及 CPU 使用率, 我可以怎麼做？kubectl autoscale deployment/deploymentName --min=10 --max=15 --cpu-percent=80 Kubernetes 中, 假如我現在要擴縮指定 Deployment 到 10 個 replica, 我可以怎麼做？kubectl scale deployment/deploymentName --replicas=replicasNumber Kubernetes 中, 如果我要放棄目前的版本回滾到一個指定的版本, 我可以怎麼做？kubectl rollout undo deployment/deploymentName --to-revision=revisionName Kubernetes 中, 如果我要放棄目前的版本回滾到前一個版本, 我可以怎麼做？kubectl rollout undo deployment/deploymentName Kubernetes 中, 如果我要檢視指定 revision 的細節資訊, 我可以怎麼做？kubectl rollout history deployment/deploymentName --revision=revisionName Kubernetes 中, 有哪三種方法可以指定 CHANGE-CAUSE message? 藉由 kubectl annotate 指令 變更資源時, 加入 --record flag 手動變更 Kubernetes 中, 當我回滾到之前的版本, 會否對 replica 的期望數量有影響？不會, rolling back 只會影響到 spec.template 中的內容 Kubernetes 中, Deployment revision 唯有當什麼情況之下才會被建立？當 spec.template 中的內容有變更時 Kubernetes 中, 自 apps/v1 的版本後, Deployment 的 label selector 在建立後可以再變更嗎？不行 Kubernetes 中, 在滾動升級的過程中, 如果新的 Deployment 還沒完成擴容我就更新了這個 Deployment, 那 Deployment controller 會等到原本的擴容任務完成之後再開始新的任務嗎？不會, 會立即縮減舊的, 擴容新的 Kubernetes 中, 當 Deployment 被更新了, 新的 ReplicaSet 會被建立來提供期望的 Pods 數量, 那 Kubernetes 是如何判斷舊的 ReplicaSet?label 符合 .spec.selector 但 .spec.template 不符合 Kubernetes 中, 在滾動升級的過程中, Deployment 建立新的 Pod 以及刪除舊的 Pod 的模式是？確保不可用以及可用的 Pod 都處於指定的範圍之內, 它不會等到新的 Pod 都建好才去砍舊的, 也不會等到舊的 Pod 都砍完才去建新的 Kubernetes 中, 預設最多幾 % 的期望 Pod 數量可以處於運行中？125% Kubernetes 中, 當實施滾動升級時, 預設最多可以有幾% 的 Pod 不可用？25% Kubernetes 中, 當實施滾動升級時, 預設至少會保持幾 % 的 Pods 運行？75% Kubernetes 中, 當 rollout 被觸發, Deployment 是透過建立一個新的什麼資源來建立新的 Pod?ReplicaSet Kubernetes 中, 如果我要利用 kubectl CLI 來更新指定鏡像的版本, 我可以使用哪一個指令？ kubectl set image deployment/deploymentName containerName=imageName:tagName --record Kubernetes 中, Deployment 的 rollout 唯有在什麼情況下會被觸發？當 .spec.template 的內容變了 Kubernetes 中, pod-template-hash 是由 hash 哪一個 field 得來的？PodTemplate Kubernetes 中, pod-template-hash 的用途是？確保一個 Deployment 建立的 ReplicaSet 不會重疊 Kubernetes 中, pod-template-hash 是由誰加到 ReplicaSet 上的？Deployment Controller Kubernetes 中, pod-template-hash 可以被變更嗎？不可 Kubernetes 中, 當我們在定義 labels 以及 selectors 時, 務必要注意什麼？ 否則會造成衝突以及預期外的行為不可讓 labels 或 selectors 在多個 controller 之間互相重疊 Kubernetes 中, 如果要檢視每個 pod 自動產生的 labels, 可以使用哪一個 kubectl 指令？kubectl get pods --show-labels Kubernetes 中, ReplicaSet 的命名格式為？[DEPLOYMENT-NAME]-[RANDOM-STRING] Kubernetes 中, 如果要透過 CLI 取得 ReplicaSet, 可以使用哪一個 kubectl command?kubectl get rs Kubernetes 中, rs 是哪一個資源的縮寫？ReplicaSet Kubernetes 中, 要如何查看 rollout status?kubectl rollout status deployment deploymentName Kubernetes 中, 當我在建立資源時加上了 --record flag, 我要怎樣才可以看到運行的 command 的紀錄？ kubectl describe resource resourceName Kubernetes 中, 如果我想要之後使用 kubectl describe 時都可以看到該 resource 之前執行過什麼執行, 那我可以在建立該 resource 時加上哪一個 flag?--record Kubernetes 中, matchExpressions field 的 operator Lt 代表的意思是？該 label 的 value 需小於指定值 Kubernetes 中, matchExpressions field 的 operator Gt 代表的意思是？該 label 的 value 需大於指定值 Kubernetes 中, matchExpressions field 的 operator DoesNotExist 代表的意思是？該 label key 有存在的都算 Kubernetes 中, matchExpressions field 的 operator Exist 代表的意思是？該 label key 有存在的都算 Kubernetes 中, matchExpressions field 的 operator NotIn 代表的意思是？該 label 的 value 需不存在於指定的 array list 當中 Kubernetes 中, matchExpressions field 的 operator In 代表的意思是？該 label 的 value 需存在於指定的 array list 當中 Kubernetes 中, matchLabels field 代表？一對 key/value pair Kubernetes 中, matchExpressions field 有哪幾個 operator？ In NotIn Exists DoesNotExist Lt Gt","link":"/zh-tw/kubernetes-workloads-controllers-deployments/"},{"title":"Laravel - Database - Migrations","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Generating Migrations以下的 Laravel example command 的意思是？ Example:php artisan make:migration create_users_table --create=usersphp artisan make:migration add_votes_to_users_table --table=users Answer:// 建立 migration, 並建立且對應 table usersphp artisan make:migration create_users_table --create=users// 建立 migration, 並指定對應 table 為 usersphp artisan make:migration add_votes_to_users_table --table=users Squashing Migrations以下的 Laravel example command 的意思是？ Example:php artisan schema:dumpphp artisan schema:dump --prune Answer:// 將所有的 migrations file 輸出成一個 SQL filephp artisan schema:dump// 將所有的 migrations file 輸出成一個 SQL file, 並刪除 migrations filephp artisan schema:dump --prune Migration Structure以下的 Laravel Example code 的意思是？ Example:&lt;?phpclass CreateFlightsTable extends Migration&#123; public function up() &#123; Schema::create(&#x27;flights&#x27;, function (Blueprint $table) &#123; $table-&gt;id(); $table-&gt;string(&#x27;name&#x27;); $table-&gt;string(&#x27;airline&#x27;); $table-&gt;timestamps(); &#125;); &#125; public function down() &#123; Schema::drop(&#x27;flights&#x27;); &#125;&#125; Answer:&lt;?phpclass CreateFlightsTable extends Migration&#123; // up() 內為 migration 主要執行的動作 public function up() &#123; Schema::create(&#x27;flights&#x27;, function (Blueprint $table) &#123; $table-&gt;id(); $table-&gt;string(&#x27;name&#x27;); $table-&gt;string(&#x27;airline&#x27;); $table-&gt;timestamps(); &#125;); &#125; // down() 內為與 up() 相反的執行動作 public function down() &#123; Schema::drop(&#x27;flights&#x27;); &#125; Running MigrationsForcing Migrations To Run In Production以下的 Laravel example command 的意思是？ Example:php artisan migrate --force Answer:在 production 環境中, 要執行 migrate 會跳出確認視窗, 如果使用 –force 就可以跳過 Rolling Back Migrations以下的 Laravel example command 的意思是？ Example:php artisan migrate:rollback Answer:回滾上一個 batch 的 migrations, 也就是執行 migration class 中 down() 內的動作, 可能會有多個 migrations 檔案 以下的 Laravel example command 的意思是？ Example:php artisan migrate:rollback --step=5 Answer:預設 rollback 會回滾上一個 batch 的 migrations, –step flag 可以指定 migrations file 的數量 以下的 Laravel example command 的意思是？ Example:php artisan migrate:reset Answer:回滾所有的 migrations Roll Back &amp; Migrate Using A Single Command以下的 Laravel example command 的意思是？ Example:php artisan migrate:refresh// Refresh the database and run all database seeds...php artisan migrate:refresh --seed Answer:// rollback 所有的 migrations, 並且再 migrate 他們php artisan migrate:refresh// rollback 所有的 migrations, 並且再 migrate 他們, 並執行 seedphp artisan migrate:refresh --seed 以下的 Laravel example command 的意思是？ Example:php artisan migrate:refresh --step=5 Answer:預設會 rollback 並 migrate 所有的 migrations, –step flag 可以指定 migrations 數量 Drop All Tables &amp; Migrate以下的 Laravel example command 的意思是？ Example:php artisan migrate:freshphp artisan migrate:fresh --seed Answer:// drop 所有的 table, 而並非執行 &quot;down()&quot; 內的動作, 然後再 migratephp artisan migrate:fresh// drop 所有的 table, 而並非執行 &quot;down()&quot; 內的動作, 然後再 migrate, 並執行 seedphp artisan migrate:fresh --seed TablesCreating Tables以下的 Laravel example command 的意思是？ Example:&lt;?phpSchema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;id();&#125;); Answer:建立一個名為 users 的 table, column 為 id Checking For Table / Column Existence以下的 Laravel example command 的意思是？ Example:&lt;?phpif (Schema::hasTable(&#x27;users&#x27;)) &#123; //&#125;if (Schema::hasColumn(&#x27;users&#x27;, &#x27;email&#x27;)) &#123; //&#125; Answer:&lt;?php// 判斷是否有 users 這個 tableif (Schema::hasTable(&#x27;users&#x27;)) &#123; //&#125;// 判斷 users table 中是否有 email 這個 columnif (Schema::hasColumn(&#x27;users&#x27;, &#x27;email&#x27;)) &#123; //&#125; Database Connection &amp; Table Options以下的 Laravel Migration example command 的意思是？ Example:&lt;?phpSchema::connection(&#x27;foo&#x27;)-&gt;create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;id();&#125;); Answer:指定在 foo 這個 database 中建立 users table 以下的 Laravel Migration example command 的意思是？ Example:&lt;?php$table-&gt;engine = &#x27;InnoDB&#x27;;$table-&gt;charset = &#x27;utf8mb4&#x27;;$table-&gt;collation = &#x27;utf8mb4_unicode_ci&#x27;;$table-&gt;temporary(); Answer:&lt;?php// 指定 table 的 storage engine$table-&gt;engine = &#x27;InnoDB&#x27;;// 指定 character set$table-&gt;charset = &#x27;utf8mb4&#x27;;// 指定 collation$table-&gt;collation = &#x27;utf8mb4_unicode_ci&#x27;;// 建立臨時 table$table-&gt;temporary(); Renaming / Dropping Tables以下的 Laravel Migration example command 的意思是？ Example:&lt;?phpSchema::rename($from, $to); Answer:重命名 table 以下的 Laravel Migration example command 的意思是？ Example:&lt;?phpSchema::drop(&#x27;users&#x27;);Schema::dropIfExists(&#x27;users&#x27;); Answer:&lt;?php// drop users tableSchema::drop(&#x27;users&#x27;);// 如果 users table 存在, drop itSchema::dropIfExists(&#x27;users&#x27;); ColumnsModifying Columns以下的 Laravel Migration example code 的意思是？ Example:&lt;?phpSchema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;string(&#x27;name&#x27;, 50)-&gt;nullable()-&gt;change();&#125;); Answer:變更欄位為 ‘name’ 的 column type, 變更為 50 characters, 變且新增 nullable type 以下的 Laravel Migration example code 的意思是？ Example:&lt;?phpSchema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;renameColumn(&#x27;from&#x27;, &#x27;to&#x27;);&#125;); Answer:變更 column 的名稱 Laravel 中, 支援 rename enum 欄位嗎？不支援 Dropping Columns以下的 Laravel Migration example code 的意思是？ Example:&lt;?phpSchema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;dropColumn([&#x27;votes&#x27;, &#x27;avatar&#x27;, &#x27;location&#x27;]);&#125;); Answer:drop 複數 column 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropMorphs(&#x27;morphable&#x27;); Answer:drop morphable_id 以及 morphable_type column 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropSoftDeletes(); Answer:drop deleted_at column 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropTimestamps(); Answer:drop created_at 以及 updated_at column IndexesCreating Indexes以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;string(&#x27;email&#x27;)-&gt;unique(); Answer:建立 ‘email’ column 並增加 unique type 以下的 Laravel Migration example code 的意思是？ Example:&lt;?phppublic function boot()&#123; Schema::defaultStringLength(191);&#125; Answer:指定 migration 產生的 default string length, 所以 MySQL 可以產生索引, 若 MySQL 版本 older than 5.7.7, 需手動指定, 否則可能會出現 &quot;SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes&quot; (SQL: alter table usersadd uniqueusers_email_unique(email)) exception Renaming Indexes以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;renameIndex(&#x27;from&#x27;, &#x27;to&#x27;) Answer:重新命名 index Dropping Indexes以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropPrimary(&#x27;users_id_primary&#x27;); Answer:去掉 primary key 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropUnique(&#x27;users_email_unique&#x27;); Answer:去掉 unique key 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropIndex(&#x27;geo_state_index&#x27;); Answer:去掉 index 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropSpatialIndex(&#x27;geo_location_spatialindex&#x27;); Answer:去掉 spatial index 以下的 Laravel Migration example code 中, 被 drop 的 index name 是什麼？ Example:&lt;?phpSchema::table(&#x27;geo&#x27;, function (Blueprint $table) &#123; $table-&gt;dropIndex([&#x27;state&#x27;]); // Drops index &#x27;geo_state_index&#x27;&#125;); Answer:geo_state_index Foreign Key Constraints以下的 Laravel Migration example code 的意思是？ Example:&lt;?phpSchema::table(&#x27;posts&#x27;, function (Blueprint $table) &#123; $table-&gt;unsignedBigInteger(&#x27;user_id&#x27;); $table-&gt;foreign(&#x27;user_id&#x27;)-&gt;references(&#x27;id&#x27;)-&gt;on(&#x27;users&#x27;);&#125;); Answer:定義一個 foreign key user_id, reference users table 的 id column, 如果該 users table 的 id 不存在, 那該筆資料就無法被建立 以下的 Laravel Migration example code 的意思是？ Example:&lt;?phpSchema::table(&#x27;posts&#x27;, function (Blueprint $table) &#123; $table-&gt;foreignId(&#x27;user_id&#x27;)-&gt;constrained();&#125;); Answer:foreignId 為 unsignedBigInteger 的 alias, constrained 會自動 reference users table 的 id column, 如果 reference 的 table 不是 users, 那可以在 constrained method 中帶入 argument 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;foreignId(&#x27;user_id&#x27;) -&gt;constrained() -&gt;onDelete(&#x27;cascade&#x27;); Answer:當該 user 被 delete 時, 會連帶 delete 有 reference 的 foreign key column 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropForeign(&#x27;posts_user_id_foreign&#x27;); Answer:從 posts table 中的 user_id column, drop foreign key index 以下的 Laravel Migration example code 的意思是？ Example:&lt;?php$table-&gt;dropForeign([&#x27;user_id&#x27;]); Answer:將 column name 包在 array 中, Laravel 會依照 constraint name convention 去尋找並 drop foreign key index 以下的 Laravel Migration example code 的意思是？ Example:&lt;?phpSchema::enableForeignKeyConstraints();Schema::disableForeignKeyConstraints(); Answer:啟用或關閉 foreignKeyConstraints 功能, 有些資料庫默認是關閉的, 如 SQLite, 若要使用須先打開才行 # Additional以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function up()&#123; Schema::table(&#x27;orders&#x27;, function (Blueprint $table) &#123; $table-&gt;unsignedBigInteger(&#x27;coupon_code_id&#x27;)-&gt;nullable()-&gt;after(&#x27;paid_at&#x27;); $table-&gt;foreign(&#x27;coupon_code_id&#x27;)-&gt;references(&#x27;id&#x27;)-&gt;on(&#x27;coupon_codes&#x27;)-&gt;onDelete(&#x27;set null&#x27;); &#125;);&#125; Answer:當 coupon 被刪除, 就將 orders table 中的 coupon_code_id 設為 null","link":"/zh-tw/laravel-database-migrations/"},{"title":"Laravel - Database - Redis (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # IntroductionLaravel 文件上推薦使用 PhpRedis 或 predis?PhpRedis # Configuration以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;redis&#x27; =&gt; [ &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;phpredis&#x27;), &#x27;default&#x27; =&gt; [ &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), &#x27;database&#x27; =&gt; env(&#x27;REDIS_DB&#x27;, 0), ], &#x27;cache&#x27; =&gt; [ &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), &#x27;database&#x27; =&gt; env(&#x27;REDIS_CACHE_DB&#x27;, 1), ],], Answer:&lt;?php&#x27;redis&#x27; =&gt; [ // 使用的 redis client, 預設 phpredis &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;phpredis&#x27;), &#x27;default&#x27; =&gt; [ // host, 預設 127.0.0.1 &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), // password, 預設 null &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), // port, 預設 6379 &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), // database, 預設 0 &#x27;database&#x27; =&gt; env(&#x27;REDIS_DB&#x27;, 0), ], &#x27;cache&#x27; =&gt; [ &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), &#x27;database&#x27; =&gt; env(&#x27;REDIS_CACHE_DB&#x27;, 1), ],], 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;redis&#x27; =&gt; [ &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;phpredis&#x27;), &#x27;default&#x27; =&gt; [ &#x27;url&#x27; =&gt; &#x27;tcp://127.0.0.1:6379?database=0&#x27;, ], &#x27;cache&#x27; =&gt; [ &#x27;url&#x27; =&gt; &#x27;tls://user:password@127.0.0.1:6380?database=1&#x27;, ],], Answer:預設會需要定義 host, password, port, database, 可用 url 方式定義全部 # Configuring The Connection Scheme以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;redis&#x27; =&gt; [ &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;phpredis&#x27;), &#x27;default&#x27; =&gt; [ // 這行意思是？ &#x27;scheme&#x27; =&gt; &#x27;tls&#x27;, &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;127.0.0.1&#x27;), &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), &#x27;database&#x27; =&gt; env(&#x27;REDIS_DB&#x27;, 0), ],], Answer:預設使用 tcp 方式, 可自訂為 TLS # Clusters以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;redis&#x27; =&gt; [ &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;phpredis&#x27;), // 這行意思是？ &#x27;clusters&#x27; =&gt; [ &#x27;default&#x27; =&gt; [ [ &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;localhost&#x27;), &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), &#x27;database&#x27; =&gt; 0, ], ], ],], Answer:如果使用 Redis Cluster 的話, 需定義於 ‘clusters’ 參數之下 以下的 Laravel example code 的意思是？ Example:&lt;?php// 在 config/database.php&#x27;redis&#x27; =&gt; [ &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;phpredis&#x27;), &#x27;options&#x27; =&gt; [ &#x27;cluster&#x27; =&gt; env(&#x27;REDIS_CLUSTER&#x27;, &#x27;redis&#x27;), ], &#x27;clusters&#x27; =&gt; [ // ... ],],// 在 .envREDIS_CLUSTER=redis Answer:Laravel 預設 cluster redis 會使用 client-side sharding, 若希望使用 native redis cluster, 可將 options.cluster 的 value 設為 redis # Predis以下的 Laravel example code 的意思是？ Example:&lt;?php// 在 config/database.php&#x27;redis&#x27; =&gt; [ &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;predis&#x27;), // Rest of Redis configuration...], Answer:指定 redis client, 預設是 phpredis, 若要使用 predis, 需特別指定 env 當使用 Laravel predis 時, 除了以下的預設 setting, 還可以設定額外的 setting 嗎？ Example:&lt;?php&#x27;default&#x27; =&gt; [ &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;localhost&#x27;), &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), &#x27;database&#x27; =&gt; 0, &#x27;read_write_timeout&#x27; =&gt; 60,], Answer:可, 官方文件 Laravel 中, 為何在 config/app.php 當中, alias array 中, redis 是被 disable 的？ Example:&lt;?php&#x27;Queue&#x27; =&gt; Illuminate\\Support\\Facades\\Queue::class,&#x27;Redirect&#x27; =&gt; Illuminate\\Support\\Facades\\Redirect::class,// &#x27;Redis&#x27; =&gt; Illuminate\\Support\\Facades\\Redis::class,&#x27;Request&#x27; =&gt; Illuminate\\Support\\Facades\\Request::class,&#x27;Response&#x27; =&gt; Illuminate\\Support\\Facades\\Response::class, Answer:因為 Redis alias 會跟 phpredis extension 提供的 class name 衝突, 因此如果使用 phpredis 時是 disable 的, 但如果使用 predis 時, 可以 uncomment # PhpRedis以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;redis&#x27; =&gt; [ &#x27;client&#x27; =&gt; env(&#x27;REDIS_CLIENT&#x27;, &#x27;phpredis&#x27;), // Rest of Redis configuration...],// .env REDIS_CLIENT=phpredis Answer:Laravel 預設使用 Phpredis extension 來跟 Redis 溝通 以下的 Laravel example code 的意思是？ Example:&lt;?php// phpredis&#x27;default&#x27; =&gt; [ &#x27;host&#x27; =&gt; env(&#x27;REDIS_HOST&#x27;, &#x27;localhost&#x27;), &#x27;password&#x27; =&gt; env(&#x27;REDIS_PASSWORD&#x27;, null), &#x27;port&#x27; =&gt; env(&#x27;REDIS_PORT&#x27;, 6379), &#x27;database&#x27; =&gt; 0, &#x27;read_timeout&#x27; =&gt; 60, &#x27;context&#x27; =&gt; [ // &#x27;auth&#x27; =&gt; [&#x27;username&#x27;, &#x27;secret&#x27;], // &#x27;stream&#x27; =&gt; [&#x27;verify_peer&#x27; =&gt; false], ],], Answer:phpredis 也有提供一些額外的 parameter 可以設定 # Interacting With Redis以下的 Laravel example code 的意思是？ Example:&lt;?phpclass UserController extends Controller&#123; public function show($id) &#123; return view(&#x27;user.profile&#x27;, [ &#x27;user&#x27; =&gt; Redis::get(&#x27;user:profile:&#x27;.$id) ]); &#125;&#125; Answer:使用 redis 的 get command, 取得指定的 key 的 value 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Redis;Redis::set(&#x27;name&#x27;, &#x27;Taylor&#x27;);$values = Redis::lrange(&#x27;names&#x27;, 5, 10); Answer:set key / value 為 name / Taylor取得 range between 5, 10 的 value, 0 代表第一個位置, 1 代表第二個位置, -1 代表倒數第一個位置, -2 代表倒數第二個位置, 若是超出範圍, 則代表最後一個位置, 比如 總共只有 10 個 item, range 10 會等於第十個位置, range -100 會等於第一個位置 # Pipelining Commands以下的 Laravel example code 的意思是？ Example:&lt;?php$values = Redis::command(&#x27;lrange&#x27;, [&#x27;name&#x27;, 5, 10]); Answer:使用 command method, 直接 pass command name 給 redis server, 同 Redis::lrange() # Using Multiple Redis Connections以下的 Laravel example code 的意思是？ Example:&lt;?php$redis = Redis::connection();$redis = Redis::connection(&#x27;connection-name&#x27;); Answer:取得 redis 預設 connection取得 redis 指定名為 &#39;connection-name&#39; 的 connection # Transactions以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Redis;Redis::transaction(function ($redis) &#123; $redis-&gt;incr(&#x27;user_visits&#x27;, 1); $redis-&gt;incr(&#x27;total_visits&#x27;, 1);&#125;); Answer:使用 redis 的 transaction feature, 所有的 command 會一次性執行, 所以無法在 transaction 的過程中取值 # Lua Script以下的 Laravel example code 的意思是？ Example:&lt;?php$value = Redis::eval(&lt;&lt;&lt;&#x27;LUA&#x27; local counter = redis.call(&quot;incr&quot;, KEYS[1]) if counter &gt; 5 then redis.call(&quot;incr&quot;, KEYS[2]) end return counterLUA, 2, &#x27;first-counter&#x27;, &#x27;second-counter&#x27;); Answer:使用 eval 執行 redis script, 既有 transaction 的 atomic 特性, 又可以在過程中可以與 redis 互動arg1 為 lua script, arg2 為 key 的數量, arg3 為 key1, arg4 為 key2, 在往後可以帶入任何會在 script 內用到的變數 # Pipelining Commands以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Redis;Redis::pipeline(function ($pipe) &#123; for ($i = 0; $i &lt; 1000; $i++) &#123; $pipe-&gt;set(&quot;key:$i&quot;, $i); &#125;&#125;); Answer:當需要執行複數的 redis command 時, 可以使用 pipeline method, 只經由一次的 connection 將多個 command 送到 redis server, closure 內的 command 會按照順序執行如果沒使用 pipeline, 多個 command 會建立多次 connection # Pub / Sub以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Console\\Commands;use Illuminate\\Console\\Command;use Illuminate\\Support\\Facades\\Redis;class RedisSubscribe extends Command&#123; protected $signature = &#x27;redis:subscribe&#x27;; protected $description = &#x27;Subscribe to a Redis channel&#x27;; public function handle() &#123; Redis::subscribe([&#x27;test-channel&#x27;], function ($message) &#123; echo $message; &#125;); &#125;&#125;// in Routeuse Illuminate\\Support\\Facades\\Redis;Route::get(&#x27;/publish&#x27;, function () &#123; // ... Redis::publish(&#x27;test-channel&#x27;, json_encode([ &#x27;name&#x27; =&gt; &#x27;Adam Wathan&#x27; ]));&#125;); Answer:使用 redis pub/sub feature, 可使用 Laravel subscribe 一個 channel, 而用其他的應用 publish 到這個 channel # Wildcard Subscriptions以下的 Laravel example code 的意思是？ Example:&lt;?phpRedis::psubscribe([&#x27;*&#x27;], function ($message, $channel) &#123; echo $message;&#125;);Redis::psubscribe([&#x27;users.*&#x27;], function ($message, $channel) &#123; echo $message;&#125;); Answer:使用 psubscribe method, 可以 subscribe wildcard channels","link":"/zh-tw/laravel-database-redis/"},{"title":"Laravel - Database - Query Builder (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Retrieving Results# Retrieving All Rows From A Table以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Support\\Facades\\DB;class UserController extends Controller&#123; public function index() &#123; $users = DB::table(&#x27;users&#x27;)-&gt;get(); return view(&#x27;user.index&#x27;, [&#x27;users&#x27; =&gt; $users]); &#125;&#125; Answer:取得 users table 中所有的 records, 並將資料帶到 ‘views/user/index’ page # Retrieving A Single Row / Column From A Table以下的 Laravel example code 的意思是？ Example:&lt;?php$email = DB::table(&#x27;users&#x27;)-&gt;where(&#x27;name&#x27;, &#x27;John&#x27;)-&gt;value(&#x27;email&#x27;); Answer:只取得符合 where(‘name’, ‘John’) 條件的眾多 user model 中, 第一個 model 中的 ‘email’ column 的值 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = DB::table(&#x27;users&#x27;)-&gt;where(&#x27;name&#x27;, &#x27;John&#x27;)-&gt;first();echo $user-&gt;name; Answer:從 Query Builder 的結果, collection of models 中, 回傳第一個 model # Retrieving A List Of Column Values以下的 Laravel example code 的意思是？ Example:&lt;?php$titles = DB::table(&#x27;roles&#x27;)-&gt;pluck(&#x27;title&#x27;);foreach ($titles as $title) &#123; echo $title;&#125; Answer:取得 roles collection 中的 title column data # Chunking Results以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;orderBy(&#x27;id&#x27;)-&gt;chunk(100, function ($users) &#123; // Process the records... return false;&#125;); Answer:return false 終止 chunk 以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;where(&#x27;active&#x27;, false) -&gt;chunkById(100, function ($users) &#123; foreach ($users as $user) &#123; DB::table(&#x27;users&#x27;) -&gt;where(&#x27;id&#x27;, $user-&gt;id) -&gt;update([&#x27;active&#x27; =&gt; true]); &#125; &#125;); Answer:chunkById 預設會使用 orderBy id, 並且會記住上一個 chunk 的 last id效能上使用 chunkById 更好, 因為 chunk 是採用 offset … limit, 這樣當資料越來越多的時候, 會造成不必要的效能浪費, 而 chunkById 是採用 where id &gt; $lastId, 因為效能上較佳再者, 因為 chunkById 預設會 orderby id, 所以不會有 chunk 跟 chunk 之間因為順序錯亂而丟失 item 的情況 # Aggregates以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;count(); Answer:取得 users table 中總共的資料筆數 以下的 Laravel example code 的意思是？ Example:&lt;?php$price = DB::table(&#x27;orders&#x27;)-&gt;max(&#x27;price&#x27;); Answer:可得 orders table 中, price column value 最大的那筆資料 # Determining If Records Exist以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn DB::table(&#x27;orders&#x27;)-&gt;where(&#x27;finalized&#x27;, 1)-&gt;exists();return DB::table(&#x27;orders&#x27;)-&gt;where(&#x27;finalized&#x27;, 1)-&gt;doesntExist(); Answer:判斷該 model 是否存在, return boolean # Selects# Specifying A Select Clause以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;select(&#x27;name&#x27;, &#x27;email as user_email&#x27;)-&gt;get(); Answer:只取得 &#39;name&#39;, &#39;email&#39; as user_email 這兩個欄位 以下的 Laravel example code 的意思是？ Example:&lt;?php$query = DB::table(&#x27;users&#x27;)-&gt;select(&#x27;name&#x27;);$users = $query-&gt;addSelect(&#x27;age&#x27;)-&gt;get(); Answer:使用 addSelect(), 在原本既存的 $query 多 select 一個 column # Raw Expressions以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;select(DB::raw(&#x27;count(*) as user_count, status&#x27;)) -&gt;where(&#x27;status&#x27;, &#x27;&lt;&gt;&#x27;, 1) -&gt;groupBy(&#x27;status&#x27;) -&gt;get(); Answer:使用 DB::row(), 裡頭直接帶入 DB raw 語法 以下的 Laravel example code 的意思是？ Example:&lt;?php$orders = DB::table(&#x27;orders&#x27;) -&gt;selectRaw(&#x27;price * ? as price_with_tax&#x27;, [1.0825]) -&gt;get(); Answer:若要使用 select 的 mysql raw 語法, 可使用 selectRaw() 以下的 Laravel example code 的意思是？ Example:&lt;?php$orders = DB::table(&#x27;orders&#x27;) -&gt;whereRaw(&#x27;price &gt; IF(state = &quot;TX&quot;, ?, 100)&#x27;, [200]) -&gt;get(); Answer:使用 MySQL whereRaw expression, price &gt; (如果 state = &quot;TX&quot;, 那就是 200, 否則就是 100) 以下的 Laravel example code 的意思是? Example:&lt;?php$orders = DB::table(&#x27;orders&#x27;) -&gt;orderByRaw(&#x27;updated_at - created_at DESC&#x27;) -&gt;get(); Answer:使用 orderByRaw 取得 update_at 減掉 created_at 的時間, 再以這個時間排序 以下的 Laravel example code 的意思是？ Example:&lt;?php$orders = DB::table(&#x27;orders&#x27;) -&gt;select(&#x27;city&#x27;, &#x27;state&#x27;) -&gt;groupByRaw(&#x27;city, state&#x27;) -&gt;get(); Answer:若要使用 raw group by constraint, 可使用 groupByRaw() # Joins# Inner Join Clause以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;join(&#x27;contacts&#x27;, &#x27;users.id&#x27;, &#x27;=&#x27;, &#x27;contacts.user_id&#x27;) -&gt;join(&#x27;orders&#x27;, &#x27;users.id&#x27;, &#x27;=&#x27;, &#x27;orders.user_id&#x27;) -&gt;select(&#x27;users.*&#x27;, &#x27;contacts.phone&#x27;, &#x27;orders.price&#x27;) -&gt;get(); Answer:使用 join 取得多張 table 資料 # Left Join / Right Join Clause以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;leftJoin(&#x27;posts&#x27;, &#x27;users.id&#x27;, &#x27;=&#x27;, &#x27;posts.user_id&#x27;) -&gt;get(); Answer:leftJoin Posts table, 因為是 left join, 會將 Users table 全部列出, 以及與之相關的 Posts records, 若該 User record 並無相關的 Post record, Post 的 record 會以 null 顯示 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;rightJoin(&#x27;posts&#x27;, &#x27;users.id&#x27;, &#x27;=&#x27;, &#x27;posts.user_id&#x27;) -&gt;get(); Answer:若要 rightJoin, 可使用 rightJoin(), 會取得 posts table 上所有的欄位, 包括 posts.user_id 為 null 的欄位也會取出 # Cross Join Clause以下的 Laravel example code 的意思是？ Example:&lt;?php$sizes = DB::table(&#x27;sizes&#x27;) -&gt;crossJoin(&#x27;colors&#x27;) -&gt;get(); Answer:cross join colors table如果沒有 where constraints, cross join 會回傳兩張表的乘積 # Advanced Join Clauses以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;) -&gt;join(&#x27;contacts&#x27;, function ($join) &#123; $join-&gt;on(&#x27;users.id&#x27;, &#x27;=&#x27;, &#x27;contacts.user_id&#x27;)-&gt;orOn(...); &#125;) -&gt;get(); Answer:join contacts table, 在 closure 內可定義比較複雜的 join 條件 以下的 Laravel example code 的意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;) -&gt;join(&#x27;contacts&#x27;, function ($join) &#123; $join-&gt;on(&#x27;users.id&#x27;, &#x27;=&#x27;, &#x27;contacts.user_id&#x27;) -&gt;where(&#x27;contacts.user_id&#x27;, &#x27;&gt;&#x27;, 5); &#125;) -&gt;get(); Answer:join 並且附加額外的 where clause # Subquery Joins以下的 Laravel example code 的意思是？ Example:&lt;?php$latestPosts = DB::table(&#x27;posts&#x27;) -&gt;select(&#x27;user_id&#x27;, DB::raw(&#x27;MAX(created_at) as last_post_created_at&#x27;)) -&gt;where(&#x27;is_published&#x27;, true) -&gt;groupBy(&#x27;user_id&#x27;);$users = DB::table(&#x27;users&#x27;) -&gt;joinSub($latestPosts, &#x27;latest_posts&#x27;, function ($join) &#123; $join-&gt;on(&#x27;users.id&#x27;, &#x27;=&#x27;, &#x27;latest_posts.user_id&#x27;); &#125;)-&gt;get(); Answer:使用 joinSub() join $latestPosts 這個 subquery, arg1 為 subquery, arg2 定義 subquery 的 table alias # Unions以下的 Laravel example code 的意思是？ Example:&lt;?php$first = DB::table(&#x27;users&#x27;) -&gt;whereNull(&#x27;first_name&#x27;);$users = DB::table(&#x27;users&#x27;) -&gt;whereNull(&#x27;last_name&#x27;) -&gt;union($first) -&gt;get(); Answer:使用 union 一次取出兩個 query 不重複的資料 # Where Clauses# Simple Where ClausesLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;=&#x27;, 100)-&gt;get(); Answer:從 users table 當中 query 出 votes column 的值等於 100 的 records Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, 100)-&gt;get(); Answer:從 users table 當中 query 出 votes column 的值等於 100 的 records Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;where([ [&#x27;status&#x27;, &#x27;=&#x27;, &#x27;1&#x27;], [&#x27;subscribed&#x27;, &#x27;&lt;&gt;&#x27;, &#x27;1&#x27;],])-&gt;get(); Answer:相當於 where(‘status’, ‘=’, ‘1’)-&gt;where(‘subscribed’, ‘&lt;&gt;’, ‘1’) # Or StatementsLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100) -&gt;orWhere(&#x27;name&#x27;, &#x27;John&#x27;) -&gt;get(); Answer:取得第一個 where clause 或 第二個 where clause 的 query 結果, 簡單來說, 誰找到的都算數 # Or StatementsLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100) -&gt;orWhere(function($query) &#123; $query-&gt;where(&#x27;name&#x27;, &#x27;Abigail&#x27;) -&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 50); &#125;) -&gt;get(); Answer:// SQL: select * from users where votes &gt; 100 or (name = ‘Abigail’ and votes &gt; 50) # Additional Where ClausesLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereBetween(&#x27;votes&#x27;, [1, 100]) -&gt;get(); Answer:query column votes 介於 1~100 的 records Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereNotBetween(&#x27;votes&#x27;, [1, 100]) -&gt;get(); Answer:query column votes 不介於 1~100 的 records Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereIn(&#x27;id&#x27;, [1, 2, 3]) -&gt;get(); Answer:query records, 其 id column 的 value 為 array 中其中一個值 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereNotIn(&#x27;id&#x27;, [1, 2, 3]) -&gt;get(); Answer:query records, 其 id column 的 value 不為 array 中的任何一個值 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereNull(&#x27;updated_at&#x27;) -&gt;get(); Answer:query records, 其 updated_at 的值為 null Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereNotNull(&#x27;updated_at&#x27;) -&gt;get(); Answer:query records, 其 updated_at 的值不為 null Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereDate(&#x27;created_at&#x27;, &#x27;2016-12-31&#x27;) -&gt;get(); Answer:query records, 其 created_at 的 value 為 date 格式, 且為 ‘2016-12-31’ Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereMonth(&#x27;created_at&#x27;, &#x27;12&#x27;) -&gt;get(); Answer:query, 其 created_at column 的 value 轉成 date 格式後, month 須為 12 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereDay(&#x27;created_at&#x27;, &#x27;31&#x27;) -&gt;get(); Answer:query, 其 created_at column 的 value 轉成 date 格式後, day 須為 31 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereYear(&#x27;created_at&#x27;, &#x27;2016&#x27;) -&gt;get(); Answer:query, 其 created_at column 的 value 轉成 date 格式後, year 須為 2016 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereTime(&#x27;created_at&#x27;, &#x27;=&#x27;, &#x27;11:20:45&#x27;) -&gt;get(); Answer:query, 其 created_at column 的 value 轉成 date 格式後, time 須為 ‘11:20:45’ Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereColumn(&#x27;first_name&#x27;, &#x27;last_name&#x27;) -&gt;get(); Answer:query, 其 first_name column 的 value 需與 last_name column 的 value 相等 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereColumn(&#x27;updated_at&#x27;, &#x27;&gt;&#x27;, &#x27;created_at&#x27;) -&gt;get(); Answer:query, 其 first_name column 的 value 需大於 created_at column value Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereColumn([ [&#x27;first_name&#x27;, &#x27;=&#x27;, &#x27;last_name&#x27;], [&#x27;updated_at&#x27;, &#x27;&gt;&#x27;, &#x27;created_at&#x27;], ])-&gt;get(); Answer:一次附加多個 whereColumn clauses # Parameter GroupingLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;where(&#x27;name&#x27;, &#x27;=&#x27;, &#x27;John&#x27;) -&gt;where(function ($query) &#123; $query-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100) -&gt;orWhere(&#x27;title&#x27;, &#x27;=&#x27;, &#x27;Admin&#x27;); &#125;) -&gt;get(); Answer:在一個 where closure 內附加多個 where clauses # Where Exists ClausesLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereExists(function ($query) &#123; $query-&gt;select(DB::raw(1)) -&gt;from(&#x27;orders&#x27;) -&gt;whereRaw(&#x27;orders.user_id = users.id&#x27;); &#125;) -&gt;get(); Answer:# 如果 select 1 from orders ... 有返回的話, 回傳 select * from usersselect * from userswhere exists ( select 1 from orders where orders.user_id = users.id) # Subquery Where ClauseLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpuse App\\User;$users = User::where(function ($query) &#123; $query-&gt;select(&#x27;type&#x27;) -&gt;from(&#x27;membership&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;) -&gt;orderByDesc(&#x27;start_date&#x27;) -&gt;limit(1);&#125;, &#x27;Pro&#x27;)-&gt;get(); Answer:如果 subquery 取得的 type === ‘Pro’ 的話, 取得 users, 也就是說, 會取得最新有 membership 的 user # JSON Where ClausesLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;where(&#x27;options-&gt;language&#x27;, &#x27;en&#x27;) -&gt;get(); Answer:取得 users, 當其 JSON column options 中的 language key 的 value 為 ‘en’ Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;where(&#x27;preferences-&gt;dining-&gt;meal&#x27;, &#x27;salad&#x27;) -&gt;get(); Answer:取得 users, 當其 JSON column preferences 中的 dining 中的 meal key 的 value 為 ‘salad’ Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereJsonContains(&#x27;options-&gt;languages&#x27;, &#x27;en&#x27;) -&gt;get(); Answer:取 users, 其 options 欄位中的 languages 是一個 array, 其 value 含有 ‘en’ Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereJsonContains(&#x27;options-&gt;languages&#x27;, [&#x27;en&#x27;, &#x27;de&#x27;]) -&gt;get(); Answer:取 users, 其 options 欄位中的 languages 是一個 array, 其 values 含有 ‘en’ 以及 ‘de’ Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;whereJsonLength(&#x27;options-&gt;languages&#x27;, 0) -&gt;get(); Answer:取 users, 其 options 欄位中的 languages 是一個 array, 其 length 為 0 # Ordering, Grouping, Limit &amp; OffsetLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;orderBy(&#x27;name&#x27;, &#x27;desc&#x27;) -&gt;orderBy(&#x27;email&#x27;, &#x27;asc&#x27;) -&gt;get(); Answer:取 users, 依據 orderBy 的參數排序指定的欄位以及正序或倒序 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$user = DB::table(&#x27;users&#x27;) -&gt;latest() -&gt;first(); Answer:根據 date 做排序, 預設使用 created_at 欄位 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$randomUser = DB::table(&#x27;users&#x27;) -&gt;inRandomOrder() -&gt;first(); Answer:使用隨機排序 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$query = DB::table(&#x27;users&#x27;)-&gt;orderBy(&#x27;name&#x27;);$usersOrderedByEmail = $query-&gt;reorder(&#x27;email&#x27;, &#x27;desc&#x27;)-&gt;get(); Answer:移除現有的 orderBy constraint, 套用新的排序規則 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;groupBy(&#x27;first_name&#x27;, &#x27;status&#x27;) -&gt;having(&#x27;account_id&#x27;, &#x27;&gt;&#x27;, 100) -&gt;get(); Answer:先依據給予的欄位 groupBy record, 在使用 having 篩選出需要的資料, having 在此相當於 where 的作用 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;) -&gt;offset(10) -&gt;limit(5) -&gt;get(); Answer:跳過十筆資料, 然後只取五筆, 也可用 skip 以及 take Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;skip(10)-&gt;take(5)-&gt;get(); Answer:跳過十筆資料, 然後只取五筆, 也可用 offset 以及 limit # Conditional ClausesLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$sortBy = null;$users = DB::table(&#x27;users&#x27;) -&gt;when($sortBy, function ($query, $sortBy) &#123; return $query-&gt;orderBy($sortBy); &#125;, function ($query) &#123; return $query-&gt;orderBy(&#x27;name&#x27;); &#125;) -&gt;get(); Answer:當 when 的第一個 parameter 為 true 時, 方執行第二個 parameter closure, 若第一個 parameter 為 false, 則執行第二個 closure # InsertsLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;insert([ [&#x27;email&#x27; =&gt; &#x27;taylor@example.com&#x27;, &#x27;votes&#x27; =&gt; 0], [&#x27;email&#x27; =&gt; &#x27;dayle@example.com&#x27;, &#x27;votes&#x27; =&gt; 0],]); Answer:insert 多個 record 到 users table Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;insertOrIgnore([ [&#x27;id&#x27; =&gt; 1, &#x27;email&#x27; =&gt; &#x27;taylor@example.com&#x27;], [&#x27;id&#x27; =&gt; 2, &#x27;email&#x27; =&gt; &#x27;dayle@example.com&#x27;],]); Answer:在 insert 過程中, 如有重複的 record, 自動忽略 Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$id = DB::table(&#x27;users&#x27;)-&gt;insertGetId( [&#x27;email&#x27; =&gt; &#x27;john@example.com&#x27;, &#x27;votes&#x27; =&gt; 0]); Answer:自動取得 auto-increment ID, 預設欄位名稱為 id, 若要特別指定欄位名稱, 可帶入第二個 parameter # UpdatesLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$affected = DB::table(&#x27;users&#x27;) -&gt;where(&#x27;id&#x27;, 1) -&gt;update([&#x27;votes&#x27; =&gt; 1]); Answer:update 指定 record Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;) -&gt;updateOrInsert( [&#x27;email&#x27; =&gt; &#x27;john@example.com&#x27;, &#x27;name&#x27; =&gt; &#x27;John&#x27;], [&#x27;votes&#x27; =&gt; &#x27;2&#x27;] ); Answer:如果 parameter 1 的條件有找到 record 的話, 使用 parameter 2 指定的資料更新該 record, 如果沒找到, 會使用兩個 parameter 的資料來建立一個新的 record # Updating JSON ColumnsLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?php$affected = DB::table(&#x27;users&#x27;) -&gt;where(&#x27;id&#x27;, 1) -&gt;update([&#x27;options-&gt;enabled&#x27; =&gt; true]); Answer:更新 JSON Columns # Increment &amp; DecrementLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;increment(&#x27;votes&#x27;);DB::table(&#x27;users&#x27;)-&gt;increment(&#x27;votes&#x27;, 5);DB::table(&#x27;users&#x27;)-&gt;decrement(&#x27;votes&#x27;);DB::table(&#x27;users&#x27;)-&gt;decrement(&#x27;votes&#x27;, 5);DB::table(&#x27;users&#x27;)-&gt;increment(&#x27;votes&#x27;, 1, [&#x27;name&#x27; =&gt; &#x27;John&#x27;]); Answer:&lt;?php// 直接將 votes column 的 value 加 1DB::table(&#x27;users&#x27;)-&gt;increment(&#x27;votes&#x27;);// 直接將 votes column 的 value 加 5DB::table(&#x27;users&#x27;)-&gt;increment(&#x27;votes&#x27;, 5);// 直接將 votes column 的 value 減 1DB::table(&#x27;users&#x27;)-&gt;decrement(&#x27;votes&#x27;);// 直接將 votes column 的 value 減 5DB::table(&#x27;users&#x27;)-&gt;decrement(&#x27;votes&#x27;, 5);// 除了將 votes column 加 1 之外, 還更新 name column, 更新為 JohnDB::table(&#x27;users&#x27;)-&gt;increment(&#x27;votes&#x27;, 1, [&#x27;name&#x27; =&gt; &#x27;John&#x27;]); Laravel Query Builder 當中, 當我使用 increment 或 decrement method 時, 會觸發 model event 嗎？不會 # DeletesLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;delete();DB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;delete(); Answer:&lt;?php// 刪除 users table 中的所有 recordsDB::table(&#x27;users&#x27;)-&gt;delete();// 刪除 users table 中指定的 recordsDB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;delete(); Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;truncate(); Answer:刪除所有資料庫的資料, 並且重置 auto-incrementing ID # Pessimistic LockingLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;sharedLock()-&gt;get(); Answer:鎖住指定的 rows, 在解除鎖定之前, 這些 rows 無法被 update Laravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;lockForUpdate()-&gt;get(); Answer:鎖住指定的 rows, 在解除鎖定之前, 這些 rows 無法被 update, 也無法被 select # DebuggingLaravel Query Builder 當中, 以下的 example 意思是？ Example:&lt;?phpDB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;dd();DB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;dump(); Answer:&lt;?php// 印出 debug information, 並且停止執行該 requestDB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;dd();// 印出 debug information, 繼續執行該 requestDB::table(&#x27;users&#x27;)-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100)-&gt;dump();","link":"/zh-tw/laravel-database-query-builder/"},{"title":"Laravel - 部署","text":"# Introduction記錄一些 Laravel 部署的相關設定以及步驟 # 環境資訊AWS EC2NAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot; # 部署目標主要套件版本 Laravel 8 PHP 7.4 Nginx 1.16 MySQL 8 # 新增 yum 源站以及更新sudo yum -y install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmsudo yum -y install https://rpms.remirepo.net/enterprise/remi-release-7.rpmsudo yum -y install yum-utilssudo yum-config-manager --enable remi-php74 sudo yum update # Nginx# 安裝sudo yum -y install nginx # 啟動sudo systemctl start nginx # 開機自動啟動或不自動啟動sudo systemctl enable nginxsudo systemctl disable nginx # 確認狀態sudo systemctl status nginx # 確認語法是否正確sudo nginx -t # sites-available, sites-enabled 資料夾# 建立sudo mkdir /etc/nginx/sites-availablesudo mkdir /etc/nginx/sites-enabled # 修改設定檔sudo vim /ete/nginx/nginx.conf # Load customized enabled sitesinclude /etc/nginx/sites-enabled/*; # 產生 symbolic linksudo ln -s /etc/nginx/sites-available/yourProjectConf /etc/nginx/sites-enabled/ # 權限配置sudo chown -R nginx:nginx /var/lib/nginx # 重新安裝 (若有需要)# 完全移除 Nginxsudo systemctl stop nginx.servicesudo systemctl disable nginx.servicesudo userdel -r nginxsudo rm -rf /etc/nginxsudo rm -rf /var/log/nginxsudo rm -rf /var/cache/nginx/sudo rm -rf /usr/lib/systemd/system/nginx.servicesudo yum remove nginx # 重新安裝sudo groupadd nginxsudo useradd -g nginx nginx -s /sbin/nologinsudo yum -y install nginx # Apache# 安裝 Apachesudo yum -y install httpd24 # 啟動sudo service httpd start # 設定開機自動重啟sudo chkconfig httpd on # 確認 httpd 已啟用chkconfig --list httpd # 設定檔sudo vim /etc/httpd/conf/httpd.conf &lt;Direction &quot;/var/www/yourProject&quot;&gt; Allow Override All&lt;/Direction&gt; # 安裝 SSL modulesudo yum install mod24_ssl # AWS# 設定 security inbound # 測試 LAMP Web 伺服器# 在 /var/www/html 資料夾中建立 PHP infoecho &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt; /var/www/html/phpinfo.php # 訪問 http://ip/phpinfo.php# 刪除rm /var/www/html/phpinfo.php # PHP# 安裝 PHP sudo yum install php PHP Extensions sudo yum install php-fpm php-mysqlnd php-devel php-gd php-mbstring php-xml php-pear php-bcmath php-opcachesudo pecl channel-update pecl.php.netsudo pecl install imagick 其他套件 sudo yum install ImageMagick ImageMagick-devel ImageMagick-perl # 啟動 PHP-FPMsudo systemctl start php-fpm # 開機自動啟動或不自動啟動 PHP-FPMsudo systemctl enable php-fpmsudo systemctl disable php-fpm # 若要變更 Listen port 9000 到 socket 編輯 sudo vim /etc/php-fpm.d/www.conf 內容 ; listen = 127.0.0.1:9000listen = /var/run/php/php7.4-fpm.sock # 變更 php-fpm child process user 編輯 sudo vim /etc/php-fpm.d/www.conf 內容 user = phpgroup = php # 變更 php-fpm sock owner 以及權限 編輯 sudo vim /etc/php-fpm.d/www.conf 內容 listen.owner = yourPreferredOwnerlisten.group = yourPreferredGrouplisten.mode = 0660 # 開機自動建立 /var/run/php 編輯 sudo vim /usr/lib/tmpfiles.d/yourPreferredDaemonName.conf 內容 #Type Path Mode UID GID Age Argumentd /run/mydaemon 0755 myuser myuser - - # 變更 php-fpm child process user umasksudo systemctl edit php-fpm.service 系統會自動在 /etc/systemd/system/php-fpm.service.d 生成一個新的 override.conf 檔, 任何在此檔內的設定都會優先使用也可修改 /lib/systemd/system/php-fpm.service 檔案, 不過如果系統更新, 可能會覆蓋掉這個設定 [Service]UMask=0002 然後重啟 sudo systemctl reload php-fpm.servicesudo systemctl restart php-fpm # MySQL# 設定 yum repositorysudo rpm -Uvh https://repo.mysql.com/mysql80-community-release-el7-3.noarch.rpm # disable 預設 yum MySQL reposudo sed -i &#x27;s/enabled=1/enabled=0/&#x27; /etc/yum.repos.d/mysql-community.repo # 指定 yum mysql repo 並安裝sudo yum --enablerepo=mysql80-community install -y mysql-community-server # 啟動sudo systemctl start mysqld # 確認是否啟動sudo systemctl status mysqld # 取得臨時 root 密碼sudo grep &quot;A temporary password&quot; /var/log/mysqld.log # 完成安全設定sudo mysql_secure_installation # 針對專案建立使用者# 建立CREATE USER &#x27;userName&#x27;@&#x27;userHost&#x27; IDENTIFIED BY &#x27;userPassword&#x27;; # 賦予權限GRANT ALL ON databaseName.tableName TO &#x27;userName&#x27;@&#x27;hostName&#x27; # 使用 RDS MySQL clientmysql -h yourHost -u yourUser -p # Git# 安裝sudo yum install -y git # 設定可接受遠端 pushsudo git config receive.denyCurrentBranch ignore # 設定 hooksudo vim /var/www/projectName/.git/hooks/post-receive GIT_WORK_TREE=/var/www/projectName git checkout -fcd /var/www/projectName/usr/local/bin/composer install/usr/bin/php artisan migrate/usr/bin/php artisan config:clear/usr/bin/php artisan config:cache/usr/bin/php artisan route:clear/usr/bin/php artisan route:cache chmod 770 post-receive # Composer# 安裝 dependencysudo yum install php-cli php-zip wget unzip # 下載 Composer installerphp -r &quot;copy(&#x27;https://getcomposer.org/installer&#x27;, &#x27;composer-setup.php&#x27;);&quot; # 驗證 installer 是否正確HASH=&quot;$(wget -q -O - https://composer.github.io/installer.sig)&quot;php -r &quot;if (hash_file(&#x27;SHA384&#x27;, &#x27;composer-setup.php&#x27;) === &#x27;$HASH&#x27;) &#123; echo &#x27;Installer verified&#x27;; &#125; else &#123; echo &#x27;Installer corrupt&#x27;; unlink(&#x27;composer-setup.php&#x27;); &#125; echo PHP_EOL;&quot; # 安裝sudo php composer-setup.php --install-dir=/usr/local/bin --filename=composer # 專案# 查看 nginx userps aux | grep nginx # 查看 fpm userps aux | grep fpm # 建立資料夾sudo mkdir /var/www/projectName # 建立之後將管理專案的 groupsudo groupadd projectName # 將會存取到該專案的使用者加到該群組sudo usermod -a -G projectGroupName userName(user,nginx,php-fpm) # 修改專案資料夾目錄權限(使用上面建立的 group)sudo chown -R root:projectGroupName /var/www/projectName sudo chmod 2770 /var/www/projectName sudo find /var/www -type d -exec sudo chmod 2770 &#123;&#125; \\; sudo find /var/www -type f -exec sudo chmod 0660 &#123;&#125; \\; sudo chmod 770 /var/www/projectName/artisan sudo chmod 770 /var/www/projectName/.git/hooks/post-receive # 本機 push 到機器上# 增加新的 remotegit remote add remoteName sshKeyUserName@serverIp:/var/www/projectName # pushGIT_SSH_COMMAND=&#x27;ssh -i ~/.ssh/serverLoginPrivateKey&#x27; git push test master # 專案啟動設置 設置 .env 產生 keyphp artisan key:generate 匯入 tablesphp artisan migrate # Redis# 安裝sudo yum install redissudo yum install php-pecl-redis # 啟動sudo systemctl start redissudo systemctl status redis # 開機自動啟動或不啟動sudo systemctl enable redissudo systemctl disable redis # 使用 ElastiCache .env REDIS_HOST=tls://yourHostREDIS_PASSWORD=yourPasswordREDIS_PORT=6379 redis-cli在 ec2 上無需使用 -a 便可登入 redis-cli -c -h yourHost -a yourAuth --tls # SELinux# 確認 SELinux 是否開啟sudo getenforce # HTTP 讀取權限# 查看 project SELinux 設定ls -Zd /var/www/projectName # 賦予 storage, cache 資料夾讀寫權限sudo semanage fcontext -a -t httpd_sys_rw_content_t &quot;/var/www/projectName/storage(/.*)?&quot;sudo semanage fcontext -a -t httpd_sys_rw_content_t &quot;/var/www/projectName/bootstrap/cache(/.*)?&quot; -a: 增加規則到預設安全性本文 -m: 呈上, 修改 -d: 呈上, 刪除 -t: type # 恢復預設sudo restorecon -Rv &#x27;/usr/share/nginx/html/testapp&#x27; -R: recursive -v: verbose # 允許 HTTP 連結資料庫 (For database)sudo setsebool -P httpd_can_network_connect_db 1 -P:直接將設定值寫入設定檔 # 允許 HTTP 連結 socket (For local redis)sudo setsebool -P httpd_can_network_connect 1 -P:直接將設定值寫入設定檔 # Supervisor# 安裝sudo yum install supervisor # 執行 worker 的 user# 建立sudo useradd userName -s /sbin/nologin # 賦予專案權限sudo usermod -a -G projectGroupName workerUserName # 建立配置 worker ini 檔sudo vim /etc/supervisord.d/laravel-worker.ini [program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=/path/to/php /path/to/yourProject/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600autostart=trueautorestart=truestopasgroup=truekillasgroup=trueuser=workerUserNamenumprocs=8redirect_stderr=truestdout_logfile=/var/log/laravel-worker.logstopwaitsecs=3600 # 定義 supervisor user default umask在 worker ini 中： umask=007 然後 reread &amp; update # 啟動sudo systemctl start supervisordsudo systemctl status supervisord # 開機自動啟動sudo systemctl enable supervisord # 操作指令sudo supervisorctl reread // 重讀但不重啟sudo supervisorctl update // 重讀, 並且如果 config 有變更才重啟有變更的 processsudo supervisorctl relaod // 重讀, 不管有無變更都會重啟所有 processsudo supervisorctl restart // 只重啟, 不重讀 # APC cache# Centossudo yum install php-pecl-apcu # macOSpecl install apcu # 時區設定# MySQL 時區# 檢查 MySQL 時區SELECT @@global.time_zone, @@session.time_zone; # Server 時區# 取得 server 時區date +%Z # 取得 server 可用時區sudo timedatectl list-timezones # 設定 server 時區sudo timedatectl set-timezone Asia/Taipei # 設定 Laravel 時區修改 config/app.php 中的 timezone # 記憶體不足# 可劃分磁碟為替代記憶體sudo dd if=/dev/zero of=/swapfile bs=1M count=2000;sudo chmod 600 /swapfile;sudo mkswap /swapfile;sudo swapon /swapfile;swapon -s;sudo vim /etc/fstab; /swapfile swap swap defaults 0 0 # 若使用 GCP, 要讓 MySQL 可從外部存取# 開權限LOCAL_IP=$(curl http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip \\ -H &quot;Metadata-Flavor: Google&quot;)sudo sed -i &quot;s|bind-address.*|bind-address = $LOCAL_IP|&quot; /etc/mysql/mysql.conf.d/mysqld.cnf 更多設定可參考官方文件 # lsb-release# 安裝sudo apt-get install lsb-release # 用法lsb_release --help -h, --help show this help message and exit-v, --version show LSB modules this system supports-i, --id show distributor ID-d, --description show description of this distribution-r, --release show release number of this distribution-c, --codename show code name of this distribution-a, --all show all of the above information-s, --short show requested information in short format # 查詢細節lsb_release -a # 只顯示 kernel 版本uname -r ## # server optimization ### # sysctl - 到 `/etc/sysctl.d/` 下建立 custom.conf - 加入以下設定 net.core.somaxconn=10000net.ipv4.ip_local_port_range=10000 65535net.ipv4.tcp_tw_reuse=1 reload, sysctl --system","link":"/zh-tw/laravel-deploayment/"},{"title":"Laravel - Database - Seeding","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Writing Seeders以下 Laravel command 的意思是？ Example:php artisan make:seeder UserSeeder Answer:建立一個 seed class 以下 Laravel example code 的意思是？ Example:&lt;?phpclass DatabaseSeeder extends Seeder&#123; public function run() &#123; DB::table(&#x27;users&#x27;)-&gt;insert([ &#x27;name&#x27; =&gt; Str::random(10), &#x27;email&#x27; =&gt; Str::random(10).&#x27;@gmail.com&#x27;, &#x27;password&#x27; =&gt; Hash::make(&#x27;password&#x27;), ]); &#125;&#125; Answer:&lt;?phpclass DatabaseSeeder extends Seeder&#123; public function run() &#123; DB::table(&#x27;users&#x27;)-&gt;insert([ // 隨機產生 10 碼 &#x27;name&#x27; =&gt; Str::random(10), // 同上 &#x27;email&#x27; =&gt; Str::random(10).&#x27;@gmail.com&#x27;, // 將 string &#x27;password&#x27; hash 存到資料庫 &#x27;password&#x27; =&gt; Hash::make(&#x27;password&#x27;), ]); &#125;&#125; # Using Model Factories以下 Laravel example code 的意思是？ Example:php artisan make:factory PostFactory --model=Post Answer:建立一個 PostFactory, 該 factory 會產生 Post model 以下 Laravel example code 的意思是？ Example:&lt;?phpclass UserFactory extends Factory&#123; protected $model = User::class; public function definition() &#123; return [ &#x27;name&#x27; =&gt; $this-&gt;faker-&gt;name, &#x27;email&#x27; =&gt; $this-&gt;faker-&gt;unique()-&gt;safeEmail, &#x27;email_verified_at&#x27; =&gt; now(), &#x27;password&#x27; =&gt; &#x27;$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi&#x27;, // password &#x27;remember_token&#x27; =&gt; Str::random(10), ]; &#125;&#125; Answer:&lt;?phpclass UserFactory extends Factory&#123; // 該 factory 對應的 model protected $model = User::class; // 定義 model 預設的狀態 public function definition() &#123; return [ &#x27;name&#x27; =&gt; $this-&gt;faker-&gt;name, &#x27;email&#x27; =&gt; $this-&gt;faker-&gt;unique()-&gt;safeEmail, &#x27;email_verified_at&#x27; =&gt; now(), &#x27;password&#x27; =&gt; &#x27;$2y$10$92IXUNpkjO0rOQ5byMi.Ye4oKoEa3Ro9llC/.og/at2.uheWG/igi&#x27;, // password &#x27;remember_token&#x27; =&gt; Str::random(10), ]; &#125;&#125; 以下 Laravel 中, 位於 Factory 中的 example code 的意思是？ Example:&lt;?phppublic function suspended()&#123; return $this-&gt;state(function (array $attributes) &#123; return [ &#x27;account_status&#x27; =&gt; &#x27;suspended&#x27;, ]; &#125;);&#125; Answer:自定義一個 factory method 以下 Laravel 中, 位於 Factory 中的 example code 的意思是？ Example:&lt;?phpclass UserFactory extends Factory&#123; protected $model = User::class; public function configure() &#123; return $this-&gt;afterMaking(function (User $user) &#123; // &#125;)-&gt;afterCreating(function (User $user) &#123; // &#125;); &#125; // ...&#125; Answer:&lt;?phpclass UserFactory extends Factory&#123; 指定要建立的 model protected $model = User::class; public function configure() &#123; // make model 後要做的事 return $this-&gt;afterMaking(function (User $user) &#123; // // create model 後要做的事 &#125;)-&gt;afterCreating(function (User $user) &#123; // &#125;); &#125; // ...&#125; 以下 Laravel 中, 位於 model 內的 example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; use HasFactory;&#125; Answer:當特定 model 的 Factory 被定義後, 可在 model 中 use HasFactory trait, 這樣就可以在任何地方使用 static factory method 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phpuse App\\Models\\User;public function testDatabase()&#123; $user = User::factory()-&gt;make(); // Use model in tests...&#125; Answer:使用 factory 來 make 一個 User model, make 表示已建立但尚未儲存到資料庫 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$users = User::factory()-&gt;count(3)-&gt;make(); Answer:使用 user factory make 3 個 User model, make 表示已建立 model 但尚未儲存到資料庫 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phpprotected static function newFactory()&#123; return \\Database\\Factories\\Administration\\FlightFactory::new();&#125; Answer:HasFactory trait 中的 factor method 有其規定的 convention, 像是 modelNameFactory, 如 PostFactory, 當使用 Post::factory() 時 Laravel 會自動尋找 Factory namespace 下面的 PostFactory上面的 example code 是當 Factory 不符合這個 convention 時, 可以特別指定 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$users = User::factory()-&gt;count(5)-&gt;suspended()-&gt;make(); Answer:suspended() 為自定義的 state method, 也可被使用 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory()-&gt;make([ &#x27;name&#x27; =&gt; &#x27;Abigail Otwell&#x27;,]); Answer:一般來說, factory 會 return 在 factory 中定義好的 attributes, 但若臨時要特別指定 attributes, 可用以上的 example code 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory()-&gt;state([ &#x27;name&#x27; =&gt; &#x27;Abigail Otwell&#x27;,])-&gt;make(); Answer:一般來說, factory 會 return 在 factory 中定義好的 attributes, 但若臨時要特別指定 attributes, 可用以上的 example code 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phpuse App\\Models\\User;public function testDatabase()&#123; $user = User::factory()-&gt;create(); $users = User::factory()-&gt;count(3)-&gt;create();&#125; Answer:&lt;?phpuse App\\Models\\User;public function testDatabase()&#123; // 建立一筆 user model record 並 save $user = User::factory()-&gt;create(); // 建立三筆 user model record 並 save $users = User::factory()-&gt;count(3)-&gt;create();&#125; 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory()-&gt;create([ &#x27;name&#x27; =&gt; &#x27;Abigail&#x27;,]); Answer:一般來說, factory 會 return 在 factory 中定義好的 attributes, 但若臨時要特別指定 attributes, 可用以上的 example code 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$users = User::factory() -&gt;count(10) -&gt;state(new Sequence( [&#x27;admin&#x27; =&gt; &#x27;Y&#x27;], [&#x27;admin&#x27; =&gt; &#x27;N&#x27;], )) -&gt;create(); Answer:Sequence method 可以讓建立出來的 model 輪流使用帶入的參數, 所以這十筆 model 的資料就會是 y, n, y, n, … 以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$users = User::factory() -&gt;count(10) -&gt;state(new Sequence( fn () =&gt; [&#x27;role&#x27; =&gt; UserRoles::all()-&gt;random()], )) -&gt;create(); Answer:當使用 Sequence() 時, 也可帶入 closure, 在建立每一個 model 時 closure 都會被 invoked 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phppublic function definition()&#123; return [ &#x27;user_id&#x27; =&gt; User::factory(), &#x27;user_type&#x27; =&gt; function (array $attributes) &#123; return User::find($attributes[&#x27;user_id&#x27;])-&gt;type; &#125;, &#x27;title&#x27; =&gt; $this-&gt;faker-&gt;title, &#x27;content&#x27; =&gt; $this-&gt;faker-&gt;paragraph, ];&#125; Answer:&lt;?phppublic function definition()&#123; return [ // 建立 post 時, 同時建立一個 user &#x27;user_id&#x27; =&gt; User::factory(), // attributes 裡頭會有上一行建立的 user_id, 利用此 user_id 取得 User model 及 // 其 type &#x27;user_type&#x27; =&gt; function (array $attributes) &#123; return User::find($attributes[&#x27;user_id&#x27;])-&gt;type; &#125;, &#x27;title&#x27; =&gt; $this-&gt;faker-&gt;title, &#x27;content&#x27; =&gt; $this-&gt;faker-&gt;paragraph, ];&#125; 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory() -&gt;has(Post::factory()-&gt;count(3)) -&gt;create(); Answer:&lt;?php$user = User::factory() // 在建立該 user model 的同時, 建立三個 Post model // 須事先 define User hasMany Post 的 relation -&gt;has(Post::factory()-&gt;count(3)) -&gt;create(); 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory() -&gt;has(Post::factory()-&gt;count(3), &#x27;posts&#x27;) -&gt;create(); Answer:&lt;?php$user = User::factory() // create User 的同時也 create 三筆 Post, 須事先定義 // User hasMany Post relation // 帶入 &#x27;posts&#x27; 為特別指定, 若無指定 Laravel 會使用自己的 convention 尋找 -&gt;has(Post::factory()-&gt;count(3), &#x27;posts&#x27;) -&gt;create(); 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory() -&gt;has( Post::factory() -&gt;count(3) -&gt;state(function (array $attributes, User $user) &#123; return [&#x27;user_type&#x27; =&gt; $user-&gt;type]; &#125;) ) -&gt;create(); Answer:&lt;?php$user = User::factory() -&gt;has( Post::factory() -&gt;count(3) // 使用 state method 在 Post model 中定義額外與 User model 相關的資訊 -&gt;state(function (array $attributes, User $user) &#123; return [&#x27;user_type&#x27; =&gt; $user-&gt;type]; &#125;) ) -&gt;create(); 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory() -&gt;hasPosts(3) -&gt;create(); Answer:使用 factory’s magic relationship methods, 在 create User model 的同時, 並 create 三個 Post relationship model 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory() -&gt;hasPosts(3, [ &#x27;published&#x27; =&gt; false, ]) -&gt;create(); Answer:使用 factory’s magic relationship methods, 在 create User model 的同時, 並 create 三個 Post relationship model, 並且額外帶入 attributes 覆蓋原本的 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$user = User::factory() -&gt;hasPosts(3, function (array $attributes, User $user) &#123; return [&#x27;user_type&#x27; =&gt; $user-&gt;type]; &#125;) -&gt;create(); Answer:使用 factory’s magic relationship methods, 在 create User model 的同時, 並 create 三個 Post relationship model, 因為會用到 User model 的內容來更新 Post model, 因此使用了 state method 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$posts = Post::factory() -&gt;count(3) -&gt;for(User::factory()-&gt;state([ &#x27;name&#x27; =&gt; &#x27;Jessica Archer&#x27;, ])) -&gt;create(); Answer:在 create 3 個 Post model 的同時, create 一個 belongsTo relation 的 User model, 並自定義 name column需事先在 Post model 定義與 User model 的 belongsTo relationship 以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$user = User::factory()-&gt;create();$posts = Post::factory() -&gt;count(3) -&gt;for($user) -&gt;create(); Answer:在使用 Factory 建立 belongsTo relationship 時, 如果已有現成的 model, 可直接 pass 該 model as a parent 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$posts = Post::factory() -&gt;count(3) -&gt;forUser([ &#x27;name&#x27; =&gt; &#x27;Jessica Archer&#x27;, ]) -&gt;create(); Answer:使用 Factory magic relationship method, create 3 個 Post model 並指定其 belongsTo User model, 並指定該 User model 的 name 為 Jessica Archer 以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$user = User::factory() -&gt;has(Role::factory()-&gt;count(3)) -&gt;create(); Answer:也可使用 has() 來指定 relationship, 前提是要先在 model 定義好 relation 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$users = User::factory() -&gt;hasAttached( Role::factory()-&gt;count(3), [&#x27;active&#x27; =&gt; true] ) -&gt;create(); Answer:使用 hasAttached method 來定義 pivot table 的 attribute 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$users = User::factory() -&gt;hasAttached( Role::factory() -&gt;count(3) -&gt;state(function (array $attributes, User $user) &#123; return [&#x27;name&#x27; =&gt; $user-&gt;name.&#x27; Role&#x27;]; &#125;), [&#x27;active&#x27; =&gt; true] ) -&gt;create(); Answer:&lt;?php$users = User::factory() // 使用 hasAttached method 來定義 pivot table 的 attribute -&gt;hasAttached( // 這邊具體行為, create 3 個 Role model, 並定義 name column 的 value // 為 $user-&gt;name.&#x27; Role&#x27;, 會用到 User model, 所以使用 state method Role::factory() -&gt;count(3) -&gt;state(function (array $attributes, User $user) &#123; return [&#x27;name&#x27; =&gt; $user-&gt;name.&#x27; Role&#x27;]; &#125;), // 這一行定義 pivot model 的 active column 的 value 為 true [&#x27;active&#x27; =&gt; true] ) -&gt;create(); 以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$roles = Role::factory()-&gt;count(3)-&gt;create();$user = User::factory() -&gt;count(3) -&gt;hasAttached($roles, [&#x27;active&#x27; =&gt; true]) -&gt;create(); Answer:使用 hasAttached() 時, 也可直接帶入已經建立好的 models, 並定義 pivot table 上的值 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$users = User::factory() -&gt;hasRoles(1, [ &#x27;name&#x27; =&gt; &#x27;Editor&#x27; ]) -&gt;create(); Answer:create User model 並且同步 create 1 個 Role model, User 與 Role model relationship 可以是 hasMany 或 manyToMany 或 morphMany, 並 overwrite name column 的 value 為 EditorRelationship 須事先定義 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?php$comments = Comment::factory()-&gt;count(3)-&gt;for( Post::factory(), &#x27;commentable&#x27;)-&gt;create(); Answer:使用 factory create 3 個 comment model, 並且 create 1 個 Post model, 彼此的 relationship 為 Comments morphTo Post 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;public function definition()&#123; return [ &#x27;user_id&#x27; =&gt; User::factory(), &#x27;title&#x27; =&gt; $this-&gt;faker-&gt;title, &#x27;content&#x27; =&gt; $this-&gt;faker-&gt;paragraph, ];&#125; Answer:在 Factory 內可直接定義 relationships 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phppublic function definition()&#123; return [ &#x27;user_id&#x27; =&gt; User::factory(), &#x27;user_type&#x27; =&gt; function (array $attributes) &#123; return User::find($attributes[&#x27;user_id&#x27;])-&gt;type; &#125;, &#x27;title&#x27; =&gt; $this-&gt;faker-&gt;title, &#x27;content&#x27; =&gt; $this-&gt;faker-&gt;paragraph, ];&#125; Answer:如果某個 attribute 的值取決於 relation model 的某個欄位, 可使用 closure, 並從 $attributes 取得當前已建立的 attributes 來進一步取得資訊 以下 Laravel 中, create hasMany 跟 morphMany 的 method 一樣嗎？一樣 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phppublic function run()&#123; User::factory() -&gt;times(50) -&gt;hasPosts(1) -&gt;create();&#125; Answer:利用 User factory create 50 個 User model, 並且每個 User model 各 create 一個 hasMany relationship Post model # Calling Additional Seeders以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phppublic function run()&#123; $this-&gt;call([ UserSeeder::class, PostSeeder::class, CommentSeeder::class, ]);&#125; Answer:在 database seeder 中, 定義要執行的 seeder, 當我下 php artisan db:seed 之後將會執行以上定義的 seeder # Running Seeders以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phpphp artisan db:seedphp artisan db:seed --class=UserSeeder Answer:&lt;?php// 執行 database seeder, 會執行所有定義在 database seeder 中的動作php artisan db:seed// 只執行 php artisan db:seed --class=UserSeeder 以下 Laravel 中, 以下的 example code 意思是？ Example:&lt;?phpphp artisan migrate:fresh --seed Answer:migration drop 所有的 table 在執行 up 的同時, 執行 database seeder # Forcing Seeders To Run In Production以下 Laravel 中, 以下的 example code 意思是？ Example:php artisan db:seed --force Answer:在 production 中, Laravel 的保護機制, 當執行 php artisan db:seed 時會跳出詢問再確認的視窗, 若使用 flag --force 可略過此保護機制","link":"/zh-tw/laravel-database-seeding/"},{"title":"Laravel - Digging Deeper - Artisan Console (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Introduction以下的 Laravel example command 的意思是？ Example:php artisan list Answer:列出可用的 Artisan commands 以下的 Laravel example command 的意思是？ Example:php artisan help migrate Answer:詳述 migrate command 的用法, 將 help 至於 command 前方可列出 command 詳細用法 # Tinker (RPEL)# Installation以下的 Laravel example code 的意思是？ Example:composer require laravel/tinker Answer:安裝 Laravel tinker, tinker 預設就已安裝, 但如果有手動安裝的需求, 可以執行上面 composer 指令 # Usage以下的 Laravel example command 的意思是？ Example:php artisan tinker Answer:進入 tinker 環境 以下的 Laravel example command 的意思是？ Example:php artisan vendor:publish --provider=&quot;Laravel\\Tinker\\TinkerServiceProvider&quot; Answer:發布 tinker 的設定檔 Laravel Tinker 中, 若要 dispatch a job or queue, 該使用哪些 method？ Bus::dispatch Queue:push # Command Whitelist以下位於 tinker.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;commands&#x27; =&gt; [ // App\\Console\\Commands\\ExampleCommand::class,], Answer:Tinker 使用白名單來決定哪些 Artisan commands 允許在 Tinker shell 中執行, 預設可以執行 clear-compiled, down, env, inspire, migrate, optimize, up 這些 command, 如果想要允許更多 command, 可加入上面的 example commands array 中 Classes That Should Not Be Aliased以下位於 tinker.php 的 Laravel example code 的意思是？ Example:&#x27;dont_alias&#x27; =&gt; [ App\\Models\\User::class,], Answer:Tinker 預設會自動 alias class, 如果有些 class 你希望 tinker 不要 alias, 可加在以上的 example ‘dont_alias’ array 中 # Writing CommandLaravel custom command 會被置於哪個資料夾？app/Console/Commands # Generating Commands以下的 Laravel example command 的意思是？ Example:&lt;?phpphp artisan make:command SendEmails Answer:建立一個 custom command, 並置於 app/Console/Commands # Command Structure以下的 Laravel example command 的意思是？ Example:&lt;?phpnamespace App\\Console\\Commands;use App\\Models\\User;use App\\Support\\DripEmailer;use Illuminate\\Console\\Command;class SendEmails extends Command&#123; protected $signature = &#x27;email:send &#123;user&#125;&#x27;; protected $description = &#x27;Send drip e-mails to a user&#x27;; public function __construct() &#123; parent::__construct(); &#125; public function handle(DripEmailer $drip) &#123; $drip-&gt;send(User::find($this-&gt;argument(&#x27;user&#x27;))); &#125;&#125; Answer:&lt;?phpnamespace App\\Console\\Commands;use App\\Models\\User;use App\\Support\\DripEmailer;use Illuminate\\Console\\Command;class SendEmails extends Command&#123; // command 的名字 protected $signature = &#x27;email:send &#123;user&#125;&#x27;; // command 的描述 protected $description = &#x27;Send drip e-mails to a user&#x27;; public function __construct() &#123; parent::__construct(); &#125; // handle 裡頭就是執行此 command 的邏輯, args 可以用 type hint 的方式 inject 任何 class public function handle(DripEmailer $drip) &#123; $drip-&gt;send(User::find($this-&gt;argument(&#x27;user&#x27;))); &#125;&#125; # Closure Commands以下位於 …/routes/console.php 的 Laravel example code 的意思是？ Example:&lt;?phpArtisan::command(&#x27;build &#123;project&#125;&#x27;, function ($project) &#123; $this-&gt;info(&quot;Building &#123;$project&#125;!&quot;);&#125;); Answer:建立一個 closure based commandclosure based command 之於 class command, 就相當於 route closure 之於 controllerbuild 為帶入的 args, 所以輸入 php artisan build hello, 就會顯示 Building hello! # Type-Hinting Dependencies以下位於 …/routes/console.php 的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;use App\\Support\\DripEmailer;Artisan::command(&#x27;email:send &#123;user&#125;&#x27;, function (DripEmailer $drip, $user) &#123; $drip-&gt;send(User::find($user));&#125;); Answer:建立一個 closure based commandclosure based command 之於 class command, 就相當於 route closure 之於 controller輸入 php artisan email:send 3, 就會執行 $drip-&gt;send(User::find($user))在 closure 內可以 type hint 任何有用到的 class # Closure Command Descriptions以下位於 …/routes/console.php 的 Laravel example code 的意思是？ Example:&lt;?phpArtisan::command(&#x27;build &#123;project&#125;&#x27;, function ($project) &#123; $this-&gt;info(&quot;Building &#123;$project&#125;!&quot;);&#125;)-&gt;describe(&#x27;Build the project&#x27;); Answer:建立一個 closure based commandclosure based command 之於 class command, 就相當於 route closure 之於 controllerbuild 為帶入的 args, 所以輸入 php artisan build hello, 就會顯示 Building hello!describe 為該 command 的敘述, 當執行 php artisan list 或 php artisan help 時會顯示出來 # Defining Input Expectation# Arguments以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $signature = &#x27;email:send &#123;user&#125;&#x27;;protected $signature = &#x27;email:send &#123;user?&#125;&#x27;;protected $signature = &#x27;email:send &#123;user=foo&#125;&#x27;; Answer:&lt;?php// 例如輸入 &#x27;php artisan email:send Ray&#x27;, 那 Ray 就會等於 &#123;user&#125;, 這個 argument 是 requiredprotected $signature = &#x27;email:send &#123;user&#125;&#x27;;// 例如輸入 &#x27;php artisan email:send Ray&#x27;, 那 Ray 就會等於 &#123;user&#125;, 這個 argument 是 optionalprotected $signature = &#x27;email:send &#123;user?&#125;&#x27;;// 例如輸入 &#x27;php artisan email:send Ray&#x27;, 那 Ray 就會等於 &#123;user&#125;, 這個 argument 是 optional, 且 default value 為 fooprotected $signature = &#x27;email:send &#123;user=foo&#125;&#x27;; # Options以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $signature = &#x27;email:send &#123;user&#125; &#123;--queue&#125;&#x27;; Answer:定義 Artisan command 的 format{user} 為 argument, {–queue} 為可有可無的 options, 有帶為 true, 反之為 false輸入: ‘php artisan email:send 4 –queue’, 那 {user} = 4, ‘–queue’ 有帶的話, 為 true, 反之為 false # Options With Values以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $signature = &#x27;email:send &#123;user&#125; &#123;--queue=&#125;&#x27;;protected $signature = &#x27;email:send &#123;user&#125; &#123;--queue=default&#125;&#x27;; Answer:&lt;?php// 定義 Artisan command 的 format// &#123;user&#125; 為 argument, &#123;--queue&#125; 為可傳入值的 options// 輸入: &#x27;php artisan email:send 4 --queue=highPriority&#x27;, 那 &#123;user&#125; = 4, &#x27;--queue&#x27;// 的值為 &#x27;highPriority&#x27;protected $signature = &#x27;email:send &#123;user&#125; &#123;--queue=&#125;&#x27;;// 給予 &#x27;--queue&#x27; 一個 default 值, 若沒帶則為 &#x27;default&#x27;protected $signature = &#x27;email:send &#123;user&#125; &#123;--queue=default&#125;&#x27;; # Options Shortcuts以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $signature = &#x27;email:send &#123;user&#125; &#123;--Q|queue&#125;&#x27;; Answer:&lt;?php// 定義 Artisan command 的 format// &#123;user&#125; 為 argument, &#123;--queue&#125; 為可有可無的 options, 有帶為 true, 無則為 false// &#x27;--Q&#x27; 為 &#x27;--queue&#x27; 的縮寫, 兩者都可用// 輸入: &#x27;php artisan email:send 4 --queue&#x27;, 那 &#123;user&#125; = 4, &#x27;--queue&#x27;// 為 trueprotected $signature = &#x27;email:send &#123;user&#125; &#123;--Q|queue&#125;&#x27;; # Input Arrays以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $signature = &#x27;email:send &#123;user*&#125;; Answer:定義 Artisan command 的 format{user*} 為 array input例如輸入 ‘php artisan email:send foo bar’, 則 {user*} 的值為 [‘foo’, ‘bar’] 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phpemail:send &#123;user&#125; &#123;--id=*&#125; Answer:定義 Artisan command 的 format{user} 為單一 input例如輸入 ‘php artisan email:send bar –id=1 –i=2 –id=3’則 {user} 的值為 ‘bar’, 而 ‘–id’ 的值為 [‘1’, ‘2’, ‘3’] # Input Descriptions以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $signature = &#x27;email:send &#123;user : The ID of the user&#125; &#123;--queue= : Whether the job should be queued&#125;&#x27;; Answer:定義 Artisan command 的 format{user} 為單一 input, –queue= 為單一 input例如輸入 ‘php artisan email:send bar –queue=highPriority’, 則 {user} 的值為 ‘bar’, 而 ‘–queue’ 的值為 ‘highPriority’, colon 後的 string 為 args 及 options 的 description # Command I/O# Retrieving Input以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $userId = $this-&gt;argument(&#x27;user&#x27;); $arguments = $this-&gt;arguments(); //&#125; Answer: 取得 command signature 中定義的 argument, 例如 signature 為 ‘email:send {user}’ 取得所有 arguments, 以 array 的方式取得, 例如 signature 為 ‘email:send {user} {shop}’, 則輸出為 [‘user’ =&gt; {user}, ‘shop’ =&gt; {shop}] 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?php$queueName = $this-&gt;option(&#x27;queue&#x27;);$options = $this-&gt;options(); Answer: 取得 command signature 中定義的 option, 例如 signature 為 ‘email:send {user} {–queue=}’ 取得所有 options, 以 array 的方式取得, 例如 signature 為 ‘email:send {–id=} {–wd=}, 則輸出為 [‘id’ =&gt; {id}, ‘wd’ =&gt; {wd}], 若 options 為 array, 即 {–id=*}, 則輸出為 nested array # Prompting For Input以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $name = $this-&gt;ask(&#x27;What is your name?&#x27;);&#125; Answer:當使用者輸入 command 時會跳出詢問視窗, 讓 user 輸入 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $password = $this-&gt;secret(&#x27;What is the password?&#x27;);&#125; Answer:當使用者輸入 command 時會跳出詢問視窗, 讓 user 輸入, 與 ask() 不同之處在於 secret() 會隱藏使用者的輸入 # Asking For Confirmation以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; if ($this-&gt;confirm(&#x27;Do you wish to continue?&#x27;)) &#123; // &#125;&#125; Answer:當使用者輸入 command 時跳出詢問視窗, 讓使用者輸入, 默認為 false, 若輸入 y or yes 則為 true # Auto-Completion以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $name = $this-&gt;anticipate(&#x27;What is your name?&#x27;, [&#x27;Taylor&#x27;, &#x27;Dayle&#x27;]);&#125; Answer:當使用者輸入 command 時會跳出詢問視窗, 讓使用者輸入, 當使用者輸入 T 會自動提示 Taylor, 輸入 D 則自動提示 Dayle, 使用者可輸入其他, arg2 只是提示功能 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $name = $this-&gt;anticipate(&#x27;What is your name?&#x27;, function() &#123; &#125;);&#125; Answer:當使用者輸入 command 時會跳出詢問視窗, 讓使用者輸入, 使用者每輸入一個字, 都會 pass 到 closure, 並依照 closure 內的邏輯輸出提示詞 # Multiple Choice Questions以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $name = $this-&gt;choice( &#x27;What is your name?&#x27;, [&#x27;Taylor&#x27;, &#x27;Dayle&#x27;], $defaultIndex, $maxAttempts = null, $allowMultipleSelections = false );&#125; Answer:當使用者輸入 command 時會跳出 arg2 的選項讓使用者輸入, 即 Taylor 或 Dayle可設定 default index, 當使用者沒輸入時, 會將 default 值設為指定的 index$maxAttempts 顧名思義, 最大嘗試次數$allowMultipleSelections 即可選取多個選項 # Writing Output以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $this-&gt;info(&#x27;Display this on the screen&#x27;);&#125; Answer:顯示文字到 console, 文字為綠色 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $this-&gt;error(&#x27;Something went wrong!&#x27;);&#125; Answer:顯示文字到 console, 文字為紅色 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $this-&gt;line(&#x27;Display this on the screen&#x27;);&#125; Answer:顯示文字到 console, 文字為 plain text 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $this-&gt;newLine(); // Write three blank lines... $this-&gt;newLine(3);&#125; Answer:顯示空行顯示 3 個空行 # Table Layouts以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $headers = [&#x27;Name&#x27;, &#x27;Email&#x27;]; $users = App\\Models\\User::all([&#x27;name&#x27;, &#x27;email&#x27;])-&gt;toArray(); $this-&gt;table($headers, $users);&#125; Answer:當執行 console command 時, 以 table 的方式顯示訊息在 console, 使用 table method, arg1 為欄位名稱, arg2 為欄位內容 # Progress Bars以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $users = App\\Models\\User::all(); $bar = $this-&gt;output-&gt;createProgressBar(count($users)); $bar-&gt;start(); foreach ($users as $user) &#123; $this-&gt;performTask($user); $bar-&gt;advance(); &#125; $bar-&gt;finish();&#125; Answer:更多 progress bar 的應用, 可以參閱Symfony Progress Bar component 文件&lt;?php// 當使用者執行 console command 時, 可以用 process bar 顯示進度public function handle()&#123; $users = App\\Models\\User::all(); // 這邊建立了 progress bar, 並指定有幾個 steps $bar = $this-&gt;output-&gt;createProgressBar(count($users)); // progress bar 開始 $bar-&gt;start(); foreach ($users as $user) &#123; $this-&gt;performTask($user); // 每跑過一個 user, 都 advance 一次 $bar-&gt;advance(); &#125; // progress bar 結束 $bar-&gt;finish();&#125; # Registering Command以下位於 …/app/console/kernel 的 Laravel example code 的意思是？ Example:&lt;?phpprotected function commands()&#123; $this-&gt;load(__DIR__.&#x27;/Commands&#x27;); $this-&gt;load(__DIR__.&#x27;/MoreCommands&#x27;); // ...&#125; Answer:預設會註冊 app/Console/Commands 資料夾內的 command, 如果 command 是寫在其他資料夾, 也可以加在 kernel class 中的 commands method 內 以下位於 …/app/console/kernel 的 Laravel example code 的意思是？ Example:&lt;?php protected $commands = [ Commands\\SendEmails::class ]; Answer:Laravel 預設會註冊位於 Console/Commands 資料夾內的 command, 除了新增註冊的資料夾位址外, 也可以在 Kernel class 的 commands property 中註冊單一 command # Programmatically Executing Commands以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/foo&#x27;, function () &#123; $exitCode = Artisan::call(&#x27;email:send&#x27;, [ &#x27;user&#x27; =&gt; 1, &#x27;--queue&#x27; =&gt; &#x27;default&#x27; ]); //&#125;); Answer:可以從 CLI 之外的地方執行 artisan command, 使用 Artisan facade 的 call method, arg1 為 command name 或 class name 都可, arg2 為帶入該 command 的 parameters 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/foo&#x27;, function () &#123; $exitCode = Artisan::call(&#x27;email:send 1 --queue=default&#x27;); //&#125;); Answer:可以從 CLI 之外的地方執行 artisan command, 使用 Artisan facade 的 call method, 可使用 arg2 來帶入該 command 的 parameters, 也可直接在 arg1 輸入全部 command, 就像在 CLI 輸入一樣 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/foo&#x27;, function () &#123; Artisan::queue(&#x27;email:send&#x27;, [ &#x27;user&#x27; =&gt; 1, &#x27;--queue&#x27; =&gt; &#x27;default&#x27; ])-&gt;onConnection(&#x27;redis&#x27;)-&gt;onQueue(&#x27;commands&#x27;); //&#125;); Answer:將 Artisan command 排入 queue, 由 queue worker 去執行, 並指定 connection 以及 queue name # Passing Array Values以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/foo&#x27;, function () &#123; $exitCode = Artisan::call(&#x27;email:send&#x27;, [ &#x27;user&#x27; =&gt; 1, &#x27;--id&#x27; =&gt; [5, 13] ]);&#125;); Answer:使用 Artisan facade 在 CLI 之外的地方執行 command如果該 command 定義了 array options 或 array arguments, 可使用 array 的方式帶入 # Passing Boolean Values以下的 Laravel example code 的意思是？ Example:&lt;?php$exitCode = Artisan::call(&#x27;migrate:refresh&#x27;, [ &#x27;--force&#x27; =&gt; true,]); Answer:如果 command 的 options 為 boolean 類型, 可透過 ‘options’ =&gt; ‘boolean’ 的方式帶入 Calling Commands From Other Commands以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $this-&gt;call(&#x27;email:send&#x27;, [ &#x27;user&#x27; =&gt; 1, &#x27;--queue&#x27; =&gt; &#x27;default&#x27; ]); //&#125; Answer:在 custom command 中, 利用 call() 執行另外一個 command 以下位於 custom command class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; $this-&gt;callSilent(&#x27;email:send&#x27;, [ &#x27;user&#x27; =&gt; 1, &#x27;--queue&#x27; =&gt; &#x27;default&#x27; ]); //&#125; Answer:在 custom command 中, 利用 call() 執行另外一個 command, 並且不顯示其輸出 # Stub Customization以下的 Laravel example command 的意思是？ Example:&lt;?phpphp artisan stub:publish Answer:Artisan console make command 被用來建立不同的 class, 像是 controllers, jobs, migrations, 以及 tests, Laravel 會根據你所輸入的 input, 使用 “stub” file 來產生這些 class如果你希望可以對 stub 檔案做更動的話, 可使用 stub:publish # EventsLaravel Artisan 中, 會產生哪三個 event? ArtisanStarting CommandStarting CommandFinished Laravel Artisan event 中, ArtisanStarting 什麼時候觸發?當 Artisan 開始執行時 Laravel Artisan event 中, CommandStarting 什麼時候觸發?在 command 執行之前 Laravel Artisan event 中, CommandFinished 什麼時候觸發?當 command 結束執行時","link":"/zh-tw/laravel-digging-deeper-artisan-console/"},{"title":"Laravel - Digging Deeper - Broadcasting (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Introduction# ConfigurationLaravel 中, 有關 broadcast 的設定都在哪一個檔案中？config/broadcasting.php Laravel 中, 要啟動 BroadcastServiceProvider, 預設要到 哪個檔案 的 哪個 property 去 uncomment 這個 provider?config/app.php Laravel Broadcast 中, Laravel Echo 會存取 session 中的什麼東西？CSRF token Laravel Broadcast 中, Laravel Echo 預設會存取 session 當中的 CSRF token, 所以要在 HTML 的哪一個 tag 中載入 csrf-token？meta tag Laravel 中, 當使用 broadcast 時, 以下的 blade view example 的意思是？ Example:&lt;?php&lt;meta name=&quot;csrf-token&quot; content=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt; Answer:Laravel Broadcast 中, 預設 Laravel Echo 會存取 session 當中的 CSRF token, 並以此跟 server 驗證, 所以當不是使用 SPA 時, 需在 meta tag 內置入 csrf_token # Driver Prerequisites# Pusher ChannelsLaravel Broadcast 中, 如果是使用 Pusher Channels 的方式, 需要另外安裝 sdk 嗎？需要 composer require pusher/pusher-php-server &quot;~4.0&quot; 解釋以下的 Laravel Echo javascript code Example:import Echo from &quot;laravel-echo&quot;;window.Pusher = require(&#x27;pusher-js&#x27;);window.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;&#125;); Answer:// 載入 Echoimport Echo from &quot;laravel-echo&quot;;// 載入 pusher-jswindow.Pusher = require(&#x27;pusher-js&#x27;);// 定義 echowindow.Echo = new Echo(&#123; // channel name broadcaster: &#x27;pusher&#x27;, // channel key key: &#x27;your-pusher-channels-key&#x27;&#125;); Laravel Broadcast 中, 若使用 Pusher Channel, 那以下的 .env example 該填入？ Example:&lt;?phpBROADCAST_DRIVER=這邊要填什麼？ Answer:&lt;?phpBROADCAST_DRIVER=pusher # RedisLaravel Broadcast 中, 當我使用 Redis 時, 可使用哪兩種方式安裝 Redis? PECL Composer Laravel Broadcast 中, 當我使用 Composer 安裝 Redis 時, 可以使用哪個 CLI?composer require predis/predis Laravel Broadcast 中, 如果我使用 Redis 來 Broadcast, 那以下的 .env example 當中該填入什麼？ Example:&lt;?phpBROADCAST_DRIVER=這裡要填什麼 Answer:&lt;?phpBROADCAST_DRIVER=redis Laravel Broadcast 中, 如果我使用 Redis 來 Broadcast, 我必須要將 Redis 跟哪一種類型的 server 做配對？WebSocket # Socket.IOLaravel Broadcast 中, 如果我使用 Redis 配對 socket.io server, 前端需要安裝什麼？Socket.IO Javascript client library npm install --save socket.io-client Laravel Broadcast 中, 解釋以下 JavaScript example Example:import Echo from &quot;laravel-echo&quot;window.io = require(&#x27;socket.io-client&#x27;);window.Echo = new Echo(&#123; broadcaster: &#x27;socket.io&#x27;, host: window.location.hostname + &#x27;:6001&#x27;&#125;); Answer:// import Larave Echoimport Echo from &quot;laravel-echo&quot;// require socket.io-clientwindow.io = require(&#x27;socket.io-client&#x27;);window.Echo = new Echo(&#123; // broadcast type broadcaster: &#x27;socket.io&#x27;, // host host: window.location.hostname + &#x27;:6001&#x27;&#125;); Laravel Broadcast 中, 如果我使用 Redis, 那我安裝什麼 server 在後端？socket.IO server # Concept Overview# Using An Example Application# The ShouldBroadcast Interface以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Events;class ShippingStatusUpdated implements ShouldBroadcast&#123; public $update;&#125; Answer:在 event class implement ShouldBroadcast Laravel Broadcast 中, 以下 broadcastOn method 的用途是？ Example: &lt;?php/** * Get the channels the event should broadcast on. * * @return \\Illuminate\\Broadcasting\\PrivateChannel */public function broadcastOn()&#123; return new PrivateChannel(&#x27;order.&#x27;.$this-&gt;update-&gt;order_id);&#125; Answer:return 這個 event 需要 broadcast 的 channel # Authorizing Channels解釋以下的 Laravel example Example:&lt;?phpBroadcast::channel(&#x27;order.&#123;orderId&#125;&#x27;, function ($user, $orderId) &#123; return $user-&gt;id === Order::findOrNew($orderId)-&gt;user_id;&#125;); Answer:&lt;?php// Authorize channel, 驗證該 order 的建立者是否為該 userBroadcast::channel(&#x27;order.&#123;orderId&#125;&#x27;, function ($user, $orderId) &#123; return $user-&gt;id === Order::findOrNew($orderId)-&gt;user_id;&#125;); Laravel Broadcast 中, 當我 authorize channel 時, 以下的 closure 的回傳值是什麼？ Example:&lt;?phpBroadcast::channel(&#x27;order.&#123;orderId&#125;&#x27;, function ($user, $orderId) &#123; // 這邊要回傳？&#125;); Answer:boolean # Listening For Event BroadcastsLaravel Broadcast 中, 解釋以下 JavaScript example Example: Echo.private(`order.$&#123;orderId&#125;`) .listen(&#x27;ShippingStatusUpdated&#x27;, (e) =&gt; &#123; console.log(e.update); &#125;); Answer: // 監聽 order.$&#123;orderId&#125; channel 中的 &#x27;ShippingStatusUpdated&#x27; 事件, 並 console.log 名為 update 的 public propertyEcho.private(`order.$&#123;orderId&#125;`) .listen(&#x27;ShippingStatusUpdated&#x27;, (e) =&gt; &#123; console.log(e.update); &#125;); # Defining Broadcast EventsLaravel Broadcast 中, 一個 event 可以被廣播到多個 channel 嗎？可以 Laravel Broadcast 中, 有哪三種 channel interface? Channel PrivateChannel PresenceChannel Laravel Broadcast 中, public channel 是屬於哪一種 channel interface?Channel Laravel 中, PrivateChannels 以及 PresenceChannels 屬於 private channel 還是 public channel?private Laravel 中, PrivateChannels 以及 PresenceChannels 需要通過 channel authorization 嗎？需要 # Broadcast Name以下的 Laravel example command 的意思是？ Example:&lt;?phpnamespace App\\Events;use App\\User;use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;use Illuminate\\Queue\\SerializesModels;class ServerCreated implements ShouldBroadcast&#123; use SerializesModels; public $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function broadcastAs() &#123; return &#x27;server.created&#x27;; &#125;&#125; Answer:自定義 event name Laravel 中, 當我使用 broadcastAs() method 時, 那在註冊 listener 時, 要注意什麼？要在 event name 的前面加一個 . Laravel 中, 當我使用 broadcastAs() method 時, 那在註冊 listener 時, 要在 event name 前加個 . 如下, 為何？？ Example:&lt;?php.listen(&#x27;.server.created&#x27;, function (e) &#123; ....&#125;); Answer:因為加了 . 之後, Echo 就不會自己在前面加上 namespace # Broadcast DataLaravel Broadcast 中, 當我廣播一個 event 時, 預設會將什麼資料帶過去？該 event 中的所有 public property Laravel Broadcast 中, 當我廣播一個 event 時, 如果我有一個 public property 是 User model 的 instance, 那到了前端會變成什麼資料？一個 object Laravel Broadcast 中, 當我廣播一個 event 時, 如果我要控管傳送過去的資料, 那我可以使用哪一個 method?broadcastWith() method 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Events;class ServerCreated implements ShouldBroadcast&#123; use SerializesModels; public $user; public function __construct(User $user) &#123; $this-&gt;user = $user; &#125; public function broadcastWith() &#123; return [&#x27;id&#x27; =&gt; $this-&gt;user-&gt;id]; &#125;&#125; Answer:定義 broadcast 時帶過去的資料 key / value # Broadcast QueueLaravel 中, Broadcast queue 預設是使用哪一組 queue?預設於 queue.php 檔案中的 queue Laravel 中, 如果我想要自定義 broadcast 使用到的 queue, 可以在該 event 中新增 哪一個 property?$broadcastQueue property Laravel 中, 如果我想要使用 sync queue, 而不使用預設的, 那請回答以下 example 中的問題 Example:&lt;?phpuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;class ShippingStatusUpdated implements 這裡該填入？&#123; //&#125; Answer:&lt;?phpuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;class ShippingStatusUpdated implements ShouldBroadcastNow&#123; //&#125; # Broadcast ConditionsLaravel 中, 如果我想要當某些條件成立時, 我才 broadcast event, 那我可以使用 哪一個 method ?broadcastWhen() method Laravel 中, 如果我想要定義, 當 value property 的值大於 100 時, 我才 broadcast event, 那請回答以下 example 中的問題 Example:&lt;?phppublic function broadcastWhen()&#123; // 這裡該 return？&#125; Answer:&lt;?phppublic function broadcastWhen()&#123; return $this-&gt;value &gt; 100;&#125; # Authorizing ChannelsLaravel broadcast 中, private channel 要被監聽之前, 需要經過 Laravel authorize 嗎？需要哦 Laravel broadcast中, Laravel Echo 會自動地幫我們發 authorization request 嗎？會哦 # Defining Authorization RoutesLaravel broadcast 中, 哪個 class 的 哪個 method 負責註冊 /broadcasting/auth 來處理 authorization request? Broadcast class routes() method Laravel broadcast 中, 當我使用 Broadcast::routes 時, 預設會使用哪一個 middleware group?web middleware 以下的 Laravel example code 的意思是？ Example:&lt;?phpBroadcast::routes([&#x27;middleare&#x27; =&gt; &#x27;api&#x27;]); Answer:Laravel Broadcast 預設會使用 web middleware group, 如果要使用 api middleware group 的話, 可在 routes() 中指定 # Customizing The Authorization EndpointLaravel Broadcast 中, Laravel Echo 預設是使用哪一個 endpoint 來 authorize channel?/broadcasting/auth Laravel Broadcast 中, Laravel Echo 預設使用 /broadcasting/auth endpoint 來 authorize channel, 如果我要自定義為 /custom/endpoint/auth 的話, 在以下的 example 中可以怎麼做？ Example:&lt;?phpwindow.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;, // 這邊該填入？&#125;); Answer:&lt;?phpwindow.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;, authEndpoint: &#x27;/custom/endpoint/auth&#x27;&#125;); # Defining Authorization Callbacks以下的 Laravel example code 的意思是？ Example:&lt;?phpBroadcast::channel(&#x27;channelName&#x27;, Authorization callback); Answer:Broadcast channel, arg1 接受 channel name, arg2 接受驗證 callback Laravel Broadcast 中, Broadcast::channel method 的 authorization callback 需 return 什麼？boolean Laravel Broadcast 中, Broadcast::channel method 的 callback 接收哪兩個參數如下 example？ Example:&lt;?phpBroadcast::channel(&#x27;order.&#123;orderId&#125;&#x27;, function (這裡是？, 這裡又是？) &#123; return $user-&gt;id === Order::findOrNew($orderId)-&gt;user_id;&#125;); Answer:&lt;?phpBroadcast::channel(&#x27;order.&#123;orderId&#125;&#x27;, function ($authenticatedUser, $wildcard) &#123; return $user-&gt;id === Order::findOrNew($orderId)-&gt;user_id;&#125;); # Authorization Callback Model BindingLaravel Broadcast 中, 在以下的 example 如果我想要以 model binding 的方式 bind $order, 我可以怎麼做？ Example:&lt;?phpuse App\\Order;Broadcast::channel(&#x27;order.&#123;order&#125;&#x27;, function ($user, 要怎麼做呢？) &#123; return $user-&gt;id === $order-&gt;user_id;&#125;); Answer:&lt;?phpuse App\\Order;Broadcast::channel(&#x27;order.&#123;order&#125;&#x27;, function ($user, Order $order) &#123; return $user-&gt;id === $order-&gt;user_id;&#125;); # Authorization Callback AuthenticationLaravel Broadcast 中, private 以及 presence channel 是透過什麼來 authenticate current user?Application’s default authentication guard Laravel Broadcast 中, 如果 user authentication 沒過, 那 authorization callback 會被執行嗎?不會 Laravel Broadcast 中, 如果我要指定以下 example 中的 guards, 假設為 ‘web’, 以及 ‘admin’, 可以怎麼做？ Example:&lt;?phpBroadcast::channel(&#x27;channel&#x27;, function () &#123; // ...&#125;, 可以怎麼做呢？); Answer:&lt;?phpBroadcast::channel(&#x27;channel&#x27;, function () &#123; // ...&#125;, [&#x27;guards&#x27; =&gt; [&#x27;web&#x27;, &#x27;admin&#x27;]]); # Defining Channel ClassesLaravel Broadcast 中, 如果我們的應用使用了大量不同的 channel, 那在 routes/channels.php 檔案中可能被滿滿的 closure 所佔據, 所以我們可以使用 CLI 來建立專屬的 channel class, 該怎麼做呢？php artisan make:channel ChannelName Laravel Broadcast 中, 如果我們的應用使用了大量不同的 channel, 那在 routes/channels.php 檔案中可能被滿滿的 closure 所佔據, 所以我們可以使用 CLI 來建立專屬的 channel class, 建立好的 channel, 要在哪裡註冊呢？routes/channels.php 以下的 Laravel example code 的意思是？ Example:&lt;?php Answer: 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Broadcasting\\OrderChannel;Broadcast::channel(&#x27;order.&#123;order&#125;&#x27;, OrderChannel::class); Answer:將存取 channel order.{order} 的驗證 closure 寫成一個 class OrderChannel Laravel Broadcast 中, 如果我們的應用使用了大量不同的 channel, 那在 routes/channels.php 檔案中可能被滿滿的 closure 所佔據, 所以我們可以使用 CLI 來建立專屬的 channel class, 建立好的 channel, 建立好的 channel class 中, 原本我們寫在 closure 中的 authorization logic 要寫在 channel class 中的哪個 method 呢？join method 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Broadcasting;use App\\Order;use App\\User;class OrderChannel&#123; public function __construct() &#123; // &#125; public function join(User $user, Order $order) &#123; return $user-&gt;id === $order-&gt;user_id; &#125;&#125; Answer:在自定義的 channel class 中, 使用 join method 來定義 authorization logic, 即驗證 authenticated user 是否可存取該 channel 的 logic # Broadcasting EventsLaravel Broadcast 中, 如果我要廣播一個 event 的話, 可以使用哪兩個 method? event function broadcast function # Only To OthersLaravel Broadcast 中, 如果我要廣播一個 event, 我可以使用 event function 或是 broadcast function, 兩者的差異是？broadcast function 可以接 toOthers method Laravel Broadcast 中, toOthers method 的使用情境是？當 client 發出一個 request, 這個 request 的 response 已經做了一件事, 如果這時候還收到 broadcast, 那就會同一件事情做了兩次 Laravel Broadcast 中, toOthers method 的用途是？不會 broadcast 該 event 給 authenticated user Laravel Broadcast 中, 如果要使用 toOthers method 的話, 必須要 use 哪一個 interface?Illuminate\\Broadcasting\\InteractsWithSockets interface # ConfigurationLaravel Broadcast 中, 當使用 toOthers method 時, Laravel 是從哪裡判斷哪一個 connection 不要 broadcast 事件？X-Socket-ID header Laravel Broadcast 中, 當我使用 Vue 以及 Axios 時, 會自動附加哪一個 header, 而單純使用 JavaScript 不會附加？X-Socket-ID header Laravel Broadcast 中, 當我使用 Vue 以及 Axios 時, 會自動 X-Socket-ID header, 但使用 JavaScript 時並不會自動附加, 這時候可以從哪一個 method 取得 X-Socket-ID?Echo.socketId # Receiving Broadcasts# Installing Laravel EchoLaravel Broadcast 中, 如果我要使用 npm CLI 來安裝 Laravel Echo 以及 pusher-js package 時, 可以怎麼做？npm install --save laravel-echo pusher-js Laravel Broadcast 中, 如果我已經安裝好 Laravel Echo, 可以在哪個檔案中建立一個 Echo instance?resources/js/bootstrap.js 以下的 Laravel example code 的意思是？ Example:window.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;, cluster: &#x27;eu&#x27;, forceTLS: true&#125;); Answer:強制啟動 HTTPS 連線 # Using An Existing Client InstanceLaravel Broadcast 中, 當我使用 Laravel Echo 時, 如果我已經有 Pusher Channels 或 Socket.io client instance, 而我想要 Echo 去使用它們, 那在以下的 example 中, 我可以怎麼做？ Example:&lt;?phpconst client = require(&#x27;pusher-js&#x27;);window.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;, // 這裡可以使用？&#125;); Answer:&lt;?phpconst client = require(&#x27;pusher-js&#x27;);window.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;, client: client&#125;); # Listening For Events以下的 Laravel example code 的意思是？ Example:Echo.channel(&#x27;orders&#x27;) .listen(&#x27;OrderShipped&#x27;, (e) =&gt; &#123; console.log(e.order.name); &#125;); Answer:監聽 orders channel, OrderShipped event, listener 的邏輯為 console.log(e.order.name) Laravel Broadcast 中, 當我使用 Laravel Echo 時, 如果我要監聽一個 event, 在下面的 example 中可以怎麼做？ Example:Echo.channel(&#x27;orders&#x27;) .這裡使用哪一個method(&#x27;OrderShipped&#x27;, (e) =&gt; &#123; console.log(e.order.name); &#125;); Answer:Echo.channel(&#x27;orders&#x27;) .listen(&#x27;OrderShipped&#x27;, (e) =&gt; &#123; console.log(e.order.name); &#125;); Laravel Broadcast 中, 當我使用 Laravel Echo 時, 如果我要監聽一個 private channel, 在下面的 example 中可以怎麼做？ Example:Echo.這裡使用哪一個mehtod(&#x27;orders&#x27;) .listen(&#x27;event1&#x27;) .listen(&#x27;event2&#x27;) .listen(&#x27;event3&#x27;); Answer:Echo.private(&#x27;orders&#x27;) .listen(&#x27;event1&#x27;) .listen(&#x27;event2&#x27;) .listen(&#x27;event3&#x27;); Laravel Broadcast 中, 當我使用 Laravel Echo 時, 如果我要監聽多個 event, 在下面的 example 中可以怎麼做？ Example:Echo.private(&#x27;orders&#x27;) Answer:Echo.private(&#x27;orders&#x27;) .listen(&#x27;event1&#x27;) .listen(&#x27;event2&#x27;) .listen(&#x27;event3&#x27;); # Leaving A ChannelLaravel Broadcast 中, 如果我要離開一個 public channel order, 可以使用 Echo 的哪個 method?Echo.leaveChannel(&#x27;order&#x27;); 以下的 Laravel-Echo example code 的意思是？ Example:Echo.leave(&#x27;channel&#x27;); Answer:離開所有的 channel, 不論是 public, private, 或 presence # NamespacesLaravel Broadcast 中, Laravel Echo 會自動的附加 namespace, 這個 namespace 是？App\\Events Laravel Broadcast 中, Laravel Echo 會自動的附加 namespace, 如果我想要自定義這個 namespace, 假設為, App\\SpecialEvents 在以下的 example 中, 可以怎麼做？ Example: window.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;,&#125;); Answer: window.Echo = new Echo(&#123; broadcaster: &#x27;pusher&#x27;, key: &#x27;your-pusher-channels-key&#x27;, namespace: &#x27;App.SpecialEvents&#x27;&#125;); 以下的 Laravel example code 的意思是？ Example:Echo.channel(&#x27;orders&#x27;) .listen(&#x27;.App\\\\SpecialEvents\\\\Class&#x27;, (e) =&gt; &#123; // &#125;); Answer:Laravel Echo 會自動的附加 namespace, 如果我想要自定義 listen event class 路徑, 可在前面加個 . # Presence Channels# Authorizing Presence ChannelsLaravel Broadcast 中, Presence channel 跟 Private channel 的差別在於？Presence channel 可以暴露自己的以及獲得同個 channel 內其他 user 的資訊 Laravel Broadcast 中, 當我使用 Presence channel 時, authorization rule 驗證通過後, 需回傳？該 user 的 data Laravel Broadcast 中, 當我使用 Presence channel 時, authorization rule 驗證如果沒通過, 需回傳？false 或 null Laravel Broadcast 中, 以下的 example 中的 channel 是 public, private, 或 presence? Example:&lt;?phpBroadcast::channel(&#x27;chat.&#123;roomId&#125;&#x27;, function ($user, $roomId) &#123; if ($user-&gt;canJoinRoom($roomId)) &#123; return [&#x27;id&#x27; =&gt; $user-&gt;id, &#x27;name&#x27; =&gt; $user-&gt;name]; &#125;&#125;); Answer: Presence channel # Joining Presence Channels以下的 Javascript example code 的意思是? Example:Echo.join(`chat.$&#123;roomId&#125;`) .here((users) =&gt; &#123; // &#125;); Answer:加入一個 presence channel Laravel Broadcast 中, 以下的 here method 是在什麼時候執行 closure? Example:Echo.join(`chat.$&#123;roomId&#125;`) .here((users) =&gt; &#123; // &#125;); Answer:當該使用者成功加入頻道時 Laravel Broadcast 中, 以下的 example 中的 joining 內的 closure 會在什麼時機點執行？ Example:Echo.join(`chat.$&#123;roomId&#125;`) .joining((user) =&gt; &#123; console.log(user.name); &#125;); Answer:當有新的 user 加入這個 channel 時 Laravel Broadcast 中, 以下的 example 中的 leaving 內的 closure 會在什麼時機點執行？ Example:Echo.join(`chat.$&#123;roomId&#125;`) .leaving((user) =&gt; &#123; console.log(user.name); &#125;); Answer:當有 user 離開這個 channel 時 # Broadcasting To Presence Channels以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function broadcastOn()&#123; return new PresenceChannel(&#x27;room.&#x27;.$this-&gt;message-&gt;room_id);&#125; Answer:在指定的 event 中, 使用 broadcastOn method 來定義該 event 會被 broadcast 到哪個 channel, 使用 PresenceChannel method 來 broadcast 到 presence channel 以下的 Laravel example code 的意思是？ Example:&lt;?phpEcho.join(`chat.$&#123;roomId&#125;`) .here(...) .joining(...) .leaving(...) .listen(&#x27;NewMessage&#x27;, (e) =&gt; &#123; // &#125;); Answer:監聽該 channel 中的 NewMessage presence event # Client EventsLaravel Broadcast 中, client event 可以用在什麼情境上？當使用者在輸入文字的時候, 另一邊的使用者可以看到正在輸入中 Laravel Broadcast 中, client event 的特性是？client 端可以監聽 client 端的 event, 不需透過 server 端 以下的 Laravel example code 的意思是？ Example:Echo.private(&#x27;chat&#x27;) .whisper(&#x27;typing&#x27;, &#123; name: this.user.name &#125;); Answer:使用 Laravel Echo 在 chat private channel 中送出一個 typing client event 以下的 Laravel example code 的意思是？ Example:Echo.private(&#x27;chat&#x27;) .listenForWhisper(&#x27;typing&#x27;, (e) =&gt; &#123; console.log(e.name); &#125;); Answer:使用 Laravel Echo, 監聽 typing client event, 並執行 closure 內的邏輯 # Notifications此章節同 Notification Documentation","link":"/zh-tw/laravel-digging-deeper-broadcasting/"},{"title":"Laravel - Digging Deeper - Cache (官方文件原子化翻譯文件)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Configuration# Driver Prerequisites# Database以下的 Laravel example code 的意思是？ Example:&lt;?phpSchema::create(&#x27;cache&#x27;, function ($table) &#123; $table-&gt;string(&#x27;key&#x27;)-&gt;unique(); $table-&gt;text(&#x27;value&#x27;); $table-&gt;integer(&#x27;expiration&#x27;);&#125;); Answer:當使用的 Cache driver 為 database 時, 需建立 cache table 以下的 Laravel example CLI 的意思是？ Example:php artisan cache:table Answer:當使用的 Cache driver 為 database 時, 需建立 cache table # MemcachedLaravel 中, 當使用 Memcached 時, 需要安裝套件嗎？需要 PECL 的 package, 可參考 Stackoverflow, ServerPilot 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;memcached&#x27; =&gt; [ &#x27;servers&#x27; =&gt; [ [ &#x27;host&#x27; =&gt; env(&#x27;MEMCACHED_HOST&#x27;, &#x27;127.0.0.1&#x27;), // &#x27;host&#x27; =&gt; &#x27;/var/run/memcached/memcached.sock&#x27;, &#x27;port&#x27; =&gt; env(&#x27;MEMCACHED_PORT&#x27;, 11211), &#x27;weight&#x27; =&gt; 100, ], ],], Answer:當使用 memcached 為 cache driver 時, 可在 config/cache.php 自定義 host, post, weight也可以使用 sock # RedisLaravel 中, 若要使用 redis, 可安裝哪兩種套件 PhpRedis PHP extension via PECL predis/predis via Composer # Cache Usage# Obtaining A Cache Instance以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Support\\Facades\\Cache;class UserController extends Controller&#123; public function index() &#123; $value = Cache::get(&#x27;key&#x27;); // &#125;&#125; Answer:使用 Cache::get() 取得 cache 中該 key 的 value # Accessing Multiple Cache Stores以下的 Laravel example code 的意思是？ Example:&lt;?php$value = Cache::store(&#x27;file&#x27;)-&gt;get(&#x27;foo&#x27;);Cache::store(&#x27;redis&#x27;)-&gt;put(&#x27;bar&#x27;, &#x27;baz&#x27;, 600); // 10 Minutes Answer:Laravel 支援多種 stores, 像是 apc, redis, database, array, memcached, 等等..使用 store() 可以指定接下來要使用的 store, 若無指定則使用 default store存到 redis cache, key 為 bar, value 為 baz, 有效時間為 600 seconds Retrieving Items From The Cache以下的 Laravel example code 的意思是？ Example:&lt;?php$value = Cache::get(&#x27;key&#x27;);$value = Cache::get(&#x27;key&#x27;, &#x27;default&#x27;); Answer:從 default cache 中取得指定 key 的 value, 若無此 key 則回傳 null從 default cache 中取得指定 key 的 value, 若無此 key 則回傳 value &#39;default&#39; 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = Cache::get(&#x27;key&#x27;, function () &#123; return DB::table(...)-&gt;get();&#125;); Answer:從 default cache 中取得指定 key 的 value, 若無此 key 則執行 closure, 並回傳其 return value # Checking For Item Existence以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Cache::has(&#x27;key&#x27;)) &#123; //&#125; Answer:判斷 default cache 中, 該 &#39;key&#39; 是否存在 # Incrementing / Decrementing Values以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::increment(&#x27;key&#x27;);Cache::increment(&#x27;key&#x27;, $amount);Cache::decrement(&#x27;key&#x27;);Cache::decrement(&#x27;key&#x27;, $amount); Answer:increase 或 decrease 指定 &#39;key&#39; 的 value, arg2 為要 increase / decrease 的量 # Retrieve &amp; Store以下的 Laravel example code 的意思是？ Example:&lt;?php$value = Cache::remember(&#x27;users&#x27;, $seconds, function () &#123; return DB::table(&#x27;users&#x27;)-&gt;get();&#125;); Answer:嘗試從 default cache 中取得 key &#39;users&#39; 的 value, 若 key &#39;users&#39; 不存在, 則執行 closure, 取得 closure 的回傳值, 同時將其存到 cache 中, 有效時間為 $seconds 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = Cache::rememberForever(&#x27;users&#x27;, function () &#123; return DB::table(&#x27;users&#x27;)-&gt;get();&#125;); Answer:嘗試從 default cache 中取得 key &#39;users&#39; 的 value, 若 key &#39;users&#39; 不存在, 則執行 closure, 取得 closure 的回傳值, 同時將其存到 cache 中, 沒有失效期限 # Retrieve &amp; Delete以下的 Laravel example code 的意思是？ Example:&lt;?php$value = Cache::pull(&#x27;key&#x27;); Answer:嘗試從 default cache 中取得 key &#39;key&#39; 的 value, 並將此 key / value 從 cache 中清除, 若 key &#39;users&#39; 不存在, 則回傳 null # Storing Items In The Cache以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::put(&#x27;key&#x27;, &#x27;value&#x27;, $seconds = 10); Answer:在 default cache 中存入 key / value, 有效期限為 10 秒, 如果 $seconds 未定義, 將會無限期儲存 以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::put(&#x27;key&#x27;, &#x27;value&#x27;, now()-&gt;addMinutes(10)); Answer:在 default cache 中存入 key / value, 有效期限為從現在往後算起的十分鐘後, 若 arg3 未指定, 將會無限期儲存 # Store If Not Present以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::add(&#x27;key&#x27;, &#x27;value&#x27;, $seconds); Answer:如果 key 在 default cache 中不存在, 則新增 key / value / 有效時間, 如果真的有新增, 會回傳 true, 否則 false # Storing Items Forever以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::forever(&#x27;key&#x27;, &#x27;value&#x27;); Answer:在 default cache 內新增一筆 key / value, 有效時間為永久, 但如果 Memcached driver, 當達到 size limit, 可能會刪除 forever 檔案 # Removing Items From The Cache以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::forget(&#x27;key&#x27;); Answer:從 default cache 內移除 key 為 &#39;key&#39; 這筆資料 以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::put(&#x27;key&#x27;, &#x27;value&#x27;, 0);Cache::put(&#x27;key&#x27;, &#x27;value&#x27;, -5); Answer:當指定有效期限為 負數 時, 也有刪除的效果 以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::flush(); Answer:刪除整個 default cache 的資料, 不會因為 prefix 而有所區隔, 會刪除整個 cache 內的資料 # The Cache Helper以下的 Laravel example code 的意思是？ Example:&lt;?php$value = cache(&#x27;key&#x27;); Answer:使用 cache function 取得 default cache 中指定的 key 的 value 以下的 Laravel example code 的意思是？ Example:&lt;?phpcache([&#x27;key&#x27; =&gt; &#x27;value&#x27;], $seconds);cache([&#x27;key&#x27; =&gt; &#x27;value&#x27;], now()-&gt;addMinutes(10)); Answer:使用 cache function, 當提供完整的參數: key / value / 有效時間, 會將此參數儲存到 default cache 以下的 Laravel example code 的意思是？ Example:&lt;?phpcache()-&gt;remember(&#x27;users&#x27;, $seconds, function () &#123; return DB::table(&#x27;users&#x27;)-&gt;get();&#125;); Answer:使用 cache function, 當沒有帶入 args 時, 會回傳一個 Illuminate\\Contracts\\Cache\\Factory instance試圖取出 key 為 users 的 value, 若不存在, 執行 closure, 並將 closure 回傳值存到 default cache 當中, 有效期限為 $seconds # Cache TagsLaravel Cache 中, Cache Tags 不支援哪幾種 driver?file, dynamodb, database # Storing Tagged Cache Items以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::tags([&#x27;people&#x27;, &#x27;artists&#x27;])-&gt;put(&#x27;John&#x27;, $john, $seconds);Cache::tags([&#x27;people&#x27;, &#x27;authors&#x27;])-&gt;put(&#x27;Anne&#x27;, $anne, $seconds); Answer:在 default cache 中存入 key John, value $john, 有效期限 seconds, 並 tag 這筆資料 [&#39;people&#39;, &#39;artists&#39;] # Accessing Tagged Cache Items以下的 Laravel example code 的意思是？ Example:&lt;?php$john = Cache::tags([&#x27;people&#x27;, &#x27;artists&#x27;])-&gt;get(&#x27;John&#x27;);$anne = Cache::tags([&#x27;people&#x27;, &#x27;authors&#x27;])-&gt;get(&#x27;Anne&#x27;); Answer:從 default cache 中取得 key John, tags [&#39;people&#39;, &#39;artists&#39;] 的資料 # Removing Tagged Cache Items以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::tags([&#x27;people&#x27;, &#x27;artists&#x27;])-&gt;put(&#x27;John&#x27;, $john, $seconds);Cache::tags([&#x27;people&#x27;, &#x27;authors&#x27;])-&gt;put(&#x27;Anne&#x27;, $anne, $seconds);Cache::tags([&#x27;people&#x27;, &#x27;authors&#x27;])-&gt;flush(); Answer:移除有著 tags people, authors 的 cache items, 所以 John 跟 Anne 都會被移除 以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::tags([&#x27;people&#x27;, &#x27;artists&#x27;])-&gt;put(&#x27;John&#x27;, $john, $seconds);Cache::tags([&#x27;people&#x27;, &#x27;authors&#x27;])-&gt;put(&#x27;Anne&#x27;, $anne, $seconds);Cache::tags(&#x27;authors&#x27;)-&gt;flush(); Answer:移除有著 tags authors 的 cache items, 所以 Anne 會被移除, John 不會 # Atomic Locks# Driver Prerequisites# Database以下的 Laravel example code 的意思是？ Example:&lt;?phpSchema::create(&#x27;cache_locks&#x27;, function ($table) &#123; $table-&gt;string(&#x27;key&#x27;)-&gt;primary(); $table-&gt;string(&#x27;owner&#x27;); $table-&gt;integer(&#x27;expiration&#x27;);&#125;); Answer:當欲使用 Cache Lock, 且 driver 為 database 時, 需要新增 cache lock 用的 table # Managing Locks以下的 Laravel example code 的意思是？ Example:&lt;?php$lock = Cache::lock(&#x27;foo&#x27;, 10);if ($lock-&gt;get()) &#123; // Lock acquired for 10 seconds... $lock-&gt;release();&#125; Answer:使用 Cache Lock, 將 key foo lock 10 秒後釋放, 這 10 秒內可以執行一些邏輯, 比如 transaction, 以避免 race condition 以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::lock(&#x27;foo&#x27;)-&gt;get(function () &#123; // Lock acquired indefinitely and automatically released...&#125;); Answer:取得 default cache 中的 foo 並 lock 該 key, 然後執行 closure, 執行完後自動 release 該 lock 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Contracts\\Cache\\LockTimeoutException;$lock = Cache::lock(&#x27;foo&#x27;, 10);try &#123; $lock-&gt;block(5); // Lock acquired after waiting maximum of 5 seconds...&#125; catch (LockTimeoutException $e) &#123; // Unable to acquire lock...&#125; finally &#123; optional($lock)-&gt;release();&#125; Answer:嘗試取得 default cache 內的 key foo 並 lock 10 秒, 如果 key 不可得, 會持續嘗試 5 秒, 若 5 秒過了仍然無法取得該 key, 會 throw LockTimeoutException, 如果有取得 lock, 執行完定義的邏輯後, 會 release 該 lock 以下的 Laravel example code 的意思是？ Example:&lt;?phpCache::lock(&#x27;foo&#x27;, 10)-&gt;block(5, function () &#123; // Lock acquired after waiting maximum of 5 seconds...&#125;); Answer:嘗試取得 default cache 中的 key foo 並 lock 10 秒, 如果 key 正被 lock 中, 會持續嘗試 5 秒取得 key, 若 5 秒仍沒取得, 會 throw LockTimeoutException, 若取得則會執行 closure, closure 執行完後會 release 該 key # Managing Locks Across Processes以下的 Laravel example code 的意思是？ Example:&lt;?php$podcast = Podcast::find($id);$lock = Cache::lock(&#x27;processing&#x27;, 120);if ($result = $lock-&gt;get()) &#123; ProcessPodcast::dispatch($podcast, $lock-&gt;owner());&#125;// job hander 當中Cache::restoreLock(&#x27;processing&#x27;, $this-&gt;owner)-&gt;release();Cache::lock(&#x27;processing&#x27;)-&gt;forceRelease(); Answer:取得 key 為 processing 的 lock 之後, 鎖住 120 秒, 然後將 $lock-&gt;owner() pass 到一個 job 當中, 之後可以在該 job 當中透過 lock owner release 該 lock, 或強制 release 該 lock 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Extensions;use Illuminate\\Contracts\\Cache\\Store;class MongoStore implements Store&#123; public function get($key) &#123;&#125; public function many(array $keys) &#123;&#125; public function put($key, $value, $seconds) &#123;&#125; public function putMany(array $values, $seconds) &#123;&#125; public function increment($key, $value = 1) &#123;&#125; public function decrement($key, $value = 1) &#123;&#125; public function forever($key, $value) &#123;&#125; public function forget($key) &#123;&#125; public function flush() &#123;&#125; public function getPrefix() &#123;&#125;&#125; Answer:透過 implement Illuminate\\Contracts\\Cache\\Store, 可自定義一個 Cache Store, 可參考 MemcachedStore 的 source code Laravel 中, 當我使用一個 extended Store 時, 可將自定義的 cache driver class 放在哪？可放在 app\\Extensions 資料夾中, 不過這只是官方建議, 實際上放哪都行 # Registering The Driver以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use App\\Extensions\\MongoStore;use Illuminate\\Support\\Facades\\Cache;use Illuminate\\Support\\ServiceProvider;class CacheServiceProvider extends ServiceProvider&#123; public function register() &#123; $this-&gt;app-&gt;booting(function () &#123; Cache::extend(&#x27;mongo&#x27;, function ($app) &#123; return Cache::repository(new MongoStore); &#125;); &#125;); &#125; public function boot() &#123; // &#125;&#125; Answer:在 AppServiceProvider 的 register() 中, 註冊自定義的 cache store, extend() 的 arg1 為 store name, arg2 為 closure, 必須 return 一個 Illuminate\\Cache\\Repository instance註冊成功後就可以到 config/cache.php 修改 driver name Events以下的 Laravel example code 的意思是？ Example:&lt;?phpprotected $listen = [ &#x27;Illuminate\\Cache\\Events\\CacheHit&#x27; =&gt; [ &#x27;App\\Listeners\\LogCacheHit&#x27;, ], &#x27;Illuminate\\Cache\\Events\\CacheMissed&#x27; =&gt; [ &#x27;App\\Listeners\\LogCacheMissed&#x27;, ], &#x27;Illuminate\\Cache\\Events\\KeyForgotten&#x27; =&gt; [ &#x27;App\\Listeners\\LogKeyForgotten&#x27;, ], &#x27;Illuminate\\Cache\\Events\\KeyWritten&#x27; =&gt; [ &#x27;App\\Listeners\\LogKeyWritten&#x27;, ],]; Answer:各種預設的 Cache EventsCacheHit: 當嘗試取得 cache 而有成功取得CacheMissed: 當嘗試取得 Cache 而沒取得, 透過 closure 取得的不算有取得, 所以一樣算 missedKeyForgotten: 使用 cache:forget()keyWritten: 成功寫入 cache","link":"/zh-tw/laravel-digging-deeper-cache/"},{"title":"Laravel - Digging Deeper - Events (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Registering Events &amp; Listeners以下位於 EventServiceProvider 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $listen = [ &#x27;App\\Events\\OrderShipped&#x27; =&gt; [ &#x27;App\\Listeners\\SendShipmentNotification&#x27;, ],]; Answer:在 EventServiceProvider 的 $listen property 中註冊一個 Listener SendShipmentNotification 監聽 OrderShipped event # Generating Events &amp; ListenersLaravel 中, 我先在 EventServiceProvider 的 $listen protected property 定義好 event 跟 listener 之後, 怎麼使用 CLI 讓定義好的 event 跟 listener 自動產生？php artisan event:generate # Manually Registering EventsLaravel 中, 如果我想要定義 closure based event, 我可以在哪一個檔案中定義？EventServiceProvider Laravel 中, 如果我想要定義 closure based event, 我可以在 EventServiceProvider 中的 哪一個 method 中定義？boot method 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; parent::boot(); Event::listen(&#x27;event.name&#x27;, function ($foo, $bar) &#123; // &#125;);&#125; Answer:在 EventServiceProvider 的 boot method 定義 closure based event, 第一個 argument 為該 event name, closure 內為 trigger event 時要做的事, 相當於定義於 Listener 中的邏輯 # Wild Event Listeners以下的 Laravel example code 的意思是？ Example:&lt;?phpEvent::listen(&#x27;registered.*&#x27;, function ($eventName, array $data) &#123; //&#125;); Answer:監聽所有 registered. 開頭的 event 以下的 Laravel example code 的意思是？ Example:&lt;?phpEvent::listen(&#x27;event.*&#x27;, function ($eventName, array $data) &#123; //&#125;); Answer:監聽 wildcard event, 第一個 argument 為 event name, 第二個為該 event 的 data # Event DiscoveryLaravel Event 中, Event Discovery 的規則, 會 scan 哪一個資料夾中的 Listeners?Listeners directory Laravel Event 中, Event Discovery 的規則, 假設以下的 Listener 為我 scan 到的 Listener, Laravel 會將這個 Listener 註冊給哪一個 event? Example:&lt;?phpuse App\\Events\\PodcastProcessed;class SendPodcastProcessedNotification&#123; public function handle(PodcastProcessed $event) &#123; // &#125;&#125; Answer: PodcastProcessed event Laravel Event 中, Event Discovery 的規則, 預設是關閉的還是打開的？關閉的 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function shouldDiscoverEvents()&#123; return true;&#125; Answer:Laravel 預設關閉 Event Discovery, 就是會根據 convention 將 listener 註冊給 listener handle method 中 type hint 的 event class若要開啟, 可在 EventServiceProvider 的 shouldDiscoverEvents() 中開啟 以下位於 EventServiceProvider 的 Laravel example code 的意思是？ Example:&lt;?phpprotected function discoverEventsWithin()&#123; return [ $this-&gt;app-&gt;path(&#x27;Listeners&#x27;), ];&#125; Answer:若有開啟 Event Discovery, 預設會掃描 ‘app/Listeners’ 資料夾內的 events, 若要變更資料夾位置, 可在 discoverEventsWithin() 中定義 Laravel production 環境中, 我們可能不想要框架在每一個 request 都去 scan 所有的 listeners, 可以使用哪一個 CLI 來將 events 以及 listeners cache 住？php artisan event:cache Laravel production 環境中, 我們可能不想要框架在每一個 request 都去 scan 所有的 listeners, 所以使用 CLI 來 cache events 以及 listeners, 如果我要將 cache 拿掉, 可以使用哪一個 CLI?php artisan event:clear Laravel 中, 如果我想要使用 CLI 來顯示所有 events 以及 listeners 的對應關係, 可以使用哪一個 CLI?php artisan event:list # Defining EventsLaravel Event 中, 會寫到邏輯嗎？不會哦 # Defining Listeners# Stopping The Propagation Of An EventLaravel 中, 如果我想要停止某個 listener 對某個 event 的傳播, 那我可以在該 listener 的 handle method 中回傳什麼？false # Queued Event Listeners以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderShipped;use Illuminate\\Contracts\\Queue\\ShouldQueue;class SendShipmentNotification implements ShouldQueue&#123; //&#125; Answer:將 listener class implement ShouldQueue interface, 當觸發該 listener 時, 該 job 會被 queue # Customizing The Queue Connection &amp; Queue Name以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderShipped;use Illuminate\\Contracts\\Queue\\ShouldQueue;class SendShipmentNotification implements ShouldQueue&#123; public $connection = &#x27;sqs&#x27;;&#125; Answer:在 listener class 當中指定 connection 為 ‘sqs’ 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderShipped;use Illuminate\\Contracts\\Queue\\ShouldQueue;class SendShipmentNotification implements ShouldQueue&#123; public $queue = &#x27;listeners&#x27;;&#125; Answer:在 listener class 中使用 $queue 指定該 listener 使用的 queue 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderShipped;use Illuminate\\Contracts\\Queue\\ShouldQueue;class SendShipmentNotification implements ShouldQueue&#123; public $delay = 60;&#125; Answer:在 listener class 中, 使用 $delay 定義該 job 在被 release 回 queue 後, 至少須等待 60 秒才可在被 worker pick up 執行Laravel 8 又叫做 backoff # Conditionally Queueing Listeners以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderPlaced;use Illuminate\\Contracts\\Queue\\ShouldQueue;class RewardGiftCard implements ShouldQueue&#123; public function handle(OrderPlaced $event) &#123; // &#125; public function shouldQueue(OrderPlaced $event) &#123; return $event-&gt;order-&gt;subtotal &gt;= 5000; &#125;&#125; Answer:當 Order model 的 subtotal attribute 大於等於 5000 時, queue 該 listener # Manually Accessing The QueueLaravel Events &amp; Listeners 中, 如果我想要在程式碼中可以手動的 release 或 delete 該 listener job, 那我可以在該 Listener 中使用哪一個 trait?InteractsWithQueue trait 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderShipped;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Queue\\InteractsWithQueue;class SendShipmentNotification implements ShouldQueue&#123; use InteractsWithQueue; public function handle(OrderShipped $event) &#123; if (true) &#123; $this-&gt;release(30); &#125; &#125;&#125; Answer:若要在 listener job 中可對 job 做 release 或 delete 操作, 需 use InteractsWithQueue # Handling Failed JobsLaravel Event &amp; Listener 中, 如果我想要在 Listener 失敗後做相對應的邏輯, 那我可以在 Listener 當中定義哪一個 method?failed method 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;use App\\Events\\OrderShipped;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Queue\\InteractsWithQueue;class SendShipmentNotification implements ShouldQueue&#123; use InteractsWithQueue; public function handle(OrderShipped $event) &#123; // &#125; public function failed(OrderShipped $event, $exception) &#123; // &#125;&#125; Answer:在 listener class 內定義 failed(), 當 listener job failed 時, 執行 failed() 內的邏輯 # Dispatching Events以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Events\\OrderShipped;use App\\Http\\Controllers\\Controller;use App\\Order;class OrderController extends Controller&#123; public function ship($orderId) &#123; $order = Order::findOrFail($orderId); // Order shipment logic... event(new OrderShipped($order)); &#125;&#125; Answer:觸發 OrderShipped event # Event Subscribers# Writing Event Subscribers以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Listeners;class UserEventSubscriber&#123; public function handleUserLogin($event) &#123;&#125; public function handleUserLogout($event) &#123;&#125; public function subscribe($events) &#123; $events-&gt;listen( &#x27;Illuminate\\Auth\\Events\\Login&#x27;, &#x27;App\\Listeners\\UserEventSubscriber@handleUserLogin&#x27; ); $events-&gt;listen( &#x27;Illuminate\\Auth\\Events\\Logout&#x27;, &#x27;App\\Listeners\\UserEventSubscriber@handleUserLogout&#x27; ); &#125;&#125; Answer:在 EventSubscriber 的 subscribe method 中定義 event 以及 listener, 然後直接在此 class 中定義 listener 邏輯 # Registering Event Subscribers以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; protected $listen = [ // ]; protected $subscribe = [ &#x27;App\\Listeners\\UserEventSubscriber&#x27;, ];&#125; Answer:使用 EventServiceProvider 的 $subscribe property 來註冊事先已建立的 UserEventSubscriber’, EventSubscriber 可以在一個 class 中定義多個 listener 邏輯, 並 map 與之相對應的 event, 這樣就不需要建立多個 class, 每個 class 只定義一個 listener","link":"/zh-tw/laravel-digging-deeper-events/"},{"title":"Laravel - Digging Deeper - File Storage (官方文件原子化翻譯文件)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Configuration# The Local Driver以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;Storage::disk(&#x27;local&#x27;)-&gt;put(&#x27;example.txt&#x27;, &#x27;Contents&#x27;); Answer:使用 local driver將 Contents 寫到 project/storage/app/example.txt 檔案裡 # The Public Disk以下的 Laravel example command 的意思是？ Example:php artisan storage:link Answer:會在 storage/app/public 跟 public/storage 之間建立一個 symlink 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho asset(&#x27;storage/file.txt&#x27;); Answer:產生一個可存取 project/public/storage/file.txt 檔案的 url預設根目錄為 public 以下位於 config/filesystem.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;links&#x27; =&gt; [ public_path(&#x27;storage&#x27;) =&gt; storage_path(&#x27;app/public&#x27;), public_path(&#x27;images&#x27;) =&gt; storage_path(&#x27;app/images&#x27;),], Answer:當執行 php artisan storage:link 時, Laravel 預設會將 project/storage/app/public 以及 project/public/storage 這兩個資料夾建立 symlink, 可在 link 內自定義要建立 symlink 的規則, 如上 example:在 project/public/storage 以及 project/storage/app/public 之間建立 symlink在 project/public/images 以及 project/storage/app/images 之間建立 symlink # Driver Prerequisites# Composer PackagesLaravel filesystem 中, 如果我要使用 S3, SFTP drivers, 需要另外安裝套件嗎？要哦 Laravel filesystem 中, 如果我要使用 S3, SFTP drivers, 為何要安裝 cached adapter?可以增進效能 # S3 Driver ConfigurationLaravel filesystem 中, 如果我要使用 S3, 而我想要增加新的 env variable, naming convention 跟什麼一樣？AWS CLI # FTP Driver Configuration以下位於 config/filesystem.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;ftp&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;ftp&#x27;, &#x27;host&#x27; =&gt; &#x27;ftp.example.com&#x27;, &#x27;username&#x27; =&gt; &#x27;your-username&#x27;, &#x27;password&#x27; =&gt; &#x27;your-password&#x27;, // Optional FTP Settings... // &#x27;port&#x27; =&gt; 21, // &#x27;root&#x27; =&gt; &#x27;&#x27;, // &#x27;passive&#x27; =&gt; true, // &#x27;ssl&#x27; =&gt; true, // &#x27;timeout&#x27; =&gt; 30,], Answer:當使用 FTP driver 的設定 # SFTP Driver Configuration以下位於 config/filesystem.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;sftp&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;sftp&#x27;, &#x27;host&#x27; =&gt; &#x27;example.com&#x27;, &#x27;username&#x27; =&gt; &#x27;your-username&#x27;, &#x27;password&#x27; =&gt; &#x27;your-password&#x27;, // Settings for SSH key based authentication... &#x27;privateKey&#x27; =&gt; &#x27;/path/to/privateKey&#x27;, &#x27;password&#x27; =&gt; &#x27;encryption-password&#x27;, // Optional SFTP Settings... // &#x27;port&#x27; =&gt; 22, // &#x27;root&#x27; =&gt; &#x27;&#x27;, // &#x27;timeout&#x27; =&gt; 30,], Answer:當使用 SFTP driver 的設定 # Caching以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;s3&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;s3&#x27;, // Other Disk Options... &#x27;cache&#x27; =&gt; [ &#x27;store&#x27; =&gt; &#x27;memcached&#x27;, &#x27;expire&#x27; =&gt; 600, &#x27;prefix&#x27; =&gt; &#x27;cache-prefix&#x27;, ],], Answer:在 s3 driver 內定義 cache # Obtaining Disk Instances以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;Storage::put(&#x27;avatars/1&#x27;, $content); Answer:將 $content 寫到位於 default disk 的檔案 /avatars/1 以下的 Laravel example code 的意思是？ Example:&lt;?phpStorage::disk(&#x27;s3&#x27;)-&gt;put(&#x27;avatars/1&#x27;, $content); Answer:將 $content 寫到位於 s3 disk 的檔案 /avatars/1 # Retrieving Files以下的 Laravel example code 的意思是？ Example:&lt;?php$contents = Storage::get(&#x27;file.jpg&#x27;); Answer:從 default disk 中取得檔案 /file.jpg, get(&#39;&#39;) 裡頭指定的為 default disk 下的相對路徑 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Storage::disk(&#x27;s3&#x27;)-&gt;exists(&#x27;file.jpg&#x27;)) &#123; // ...&#125; Answer:判斷 s3 disk 下, /file.jpg 是否存在 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Storage::disk(&#x27;s3&#x27;)-&gt;missing(&#x27;file.jpg&#x27;)) &#123; // ...&#125; Answer:判斷 s3 disk 下, /file.jpg 是否不存在 # Downloading Files以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn Storage::download(&#x27;file.jpg&#x27;);return Storage::download(&#x27;file.jpg&#x27;, $name, $headers); Answer:使瀏覽器觸發一個下載動作, arg1 為檔案路徑, arg2 為檔案名稱, arg3 為 header # File URLs以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;$url = Storage::url(&#x27;file.jpg&#x27;); Answer:產生一個 default disk 中, 檔案 /file.jpg 的可被存取的 url Laravel file storage 中, 要可被 public accessible 的檔案需置於哪個資料夾？storage/app/public Laravel 中, 當產生 public accessible url 時, 會 url encode 嗎？不會, 所以務必確保使用可以成為 valid url 的檔名 # Temporary URLs以下的 Laravel example code 的意思是？ Example:&lt;?php$url = Storage::temporaryUrl( &#x27;file.jpg&#x27;, now()-&gt;addMinutes(5), [ &#x27;ResponseContentType&#x27; =&gt; &#x27;application/octet-stream&#x27;, &#x27;ResponseContentDisposition&#x27; =&gt; &#x27;attachment; filename=file2.jpg&#x27;, ]); Answer:當使用 s3 driver 時, 可使用 temporaryUrl() 產生一個暫時的 url, arg2 可指定失效時間, arg3 可指定 s3 的其他 request parameters # URL Host Customization以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;public&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;local&#x27;, &#x27;root&#x27; =&gt; storage_path(&#x27;app/public&#x27;), &#x27;url&#x27; =&gt; env(&#x27;APP_URL&#x27;).&#x27;/storage&#x27;, &#x27;visibility&#x27; =&gt; &#x27;public&#x27;,], Answer:可在 ‘url’ 選項定義產生的 url 的 host # File Metadata以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;$size = Storage::size(&#x27;file.jpg&#x27;); Answer:取得該 file 的大小 以下的 Laravel example code 的意思是？ Example:&lt;?php$time = Storage::lastModified(&#x27;file.jpg&#x27;); Answer:取得 last modified time, 格式為 UNIX timestamp # File Paths以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;$path = Storage::path(&#x27;file.jpg&#x27;); Answer:取得 local file 的 absolute path, 如果使用 s3, 會取得 s3 bucket 的 relative path # Storing Files以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;Storage::put(&#x27;file.jpg&#x27;, $contents);Storage::put(&#x27;file.jpg&#x27;, $resource); Answer:將內容寫到檔案, 或將檔案存到指定資料夾也可使用 PHP resource, 如下 demonstration Demonstration:&lt;?php$userUpload = $request-&gt;file(&#x27;fileName&#x27;);$resource = fopen( $userUpload-&gt;getRealPath(), &#x27;r&#x27;);Storage::put(&#x27;path/to/save/the/file&#x27;, $resource); # Automatic Streaming以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Http\\File;use Illuminate\\Support\\Facades\\Storage;$path = Storage::putFile(&#x27;photos&#x27;, new File(&#x27;/path/to/photo&#x27;));$path = Storage::putFileAs(&#x27;photos&#x27;, new File(&#x27;/path/to/photo&#x27;), &#x27;photo.jpg&#x27;); Answer:使用 putFile 或 putFileAs 指定儲存路徑, 檔案來源, 以及檔名 (若不指定會自動產生 Unique ID), 並 return 儲存位置的 path 包括檔名會採用 stream 的方式儲存檔案 以下的 Laravel example code 的意思是？ Example:&lt;?phpStorage::putFile(&#x27;photos&#x27;, new File(&#x27;/path/to/photo&#x27;), &#x27;public&#x27;); Answer:使用 putFile 指定儲存路徑以及檔案來源, arg3 為該檔案是否可被公開存取, public 表示可以 # Prepending &amp; Appending To Files以下的 Laravel example code 的意思是？ Example:&lt;?phpStorage::prepend(&#x27;file.log&#x27;, &#x27;Prepended Text&#x27;);Storage::append(&#x27;file.log&#x27;, &#x27;Appended Text&#x27;); Answer:可以 prepend(開頭) 或 append(結尾) 內容寫入到指定的 file # Copying &amp; Moving Files以下的 Laravel example code 的意思是？ Example:&lt;?phpStorage::copy(&#x27;old/file.jpg&#x27;, &#x27;new/file.jpg&#x27;);Storage::move(&#x27;old/file.jpg&#x27;, &#x27;new/file.jpg&#x27;); Answer:使用 copy() 來複製檔案使用 move() 來移動檔案或重新命名檔案 # File Uploads以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Http\\Request;class UserAvatarController extends Controller&#123; public function update(Request $request) &#123; $path = $request-&gt;file(&#x27;avatar&#x27;)-&gt;store(&#x27;avatars&#x27;); return $path; &#125;&#125; Answer:使用 store(), 將 file avatar 存到位置 avatars, 因為沒有指定檔名, 所以會自動產生 Unique ID, 會回傳包含檔名的 path 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = Storage::putFile(&#x27;avatars&#x27;, $request-&gt;file(&#x27;avatar&#x27;)); Answer:使用 store(), 將 file avatar 存到位置 avatars, 因為沒有指定檔名, 所以會自動產生 Unique ID, 會回傳包含檔名的 path # Specifying A File Name以下的 Laravel example code 的意思是？ Example:&lt;?php$path = $request-&gt;file(&#x27;avatar&#x27;)-&gt;storeAs( &#x27;avatars&#x27;, $request-&gt;user()-&gt;id); Answer:使用 storeAs(), 將 file avatar 存到位置 avatars, 並指定檔名為 $request-&gt;user()-&gt;id, 會回傳包含檔名的 path 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = Storage::putFileAs( &#x27;avatars&#x27;, $request-&gt;file(&#x27;avatar&#x27;), $request-&gt;user()-&gt;id); Answer:使用 putFileAs(), 將 file avatar 存到位置 avatars, 並指定檔名為 $request-&gt;user()-&gt;id, 會回傳包含檔名的 path # Specifying A Disk以下的 Laravel example code 的意思是？ Example:&lt;?php$path = $request-&gt;file(&#x27;avatar&#x27;)-&gt;store( &#x27;avatars/&#x27;.$request-&gt;user()-&gt;id, &#x27;s3&#x27;); Answer:使用 store() 將 file avatar 存到 s3 disk, 路徑為 &#39;avatars/&#39;.$request-&gt;user()-&gt;id 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = $request-&gt;file(&#x27;avatar&#x27;)-&gt;storeAs( &#x27;avatars&#x27;, $request-&gt;user()-&gt;id, &#x27;s3&#x27;); Answer:使用 storeAs(), arg1 為 disk 內路徑, arg2 為檔名, arg3 為要使用的 disk # Other Uploaded File Information以下的 Laravel example code 的意思是？ Example:&lt;?php$name = $request-&gt;file(&#x27;avatar&#x27;)-&gt;getClientOriginalName(); Answer:取得上傳檔案原本的 name 以下的 Laravel example code 的意思是？ Example:&lt;?php$extension = $request-&gt;file(&#x27;avatar&#x27;)-&gt;extension(); Answer:取得上傳檔案的 extension # File Visibility以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;Storage::put(&#x27;file.jpg&#x27;, $contents, &#x27;public&#x27;); Answer:將 $content 寫 到 default disk 的 &#39;file.jpg&#39;, 並定義 visibility 為 public, 即可公開被存取 以下的 Laravel example code 的意思是？ Example:&lt;?php$visibility = Storage::getVisibility(&#x27;file.jpg&#x27;);Storage::setVisibility(&#x27;file.jpg&#x27;, &#x27;public&#x27;); Answer:取得該檔案的 visibility設定該檔案的 visibility 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = $request-&gt;file(&#x27;avatar&#x27;)-&gt;storePublicly(&#x27;avatars&#x27;, &#x27;s3&#x27;);$path = $request-&gt;file(&#x27;avatar&#x27;)-&gt;storePubliclyAs( &#x27;avatars&#x27;, $request-&gt;user()-&gt;id, &#x27;s3&#x27;); Answer:儲存檔案並設定 visibility, 檔名自動產生儲存檔案並設定 visibility, 指定檔名為 $request-&gt;user()-&gt;id # Local Files &amp; Visibility以下位於 config/filesystem.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;local&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;local&#x27;, &#x27;root&#x27; =&gt; storage_path(&#x27;app&#x27;), &#x27;permissions&#x27; =&gt; [ &#x27;file&#x27; =&gt; [ &#x27;public&#x27; =&gt; 0664, &#x27;private&#x27; =&gt; 0600, ], &#x27;dir&#x27; =&gt; [ &#x27;public&#x27; =&gt; 0775, &#x27;private&#x27; =&gt; 0700, ], ],], Answer:當使用 local driver 時, visibility 設為 public 時, 資料夾為 755, 檔案為 644, 可在 config/filesystem.php 自定義 # Deleting Files以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;Storage::delete(&#x27;file.jpg&#x27;);Storage::delete([&#x27;file.jpg&#x27;, &#x27;file2.jpg&#x27;]); Answer:刪除 default disk 內的檔案, 一個或多個 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;Storage::disk(&#x27;s3&#x27;)-&gt;delete(&#x27;path/file.jpg&#x27;); Answer:刪除 s3 disk 中的指定檔案 # Directories# Get All Files Within A Directory以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;$files = Storage::files($directory);$files = Storage::allFiles($directory); Answer:files() 取得 $directory 中所有的 filesallFiles() 取得 $directory 中所有的 files, 包含 subdirectories 內的 files # Get All Directories Within A Directory以下的 Laravel example code 的意思是？ Example:&lt;?php$directories = Storage::directories($directory);$directories = Storage::allDirectories($directory); Answer:directories() 取得 $directory 內所有的 directoriesallDirectories() 取得 $directory 內所有的 directories, 包含 subdirectories # Create A Directory以下的 Laravel example code 的意思是？ Example:&lt;?phpStorage::makeDirectory($directory); Answer:makeDirectory() 建立 $directory, 包含所有子目錄 # Delete A Directory以下的 Laravel example code 的意思是？ Example:&lt;?phpStorage::deleteDirectory($directory); Answer:刪除 $directory # Custom Filesystems以下的 Laravel example code 的意思是？ Example:&lt;?phpcomposer require spatie/flysystem-dropbox Answer:若要使用 custom filesystem, 需安裝 adaptor 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Storage;use Illuminate\\Support\\ServiceProvider;use League\\Flysystem\\Filesystem;use Spatie\\Dropbox\\Client as DropboxClient;use Spatie\\FlysystemDropbox\\DropboxAdapter;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Storage::extend(&#x27;dropbox&#x27;, function ($app, $config) &#123; $client = new DropboxClient( $config[&#x27;authorization_token&#x27;] ); return new Filesystem(new DropboxAdapter($client)); &#125;); &#125;&#125; Answer:在 AppServiceProvider 的 boot() 中註冊 custom filesystemextend() 的 arg1 為 custom filesystem name, arg2 為 closure, 需 return 一個 Filesystem class$config 為定義在 config/filesystems.php 的資料","link":"/zh-tw/laravel-digging-deeper-file-storage/"},{"title":"Laravel - Digging Deeper - HTTP Client (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # IntroductionLaravel HTTP Client 中, 如果要使用 CLI 安裝 guzzle, 該怎麼做？composer require guzzlehttp/guzzle # Making Requests以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Http;$response = Http::get(&#x27;http://test.com&#x27;); Answer:對指定 url 發 GET request Laravel HTTP Client 中, 以下 example 中的 $response 是哪個 class 的 instance? Example:&lt;?php$response-&gt;body() : string;$response-&gt;json() : array;$response-&gt;status() : int;$response-&gt;ok() : bool;$response-&gt;successful() : bool;$response-&gt;serverError() : bool;$response-&gt;clientError() : bool;$response-&gt;header($header) : string;$response-&gt;headers() : array; Answer: Illuminate\\Http\\Client\\Response 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn Http::get(&#x27;http://test.com/users/1&#x27;)[&#x27;name&#x27;]; Answer:直接取得 response 中的 key name 的 value # Request DataLaravel HTTP Client 中, 預設發 request 的 content type 是？application/json 以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::post(&#x27;http://test.com/users&#x27;, [ &#x27;name&#x27; =&gt; &#x27;Steve&#x27;, &#x27;role&#x27; =&gt; &#x27;Network Administrator&#x27;,]); Answer:對指定 url 發 Post request, 帶著 array 內的 parameters # Sending Form URL Encoded Requests以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::asForm()-&gt;post(&#x27;http://test.com/users&#x27;, [ &#x27;name&#x27; =&gt; &#x27;Sara&#x27;, &#x27;role&#x27; =&gt; &#x27;Privacy Consultant&#x27;,]); Answer:使用 application/x-www-form-urlencoded 的方式發 Request # Multi-Part Requests以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::attach( &#x27;attachment&#x27;, file_get_contents(&#x27;photo.jpg&#x27;), &#x27;photo.jpg&#x27;)-&gt;post(&#x27;http://test.com/attachments&#x27;); Answer:使用 attach method, 指定使用 multi-part 發送 request, arg1 為 field name, arg2 為檔案來源, arg3 為檔名 Laravel HTTP Client 中, 在以下的 multi-part example, 是用什麼方式來傳送檔案? Example: &lt;?php$photo = fopen(&#x27;photo.jpg&#x27;, &#x27;r&#x27;);$response = Http::attach( &#x27;attachment&#x27;, $photo, &#x27;photo.jpg&#x27;)-&gt;post(&#x27;http://test.com/attachments&#x27;); Answer:stream source # Headers以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::withHeaders([ &#x27;X-First&#x27; =&gt; &#x27;foo&#x27;, &#x27;X-Second&#x27; =&gt; &#x27;bar&#x27;])-&gt;post(&#x27;http://test.com/users&#x27;, [ &#x27;name&#x27; =&gt; &#x27;Taylor&#x27;,]); Answer:對指定的 url 發 post request, 帶著 [&#39;name&#39; =&gt; &#39;Taylor&#39; parameters, 並定義 headers # Authentication以下的 Laravel example code 的意思是？ Example:&lt;?php// Basic authentication...$response = Http::withBasicAuth(&#x27;taylor@laravel.com&#x27;, &#x27;secret&#x27;)-&gt;post(...); Answer:發 post request, 並帶著 basic auth 需要的 account &amp; secret 以下的 Laravel example code 的意思是？ Example:&lt;?php// Digest authentication...$response = Http::withDigestAuth(&#x27;taylor@laravel.com&#x27;, &#x27;secret&#x27;)-&gt;post(...); Answer:發 post request, 並定義 digest 需要的 auth 資料 # Bearer Tokens以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::withToken(&#x27;token&#x27;)-&gt;post(...); Answer:使用 HTTP Client 發送 request, 並指定要帶過去的 bearer token # Timeout以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::timeout(3)-&gt;get(...); Answer:發 get request, 並設定 timeout 為 3 秒, 超過會觸發 Illuminate\\Http\\Client\\ConnectionException # Retries以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::retry(3, 100)-&gt;post(...); Answer:發 post request, 如果不成功, 最多 retry 3 次, 每次間隔 100 milliseconds, 若失敗回傳 Illuminate\\Http\\Client\\RequestException instance # Error HandlingLaravel HTTP Client 中, 要是 request 出現 error, HTTP client 會立即 throw error 嗎？不會 以下的 Laravel example code 的意思是？ Example:&lt;?php$response-&gt;clientError(); Answer:判斷 response status code 是否為 400 level 以下的 Laravel example code 的意思是？ Example:&lt;?php// Determine if the status code was &gt;= 200 and &lt; 300...$response-&gt;successful(); Answer:當我使用 HTTP Client 對一個 endpoint 發送 request 後, 若是 request 出現 error, HTTP client 並不會立即 throw error, 使用 successful 可判斷 request status code 是否介於 200-299 以下的 Laravel example command 的意思是？ Example:&lt;?php$response-&gt;serverError(); Answer:Laravel HTTP Client 中, 要是 request 出現 error, HTTP client 並不會立即 throw error, 使用 serverError() 可判斷 error 是否 500 level # Throwing Exceptions以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::post(...);$response-&gt;throw();return $response[&#x27;user&#x27;][&#x27;id&#x27;]; Answer:當使用 HTTP client 時, 若有錯誤 Laravel 並不會自動 throw exception, 需使用 throw(), 若有錯誤 exception 會被 throw Laravel HTTP Client 中, 在以下的 example 若是出現 client error or server error, 會拋出哪個 class 的 instance? Example:&lt;?php$response = Http::post(...);// Throw an exception if a client or server error occurred...$response-&gt;throw();return $response[&#x27;user&#x27;][&#x27;id&#x27;]; Answer: Illuminate\\Http\\Client\\RequestException Laravel HTTP Client 中, 當出錯了, 拋出一個 Illuminate\\Http\\Client\\RequestException instance 時, 可從該 instance 的哪個 public property 取得 response?$response property Laravel HTTP Client 中, 以下的 example 中, 若是沒有出現錯誤, 會拋出 exception 嗎？ Example:&lt;?phpreturn Http::post(...)-&gt;throw()-&gt;json(); Answer:不會 # Guzzle Options以下的 Laravel example code 的意思是？ Example:&lt;?php$response = Http::withOptions([ &#x27;debug&#x27; =&gt; true,])-&gt;get(&#x27;http://test.com/users&#x27;); Answer:對指定 url 發 get request, 並使用 withOptions() 定義 request option # Testing# Faking Responses以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Http;Http::fake();$response = Http::post(...); Answer:當使用 Http 的 fake() 並不帶任何參數時, 會發送一個 fake request, 並且都會 return status code 200 response # Faking Specific URLs以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fake([ // Stub a JSON response for GitHub endpoints... &#x27;github.com/*&#x27; =&gt; Http::response([&#x27;foo&#x27; =&gt; &#x27;bar&#x27;], 200, [&#x27;Headers&#x27;]), // Stub a string response for Google endpoints... &#x27;google.com/*&#x27; =&gt; Http::response(&#x27;Hello World&#x27;, 200, [&#x27;Headers&#x27;]),]); Answer:使用 fake(), 定義兩個分別來自 &#39;github.com/*&#39;, &#39;google.com/*&#39; 的 fake response Laravel HTTP Client 中, 以下的 example 中的 * 代表的意思是？wildcard 以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fake([ // Stub a JSON response for GitHub endpoints... &#x27;github.com/*&#x27; =&gt; Http::response([&#x27;foo&#x27; =&gt; &#x27;bar&#x27;], 200, [&#x27;Headers&#x27;]), // Stub a string response for all other endpoints... &#x27;*&#x27; =&gt; Http::response(&#x27;Hello World&#x27;, 200, [&#x27;Headers&#x27;]),]); Answer:使用 fake() 定義 fake response, 只要不是 &#39;github.com/*&#39; 的 url 都回 &#39;*&#39; 的 fake response # Faking Response Sequences以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fake([ &#x27;github.com/*&#x27; =&gt; Http::sequence() -&gt;push(&#x27;Hello World&#x27;, 200) -&gt;push([&#x27;foo&#x27; =&gt; &#x27;bar&#x27;], 200) -&gt;pushStatus(404), -&gt;whenEmpty(Http::response()),]); Answer:使用 sequence(), 依序回傳指定的 response當預先定義的 response 都回傳後, Laravel 預設會 throw exception, whenEmpty() 可以定義這個 exception 以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fakeSequence() -&gt;push(&#x27;Hello World&#x27;, 200) -&gt;whenEmpty(Http::response()); Answer:使用 fakeSequence 定義有順序的 fake response, 但不定義 url # Fake Callback以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fake(function ($request) &#123; return Http::response(&#x27;Hello World&#x27;, 200);&#125;); Answer:使用 fake(), 並帶入 closure, closure 內定義 fake response # Inspecting Requests以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fake();Http::withHeaders([ &#x27;X-First&#x27; =&gt; &#x27;foo&#x27;,])-&gt;post(&#x27;http://test.com/users&#x27;, [ &#x27;name&#x27; =&gt; &#x27;Taylor&#x27;, &#x27;role&#x27; =&gt; &#x27;Developer&#x27;,]);Http::assertSent(function ($request) &#123; return $request-&gt;hasHeader(&#x27;X-First&#x27;, &#x27;foo&#x27;) &amp;&amp; $request-&gt;url() == &#x27;http://test.com/users&#x27; &amp;&amp; $request[&#x27;name&#x27;] == &#x27;Taylor&#x27; &amp;&amp; $request[&#x27;role&#x27;] == &#x27;Developer&#x27;;&#125;); Answer:使用 assertSent(), 斷言確實有發出 request 並包含定義的內容 以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fake();Http::post(&#x27;http://test.com/users&#x27;, [ &#x27;name&#x27; =&gt; &#x27;Taylor&#x27;, &#x27;role&#x27; =&gt; &#x27;Developer&#x27;,]); Http::assertNotSent(function (Request $request) &#123; return $request-&gt;url() === &#x27;http://test.com/posts&#x27;;&#125;); Answer:使用 assertsent(), 斷言並未對 url http://test.com/posts 發 request, 若 closure return true, 則斷言失敗 以下的 Laravel example code 的意思是？ Example:&lt;?phpHttp::fake();Http::assertNothingSent(); Answer:斷言沒有送出任何 request","link":"/zh-tw/laravel-digging-deeper-http-client/"},{"title":"Laravel - Digging Deeper - Collections","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 IntroductionLaravel Collections 中, 以下的 Example 的意思是？ Example&lt;?php$collection = collect([&#x27;taylor&#x27;, &#x27;abigail&#x27;, null])-&gt;map(function ($name) &#123; return strtoupper($name);&#125;)-&gt;reject(function ($name) &#123; return empty($name);&#125;); Answer&lt;?php// 取得 collection instance 並將每個 entry 變成大寫$collection = collect([&#x27;taylor&#x27;, &#x27;abigail&#x27;, null])-&gt;map(function ($name) &#123; return strtoupper($name);&#125;)// 移除 empty entry-&gt;reject(function ($name) &#123; return empty($name);&#125;); Extending CollectionsLaravel Collections 中, 如果我要自定義一個 collection method, 在以下的 example 中, 該使用哪個 method? Example&lt;?phpuse Illuminate\\Support\\Collection;use Illuminate\\Support\\Str;Collection::這裡是？(&#x27;toUpper&#x27;, function () &#123; return $this-&gt;map(function ($value) &#123; return Str::upper($value); &#125;);&#125;);$collection = collect([&#x27;first&#x27;, &#x27;second&#x27;]);$upper = $collection-&gt;toUpper();// [&#x27;FIRST&#x27;, &#x27;SECOND&#x27;] Answer&lt;?phpuse Illuminate\\Support\\Collection;use Illuminate\\Support\\Str;Collection::macro(&#x27;toUpper&#x27;, function () &#123; return $this-&gt;map(function ($value) &#123; return Str::upper($value); &#125;);&#125;);$collection = collect([&#x27;first&#x27;, &#x27;second&#x27;]);$upper = $collection-&gt;toUpper();// [&#x27;FIRST&#x27;, &#x27;SECOND&#x27;] Available MethodsLaravel Collections 中, 以下的 collection method 的輸出是？ Example&lt;?phpcollect([1, 2, 3])-&gt;all(); Answer// [1, 2, 3] Laravel Collections 中, 以下的 collection example 中, $average 的值是？ Example&lt;?php$average = collect([[&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 20], [&#x27;foo&#x27; =&gt; 40]])-&gt;avg(&#x27;foo&#x27;); Answer20 Laravel Collections 中, 以下的 collection example 中, $average 的值是？ Example&lt;?php$average = collect([1, 1, 2, 4])-&gt;avg(); Answer2 Laravel Collections 中, 以下的 collection example 中, $chunks 的值是？ Example&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7]);$chunks = $collection-&gt;chunk(4);$chunks-&gt;toArray(); Answer&lt;?php// [[1, 2, 3, 4], [5, 6, 7]] Laravel Collections 中, 以下的 collection example 中, $collapsed 的值是？ Example&lt;?php$collection = collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);$collapsed = $collection-&gt;collapse();$collapsed-&gt;all(); Answer&lt;?php// [1, 2, 3, 4, 5, 6, 7, 8, 9] Laravel Collections 中, 以下的 collection example 中, $combined 的值是？ Example&lt;?php$collection = collect([&#x27;name&#x27;, &#x27;age&#x27;]);$combined = $collection-&gt;combine([&#x27;George&#x27;, 29]);$combined-&gt;all(); Answer&lt;?php// [&#x27;name&#x27; =&gt; &#x27;George&#x27;, &#x27;age&#x27; =&gt; 29] Laravel Collections 中, 以下的 collection example 中, $collectionB 的值是？ Example&lt;?php$collectionA = collect([1, 2, 3]);$collectionB = $collectionA-&gt;collect();$collectionB-&gt;all(); Answer&lt;?php// [1, 2, 3] 以下的 Laravel example code 的意思是？ Example&lt;?php$lazyCollection = LazyCollection::make(function () &#123; yield 1; yield 2; yield 3;&#125;);$collection = $lazyCollection-&gt;collect();get_class($collection);// &#x27;Illuminate\\Support\\Collection&#x27;$collection-&gt;all();// [1, 2, 3] Answer將 lazyCollection 轉成一般的 collection Laravel Collections 中, 以下的 collection example 中, $concatenated 的值是？ Example&lt;?php$collection = collect([&#x27;John Doe&#x27;]);$concatenated = $collection-&gt;concat([&#x27;Jane Doe&#x27;])-&gt;concat([&#x27;name&#x27; =&gt; &#x27;Johnny Doe&#x27;]);$concatenated-&gt;all(); Answer&lt;?php// [&#x27;John Doe&#x27;, &#x27;Jane Doe&#x27;, &#x27;Johnny Doe&#x27;] Laravel Collections 中, 以下的 example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100]);$collection-&gt;contains(&#x27;Desk&#x27;); Answer:true Laravel Collections 中, 以下的 example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100]);$collection-&gt;contains(&#x27;New York&#x27;); Answer:false Laravel Collections 中, 以下的 example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100],]);$collection-&gt;contains(&#x27;product&#x27;, &#x27;Bookcase&#x27;); Answer:false 以下的 Laravel Collections example 中, 邏輯是？ Example:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100],]);$collection-&gt;contains(&#x27;product&#x27;, &#x27;Bookcase&#x27;);// false Answer:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100],]);// 驗該 collection 中有無 &#x27;product&#x27; =&gt; &#x27;Bookcase&#x27; 的 key / value $collection-&gt;contains(&#x27;product&#x27;, &#x27;Bookcase&#x27;);// false 以下的 Laravel Collections example 中, 如果我要 判斷該 collection 中是否有大於 3 的 value, 該在 contains method 中帶入什麼參數？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;contains(這裡是？);// true Answer:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;contains(function ($value, $key) &#123; return $value &gt; 3;&#125;);// true Laravel collection method contains() 是使用 loose comparison 還是 strict comparison?loose comparison Laravel collection method contains() 跟 containsStrict() 差別是？ contains(): loose comparison containsStrict(): strict comparison 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$collection-&gt;count(); Answer:4 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 2, 2, 3]);$counted = $collection-&gt;countBy();$counted-&gt;all(); Answer: [1 =&gt; 1, 2 =&gt; 3, 3 =&gt; 1] 以下的 Laravel Collections example 中, 邏輯是？ Example:&lt;?php$collection = collect([&#x27;alice@gmail.com&#x27;, &#x27;bob@yahoo.com&#x27;, &#x27;carlos@gmail.com&#x27;]);$counted = $collection-&gt;countBy(function ($email) &#123; return substr(strrchr($email, &quot;@&quot;), 1);&#125;);$counted-&gt;all();// [&#x27;gmail.com&#x27; =&gt; 2, &#x27;yahoo.com&#x27; =&gt; 1] Answer:&lt;?php$collection = collect([&#x27;alice@gmail.com&#x27;, &#x27;bob@yahoo.com&#x27;, &#x27;carlos@gmail.com&#x27;]);// strrchr 取得 &quot;@ 最後一次出現的位置&quot; 到 &quot;最末&quot; 字串, 即 @yahoo.com, @carlos@gmail.com// substr 取得位置 1 到最末, 即 yahoo.com, carlos@gmail$counted = $collection-&gt;countBy(function ($email) &#123; return substr(strrchr($email, &quot;@&quot;), 1);&#125;);$counted-&gt;all();// [&#x27;gmail.com&#x27; =&gt; 2, &#x27;yahoo.com&#x27; =&gt; 1] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2]);$matrix = $collection-&gt;crossJoin([&#x27;a&#x27;, &#x27;b&#x27;]);$matrix-&gt;all(); Answer:&lt;?php/* [ [1, &#x27;a&#x27;], [1, &#x27;b&#x27;], [2, &#x27;a&#x27;], [2, &#x27;b&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2]);$matrix = $collection-&gt;crossJoin([&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;I&#x27;, &#x27;II&#x27;]);$matrix-&gt;all(); Example:&lt;?php/* [ [1, &#x27;a&#x27;, &#x27;I&#x27;], [1, &#x27;a&#x27;, &#x27;II&#x27;], [1, &#x27;b&#x27;, &#x27;I&#x27;], [1, &#x27;b&#x27;, &#x27;II&#x27;], [2, &#x27;a&#x27;, &#x27;I&#x27;], [2, &#x27;a&#x27;, &#x27;II&#x27;], [2, &#x27;b&#x27;, &#x27;I&#x27;], [2, &#x27;b&#x27;, &#x27;II&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;John Doe&#x27;, &#x27;Jane Doe&#x27;]);$collection-&gt;dd(); Answer:&lt;?php/* Collection &#123; #items: array:2 [ 0 =&gt; &quot;John Doe&quot; 1 =&gt; &quot;Jane Doe&quot; ] &#125;*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$diff = $collection-&gt;diff([2, 4, 6, 8]);$diff-&gt;all(); Answer:&lt;?php// [1, 3, 5] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;color&#x27; =&gt; &#x27;orange&#x27;, &#x27;type&#x27; =&gt; &#x27;fruit&#x27;, &#x27;remain&#x27; =&gt; 6]);$diff = $collection-&gt;diffAssoc([ &#x27;color&#x27; =&gt; &#x27;yellow&#x27;, &#x27;type&#x27; =&gt; &#x27;fruit&#x27;, &#x27;remain&#x27; =&gt; 3, &#x27;used&#x27; =&gt; 6,]);$diff-&gt;all(); Answer:&lt;?php// [&#x27;color&#x27; =&gt; &#x27;orange&#x27;, &#x27;remain&#x27; =&gt; 6] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;one&#x27; =&gt; 10, &#x27;two&#x27; =&gt; 20, &#x27;three&#x27; =&gt; 30, &#x27;four&#x27; =&gt; 40, &#x27;five&#x27; =&gt; 50,]);$diff = $collection-&gt;diffKeys([ &#x27;two&#x27; =&gt; 2, &#x27;four&#x27; =&gt; 4, &#x27;six&#x27; =&gt; 6, &#x27;eight&#x27; =&gt; 8,]);$diff-&gt;all(); Answer:&lt;?php// [&#x27;one&#x27; =&gt; 10, &#x27;three&#x27; =&gt; 30, &#x27;five&#x27; =&gt; 50] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;John Doe&#x27;, &#x27;Jane Doe&#x27;]);$collection-&gt;dump(); Answer:&lt;?php/* Collection &#123; #items: array:2 [ 0 =&gt; &quot;John Doe&quot; 1 =&gt; &quot;Jane Doe&quot; ] &#125;*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]);$collection-&gt;duplicates(); Answer:&lt;?php// [2 =&gt; &#x27;a&#x27;, 4 =&gt; &#x27;b&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$employees = collect([ [&#x27;email&#x27; =&gt; &#x27;abigail@example.com&#x27;, &#x27;position&#x27; =&gt; &#x27;Developer&#x27;], [&#x27;email&#x27; =&gt; &#x27;james@example.com&#x27;, &#x27;position&#x27; =&gt; &#x27;Designer&#x27;], [&#x27;email&#x27; =&gt; &#x27;victoria@example.com&#x27;, &#x27;position&#x27; =&gt; &#x27;Developer&#x27;],])$employees-&gt;duplicates(&#x27;position&#x27;); Answer:&lt;?php// [2 =&gt; &#x27;Developer&#x27;] 以下的 Laravel Collections method duplicates 跟 duplicatesStrict 差別在於？？loose comparison 與 strict comparison 以下的 Laravel Collections method 中, foeach 相當於哪個 collection method?？collection.each 以下的 Laravel Collections method each 中, 在以下的 example, 如果我要打斷 iteration, 該怎麼做？ Example:&lt;?php$collection-&gt;each(function ($item, $key) &#123; if (/* some condition */) &#123; // 這裡要 return? &#125;&#125;); Answer:&lt;?php$collection-&gt;each(function ($item, $key) &#123; if (/* some condition */) &#123; return false; &#125;&#125;); 以下的 Laravel example code 的意思是？ Example:&lt;?php$collection = collect([[&#x27;John Doe&#x27;, 35], [&#x27;Jane Doe&#x27;, 33]]);$collection-&gt;eachSpread(function ($name, $age) &#123; //&#125;); Answer:使用 eachSpread iterate 每一個 nested item, 如果裡頭的動作是 echo $name, 輸出為 John Doe, Jane Doe 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([1, 2, 3, 4])-&gt;every(function ($value, $key) &#123; return $value &gt; 2;&#125;); Answer:&lt;?php// false 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([]);$collection-&gt;every(function ($value, $key) &#123; return $value &gt; 2;&#125;); Answer:// true 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;product_id&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 100, &#x27;discount&#x27; =&gt; false]);$filtered = $collection-&gt;except([&#x27;price&#x27;, &#x27;discount&#x27;]);$filtered-&gt;all(); Answer:&lt;?php// [&#x27;product_id&#x27; =&gt; 1] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$filtered = $collection-&gt;filter(function ($value, $key) &#123; return $value &gt; 2;&#125;);$filtered-&gt;all(); Answer:&lt;?php// [3, 4] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, null, false, &#x27;&#x27;, 0, []]);$collection-&gt;filter()-&gt;all(); Answer:&lt;?php// [1, 2, 3] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([1, 2, 3, 4])-&gt;first(function ($value, $key) &#123; return $value &gt; 2;&#125;); Answer:&lt;?php// 3 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([1, 2, 3, 4])-&gt;first(); Answer:&lt;?php// 1 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Regena&#x27;, &#x27;age&#x27; =&gt; null], [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 14], [&#x27;name&#x27; =&gt; &#x27;Diego&#x27;, &#x27;age&#x27; =&gt; 23], [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 84],]);$collection-&gt;firstWhere(&#x27;name&#x27;, &#x27;Linda&#x27;); Answer:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 14] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Regena&#x27;, &#x27;age&#x27; =&gt; null], [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 14], [&#x27;name&#x27; =&gt; &#x27;Diego&#x27;, &#x27;age&#x27; =&gt; 23], [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 84],]);$collection-&gt;firstWhere(&#x27;age&#x27;, &#x27;&gt;=&#x27;, 18); Answer:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;Diego&#x27;, &#x27;age&#x27; =&gt; 23] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Regena&#x27;, &#x27;age&#x27; =&gt; null], [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 14], [&#x27;name&#x27; =&gt; &#x27;Diego&#x27;, &#x27;age&#x27; =&gt; 23], [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 84],]);$collection-&gt;firstWhere(&#x27;age&#x27;); Answer:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;Linda&#x27;, &#x27;age&#x27; =&gt; 14] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Sally&#x27;], [&#x27;school&#x27; =&gt; &#x27;Arkansas&#x27;], [&#x27;age&#x27; =&gt; 28]]);$flattened = $collection-&gt;flatMap(function ($values) &#123; return array_map(&#x27;strtoupper&#x27;, $values);&#125;);$flattened-&gt;all(); Answer:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;SALLY&#x27;, &#x27;school&#x27; =&gt; &#x27;ARKANSAS&#x27;, &#x27;age&#x27; =&gt; &#x27;28&#x27;]; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;languages&#x27; =&gt; [&#x27;php&#x27;, &#x27;javascript&#x27;]]);$flattened = $collection-&gt;flatten();$flattened-&gt;all(); Answer:&lt;?php// [&#x27;taylor&#x27;, &#x27;php&#x27;, &#x27;javascript&#x27;]; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;Apple&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;iPhone 6S&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;], ], &#x27;Samsung&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;Galaxy S7&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;] ],]);$products = $collection-&gt;flatten(1);$products-&gt;values()-&gt;all(); Answer:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;iPhone 6S&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy S7&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;Apple&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;iPhone 6S&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;], ], &#x27;Samsung&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;Galaxy S7&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;] ],]);$products = $collection-&gt;flatten();$products-&gt;values()-&gt;all(); Answer:&lt;?php// [&#x27;iPhone 6S&#x27;, &#x27;Apple&#x27;, &#x27;Galaxy S7&#x27;, &#x27;Samsung&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;framework&#x27; =&gt; &#x27;laravel&#x27;]);$flipped = $collection-&gt;flip();$flipped-&gt;all(); Answer:&lt;?php// [&#x27;taylor&#x27; =&gt; &#x27;name&#x27;, &#x27;laravel&#x27; =&gt; &#x27;framework&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;framework&#x27; =&gt; &#x27;laravel&#x27;]);$collection-&gt;forget(&#x27;name&#x27;);$collection-&gt;all(); Answer:&lt;?php// [&#x27;framework&#x27; =&gt; &#x27;laravel&#x27;] Laravel collection method reject 跟 forget 差別是？reject 會 return 一個新的 collection, forget 修改原本的 collection 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);$chunk = $collection-&gt;forPage(2, 3);$chunk-&gt;all(); Answer:&lt;?php// [4, 5, 6] 以下的 Laravel Collections example 中, forPage method 的 argument 代表的意思是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);$chunk = $collection-&gt;forPage(2, 3);$chunk-&gt;all();// [4, 5, 6] Answer:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9]);// 2 代表第二頁的內容, 3 代表每頁顯示 3 筆資料$chunk = $collection-&gt;forPage(2, 3);$chunk-&gt;all();// [4, 5, 6] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;framework&#x27; =&gt; &#x27;laravel&#x27;]);$value = $collection-&gt;get(&#x27;name&#x27;); Answer:&lt;?php// taylor 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;framework&#x27; =&gt; &#x27;laravel&#x27;]);$value = $collection-&gt;get(&#x27;hello&#x27;); Answer:&lt;?php// null 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;framework&#x27; =&gt; &#x27;laravel&#x27;]);$value = $collection-&gt;get(&#x27;foo&#x27;, &#x27;default-value&#x27;); Answer:&lt;?php// default-value 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;framework&#x27; =&gt; &#x27;laravel&#x27;]);$collection-&gt;get(&#x27;email&#x27;, function () &#123; return &#x27;default-value&#x27;;&#125;); Answer:&lt;?php// default-value 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;email&#x27; =&gt; &#x27;ray@gmail.com&#x27;, &#x27;name&#x27; =&gt; &#x27;taylor&#x27;, &#x27;framework&#x27; =&gt; &#x27;laravel&#x27;]);$collection-&gt;get(&#x27;email&#x27;, function () &#123; return &#x27;default-value&#x27;;&#125;); Answer:&lt;?php// [&#x27;email&#x27; =&gt; &#x27;ray@gmail.com&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Chair&#x27;], [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;], [&#x27;account_id&#x27; =&gt; &#x27;account-x11&#x27;, &#x27;product&#x27; =&gt; &#x27;Desk&#x27;],]);$grouped = $collection-&gt;groupBy(&#x27;account_id&#x27;);$grouped-&gt;toArray(); Answer:&lt;?php/* [ &#x27;account-x10&#x27; =&gt; [ [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Chair&#x27;], [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;], ], &#x27;account-x11&#x27; =&gt; [ [&#x27;account_id&#x27; =&gt; &#x27;account-x11&#x27;, &#x27;product&#x27; =&gt; &#x27;Desk&#x27;], ], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Chair&#x27;], [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;], [&#x27;account_id&#x27; =&gt; &#x27;account-x11&#x27;, &#x27;product&#x27; =&gt; &#x27;Desk&#x27;],]);$grouped = $collection-&gt;groupBy(function ($item, $key) &#123; return substr($item[&#x27;account_id&#x27;], -3);&#125;);$grouped-&gt;toArray(); Answer:&lt;?php/* [ &#x27;x10&#x27; =&gt; [ [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Chair&#x27;], [&#x27;account_id&#x27; =&gt; &#x27;account-x10&#x27;, &#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;], ], &#x27;x11&#x27; =&gt; [ [&#x27;account_id&#x27; =&gt; &#x27;account-x11&#x27;, &#x27;product&#x27; =&gt; &#x27;Desk&#x27;], ], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$data = new Collection([ 10 =&gt; [&#x27;user&#x27; =&gt; 1, &#x27;skill&#x27; =&gt; 1, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;, &#x27;Role_3&#x27;]], 20 =&gt; [&#x27;user&#x27; =&gt; 2, &#x27;skill&#x27; =&gt; 1, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;, &#x27;Role_2&#x27;]], 30 =&gt; [&#x27;user&#x27; =&gt; 3, &#x27;skill&#x27; =&gt; 2, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;]], 40 =&gt; [&#x27;user&#x27; =&gt; 4, &#x27;skill&#x27; =&gt; 2, &#x27;roles&#x27; =&gt; [&#x27;Role_2&#x27;]],]);$result = $data-&gt;groupBy([ &#x27;skill&#x27;, function ($item) &#123; return $item[&#x27;roles&#x27;]; &#125;,], $preserveKeys = true); Answer:&lt;?php/*[ 1 =&gt; [ &#x27;Role_1&#x27; =&gt; [ 10 =&gt; [&#x27;user&#x27; =&gt; 1, &#x27;skill&#x27; =&gt; 1, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;, &#x27;Role_3&#x27;]], 20 =&gt; [&#x27;user&#x27; =&gt; 2, &#x27;skill&#x27; =&gt; 1, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;, &#x27;Role_2&#x27;]], ], &#x27;Role_2&#x27; =&gt; [ 20 =&gt; [&#x27;user&#x27; =&gt; 2, &#x27;skill&#x27; =&gt; 1, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;, &#x27;Role_2&#x27;]], ], &#x27;Role_3&#x27; =&gt; [ 10 =&gt; [&#x27;user&#x27; =&gt; 1, &#x27;skill&#x27; =&gt; 1, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;, &#x27;Role_3&#x27;]], ], ], 2 =&gt; [ &#x27;Role_1&#x27; =&gt; [ 30 =&gt; [&#x27;user&#x27; =&gt; 3, &#x27;skill&#x27; =&gt; 2, &#x27;roles&#x27; =&gt; [&#x27;Role_1&#x27;]], ], &#x27;Role_2&#x27; =&gt; [ 40 =&gt; [&#x27;user&#x27; =&gt; 4, &#x27;skill&#x27; =&gt; 2, &#x27;roles&#x27; =&gt; [&#x27;Role_2&#x27;]], ], ],];*/ Laravel collection method contains 與 has 的差異是？ contains() 帶入一組 array 的 key/value, 或單組 key has() 帶入多個 key, 以 array 的形式 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;account_id&#x27; =&gt; 1, &#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;amount&#x27; =&gt; 5]);$collection-&gt;has(&#x27;product&#x27;);// 輸出是？$collection-&gt;has([&#x27;product&#x27;, &#x27;amount&#x27;]);// 輸出是？$collection-&gt;has([&#x27;amount&#x27;, &#x27;price&#x27;]);// 輸出是？ Answer:&lt;?php// true// true// false 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;account_id&#x27; =&gt; 1, &#x27;product&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;account_id&#x27; =&gt; 2, &#x27;product&#x27; =&gt; &#x27;Chair&#x27;],]);$collection-&gt;implode(&#x27;product&#x27;, &#x27;, &#x27;); Answer:&lt;?php// Desk, Chair 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([1, 2, 3, 4, 5])-&gt;implode(&#x27;-&#x27;); Answer:&lt;?php// &#x27;1-2-3-4-5&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;Desk&#x27;, &#x27;Sofa&#x27;, &#x27;Chair&#x27;]);$intersect = $collection-&gt;intersect([&#x27;Desk&#x27;, &#x27;Chair&#x27;, &#x27;Bookcase&#x27;]);$intersect-&gt;all(); Answer:&lt;?php// [0 =&gt; &#x27;Desk&#x27;, 2 =&gt; &#x27;Chair&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;serial&#x27; =&gt; &#x27;UX301&#x27;, &#x27;type&#x27; =&gt; &#x27;screen&#x27;, &#x27;year&#x27; =&gt; 2009]);$intersect = $collection-&gt;intersectByKeys([ &#x27;reference&#x27; =&gt; &#x27;UX404&#x27;, &#x27;type&#x27; =&gt; &#x27;tab&#x27;, &#x27;year&#x27; =&gt; 2011]);$intersect-&gt;all(); Answer:&lt;?php// [&#x27;type&#x27; =&gt; &#x27;screen&#x27;, &#x27;year&#x27; =&gt; 2009] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([])-&gt;isEmpty(); Answer:&lt;?php// true 以下的 Laravel example code 的意思是？ Example:&lt;?phpcollect([])-&gt;isNotEmpty(); Answer:false判斷該 collection 是否為 empty 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])-&gt;join(&#x27;, &#x27;); Answer:&lt;?php// &#x27;a, b, c&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])-&gt;join(&#x27;, &#x27;, &#x27;, and &#x27;); Answer:&lt;?php// &#x27;a, b, and c&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([&#x27;a&#x27;, &#x27;b&#x27;])-&gt;join(&#x27;, &#x27;, &#x27; and &#x27;); Answer:&lt;?php// &#x27;a and b&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([&#x27;a&#x27;])-&gt;join(&#x27;, &#x27;, &#x27; and &#x27;); Answer:&lt;?php// &#x27;a&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([])-&gt;join(&#x27;, &#x27;, &#x27; and &#x27;); Answer:&lt;?php// &#x27;&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;],]);$keyed = $collection-&gt;keyBy(&#x27;product_id&#x27;);$keyed-&gt;all(); Answer:&lt;?php/* [ &#x27;prod-100&#x27; =&gt; [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], &#x27;prod-200&#x27; =&gt; [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;],]);$keyed = $collection-&gt;keyBy(&#x27;product_id&#x27;);$keyed-&gt;all(); Answer:&lt;?php/* [ &#x27;prod-100&#x27; =&gt; [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;],]);$keyed = $collection-&gt;keyBy(function ($item) &#123; return strtoupper($item[&#x27;product_id&#x27;]);&#125;);$keyed-&gt;all(); Answer:&lt;?php/* [ &#x27;PROD-100&#x27; =&gt; [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], &#x27;PROD-200&#x27; =&gt; [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;prod-100&#x27; =&gt; [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], &#x27;prod-200&#x27; =&gt; [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;],]);$keys = $collection-&gt;keys();$keys-&gt;all(); Answer:&lt;?php// [&#x27;prod-100&#x27;, &#x27;prod-200&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([1, 2, 3, 4])-&gt;last(function ($value, $key) &#123; return $value &lt; 3;&#125;); Answer:&lt;?php// 2 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([1, 2, 3, 4])-&gt;last(); Answer:&lt;?php// 4 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$multiplied = $collection-&gt;map(function ($item, $key) &#123; return $item * 2;&#125;);$multiplied-&gt;all(); Answer:&lt;?php// [2, 4, 6, 8, 10] *Laravel collection method map() 與 transform(), 差別在於？*map 產生新的 collection, transform 修改現有的 collection 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpclass Currency&#123; function __construct(string $code) &#123; $this-&gt;code = $code; &#125;&#125;$collection = collect([&#x27;USD&#x27;, &#x27;EUR&#x27;, &#x27;GBP&#x27;]);$currencies = $collection-&gt;mapInto(Currency::class);$currencies-&gt;all(); Answer:&lt;?php// [Currency(&#x27;USD&#x27;), Currency(&#x27;EUR&#x27;), Currency(&#x27;GBP&#x27;)] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);$chunks = $collection-&gt;chunk(2);$sequence = $chunks-&gt;mapSpread(function ($even, $odd) &#123; return $even + $odd;&#125;);$sequence-&gt;all(); Answer:&lt;?php// [1, 5, 9, 13, 17] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [ &#x27;name&#x27; =&gt; &#x27;John Doe&#x27;, &#x27;department&#x27; =&gt; &#x27;Sales&#x27;, ], [ &#x27;name&#x27; =&gt; &#x27;Jane Doe&#x27;, &#x27;department&#x27; =&gt; &#x27;Sales&#x27;, ], [ &#x27;name&#x27; =&gt; &#x27;Johnny Doe&#x27;, &#x27;department&#x27; =&gt; &#x27;Marketing&#x27;, ]]);$grouped = $collection-&gt;mapToGroups(function ($item, $key) &#123; return [$item[&#x27;department&#x27;] =&gt; $item[&#x27;name&#x27;]];&#125;);$grouped-&gt;toArray(); Answer:&lt;?php/* [ &#x27;Sales&#x27; =&gt; [&#x27;John Doe&#x27;, &#x27;Jane Doe&#x27;], &#x27;Marketing&#x27; =&gt; [&#x27;Johnny Doe&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [ &#x27;name&#x27; =&gt; &#x27;John Doe&#x27;, &#x27;department&#x27; =&gt; &#x27;Sales&#x27;, ], [ &#x27;name&#x27; =&gt; &#x27;Jane Doe&#x27;, &#x27;department&#x27; =&gt; &#x27;Sales&#x27;, ], [ &#x27;name&#x27; =&gt; &#x27;Johnny Doe&#x27;, &#x27;department&#x27; =&gt; &#x27;Marketing&#x27;, ]]);$grouped = $collection-&gt;mapToGroups(function ($item, $key) &#123; return [$item[&#x27;department&#x27;] =&gt; $item[&#x27;name&#x27;]];&#125;);$grouped-&gt;get(&#x27;Sales&#x27;)-&gt;all(); Answer:&lt;?php// [&#x27;John Doe&#x27;, &#x27;Jane Doe&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [ &#x27;name&#x27; =&gt; &#x27;John&#x27;, &#x27;department&#x27; =&gt; &#x27;Sales&#x27;, &#x27;email&#x27; =&gt; &#x27;john@example.com&#x27; ], [ &#x27;name&#x27; =&gt; &#x27;Jane&#x27;, &#x27;department&#x27; =&gt; &#x27;Marketing&#x27;, &#x27;email&#x27; =&gt; &#x27;jane@example.com&#x27; ]]);$keyed = $collection-&gt;mapWithKeys(function ($item) &#123; return [$item[&#x27;email&#x27;] =&gt; $item[&#x27;name&#x27;]];&#125;);$keyed-&gt;all(); Answer:&lt;?php/* [ &#x27;john@example.com&#x27; =&gt; &#x27;John&#x27;, &#x27;jane@example.com&#x27; =&gt; &#x27;Jane&#x27;, ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$max = collect([[&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 20]])-&gt;max(&#x27;foo&#x27;);// $max 輸出是？$max = collect([1, 2, 3, 4, 5])-&gt;max();// $max 輸出是？ Answer:&lt;?php// 20// 5 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$median = collect([[&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 20], [&#x27;foo&#x27; =&gt; 40]])-&gt;median(&#x27;foo&#x27;);// $median 輸出是？$median = collect([1, 1, 2, 4])-&gt;median();// $median 輸出是？ Answer:&lt;?php// 15// 1.5 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;product_id&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 100]);$merged = $collection-&gt;merge([&#x27;price&#x27; =&gt; 200, &#x27;discount&#x27; =&gt; false]);$merged-&gt;all(); Answer:&lt;?php// [&#x27;product_id&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 200, &#x27;discount&#x27; =&gt; false] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;Desk&#x27;, &#x27;Chair&#x27;]);$merged = $collection-&gt;merge([&#x27;Bookcase&#x27;, &#x27;Door&#x27;]);$merged-&gt;all(); Answer:&lt;?php// [&#x27;Desk&#x27;, &#x27;Chair&#x27;, &#x27;Bookcase&#x27;, &#x27;Door&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;product_id&#x27; =&gt; 1, &#x27;price&#x27; =&gt; 100]);$merged = $collection-&gt;mergeRecursive([&#x27;product_id&#x27; =&gt; 2, &#x27;price&#x27; =&gt; 200, &#x27;discount&#x27; =&gt; false]);$merged-&gt;all(); Answer:&lt;?php// [&#x27;product_id&#x27; =&gt; [1, 2], &#x27;price&#x27; =&gt; [100, 200], &#x27;discount&#x27; =&gt; false] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$min = collect([[&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 20]])-&gt;min(&#x27;foo&#x27;);// $min 輸出是？$min = collect([1, 2, 3, 4, 5])-&gt;min();// $min 輸出是？ Answer:&lt;?php// 10// 1 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$mode = collect([[&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 10], [&#x27;foo&#x27; =&gt; 20], [&#x27;foo&#x27; =&gt; 40]])-&gt;mode(&#x27;foo&#x27;);// $mode 輸出是？$mode = collect([1, 1, 2, 4])-&gt;mode();// $mode 輸出是？ Answer:&lt;?php// [10]// [1] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]);$collection-&gt;nth(4); Answer:&lt;?php// [&#x27;a&#x27;, &#x27;e&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;]);$collection-&gt;nth(4, 1); Answer:&lt;?php// [&#x27;b&#x27;, &#x27;f&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;product_id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100, &#x27;discount&#x27; =&gt; false]);$filtered = $collection-&gt;only([&#x27;product_id&#x27;, &#x27;name&#x27;]);$filtered-&gt;all(); Answer:&lt;?php// [&#x27;product_id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]);$filtered = $collection-&gt;pad(5, 0);$filtered-&gt;all();// $filtered 輸出是？$filtered = $collection-&gt;pad(-5, 0);$filtered-&gt;all();// $filtered 輸出是？ Answer:&lt;?php// [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, 0, 0]// [0, 0, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6]);list($underThree, $equalOrAboveThree) = $collection-&gt;partition(function ($i) &#123; return $i &lt; 3;&#125;);$underThree-&gt;all();// $underThree 輸出是？$equalOrAboveThree-&gt;all();// $equalOrAboveThree 輸出是？ Answer:&lt;?php// [1, 2]// [3, 4, 5, 6] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3]);$piped = $collection-&gt;pipe(function ($collection) &#123; return $collection-&gt;sum();&#125;); Answer:&lt;?php// 6 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;],]);$plucked = $collection-&gt;pluck(&#x27;name&#x27;);$plucked-&gt;all(); Answer:&lt;?php// [&#x27;Desk&#x27;, &#x27;Chair&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;product_id&#x27; =&gt; &#x27;prod-200&#x27;, &#x27;name&#x27; =&gt; &#x27;Chair&#x27;],]);$plucked = $collection-&gt;pluck(&#x27;name&#x27;, &#x27;product_id&#x27;);$plucked-&gt;all(); Answer:&lt;?php// [&#x27;prod-100&#x27; =&gt; &#x27;Desk&#x27;, &#x27;prod-200&#x27; =&gt; &#x27;Chair&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;brand&#x27; =&gt; &#x27;Tesla&#x27;, &#x27;color&#x27; =&gt; &#x27;red&#x27;], [&#x27;brand&#x27; =&gt; &#x27;Pagani&#x27;, &#x27;color&#x27; =&gt; &#x27;white&#x27;], [&#x27;brand&#x27; =&gt; &#x27;Tesla&#x27;, &#x27;color&#x27; =&gt; &#x27;black&#x27;], [&#x27;brand&#x27; =&gt; &#x27;Pagani&#x27;, &#x27;color&#x27; =&gt; &#x27;orange&#x27;],]);$plucked = $collection-&gt;pluck(&#x27;color&#x27;, &#x27;brand&#x27;);$plucked-&gt;all(); Answer:&lt;?php// [&#x27;Tesla&#x27; =&gt; &#x27;black&#x27;, &#x27;Pagani&#x27; =&gt; &#x27;orange&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;pop();// 這裡的輸出是？$collection-&gt;all();// 這裡的輸出是？ Answer:&lt;?php// 5// [1, 2, 3, 4] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;prepend(0);$collection-&gt;all(); Answer:&lt;?php// [0, 1, 2, 3, 4, 5] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2]);$collection-&gt;prepend(0, &#x27;zero&#x27;);$collection-&gt;all(); Answer:&lt;?php// [&#x27;zero&#x27; =&gt; 0, &#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;]);$collection-&gt;pull(&#x27;name&#x27;);// 這裡的輸出是？$collection-&gt;all();// 這裡的輸出是？ Answer:&lt;?php// &#x27;Desk&#x27;// [&#x27;product_id&#x27; =&gt; &#x27;prod-100&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$collection-&gt;push(5);$collection-&gt;all(); Answer:&lt;?php// [1, 2, 3, 4, 5] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;product_id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;]);$collection-&gt;put(&#x27;price&#x27;, 100);$collection-&gt;all(); Answer:&lt;?php// [&#x27;product_id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;random(); Answer:&lt;?php// 4 - (retrieved randomly) 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$random = $collection-&gt;random(3);$random-&gt;all(); Answer:&lt;?php// [2, 4, 5] - (retrieved randomly) 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3]);$total = $collection-&gt;reduce(function ($carry, $item) &#123; return $carry + $item;&#125;); Answer:&lt;?php// 6 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3]);$collection-&gt;reduce(function ($carry, $item) &#123; return $carry + $item;&#125;, 4); Answer:&lt;?php// 10 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$filtered = $collection-&gt;reject(function ($value, $key) &#123; return $value &gt; 2;&#125;);$filtered-&gt;all(); Answer:&lt;?php// [1, 2] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;Taylor&#x27;, &#x27;Abigail&#x27;, &#x27;James&#x27;]);$replaced = $collection-&gt;replace([1 =&gt; &#x27;Victoria&#x27;, 3 =&gt; &#x27;Finn&#x27;]);$replaced-&gt;all(); Answer:&lt;?php// [&#x27;Taylor&#x27;, &#x27;Victoria&#x27;, &#x27;James&#x27;, &#x27;Finn&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;Taylor&#x27;, &#x27;Abigail&#x27;, [&#x27;James&#x27;, &#x27;Victoria&#x27;, &#x27;Finn&#x27;]]);$replaced = $collection-&gt;replaceRecursive([&#x27;Charlie&#x27;, 2 =&gt; [1 =&gt; &#x27;King&#x27;]]);$replaced-&gt;all(); Answer:&lt;?php// [&#x27;Charlie&#x27;, &#x27;Abigail&#x27;, [&#x27;James&#x27;, &#x27;King&#x27;, &#x27;Finn&#x27;]] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]);$reversed = $collection-&gt;reverse();$reversed-&gt;all(); Answer:&lt;?php/* [ 4 =&gt; &#x27;e&#x27;, 3 =&gt; &#x27;d&#x27;, 2 =&gt; &#x27;c&#x27;, 1 =&gt; &#x27;b&#x27;, 0 =&gt; &#x27;a&#x27;, ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([2, 4, 6, 8]);$collection-&gt;search(4); Answer:&lt;?php// 1 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([2, 4, 6, 8]);$collection-&gt;search(&#x27;4&#x27;, true); Answer:&lt;?php// false 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([2, 4, 6, 8]);$collection-&gt;search(function ($item, $key) &#123; return $item &gt; 5;&#125;); Answer:&lt;?php// 2 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;shift();// 這裡輸出是？$collection-&gt;all();// 這裡輸出是？ Answer:&lt;?php// 1// [2, 3, 4, 5] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$shuffled = $collection-&gt;shuffle();$shuffled-&gt;all(); Answer:&lt;?php// [3, 2, 5, 1, 4] - (generated randomly) 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);$collection = $collection-&gt;skip(4);$collection-&gt;all(); Answer:&lt;?php// [5, 6, 7, 8, 9, 10] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$subset = $collection-&gt;skipUntil(function ($item) &#123; return $item &gt;= 3;&#125;);$subset-&gt;all(); Answer:&lt;?php// [3, 4] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);$collection = $collection-&gt;skip(4);$collection-&gt;all(); Answer:&lt;?php// [5, 6, 7, 8, 9, 10] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$subset = $collection-&gt;skipUntil(3);$subset-&gt;all(); Answer:&lt;?php// [3, 4] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$subset = $collection-&gt;skipWhile(function ($item) &#123; return $item &lt;= 3;&#125;);$subset-&gt;all(); Answer:&lt;?php// [4] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);$slice = $collection-&gt;slice(4);$slice-&gt;all(); Answer:&lt;?php// [5, 6, 7, 8, 9, 10] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);$slice = $collection-&gt;slice(4, 2);$slice-&gt;all(); Answer:&lt;?php// [5, 6] Laravel Collections method some() 是哪一個 method 的 alias？contains() 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([5, 3, 1, 2, 4]);$sorted = $collection-&gt;sort();$sorted-&gt;values()-&gt;all(); Answer:&lt;?php// [1, 2, 3, 4, 5] Laravel Collections method sort() 是否會保留原本的 index？會的 Laravel Collections method slice() 是否會保留原本的 index？會的 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;name&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150],]);$sorted = $collection-&gt;sortBy(&#x27;price&#x27;);$sorted-&gt;values()-&gt;all(); Answer:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Black&#x27;, &#x27;Mahogany&#x27;]], [&#x27;name&#x27; =&gt; &#x27;Chair&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Black&#x27;]], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Red&#x27;, &#x27;Beige&#x27;, &#x27;Brown&#x27;]],]);$sorted = $collection-&gt;sortBy(function ($product, $key) &#123; return count($product[&#x27;colors&#x27;]);&#125;);$sorted-&gt;values()-&gt;all(); Answer:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;Chair&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Black&#x27;]], [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Black&#x27;, &#x27;Mahogany&#x27;]], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Red&#x27;, &#x27;Beige&#x27;, &#x27;Brown&#x27;]], ]*/ Laravel Collections method 中, sortBy 跟 sortByDesc 差別在哪？反方向 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([5, 3, 1, 2, 4]);$sorted = $collection-&gt;sortDesc();$sorted-&gt;values()-&gt;all(); Answer:&lt;?php// [5, 4, 3, 2, 1] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;id&#x27; =&gt; 22345, &#x27;first&#x27; =&gt; &#x27;John&#x27;, &#x27;last&#x27; =&gt; &#x27;Doe&#x27;,]);$sorted = $collection-&gt;sortKeys();$sorted-&gt;all(); Answer:&lt;?php/* [ &#x27;first&#x27; =&gt; &#x27;John&#x27;, &#x27;id&#x27; =&gt; 22345, &#x27;last&#x27; =&gt; &#x27;Doe&#x27;, ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ &#x27;id&#x27; =&gt; 22345, &#x27;first&#x27; =&gt; &#x27;John&#x27;, &#x27;last&#x27; =&gt; &#x27;Doe&#x27;,]);$sorted = $collection-&gt;sortKeysDesc();$sorted-&gt;all(); Answer:&lt;?php/* [ &#x27;last&#x27; =&gt; &#x27;Doe&#x27;, &#x27;id&#x27; =&gt; 22345, &#x27;first&#x27; =&gt; &#x27;John&#x27;, ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$chunk = $collection-&gt;splice(2);$chunk-&gt;all();// 這裡輸出是？$collection-&gt;all();// 這裡輸出是？ Answer:&lt;?php// [3, 4, 5]// [1, 2] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$chunk = $collection-&gt;splice(2, 1);$chunk-&gt;all();// 這裡輸出是？$collection-&gt;all();// 這裡輸出是？ Answer:&lt;?php// [3]// [1, 2, 4, 5] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$chunk = $collection-&gt;splice(2, 1, [10, 11]);$chunk-&gt;all();// 這裡輸出是？$collection-&gt;all();// 這裡輸出是？ Answer:&lt;?php// [3]// [1, 2, 10, 11, 4, 5] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$groups = $collection-&gt;split(3);$groups-&gt;toArray(); Answer:&lt;?php// [[1, 2], [3, 4], [5]] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([1, 2, 3, 4, 5])-&gt;sum(); Answer:&lt;?php// 15 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;JavaScript: The Good Parts&#x27;, &#x27;pages&#x27; =&gt; 176], [&#x27;name&#x27; =&gt; &#x27;JavaScript: The Definitive Guide&#x27;, &#x27;pages&#x27; =&gt; 1096],]);$collection-&gt;sum(&#x27;pages&#x27;); Answer:&lt;?php// 1272 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Chair&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Black&#x27;]], [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Black&#x27;, &#x27;Mahogany&#x27;]], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;colors&#x27; =&gt; [&#x27;Red&#x27;, &#x27;Beige&#x27;, &#x27;Brown&#x27;]],]);$collection-&gt;sum(function ($product) &#123; return count($product[&#x27;colors&#x27;]);&#125;); Answer:&lt;?php// 6 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([0, 1, 2, 3, 4, 5]);$chunk = $collection-&gt;take(3);$chunk-&gt;all(); Answer:&lt;?php// [0, 1, 2] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([0, 1, 2, 3, 4, 5]);$chunk = $collection-&gt;take(-2);$chunk-&gt;all(); Answer:&lt;?php// [4, 5] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$subset = $collection-&gt;takeUntil(function ($item) &#123; return $item &gt;= 3;&#125;);$subset-&gt;all(); Answer:&lt;?php// [1, 2] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$subset = $collection-&gt;takeUntil(3);$subset-&gt;all(); Answer:&lt;?php// [1, 2] 3 表示 value, 非 index 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4]);$subset = $collection-&gt;takeWhile(function ($item) &#123; return $item &lt; 3;&#125;);$subset-&gt;all(); Answer:&lt;?php// [1, 2] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpcollect([2, 4, 3, 1, 5]) -&gt;sort() -&gt;tap(function ($collection) &#123; Log::debug(&#x27;Values after sorting&#x27;, $collection-&gt;values()-&gt;toArray()); &#125;) -&gt;shift(); Answer:&lt;?php// 1 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = Collection::times(10, function ($number) &#123; return $number * 9;&#125;);$collection-&gt;all(); Answer:&lt;?php// [9, 18, 27, 36, 45, 54, 63, 72, 81, 90] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$categories = Collection::times(3, function ($number) &#123; return factory(Category::class)-&gt;create([&#x27;name&#x27; =&gt; &quot;Category No. $number&quot;]);&#125;);$categories-&gt;all(); Answer:&lt;?php/* [ [&#x27;id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;Category No. 1&#x27;], [&#x27;id&#x27; =&gt; 2, &#x27;name&#x27; =&gt; &#x27;Category No. 2&#x27;], [&#x27;id&#x27; =&gt; 3, &#x27;name&#x27; =&gt; &#x27;Category No. 3&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200]);$collection-&gt;toArray(); Answer:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200]);$collection-&gt;toJson(); Answer:&lt;?php// &#x27;&#123;&quot;name&quot;:&quot;Desk&quot;, &quot;price&quot;:200&#125;&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3, 4, 5]);$collection-&gt;transform(function ($item, $key) &#123; return $item * 2;&#125;);$collection-&gt;all(); Answer:&lt;?php// [2, 4, 6, 8, 10] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1 =&gt; [&#x27;a&#x27;], 2 =&gt; [&#x27;b&#x27;]]);$union = $collection-&gt;union([3 =&gt; [&#x27;c&#x27;], 1 =&gt; [&#x27;b&#x27;]]);$union-&gt;all(); Answer:&lt;?php// [1 =&gt; [&#x27;a&#x27;], 2 =&gt; [&#x27;b&#x27;], 3 =&gt; [&#x27;c&#x27;]] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 1, 2, 2, 3, 4, 2]);$unique = $collection-&gt;unique();$unique-&gt;values()-&gt;all(); Answer:&lt;?php// [1, 2, 3, 4] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;iPhone 6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;iPhone 5&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;Apple Watch&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;watch&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy S6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy Gear&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;, &#x27;type&#x27; =&gt; &#x27;watch&#x27;],]);$unique = $collection-&gt;unique(&#x27;brand&#x27;);$unique-&gt;values()-&gt;all(); Answer:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;iPhone 6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy S6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;iPhone 6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;iPhone 5&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;Apple Watch&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;watch&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy S6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy Gear&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;, &#x27;type&#x27; =&gt; &#x27;watch&#x27;],]);$unique = $collection-&gt;unique(function ($item) &#123; return $item[&#x27;brand&#x27;].$item[&#x27;type&#x27;];&#125;);$unique-&gt;values()-&gt;all(); Example:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;iPhone 6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;Apple Watch&#x27;, &#x27;brand&#x27; =&gt; &#x27;Apple&#x27;, &#x27;type&#x27; =&gt; &#x27;watch&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy S6&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;, &#x27;type&#x27; =&gt; &#x27;phone&#x27;], [&#x27;name&#x27; =&gt; &#x27;Galaxy Gear&#x27;, &#x27;brand&#x27; =&gt; &#x27;Samsung&#x27;, &#x27;type&#x27; =&gt; &#x27;watch&#x27;], ]*/ Laravel Collections method unique 是 loose comparisons or strict comparison?loose comparison 如果要使用 Laravel Collections method unique strict comparison 的話, 該使用哪個 method?uniqueStrict() 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3]);$collection-&gt;unless(true, function ($collection) &#123; return $collection-&gt;push(4);&#125;);$collection-&gt;unless(false, function ($collection) &#123; return $collection-&gt;push(5);&#125;);$collection-&gt;all(); Answer:&lt;?php// [1, 2, 3, 5] Laravel Collections method 中, unlessEmpty 是哪個 method 的 alias?whenNotEmpty() Laravel Collections method 中, unlessNotEmpty 是哪個 method 的 alias?whenEmpty() 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpCollection::unwrap(collect(&#x27;John Doe&#x27;));// 這裡輸出是？Collection::unwrap([&#x27;John Doe&#x27;]);// 這裡輸出是？Collection::unwrap(&#x27;John Doe&#x27;);// 這裡輸出是？ Answer:&lt;?php// 如果 argument 是 array, 輸出 array, 否則則輸出 argument 本身// [&#x27;John Doe&#x27;]// [&#x27;John Doe&#x27;]// &#x27;John Doe&#x27; 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ 10 =&gt; [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], 11 =&gt; [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200]]);$values = $collection-&gt;values();$values-&gt;all(); Answer:&lt;?php// 會重置 key/* [ 0 =&gt; [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], 1 =&gt; [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([1, 2, 3]);$collection-&gt;when(true, function ($collection) &#123; return $collection-&gt;push(4);&#125;);$collection-&gt;when(false, function ($collection) &#123; return $collection-&gt;push(5);&#125;);$collection-&gt;all(); Answer:&lt;?php// 恰恰與 unless 相反// [1, 2, 3, 4] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;michael&#x27;, &#x27;tom&#x27;]);$collection-&gt;whenEmpty(function ($collection) &#123; return $collection-&gt;push(&#x27;adam&#x27;);&#125;);$collection-&gt;all();// [&#x27;michael&#x27;, &#x27;tom&#x27;] Answer:&lt;?php當 $collection 為 empty 時, 執行 closure 內的邏輯// [&#x27;michael&#x27;, &#x27;tom&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect();$collection-&gt;whenEmpty(function ($collection) &#123; return $collection-&gt;push(&#x27;adam&#x27;);&#125;);$collection-&gt;all(); Answer:&lt;?php// [&#x27;adam&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;michael&#x27;, &#x27;tom&#x27;]);$collection-&gt;whenEmpty(function ($collection) &#123; return $collection-&gt;push(&#x27;adam&#x27;);&#125;, function ($collection) &#123; return $collection-&gt;push(&#x27;taylor&#x27;);&#125;);$collection-&gt;all(); Answer:&lt;?php// [&#x27;michael&#x27;, &#x27;tom&#x27;, &#x27;taylor&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;michael&#x27;, &#x27;tom&#x27;]);$collection-&gt;whenNotEmpty(function ($collection) &#123; return $collection-&gt;push(&#x27;adam&#x27;);&#125;);$collection-&gt;all(); Answer:&lt;?php// [&#x27;michael&#x27;, &#x27;tom&#x27;, &#x27;adam&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect();$collection-&gt;whenNotEmpty(function ($collection) &#123; return $collection-&gt;push(&#x27;adam&#x27;);&#125;);$collection-&gt;all(); Answer:&lt;?php// [] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect();$collection-&gt;whenNotEmpty(function ($collection) &#123; return $collection-&gt;push(&#x27;adam&#x27;);&#125;, function ($collection) &#123; return $collection-&gt;push(&#x27;taylor&#x27;);&#125;);$collection-&gt;all(); Answer:&lt;?php// [&#x27;taylor&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100],]);$filtered = $collection-&gt;where(&#x27;price&#x27;, 100);$filtered-&gt;all(); Answer:&lt;?php/* [ [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100], ]*/ Laravel collection method where() 預設是 loose comparison, 如果要讓它是 strict comparison, 該使用哪個 method?whereStrict 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 80], [&#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], [&#x27;product&#x27; =&gt; &#x27;Pencil&#x27;, &#x27;price&#x27; =&gt; 30], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100],]);$filtered = $collection-&gt;whereBetween(&#x27;price&#x27;, [100, 200]);$filtered-&gt;all(); Answer:&lt;?php/* [ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100],]);$filtered = $collection-&gt;whereIn(&#x27;price&#x27;, [150, 200]);$filtered-&gt;all(); Answer:&lt;?php/* [ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], ]*/ Laravel collection method whereIn() 預設是 loose comparison, 如果要讓它是 strict comparison, 該使用哪個 method?whereInStrict 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?phpuse App\\User;use App\\Post;$collection = collect([ new User, new User, new Post,]);$filtered = $collection-&gt;whereInstanceOf(User::class);$filtered-&gt;all(); Answer:&lt;?php// [App\\User, App\\User] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 80], [&#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], [&#x27;product&#x27; =&gt; &#x27;Pencil&#x27;, &#x27;price&#x27; =&gt; 30], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100],]);$filtered = $collection-&gt;whereNotBetween(&#x27;price&#x27;, [100, 200]);$filtered-&gt;all(); Answer:&lt;?php/* [ [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 80], [&#x27;product&#x27; =&gt; &#x27;Pencil&#x27;, &#x27;price&#x27; =&gt; 30], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;product&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;product&#x27; =&gt; &#x27;Bookcase&#x27;, &#x27;price&#x27; =&gt; 150], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100],]);$filtered = $collection-&gt;whereNotIn(&#x27;price&#x27;, [150, 200]);$filtered-&gt;all(); Answer:&lt;?php/* [ [&#x27;product&#x27; =&gt; &#x27;Chair&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;product&#x27; =&gt; &#x27;Door&#x27;, &#x27;price&#x27; =&gt; 100], ]*/ 如果我要使用 strict 模式的 whereNotInStrict, 可以使用哪個 method？whereNotInStrict() 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;name&#x27; =&gt; null], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;],]);$filtered = $collection-&gt;whereNotNull(&#x27;name&#x27;);$filtered-&gt;all(); Answer:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([ [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;name&#x27; =&gt; null], [&#x27;name&#x27; =&gt; &#x27;Bookcase&#x27;],]);$filtered = $collection-&gt;whereNull(&#x27;name&#x27;);$filtered-&gt;all(); Answer:&lt;?php/* [ [&#x27;name&#x27; =&gt; null], ]*/ 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = Collection::wrap(&#x27;John Doe&#x27;);$collection-&gt;all();// 這裡的輸出是？$collection = Collection::wrap([&#x27;John Doe&#x27;]);$collection-&gt;all();// 這裡的輸出是？$collection = Collection::wrap(collect(&#x27;John Doe&#x27;));$collection-&gt;all();// 這裡的輸出是？ Answer:&lt;?php// [&#x27;John Doe&#x27;]// [&#x27;John Doe&#x27;]// [&#x27;John Doe&#x27;] 以下的 Laravel Collections example 中, 輸出是？ Example:&lt;?php$collection = collect([&#x27;Chair&#x27;, &#x27;Desk&#x27;]);$zipped = $collection-&gt;zip([100, 200]);$zipped-&gt;all(); Answer:&lt;?php// [[&#x27;Chair&#x27;, 100], [&#x27;Desk&#x27;, 200]] Higher Order MessagesLaravel Collections method 中, 什麼是 higher order message？collection method 的縮寫 Lazy CollectionsIntroduction以下的 Laravel example code 的意思是？ Example:&lt;?php$users = App\\User::cursor()-&gt;filter(function ($user) &#123; return $user-&gt;id &gt; 500;&#125;);foreach ($users as $user) &#123; echo $user-&gt;id;&#125; Answer:cursor 為 PHP generator 的概念, 不會一次性的將所有 model 都 load 到 memory, 會一次 load 一個 model 並執行, 減低記憶體用量 Lazy Collection Methods解釋以下 collection example Example:&lt;?php$lazyCollection = LazyCollection::times(INF)-&gt;tapEach(function ($value) &#123; dump($value);&#125;);// Nothing has been dumped so far...$array = $lazyCollection-&gt;take(3)-&gt;all();// 1// 2// 3 Answer:&lt;?php// 宣告一個無窮大的 collection, 但此 collection 必不會執行, 會等到被呼叫才會執行, tapEach 是 lazy collection 專屬的 method$lazyCollection = LazyCollection::times(INF)-&gt;tapEach(function ($value) &#123; dump($value);&#125;);// Nothing has been dumped so far...// 這邊才會執行$array = $lazyCollection-&gt;take(3)-&gt;all();// 1// 2// 3 回答以下 lazy collection example 中的問題 Example:&lt;?php$users = User::cursor()-&gt;remember();// 到此, 有 query 被執行嗎？$users-&gt;take(5)-&gt;all();// 到此, 有 query 被執行嗎？// 哪些 user 被從資料庫拉出？$users-&gt;take(20)-&gt;all();// 到此, 哪些 user 被從資料庫拉出？ Answer:&lt;?php$users = User::cursor()-&gt;remember();// 到此, 有 query 被執行嗎？ 沒有$users-&gt;take(5)-&gt;all();// 到此, 有 query 被執行嗎？ 有哦// 哪些 user 被從資料庫拉出？ 前 5 個 user$users-&gt;take(20)-&gt;all();// 到此, 哪些 user 被從資料庫拉出？ 6 到 20, 前 5 個來自於 cache","link":"/zh-tw/laravel-digging-deeper-collections/"},{"title":"Laravel - Digging Deeper - Localization (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 以下的 Laravel example directory structure 的意思是？ Example1:/resources /lang /en messages.php /es messages.php Example2:/resources /lang en.json es.json Answer:為 localization 的翻譯檔案置放規則1 為 Laravel 預設的方式, 2 適合當有大量的翻譯檔案時 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\App;Route::get(&#x27;/greeting/&#123;locale&#125;&#x27;, function ($locale) &#123; if (! in_array($locale, [&#x27;en&#x27;, &#x27;es&#x27;, &#x27;fr&#x27;])) &#123; abort(400); &#125; App::setLocale($locale); //&#125;); Answer:使用 API 來調整 locale, 如果沒有指定的語言則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;fallback_locale&#x27; =&gt; &#x27;en&#x27;, Answer:當 default locale file 沒有相對應的 transaction string 時, 使用 fallback locale # Determining The Current Locale以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\App;$locale = App::currentLocale();if (App::isLocale(&#x27;en&#x27;)) &#123; //&#125; Answer:取得 current locale 以及判斷 current locale # Defining Translation Strings# Using Short Keys以下的 Laravel example locale code 的意思是？ Example:&lt;?php&#123; &quot;I love programming.&quot;: &quot;Me encanta programar.&quot;&#125; Answer:use translation string as key 以下的 Laravel example code 中, 如果 nl.json 檔案中沒有 ‘Action’ string, 但有 nl/action 這個檔案, 那會使用哪一個？ Example:&lt;?php__(&#x27;Action&#x27;) Answer:會使用 nl/action 這個檔案, 所以務必要避免衝突 # Retrieving Translation Strings以下的 Laravel example code 的意思是？ Example:&lt;?phpecho __(&#x27;messages.welcome&#x27;); Answer:取得 default locale directory 中的 messages file 中的 welcome string key 的 value 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho __(&#x27;I love programming.&#x27;); Answer:取得 default locale json file 中的 translation string key 的 value 以下的 Laravel example code 的意思是？ Example:&lt;?php&#123;&#123; __(&#x27;messages.welcome&#x27;) &#125;&#125; Answer:在 blade method 中使用 __() 取得 default locale directory 中, message file 中的 welcome string key 的 value # Replacing Parameters In Translation Strings以下的 Laravel example code 的意思是？ Example:&lt;?php// 在 localization 檔案中&#x27;welcome&#x27; =&gt; &#x27;Welcome, :NAME&#x27;, &#x27;goodbye&#x27; =&gt; &#x27;Goodbye, :Name&#x27;,// controller 內echo __(&#x27;messages.welcome&#x27;, [&#x27;name&#x27; =&gt; &#x27;dayle&#x27;]); Answer:// Welcome, DAYLE// Goodbye, Dayle可在 localization 檔案中定義 placeholder, 並如果 placeholder 是大寫開頭, 帶進去的值也會自動地被 capitalised # Pluralization以下的 Laravel example code 的意思是？ Example:&lt;?php// in localization file&#x27;minutes_ago&#x27; =&gt; &#x27;&#123;1&#125; :value minute ago|[2,*] :value minutes ago&#x27;,// in controllerecho trans_choice(&#x27;time.minutes_ago&#x27;, 5, [&#x27;value&#x27; =&gt; 5]); Answer:Localization file 內, 可使用 | 定義 singular 以及 plural transaction string, 然後透過 trans_choice() arg2 帶入的參數來決定 singular 或 plural, 也可在 arg3 帶入 placeholder 的 value 以下的 Laravel example code 的意思是？ Example:&lt;?php&#123; &quot;There is one apple|There are many apples&quot;: &quot;Hay una manzana|Hay muchas manzanas&quot;&#125;// 或&#x27;apples&#x27; =&gt; &#x27;There is one apple|There are many apples&#x27;,// in controllertrans_choice(&#x27;message.apples&#x27;, 5) Answer:// There are many apples使用 | 來定義單複數, trans_choice arg2 可判斷單複數, 並取得定義好的 string 以下的 Laravel example code 的意思是？ Example:&lt;?php// in localization file&#x27;apples&#x27; =&gt; &#x27;&#123;0&#125; There are none|&#123;1&#125; There is one|[2,*] There are :count&#x27;,// in controllerreturn trans_choice(&#x27;message.apples&#x27;, 10) Answer:// There are 10若要 display arg2 integer value, 可使用 default 的 :count # Overriding Package Language FilesLaravel 中, 假如有個 package 有自己的 localization file, 該 package 名為 skyrim/hearthfire, 那我該怎麼覆寫它？resources/lang/vendor/hearthfire/en/messages.php","link":"/zh-tw/laravel-digging-deeper-localization/"},{"title":"Laravel - Digging Deeper - Notifications (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Creating NotificationsLaravel Notifications 中, 如果我要使用 CLI 建立 notification, 可以怎麼做？php artisan make:notification NotificationName # Sending Notifications# Using The Notifiable TraitLaravel Notifications 中, 要發送一個 notification 有哪兩種方式？ Notifiable trait Notification facade Laravel Notifications 中, 哪個 model 預設就有使用 Notifiable trait?User model Laravel Notifications 中, Notifiable trait 可以使用在哪些 model 上？每一個 model 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Notifications\\InvoicePaid;$user-&gt;notify(new InvoicePaid($invoice)); Answer:使用 notifiable trait 的 notify() 將該 notification 發送給該 user, 具體使用哪一種 notification type 視乎在 InvoicePaid 中的 via method 如何定義 # Using The Notification FacadeLaravel Notifications 中, 什麼情境下比較適合使用 Notification Facade?當我要發送 notification 給多個對象時 以下的 Laravel example code 的意思是? Example:&lt;?phpNotification::send($users, new InvoicePaid($invoice)); Answer:使用 Notification facade 一次發送 notification 給多個 user # Specifying Delivery ChannelsLaravel Notifications 中, 哪一個 method 決定 notification 要以什麼樣的形式被傳送, 例如 mail, 或 slack 等等…via method Laravel Notifications 中, 哪個網站可以看到 notification 支援 channel 總表？這裏 解釋以下 Laravel Notification example Example:&lt;?phppublic function via($notifiable)&#123; return $notifiable-&gt;prefers_sms ? [&#x27;nexmo&#x27;] : [&#x27;mail&#x27;, &#x27;database&#x27;];&#125; Answer:如果 $notifiable 的 attribute prefers_sms 為 true, 則經由 nexmo 發送, 否則則經由 mail 以及 database Laravel Notifications 中, $notifiable 代表？Notification 要發送到的 instance, 例如我要發送到指定 user, 那 $notifiable 就代表該 user model # Queueing Notifications以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Notifications;use Illuminate\\Bus\\Queueable;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Notifications\\Notification;class InvoicePaid extends Notification implements ShouldQueue&#123; use Queueable; // ...&#125; Answer:implement ShouldQueue interface, 該 notification 將會被 queueuse Queueable trait, 該 notification 內可使用 Queueable trait 定義的 method 以下的 Laravel example code 的意思是？ Example:&lt;?php$when = now()-&gt;addMinutes(10);$user-&gt;notify((new InvoicePaid($invoice))-&gt;delay($when)); Answer:不立即發送 notification, 會 delay $when 之後再執行 # On-Demand Notifications以下的 Laravel example code 的意思是？ Example:&lt;?phpNotification::route(&#x27;mail&#x27;, &#x27;ray@example.com&#x27;) -&gt;route(&#x27;nexmo&#x27;, &#x27;3333&#x27;) -&gt;notify(new InvoicePaid($invoice)); Answer:使用 Notification class 的 route method, 可指定 channel 以及接收方並傳送, 儘管接收方並不存在於 database # Mail Notifications# Formatting Mail MessagesLaravel Notifications 中, 如果 notification 會以 mail 的形式被傳送, 那我需要再 Notification class 中使用 哪一個 method 來定義 mail 內容?toMail method 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; $url = url(&#x27;/invoice/&#x27;.$this-&gt;invoice-&gt;id); return (new MailMessage) -&gt;greeting(&#x27;Hello!&#x27;) -&gt;line(&#x27;One of your invoices has been paid!&#x27;) -&gt;action(&#x27;View Invoice&#x27;, $url) -&gt;line(&#x27;Thank you for using our application!&#x27;);&#125; Answer:在 notification 的 toMail() 中定義 mail 的格式以及內容 # Other Notification Formatting OptionsLaravel Notifications 中, 除了使用 lines 語法在 toMail method 裡頭定義 mail 格式外, 如果我想要使用 template 來定義, 可以使用 MailMessage 的哪一個 method?view method 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; return (new MailMessage)-&gt;view( &#x27;emails.name&#x27;, [&#x27;invoice&#x27; =&gt; $this-&gt;invoice] );&#125; Answer:在 notification 的 tiMail() 中, 使用 MailMessage class 的 view(), 以 template 來定義 mail 格式以及內容 Laravel Notifications 中, 在 toMail method 中, 可以使用哪幾種方式來定義 mail 內容或格式？ greeting 等等的 syntax view mailable class markdown # Error Messages以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; return (new MailMessage) -&gt;error() -&gt;subject(&#x27;Notification Subject&#x27;) -&gt;line(&#x27;...&#x27;);&#125; Answer:使用 error() 當該 mail 內容是與 error 有關 # Customizing The SenderLaravel Notifications 中, 預設的 mail sender 定義在哪個檔案中config/mail.php 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; return (new MailMessage) -&gt;from(&#x27;test@example.com&#x27;, &#x27;Example&#x27;) -&gt;line(&#x27;...&#x27;);&#125; Answer:定義 mail sender, 除了可在 config/mail.php 定義之外, 也可使用 from() 定義 # Customizing The Recipient以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Illuminate\\Notifications\\Notifiable;class User extends Authenticatable&#123; use Notifiable; public function routeNotificationForMail($notification) &#123; // Return email address only... return $this-&gt;email_address; &#125;&#125; Answer:當寄送 mail 時, 預設會去尋找 notifiable 的 email property, 如果我不想使用 email, 可以使用 routeNotificationForMail(), 自定義成 email_address # Customizing The SubjectLaravel Notifications 中, 當我使用 mail 發送 notification 時, 預設 subject 是什麼？class name, 如果 class 是 InvoicePaid, subject 就是 Invoice Paid 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; return (new MailMessage) -&gt;subject(&#x27;Notification Subject&#x27;) -&gt;line(&#x27;...&#x27;);&#125; Answer:當使用 mail notification 時, 預設 subject 會是 class name, 比如 InvoicePaid 會變成 Invoice Paid, 可使用 subject() 自定義 # Customizing The Mailer以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; return (new MailMessage) -&gt;mailer(&#x27;postmark&#x27;) -&gt;line(&#x27;...&#x27;);&#125; Answer:若要定義 mailer driver, 除了可在 config/mail.php 定義之外, 也可使用 mailer() 定義 # Customizing The Templates以下的 Laravel example code 的意思是？ Example:php artisan vendor:publish --tag=laravel-notifications Answer:會將 vendor 中的 notification 模板匯出, 可完全自定義 # Previewing Mail Notifications以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;mail&#x27;, function () &#123; $invoice = App\\Invoice::find(1); return (new App\\Notifications\\InvoicePaid($invoice)) -&gt;toMail($invoice-&gt;user);&#125;); Answer:將 InvoicePaid 這個 notification 在 Mail 上是如何顯示的 return 到瀏覽器, 以供確認以及測試 # Markdown Mail Notifications# Generating The Message以下的 Laravel example command 的意思是？ Example:php artisan make:notification InvoicePaid --markdown=mail.invoice.paid Answer:建立一個名為 InvoicePaid 的 notification, 以及一個 markdown, 路徑為 mail/invoice/paid 以下的 Laravel example command 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; $url = url(&#x27;/invoice/&#x27;.$this-&gt;invoice-&gt;id); return (new MailMessage) -&gt;subject(&#x27;Invoice Paid&#x27;) -&gt;markdown(&#x27;mail.invoice.paid&#x27;, [&#x27;url&#x27; =&gt; $url]);&#125; Answer:使用 markdown template 來定義 mail 的格式內容 # Writing The Message# Button Component以下的 Laravel example command 的意思是？ Example:&lt;?php@component(&#x27;mail::button&#x27;, [&#x27;url&#x27; =&gt; $url, &#x27;color&#x27; =&gt; &#x27;green&#x27;])View Invoice@endcomponent Answer:當使用 markdown template 定義 mail 格式內容時, 使用 @component, 建立一個內建的 mail button, 並指定其 url 以及 color # Panel Component以下的 Laravel example command 的意思是？ Example:&lt;?php@component(&#x27;mail::panel&#x27;)This is the panel content.@endcomponent Answer:當使用 markdown template 定義 mail 格式內容時, 使用 mail::panel, 該區塊內的背景顏色會不同, 以凸顯區塊內的文字 # Table Component以下的 Laravel example command 的意思是？ Example:&lt;?php@component(&#x27;mail::table&#x27;)| Laravel | Table | Example || ------------- |:-------------:| --------:|| Col 2 is | Centered | $10 || Col 3 is | Right-Aligned | $20 |@endcomponent Answer:當使用 markdown template 定義 mail 時, 使用 mail::table 定義一個 markdown 格式的 table # Customizing The Components以下的 Laravel example command 的意思是？ Example:php artisan vendor:publish --tag=laravel-mail Answer:會將 vendor 中 mail 的模板全部匯出, 然後可根據需求自定義模板 Laravel Notifications 中, 當我使用以下的 CLI 來匯出 component 的 source 檔時, 會匯出到哪個資料夾？resources/views/vendor/mail # Customizing The CSSLaravel Notifications 中, 如果我要自定義一個 mail markdown 的 theme, 可以在哪個資料夾中定義新的 css 檔案？resources/views/vendor/mail/html/themes Laravel Notifications 中, 如果我在 resources/views/vendor/mail/html/themes 資料夾中自己定義了一個 css 檔案, 接下來我必須要修改哪個檔案的設定來讓他生效？config/mail.php 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toMail($notifiable)&#123; return (new MailMessage) -&gt;theme(&#x27;invoice&#x27;) -&gt;subject(&#x27;Invoice Paid&#x27;) -&gt;markdown(&#x27;mail.invoice.paid&#x27;, [&#x27;url&#x27; =&gt; $url]);&#125; Answer:&lt;?php// 使用 toMail method 來定義 to mail 格式public function toMail($notifiable)&#123; return (new MailMessage) // 指定 theme, 位於 `resources/views/vendor/mail/html/themes` 資料夾, invoice.css 檔案, 若不指定會使用 default.css -&gt;theme(&#x27;invoice&#x27;) // Mail 主題 -&gt;subject(&#x27;Invoice Paid&#x27;) // markdown 模板, 帶 url 參數過去 -&gt;markdown(&#x27;mail.invoice.paid&#x27;, [&#x27;url&#x27; =&gt; $url]);&#125; # Database Notifications# PrerequisitesLaravel Notifications 中, 什麼是 database notification?將 notification 儲存於 database table Laravel Notifications 中, 如果我要使用 CLI 建立一個 notification table, 該怎麼做？php artisan notifications:tablephp artisan migrate # Formatting Database NotificationsLaravel Notifications 中, 當我使用 database notification 時, 可使用哪個 method 來定義回傳資料？ toArray() method toDatabase() method Laravel Notifications 中, 如果我在我的 notification 當中同時使用了 database 以及 broadcast, 那針對 database notification 我該使用哪個 method 來定義其內容？toDatabase method Laravel Notifications 中, 當我使用 database notification 時, toDatabase method 的回傳格式必須是？array Laravel Notifications 中, 當我使用 database notification 時, toDatabase method 回傳值會被以什麼格式存在 data column？JSON Laravel Notifications 中, 當我使用 database notification 時, toDatabase method 回傳值會被以 JSON 格式存在哪一個 column？data 以下的 Laravel example command 的意思是？ Example:&lt;?phppublic function toArray($notifiable)&#123; return [ &#x27;invoice_id&#x27; =&gt; $this-&gt;invoice-&gt;id, &#x27;amount&#x27; =&gt; $this-&gt;invoice-&gt;amount, ];&#125; Answer:在 notification 內, 當使用 database notification 時, 使用 toArray() 定義內容toArray() 可用於 broadcast 以及 database, 當兩者都有用到時, 請使用 toDatabase 以及 toBroadcast # Accessing The NotificationsLaravel Notifications 中, 如果我要從 notifiable model 來存取 notification data, 我可以使用哪一個 trait?Illuminate\\Notifications\\Notifiable trait Laravel Notifications 中, notification 預設會以什麼排序？created_at 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = App\\User::find(1);foreach ($user-&gt;unreadNotifications as $notification) &#123; echo $notification-&gt;type;&#125; Answer:當使用 Database notification 時, 可以使用 unreadNotifications relation 取得所有未讀的 notification # Marking Notifications As Read以下的 Laravel example command 的意思是？ Example:&lt;?php$user = App\\User::find(1);foreach ($user-&gt;unreadNotifications as $notification) &#123; $notification-&gt;markAsRead();&#125; Answer:當使用 database notification 時, 可使用 markAsRead() 標記特定 notification as read Laravel Notifications 中, 當我使用 markAsRead() method 時, 可以使用在 collection 上嗎？可 以下的 Laravel testing example code 的意思是？ Example:&lt;?php$user-&gt;notifications()-&gt;delete(); Answer:刪除該 user 的 database notification # Broadcast Notifications# Formatting Broadcast NotificationsLaravel Notifications 中, 如果我使用 event broadcasting 來發送 notification, 該使用哪個 method?toBroadcast method Laravel Notifications 中, 如果我使用 event broadcasting 來發送 notification, 當 toBroadcast method 不存在於, Laravel 會使用哪個 method??toArray method 以下的 Laravel example code 的意思是? Example:&lt;?phppublic function toBroadcast($notifiable)&#123; return new BroadcastMessage([ &#x27;invoice_id&#x27; =&gt; $this-&gt;invoice-&gt;id, &#x27;amount&#x27; =&gt; $this-&gt;invoice-&gt;amount, ]);&#125; Answer:在 toBroadcast method 內, 使用 new BroadcastMessage instance 來定義 broadcast message # Broadcast Queue Configuration以下的 Laravel example command 的意思是？ Example:&lt;?phpreturn (new BroadcastMessage($data)) -&gt;onConnection(&#x27;sqs&#x27;) -&gt;onQueue(&#x27;broadcasts&#x27;); Answer:在 broadcast notification 中指定 queue 以及 connection # Customizing The Notification Type以下的 Laravel example command 的意思是？ Example:&lt;?phpuse Illuminate\\Notifications\\Messages\\BroadcastMessage;public function broadcastType()&#123; return &#x27;broadcast.message&#x27;;&#125; Answer:預設 broadcast notification type 為 notification 的 full class name, 若要自定義, 可使用 broadcastType() # Listening For Notifications以下的 Laravel example code 的意思是？ Example:&lt;?phpEcho.private(&#x27;App.User.&#x27; + userId) .notification((notification) =&gt; &#123; console.log(notification.type); &#125;); Answer:Laravel echo 可以 listen 事先定義好的 channel, 並接收 broadcast 後採取後續動作listen private channel ‘App.User.userId’, userId 為動態的, 之後再 console.log notification object 的 type property # Customizing The Notification Channel以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Broadcasting\\PrivateChannel;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Illuminate\\Notifications\\Notifiable;class User extends Authenticatable&#123; use Notifiable; public function receivesBroadcastNotificationsOn() &#123; return &#x27;users.&#x27;.$this-&gt;id; &#125;&#125; Answer:當 notifiable 為 user 時, 在 user model 中定義 Broadcast notification 的對象 channel # SMS Notifications# PrerequisitesLaravel Notifications 中, 當我要使用 Nexmo 來發送 SMS notification 時, 要先安裝什麼？Nexmo 套件 composer require laravel/nexmo-notification-channel Laravel Notifications 中, 當我使用 Nexmo 來發送 SMS notification 時, 需在哪個檔案中定義發送端的號碼？config/services.php 以下位於 config/services.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;nexmo&#x27; =&gt; [ &#x27;sms_from&#x27; =&gt; &#x27;15556666666&#x27;,], Answer:定義 Nexmo sender 的號碼 # Formatting SMS NotificationsLaravel Notifications 中, 如果使用 SMS notification 的話, notification class 中該使用哪一個 method 來定義內容？toNexmo method 以下位於 Notification 的 Laravel example code 的意思是？ Example:&lt;?phppublic function toNexmo($notifiable)&#123; return (new NexmoMessage) -&gt;content(&#x27;Your SMS message content&#x27;);&#125; Answer:定義 Nexmo message 的內容, 然後可以在 via method 內使用 Nexmo # Formatting Shortcode NotificationsLaravel Notifications 中, 什麼是 shortcode notification?Nexmo 帳號中事先定義好的模板 Laravel Notifications 中, 如果我要使用 shotcode notification, 該使用哪個 method?toShartcode method Laravel Notifications 中, shortcode notification 有哪幾種 type? alert 2fa marketing Laravel Notifications 中, 當使用 shortcode notification 時, 需要在 notifiable model 當中定義哪個 method 來定義接收方?routeNotificationForShortcode method # Unicode Content以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toNexmo($notifiable)&#123; return (new NexmoMessage) -&gt;content(&#x27;Your unicode message&#x27;) -&gt;unicode();&#125; Answer:使用 Nexmo notification 時, 如果 content 含有 unicode, 需加上 unicode() # Customizing The “From” NumberLaravel Notifications 中, 當使用 Nexmo notification 時, 預設的傳送人號碼被定義在哪？config/services.php 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toNexmo($notifiable)&#123; return (new NexmoMessage) -&gt;content(&#x27;Your SMS message content&#x27;) -&gt;from(&#x27;15554443333&#x27;);&#125; Answer:除了在 config/service.php 可定義發送人的號碼外, 也可使用 from() 指定 # Routing SMS Notifications以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Illuminate\\Notifications\\Notifiable;class User extends Authenticatable&#123; use Notifiable; public function routeNotificationForNexmo($notification) &#123; return $this-&gt;phone_number; &#125;&#125; Answer:當使用 Nexmo notification 時, 可在 User model 的 routeNotificationForNexmo method 定義 user phone number 實際上的 column name # Slack Notifications# PrerequisitesLaravel Notifications 中, 若要使用 Slack notification, 需要另外安裝套件嗎？要哦 composer require laravel/slack-notification-channel # Formatting Slack NotificationsLaravel Notifications 中, 當我使用 Slack notification 時, 該在 notification class 當中使用哪一個 method 來定義格式跟內容？toSlack method 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function toSlack($notifiable)&#123; return (new SlackMessage) -&gt;from(&#x27;Laravel&#x27;, &#x27;emoji&#x27;) -&gt;to(&#x27;username or channel&#x27;) -&gt;image(&#x27;https://laravel.com/img/favicon/favicon.ico&#x27;) -&gt;content(&#x27;This will display the Laravel logo next to the message&#x27;);&#125; Answer:&lt;?php// 使用 toSlack method 來定義格式內容public function toSlack($notifiable)&#123; return (new SlackMessage) // 寄件方的名字, emoji -&gt;from(&#x27;Laravel&#x27;, &#x27;emoji&#x27;) // 收件方 username 或 channel -&gt;to(&#x27;username or channel&#x27;) // 寄件方 logo -&gt;image(&#x27;https://laravel.com/img/favicon/favicon.ico&#x27;) // 內文 -&gt;content(&#x27;This will display the Laravel logo next to the message&#x27;);&#125; # Slack Attachments以下位於 notification 的 Laravel example code 的意思是？ Example: &lt;?phppublic function toSlack($notifiable)&#123; $url = url(&#x27;/exceptions/&#x27;.$this-&gt;exception-&gt;id); return (new SlackMessage) -&gt;error() -&gt;content(&#x27;Whoops! Something went wrong.&#x27;) -&gt;attachment(function ($attachment) use ($url) &#123; $attachment-&gt;title(&#x27;Exception: File Not Found&#x27;, $url) -&gt;content(&#x27;File [background.jpg] was not found.&#x27;); &#125;);&#125; Answer:使用 attachment() 定義更豐富的格式選項, 如下 picture Picture: 以下位於 notification 的 Laravel example code 的意思是？ Example: &lt;?phppublic function toSlack($notifiable)&#123; $url = url(&#x27;/invoices/&#x27;.$this-&gt;invoice-&gt;id); return (new SlackMessage) -&gt;success() -&gt;content(&#x27;One of your invoices has been paid!&#x27;) -&gt;attachment(function ($attachment) use ($url) &#123; $attachment-&gt;title(&#x27;Invoice 1322&#x27;, $url) -&gt;fields([ &#x27;Title&#x27; =&gt; &#x27;Server Expenses&#x27;, &#x27;Amount&#x27; =&gt; &#x27;$1,234&#x27;, &#x27;Via&#x27; =&gt; &#x27;American Express&#x27;, &#x27;Was Overdue&#x27; =&gt; &#x27;:-1:&#x27;, ]); &#125;);&#125; Answer:使用 fields(), 定義 table 的效果 Picture: # Markdown Attachment Content以下位於 notification 的 Laravel example code 的意思是？ Example:&lt;?phppublic function toSlack($notifiable)&#123; $url = url(&#x27;/exceptions/&#x27;.$this-&gt;exception-&gt;id); return (new SlackMessage) -&gt;error() -&gt;content(&#x27;Whoops! Something went wrong.&#x27;) -&gt;attachment(function ($attachment) use ($url) &#123; $attachment-&gt;title(&#x27;Exception: File Not Found&#x27;, $url) -&gt;content(&#x27;File [background.jpg] was *not found*.&#x27;) -&gt;markdown([&#x27;text&#x27;]); &#125;);&#125; Answer:使用 markdown() 定義 markdown 語法 Laravel Slack Notifications 中, 有關 markdown format 的詳細資訊, 可以參考？Slack API Document # Routing Slack NotificationsLaravel Slack Notifications 中, notifiable entity 中的 routeNotificationForSlack 應該要 return 什麼？webhook URL Laravel Slack Notifications 中, 該在 notifiable entity 當中使用哪個 method 來定義接收方？routeNotificationForSlack method # Localizing Notifications以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;notify((new InvoicePaid($invoice))-&gt;locale(&#x27;es&#x27;)); Answer:使用 notifiable trait send notification 並使用 locale() 定義 notification locale 以下的 Laravel example code 的意思是？ Example:&lt;?phpNotification::locale(&#x27;es&#x27;)-&gt;send($users, new InvoicePaid($invoice)); Answer:使用 notification facade send notification 給多個 users 並使用 locale() 定義 notification locale # User Preferred Locales以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Contracts\\Translation\\HasLocalePreference;class User extends Model implements HasLocalePreference&#123; public function preferredLocale() &#123; return $this-&gt;locale; &#125;&#125; Answer:implement HasLocalePreference, 並使用 preferredLocale() 定義每個 user 的 locale, example 中假定在每個 user row 中都有定義 locale # Notification EventsLaravel Notifications 中, 每當 notification 被傳送了, 都會觸發一個什麼事件？Illuminate\\Notifications\\Events\\NotificationSent Laravel Notifications 中, 如果我想要註冊一個事件, 每當 notification 被傳送就會觸發這個事件, 那麼我可以在哪個檔案中註冊這個事件的 listener？EventServiceProvider 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass EventServiceProvider extends ServiceProvider&#123; protected $listen = [ &#x27;Illuminate\\Notifications\\Events\\NotificationSent&#x27; =&gt; [ &#x27;App\\Listeners\\LogNotification&#x27;, ], ];&#125; Answer:在 EventServiceProvider 的 $listen property 中, 定義了每當 notification 傳送, 就觸發 LogNotification listener 以下位於 custom listener 的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle(NotificationSent $event)&#123; $event-&gt;channel $event-&gt;notifiable $event-&gt;notification $event-&gt;response&#125; Answer:&lt;?php// 註冊一個 Listener, 監聽 NotificationSent event, 每當 notification sent, 就觸發此 Listenerpublic function handle(NotificationSent $event)&#123; // 取得該 notification 的 channel $event-&gt;channel // 取得該 notification 的 notifiable instance $event-&gt;notifiable // 取得該 notification 的 notification instance $event-&gt;notification // 取得該 notification 的 response instance $event-&gt;response&#125; # Custom ChannelsLaravel Notifications 中, 如果我想要自定義我自己的 channel, 可以參考哪裡？官方文件","link":"/zh-tw/laravel-digging-deeper-notifications/"},{"title":"Laravel - Digging Deeper - Helpers (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Method Listing# Arrays &amp; Objects# Arr::accessible()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;use Illuminate\\Support\\Collection;$isAccessible = Arr::accessible([&#x27;a&#x27; =&gt; 1, &#x27;b&#x27; =&gt; 2]);$isAccessible = Arr::accessible(new Collection);$isAccessible = Arr::accessible(&#x27;abc&#x27;);$isAccessible = Arr::accessible(new stdClass); Answer:判斷 parameter 是否 array accessible Output:&lt;?php// true// true// false// false # Arr::add()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = Arr::add([&#x27;name&#x27; =&gt; &#x27;Desk&#x27;], &#x27;price&#x27;, 100);$array = Arr::add([&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; null], &#x27;price&#x27;, 100); Answer:將 key / value 加到 arg1 array如果 given key 不存在於該 array, 或存在但其 value 為 null Output:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100]// [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100] # Arr::collapse()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); Answer:將含有多個 arrays 的 array 變成一個 single array Output:&lt;?php// [1, 2, 3, 4, 5, 6, 7, 8, 9] # Arr::crossJoin()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$matrix = Arr::crossJoin([1, 2], [&#x27;a&#x27;, &#x27;b&#x27;]);$matrix = Arr::crossJoin([1, 2], [&#x27;a&#x27;, &#x27;b&#x27;], [&#x27;I&#x27;, &#x27;II&#x27;]); Answer:cross join 帶入的 array Output:&lt;?php/* [ [1, &#x27;a&#x27;], [1, &#x27;b&#x27;], [2, &#x27;a&#x27;], [2, &#x27;b&#x27;], ]*//* [ [1, &#x27;a&#x27;, &#x27;I&#x27;], [1, &#x27;a&#x27;, &#x27;II&#x27;], [1, &#x27;b&#x27;, &#x27;I&#x27;], [1, &#x27;b&#x27;, &#x27;II&#x27;], [2, &#x27;a&#x27;, &#x27;I&#x27;], [2, &#x27;a&#x27;, &#x27;II&#x27;], [2, &#x27;b&#x27;, &#x27;I&#x27;], [2, &#x27;b&#x27;, &#x27;II&#x27;], ]*/ # Arr::divide()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;[$keys, $values] = Arr::divide([&#x27;name&#x27; =&gt; &#x27;Desk&#x27;]); Answer:返回兩個 arrays, 一個裝 key, 一個裝 value Output:&lt;?php// $keys: [&#x27;name&#x27;]// $values: [&#x27;Desk&#x27;] # Arr::dot()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];$flattened = Arr::dot($array); Answer:將一個 multi-dimensional array 變成一個 single array, 並使用 . (英文句點符號) 來表示 depth Output:&lt;?php// [&#x27;products.desk.price&#x27; =&gt; 100] # Arr::except()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100];$filtered = Arr::except($array, [&#x27;price&#x27;]); Answer:將指定於 arg2 的 key 從 arg1 array 中移除 Output:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;] # Arr::exists()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;name&#x27; =&gt; &#x27;John Doe&#x27;, &#x27;age&#x27; =&gt; 17];$exists = Arr::exists($array, &#x27;name&#x27;);$exists = Arr::exists($array, &#x27;salary&#x27;); Answer:判斷 arg2 的 key 是否存在於 arg1 array Output:&lt;?php// true// false # Array::first()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [100, 200, 300];$first = Arr::first($array, function ($value, $key) &#123; return $value &gt;= 150;&#125;); Answer:回傳 arg1 array 中第一個符合 arg2 closure 中邏輯的輸出 Output:&lt;?php// 200 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$first = Arr::first($array, $callback, $default); Answer:回傳 arg1 array 中第一個符合 arg2 closure 中邏輯的輸出, 如果 array 中沒有出現符合的 item, 則 return arg3 $default # Arr::flatten()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;name&#x27; =&gt; &#x27;Joe&#x27;, &#x27;languages&#x27; =&gt; [&#x27;PHP&#x27;, &#x27;Ruby&#x27;]];$flattened = Arr::flatten($array); Answer:將一個 multi-dimensional array 變為一個 single array Output:&lt;?php// [&#x27;Joe&#x27;, &#x27;PHP&#x27;, &#x27;Ruby&#x27;] # Arr::forget()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];Arr::forget($array, &#x27;products.desk&#x27;); Answer:將 arg2 指定 key 從 arg1 $array 中移除可使用 . (英文句點符號) 來表示 depth Output:&lt;?php// [&#x27;products&#x27; =&gt; []] # Arr::get()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];$price = Arr::get($array, &#x27;products.desk.price&#x27;); Answer:從 arg1 $array 中取得 arg2 指定 key 的 value可使用 . (英文句點符號) 來表示 depth Output:&lt;?php// 100 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$discount = Arr::get($array, &#x27;products.desk.discount&#x27;, 0); Answer:從 arg1 $array 中取得 arg2 指定 key 的 value可使用 . (英文句點符號) 來表示 depth如果沒有指定 key, 可指定 default 值 Output:&lt;?php// 0 # Arr::has()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;product&#x27; =&gt; [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100]];$contains = Arr::has($array, &#x27;product.name&#x27;);$contains = Arr::has($array, [&#x27;product.price&#x27;, &#x27;product.discount&#x27;]); Answer:判斷 arg2 指定 key 是否存在於 arg1 $array可使用 . (英文句點符號) 來表示 depth Output:&lt;?php// true// false # Arr::hasAny()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;product&#x27; =&gt; [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100]];$contains = Arr::hasAny($array, &#x27;product.name&#x27;);$contains = Arr::hasAny($array, [&#x27;product.name&#x27;, &#x27;product.discount&#x27;]);$contains = Arr::hasAny($array, [&#x27;category&#x27;, &#x27;product.discount&#x27;]); Answer:判斷 arg2 指定的的多個 item 是否有任何一個存在於 arg1 $array Output:&lt;?php// true// true// false # Arr::isAssoc()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$isAssoc = Arr::isAssoc([&#x27;product&#x27; =&gt; [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100]]);$isAssoc = Arr::isAssoc([1, 2, 3]); Answer:判斷帶入的 array 是否為一個 associative array如果沒有從 0 開始的 sequential number 作為 key 的 array 都視為 associative array Output:&lt;?php// true// false # Arr::last()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [100, 200, 300, 110];$last = Arr::last($array, function ($value, $key) &#123; return $value &gt;= 150;&#125;); Answer:從 arg1 $array 中取得符合 arg2 closure, 從後面往前第一個值 Output:&lt;?php// 300 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$last = Arr::last($array, $callback, $default); Answer:從 arg1 $array 中取得符合 arg2 closure, 從後面往前第一個值若無符合, 則回傳 default 值 # Arr::only()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100, &#x27;orders&#x27; =&gt; 10];$slice = Arr::only($array, [&#x27;name&#x27;, &#x27;price&#x27;]); Answer:從 arg1 $array 中, 取得符合 arg2 keys 的 item Output:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100] # Arr::pluck()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [ [&#x27;developer&#x27; =&gt; [&#x27;id&#x27; =&gt; 1, &#x27;name&#x27; =&gt; &#x27;Taylor&#x27;]], [&#x27;developer&#x27; =&gt; [&#x27;id&#x27; =&gt; 2, &#x27;name&#x27; =&gt; &#x27;Abigail&#x27;]],];$names = Arr::pluck($array, &#x27;developer.name&#x27;); Answer:從 arg1 $array 中, 取得所有符合 arg2 key 的 values可使用 . (英文句點符號) 來表示 depth Output:&lt;?php// [&#x27;Taylor&#x27;, &#x27;Abigail&#x27;] 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$names = Arr::pluck($array, &#x27;developer.name&#x27;, &#x27;developer.id&#x27;); Answer:從 arg1 $array 中, 取得所有符合 arg2 key 的 values, 可使用 arg3 定義 value 的 key可使用 . (英文句點符號) 來表示 depth Output:&lt;?php// [1 =&gt; &#x27;Taylor&#x27;, 2 =&gt; &#x27;Abigail&#x27;] # Arr::prepend()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;];$array = Arr::prepend($array, &#x27;zero&#x27;); Answer:將 arg2 的 item push 的 arg1 $array 的開始處 Output:&lt;?php// [&#x27;zero&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;] 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;price&#x27; =&gt; 100];$array = Arr::prepend($array, &#x27;Desk&#x27;, &#x27;name&#x27;); Answer:將 arg2 的 item push 的 arg1 $array 的開始處, 若有需要, 可使用 arg3 定義 value 的 key Output:&lt;?php// [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100] # Arr::pull()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;, &#x27;price&#x27; =&gt; 100];$name = Arr::pull($array, &#x27;name&#x27;); Answer:從 arg1 $array 中, 取出並同時從 $array 中移除符合 arg2 key 的 item Output:&lt;?php// $name: Desk// $array: [&#x27;price&#x27; =&gt; 100] 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$value = Arr::pull($array, $key, $default); Answer:從 arg1 $array 中, 取出並同時從 $array 中移除符合 arg2 key 的 item, 可定義 arg3 default 值, 當無符合的 item 時將回傳 default 值 # Arr::query()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [ &#x27;name&#x27; =&gt; &#x27;Taylor&#x27;, &#x27;order&#x27; =&gt; [ &#x27;column&#x27; =&gt; &#x27;created_at&#x27;, &#x27;direction&#x27; =&gt; &#x27;desc&#x27; ]];Arr::query($array); Answer:將 parameter $array 轉為 query string Output:&lt;?php// name=Taylor&amp;order[column]=created_at&amp;order[direction]=desc # Arr::random()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [1, 2, 3, 4, 5];$random = Arr::random($array); Answer:隨機 return $array 中的一個 value Output:&lt;?php// 4 - (retrieved randomly) 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$items = Arr::random($array, 2); Answer:隨機 return $array 中的一個 value, arg2 可以指定要隨機 return value 的數量 Output:&lt;?php// [2, 5] - (retrieved randomly) # Arr::set()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];Arr::set($array, &#x27;products.desk.price&#x27;, 200); Answer:在 arg1 $array 中, set key / value = arg2 / arg3可使用 . (英文句點符號) 來表示 depth Output:&lt;?php// [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 200]]] # Arr::shuffle()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = Arr::shuffle([1, 2, 3, 4, 5]); Answer:將 parameter array 順序隨機打亂 Output:&lt;?php// [3, 2, 5, 1, 4] - (generated randomly) # Arr::sort()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [&#x27;Desk&#x27;, &#x27;Table&#x27;, &#x27;Chair&#x27;];$sorted = Arr::sort($array); Answer:sort $array Output:&lt;?php// [&#x27;Chair&#x27;, &#x27;Desk&#x27;, &#x27;Table&#x27;] 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [ [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;name&#x27; =&gt; &#x27;Table&#x27;], [&#x27;name&#x27; =&gt; &#x27;Chair&#x27;],];$sorted = array_values(Arr::sort($array, function ($value) &#123; return $value[&#x27;name&#x27;];&#125;)); Answer:根據 closure 的回傳值來做 sorting Output:&lt;?php/* [ [&#x27;name&#x27; =&gt; &#x27;Chair&#x27;], [&#x27;name&#x27; =&gt; &#x27;Desk&#x27;], [&#x27;name&#x27; =&gt; &#x27;Table&#x27;], ]*/ # Arr::sortRecursive()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [ [&#x27;Roman&#x27;, &#x27;Taylor&#x27;, &#x27;Li&#x27;], [&#x27;PHP&#x27;, &#x27;Ruby&#x27;, &#x27;JavaScript&#x27;], [&#x27;one&#x27; =&gt; 1, &#x27;two&#x27; =&gt; 2, &#x27;three&#x27; =&gt; 3],];$sorted = Arr::sortRecursive($array); Answer:recursively sort $array, 使用 sort() 排序 numerically indexed sub-arrays, 使用 ksort() 排序 associative sub-arrays Output:&lt;?php/* [ [&#x27;JavaScript&#x27;, &#x27;PHP&#x27;, &#x27;Ruby&#x27;], [&#x27;one&#x27; =&gt; 1, &#x27;three&#x27; =&gt; 3, &#x27;two&#x27; =&gt; 2], [&#x27;Li&#x27;, &#x27;Roman&#x27;, &#x27;Taylor&#x27;], ]*/ # Arr::where()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = [100, &#x27;200&#x27;, 300, &#x27;400&#x27;, 500];$filtered = Arr::where($array, function ($value, $key) &#123; return is_string($value);&#125;); Answer:使用 arg2 closure 過濾 arg1 $array Output:&lt;?php// [1 =&gt; &#x27;200&#x27;, 3 =&gt; &#x27;400&#x27;] # Arr::wrap()以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$string = &#x27;Laravel&#x27;;$array = Arr::wrap($string); Answer:會用 array 將 given parameter 包起來, 如果 given parameter 已經是 array, 那則不變 Output:&lt;?php// [&#x27;Laravel&#x27;] 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Arr;$array = Arr::wrap(null); Answer:如果 given parameter 為 null, 則 return empty array Output:&lt;?php// [] # data_fill()以下的 Laravel example code 的意思是？ Example:&lt;?php$data = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];data_fill($data, &#x27;products.desk.price&#x27;, 200);data_fill($data, &#x27;products.desk.discount&#x27;, 10); Answer:使用 &#39;dot&#39; notation 代表 depth, 將 arg2 key / arg3 value fill 到 arg1 $data (如果不存在的話), $data 可以是 array 或 object與 data_set 的差異在於, 如果指定 key 已存在, data_fill 不會覆蓋, data_set 會 Output:&lt;?php// [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]]// [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100, &#x27;discount&#x27; =&gt; 10]]] 以下的 Laravel example code 的意思是？ Example:&lt;?php$data = [ &#x27;products&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;Desk 1&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;name&#x27; =&gt; &#x27;Desk 2&#x27;], ],];data_fill($data, &#x27;products.*.price&#x27;, 200); Answer:使用 &#39;dot&#39; notation 代表 depth, 將 arg2 key / arg3 value set 到 arg1 $data (如果不存在的話), $data 可以是 array 或 object, 也可使用 * 來代表 wildcard, 一次性設定多個 sub-array 中的 key Output:&lt;?php/* [ &#x27;products&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;Desk 1&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;name&#x27; =&gt; &#x27;Desk 2&#x27;, &#x27;price&#x27; =&gt; 200], ], ]*/ # data_get()以下的 Laravel example code 的意思是？ Example:&lt;?php$data = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];$price = data_get($data, &#x27;products.desk.price&#x27;); Answer:從 arg1 $data 中取得 arg2 指定的 item, 使用 . (英文句點符號) 來表示 depth, $data 可以是 array 或 object Output:&lt;?php// 100 以下的 Laravel example code 的意思是？ Example:&lt;?php$discount = data_get($data, &#x27;products.desk.discount&#x27;, 0);// 0 Answer:從 arg1 $data 中取得 arg2 指定的 item, 使用 . (英文句點符號) 來表示 depth, $data 可以是 array 或 object, 也可在 arg3 定義 default 值, 當 arg2 item 不存在時 return default 值 以下的 Laravel example code 的意思是？ Example:&lt;?php$data = [ &#x27;product-one&#x27; =&gt; [&#x27;name&#x27; =&gt; &#x27;Desk 1&#x27;, &#x27;price&#x27; =&gt; 100], &#x27;product-two&#x27; =&gt; [&#x27;name&#x27; =&gt; &#x27;Desk 2&#x27;, &#x27;price&#x27; =&gt; 150],];data_get($data, &#x27;*.name&#x27;); Answer:從 arg1 $data 中取得 arg2 指定的 item, 使用 . (英文句點符號) 來表示 depth, $data 可以是 array 或 object, 也可使用 * (星號) 表示 wildcard, 取出多個 sub-arrays 中的指定 item Output:&lt;?php// [&#x27;Desk 1&#x27;, &#x27;Desk 2&#x27;]; # data_set()以下的 Laravel example code 的意思是？ Example:&lt;?php$data = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];data_set($data, &#x27;products.desk.price&#x27;, 200); Answer:使用 &#39;dot&#39; notation 代表 depth, 將 arg2 key / arg3 value set 到 arg1 $data (如果不存在的話), $data 可以是 array 或 object與 data_set 的差異在於, 如果指定 key 已存在, data_fill 不會覆蓋, data_set 會 Output:&lt;?php// [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 200]]] 以下的 Laravel example code 的意思是？ Example:&lt;?php$data = [ &#x27;products&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;Desk 1&#x27;, &#x27;price&#x27; =&gt; 100], [&#x27;name&#x27; =&gt; &#x27;Desk 2&#x27;, &#x27;price&#x27; =&gt; 150], ],];data_set($data, &#x27;products.*.price&#x27;, 200); Answer:使用 &#39;dot&#39; notation 代表 depth, 將 arg2 key / arg3 value set 到 arg1 $data (如果不存在的話), $data 可以是 array 或 object也可使用 * (星號) 表示 wildcard, 在多個 sub-arrays 中, set 指定 item與 data_set 的差異在於, 如果指定 key 已存在, data_fill 不會覆蓋, data_set 會 Output:&lt;?php/* [ &#x27;products&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;Desk 1&#x27;, &#x27;price&#x27; =&gt; 200], [&#x27;name&#x27; =&gt; &#x27;Desk 2&#x27;, &#x27;price&#x27; =&gt; 200], ], ]*/ 以下的 Laravel example code 的意思是？ Example:&lt;?php$data = [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]];data_set($data, &#x27;products.desk.price&#x27;, 200, $overwrite = false); Answer:使用 &#39;dot&#39; notation 代表 depth, 將 arg2 key / arg3 value set 到 arg1 $data (如果不存在的話), $data 可以是 array 或 object與 data_set 的差異在於, 如果指定 key 已存在, data_fill 不會覆蓋, data_set 會data_set 預設會複寫, 也可在 arg4 帶入 $overwrite = false, 這樣就不會複寫已存在的 key Output:&lt;?php// [&#x27;products&#x27; =&gt; [&#x27;desk&#x27; =&gt; [&#x27;price&#x27; =&gt; 100]]] # head()以下的 Laravel example code 的意思是？ Example:&lt;?php$array = [100, 200, 300];$first = head($array); Answer:return 帶入 array 中的第一個 item Output:&lt;?php// 100 # last()以下的 Laravel example code 的意思是？ Example:&lt;?php$array = [100, 200, 300];$last = last($array); Answer:return given array 中的最後一個 item Output:&lt;?php// 300 # Paths以下的 Laravel example code 的意思是？ Example:&lt;?php$path = app_path();$path = app_path(&#x27;Http/Controllers/Controller.php&#x27;); Answer:取得通往 project 中, app 資料夾的系統絕對路徑, 比如說你的 project 放在 /var/www/projects 中, 那路徑就會是 /var/www/projects/yourProjectName/app, 也可帶入 app 資料夾中的任何檔案相對位置 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = base_path();$path = base_path(&#x27;vendor/bin&#x27;); Answer:取得通往 project 的系統絕對路徑, 比如說你的 project 放在 /var/www/projects 中, 那路徑就會是 /var/www/projects/yourProjectName, 也可帶入 project 中的任何檔案相對位置 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = config_path();$path = config_path(&#x27;app.php&#x27;); Answer:取得通往 project 的 config 資料夾系統絕對路徑, 比如說你的 project 放在 /var/www/projects 中, 那路徑就會是 /var/www/projects/yourProjectName/config, 也可帶入 config 資料夾中的任何檔案相對位置 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = database_path();$path = database_path(&#x27;factories/UserFactory.php&#x27;); Answer:取得通往 project 的 database 資料夾系統絕對路徑, 比如說你的 project 放在 /var/www/projects 中, 那路徑就會是 /var/www/projects/yourProjectName/database, 也可帶入 database 資料夾中的任何檔案相對位置 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = mix(&#x27;css/app.css&#x27;); Answer:取得 project mix file 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = public_path();$path = public_path(&#x27;css/app.css&#x27;); Answer:取得通往 project 的 public 資料夾系統絕對路徑, 比如說你的 project 放在 /var/www/projects 中, 那路徑就會是 /var/www/projects/yourProjectName/public, 也可帶入 public 資料夾中的任何檔案相對位置 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = resource_path();$path = resource_path(&#x27;sass/app.scss&#x27;); Answer:取得通往 project 的 resources 資料夾系統絕對路徑, 比如說你的 project 放在 /var/www/projects 中, 那路徑就會是 /var/www/projects/yourProjectName/resources, 也可帶入 resources 資料夾中的任何檔案相對位置 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = storage_path();$path = storage_path(&#x27;app/file.txt&#x27;); Answer:取得通往 project 的 storage 資料夾系統絕對路徑, 比如說你的 project 放在 /var/www/projects 中, 那路徑就會是 /var/www/projects/yourProjectName/storage, 也可帶入 storage 資料夾中的任何檔案相對位置 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho __(&#x27;Welcome to our application&#x27;);echo __(&#x27;messages.welcome&#x27;); Answer:__ function 會使用 localization file 來 translate 帶入的 translation string 或 key, 如果該 translation string 或 key 不存在, 則 return 帶入的 string 以下的 Laravel example code 的意思是？ Example:&lt;?php$class = class_basename(&#x27;Foo\\Bar\\Baz&#x27;);// Baz Answer:class_basename() 可以取得 class name without namespace 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho e(&#x27;&lt;html&gt;foo&lt;/html&gt;&#x27;);// &amp;lt;html&amp;gt;foo&amp;lt;/html&amp;gt; Answer:e() 會執行 PHP htmlspecialchars function, 預設 double_encode option 以下的 Laravel example code 的意思是？ Example:&lt;?php$string = &#x27;The event will take place between :start and :end&#x27;;$replaced = preg_replace_array(&#x27;/:[a-z_]+/&#x27;, [&#x27;8:30&#x27;, &#x27;9:00&#x27;], $string);// The event will take place between 8:30 and 9:00 Answer:在 arg3 $string 中尋找符合 arg1 pattern 的 string, 然後依照順序使用 arg2 array 中的 item 取代 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::after(&#x27;This is my name&#x27;, &#x27;This is&#x27;);// &#x27; my name&#x27; Answer:在 arg1 string 中, 尋找 arg2 的字段, 並 return arg2 之後的字段 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::afterLast(&#x27;App\\Http\\Controllers\\Controller&#x27;, &#x27;\\\\&#x27;);// &#x27;Controller&#x27; Answer:從 arg1 string 中尋找 arg2 的 string 最後一次出現的地方, 然後 return arg2 string 之後的 string, 如果沒找到 arg2 string, 則回傳整個 arg1 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::ascii(&#x27;û&#x27;); Answer:將 arg 移譯成 ASCII value// ‘u’ 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::before(&#x27;This is my name&#x27;, &#x27;my name&#x27;); Answer:在 arg1 string 中, 尋找 arg2 的字段, 並 return arg2 之前的字段// ‘This is ‘ 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::beforeLast(&#x27;This is my name&#x27;, &#x27;is&#x27;);// &#x27;This &#x27; Answer:在 arg1 string 中, 尋找 arg2 的字段, 並 return arg2 最後一次出現時前面的所有字段 以下的 Laravel example code 的意思是？ Example:&lt;?php$slice = Str::between(&#x27;This is my name&#x27;, &#x27;This&#x27;, &#x27;name&#x27;); Answer:從 arg1 string 中, 取得 arg2, arg3 中間的 string// ‘ is my ‘ 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::camel(&#x27;foo_bar&#x27;); Answer:將 string 轉為 camel case// fooBar 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$contains = Str::contains(&#x27;This is my name&#x27;, &#x27;my&#x27;); Answer:判斷 arg1 string 是否含有 arg2 string// true 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$contains = Str::contains(&#x27;This is my name&#x27;, [&#x27;my&#x27;, &#x27;foo&#x27;]); Answer:判斷 arg1 string 內, 是否含有 arg2 array 內的任何一個 string// true 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$containsAll = Str::containsAll(&#x27;This is my name&#x27;, [&#x27;my&#x27;, &#x27;name&#x27;]); Answer:判斷 arg1 string 中, 是否包含 arg2 array 中的所有 string// true 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::endsWith(&#x27;This is my name&#x27;, &#x27;name&#x27;); Answer:判斷 arg1 string 是否以 arg2 string 結尾// true 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::endsWith(&#x27;This is my name&#x27;, [&#x27;name&#x27;, &#x27;foo&#x27;]);$result = Str::endsWith(&#x27;This is my name&#x27;, [&#x27;this&#x27;, &#x27;foo&#x27;]); Answer:判斷 arg1 string 是否以 arg2 array 中的任何一個 string 結尾// true// false 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$adjusted = Str::finish(&#x27;this/string&#x27;, &#x27;/&#x27;);$adjusted = Str::finish(&#x27;this/string/&#x27;, &#x27;/&#x27;); Answer:如果 arg1 string 並非以 arg2 string 結尾, 則加上// this/string/// this/string/ 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$matches = Str::is(&#x27;foo*&#x27;, &#x27;foobar&#x27;);$matches = Str::is(&#x27;baz*&#x27;, &#x27;foobar&#x27;); Answer:判斷 arg2 是否符合 arg1 pattern// true// false 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$isAscii = Str::isAscii(&#x27;Taylor&#x27;);$isAscii = Str::isAscii(&#x27;ü&#x27;); Answer:判斷 string 是否為 7 bit ASCII// true// false 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$isUuid = Str::isUuid(&#x27;a0a2a2d2-0b87-4a18-83f2-2529882be2de&#x27;);$isUuid = Str::isUuid(&#x27;laravel&#x27;); Answer:判斷 string 是否為 valid uuid// true// false 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::kebab(&#x27;fooBar&#x27;); Answer:判斷 string 是否為 kebab case// foo-bar 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$length = Str::length(&#x27;Laravel&#x27;); Answer:取得 string length// 7 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$truncated = Str::limit(&#x27;The quick brown fox jumps over the lazy dog&#x27;, 20); Answer:將 arg1 string 從頭開始只取 arg2 給的字串數, 其餘截掉// The quick brown fox… 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$truncated = Str::limit(&#x27;The quick brown fox jumps over the lazy dog&#x27;, 20, &#x27; (...)&#x27;); Answer:將 arg1 string 從頭開始只取 arg2 給的字串數, 其餘截掉, 可帶入 arg3 取代被截掉的部分// The quick brown fox (…) 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::lower(&#x27;LARAVEL&#x27;); Answer:取得 string 的 lower case// laravel 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$html = Str::markdown(&#x27;# Laravel&#x27;);// &lt;h1&gt;Laravel&lt;/h1&gt;$html = Str::markdown(&#x27;# Taylor &lt;b&gt;Otwell&lt;/b&gt;&#x27;, [ &#x27;html_input&#x27; =&gt; &#x27;strip&#x27;,]);// &lt;h1&gt;Taylor Otwell&lt;/h1&gt; Answer:將 markdown 格式轉為 HTML 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;return (string) Str::orderedUuid(); Answer:產生 timestamp first UUID, 凡是使用此 method 的 uuid, 會依照順序產生 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$padded = Str::padBoth(&#x27;James&#x27;, 10, &#x27;_&#x27;);$padded = Str::padBoth(&#x27;James&#x27;, 10); Answer:使用 PHP function str_pad, 會依序在左右開始加上 arg3 string, 直到 string 長度達到 arg2 指定的長度// &#39;__James___&#39;// &#39; James &#39; 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$padded = Str::padLeft(&#x27;James&#x27;, 10, &#x27;-=&#x27;);// &#x27;-=-=-James&#x27;$padded = Str::padLeft(&#x27;James&#x27;, 10);// &#x27; James&#x27; Answer:會使用 PHP function str_pad, 從 arg1 string 的左側開始 pad arg3 的 string, 直到長度達到 arg2 指定的長度 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$padded = Str::padRight(&#x27;James&#x27;, 10, &#x27;-&#x27;);$padded = Str::padRight(&#x27;James&#x27;, 10); Answer:會使用 PHP function str_pad, 從 arg1 string 的右側開始 pad arg3 的 string, 直到長度達到 arg2 指定的長度// &#39;James-----&#39;// &#39;James &#39; 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::plural(&#x27;car&#x27;);$plural = Str::plural(&#x27;child&#x27;); Answer:將 string 轉為其複數// cars// children 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::plural(&#x27;child&#x27;, 2);$singular = Str::plural(&#x27;child&#x27;, 1); Answer:根據 arg2 的 integer, 將 string 轉為其單數或複數// children// child 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::pluralStudly(&#x27;VerifiedHuman&#x27;);$plural = Str::pluralStudly(&#x27;UserFeedback&#x27;); Answer:將 Studly caps case string 轉為單字複數// VerifiedHumans// UserFeedback 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::pluralStudly(&#x27;VerifiedHuman&#x27;, 2);// VerifiedHumans$singular = Str::pluralStudly(&#x27;VerifiedHuman&#x27;, 1);// VerifiedHuman Answer:依據 arg2 的 integer 將 Studly caps case string 轉為單字單數或複數 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$random = Str::random(40); Answer:產生一段指定長度的 random string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = &#x27;The event will take place between ? and ?&#x27;;$replaced = Str::replaceArray(&#x27;?&#x27;, [&#x27;8:30&#x27;, &#x27;9:00&#x27;], $string); Answer:從 arg3 string 中, 尋找 arg1 的字串, 並將之以 arg2 array 中的字串依序取代// The event will take place between 8:30 and 9:00 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$replaced = Str::replaceFirst(&#x27;the&#x27;, &#x27;a&#x27;, &#x27;the quick brown fox jumps over the lazy dog&#x27;);// a quick brown fox jumps over the lazy dog Answer:從 arg3 string 中尋找 arg1 字串, 並以 arg2 字串取代之 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$replaced = Str::replaceLast(&#x27;the&#x27;, &#x27;a&#x27;, &#x27;the quick brown fox jumps over the lazy dog&#x27;); Answer:在 arg3 string 中, 尋找 arg1 string 最後出現的位置, 並以 arg2 string 取代之// the quick brown fox jumps over a lazy dog 以下的 Laravel example code 的意思是？ Example:&lt;?use Illuminate\\Support\\Str;$singular = Str::singular(&#x27;cars&#x27;);$singular = Str::singular(&#x27;children&#x27;); Answer:取得單字的單數型態// car// childphp 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slug = Str::slug(&#x27;Laravel 5 Framework&#x27;, &#x27;-&#x27;); Answer:使用 arg2 的 string, 為 arg1 產生一個 URL friendly slug// laravel-5-framework 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::snake(&#x27;fooBar&#x27;); Answer:將 string 轉為 snake case// foo_bar 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$adjusted = Str::start(&#x27;this/string&#x27;, &#x27;/&#x27;);$adjusted = Str::start(&#x27;/this/string&#x27;, &#x27;/&#x27;); Answer:如果 arg1 string 不是由 arg2 開頭的話, 就加上去// /this/string// /this/string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::startsWith(&#x27;This is my name&#x27;, &#x27;This&#x27;); Answer:判斷 arg1 string 是否 start with arg1 string// true 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::studly(&#x27;foo_bar&#x27;); Answer:將 string 轉為 StudlyCase// FooBar 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::substr(&#x27;The Laravel Framework&#x27;, 4, 7); Answer:從 arg1 string 中, 從 arg2 index 位置開始往後取, 取 arg3 指定的 length// Laravel 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$count = Str::substrCount(&#x27;If you like ice cream, you will like snow cones.&#x27;, &#x27;like&#x27;); Answer:取得在 arg1 string 中共出現了 arg2 string 幾次// 2 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::title(&#x27;a nice title uses the correct case&#x27;); Answer:將 string 轉為 Title Case// A Nice Title Uses The Correct Case 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::ucfirst(&#x27;foo bar&#x27;); Answer:將 string 第一個字母轉為大寫// Foo bar 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::upper(&#x27;laravel&#x27;); Answer:將整個 string 中的每個字母都轉為大寫// LARAVEL 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;return (string) Str::uuid(); Answer:產生 version 4 UUID 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;return Str::words(&#x27;Perfectly balanced, as all things should be.&#x27;, 3, &#x27; &gt;&gt;&gt;&#x27;); Answer:將 arg1 string, 使用 arg3 的數字來限制單字數量, arg3 代表之後刪減掉的部分要顯示什麼// Perfectly balanced, as &gt;&gt;&gt; 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho trans(&#x27;messages.welcome&#x27;); Answer:使用 localization file 來翻譯指定的 translation key, 如果指定的 translation key 不存在, 將 return 帶入的 key, 如果 message.welcome 這個 translation key 不存在, 將回傳 messages.welcome 以下的 Laravel example code 的意思是？ Example:&lt;?phpecho trans_choice(&#x27;messages.notifications&#x27;, $unreadCount); Answer:使用 localization file 來翻譯指定的 translation key, 如果指定的 translation key 不存在, 將會 return 帶入的 key, 如果 message.welcome 這個 translation key 不存在, 將回傳 messages.welcomearg2 為用來替換 translation value 的值, 比方說 The unread number is :unreadCount # Fluent Strings以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::of(&#x27;This is my name&#x27;)-&gt;after(&#x27;This is&#x27;); Answer:// ‘ my name’Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化在 of() 中的 string 中尋找帶入 after() 中的 string, 並取其後面的 string, 如果 after() 中的 string 不存在, 會 return of() 中的所有 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::of(&#x27;App\\Http\\Controllers\\Controller&#x27;)-&gt;afterLast(&#x27;\\\\&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘Controller’return \\\\ 在 of() string 中最後出現的位置其後方的 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;Taylor&#x27;)-&gt;append(&#x27; Otwell&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘Taylor Otwell’將 append() string append 到 of() string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;ü&#x27;)-&gt;ascii(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘u’將 of() string 轉音譯為 ASCII value 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;/foo/bar/baz&#x27;)-&gt;basename(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘baz’取得 of string 的 basename 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;/foo/bar/baz.jpg&#x27;)-&gt;basename(&#x27;.jpg&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘baz’取得 of string 的 basename, 會從 result 中移除 basename() string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::of(&#x27;This is my name&#x27;)-&gt;before(&#x27;my name&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘This is ‘從 of() string 中, 尋找 before() string, 並取其前面的 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slice = Str::of(&#x27;This is my name&#x27;)-&gt;beforeLast(&#x27;is&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘This ‘從 of() string 中尋找 before() string 最後一次出現的地方, 並取其前面的 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::of(&#x27;foo_bar&#x27;)-&gt;camel(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// fooBar將 of() string 轉為 camel case 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$contains = Str::of(&#x27;This is my name&#x27;)-&gt;contains(&#x27;my&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true判斷 of() string 中是否含有 contains() string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$contains = Str::of(&#x27;This is my name&#x27;)-&gt;contains([&#x27;my&#x27;, &#x27;foo&#x27;]); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true判斷 of() string 中是否含有 contains() string, 只要中一個就算 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$containsAll = Str::of(&#x27;This is my name&#x27;)-&gt;containsAll([&#x27;my&#x27;, &#x27;name&#x27;]); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true判斷 of() string 中是否含有 contains() string, 全中才算 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;/foo/bar/baz&#x27;)-&gt;dirname(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘/foo/bar’取 of() string 的 dirname 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;/foo/bar/baz&#x27;)-&gt;dirname(2); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘/foo’取 of() string 的 dirname, 可帶入 dirname() 你希望 trim 的 dir level 數量 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;This is my name&#x27;)-&gt;endsWith(&#x27;name&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true判斷 of() string 是否以 endsWith() string 結尾 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;This is my name&#x27;)-&gt;endsWith([&#x27;name&#x27;, &#x27;foo&#x27;]);$result = Str::of(&#x27;This is my name&#x27;)-&gt;endsWith([&#x27;this&#x27;, &#x27;foo&#x27;]); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true// false判斷 of() string 是否以 endsWith() string 結尾, 中一個就算 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;Laravel&#x27;)-&gt;exactly(&#x27;Laravel&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true判斷 of() string 是否跟 exactly() string 完全相同 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$collection = Str::of(&#x27;foo bar baz&#x27;)-&gt;explode(&#x27; &#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// collect([&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;])將 of() string 以 explode() string 為 delimiter, 拆成一個 array 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$adjusted = Str::of(&#x27;this/string&#x27;)-&gt;finish(&#x27;/&#x27;);$adjusted = Str::of(&#x27;this/string/&#x27;)-&gt;finish(&#x27;/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// this/string/// this/string/如果 of() string 不是以 finish() string 結尾, 則加上 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$matches = Str::of(&#x27;foobar&#x27;)-&gt;is(&#x27;foo*&#x27;);$matches = Str::of(&#x27;foobar&#x27;)-&gt;is(&#x27;baz*&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true// false判斷 of() string 是否符合 is() pattern 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;Taylor&#x27;)-&gt;isAscii();$result = Str::of(&#x27;ü&#x27;)-&gt;isAscii(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true// false判斷 of() string 是否為 ASCII value 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27; &#x27;)-&gt;trim()-&gt;isEmpty();$result = Str::of(&#x27;Laravel&#x27;)-&gt;trim()-&gt;isEmpty(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true// false判斷 of() string 是否 empty() 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27; &#x27;)-&gt;trim()-&gt;isNotEmpty();$result = Str::of(&#x27;Laravel&#x27;)-&gt;trim()-&gt;isNotEmpty(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// false// true判斷 of() string 是否 isNotempty() 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::of(&#x27;fooBar&#x27;)-&gt;kebab(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// foo-bar將 of() string 轉為 kebab case 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$length = Str::of(&#x27;Laravel&#x27;)-&gt;length(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// 7取得 of() string 的 length 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$truncated = Str::of(&#x27;The quick brown fox jumps over the lazy dog&#x27;)-&gt;limit(20); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// The quick brown fox…限制 of() string 的 length, 超過則截斷 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$truncated = Str::of(&#x27;The quick brown fox jumps over the lazy dog&#x27;)-&gt;limit(20, &#x27; (...)&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// The quick brown fox (…)限制 of() string 的 length, 超過則截斷, 並顯示 limit() arg2 的 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;LARAVEL&#x27;)-&gt;lower(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘laravel’將 of() string 轉為 lower case 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27; Laravel &#x27;)-&gt;ltrim();$string = Str::of(&#x27;/Laravel/&#x27;)-&gt;ltrim(&#x27;/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// &#39;Laravel &#39;// &#39;Laravel/&#39;trim of() string 的 left side 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$html = Str::of(&#x27;# Laravel&#x27;)-&gt;markdown();$html = Str::of(&#x27;# Taylor &lt;b&gt;Otwell&lt;/b&gt;&#x27;)-&gt;markdown([ &#x27;html_input&#x27; =&gt; &#x27;strip&#x27;,]); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// &lt;h1&gt;Laravel&lt;/h1&gt;// &lt;h1&gt;Taylor Otwell&lt;/h1&gt;將 of() string 中如果有 markdown 語法, 轉為 HTML 效果 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;foo bar&#x27;)-&gt;match(&#x27;/bar/&#x27;);$result = Str::of(&#x27;foo bar&#x27;)-&gt;match(&#x27;/foo (.*)/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘bar’// ‘bar’回傳 of() string 中, 符合 match() 中 regex pattern 的部分, 如果沒有符合, 則回傳 empty collection 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;bar foo bar&#x27;)-&gt;matchAll(&#x27;/bar/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// collect([&#39;bar&#39;, &#39;bar&#39;])回傳一個 collection, 含有 of() string 中, 符合 matchAll() 中 regex pattern 的全部 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;bar fun bar fly&#x27;)-&gt;matchAll(&#x27;/f(\\w*)/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// collect([&#39;un&#39;, &#39;ly&#39;]);回傳一個 collection, 含有 of() string 中, 符合 matchAll() 中 regex pattern 的全部 string, 如果 pattern 含有 group, 會回傳符合該 group 的 string, 如果沒有符合, 則回傳 empty collection 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$padded = Str::of(&#x27;James&#x27;)-&gt;padBoth(10, &#x27;_&#x27;);$padded = Str::of(&#x27;James&#x27;)-&gt;padBoth(10); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// &#39;__James___&#39;// &#39; James &#39;使用 padBoth(), 平均 pad of() string 的左右兩邊, 直到滿足 padBoth() arg1 length, 若有指定 arg2, 則使用該 string 補滿, 若無則使用空白 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$padded = Str::of(&#x27;James&#x27;)-&gt;padLeft(10, &#x27;-=&#x27;);$padded = Str::of(&#x27;James&#x27;)-&gt;padLeft(10); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// &#39;-=-=-James&#39;// &#39; James&#39;使用 padLeft(), 補滿 pad of() string 的左邊, 直到滿足 padLeft() arg1 length, 若有指定 arg2, 則使用該 string 補滿, 若無則使用空白 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$padded = Str::of(&#x27;James&#x27;)-&gt;padRight(10, &#x27;-&#x27;);$padded = Str::of(&#x27;James&#x27;)-&gt;padRight(10); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// &#39;James-----&#39;// &#39;James &#39;使用 padRight(), 補滿 pad of() string 的右邊, 直到滿足 padRight() arg1 length, 若有指定 arg2, 則使用該 string 補滿, 若無則使用空白 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$hash = Str::of(&#x27;Laravel&#x27;)-&gt;pipe(&#x27;md5&#x27;)-&gt;prepend(&#x27;Checksum: &#x27;);$closure = Str::of(&#x27;foo&#x27;)-&gt;pipe(function ($str) &#123; return &#x27;bar&#x27;;&#125;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘Checksum: a5c95b86291ea299fcbe64458ed12702’// ‘bar’可以 transform of() string, 藉由將 string 帶入 closure 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::of(&#x27;car&#x27;)-&gt;plural();$plural = Str::of(&#x27;child&#x27;)-&gt;plural(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// cars// children將 of() string 轉為複數 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::of(&#x27;child&#x27;)-&gt;plural(2);// children$plural = Str::of(&#x27;child&#x27;)-&gt;plural(1);// child Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化將 of() string 轉為單數或複數, 藉由帶入 plural() 數字 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;Framework&#x27;)-&gt;prepend(&#x27;Laravel &#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// Laravel Framework將 prepend() string 置於 of() string 之前 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$replaced = Str::of(&#x27;Laravel 6.x&#x27;)-&gt;replace(&#x27;6.x&#x27;, &#x27;7.x&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// Laravel 7.x將 of() string 中的 repace() arg1 string, replace 為 replace() arg2 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = &#x27;The event will take place between ? and ?&#x27;;$replaced = Str::of($string)-&gt;replaceArray(&#x27;?&#x27;, [&#x27;8:30&#x27;, &#x27;9:00&#x27;]); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// The event will take place between 8:30 and 9:00在 of() string 中尋找 replaceArray() arg1 的 string, 將將之依序替換為 arg2 array 中的 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$replaced = Str::of(&#x27;the quick brown fox jumps over the lazy dog&#x27;)-&gt;replaceFirst(&#x27;the&#x27;, &#x27;a&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// a quick brown fox jumps over the lazy dog從 of() string 中尋找 replaceFirst() arg1 string, 將找到的第一個替換為 replaceFirst() arg2 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$replaced = Str::of(&#x27;the quick brown fox jumps over the lazy dog&#x27;)-&gt;replaceLast(&#x27;the&#x27;, &#x27;a&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// the quick brown fox jumps over a lazy dog從 of() string 中尋找 replaceLast arg1 string, 將找到的最後一個替換成 replaceLast() arg2 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$replaced = Str::of(&#x27;(+1) 501-555-1000&#x27;)-&gt;replaceMatches(&#x27;/[^A-Za-z0-9]++/&#x27;, &#x27;&#x27;) Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘15015551000’將 of() string 中, 符合 replaceMatches() arg1 pattern 的部分替換成 replaceMatches() arg2 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;This is my name&#x27;)-&gt;endsWith(&#x27;name&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true判斷 of() string 否則以 endWith() string 結尾 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;This is my name&#x27;)-&gt;endsWith([&#x27;name&#x27;, &#x27;foo&#x27;]);$result = Str::of(&#x27;This is my name&#x27;)-&gt;endsWith([&#x27;this&#x27;, &#x27;foo&#x27;]); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true// false判斷 of() string 否則以 endWith() string 結尾, 一個中就算 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::of(&#x27;car&#x27;)-&gt;plural();$plural = Str::of(&#x27;child&#x27;)-&gt;plural(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// cars// children取得 of() string 的複數 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$plural = Str::of(&#x27;child&#x27;)-&gt;plural(2);$plural = Str::of(&#x27;child&#x27;)-&gt;plural(1); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// children// child可帶入 plural() 數字, 決定要 return of() string 的單複數 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27; Laravel &#x27;)-&gt;rtrim();$string = Str::of(&#x27;/Laravel/&#x27;)-&gt;rtrim(&#x27;/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘ Laravel’// ‘/Laravel’trim of() string 的右邊, 可帶入想要 trim 的字串 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$singular = Str::of(&#x27;cars&#x27;)-&gt;singular();$singular = Str::of(&#x27;children&#x27;)-&gt;singular(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// car// child將 of() string 轉為單數 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$slug = Str::of(&#x27;Laravel Framework&#x27;)-&gt;slug(&#x27;-&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// laravel-framework從 of() string 產生 URL friendly slug 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::of(&#x27;fooBar&#x27;)-&gt;snake(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// foo_barreturn of() string 的 snake case 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$segments = Str::of(&#x27;one, two, three&#x27;)-&gt;split(&#x27;/[\\s,]+/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// collect([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])使用 split() pattern 來 split of() string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$adjusted = Str::of(&#x27;this/string&#x27;)-&gt;start(&#x27;/&#x27;);$adjusted = Str::of(&#x27;/this/string&#x27;)-&gt;start(&#x27;/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// /this/string// /this/string如果 of() string 不是以 start() string 開頭, 則加上 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$result = Str::of(&#x27;This is my name&#x27;)-&gt;startsWith(&#x27;This&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// true判斷 of() string 是否為 startsWith() string 開頭 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::of(&#x27;foo_bar&#x27;)-&gt;studly(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// FooBar將 of() string 轉為 studly case 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;Laravel Framework&#x27;)-&gt;substr(8);$string = Str::of(&#x27;Laravel Framework&#x27;)-&gt;substr(8, 5); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// Framework// Frame從 of() string 中, 根據 substr() 中指定的起始點與 length, return 該 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;Laravel&#x27;) -&gt;append(&#x27; Framework&#x27;) -&gt;tap(function ($string) &#123; dump(&#x27;String after append: &#x27; . $string); &#125;) -&gt;upper(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// LARAVEL FRAMEWORK可以對 of() string 做一些邏輯處理, 但不更動到 of() string, tap() 會 return 原本的 of() string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$converted = Str::of(&#x27;a nice title uses the correct case&#x27;)-&gt;title(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// A Nice Title Uses The Correct Case將 of() string 中的每一個 word 第一個字轉大寫 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27; Laravel &#x27;)-&gt;trim();$string = Str::of(&#x27;/Laravel/&#x27;)-&gt;trim(&#x27;/&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘Laravel’// ‘Laravel’從 of() string 中, trim 指定的 string 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;foo bar&#x27;)-&gt;ucfirst(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// Foo bar將 of() string 第一個 word 第一個字轉大寫 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$adjusted = Str::of(&#x27;laravel&#x27;)-&gt;upper(); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// LARAVEL將 of() string 轉大寫 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;Taylor&#x27;) -&gt;when(true, function ($string) &#123; return $string-&gt;append(&#x27; Otwell&#x27;); &#125;);// &#x27;Taylor Otwell&#x27; Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化當 when() arg1 為 true 時, 執行 arg2 closure, closure 可帶入 of() string, 也可定義 arg3, 當 arg1 為 false 時要執行的 closure 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27; &#x27;)-&gt;whenEmpty(function ($string) &#123; return $string-&gt;trim()-&gt;prepend(&#x27;Laravel&#x27;);&#125;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// ‘Laravel’如果 of() string 為 empty, 則 invoke whenEmpty() closure 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;$string = Str::of(&#x27;Perfectly balanced, as all things should be.&#x27;)-&gt;words(3, &#x27; &gt;&gt;&gt;&#x27;); Answer:Fluent string 語法, 可以 chain 多個 string operations, 使其更加物件導向以及語意化// Perfectly balanced, as &gt;&gt;&gt;從 of() string 中取 3 個 words, 剩下的截掉, 並顯示 &gt;&gt;&gt; # URLs以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Http\\Controllers\\HomeController;$url = action([UserController::class, &#x27;profile&#x27;], [&#x27;id&#x27; =&gt; 1]); Answer:產生該指定 controller 的 url, 但前提是該 controller 已有對應的 route, action() arg2 可帶入 route url parameter 以下的 Laravel example code 的意思是？ Example:&lt;?php// ASSET_URL=http://example.com/assets$url = asset(&#x27;img/photo.jpg&#x27;); // http://example.com/assets/img/photo.jpg Answer:產生一個對應指定資源的 url, domain 會隨著 .env 的 ASSET_URL 而改變, 如果有使用 S3 或 CDN, 可在此設定 以下的 Laravel example code 的意思是？ Example:&lt;?php$url = route(&#x27;route.name&#x27;, [&#x27;id&#x27; =&gt; 1], false); Answer:route() 可產生一個指定 named route 的 url, arg2 可帶入該 route 會用到的 url parameter預設產生 absolute url, 若要產生 relative, 可在 arg3 帶入 false 以下的 Laravel example code 的意思是？ Example:&lt;?php$url = secure_asset(&#x27;img/photo.jpg&#x27;); Answer:產生一個對應指定資源的 https url, domain 會隨著 .env 的 ASSET_URL 而改變, 如果有使用 S3 或 CDN, 可在此設定 以下的 Laravel example code 的意思是？ Example:&lt;?php$url = secure_url(&#x27;user/profile&#x27;);$url = secure_url(&#x27;user/profile&#x27;, [1]); Answer:產生一個導向 named route 的 HTTPS url, 可在 arg2 帶入 url parameter 以下的 Laravel example code 的意思是？ Example:&lt;?php$url = url(&#x27;user/profile&#x27;);$url = url(&#x27;user/profile&#x27;, [1]); Answer:產生一個導向 named route 的 HTTP url, 可在 arg2 帶入 url parameter 以下的 Laravel example code 的意思是？ Example:&lt;?php$current = url()-&gt;current();$full = url()-&gt;full();$previous = url()-&gt;previous(); Answer:如果 url() 沒有帶入 parameter, 那就會回傳一個 UrlGenerator instance, 可使用相關的 method # Miscellaneous以下的 Laravel example code 的意思是？ Example:&lt;?phpabort(403); Answer:直接 throw 一個 HTTP exception, 會由 exception handler 渲染輸出 以下的 Laravel example code 的意思是？ Example:&lt;?phpabort(403, &#x27;Unauthorized.&#x27;, $headers); Answer:throw 一個 HTTP exception, 且定義 message 以及其 header 以下的 Laravel example code 的意思是？ Example:&lt;?phpabort_if(! Auth::user()-&gt;isAdmin(), 403); Answer:如果 arg1 為 true, 則 throw 一個 HTTP exception 以下的 Laravel example code 的意思是？ Example:&lt;?phpabort_unless(Auth::user()-&gt;isAdmin(), 403); Answer:如果 arg1 不為 true, 則 throw 一個 HTTP exception 以下的 Laravel example code 的意思是？ Example:&lt;?php$container = app(); Answer:return 一個 service container instance 以下的 Laravel example code 的意思是？ Example:&lt;?php$api = app(&#x27;HelpSpot\\API&#x27;); Answer:可 pass class 或 instance name, 可從 container 中 resolve 該 class 或 instance 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = auth()-&gt;user(); Answer:auth() return 一個 authenticator instance, 也可使用 Auth facade 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = auth(&#x27;admin&#x27;)-&gt;user(); Answer:auth() return 一個 authenticator instance, 也可使用 Auth facade, 也可指定要使用哪一個 guard 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn back($status = 302, $headers = [], $fallback = &#x27;/&#x27;);return back(); Answer:產生一個 redirect HTTP response, 回到上一個 location 以下的 Laravel example code 的意思是？ Example:&lt;?php$password = bcrypt(&#x27;my-secret-password&#x27;); Answer:使用 Bcrypt hash value, 相當於 Hash::make() 以下的 Laravel example code 的意思是？ Example:&lt;?phpblank(&#x27;&#x27;);blank(&#x27; &#x27;);blank(null);blank(collect());blank(0);blank(true);blank(false); Answer:// true// false判斷 given value 是否為 blank, 相反的 method 為 filled() 以下的 Laravel example code 的意思是？ Example:&lt;?phpbroadcast(new UserRegistered($user));broadcast(new UserRegistered($user))-&gt;toOthers(); Answer:將指定 event 廣播給其 listeners 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = cache(&#x27;key&#x27;);$value = cache(&#x27;key&#x27;, &#x27;default&#x27;); Answer:從 default cache 取得 given key 的 value, 若 given key 不存在, 則取 default 以下的 Laravel example code 的意思是？ Example:&lt;?phpcache([&#x27;key&#x27; =&gt; &#x27;value&#x27;], 300);cache([&#x27;key&#x27; =&gt; &#x27;value&#x27;], now()-&gt;addSeconds(10)); Answer:當 pass array 到 cache() 時, 為存值到 cache 中, 可在 arg2 定義有效期限 以下的 Laravel example code 的意思是？ Example:&lt;?php$traits = class_uses_recursive(App\\Models\\User::class); Answer:回傳所有被該 class 以及其 parent class 使用的 traits 以下的 Laravel example code 的意思是？ Example:&lt;?php$collection = collect([&#x27;taylor&#x27;, &#x27;abigail&#x27;]); Answer:將 given value 轉為 collection 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = config(&#x27;app.timezone&#x27;);$value = config(&#x27;app.timezone&#x27;, $default); Answer:取得 config dir 中, 指定的檔案中的 key value, 若無則取得 default 以下的 Laravel example code 的意思是？ Example:&lt;?phpconfig([&#x27;app.debug&#x27; =&gt; true]); Answer:在 run time 改變 config 的值, 只在該次 request 中有效 以下的 Laravel example code 的意思是？ Example:&lt;?php$cookie = cookie(&#x27;name&#x27;, &#x27;value&#x27;, $minutes); Answer:建立指定 cookie with key &amp; value, 以及有效期限 以下的 Laravel example code 的意思是？ Example:&lt;?php&#123;&#123; csrf_field() &#125;&#125; Answer:在 form 中產生 csrf token, 以避免 csrf attack 以下的 Laravel example code 的意思是？ Example:&lt;?php$token = csrf_token(); Answer:取得當次 request 的 CSRF token 以下的 Laravel example code 的意思是？ Example:&lt;?phpdd($value);dd($value1, $value2, $value3, ...); Answer:dump and die 以下的 Laravel example code 的意思是？ Example:&lt;?phpdispatch(new App\\Jobs\\SendEmails); Answer:dispatch 一個 job, 如果該 job implement ShouldQueue, 則走 queue 以下的 Laravel example code 的意思是？ Example:&lt;?php$result = dispatch_now(new App\\Jobs\\SendEmails); Answer:立即 dispatch 一個 job, 不走 queue 以下的 Laravel example code 的意思是？ Example:&lt;?phpdump($value);dump($value1, $value2, $value3, ...); Answer:dump given variable 以下的 Laravel example code 的意思是？ Example:&lt;?php$env = env(&#x27;APP_ENV&#x27;);$env = env(&#x27;APP_ENV&#x27;, &#x27;production&#x27;); Answer:取得 .env 值, 當 config:cache 時, 此 function 失效 以下的 Laravel example code 的意思是？ Example:&lt;?phpevent(new UserRegistered($user)); Answer:dispatch 指定的 event 以下的 Laravel example code 的意思是？ Example:&lt;?phpfilled(0);filled(true);filled(false);// truefilled(&#x27;&#x27;);filled(&#x27; &#x27;);filled(null);filled(collect());// false Answer:判斷 given value 是否 filled, 相反的 function 為 blank() 以下的 Laravel example code 的意思是？ Example:&lt;?phpinfo(&#x27;User login attempt failed.&#x27;, [&#x27;id&#x27; =&gt; $user-&gt;id]); Answer:會將 given value 寫到 log, 也可帶入 array 以下的 Laravel example code 的意思是？ Example:&lt;?phplogger(&#x27;User login attempt failed.&#x27;, [&#x27;id&#x27; =&gt; $user-&gt;id]); Answer:將 given value 寫到 debug level log 以下的 Laravel example code 的意思是？ Example:&lt;?phplogger()-&gt;error(&#x27;You are not allowed here.&#x27;); Answer:當 logger() 沒有 given value 時, 將回傳 logger instance 以下的 Laravel example code 的意思是？ Example:&lt;?php&lt;form method=&quot;POST&quot;&gt; &#123;&#123; method_field(&#x27;DELETE&#x27;) &#125;&#125;&lt;/form&gt; Answer:method_field 產生一個 HTML hidden input field, 包含著 HTTP verb, 用在 HTTP FORM 不支援的 HTTP method 以下的 Laravel example code 的意思是？ Example:&lt;?php$now = now(); Answer:now() 建立一個 Illuminate\\Support\\Carbon 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = old(&#x27;value&#x27;);$value = old(&#x27;value&#x27;, &#x27;default&#x27;); Answer:取得 session old value 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn optional($user-&gt;address)-&gt;street;&#123;!! old(&#x27;name&#x27;, optional($user)-&gt;name) !!&#125; Answer:optional 接受任何形式的 argument, 如果 given object 為 null, 當呼叫該 object 的 method 或 property 時會 return null, 則不會 throw error如果 $user 本身就有可能是 null 或非 object, 那就要把 $user 也放到另外一個 optional 才行 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn optional(User::find($id), function ($user) &#123; return $user-&gt;name;&#125;); Answer:optional() 可帶入 second args closure, 當 arg1 非為 null 時, 會觸發 arg2 closure 以下的 Laravel example code 的意思是？ Example:&lt;?php$policy = policy(App\\Models\\User::class); Answer:取得 policy instance 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn redirect($to = null, $status = 302, $headers = [], $https = null);return redirect(&#x27;/home&#x27;);return redirect()-&gt;route(&#x27;route.name&#x27;); Answer:當有 pass args 時, return redirect HTTP response, 否則 return redirector instance 以下的 Laravel example code 的意思是？ Example:&lt;?phpreport($e); Answer:使用 default exception handler report exception 以下的 Laravel example code 的意思是？ Example:&lt;?phpreport(&#x27;Something went wrong.&#x27;); Answer:當 pass string 時, 會建立一個 exception, with the given string 以下的 Laravel example code 的意思是？ Example:&lt;?php$request = request();$value = request(&#x27;key&#x27;, $default); Answer:回傳 current Request instance 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn rescue(function () &#123; return $this-&gt;method();&#125;); Answer:會執行一個 closure, 如果有 error, 會 report error 並繼續往下執行 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn rescue(function () &#123; return $this-&gt;method();&#125;, false);return rescue(function () &#123; return $this-&gt;method();&#125;, function () &#123; return $this-&gt;failure();&#125;); Answer:也可帶入 rescue() second args, 當 arg1 closure throw error 時, return second args 以下的 Laravel example code 的意思是？ Example:&lt;?php$api = resolve(&#x27;HelpSpot\\API&#x27;); Answer:使用 service container resolve given class 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn response(&#x27;Hello World&#x27;, 200, $headers);return response()-&gt;json([&#x27;foo&#x27; =&gt; &#x27;bar&#x27;], 200, $headers); Answer:如果有 pass args, 則產生一個 response instance, 否則則取得 response factory instance 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn retry(5, function () &#123; // Attempt 5 times while resting 100ms in between attempts...&#125;, 100); Answer:嘗試執行 given closure, 如果 throw error, 則重試, 直到達到 arg1 的次數, 若沒有 error, 則 return value, 有且達到次數上限則 throw error 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = session(&#x27;key&#x27;); Answer:取得 session value 以下的 Laravel example code 的意思是？ Example:&lt;?phpsession([&#x27;chairs&#x27; =&gt; 7, &#x27;instruments&#x27; =&gt; 3]); Answer:set session key / value 以下的 Laravel example code 的意思是？ Example:&lt;?php$value = session()-&gt;get(&#x27;key&#x27;);session()-&gt;put(&#x27;key&#x27;, $value); Answer:如果沒有 pass args, session() 回傳 session store instance 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = tap($user)-&gt;update([ &#x27;name&#x27; =&gt; $name, &#x27;email&#x27; =&gt; $email,]); Answer:tap() 如果不指定 arg2 as closure, 可以接著呼叫 passed value 的任何 method, 並最後 return value 自身上面的例子中, 正常 Eloquent update 會 return int, 但使用 tap 會可以強制 return 一個更新過的 $user model 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = tap(User::first(), function ($user) &#123; $user-&gt;name = &#x27;taylor&#x27;; $user-&gt;save();&#125;); Answer:tap() 可 pass two args, 並將 arg1 pass 進 arg2 closure, closure 內就算不 return 也沒有影響, tap() 本身會回傳 $user, 即更新後的 $user 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $user-&gt;tap(function ($user) &#123; //&#125;); Answer:可在 model user Tappable trait, 然後就可使用 tap method 以下的 Laravel example code 的意思是？ Example:&lt;?phpthrow_if(! Auth::user()-&gt;isAdmin(), AuthorizationException::class);throw_if( ! Auth::user()-&gt;isAdmin(), AuthorizationException::class, &#x27;You are not allowed to access this page.&#x27;); Answer:如果 arg1 為 true, 則 throw arg2 exception 以下的 Laravel example code 的意思是？ Example:&lt;?phpthrow_unless(Auth::user()-&gt;isAdmin(), AuthorizationException::class);throw_unless( Auth::user()-&gt;isAdmin(), AuthorizationException::class, &#x27;You are not allowed to access this page.&#x27;); Answer:如果 arg2 非為 true, 一律 throw arg2 exception 以下的 Laravel example code 的意思是？ Example:&lt;?php$today = today(); Answer:取得 Illuminate\\Support\\Carbon instance for current date 以下的 Laravel example code 的意思是？ Example:&lt;?php$traits = trait_uses_recursive(\\Illuminate\\Notifications\\Notifiable::class); Answer:取得一個 trait 使用的所有 trait 以下的 Laravel example code 的意思是？ Example:&lt;?php$callback = function ($value) &#123; return $value * 2;&#125;;$result = transform(5, $callback); Answer:// 10會將 pass 進去的 arg1 value 帶入 arg2 closure 執行, 如果 arg2 closure return 值非為 blank, 則回傳該值與 tap 的差異, tap 回傳 pass 進的值, transform 回傳 closure return 值 以下的 Laravel example code 的意思是？ Example:&lt;?php$result = transform(null, $callback, &#x27;The value is blank&#x27;); Answer:// The value is blank可 pass arg3 為 default 值, 當 arg2 closure 為 null, return arg3與 with() 類似, 但 transform() 可 pass arg3 as default value與 tap() 類似, 但 transform() return arg2 closure return value, tap() 回傳 pass 進的 arg1 value 以下的 Laravel example code 的意思是？ Example:&lt;?php$validator = validator($data, $rules, $messages); Answer:validator function 建立一個 new validator instance, 與 Validator facade 效果相同 以下的 Laravel example code 的意思是？ Example:&lt;?php$result = value(true);$result = value(function () &#123; return false;&#125;); Answer:// true// falsereturn given value, 如果給 closure, 會回傳 closure return value 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn view(&#x27;auth.login&#x27;); Answer:取得一個 new view instance 以下的 Laravel example code 的意思是？ Example:&lt;?php$callback = function ($value) &#123; return (is_numeric($value)) ? $value * 2 : 0;&#125;;$result = with(5, $callback);$result = with(null, $callback);$result = with(5, null); Answer:// 10// 0// 5會將 arg1 帶入 arg2 closure, 如果 closure return null, 則 return arg1, 否則則 return closure return value與 transform 類似, 但 transform 可 pass arg3 as default value # Additional以下的 Laravel 程式碼的意思是？ Example:&lt;?php$ip = data_get($this-&gt;pendingWalletSettlement-&gt;settleable, &#x27;depositDetail.client_ipv4&#x27;) Answer:&lt;?php// 從 settleable 得到的 model 裏頭, 取得他的 relation depositDetail 的 attribute client_ipv4$ip = data_get($this-&gt;pendingWalletSettlement-&gt;settleable, &#x27;depositDetail.client_ipv4&#x27;)","link":"/zh-tw/laravel-digging-deeper-helpers/"},{"title":"Laravel - Digging Deeper - Mail (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Driver / Transport Prerequisites# Mailgun Driver以下的 Laravel example code 的意思是？ Example:&lt;?php// config/services.php&#x27;mailgun&#x27; =&gt; [ &#x27;domain&#x27; =&gt; env(&#x27;MAILGUN_DOMAIN&#x27;), &#x27;secret&#x27; =&gt; env(&#x27;MAILGUN_SECRET&#x27;), &#x27;endpoint&#x27; =&gt; env(&#x27;MAILGUN_ENDPOINT&#x27;, &#x27;api.eu.mailgun.net&#x27;),], Answer:設定 mail driver mailgun service, 如果不是使用 United States Mailgun region, 可以自定義在 endpoint # Postmark Driver以下的 Laravel example code 的意思是？ Example:&lt;?phpcomposer require wildbit/swiftmailer-postmark Answer:使用 postmark mail driver 需要安裝的套件 以下的 Laravel example code 的意思是？ Example:&lt;?php// config/services.php&#x27;postmark&#x27; =&gt; [ &#x27;token&#x27; =&gt; env(&#x27;POSTMARK_TOKEN&#x27;),], Answer:mail driver psotmark 的設定 以下的 Laravel example code 的意思是？ Example:&lt;?php// config/mail.php&#x27;postmark&#x27; =&gt; [ &#x27;transport&#x27; =&gt; &#x27;postmark&#x27;, &#x27;message_stream_id&#x27; =&gt; env(&#x27;POSTMARK_MESSAGE_STREAM_ID&#x27;),], Answer:可自定義 postmark mail driver 的 message_stream # SES Driver以下的 Laravel example code 的意思是？ Example:composer require aws/aws-sdk-php Answer:要在 Laravel 使用 AWS 的服務, 如 s3, SES, SQS 時, 需安裝 AWS SDK 以下的 Laravel example code 的意思是？ Example:&lt;?php// config/services.php&#x27;ses&#x27; =&gt; [ &#x27;key&#x27; =&gt; env(&#x27;AWS_ACCESS_KEY_ID&#x27;), &#x27;secret&#x27; =&gt; env(&#x27;AWS_SECRET_ACCESS_KEY&#x27;), &#x27;region&#x27; =&gt; env(&#x27;AWS_DEFAULT_REGION&#x27;, &#x27;us-east-1&#x27;), &#x27;options&#x27; =&gt; [ &#x27;ConfigurationSetName&#x27; =&gt; &#x27;MyConfigurationSet&#x27;, &#x27;Tags&#x27; =&gt; [ [&#x27;Name&#x27; =&gt; &#x27;foo&#x27;, &#x27;Value&#x27; =&gt; &#x27;bar&#x27;], ], ],], Answer:除了 AWS 預設的 key, secret, region 之外, 還可設置 additional 的 setting # Generating Mailables以下的 Laravel example code 的意思是？ Example:php artisan make:mail OrderShipped Answer:建立一個 mailable class, 會放在 app/Mail # Writing Mailables# Configuring The Sender# Using The from Method以下的 Laravel example code 的意思是？ Example:&lt;?php// in mailable classpublic function build()&#123; return $this-&gt;from(&#x27;example@example.com&#x27;) -&gt;view(&#x27;emails.orders.shipped&#x27;);&#125; Answer:在 mailable class 的 build 中, 可以使用 from 來指定由的 from # Using A Global from address以下的 Laravel example code 的意思是？ Example:&lt;?php// config/mail.php&#x27;from&#x27; =&gt; [&#x27;address&#x27; =&gt; &#x27;example@example.com&#x27;, &#x27;name&#x27; =&gt; &#x27;App Name&#x27;], Answer:可在 config/mail.php 定義 global 的 from, 即寄件人信箱, 若需要 ad hoc 可在 mailable class 的 build method 中使用 from() 定義 以下的 Laravel example code 的意思是？ Example:&lt;?php// config/mail.php&#x27;reply_to&#x27; =&gt; [&#x27;address&#x27; =&gt; &#x27;example@example.com&#x27;, &#x27;name&#x27; =&gt; &#x27;App Name&#x27;], Answer:定義 reply_to address當收到 mail 時, 預設按下 reply 會寄給 FROM address, 若要指定一個跟 FROM address 不同的 reply address, 可在此定義 # Configuring The View以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;);&#125; Answer:在 mailable class 的 build method 內, 使用 view() 來指定渲染該 mail 的 template # Plain Text Emails以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;) -&gt;text(&#x27;emails.orders.shipped_plain&#x27;);&#125; Answer:可以同時定義 HTML 以及 plain text version, 當 user 切換為 plain text version 時, 就會顯示該版本 # View Data# Via Public Properties以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Mail;class OrderShipped extends Mailable&#123; use Queueable, SerializesModels; public $order; public function __construct(Order $order) &#123; $this-&gt;order = $order; &#125; public function build() &#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;); &#125;&#125;// on template&lt;div&gt; Price: &#123;&#123; $order-&gt;price &#125;&#125;&lt;/div&gt; Answer:當使用 mailable class 時, 可在 constructor 內定義 property, 此 property 可在 template 中被調用 # Via The with Method:以下的 Laravel example code 的意思是？ Example:&lt;?phpclass OrderShipped extends Mailable&#123; use Queueable, SerializesModels; protected $order; public function __construct(Order $order) &#123; $this-&gt;order = $order; &#125; public function build() &#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;) -&gt;with([ &#x27;orderName&#x27; =&gt; $this-&gt;order-&gt;name, &#x27;orderPrice&#x27; =&gt; $this-&gt;order-&gt;price, ]); &#125;&#125;// template file&lt;div&gt; Price: &#123;&#123; $orderPrice &#125;&#125;&lt;/div&gt; Answer:如果 mailable 中的 property 使用 protected 或 private 的話, 則必須使用 with() 將 data pass 過去 # Attachments以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;) -&gt;attach(&#x27;/path/to/file&#x27;, [ &#x27;as&#x27; =&gt; &#x27;name.pdf&#x27;, &#x27;mime&#x27; =&gt; &#x27;application/pdf&#x27;, ]);&#125; Answer:在 mailable class 的 build method 中, 可以使用 attach() 定義 attachment, arg2 還可以定義檔名以及 mine type # Attaching Files from Disk以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;) -&gt;attachFromStorage(&#x27;/path/to/file&#x27;, &#x27;name.pdf&#x27;, [ &#x27;mime&#x27; =&gt; &#x27;application/pdf&#x27; ]);&#125; Answer:在 mailable class 的 build method 中, 使用 attachFromStorage, attach filesystem disk 的 file 到 email, arg2 可指定檔名, arg3 可指定 mine type 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;) -&gt;attachFromStorageDisk(&#x27;s3&#x27;, &#x27;/path/to/file&#x27;);&#125; Answer:在 mailable class 的 build method 中, 使用 attachFromStorageDisk, attach filesystem disk 的 file 到 email, arg1 可指定要使用哪一個 disk # Raw Data Attachment以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; return $this-&gt;view(&#x27;emails.orders.shipped&#x27;) -&gt;attachData($this-&gt;pdf, &#x27;name.pdf&#x27;, [ &#x27;mime&#x27; =&gt; &#x27;application/pdf&#x27;, ]);&#125; Answer:attach raw data, 通常是 attach 當次 request 產生的 pdf, 在 memory 中, 並沒有存到 disk 中, arg2 可指定檔名 arg3 可指定 mine type # Inline Attachments以下的 Laravel example code 的意思是？ Example:&lt;?php&lt;body&gt; Here is an image: &lt;img src=&quot;&#123;&#123; $message-&gt;embed($pathToImage) &#125;&#125;&quot;&gt;&lt;/body&gt; Answer:email template 中, 可以使用 $message variable 的 embed method 來實現 inline attachment # Embedding Raw Data Attachments以下的 Laravel example code 的意思是？ Example:&lt;?php&lt;body&gt; Here is an image from raw data: &lt;img src=&quot;&#123;&#123; $message-&gt;embedData($data, &#x27;example-image.jpg&#x27;) &#125;&#125;&quot;&gt;&lt;/body&gt; Answer:在 mail template 中, 如果 memory 中已有檔案, 可以使用 embedData method 來實現 inline attachment # Customizing The SwiftMailer Message以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; $this-&gt;view(&#x27;emails.orders.shipped&#x27;); $this-&gt;withSwiftMessage(function ($message) &#123; $message-&gt;getHeaders()-&gt;addTextHeader( &#x27;Custom-Header&#x27;, &#x27;Header Value&#x27; ); &#125;);&#125; Answer:在 mailable class 的 build method 中, 使用 withSwiftMessage(), 可註冊一個 closure, 會跟著 SwiftMailer message instance 被觸發, 可在送出 mail 前做一些客製化 # Markdown Mailables# Generating Markdown Mailables以下的 Laravel example command 的意思是？ Example:&lt;?phpphp artisan make:mail OrderShipped --markdown=emails.orders.shipped Answer:建立一個 mailable class, 以及相對應的 markdown template 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function build()&#123; return $this-&gt;from(&#x27;example@example.com&#x27;) -&gt;markdown(&#x27;emails.orders.shipped&#x27;, [ &#x27;url&#x27; =&gt; $this-&gt;orderUrl, ]);&#125; Answer:在 mailable class 的 build method 中, 使用 markdown(), arg1 指定 markdown template, arg2 可帶入 array, 該 array data 會在 template 中可被以變數的方式使用 # Writing Markdown Messages以下的 Laravel Mailable Markdown Template example code 的意思是？ Example:&lt;?php@component(&#x27;mail::message&#x27;)# Order ShippedYour order has been shipped!@component(&#x27;mail::button&#x27;, [&#x27;url&#x27; =&gt; $url])View Order@endcomponentThanks,&lt;br&gt;&#123;&#123; config(&#x27;app.name&#x27;) &#125;&#125;@endcomponent Answer:Laravel 的 Mailable Markdown Template 結合了 Blade 的 component 以及 Markdown 語法, 可使用 Laravel 預設的 email UI component # Button Component以下的 Laravel Mailable Markdown Template example code 的意思是？ Example:&lt;?php@component(&#x27;mail::button&#x27;, [&#x27;url&#x27; =&gt; $url, &#x27;color&#x27; =&gt; &#x27;success&#x27;])View Order@endcomponent Answer:使用 Laravel 內建的 email UI component, 為一個 button, 可指定 url 以及 color, color 又可指定 primary, success, 以及 error # Panel Component以下的 Laravel Mailable Markdown Template example code 的意思是？ Example:&lt;?php@component(&#x27;mail::panel&#x27;)This is the panel content.@endcomponent Answer:使用 Laravel 內建的 email UI component, panel 的效果會讓該區塊的背景顏色稍為不同, 可以達到引起注意力的效果 # Table Component以下的 Laravel Mailable Markdown Template example code 的意思是？ Example:&lt;?php@component(&#x27;mail::table&#x27;)| Laravel | Table | Example || ------------- |:-------------:| --------:|| Col 2 is | Centered | $10 || Col 3 is | Right-Aligned | $20 |@endcomponent Answer:使用 Laravel 內建的 email UI component, 就是 Markdown table 的效果 # Customizing The Components以下的 Laravel example commadn 的意思是？ Example:&lt;?phpphp artisan vendor:publish --tag=laravel-mail Answer:可以匯出 Laravel 內建的 mail template, 匯出後可依照自己的需求去做進一步客製化, 會匯出到 resources/views/vendor/mail 資料夾 # Customizing The CSSLaravel 中, 如果我要客製化 Markdown template 的 CSS, 該怎麼做？ 在 export components 後, 修改 resources/views/vendor/mail/html/themes 資料夾中的 default.css 在 resources/views/vendor/mail/html/themes 資料夾中建立一個新的 CSS file, 並在 config/mail.php 中修改 theme 要吃的檔案 若要針對單一 mailable class 修改, 可在 mailable class 中的 $theme property 中, 指定要吃的 theme css file # Sending Mail以下的 Laravel example code 的意思是？ Example:&lt;?phpclass OrderShipmentController extends Controller&#123; public function store(Request $request) &#123; $order = Order::findOrFail($request-&gt;order_id); // Ship the order... Mail::to($request-&gt;user())-&gt;send(new OrderShipped($order)); &#125;&#125; Answer:使用 Mail facade 的 to(), 指定收件人, 會自動到該 User model 尋找 name column 以及 email column, 然後再指定 mailable class 以下的 Laravel example code 的意思是？ Example:&lt;?phpMail::to($request-&gt;user()) -&gt;cc($moreUsers) -&gt;bcc($evenMoreUsers) -&gt;send(new OrderShipped($order)); Answer:也可使用 cc (Carbon Copy) 以及 bcc (Blind Carbon Copy) method 來寄信 # Looping Over Recipients以下的 Laravel example code 的意思是？ Example:&lt;?phpforeach ([&#x27;taylor@example.com&#x27;, &#x27;dries@example.com&#x27;] as $recipient) &#123; Mail::to($recipient)-&gt;send(new OrderShipped($order));&#125; Answer:有時會需要使用 loop 來將同一個 mailable class 寄給很多收件人, 這時務必在每一個 iteration 中都要使用 new Mailable Instance, 否則 to() 會將 email append 到 mailable instance, 這樣就會變成每一個 iteration 都會寄給之前的所有收件人 # Sending Mail Via A Specific Mailer以下的 Laravel example code 的意思是？ Example:&lt;?phpMail::mailer(&#x27;postmark&#x27;) -&gt;to($request-&gt;user()) -&gt;send(new OrderShipped($order)); Answer:Laravel 預設會使用 config/mail.php 中的 default mailer 來寄信, 也可使用 mailer() 來特別指定 # Queueing Mail# Queueing A Mail Message以下的 Laravel example code 的意思是？ Example:&lt;?phpMail::to($request-&gt;user()) -&gt;cc($moreUsers) -&gt;bcc($evenMoreUsers) -&gt;queue(new OrderShipped($order)); Answer:使用 queue 來發送 mail # Delayed Message Queueing以下的 Laravel example code 的意思是？ Example:&lt;?phpMail::to($request-&gt;user()) -&gt;cc($moreUsers) -&gt;bcc($evenMoreUsers) -&gt;later(now()-&gt;addMinutes(10), new OrderShipped($order)); Answer:使用 later(), 可以發送 delayed queue message # Pushing To Specific Queues以下的 Laravel example code 的意思是？ Example:&lt;?php$message = (new OrderShipped($order)) -&gt;onConnection(&#x27;sqs&#x27;) -&gt;onQueue(&#x27;emails&#x27;);Mail::to($request-&gt;user()) -&gt;cc($moreUsers) -&gt;bcc($evenMoreUsers) -&gt;queue($message); Answer:使用 queue 發送 mail, 並指定其 connection 以及 queue # Queueing By Default以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Contracts\\Queue\\ShouldQueue;class OrderShipped extends Mailable implements ShouldQueue&#123; //&#125; Answer:如果已經確定這個 mailable 會固定使用 queue 來發送, 可以 implement ShouldQueue interface # Queued Mailables &amp; Database Transaction以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Contracts\\Queue\\ShouldQueue;class OrderShipped extends Mailable implements ShouldQueue&#123; public $afterCommit = true;&#125; Answer:有時我們會在 transaction 中發送 queued mailable, 但在 transaction 完成之前 mailable 就已經 dispatch 了, 這會造成預期外的錯誤, 如要避免此情況, 可將 mailable class 的 $afterCommit property 設為 true, 這樣 queued mail 就會等到當下所有的 open transaction 都完成了才會寄出 # Rendering Mailables以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Mail\\InvoicePaid;use App\\Models\\Invoice;$invoice = Invoice::find(1);return (new InvoicePaid($invoice))-&gt;render(); Answer:render method 會以 string 的方式 return HTML content # Previewing Mailables In The Browser以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/mailable&#x27;, function () &#123; $invoice = App\\Models\\Invoice::find(1); return new App\\Mail\\InvoicePaid($invoice);&#125;); Answer:在設計 mailable class 時, 會希望可以即時地看到畫面, 這時可以直接 return mailable instance需注意這並不會 return inline attachment, 如需測試 inline attachment, 可使用 MailHog 或 HELO # Localizing Mailables以下的 Laravel example code 的意思是？ Example:&lt;?phpMail::to($request-&gt;user())-&gt;locale(&#x27;es&#x27;)-&gt;send( new OrderShipped($order)); Answer:使用 locale() 來指定 locale # User Preferred Locales以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Contracts\\Translation\\HasLocalePreference;class User extends Model implements HasLocalePreference&#123; public function preferredLocale() &#123; return $this-&gt;locale; &#125;&#125;// in controllerMail::to($request-&gt;user())-&gt;send(new OrderShipped($order)); Answer:當 notifiable model implement HasLocalePreference interface 之後, 可在 preferredLocale() 中定義要使用的 locale, 當使用 to() 發送 mailable 給指定 user 時, 會自動抓取資料庫中的 locale # Testing Mailables以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Mail\\InvoicePaid;use App\\Models\\User;public function test_mailable_content()&#123; $user = User::factory()-&gt;create(); $mailable = new InvoicePaid($user); $mailable-&gt;assertSeeInHtml($user-&gt;email); $mailable-&gt;assertSeeInHtml(&#x27;Invoice Paid&#x27;); $mailable-&gt;assertSeeInText($user-&gt;email); $mailable-&gt;assertSeeInText(&#x27;Invoice Paid&#x27;);&#125; Answer:可使用 mailable testing method 來驗證 mailable 是否包含指定的 string, assertSeeInHtml 跟 assertSeeInText 差別在於 HTML version mail 跟 plain text version mail # Mail &amp; Local DevelopmentLaravel 中, 如果要測試 mail 是否有被發送, 可使用哪兩種方式？Log driver 或一些其他的服務, 像是 HELO, Mailtrap, MailHog # Events以下的 Laravel example code 的意思是？ Example:&lt;?phpprotected $listen = [ &#x27;Illuminate\\Mail\\Events\\MessageSending&#x27; =&gt; [ &#x27;App\\Listeners\\LogSendingMessage&#x27;, ], &#x27;Illuminate\\Mail\\Events\\MessageSent&#x27; =&gt; [ &#x27;App\\Listeners\\LogSentMessage&#x27;, ],]; Answer:可註冊 listener 監聽兩種 mail event, MessageSending event 在 mail 發送前被觸發, MessageSent 在發送後觸發, 注意如果只是 queue 的話並不會觸發, 待該 job 真正被 worker pick up 被執行時才會觸發","link":"/zh-tw/laravel-digging-deeper-mail/"},{"title":"Laravel - Documentation - 目錄 (官方文件原子化翻譯)","text":"# 前言我喜歡使用 Laravel 開發的感覺, 除了開發快速, 程式碼簡潔且優雅之外, Laravel 框架本身也是一個很好的學習參照物 Laravel 的功能很多, 在進入 Laravel 底層的世界之前, 我希望可以初步的了解全部的功能, 我相信這會讓我在遇到問題時, 可以不必重新造輪子, 選擇 Laravel 已提供的最佳解法。 所以我詳讀 Laravel Documentation 的每一頁文件, 並以適合自己理解的方式製作成筆記。而我希望這份筆記也可以幫助到其他人。 # The BasicsRoutingMiddlewareCSRF ProtectionControllersRequestsResponsesViewsURL GenerationSessionValidationError HandlingLoggingBlade Templates # SecurityAuthenticationAuthorizationEmail VerificationEncryptionHashingPassword Reset # Digging DeeperArtisan ConsoleBroadcastingCacheCollectionsEventsFile StorageHelpersHTTP ClientMailNotificationsPackage DevelopmentQueuesTask SchedulingLocalizationCompiling Assets # DatabaseGetting StartedQuery BuilderPaginationMigrationsSeedingRedis # Eloquent ORMGetting StartedRelationshipsCollectionsMutatorsAPI ResourcesSerialization # TestingGetting StartedHTTP TestsConsole TestsBrowser TestsDatabaseMocking # PackagesCashier (Stripe)Cashier (Paddle)Cashier (Mollie)DuskEnvoyHorizonJetstreamPassportSanctumScoutSocialiteTelescope # AdditionalCarbon","link":"/zh-tw/laravel-documentation/"},{"title":"Laravel - Digging Deeper - Task Scheduling (官方文件原子化翻譯)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Defining Schedules以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Console;use Illuminate\\Console\\Scheduling\\Schedule;use Illuminate\\Foundation\\Console\\Kernel as ConsoleKernel;use Illuminate\\Support\\Facades\\DB;class Kernel extends ConsoleKernel&#123; protected $commands = [ // ]; protected function schedule(Schedule $schedule) &#123; $schedule-&gt;call(function () &#123; DB::table(&#x27;recent_users&#x27;)-&gt;delete(); &#125;)-&gt;daily(); &#125;&#125; Answer:在 App\\Console\\Kernel class 的 schedule method 中定義 schedule, 在每天的晚上 12 點刪除 records in recent_users table 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(new DeleteRecentUsers)-&gt;daily(); Answer:除了 schedule closure, 也可以 schedule invokable object 以下的 Laravel example command 的意思是？ Example:&lt;?phpphp artisan schedule:list Answer:列出所有已定義的 schedule overview # Scheduling Artisan Commands以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Console\\Commands\\SendEmailsCommand;$schedule-&gt;command(&#x27;emails:send Taylor --force&#x27;)-&gt;daily();$schedule-&gt;command(SendEmailsCommand::class, [&#x27;Taylor&#x27;, &#x27;--force&#x27;])-&gt;daily(); Answer:使用 Laravel schedule 來 schedule command 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Jobs\\Heartbeat;$schedule-&gt;job(new Heartbeat, &#x27;heartbeats&#x27;, &#x27;sqs&#x27;)-&gt;everyFiveMinutes(); Answer:使用 Laravel schedule 來 schedule job, 並指定 queue 以及 connection # Scheduling Shell Commands以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;exec(&#x27;node /home/forge/script.js&#x27;)-&gt;daily(); Answer:使用 Laravel schedule 來 schedule shell command # Schedule Frequency Options以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;cron(&#x27;* * * * *&#x27;); Answer:客製化的 cron schedule 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyMinute(); Answer:每分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyTwoMinutes(); Answer:每 2 分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyThreeMinutes(); Answer:每 3 分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyFourMinutes(); Answer:每 4 分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyFiveMinutes(); Answer:每 5 分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyTenMinutes(); Answer:每 10 分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyFifteenMinutes(); Answer:每 15 分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyThirtyMinutes(); Answer:每 30 分鐘執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;hourly(); Answer:每 1 小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;hourlyAt(17); Answer:每 1 小時的 17 分執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyTwoHours(); Answer:每 2 小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyThreeHours(); Answer:每 3 小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everyFourHours(); Answer:每 4 小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;everySixHours(); Answer:每 6 小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;daily(); Answer:每 1 天 00:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;dailyAt(&#x27;13:00&#x27;); Answer:每 1 天的 13:00 時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;twiceDaily(1, 13); Answer:每 1 天的 01:00 以及 13:00 時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;weekly(); Answer:每個 Sunday 00:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;weeklyOn(1, &#x27;8:00&#x27;); Answer:每個 Monday 8:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;monthly(); Answer:每個月的第一天 00:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;monthlyOn(4, &#x27;15:00&#x27;); Answer:每個月的第四天 15:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;twiceMonthly(1, 16, &#x27;13:00&#x27;); Answer:每個月的第一天, 第十六天 13:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;lastDayOfMonth(&#x27;15:00&#x27;); Answer:每個月的最後一天, 15:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;quarterly(); Answer:每季的第一天 00:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;yearly(); Answer:每年的第一天 00:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;yearlyOn(6, 1, &#x27;17:00&#x27;); Answer:每年的六月一號 17:00 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;timezone(&#x27;America/New_York&#x27;); Answer:定義 schedule timezone 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;weekly()-&gt;mondays()-&gt;at(&#x27;13:00&#x27;);$schedule-&gt;command(&#x27;foo&#x27;) -&gt;weekdays() -&gt;hourly() -&gt;timezone(&#x27;America/Chicago&#x27;) -&gt;between(&#x27;8:00&#x27;, &#x27;17:00&#x27;); Answer:除了直接使用 constraint method, 也可以將不同的 constraint 連接起來每個禮拜一的 13:00 執行星期 1 - 5, 8:00 到 17:00 每小時執行一次 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;weekdays(); Answer:禮拜 1 - 5 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;weekends(); Answer:禮拜六 - 日 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;sundays(); Answer:禮拜日執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;mondays(); Answer:禮拜一執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;tuesdays; Answer:禮拜二執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;wednesdays; Answer:禮拜三執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;thursdays; Answer:禮拜四執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;fridays; Answer:禮拜五執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;saturdays(); Answer:禮拜六執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;days(array|mixed); Answer:在指定的 days 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;bewteen($startTime, $endTime); Answer:在指定的時間區間內執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;unlessBetween($startTime, $endTime); Answer:只在指定的時間區間內不執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;when(Closure); Answer:當 closure return true 時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;call(function () &#123; //&#125;)-&gt;enviroments($env); Answer:若為指定的 env 時則執行, 例如 staging 或 production # Day Constraints以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;hourly() -&gt;days([0, 3]); Answer:在禮拜日, 禮拜三的每小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Console\\Scheduling\\Schedule;$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;hourly() -&gt;days([Schedule::SUNDAY, Schedule::WEDNESDAY]); Answer:在禮拜日, 禮拜三的每小時執行 # Between Time Constraints以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;hourly() -&gt;between(&#x27;7:00&#x27;, &#x27;22:00&#x27;); Answer:在 7:00 到 22:00 之間, 每小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;hourly() -&gt;unlessBetween(&#x27;23:00&#x27;, &#x27;4:00&#x27;); Answer:在 23:00 到 04:00 之間不執行, 其餘時間每小時執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;)-&gt;daily()-&gt;when(function () &#123; return true;&#125;); Answer:每天的 00:00, 若 when() 內 closure return true 執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;)-&gt;daily()-&gt;skip(function () &#123; return true;&#125;); Answer:每天的 00:00, 若 skip() 內 closure return true 則不執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;environments([&#x27;staging&#x27;, &#x27;production&#x27;]); Answer:每天的 00:00, 若 env 為 staging 或 production 時執行 # Timezones以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;report:generate&#x27;) -&gt;timezone(&#x27;America/New_York&#x27;) -&gt;at(&#x27;2:00&#x27;) Answer:New_York 時間的 2:00 執行 以下位於 App\\Console\\Kernel 的 Laravel example code 的意思是？ Example:&lt;?phpprotected function scheduleTimezone()&#123; return &#x27;America/Chicago&#x27;;&#125; Answer:在 App\\Console\\Kernel 的 scheduleTimezone() 內可定義適用於 schedule 的 global timezone Laravel 中, 為何不建議 timezone scheduling?因為一些時區會使用夏令制, 也就是可能會多一個小時或少一個小時, 這會造成一個 schedule 在一天內執行兩次, 或完全不執行 # Preventing Task Overlaps以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;)-&gt;withoutOverlapping(); Answer:使用 withoutOverlapping() 來避免 task 已經在執行中了, 又被執行 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;)-&gt;withoutOverlapping(10); Answer:使用 withoutOverlapping() 來避免 task 已經在執行中了, 又被執行, 預設 withoutOverlapping lock 會在 24 hours 後失效, 也可帶入時間自定義, 單位為 minute # Running Tasks On One Server以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;report:generate&#x27;) -&gt;fridays() -&gt;at(&#x27;17:00&#x27;) -&gt;onOneServer(); Answer:如果是跑多台 server 的話, scheduled task 很有可能會在多台 server 同時執行, 這樣就執行了多次, 浪費效能, 可使用 onOneServer(), 第一台取得該 scheduled task 執行權的 server 會給該 task 加上一個 lock, 避免重複執行 # Background Tasks以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;analytics:report&#x27;) -&gt;daily() -&gt;runInBackground(); Answer:當使用 scheduled task 時, 預設會按照順序執行的, 如此一來, 如果遇到耗時較久的 task, 很有可能會造成阻塞, 這時可使用 runInBackground() 讓不同的 task 同時被執行, runInBackground() 只適用於 command 或 exec 的 scheduled task # Maintenance Mode以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;)-&gt;evenInMaintenanceMode(); Answer:預設在 maintenance mode 時, scheduled task 是不會被執行的, 如果依然想要執行的話, 可使用 evenInMaintenanceMode() # Running The Scheduler以下的 Laravel example code 的意思是？ Example:&lt;?php* * * * * cd /path-to-your-project &amp;&amp; php artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1 Answer:schedule:run 指定會去判斷當下時間是否有需要執行任何已定義的 scheduled task, 所以必須使用 cron server, 每分鐘都執行一次 schedule:run # Running The Scheduler Locally以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan schedule:work Answer:在本地開發時, 我們不太會使用 cron 來跑 scheduled task, 這時可使用 schedule:work command 來暫時跑一個 process 在 foreground, 每分鐘都去執行 schedule:run # Task Output以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;sendOutputTo($filePath); Answer:定義 scheduled task 的 output 位置, 會覆蓋該檔案 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;appendOutputTo($filePath); Answer:定義 scheduled task 的 output append 位置, append 輸出 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;report:generate&#x27;) -&gt;daily() -&gt;sendOutputTo($filePath) -&gt;emailOutputTo(&#x27;taylor@example.com&#x27;); Answer:定義 scheduled task 的 output 位置, 可定義機器內的檔案位置, 或是將 output 透過 email 發送 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;report:generate&#x27;) -&gt;daily() -&gt;emailOutputOnFailure(&#x27;taylor@example.com&#x27;); Answer:定義 scheduled task 的 output 透過 email 方式發送, 且只有在 non-zero exit code 時才發送 # Task Hooks以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;before(function () &#123; // do something &#125;) -&gt;after(function () &#123; // do something &#125;); Answer:使用 before(), after(), 在 scheduled task 被執行前以及執行後執行一些邏輯 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Stringable;$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;onSuccess(function (Stringable $output) &#123; // do something &#125;) -&gt;onFailure(function (Stringable $output) &#123; // do something &#125;); Answer:使用 onSuccess(), onFailure(), 在 scheduled task 執行成功或失敗後做一些事, 並且可使用 type hint Stringable 來存取 output # Pinging URLs以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;pingBefore($url) -&gt;thenPing($url); Answer:使用 pingBefore(), thenPing(), 在 scheduled task 執行前後 ping 指定的 url 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;pingBeforeIf($condition, $url) -&gt;thenPingIf($condition, $url); Answer:ping arg2 的 $url, 如果 arg1 $condition 為 true 的話 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;daily() -&gt;pingOnSuccess($successUrl) -&gt;pingOnFailure($failureUrl); Answer:會在 success 時 ping $successUrl, fails 時 ping $failureUrl 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;emails:send&#x27;) -&gt;twiceDailyAt(1, 13, 5); Answer:一天跑兩次, 分別在 01:05, 以及 13:05 時執行","link":"/zh-tw/laravel-digging-deeper-task-scheduling/"},{"title":"Laravel - Eloquent ORM - Collections (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Available Methods以下的 Laravel example code 的意思是？ Example:&lt;?php$users-&gt;contains(1);$users-&gt;contains(User::find(1)); Answer:判斷 Eloquent collection $users 是否含有 primary key 為 1 的 model, 或直接帶入 model 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;$users = $users-&gt;diff(User::whereIn(&#x27;id&#x27;, [1, 2, 3])-&gt;get()); Answer:取得 $users eloquent collection 中, 非 User::whereIn(&#39;id&#39;, [1,2,3])-&gt;get() 的 model 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = $users-&gt;except([1, 2, 3]); Answer:取得 $users eloquent model 中, primary key 非為 [1,2,3] 的 models 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = User::all();$user = $users-&gt;find(1); Answer:可帶入 primary key, 或 array of primary key, 或 model 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = $users-&gt;fresh();$users = $users-&gt;fresh(&#x27;comments&#x27;); Answer:從資料庫重新取得 $users eloquent collection 中的所有 model, 若是帶入 relation, 則該 relation 會被 eager loaded 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;$users = $users-&gt;intersect(User::whereIn(&#x27;id&#x27;, [1, 2, 3])-&gt;get()); Answer:取得 $users eloquent collection 中, 與 intersect() arg 重疊的 models 以下的 Laravel example code 的意思是？ Example:&lt;?php$users-&gt;load([&#x27;comments&#x27;, &#x27;posts&#x27;]);$users-&gt;load(&#x27;comments.author&#x27;); Answer:eager load $users eloquent collection 中所有 model 的指定 relations 以下的 Laravel example code 的意思是？ Example:&lt;?php$users-&gt;loadMissing([&#x27;comments&#x27;, &#x27;posts&#x27;]);$users-&gt;loadMissing(&#x27;comments.author&#x27;); Answer:如果 $users collection 中的 model 還沒有 eager load 指定的 relation, eager load it 以下的 Laravel example code 的意思是？ Example:&lt;?php$users-&gt;modelKeys();// [1, 2, 3, 4, 5] Answer:取得 $user eloquent collection 中 model 的 primary key 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = $users-&gt;makeVisible([&#x27;address&#x27;, &#x27;phone_number&#x27;]); Answer:將 $users eloquent collection 中的 model, 設為 hidden 的 attribute 改為 visible 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = $users-&gt;makeHidden([&#x27;address&#x27;, &#x27;phone_number&#x27;]); Answer:將 $users eloquent collection 中的 model 設為 visible 的 attribute 改為 hidden 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = $users-&gt;only([1, 2, 3]); Answer:只取得 given primary key 的 model 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;$users = User::where(&#x27;status&#x27;, &#x27;VIP&#x27;)-&gt;get();$users-&gt;toQuery()-&gt;update([ &#x27;status&#x27; =&gt; &#x27;Administrator&#x27;,]); Answer:將 $user eloquent collection 轉為含有 whereIn 現有 model primary key constraint 的 query builder 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = $users-&gt;unique(); Answer:移除 $users eloquent collection 中, 有相同 primary key 的 model 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use App\\Support\\UserCollection;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function newCollection(array $models = []) &#123; return new UserCollection($models); &#125;&#125; Answer:如果想要自訂特定 model 的 collection, 可使用 newCollection, 如果想要取得所有 model 的 collection, 可定義在 base model, 如 example, 可定義一個 UserCollection class, 在 newCollection method 中 return 該 class, 之後便可在 UserCollection class 中自定義 collection method","link":"/zh-tw/laravel-eloquent-orm-collections/"},{"title":"Laravel - Eloquent ORM - Serialization (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Serializing Models &amp; Collections# Serializing To Arrays以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;$user = User::with(&#x27;roles&#x27;)-&gt;first();return $user-&gt;toArray(); Answer:convert model 以及其 relation to array 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = User::first();return $user-&gt;attributesToArray(); Answer:將 $user model 的 attribute 轉為 array, 不包含 relation 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = User::all();return $users-&gt;toArray(); Answer:將 $users collection 轉為 array # Serializing To JSON以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;$user = User::find(1);return $user-&gt;toJson();return $user-&gt;toJson(JSON_PRETTY_PRINT); Answer:將 model 轉為 JSON, 也可帶入 PHP 支援的 JSON encoding option 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn (string) User::find(1); Answer:cast model 或 collection to string, 會自動呼叫 toJson method 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;users&#x27;, function () &#123; return User::all();&#125;); Answer:如果直接 return Eloquent objects, Laravel 會自動將其轉為 JSON # Hiding Attributes From JSON以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $hidden = [&#x27;password&#x27;];&#125; Answer:$hidden 內的 attribute 不會被 serialized 成 JSON Laravel 中, 如果我要讓一個 model 的 relation hidden, 可以怎麼做？在 $hidden property 內帶入 relation method name 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $visible = [&#x27;first_name&#x27;, &#x27;last_name&#x27;];&#125; Answer:所以不在 $visible property 內的 attribute 都不會被 serialized 到 model array 或 JSON # Temporarily Modifying Attribute Visibility以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $user-&gt;makeVisible(&#x27;attribute&#x27;)-&gt;toArray(); Answer:暫時性的讓原本被 hidden 的 attribute visible, 這樣才會被 serialized 到 array 內 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $user-&gt;makeHidden(&#x27;attribute&#x27;)-&gt;toArray(); Answer:暫時性的讓原本被 visible 的 attribute hidden, 這樣才不會被 serialized 到 array 內 # Appending Values To JSON以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $appends = [&#x27;is_admin&#x27;]; public function getIsAdminAttribute() &#123; return $this-&gt;attributes[&#x27;admin&#x27;] === &#x27;yes&#x27;; &#125; &#125; Answer:Model 中, 使用 accessor 取得值, 在放到 $appends property 中, 這樣每次都會 serializing 到 array 或 JSON 中, 也會反應 $visible 或 $hidden 的設定 # Appending At Run Time以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $user-&gt;append(&#x27;is_admin&#x27;)-&gt;toArray();return $user-&gt;setAppends([&#x27;is_admin&#x27;])-&gt;toArray(); Answer:使用 append 以及 setAppend, 在 run time 加入, 這樣該 value 才會被 serialized to array 或 JSON # Date Serialization# Customizing The Default Date Format以下的 Laravel example code 的意思是？ Example:&lt;?phpprotected function serializeDate(DateTimeInterface $date)&#123; return $date-&gt;format(&#x27;Y-m-d&#x27;);&#125; Answer:在 model 中, 使用 serializeDate() 定義 date serialization format, 此設定並不會影響 date 要存進資料庫時的格式化過程 # Customizing The Date Format Per Attribute以下的 laravel example code 的意思是？ example:&lt;?phpprotected $casts = [ &#x27;birthday&#x27; =&gt; &#x27;date:y-m-d&#x27;, &#x27;joined_at&#x27; =&gt; &#x27;datetime:y-m-d h:00&#x27;,]; answer:在 model 的 $casts property 內, 可以針對不同的 date attribute 定義不同的 serialization format 以下的 laravel example code 的意思是？ example:&lt;?phpprotected $casts = [ &#x27;birthday&#x27; =&gt; &#x27;immutable_date:y-m-d&#x27;, &#x27;joined_at&#x27; =&gt; &#x27;immutable_datetime:y-m-d h:00&#x27;,]; answer:在 model 的 $casts property 內, 可以針對不同的 date attribute 定義不同的 serialization format","link":"/zh-tw/laravel-eloquent-orm-serialization/"},{"title":"Laravel - Eloquent ORM - Getting Started","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Defining Models以下的 Laravel command 的意思是？ Example:php artisan make:model Flight Answer:建立一個名為 Flight 的 model 以下的 Laravel command 的意思是？ Example:php artisan make:model Flight --migrationphp artisan make:model Flight -m Answer:// 建立一個名為 Flight 的 model, 並建立其 migrationphp artisan make:model Flight --migration// 同上php artisan make:model Flight -m 以下的 Laravel command 的意思是？ Example:php artisan make:model Flight --factoryphp artisan make:model Flight -fphp artisan make:model Flight --seedphp artisan make:model Flight -sphp artisan make:model Flight --controllerphp artisan make:model Flight -cphp artisan make:model Flight -mfsc Answer:// 建立 Flight model, 並建立其 Factoryphp artisan make:model Flight --factory// 同上php artisan make:model Flight -f// 建立 Flight model, 並建立其 seederphp artisan make:model Flight --seed// 同上php artisan make:model Flight -s// 建立 Flight model, 並建立其 controlelrphp artisan make:model Flight --controller// 同上php artisan make:model Flight -c// 建立 Flight model, 並建立其 migraiton, factory, seeder, 以及 controllerphp artisan make:model Flight -mfsc # Eloquent Model ConventionsLaravel 中, 假設 model name 為 AirTrafficController, 根據 Laravel Model Convention, table name 應為？air_traffic_controllers # Table Names以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; protected $table = &#x27;my_flights&#x27;;&#125; Answer:指定該 model 所對應的 table # Primary Keys以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; protected $primaryKey = &#x27;flight_id&#x27;;&#125; Answer:primary key 預設為 id, 可以特別指定 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; public $incrementing = false;&#125; Answer:Laravel 預設 primary key 為 id, 且為 auto-incrementing, 會 cast 成 int, 若要使用 non-numeric 或 non-incrementing 的 primary key 的話, 要特別指定為 false 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; protected $keyType = &#x27;string&#x27;;&#125; Answer:Laravel 預設 primary key 為 id, 且為 auto-incrementing, 會 cast 成 int, 若 primary key 不是 int, 需特別指定 type # Timestamps以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; public $timestamps = false;&#125; Answer:Laravel Eloquent 預設會自動管理 created_at 以及 updated_at 欄位, 若不需 Eloquent 自動管理, 可設為 false 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; protected $dateFormat = &#x27;U&#x27;;&#125; Answer:Laravel 預設 timestamps 有其固定格式, 可特別指定格式, 格式決定儲存在資料庫中的格式以及 serialized 之後的格式 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; const CREATED_AT = &#x27;creation_date&#x27;; const UPDATED_AT = &#x27;last_update&#x27;;&#125; Answer:Laravel 中, 預設儲存 timestamps 的 column 分別是 created_at 以及 updated_at, 可使用以上 example 來自定義 # Database Connection以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; protected $connection = &#x27;connection-name&#x27;;&#125; Answer:Laravel 中, Eloquent Model 會使用預設的 Database connection, 可使用上面的 example 自定義 # Default Attribute Values以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Flight extends Model&#123; protected $attributes = [ &#x27;delayed&#x27; =&gt; false, ];&#125; Answer:設定 Eloquent Model attribute 的預設值 # Retrieving Models# Adding Additional Constraints以下的 Laravel example code 的意思是？ Example:&lt;?php$flights = App\\Models\\Flight::all();foreach ($flights as $flight) &#123; echo $flight-&gt;name;&#125; Answer:all() 可取得該 model 的所有 records, 也可使用 query constraints 之後, 使用 get() 取得結果 以下的 Laravel example code 的意思是？ Example:&lt;?php$flights = App\\Models\\Flight::where(&#x27;active&#x27;, 1) -&gt;orderBy(&#x27;name&#x27;, &#x27;desc&#x27;) -&gt;take(10) -&gt;get(); Answer:where()-&gt;orderBy()-&gt;take() 為 constraints, 最後使用 get() 取得資料, 若無 constraints, 可直接使用 all() 取得資料 # Refreshing Models以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::where(&#x27;number&#x27;, &#x27;FR 900&#x27;)-&gt;first();$freshFlight = $flight-&gt;fresh(); Answer:fresh() 會從 model 重新取得資料, 不影響 $flight 的內容 以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::where(&#x27;number&#x27;, &#x27;FR 900&#x27;)-&gt;first();$flight-&gt;number = &#x27;FR 456&#x27;;$flight-&gt;refresh();$flight-&gt;number; // &quot;FR 900&quot; Answer:refresh() 會使用 fresh() 取得的 data 將原本的替換掉, 包括 relationship # Collections以下的 Laravel example code 的意思是？ Example:&lt;?php$flights = $flights-&gt;reject(function ($flight) &#123; return $flight-&gt;cancelled;&#125;); Answer:將 cancelled 的 model 從 $flights 這個 collection 中移除, 並取代 $flights也可使用 &lt;?php$flights-&gt;forget(function ($flight) &#123; return $flight-&gt;cancelled;&#125;) 以下的 Laravel 中, 可以 foreach collection 嗎？可以 # Chunking Results以下的 Laravel example code 的意思是？ Example:&lt;?phpFlight::chunk(200, function ($flights) &#123; foreach ($flights as $flight) &#123; // &#125;&#125;); Answer:會將 collections 分成 1 個 chunk 200 筆資料, 所以共有幾個 chunk 視乎該 collection 共有幾筆資料, 再將每個 chunk 丟入 closure 執行, 如此一來, 當處理資料數量龐大的 collection 時, 可節省記憶體單次調用量 以下的 Laravel example code 的意思是？ Example:&lt;?phpFlight::where(&#x27;departed&#x27;, true)-&gt;chunkById(200, function ($flights) &#123; $flights-&gt;each-&gt;update([&#x27;departed&#x27; =&gt; false]);&#125;); Answer:一次只取 200 筆 update 以節省 memory, chunkById 會記住上一次 chunk 的 last_id, 並加上 orderById, 下一次只會從 last_id 之後取值; 若只使用 chunk 的話, 會是 offset … limit …, 後者遇到數據量大時, 效能會很差, 前者可以很明顯地增進效能 # Advanced Subqueries以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn Destination::addSelect([&#x27;last_flight&#x27; =&gt; Flight::select(&#x27;name&#x27;) -&gt;whereColumn(&#x27;destination_id&#x27;, &#x27;destinations.id&#x27;) -&gt;orderBy(&#x27;arrived_at&#x27;, &#x27;desc&#x27;) -&gt;limit(1)])-&gt;get(); Answer:&lt;?php// 新增 last_flight column, 其值為 query Flight table 得來return Destination::addSelect([&#x27;last_flight&#x27; =&gt; Flight::select(&#x27;name&#x27;) // 這行主要定義, 哪些 last_flight 會對應到哪一個 Destination row -&gt;whereColumn(&#x27;destination_id&#x27;, &#x27;destinations.id&#x27;) // 依照 arrived_at 排序 -&gt;orderBy(&#x27;arrived_at&#x27;, &#x27;desc&#x27;) // 只取一筆, 即最近的航班 -&gt;limit(1)])-&gt;get(); # Retrieving Single Models / Aggregates以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::find(1);$flight = App\\Models\\Flight::where(&#x27;active&#x27;, 1)-&gt;first();$flight = App\\Models\\Flight::firstWhere(&#x27;active&#x27;, 1); Answer:&lt;?php// 取得符合 primary key 的 model$flight = App\\Models\\Flight::find(1);// 取得符合 where constraint 的第一個 model$flight = App\\Models\\Flight::where(&#x27;active&#x27;, 1)-&gt;first();// where(&#x27;active&#x27;, 1)-&gt;first() 的縮寫$flight = App\\Models\\Flight::firstWhere(&#x27;active&#x27;, 1); 以下的 Laravel example code 的意思是？ Example:&lt;?php$flights = App\\Models\\Flight::find([1, 2, 3]); Answer:取得 primary key 符合 array 的 model 以下的 Laravel example code 的意思是？ Example:&lt;?php$model = App\\Models\\Flight::where(&#x27;legs&#x27;, &#x27;&gt;&#x27;, 100) -&gt;firstOr([&#x27;id&#x27;, &#x27;legs&#x27;], function () &#123; // ... &#125;); Answer:取得符合 (‘legs’, ‘&gt;’, 100) 條件的第一個 model 的 ‘id’ 及 ‘legs’ column, 如果該 model 不可得, 則執行 closure 內的動作 # Not Found Exceptions以下的 Laravel example code 的意思是？ Example:&lt;?php$model = App\\Models\\Flight::findOrFail(1);$model = App\\Models\\Flight::where(&#x27;legs&#x27;, &#x27;&gt;&#x27;, 100)-&gt;firstOrFail(); Answer:&lt;?php// 取得 primary key 為 1 的 model, 如果沒找到, 則 throw &#x27;ModelNotFoundException&#x27;// 如果該 exception 沒有被 caught, 則會回傳 404 給 user$model = App\\Models\\Flight::findOrFail(1);// 取得符合 (&#x27;legs&#x27;, &#x27;&gt;&#x27;, 100) 條件的第一個 model, 如果沒找到, 則 throw &#x27;ModelNotFoundException&#x27;// 如果該 exception 沒有被 caught, 則會回傳 404 給 user$model = App\\Models\\Flight::where(&#x27;legs&#x27;, &#x27;&gt;&#x27;, 100)-&gt;firstOrFail(); # Retrieving Aggregates以下的 Laravel example code 的意思是？ Example:&lt;?php$count = App\\Models\\Flight::where(&#x27;active&#x27;, 1)-&gt;count();$max = App\\Models\\Flight::where(&#x27;active&#x27;, 1)-&gt;max(&#x27;price&#x27;); Answer:&lt;?php// 取得符合 where(&#x27;active&#x27;, 1) 條件的 model 數量$count = App\\Models\\Flight::where(&#x27;active&#x27;, 1)-&gt;count();// 取得符合 where(&#x27;active&#x27;, 1) 條件的 model 中, price column 的最大值$max = App\\Models\\Flight::where(&#x27;active&#x27;, 1)-&gt;max(&#x27;price&#x27;); # Inserting &amp; Updating Models# Inserts以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;class FlightController extends Controller&#123; public function store(Request $request) &#123; // Validate the request... $flight = new Flight; $flight-&gt;name = $request-&gt;name; $flight-&gt;save(); &#125;&#125; Answer:從 $request 取得 name, 在 assign 到 $flight model 的 name attribute, 在執行 save() 存到資料庫created_at 以及 updated_at 會自動建立 # Updates以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::find(1);$flight-&gt;name = &#x27;New Flight Name&#x27;;$flight-&gt;save(); Answer:取得 primary key 為 1 的 model, 再用 save() 更新其 name attribute, updated_at 欄位會自動更新 # Mass Updates以下的 Laravel example code 的意思是？ Example:&lt;?phpApp\\Models\\Flight::where(&#x27;active&#x27;, 1) -&gt;where(&#x27;destination&#x27;, &#x27;San Diego&#x27;) -&gt;update([&#x27;delayed&#x27; =&gt; 1]); Answer:取得符合 where(‘active’, 1), 以及 where(‘destination’, ‘San Diego’) 的 models, 並更新 delayed column 為 1 Laravel 中, 當使用 Eloquent 實施 mass update 時, model events 像是 saving, saved, updating, updated 會被觸發嗎？不會 # Examining Attribute Changes以下的 Laravel example code 的意思是？ Example:&lt;?php$user = User::create([ &#x27;first_name&#x27; =&gt; &#x27;Taylor&#x27;, &#x27;last_name&#x27; =&gt; &#x27;Otwell&#x27;, &#x27;title&#x27; =&gt; &#x27;Developer&#x27;,]);$user-&gt;title = &#x27;Painter&#x27;;$user-&gt;isDirty(); // true or false$user-&gt;isDirty(&#x27;title&#x27;); // true or false$user-&gt;isDirty(&#x27;first_name&#x27;); // true or false$user-&gt;isClean(); // true or false$user-&gt;isClean(&#x27;title&#x27;); // true or false$user-&gt;isClean(&#x27;first_name&#x27;); // true or true$user-&gt;save();$user-&gt;isDirty(); // true or false$user-&gt;isClean(); // true or false Answer:&lt;?php$user = User::create([ &#x27;first_name&#x27; =&gt; &#x27;Taylor&#x27;, &#x27;last_name&#x27; =&gt; &#x27;Otwell&#x27;, &#x27;title&#x27; =&gt; &#x27;Developer&#x27;,]);// 這裡變更了 $user model 的 title attribute, 但尚未更動資料庫$user-&gt;title = &#x27;Painter&#x27;;// $user model 的 title attribute 變了, 所以 true$user-&gt;isDirty(); // true// 同上$user-&gt;isDirty(&#x27;title&#x27;); // true// first_name attribute 並未更動, 所以 false$user-&gt;isDirty(&#x27;first_name&#x27;); // false// $user model 已有變更, 所以非 clean$user-&gt;isClean(); // false// title attribute 已變更, 所以非 clean$user-&gt;isClean(&#x27;title&#x27;); // false// first_name attribute 並未更動, 所以 clean$user-&gt;isClean(&#x27;first_name&#x27;); // true// 這邊才真正更動資料庫$user-&gt;save();// 更動後, model 跟資料庫已同步, 所以 isDirty 為 false$user-&gt;isDirty(); // false// 更動後, model 跟資料庫已同步, 所以是 clean 的$user-&gt;isClean(); // true 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = User::create([ &#x27;first_name&#x27; =&gt; &#x27;Taylor&#x27;, &#x27;last_name&#x27; =&gt; &#x27;Otwell&#x27;, &#x27;title&#x27; =&gt; &#x27;Developer&#x27;,]);$user-&gt;title = &#x27;Painter&#x27;;$user-&gt;save();$user-&gt;wasChanged(); // true or false$user-&gt;wasChanged(&#x27;title&#x27;); // true or false$user-&gt;wasChanged(&#x27;first_name&#x27;); // true or false Answer:&lt;?php$user = User::create([ &#x27;first_name&#x27; =&gt; &#x27;Taylor&#x27;, &#x27;last_name&#x27; =&gt; &#x27;Otwell&#x27;, &#x27;title&#x27; =&gt; &#x27;Developer&#x27;,]);// 這邊更動了資料庫$user-&gt;title = &#x27;Painter&#x27;;$user-&gt;save();// 資料庫在當次 request cycle 有更動, 故為 true$user-&gt;wasChanged(); // true// title 有更動, 故為 true$user-&gt;wasChanged(&#x27;title&#x27;); // true// first_name 並沒有更動, 所以為 false$user-&gt;wasChanged(&#x27;first_name&#x27;); // false 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = User::find(1);$user-&gt;name; // John$user-&gt;email; // john@example.com$user-&gt;name = &quot;Jack&quot;;$user-&gt;name; // Jack$user-&gt;getOriginal(&#x27;name&#x27;); // 這裡是？$user-&gt;getOriginal(); // 這裡是？ Answer:&lt;?php$user = User::find(1);$user-&gt;name; // John$user-&gt;email; // john@example.com// 這裡變更了 $user model, 但尚未更動資料庫$user-&gt;name = &quot;Jack&quot;;$user-&gt;name; // Jack// 取得變更前的 $user model 的 name attribute$user-&gt;getOriginal(&#x27;name&#x27;); // John// 取得變更前的 $user model$user-&gt;getOriginal(); // 為更動前的 model array # Mass Assignment以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;class Flight extends Model&#123; protected $fillable = [&#x27;name&#x27;];&#125; Answer:允許 name column 可以批量 assign, 防止有心人士自帶預料外的參數 assign 到預料外的欄位 以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::create([&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;]); Answer:建立一筆資料, 並取得該 model 以下的 Laravel example code 的意思是？ Example:&lt;?php$flight-&gt;fill([&#x27;name&#x27; =&gt; &#x27;Flight 22&#x27;]); Answer:assign ‘Flight 22’ 到 $flight model 的 name attribute相當於 $flight-&gt;name = ‘Flight 22’; 以下的 Laravel example code 的意思是？ Example:&lt;?php$fillable = [ &#x27;options-&gt;enabled&#x27;,]; Answer:允許 nested JSON attribute “options-&gt;enabled” 可被批量 assign 以下的 Laravel example code 的意思是？ Example:&lt;?phpprotected $guarded = []; Answer:該 model 內的所有 attribute 都允許 mass assignment # Other Creation Methods# firstOrCreate / firstOrNew以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::firstOrCreate([&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;]);$flight = App\\Models\\Flight::firstOrCreate( [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;], [&#x27;delayed&#x27; =&gt; 1, &#x27;arrival_time&#x27; =&gt; &#x27;11:30&#x27;]);$flight = App\\Models\\Flight::firstOrNew([&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;]);$flight = App\\Models\\Flight::firstOrNew( [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;], [&#x27;delayed&#x27; =&gt; 1, &#x27;arrival_time&#x27; =&gt; &#x27;11:30&#x27;]); Answer:&lt;?php// 使用條件 [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;] 從資料庫尋找, 若找到則回傳該 model, // 若沒找到, 則使用 [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;] 建立該筆資料並回傳該 model$flight = App\\Models\\Flight::firstOrCreate([&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;]);// 使用條件 [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;] 從資料庫尋找, 若找到則回傳該 model, // 若沒找到, 則使用 [&#x27;name =&gt; &#x27;Flight 10&#x27;, &#x27;delayed&#x27; =&gt; 1, &#x27;arrival_time&#x27; =&gt; &#x27;11:30&#x27;]// 建立該筆資料並回傳該 model$flight = App\\Models\\Flight::firstOrCreate( [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;], [&#x27;delayed&#x27; =&gt; 1, &#x27;arrival_time&#x27; =&gt; &#x27;11:30&#x27;]);// 使用條件 [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;] 從資料庫尋找, 若找到則回傳該 model, // 若沒找到, 則使用 [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;] 回傳並建立該 model, 但尚未// 更新資料庫$flight = App\\Models\\Flight::firstOrNew([&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;]);// 使用條件 [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;] 從資料庫尋找, 若找到則回傳該 model, // 若沒找到, 則使用 [&#x27;name =&gt; &#x27;Flight 10&#x27;, &#x27;delayed&#x27; =&gt; 1, &#x27;arrival_time&#x27; =&gt; &#x27;11:30&#x27;]// 建立該 model, 但尚未更新資料庫$flight = App\\Models\\Flight::firstOrNew( [&#x27;name&#x27; =&gt; &#x27;Flight 10&#x27;], [&#x27;delayed&#x27; =&gt; 1, &#x27;arrival_time&#x27; =&gt; &#x27;11:30&#x27;]); # updateOrCreate以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::updateOrCreate( [&#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;], [&#x27;price&#x27; =&gt; 99, &#x27;discounted&#x27; =&gt; 1]); Answer:&lt;?php// 使用條件 [&#x27;departure&#x27; =&gt; &#x27;Oasland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;] 尋找// 如果有找到, 更新 [&#x27;price&#x27; =&gt; 99, &#x27;discounted&#x27; =&gt; 1], 如果沒找到, merge 上面// 兩個 array 並建立該筆資料$flight = App\\Models\\Flight::updateOrCreate( [&#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;], [&#x27;price&#x27; =&gt; 99, &#x27;discounted&#x27; =&gt; 1]); 以下的 Laravel example code 的意思是？ Example:&lt;?phpApp\\Models\\Flight::upsert([ [&#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;, &#x27;price&#x27; =&gt; 99], [&#x27;departure&#x27; =&gt; &#x27;Chicago&#x27;, &#x27;destination&#x27; =&gt; &#x27;New York&#x27;, &#x27;price&#x27; =&gt; 150]], [&#x27;departure&#x27;, &#x27;destination&#x27;], [&#x27;price&#x27;]); Answer:&lt;?php// 尋找第一個 arg 中的兩筆 record [[&#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;, &#x27;price&#x27; =&gt; 99], [array 2]]// 如果沒找到, 則以上面 array 中的資料建立, 如果有找到, 即 duplicate record, 那就更新第三個 arg 中的// price column, 則判斷是否 exist 的 unique 欄位為第二個 array 中的 [&#x27;departure&#x27;, &#x27;destination&#x27;]App\\Models\\Flight::upsert([ [&#x27;departure&#x27; =&gt; &#x27;Oakland&#x27;, &#x27;destination&#x27; =&gt; &#x27;San Diego&#x27;, &#x27;price&#x27; =&gt; 99], [&#x27;departure&#x27; =&gt; &#x27;Chicago&#x27;, &#x27;destination&#x27; =&gt; &#x27;New York&#x27;, &#x27;price&#x27; =&gt; 150]], [&#x27;departure&#x27;, &#x27;destination&#x27;], [&#x27;price&#x27;]); # Deleting Models以下的 Laravel example code 的意思是？ Example:&lt;?php$flight = App\\Models\\Flight::find(1);$flight-&gt;delete(); Answer:取得 primary key 為 1 的 model, 並 delete # Deleting An Existing Model By Key以下的 Laravel example code 的意思是？ Example:&lt;?phpApp\\Models\\Flight::destroy(1);App\\Models\\Flight::destroy(1, 2, 3);App\\Models\\Flight::destroy([1, 2, 3]);App\\Models\\Flight::destroy(collect([1, 2, 3])); Answer:&lt;?php// 刪除 primary key 為 1 的 modelApp\\Models\\Flight::destroy(1);// 同上App\\Models\\Flight::destroy(1, 2, 3);// 同上App\\Models\\Flight::destroy([1, 2, 3]);// 同上App\\Models\\Flight::destroy(collect([1, 2, 3])); 以下的 Laravel example code, deleting 以及 deleted event 會被觸發嗎？ Example:&lt;?phpApp\\Models\\Flight::destroy(1);App\\Models\\Flight::destroy(1, 2, 3);App\\Models\\Flight::destroy([1, 2, 3]);App\\Models\\Flight::destroy(collect([1, 2, 3])); Answer:會的, 因為 destroy 會分別載入每個 model, 並呼叫 delete method # Deleting Models By Query以下的 Laravel example code 的意思是？ Example:&lt;?php$deletedRows = App\\Models\\Flight::where(&#x27;active&#x27;, 0)-&gt;delete(); Answer:刪除符合 where(‘active’, 0) 的 model 以下的 Laravel example code, deleting 以及 deleted event 會被觸發嗎？ Example:&lt;?php$deletedRows = App\\Models\\Flight::where(&#x27;active&#x27;, 0)-&gt;delete(); Answer:不會, 因為實際上 model 並沒有被 retrieve # Soft Deleting以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\SoftDeletes;class Flight extends Model&#123; use SoftDeletes;&#125; Answer:啟用 soft delete, 啟用後當執行 delete(), model 並不會真正被刪除, 而是會在 deleted_at column 增加一筆時間, 如果 deleted_at column 不是 null, 那就代表該筆資料已被 soft deleted 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function up()&#123; Schema::table(&#x27;flights&#x27;, function (Blueprint $table) &#123; $table-&gt;softDeletes(); &#125;);&#125;public function down()&#123; Schema::table(&#x27;flights&#x27;, function (Blueprint $table) &#123; $table-&gt;dropSoftDeletes(); &#125;);&#125; Answer:&lt;?phppublic function up()&#123; // 增加 deleted_at column Schema::table(&#x27;flights&#x27;, function (Blueprint $table) &#123; $table-&gt;softDeletes(); &#125;);&#125;public function down()&#123; // 刪除 deleted_at column Schema::table(&#x27;flights&#x27;, function (Blueprint $table) &#123; $table-&gt;dropSoftDeletes(); &#125;);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($flight-&gt;trashed()) &#123; //&#125; Answer:確認該 model 是否被 soft deleted # Querying Soft Deleted Models# Including Soft Deleted Models**以下的 Laravel example code 的意思是？ Example:&lt;?php$flights = App\\Models\\Flight::withTrashed() -&gt;where(&#x27;account_id&#x27;, 1) -&gt;get(); Answer:當 model 被 soft deleted, 預設會被自動從 query 結果中排除, 如果要取得 soft deleted 的 model, 可以使用 withTrashed() 以下的 Laravel example code 的意思是？ Example:&lt;?php$flight-&gt;history()-&gt;withTrashed()-&gt;get(); Answer:取得 $flight model 的所有 history relation model, 包含 soft deleted # Retrieving Only Soft Deleted Models以下的 Laravel example code 的意思是？ Example:&lt;?php$flights = App\\Models\\Flight::onlyTrashed() -&gt;where(&#x27;airline_id&#x27;, 1) -&gt;get(); Answer:只取得符合 where(‘airline_id’, 1) 條件的 soft deleted model # Restoring Soft Deleted Models以下的 Laravel example code 的意思是？ Example:&lt;?php$flight-&gt;restore(); Answer:將 $flight soft deleted model 復原, 換言之, 將 deleted_at column 設為 null 以下的 Laravel example code 的意思是？ Example:&lt;?phpApp\\Models\\Flight::withTrashed() -&gt;where(&#x27;airline_id&#x27;, 1) -&gt;restore(); Answer:restore 符合 where(‘airline_id’, 1) 的所有 model, 即把 deleted_at column 設為 null 以下的 Laravel example code 的意思是？ Example:&lt;?php$flight-&gt;history()-&gt;restore(); Answer:restore $flight model 的 relation history 上的所有 soft deleted model # Permanently Deleting Models以下的 Laravel example code 的意思是？ Example:&lt;?php$flight-&gt;forceDelete();$flight-&gt;history()-&gt;forceDelete(); Answer:&lt;?php// 強制刪除 $flight, 即真正的刪除這筆資料$flight-&gt;forceDelete();// 強制刪除 relation history 上的所有 model, 這裡不包含 soft-deleted// 如果要取得 soft-deleted 需加上 withTrashed()$flight-&gt;history()-&gt;forceDelete(); # Replicating Models以下的 Laravel example code 的意思是？ Example:&lt;?php$shipping = App\\Models\\Address::create([ &#x27;type&#x27; =&gt; &#x27;shipping&#x27;, &#x27;line_1&#x27; =&gt; &#x27;123 Example Street&#x27;, &#x27;city&#x27; =&gt; &#x27;Victorville&#x27;, &#x27;state&#x27; =&gt; &#x27;CA&#x27;, &#x27;postcode&#x27; =&gt; &#x27;90001&#x27;,]);$billing = $shipping-&gt;replicate()-&gt;fill([ &#x27;type&#x27; =&gt; &#x27;billing&#x27;]);$billing-&gt;save(); Answer:&lt;?php// 建立一筆資料, 並 assign 到 $shipping$shipping = App\\Models\\Address::create([ &#x27;type&#x27; =&gt; &#x27;shipping&#x27;, &#x27;line_1&#x27; =&gt; &#x27;123 Example Street&#x27;, &#x27;city&#x27; =&gt; &#x27;Victorville&#x27;, &#x27;state&#x27; =&gt; &#x27;CA&#x27;, &#x27;postcode&#x27; =&gt; &#x27;90001&#x27;,]);// 複製 $shipping model, 將 type 替換為 &#x27;billing&#x27;, 並 assign 到 $billing// replicate 只是複製 model, 並未真正變動資料庫$billing = $shipping-&gt;replicate()-&gt;fill([ &#x27;type&#x27; =&gt; &#x27;billing&#x27;]);// 將 $billing 真正的存進資料庫$billing-&gt;save(); # Query ScopesLaravel 中, 當我新增 global scope constraint 時, 需要考慮到 soft-deleted 嗎？不需要, Laravel 會自動處理好 # Global Scopes# Writing Global Scopes以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Scopes;use Illuminate\\Database\\Eloquent\\Builder;use Illuminate\\Database\\Eloquent\\Model;use Illuminate\\Database\\Eloquent\\Scope;class AgeScope implements Scope&#123; public function apply(Builder $builder, Model $model) &#123; $builder-&gt;where(&#x27;age&#x27;, &#x27;&gt;&#x27;, 200); &#125;&#125; Answer:新增一個 global scope constraint, 可以在 model 的 booted method 中加入各種新增的 global scope constraint, 加入後, 該 model 取得的 query 都會自動附加 where(‘age’, ‘&gt;’, 200) constraint # Applying Global Scopes以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use App\\Scopes\\AgeScope;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected static function booted() &#123; static::addGlobalScope(new AgeScope); &#125;&#125; Answer:在 model 的 booted method 中, 可以將客制好的 global scope constraint AgeScope 附加到該 model, 如此一來, 之後使用 User model 的 query builder 都會自動附加 AgeScope 所定義的 constraint # Anonymous Global Scopes以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Builder;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected static function booted() &#123; static::addGlobalScope(&#x27;age&#x27;, function (Builder $builder) &#123; $builder-&gt;where(&#x27;age&#x27;, &#x27;&gt;&#x27;, 200); &#125;); &#125;&#125; Answer:利用 closure 來附加 global scope constraint, 這樣就不必另外定義一個 scope class, 適用於較簡單的 global scope # Removing Global Scopes以下的 Laravel example code 的意思是？ Example:&lt;?phpUser::withoutGlobalScope(AgeScope::class)-&gt;get(); Answer:從當次 query 的結果中, 移除 AgeScope 這個 global scope constraints 以下的 Laravel example code 的意思是？ Example:&lt;?phpUser::withoutGlobalScope(&#x27;age&#x27;)-&gt;get(); Answer:從當次 query 的結果中, 移除 age 這個 global scope constraints, age 為 closure 方式直接在 model 的 booted method 中定義的 以下的 Laravel example code 的意思是？ Example:&lt;?phpUser::withoutGlobalScopes()-&gt;get();User::withoutGlobalScopes([ FirstScope::class, SecondScope::class])-&gt;get(); Answer:&lt;?php// 從當次 User model 的 query 當中移除所有 global scopesUser::withoutGlobalScopes()-&gt;get();// 從當次 User model 的 query 當中移除 array 中的 global scopeUser::withoutGlobalScopes([ FirstScope::class, SecondScope::class])-&gt;get(); # Local Scopes以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function scopePopular($query) &#123; return $query-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100); &#125; public function scopeActive($query) &#123; return $query-&gt;where(&#x27;active&#x27;, 1); &#125;&#125; Answer:定義 local scope, 簡單來說, 當我使用 $query-&gt;popular() 就會等於 $query-&gt;where(‘votes’, ‘&gt;’, 100), 而 $query-&gt;active() 便會等於 $query-&gt;where(‘active’, 1) # Utilizing Local Scope以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function scopePopular($query) &#123; return $query-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100); &#125; public function scopeActive($query) &#123; return $query-&gt;where(&#x27;active&#x27;, 1); &#125;&#125;$users = App\\Models\\User::popular()-&gt;active()-&gt;orderBy(&#x27;created_at&#x27;)-&gt;get(); Answer:popular() 以及 active() 為 local scope, 會使用定義於該 local scope 內 query 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function scopePopular($query) &#123; return $query-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100); &#125; public function scopeActive($query) &#123; return $query-&gt;where(&#x27;active&#x27;, 1); &#125;&#125;$users = App\\Models\\User::popular()-&gt;orWhere(function (Builder $query) &#123; $query-&gt;active();&#125;)-&gt;get(); Answer:相當於 $query-&gt;where(...)-&gt;orWhere(...) constraints, 只不過對象換成了 local scope, 像是 $query-&gt;popular()-&gt;orActive(), 注意後者語法只是比喻, Laravel 目前沒有提供這樣的用法, 也可使用 orWhere-&gt; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function scopePopular($query) &#123; return $query-&gt;where(&#x27;votes&#x27;, &#x27;&gt;&#x27;, 100); &#125; public function scopeActive($query) &#123; return $query-&gt;where(&#x27;active&#x27;, 1); &#125;&#125;$users = App\\Models\\User::popular()-&gt;orWhere-&gt;active()-&gt;get(); Answer:相當於 $query-&gt;where(...)-&gt;orWhere(...) constraints, 只不過對象換成了 local scope, 像是 $query-&gt;popular()-&gt;orActive(), 注意後者語法只是比喻, Laravel 目前沒有提供這樣的用法, 也可使用 closure 方式帶入 orWhere() # Dynamic Scopes以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function scopeOfType($query, $type) &#123; return $query-&gt;where(&#x27;type&#x27;, $type); &#125;&#125;$users = App\\Models\\User::ofType(&#x27;admin&#x27;)-&gt;get(); Answer:dynamic scopes 概念, 可以動態的帶入參數到 scope 內, 所以 User::ofType(&#39;admin&#39;)-&gt;get(), 就相當於 User::where(&#39;type&#39;, &#39;admin&#39;)-&gt;get() # Comparing Models以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($post-&gt;is($anotherPost)) &#123; //&#125; Answer:比較兩個 model 是否有相同的 primary_key, table, database connection 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($post-&gt;author()-&gt;is($user)) &#123; //&#125; Answer:比較 $post model 的 author relation model 是否跟 $user model 有相同的 primary_key, table, database connection # EventsLaravel Eloquent Model 中, retrieved event 什麼時候會被觸發？當有一個現存 model 從 database 被 retrieve 時 Laravel Eloquent Model 中, creating/created event 什麼時候會被觸發？當一個 model 第一次被儲存在資料庫時, 只有第一次會觸發 Laravel Eloquent Model 中, updating/updated event 什麼時候會被觸發？當現存的 model 被更新且呼叫 save() Laravel Eloquent Model 中, saving/saved event 什麼時候會被觸發？當 model 被建立或更新都會觸發 # Using Closures以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected static function booted() &#123; static::created(function ($user) &#123; // &#125;); &#125;&#125; Answer:使用 closure 來定義當 created model event 被觸發後所做的事 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;use function Illuminate\\Events\\queueable;class User extends Model&#123; protected static function booted() &#123; static::created(queueable(function ($user) &#123; // &#125;)); &#125;&#125; Answer:使用 closure 來定義當 created model event 被觸發後所做的事, 並 queue 被觸發的 closure listener # Observers以下的 Laravel example command 的意思是？ Example:php artisan make:observer UserObserver --model=User Answer:建立一個 observer, 名為 UserObserver, 對應的 model 為 User model, 可定義一系列 User model 的各種 model event 的 Listener 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Observers;use App\\Models\\User;class UserObserver&#123; public function created(User $user) &#123; // &#125; public function updated(User $user) &#123; // &#125; public function deleted(User $user) &#123; // &#125; public function forceDeleted(User $user) &#123; // &#125;&#125; Answer:&lt;?phpnamespace App\\Observers;use App\\Models\\User;class UserObserver&#123; // 當 created model event 被觸發後要做的事 public function created(User $user) &#123; // &#125; // 當 updated model event 被觸發後要做的事 public function updated(User $user) &#123; // &#125; // 當 deleted model event 被觸發後要做的事 public function deleted(User $user) &#123; // &#125; // 當 forceDeleted model event 被觸發後要做的事 public function forceDeleted(User $user) &#123; // &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use App\\Observers\\UserObserver;use App\\Models\\User;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; User::observe(UserObserver::class); &#125;&#125; Answer:在 AppServiceProvider 中註冊 UserObserver, 註冊後 UserObserver 後, 定義於 UserObserver 的 Listener 會開始監聽 User model event # Muting Events以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;$user = User::withoutEvents(function () use () &#123; User::findOrFail(1)-&gt;delete(); return User::find(2);&#125;); Answer:withoutEvent method 只接受 closure 為參數, 在這個 closure 內執行的任何 code 都不會觸發 model event範例中刪除 primary key 為 1 的 User model, 但不會觸發任何 model event # Saving A Single Model Without Event以下的 Laravel example code 的意思是？ Example:&lt;?php$user = User::findOrFail(1);$user-&gt;name = &#x27;Victoria Faith&#x27;;$user-&gt;saveQuietly(); Answer:修改 primary key 為 1 的 User model, 且不觸發任何 model event # Additional在 Laravel 中, 如何得到與該 model 相關的 table 的名字?model-&gt;getTable()// string","link":"/zh-tw/laravel-eloquent-orm-getting-started/"},{"title":"Laravel - Eloquent ORM - Mutators","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Accessors &amp; Mutators# Defining An Accessor以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function getFirstNameAttribute($value) &#123; return ucfirst($value); &#125;&#125; Answer:定義一個 accessor當我使用 Eloquent Model 取得 first_name attribute 時,將 string 的第一個字符轉為大寫, 所以完成定義後, 當我使用 $user-&gt;first_name;, 會自動將原本的 value 第一個字符轉為大寫 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function getFullNameAttribute()&#123; return &quot;&#123;$this-&gt;first_name&#125; &#123;$this-&gt;last_name&#125;&quot;;&#125; Answer:定義一個 accessorfull_name 是一個 computed value, 來源來自 first_name 以及 last_name column, 所以當我使用 $user-&gt;full_name 時, 會自動取得 accessor 中定義的值由於 full_name 並不存在於 table 中, 因此當我回傳整個 model 時並不會出現 full_name 這個 attribute, 可透過 append() 達成 # Defining A Mutator以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function setFirstNameAttribute($value) &#123; $this-&gt;attributes[&#x27;first_name&#x27;] = strtolower($value); &#125;&#125; Answer:定義一個 mutator當我們定義一個 model 的 attribute 時, mutator 會自動地呼叫 mutator, 對 attribute 進行操控以此 example 來說, 如果我使用 $user-&gt;first_name = &#39;Sally&#39;;, 那就會自動將 Sally 轉成小寫, 這實在 Eloquent Model 中 first_name 會是 sally # Date MutatorsLaravel 中, 預設 Eloquent 會將 created_at 以及 updated_at 轉成哪一個 class 的 instance?Carbon 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $dates = [ &#x27;seen_at&#x27;, ];&#125; Answer:定義一個 date mutator, 會將 seen_at column 預設轉換為 Carbon instance 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = App\\Models\\User::find(1);$user-&gt;deleted_at = now();$user-&gt;save(); Answer:將 deleted_at 的時間變為現在時間, 預設時區使用 Laravel 時區 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = App\\Models\\User::find(1);return $user-&gt;deleted_at-&gt;getTimestamp(); Answer:將 deleted_at 使用 Carbon class 的 getTimestamp() 轉成 timestamp 格式 # Data Formats以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class Flight extends Model&#123; protected $dateFormat = &#x27;U&#x27;;&#125; Answer:Laravel 預設的 timestamps 格式為 &#39;Y-m-d H:i:s, 這也是會存在資料庫中的格式, 如果要自定義的話, 可以再 model 中的 $dateFormat property 自定義 # Attribute CastingLaravel Model Attribute Casting 支援哪些 type？ integer real float double decimal: string boolean object array collection date datetime timestamp encrypted encrypted:object encrypted:array encrypted:collection 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $casts = [ &#x27;is_admin&#x27; =&gt; &#x27;boolean&#x27;, ];&#125; Answer:假如資料庫存的是 0,1, $cast method 會在取得資料後自動將其轉成 boolean Laravel Model Attribute Casting 可以 cast null 嗎？不可 # Custom Casts以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Casts;use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;class Json implements CastsAttributes&#123; public function get($model, $key, $value, $attributes) &#123; return json_decode($value, true); &#125; public function set($model, $key, $value, $attributes) &#123; return json_encode($value); &#125;&#125; Answer:&lt;?phpnamespace App\\Casts;use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;// 定義一個 custom castclass Json implements CastsAttributes&#123; // get 代表如何將資料庫中取得的資料進行轉換 public function get($model, $key, $value, $attributes) &#123; // 將資料庫取得的資料從 json 轉成 associatibe array return json_decode($value, true); &#125; // set 代表如何將資料轉換成適合存進資料庫的形式 public function set($model, $key, $value, $attributes) &#123; // 將要存進資料庫的資料轉成 json 格式 return json_encode($value); &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use App\\Casts\\Json;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $casts = [ &#x27;options&#x27; =&gt; Json::class, ];&#125; Answer:在定義了 custom cast class 之後, 使用 User model 的 $cast property 來使用這個 custom cast class # Value Object Casting以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Casts;use App\\Models\\Address as AddressModel;use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;use InvalidArgumentException;class Address implements CastsAttributes&#123; public function get($model, $key, $value, $attributes) &#123; return new AddressModel( $attributes[&#x27;address_line_one&#x27;], $attributes[&#x27;address_line_two&#x27;] ); &#125; public function set($model, $key, $value, $attributes) &#123; if (! $value instanceof AddressModel) &#123; throw new InvalidArgumentException(&#x27;The given value is not an Address instance.&#x27;); &#125; return [ &#x27;address_line_one&#x27; =&gt; $value-&gt;lineOne, &#x27;address_line_two&#x27; =&gt; $value-&gt;lineTwo, ]; &#125;&#125; Answer:&lt;?phpnamespace App\\Casts;use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;use InvalidArgumentException;// 此為 value object casting// 比方說, 我們在 User model 的 $cast property 定義 [&#x27;address&#x27; =&gt; App\\Casts\\Address], 再到 App\\Models 下建立一個 Address model// App\\Models\\Address class 為我們實際上要操作的 value object, 而當前這個 class 是這個 value object 與 User model 之間的 caster// 當我使用 $user-&gt;address 時, 實際上便會呼叫當前 class 的 get(), 從 DB 中將資料帶入 App\\Models\\Address 這個 class 中// 而當使用 $user-&gt;address-&gt;lineOne = &#x27;123&#x27;, $user-&gt;save() 時, 則會呼叫 set(), 將 object 中的 property insert 到資料庫中的欄位class Address implements CastsAttributes&#123; // $model 代表呼叫 Address 的 model, $user-&gt;address, model 就是 $user // $key 代表 address // $value 代表 address 的 value // $attribute 代表 raw data, 即 DB 中的 column public function get($model, $key, $value, $attributes) &#123; // 從 DB 中取出 &#x27;address_line_one&#x27;, &#x27;address_line_two&#x27;, 並 assign 到 Address object 中的 lineOne, 及 lineTwo property // 若 property 數量大於 attribute, 則會噴錯 return new Address( $attributes[&#x27;address_line_one&#x27;], $attributes[&#x27;address_line_two&#x27;] ); &#125; public function set($model, $key, $value, $attributes) &#123; if (! $value instanceof Address) &#123; throw new InvalidArgumentException(&#x27;The given value is not an Address instance.&#x27;); &#125; // 將 $value-&gt;lineOne 以及 lineTwo 儲存到資料庫的 address_line_one, address_line_two column return [ &#x27;address_line_one&#x27; =&gt; $value-&gt;lineOne, &#x27;address_line_two&#x27; =&gt; $value-&gt;lineTwo, ]; &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Casts;use App\\Models\\Address as AddressModel;use Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;use InvalidArgumentException;class Address implements CastsAttributes, SerializesCastableAttributes;&#123; public function serialize($model, string $key, $value, array $attributes) &#123; return (string) $value; &#125;&#125; Answer: short: 讓 custom cast class 可以 serialize object 或 JSONlong: 當使用 toArray method 來將 Eloquent model 轉成 array 或 JSON 時, custom cast value objects 將會被 serialize 如果有 implement Arrayable 或 JsonSerializable interface 的話。 然而, 當使用第三方 library 提供的 value objects 時, 可能無法在這些 object 上 implement 這些 interface, 因此可在 custom cast class implement SerializesCastableAttributes interface, 並新增 serialize method # Inbound Casting以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Casts;use Illuminate\\Contracts\\Database\\Eloquent\\CastsInboundAttributes;class Hash implements CastsInboundAttributes&#123; protected $algorithm; public function __construct($algorithm = null) &#123; $this-&gt;algorithm = $algorithm; &#125; public function set($model, $key, $value, $attributes) &#123; return is_null($this-&gt;algorithm) ? bcrypt($value) : hash($this-&gt;algorithm, $value); &#125;&#125; Answer:如果 custom cast 的作用範圍只限定於將要存進資料庫的資料作轉換, 但從資料庫取出資料時並不另外轉換, 在這樣的情況話, 就可以使用 inbound custom cast需 implement CastsInboundAttributes interface, 以及只需 set method 即可 # Cast Parameters以下的 Laravel example code 的意思是？ Example:&lt;?phpclass User extends Authenticatable;&#123; protected $casts = [ &#x27;secret&#x27; =&gt; Hash::class.&#x27;:sha256&#x27;, ];&#125; Answer:將 parameter “sha256” 帶入 custom cast class “Hash” # Castables以下的 Laravel example code 的意思是？ Example:&lt;?phpclass User extends Authenticatable;&#123; protected $casts = [ &#x27;address&#x27; =&gt; \\App\\Models\\Address::class.&#x27;:argument&#x27;, ];&#125;class Address implements Castable&#123; public static function castUsing(array $arguments) &#123; return AddressCast::class; &#125;&#125; Answer:&lt;?php// 這是實作 cast value object 的另外一種方式, 個人覺得這種方式比較直觀class User extends Authenticatable;&#123; // 除了指定為 custom cast class 之外, 也可以直接指定要操作的 cast value object class // 需注意的是, 後面的 argument 會被 pass 到 custom cast class, 而不是 cast value object class protected $casts = [ &#x27;address&#x27; =&gt; \\App\\Models\\Address::class.&#x27;:argument&#x27;, ];&#125;// 而在 cast value object class 中, 要 implement Castable interfaceclass Address implements Castable&#123; // 並且, 要定義一個 castUsing method, 指定使用哪一個 custom cast class public static function castUsing(array $arguments) &#123; return AddressCast::class; &#125;&#125; # Array &amp; JSON Casting以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; protected $casts = [ &#x27;options&#x27; =&gt; &#x27;array&#x27;, ];&#125;$user = App\\Models\\User::find(1);$options = $user-&gt;options;$options[&#x27;key&#x27;] = &#x27;value&#x27;;$user-&gt;options = $options;$user-&gt;save(); Answer:如果 DB 內的內容是 JSON 或 TEXT 的話, 可以使用 array type, 當從資料庫取出資料時, 會自動轉成 PHP array, 而將 array 存進資料庫時, 則會自動轉成 JSON 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = App\\Models\\User::find(1);$user-&gt;update([&#x27;options-&gt;testKey&#x27; =&gt; &#x27;testValue&#x27;]); Answer:更新 JSON column 中的 key 為 ‘testKey’ 的 value 更新為 ‘testValue’ # Date Casting以下的 Laravel example code 的意思是？ Example:&lt;?phpprotected $casts = [ &#x27;created_at&#x27; =&gt; &#x27;datetime:Y-m-d&#x27;,]; Answer:雖說 created_at 預設就會被 cast 成 datetime type, 但還可以特別指定格式當 model 被 serialized 成 array 或 JSON 時, 會使用這個格式 # Query Time Casting以下的 Laravel example code 的意思是？ Example:&lt;?php$users = User::select([ &#x27;users.*&#x27;, &#x27;last_posted_at&#x27; =&gt; Post::selectRaw(&#x27;MAX(created_at)&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;)])-&gt;withCasts([ &#x27;last_posted_at&#x27; =&gt; &#x27;datetime&#x27;])-&gt;get(); Answer:在 query 的過程中, 將 ‘last_posted_at’ 轉成 datetime type, 即 carbon instance, 若不使用 withCasts, 則 last_posted_at 會是一個 raw string, 如下 example&lt;?php$users = User::select([ &#x27;users.*&#x27;, &#x27;last_posted_at&#x27; =&gt; Post::selectRaw(&#x27;MAX(created_at)&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;)])-&gt;withCasts([ &#x27;last_posted_at&#x27; =&gt; &#x27;datetime&#x27;])-&gt;get();$last_posted_at = $users-&gt;first()-&gt;last_posted_at;// 若不使用 cast, 是無法使用 Carbon class year property 的dd($last_posted_at-&gt;year);","link":"/zh-tw/laravel-eloquent-orm-mutators/"},{"title":"Laravel - 高併發","text":"# 前言紀錄一下 5000 RPS 併發的專案架構 # 部署全套架構 # AMI 製作啟動一台 instance, 安裝必要環境, 視需求可參考 Laravel 部署 # 前端專案部署在 AWS S3 上, 並使用 CloudFront 來 cache 靜態檔案整個架構大概是 CI/CD 將專案部署到 s3, CloudFront 建立從 s3 取得資源, 並 cache, 將 domain map 到 CloudFront 分佈的 domain # s3 設定 建立一個 bucket, 並從屬性設定靜態網站託管 取消封鎖公開存取 儲存貯體政策定義, 讓 bucket 可被存取, 但僅限特定的 referer &#123; &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Id&quot;: &quot;http referer policy example&quot;, &quot;Statement&quot;: [ &#123; &quot;Sid&quot;: &quot;Allow get requests originating from www.example.com and example.com.&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: &quot;*&quot;, &quot;Action&quot;: [ &quot;s3:GetObject&quot;, &quot;s3:GetObjectVersion&quot; ], &quot;Resource&quot;: &quot;arn:aws:s3:::貯體名稱/*&quot;, &quot;Condition&quot;: &#123; &quot;StringLike&quot;: &#123; &quot;aws:Referer&quot;: &quot;設定在 cloud front 的 referer value&quot; &#125; &#125; &#125; ]&#125; cors 設定, 若有使用 CloudFront, 可直接設定在 CloudFront。 若不特別定義, s3 針對 option request 的 response, 不會帶著 Access-Control-Allow-origin 相關的 header, 直接的結果是, 當瀏覽器使用非簡單請求時, 就會被 cors block [ &#123; &quot;AllowedHeaders&quot;: [ &quot;*&quot; ], &quot;AllowedMethods&quot;: [ &quot;GET&quot; ], &quot;AllowedOrigins&quot;: [ &quot;*&quot; ], &quot;ExposeHeaders&quot;: [] &#125;] # CloudFront 來源網域輸入 s3 static site url 名稱隨便 新增自訂標頭, 這邊新增一個 key 為 Referer, value 自訂的 header, 主要是讓 s3 識別用, 這樣可以阻擋一部分 非 CloudFront 對 s3 所發出的請求 回應標頭政策, 可加入 CORS, 不然就是要在 s3 處做設定 針對 error 404, 一律導向 index.html 若專案有更新, 都需 invalidate cache, 手動的話可從 console 操作, CI/CD 的話需呼叫 AWS API 若要使用 HTTPS, 可使用 ACM 來取得憑證, 用於 CloudFront 的憑證是有限制區域的, 僅限於 us-east-1 的 ACM 使用 ACM, 替我們擁有的 domain 取得憑證, 需要在 dns 管理介面 (看 domain 在哪買的) 輸入 ACM 產生的 key / value 來成功驗證, 驗證成功後即取得憑證 建立分佈後, 在 dns 管理介面建立 cname, 將特定 domain 導向此分佈產生的 domain, 注意憑證須事先設定好, 否則 HTTPS 無法導向 # 後端# DB 使用 console 建立 DB 使用生產環境 SSD 大小關係到 IOPS, 最高級的可使用佈建式 EBS, 若是一般的 SSD, 約 1 GB = 3 IOPS, 所以 SSD 越大, IOPS 越高, 可視實際用量調整 備份時間設定在半夜 是否備庫取決於專案形式, 主要就是預算以及需求 可自訂 security group, 需開通 port 3306 可傳入, 否則會連不上資料庫 可自訂 parameter group, 這是修改 MySQL 參數的唯一方法 可自訂登入預設使用者 &amp; password, 以供 APP 存取 為安全性, 可設為非公開, 再透過 AWS 機器連進去 記得匯出日誌 # DB proxy 使用 proxy 的目的, 是為了隊列 connection, 因為 RDS 的 max_connection 是有限的, 且依據每一種規格的 max_connection 會有所不同, 是根據 memory / 某個數 來定義的, 可到 default parameter group 去看 代理的運作原理, 是代替 DB 在 DB 之前 proxy, 發給 DB 定義的 connection 數量, 並把超出的隊列 建立代理前, 需要先使用 secret manager 來建立新的 secret, secret 的內容為存取 DB 的 account &amp; password 可參考這篇文件 來建立 proxy 有一點要注意, 由於是 client 連到 proxy, 在連到 DB, 所以 proxy 的 security group inbound 會是允許 EC2 來源的 3306, 而 DB 的 security group inbound 會是允許 proxy 來源的 3306, 所以這邊會有兩個 security group, 一個是 proxy, 一個是 DB, 文件裡沒寫到, 照文件的 security group 配置會失敗 # Redis 使用 Elasticache console 建立 可定義 security group, 需允許 6379 port, 否則會連不上 若資料較不敏感, 不需使用加密, 不管是靜態加密或傳輸加密, 畢竟加密就會對性能造成影響 若使用傳輸加密, 可自訂 auth 字串, 在 Laravel 的 .env 會像是這樣 REDIS_HOST=tls://redis 終端節點 REDIS_PASSWORD=auth字串, 若無傳輸加密可留空 # EC2 基本上就是開一台乾淨的機器, 將專案會需要用到的環境安裝上去, 然後建立 AMI # AMI 相較於啟動範本, AMI 像是硬碟中的資料, 跟硬體無關, 像是機器規格, 安全群組, 硬碟空間大小 # 啟動範本 相較於 AMI, 啟動範本可以指定 AMI, 然後定義其他資訊, 像是機器規格, 安全群組, 硬碟空間大小 用於 auto scalling 啟動機器的依據, 需先建立好 AMI 可選auto scalling 指引, 會提示哪些選項須留空, 哪邊為必填 如果想從現存的範本複製一份, 可指定來源範本 需指定是先建立好的 AMI 最重要的當屬 使用者資料, 機器會再啟動後執行 使用者資料 當中的 script, 目的是讓你的專案可以在機器啟動後達到 ready to service 的狀態 可為範本定義一個 security group # security group AWS 幾乎每種服務都可為其定義 security group default security group 無法刪除 若要限制特定來源的 port, 比如說, 我只允許來自於 LB 的 80 port 的 request, 那麼除了定義 port 之外, 可將來源定義成該 LB 的 security gruop # target group 可將複數的 instance 註冊到同一個 target group, 亦可稱為 instance group 可接收來自於 LB 的 request # LB 將來自於 Internet 的 request 導向後方的 target group 可設定 LB 將特定條件的 source 導向特定的 target group LB 與 target group 的 protocol 必須一致, 即兩者要嘛都 HTTP, 要嘛都 TCP, 或其他相同的 protocol 當使用 HTTPS 時, 憑證可使用 ACM 來取得, 同 CloudFront 的 ACM 設定, 但 LB 的 ACM 不局限於 us-east-1 地區 在 DNS 管理介面, 將特定的 domain name cname 到 LB 產生的 domain name, 若 LB 支援 HTTPS 且 request 為 HTTPS, 則 LB 上設定的憑證的 domain name, 需與發出 HTTPS request 的 domain name 相符 可從 listener =&gt; rule 將特定的來源導向不同的 target group, 可定義多個 target group 以及多種 rule 可設定 log, 並將其匯出到 s3, s3 bucket 可不必事先建立, 設定 log 匯出時選擇自動建立 s3 bucket 即可 # auto scalling policy 當我們已經定義好啟動範本, 就可以定義 auto scalling policy 來自動根據情境 scale instance, 並且使用啟動範本來啟動 instance 可根據機器的使用率來決定是否 scale, 也可單純手動控制所需數量 可在建立時, 指定要套用的 LB, 選擇該 LB 下的 target group 當健康檢查未通過時, auto scaling policy 會自動關掉 unhealthy instance 並且啟動新的, 可設定新的 instance 啟動後, 過多久時間開始做健康檢查, 以避免啟動耗時較久的啟動範本, 還沒啟動好就被關掉了 # CloudWatch 在機器上安裝 cloud watch agent, 可以非同步的將指定的 log 檔定時輸出到 AWS CloudWatch, 只有一台機器時用不到, 但若 LB 架構, 可能會有多台機器的話就必要 使用 cloud watch agent, 而不是直接使用 cloud watch sdk 的原因是, 使用 sdk 由於是在程式端進行 log 串流, 會影響 response time, 若是跑 qeueue 可以解決這個問題, 但必須要額外設定 worker 去跑, 所以倒不如直接使用 agent 跑 backgroud process 來的單純 首先要先安裝 cloud watch agent, 參考 文件 config 可以自動生成預設的, 也可以手動增加, 為了後續可以即時地透過 Git 來對 config 做版本控制並且更新, 我是採手動的, 可參考 文件 example 大概像是這樣, 可安裝後, 輸入 command amazon-cloudwatch-agent-ctl 獲取各種參數以及用法, 像是 $cloudAgentCtl -a fetch-config -m ec2 -c file:$cloudWatchAgentConfigFile -s, 這樣就是讀取指定位置的 config, 並且重啟, 類行為 ec2 &#123; &quot;agent&quot;: &#123; &quot;logfile&quot;: &quot;/var/log/cloud-watch-agent/cloud-watch-agent.log&quot; &#125;, &quot;logs&quot;: &#123; &quot;logs_collected&quot;: &#123; &quot;files&quot;: &#123; &quot;collect_list&quot;: [ &#123; &quot;file_path&quot;: &quot;/var/www/fun-marketing-backend/storage/logs/laravel-*.log&quot;, &quot;log_group_name&quot;: &quot;fun-marketing-pro&quot;, &quot;log_stream_name&quot;: &quot;backend-api-default&quot;, &quot;timezone&quot;: &quot;UTC&quot;, &quot;multi_line_start_pattern&quot;: &quot;^\\\\[\\\\d&#123;4&#125;\\\\-\\\\d&#123;2&#125;\\\\-\\\\d&#123;2&#125; \\\\d&#123;2&#125;:\\\\d&#123;2&#125;:\\\\d&#123;2&#125;\\\\].*$&quot; &#125;, &#123; &quot;file_path&quot;: &quot;/var/www/fun-marketing-backend/storage/logs/grabRedEnvelope-*.log&quot;, &quot;log_group_name&quot;: &quot;fun-marketing-pro&quot;, &quot;log_stream_name&quot;: &quot;backend-api-grab-red-envelope&quot;, &quot;timezone&quot;: &quot;UTC&quot;, &quot;multi_line_start_pattern&quot;: &quot;^\\\\[\\\\d&#123;4&#125;\\\\-\\\\d&#123;2&#125;\\\\-\\\\d&#123;2&#125; \\\\d&#123;2&#125;:\\\\d&#123;2&#125;:\\\\d&#123;2&#125;\\\\].*$&quot; &#125; ] &#125; &#125;, &quot;log_stream_name&quot;: &quot;default&quot;, &quot;force_flush_interval&quot;: 15 &#125;&#125; 細節設定檔部分, 可參考你自己寫的 fun-marketing 專案, 大概流程是 push 到 gitlab, 然後 觸發 git runner, 呼叫 codedeploy api, 然後 codedeploy 將 cloud agent config 部署到機器上, 最後 重啟 cloud agent # CodeDeploy 因為使用 AWS 全套服務, CodeDeploy 在一定用量內的話, 基本上可以說是免費的 另外就是, 因為專案是 LB 架構, 需要同時部署到多台機器上, 是以 target group 為單位來部署的, 因此使用 AWS CodeDeploy 會相對單純很多 首先, 先從 console 去建立一個應用程式 這邊看是使用哪種平台, 這個專案是使用 EC2 內部部署的, 簡單來說就是部署對象是 EC2 機器 需建立一個 service role 讓 code deploy process 使用, 可以直接建立一個 service role, 然後綁 AWS CodeDeploy 預設的 role 就可 可以選擇 Auto scalling 群組, EC2 執行個體, 以及 現場部署執行個體 來作為部署目標, 可多選而非則一 現場部署的官方解釋是 An on-premises instance is any physical device that is not an Amazon EC2 instance that can run the CodeDeploy agent and connect to public AWS service endpoints., 這是他跟一般 EC2 部署的差異 Auto scalling 群組會出現你已經建立的群組給你選 EC2 執行個體, 可以指定 tag 現場部署執行個體也是指定 tag, 但這個 tag 要自己到機器上去下指令定義, 然後才能獲取 tag 部署類型可使用就地或藍綠, 藍綠部署主要是利用 LB 多台機器的機制, 新的開起來後再馬上切過去, 然後再關掉舊的, 可以某層面上做到 zero downtime (在不談到 DB 的情況下), 就地部署則是不管三七二十一直接給你部署下去, fun-marketing 專案我在部署 script 有使用特別的方法, 也是會先把新的專案部署好, 再切換過去, 所以在 code deploy 這邊就使用就地部署 承上, 由於已經做到 zero downtime, 所以直接就使用 AllAtOnce 組態 可以讓負載平衡器在部署時, 阻擋流量, 等到部署完畢再放行流量, 由於在機器上已做到 zero downtime, 所以這邊就沒特別阻擋, 只是說應該上版時, 要選在人少的時候上版, 總不可能在尖峰時段上版吧 QQ # CodeDeploy Notification 在每次部署時, 發送通知到 Slack channel 先到 AWS Chatbot config new client, 具體可參考這篇文件, 文件中的 guardrail 可以先隨便選一個, 等到建立完成後再編輯, 因為 guardrail 主要是界定一個權限範圍, 會需要輸入一個 policy, 而照文件上, 會使用 policy template 來建立, 所以在成功建立 chatbot 的同時, 一個預設 notification only 的 policy 也會被建立, 可被用在 guardrail 建立 chatbot 時, SNS topic 先不用定義, 在我們建立通知規則時, 將 chatbot 作為 notification target 時, AWS 會自動建立對應的 SNS topic 建立完 chatbot 之後, 參考這篇文件 建立 notification rule, 把上面建立的 chatbot 作為目標, 這樣 SNS topic 就會自動被建立 最後, 到 chatbot 處 sens test message 看看 channel 是否能收到 test message","link":"/zh-tw/laravel-high-concurrency/"},{"title":"Laravel - Frontend - Blade Templates (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Template Inheritance# Defining A Layout以下的 Laravel example code 的意思是？ Example:&lt;!-- Stored in resources/views/layouts/app.blade.php --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;App Name - @yield(&#x27;title&#x27;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section(&#x27;sidebar&#x27;) This is the master sidebar. @show &lt;div class=&quot;container&quot;&gt; @yield(&#x27;content&#x27;) &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Answer:&lt;!-- stored in resources/views/layouts/app.blade.php --&gt;&lt;html&gt; &lt;head&gt; &lt;!-- 此 app file 可作為 layout file 讓其他 file extends --&gt; &lt;!-- 假設, 當 child file extends app file 時, child file --&gt; &lt;!-- 會有 app.file 上的所有內容, 那如果我想要在 child file 特定的位置加入 --&gt; &lt;!-- 一些只屬於 child file 的 code, 那便可以使用 @yield 事先在 app file --&gt; &lt;!-- 如下 example, 當我在 child file 使用 @section(&#x27;title&#x27;) --&gt; &lt;!-- 那我就可以在 @yield 定義的位置, 加入只屬於 child file 的 code --&gt; &lt;title&gt;app name - @yield(&#x27;title&#x27;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @section(&#x27;sidebar&#x27;) this is the master sidebar. &lt;!-- @show 等於 @endsction 之後, 在 @yield(&#x27;sidebar&#x27;) --&gt; @show &lt;div class=&quot;container&quot;&gt; &lt;!-- 將此位置定義為 &#x27;content&#x27;, 所有 extends app file 的 view --&gt; &lt;!-- 都可以使用 @section(&#x27;content&#x27;) 加入該 view 需要的 code --&gt; @yield(&#x27;content&#x27;) &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; # Extending A Layout以下的 Laravel example code 的意思是？ Example:&lt;!-- Stored in resources/views/child.blade.php --&gt;@extends(&#x27;layouts.app&#x27;)@section(&#x27;title&#x27;, &#x27;Page Title&#x27;)@section(&#x27;sidebar&#x27;) @parent &lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;@endsection@section(&#x27;content&#x27;) &lt;p&gt;This is my body content.&lt;/p&gt;@endsection Answer:&lt;!-- Stored in resources/views/child.blade.php --&gt;&lt;!-- extends layouts.app file, 因此會使用 app file 的所有佈局 --&gt;@extends(&#x27;layouts.app&#x27;)&lt;!-- @yield 會定義在 layout file 的位置, 而 @section --&gt;&lt;!-- 可以指定要在哪個 yield 的位置插入 code, 這些 code 會被 --&gt;&lt;!-- render 在 child page, arg2 為縮寫, 直接輸入要插入的 code --&gt;&lt;!-- 並省略掉 @endsection --&gt;@section(&#x27;title&#x27;, &#x27;Page Title&#x27;)&lt;!-- 如果沒有 @parent, 則會 render child page 的 section 內的 code --&gt;&lt;!-- @parent 可使 layout page section 內的 code 不被覆蓋, 達到 append 的效果 --&gt;@section(&#x27;sidebar&#x27;) @parent &lt;p&gt;This is appended to the master sidebar.&lt;/p&gt;@endsection&lt;!-- 在 layout page @yield(&#x27;content&#x27;) 的位置插入以下的 code --&gt;@section(&#x27;content&#x27;) &lt;p&gt;This is my body content.&lt;/p&gt;@endsection 以下的 Laravel example code 的意思是？ Example:@yield(&#x27;content&#x27;, View::make(&#x27;view.name&#x27;)) Answer:定義此位置為 &#39;content&#39;, 並定義預設值為 &#39;view.name&#39; page, 所以 extends 此 example 的 child page 都可以使用 @section(&#39;content&#39;) 在此位置插入 code, 如果 child page 沒有定義 @section(&#39;content&#39;) 的話, 則使用預設值 &#39;view.name&#39; page 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;blade&#x27;, function () &#123; return view(&#x27;child&#x27;);&#125;); Answer:當收到 Request to url ‘blade’, 回傳 ‘child’ view, 可以是一個 blade view # Displaying Data以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;greeting&#x27;, function () &#123; return view(&#x27;welcome&#x27;, [&#x27;name&#x27; =&gt; &#x27;Samantha&#x27;]);&#125;); Answer:當收到 Request 5o ‘greeting’ uri, 回傳 ‘welcome’ view page, 並帶著 [&#39;name&#39; =&gt; &#39;Samantha&#39;], 並在 view page 可以 display ‘name’ Hello, &#123;&#123; $name &#125;&#125; 以下的 Laravel blade example code 的意思是？ Example:The current UNIX timestamp is &#123;&#123; time() &#125;&#125;. Answer:使用 blade 語法, 可以在 &#123;&#123; &#125;&#125; 內執行任何 PHP function # Displaying Unescaped Data以下的 Laravel blade example code 的意思是？ Example:Hello, &#123;!! $name !!&#125;. Answer:blade 語法 &#123;&#123; &#125;&#125; 預設會執行 PHP 的 htmlspecialchars method, 若不希望資料經過 escaped, 可以使用 &#123;!! !!&#125; # Rendering JSON以下的 Laravel blade example code 的意思是？ Example:&lt;script&gt; var app = @json($array); var app = @json($array, JSON_PRETTY_PRINT);&lt;/script&gt; Answer:blade 語法, @json() 相當於 json_encode(), 預設使用 JSON_HEX_TAG, JSON_HEX_APOS, JSON_HEX_AMP, JSON_HEX_QUOT flags # HTML Entity Encoding以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Blade;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123; public function boot() &#123; Blade::withoutDoubleEncoding(); &#125;&#125; Answer:Blade 預設會 double encode HTML entities, 若要關閉 double encoding, 可在 AppServiceProvider 的 boot() 中, 使用 Blade 的 withoutDoubleEncoding() # Blade &amp; JavaScript Frameworks以下的 Laravel blade example code 的意思是？ Example:&lt;h1&gt;Laravel&lt;/h1&gt;Hello, @&#123;&#123; name &#125;&#125;. Answer:許多 JavaScript 框架也會用到 &#123; &#125; 符號來表示某些語法, 可使用 @ 來告訴 Blade 不需對 &#123;&#123; &#125;&#125; 內的內容做任何動作, 讓他們可以被 JS framework 解析 以下的 Laravel blade example code 的意思是？ Example:&#123;&#123;-- Blade --&#125;&#125;@@json()&lt;!-- HTML output --&gt;@json() Answer:@json() 本是 Blade 的一個 function, 可使用 @ 來 escape Blade 語法, 所以在 HTML 上的輸出會是 @json() # The @verbatim Directive以下的 Laravel blade example code 的意思是？ Example:@verbatim &lt;div class=&quot;container&quot;&gt; Hello, &#123;&#123; name &#125;&#125;. &lt;/div&gt;@endverbatim Answer:由於許多 JS Framework 也會使用 &#123;&#123; &#125;&#125; 來解析變數或一些語法, 如果 Blade page 內有許多的 &#123;&#123; &#125;&#125; 都是要讓 JS Framework 來解析的話, 可以寫在 @verbatim directive 內 # Control Structures# If Statements以下的 Laravel Blade example code 的意思是？ Example:@if (count($records) === 1) I have one record!@elseif (count($records) &gt; 1) I have multiple records!@else I don&#x27;t have any records!@endif Answer:使用 Blade 的 if else 語法 以下的 Laravel Blade example code 的意思是？ Example:@unless (Auth::check()) You are not signed in.@endunless Answer:使用 Blade 的 unless 語法, 應該是相當語意化了 以下的 Laravel Blade example code 的意思是？ Example:@isset($records) // $records is defined and is not null...@endisset@empty($records) // $records is &quot;empty&quot;...@endempty Answer:同 PHP 的 isset() 以及 empty() # Authentication Directives以下的 Laravel Blade example code 的意思是？ Example:@auth // The user is authenticated...@endauth@guest // The user is not authenticated...@endguest Answer:分別定義 authenticated user 以及 unauthenticated user 該做的事 以下的 Laravel Blade example code 的意思是？ Example:@auth(&#x27;admin&#x27;) // The user is authenticated...@endauth@guest(&#x27;admin&#x27;) // The user is not authenticated...@endguest Answer:分別定義 authenticated user 以及 unauthenticated user 該做的事, 並指定 guard # Selection Directives以下的 Laravel Blade example code 的意思是？ Example:@hasSection(&#x27;navigation&#x27;) &lt;div class=&quot;pull-right&quot;&gt; @yield(&#x27;navigation&#x27;) &lt;/div&gt; &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;@endif Answer:判斷 section &#39;navigation&#39; 是否有被定義 以下的 Laravel Blade example code 的意思是？ Example:@sectionMissing(&#x27;navigation&#x27;) &lt;div class=&quot;pull-right&quot;&gt; @include(&#x27;default-navigation&#x27;) &lt;/div&gt;@endif Answer:判斷 section &#39;navigation&#39; 是否沒有被定義 # Environment Directives以下的 Laravel Blade example code 的意思是？ Example:@production // Production specific content...@endproduction Answer:定義如果 env 為 production 時該做的事 以下的 Laravel Blade example code 的意思是？ Example:@env(&#x27;staging&#x27;) // The application is running in &quot;staging&quot;...@endenv@env([&#x27;staging&#x27;, &#x27;production&#x27;]) // The application is running in &quot;staging&quot; or &quot;production&quot;...@endenv Answer:定義如果 env 為特定的 env 時該做的事 # Switch Statements以下的 Laravel Blade example code 的意思是？ Example:@switch($i) @case(1) First case... @break @case(2) Second case... @break @default Default case...@endswitch Answer:同 PHP 的 switch() # Loops以下的 Laravel Blade example code 的意思是？ Example:@for ($i = 0; $i &lt; 10; $i++) The current value is &#123;&#123; $i &#125;&#125;@endfor@foreach ($users as $user) &lt;p&gt;This is user &#123;&#123; $user-&gt;id &#125;&#125;&lt;/p&gt;@endforeach@forelse ($users as $user) &lt;li&gt;&#123;&#123; $user-&gt;name &#125;&#125;&lt;/li&gt;@empty &lt;p&gt;No users&lt;/p&gt;@endforelse@while (true) &lt;p&gt;I&#x27;m looping forever.&lt;/p&gt;@endwhile Answer:同 PHP 的 loop 以下的 Laravel Blade example code 的意思是？ Example:@foreach ($users as $user) @if ($user-&gt;type == 1) @continue @endif &lt;li&gt;&#123;&#123; $user-&gt;name &#125;&#125;&lt;/li&gt; @if ($user-&gt;number == 5) @break @endif@endforeach Answer:同 PHP 的 loop, 也可以 break 中斷 loop 以下的 Laravel Blade example code 的意思是？ Example:@foreach ($users as $user) @continue($user-&gt;type == 1) &lt;li&gt;&#123;&#123; $user-&gt;name &#125;&#125;&lt;/li&gt; @break($user-&gt;number == 5)@endforeach Answer:同 PHP 的 loop, 可以將 condition 帶入 continue() 以及 break(), 視條件跳過當次 loop 或中斷整個 loop # The Loop Variable以下的 Laravel Blade example code 的意思是？ Example:@foreach ($users as $user) @if ($loop-&gt;first) This is the first iteration. @endif @if ($loop-&gt;last) This is the last iteration. @endif &lt;p&gt;This is user &#123;&#123; $user-&gt;id &#125;&#125;&lt;/p&gt;@endforeach Answer:Blade 特有語法, 可在 loop 內使用 $loop variable, 取得關於此 loop 的一些資訊, 如上 example 可判斷該次 loop 是否為第一次獲最後一次 以下的 Laravel Blade example code 的意思是？ Example:@foreach ($users as $user) @foreach ($user-&gt;posts as $post) @if ($loop-&gt;parent-&gt;first) This is first iteration of the parent loop. @endif @endforeach@endforeach Answer:Blade 特有語法, 可在 loop 內使用 $loop variable, 取得關於此 loop 的一些資訊, 如上 example, 可從內圈 loop 中使用 $loop-&gt;parent 取得外圈 $loop variable 的資訊 以下的 Laravel Blade example code 的意思是？ Example:@foreach ($users as $user) $loop-&gt;index $loop-&gt;iteration $loop-&gt;remaining $loop-&gt;count $loop-&gt;first $loop-&gt;last $loop-&gt;even $loop-&gt;odd $loop-&gt;depth $loop-&gt;parent@endforeach Answer:&lt;!-- Blade 特有語法, 可在 loop 內使用 $loop variable, 取得關於此 loop 的一些資訊, 如上 example, 可從內圈 loop 中使用 $loop-&gt;parent 取得外圈 $loop variable 的資訊 --&gt;@foreach ($users as $user) &lt;!-- 取得當前 loop index, 從 0 開始 --&gt; $loop-&gt;index &lt;!-- 取得當前 loop 跑第幾次了, 從 1 開始 --&gt; $loop-&gt;iteration &lt;!-- 剩餘的 iteration 次數 --&gt; $loop-&gt;remaining &lt;!-- 總共有幾個 item 要 iterated --&gt; $loop-&gt;count &lt;!-- 是否為第一個 iteration --&gt; $loop-&gt;first &lt;!-- 是否為最後一個 iteration --&gt; $loop-&gt;last &lt;!-- 是否為偶數 iteration --&gt; $loop-&gt;even &lt;!-- 是否為基數 iteration --&gt; $loop-&gt;odd &lt;!-- 當前 loop 是位於第幾層 --&gt; $loop-&gt;depth &lt;!-- 如果位於 nested loop 的話, 取得 parent loop&#x27;s variable --&gt; $loop-&gt;parent@endforeach # Comments以下的 Laravel Blade example code 的意思是？ Example:&#123;&#123;-- This comment will not be present in the rendered HTML --&#125;&#125; Answer:Blade 特有的 comment 語法, 且並不會顯示在 rendered HTML page # Including Subviews以下的 Laravel Blade example code 的意思是？ Example:&lt;div&gt; @include(&#x27;shared.errors&#x27;) &lt;form&gt; &lt;!-- Form Contents --&gt; &lt;/form&gt;&lt;/div&gt; Answer:在當前頁面 include &#39;shared.errors&#39; page, 所有在 &#39;shared.errors&#39; page 上的 variable 也可被取用 以下的 Laravel Blade example code 的意思是？ Example:@include(&#x27;view.name&#x27;, [&#x27;status&#x27; =&gt; &#x27;complete&#x27;]) Answer:預設 &#39;view.name&#39; 會使用自己的 variable, 可透過 @include 的 arg2 自定義 以下的 Laravel Blade example code 的意思是？ Example:@includeIf(&#x27;view.name&#x27;, [&#x27;status&#x27; =&gt; &#x27;complete&#x27;]) Answer:如果 include 一個不存在的 view, Laravel 預設會 throw error, 可加入判斷, 如果存在的話再 include 以下的 Laravel Blade example code 的意思是？ Example:@includeWhen($boolean, &#x27;view.name&#x27;, [&#x27;status&#x27; =&gt; &#x27;complete&#x27;])@includeUnless($boolean, &#x27;view.name&#x27;, [&#x27;status&#x27; =&gt; &#x27;complete&#x27;]) Answer:&lt;!-- 如果 boolean 為 true, 則 include, 當... 我就執行 include --&gt;@includeWhen($boolean, &#x27;view.name&#x27;, [&#x27;status&#x27; =&gt; &#x27;complete&#x27;])&lt;!-- 如果 boolean 為 false, 則 include, 除非... 否則我一律執行 include --&gt;@includeUnless($boolean, &#x27;view.name&#x27;, [&#x27;status&#x27; =&gt; &#x27;complete&#x27;]) 以下的 Laravel Blade example code 的意思是？ Example:@includeFirst([&#x27;custom.admin&#x27;, &#x27;admin&#x27;], [&#x27;status&#x27; =&gt; &#x27;complete&#x27;]) Answer:將 include array 內存在的第一個 view, 換言之, 若 &#39;custom.admin&#39; 不存在, 則 include &#39;admin&#39;, 並帶入該 view 會使用到的 variable 在 Laravel Blade 中, 需避免使用 __DIR__, 或 __FILE__, 為何？因為會指向 cached, compiled view path # Rendering Views For Collections以下的 MySQL Blade example code 的意思是? Example:@each(&#x27;view.name&#x27;, $jobs, &#x27;job&#x27;, &#x27;view.empty&#x27;) Answer:(1) &#39;view.name&#39; 表示要 render 的 view(2) $jobs 為一個 array, 將會被 iterated(3) &#39;job&#39; 表示當次 iteration 的 key/value, 會被 pass 到 &#39;view.name&#39; 中, 可在 &#39;view.name&#39; 中取用 key 以輸出其 value(4) &#39;view.empty&#39; 表示當 $jobs 是個 empty array 時該 render 的 view 以下的 MySQL Blade example 中, 會繼承 parent 的 variable 嗎? Example:@each(&#x27;view.name&#x27;, $jobs, &#x27;job&#x27;, &#x27;view.empty&#x27;) Answer:不會, 若要使用繼承的 variable, 可使用 @foreach 搭配 @include # The @once Directive以下的 Laravel Blade example code 的意思是？ Example:@once @push(&#x27;scripts&#x27;) &lt;script&gt; // Your custom JavaScript... &lt;/script&gt; @endpush@endonce Answer:Blade 語法, 在 @once 內的語法在當次 render cycle 中只會被讀取一次, 所以 @push 只會作用一次, 這樣就不會出現重複 push script 的情況了 Answer:Blade 語法, 在 @php directive 內可以直接輸入 PHP code # Building Layouts# Layouts Using Components# Defining The Layout Component以下的 Laravel Blade example code 的意思是？ Example:&lt;!-- resources/views/components/layout.blade.php --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123; $title ?? &#x27;Todo Manager&#x27; &#125;&#125; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Todos&lt;/h1&gt; &lt;hr/&gt; &#123;&#123; $slot &#125;&#125; &lt;/body&gt;&lt;/html&gt; Answer:定義一個 Blade component 模板, 在其他 page 可以使用 來 render 這個模板定義的元素 # Applying The Layout Component以下的 Laravel example code 的意思是？ Example:&lt;!-- resources/views/tasks.blade.php --&gt;&lt;x-layout&gt; @foreach ($tasks as $task) &#123;&#123; $task &#125;&#125; @endforeach&lt;/x-layout&gt; Answer:在 task blade page 使用 Layout component, 在 directive 內的 code, 將會被注入到 component 的 $slot variable # Forms# CSRF Field以下的 Laravel Blade example code 的意思是？ Example:&lt;form method=&quot;POST&quot; action=&quot;/profile&quot;&gt; @csrf ...&lt;/form&gt; Answer:Blade 特有語法, 在該 FORM 中產生 CSRF token field # Method Field以下的 Laravel Blade example code 的意思是？ Example:&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt; @method(&#x27;PUT&#x27;) ...&lt;/form&gt; Answer:Blade 特有語法, 因為 HTML Form 並不支援 PUT, PATCH, DELETE, 可使用 @method() 來模擬不支援的 HTTP method # Validation Errors以下的 Laravel Blade example code 的意思是？ Example:&lt;!-- /resources/views/post/create.blade.php --&gt;&lt;label for=&quot;title&quot;&gt;Post Title&lt;/label&gt;&lt;input id=&quot;title&quot; type=&quot;text&quot; class=&quot;@error(&#x27;title&#x27;) is-invalid @enderror&quot;&gt;@error(&#x27;title&#x27;) &lt;div class=&quot;alert alert-danger&quot;&gt;&#123;&#123; $message &#125;&#125;&lt;/div&gt;@enderror Answer:Blade 特有語法, 如果 error title 存在的話, 則執行 directive 內的動作 以下的 Laravel Blade example code 的意思是？ Example:&lt;!-- /resources/views/auth.blade.php --&gt;&lt;label for=&quot;email&quot;&gt;Email address&lt;/label&gt;&lt;input id=&quot;email&quot; type=&quot;email&quot; class=&quot;@error(&#x27;email&#x27;, &#x27;login&#x27;) is-invalid @enderror&quot;&gt;@error(&#x27;email&#x27;, &#x27;login&#x27;) &lt;div class=&quot;alert alert-danger&quot;&gt;&#123;&#123; $message &#125;&#125;&lt;/div&gt;@enderror Answer:Blade 特有語法, @error() 可以指定第二個 args, 為自定義的 message bag name想像一下如果該 page 有多個 form, 要 submit 到不同的 API, 若有 error 的話肯定會有多個不同的 message bag object, 所以必須給 message bag 自定義 name # PHP以下的 Laravel Blade example code 的意思是？ Example:@php $counter = 1;@endphp # Components以下的 Laravel example command 的意思是？ Example:php artisan make:component Alert Answer:建立一個 component 名為 Alert Laravel 中, 當我使用 CLI 建立一個 component, 其 view 及 component 位置為？view: resources/views/components 資料夾下component: App\\View\\Components 資料夾下 以下的 Laravel example command 的意思是？ Example:php artisan make:component Forms/Input Answer:Laravel 預設將 component 置於 resources/views/components 資料夾下, 亦可指定子資料夾, 所以會置於:view: resources/views/components/forms 資料夾下component: App\\View\\Components\\Forms 資料夾下 # Manually Registering Package Components以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Blade;public function boot()&#123; Blade::component(&#x27;package-alert&#x27;, AlertComponent::class);&#125;// 然後在 Blade view page 可以使用&lt;x-package-alert/&gt; Answer:如果自己建立一個 package, 並且在裡頭有使用到 Blade components 的話, 需要在 package 的 server provider 的 boot method 當中註冊該 component 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Blade;public function boot()&#123; Blade::componentNamespace(&#x27;Nightshade\\\\Views\\\\Components&#x27;, &#x27;nightshade&#x27;);&#125;// 然後在 Blade page 可以使用&lt;x-nightshade::calendar /&gt;&lt;x-nightshade::color-picker /&gt; Answer:如果自己建立一個 package, 並且在裡頭有使用到 Blade components 的話, 需要在 package 的 server provider 的 boot method 當中, 註冊 components, 上面的 example 假設在 Nightshade 這個 package 的 Package\\Views\\Components 位置有 calendar 以及 color-picker components # Rendering Components以下的 Laravel Blade example code 的意思是？ Example:&lt;x-alert/&gt;&lt;x-user-profile/&gt; Answer:使用 x-alert 以及 x-user-profile components 以下的 Laravel Blade example code 的意思是？ Example:&lt;x-inputs.button/&gt; Answer:當 component 為 nested, 使用 &#39;dot&#39; 符號上面 example 使用 App\\View\\Components\\Inputs\\Button.php component # Passing Data To Components以下的 Laravel Blade example code 的意思是？ Example:&lt;x-alert type=&quot;error&quot; :message=&quot;$message&quot;/&gt; Answer:帶入參數到 alert component當帶入 hard coded string 時, 直接使用 HTML attributes 即可當帶入 variable, 前線需加上 : 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\View\\Components;use Illuminate\\View\\Component;class Alert extends Component&#123; public $type; public $message; public function __construct($type, $message) &#123; $this-&gt;type = $type; $this-&gt;message = $message; &#125; public function render() &#123; return view(&#x27;components.alert&#x27;); &#125;&#125;// 在 component view 中&lt;div class=&quot;alert alert-&#123;&#123; $type &#125;&#125;&quot;&gt; &#123;&#123; $message &#125;&#125;&lt;/div&gt;// 在別的 blade 中&lt;x-alert type=&quot;error&quot;&gt; Answer:在 component class 中定義 property, 之後在 component view 中可以使用此 property, 而在引用的 blade 可以 assign 給 type 或 message variable 新的值 # Casting以下的 Laravel example code 的意思是？ Example:&lt;?php// 在 component modelpublic function __construct($alertType)&#123; $this-&gt;alertType = $alertType;&#125;// 在其他 blade page&lt;x-alert alert-type=&quot;danger&quot; /&gt; Answer:在 component model 可定義 property, 需使用 camelCast而在引用處可帶入該 property, 需使用 kebab-case # Component Methods以下的 Laravel example code 的意思是？ Example:&lt;?php// 在 component modelpublic function isSelected($option)&#123; return $option === $this-&gt;selected;&#125;// 在 component template&lt;option &#123;&#123; $isSelected($value) ? &#x27;selected=&quot;selected&quot;&#x27; : &#x27;&#x27; &#125;&#125; value=&quot;&#123;&#123; $value &#125;&#125;&quot;&gt; &#123;&#123; $label &#125;&#125;&lt;/option&gt; Answer:可在 component template 使用定義於 component model 的 method # Accessing Attributes &amp; Slots Within Component Classes以下的 Laravel Blade component example code 的意思是？ Example:&lt;?phppublic function render()&#123; return function (array $data) &#123; // $data[&#x27;componentName&#x27;]; // $data[&#x27;attributes&#x27;]; // $data[&#x27;slot&#x27;]; return &#x27;&lt;div&gt;Components content&lt;/div&gt;&#x27;; &#125;;&#125; Answer:可以從 render method 中取得 componentName, attributes, slot 的值return 值為 string, 會覆蓋 component view, 應用待研究 # Additional Dependencies以下的 Laravel Blade component example code 的意思是？ Example:&lt;?phpuse App\\Services\\AlertCreatorpublic function __construct(AlertCreator $creator, $type, $message)&#123; $this-&gt;creator = $creator; $this-&gt;type = $type; $this-&gt;message = $message;&#125; Answer:使用 method injection 注入 AlertCreator instance # Component Attributes以下的 Laravel example code 的意思是？ Example:// 位於 component layout page&lt;div &#123;&#123;$attributes&#125;&#125;&gt; &#123;&#123;$attributes&#125;&#125;&lt;/div&gt;// 位於其他 view page@php$message = &#x27;message&#x27;;@endphp&lt;x-layout type=&quot;error&quot; :message=&quot;$message&quot; class=&quot;mt-4&quot;&gt; &lt;/x-layout&gt; Answer:在 component template page 可以使用 $attributes 實際上 render 該 page 的 attributes, 在 view page 定義的會覆蓋 component view 定義的, 可使用 $attributes-&gt;merge() 來使兩者共存 以下的 Laravel example code, 支援嗎？ Example:&lt;x-alert :live=&quot;@env(&#x27;production&#x27;)&quot;/&gt; Answer:不支援, component tag 內不支援使用 @ directive # Default / Merged Attributes以下的 Laravel Blade example code 的意思是？ Example:// component view page&lt;div &#123;&#123; $attributes-&gt;merge([&#x27;class&#x27; =&gt; &#x27;alert alert-&#x27;.$type]) &#125;&#125;&gt; &#123;&#123; $message &#125;&#125;&lt;/div&gt;// 調用 component 的頁面&lt;x-alert type=&quot;error&quot; :message=&quot;$message&quot; class=&quot;mb-4&quot;/&gt;// rendered page&lt;div class=&quot;alert alert-error mb-4&quot;&gt; &lt;!-- Contents of the $message variable --&gt;&lt;/div&gt; Answer:使用 $attribute-&gt;merge(), 可以在 component view 定義 default 的 attributes, 並且 render 時又包含引用頁面定義的 attribute, 若不使用 merge(), 引用頁面定義的 attributes 會覆寫 component view 定義的 attributes 以下的 Laravel Blade example code 的意思是？ Example:// component view&lt;button &#123;&#123; $attributes-&gt;merge([&#x27;type&#x27; =&gt; &#x27;button&#x27;]) &#125;&#125;&gt; &#123;&#123; $slot &#125;&#125;&lt;/button&gt;// 引用的 page&lt;x-button type=&quot;submit&quot;&gt; Submit&lt;/x-button&gt;// render 的 page&lt;button type=&quot;submit&quot;&gt; Submit&lt;/button&gt; Answer:當 $attributes-&gt;merge() 的對象不是 class 時, 會被視為 default value, 如果這時在引用的 page 又定義了一次, 那會以引用 page 的為主, 跟 merge class 不同, 兩者並不會共存 以下的 Laravel Blade example code 的意思是？ Example:&lt;div &#123;&#123; $attributes-&gt;merge([&#x27;data-controller&#x27; =&gt; $attributes-&gt;prepends(&#x27;profile-controller&#x27;)]) &#125;&#125;&gt; &#123;&#123; $slot &#125;&#125;&lt;/div&gt; Answer:當 $attributes-&gt;merge() 的對象不是 class 時, 會被視為 default value, 如果這時在引用的 page 又定義了一次, 那會以引用 page 的為主, 跟 merge class 不同, 兩者並不會共存但可以使用 $attributes-&gt;prepends() 使兩者共存, 以上的 example 中, &#39;data-controller&#39; 的 default value 為 &#39;profile-controller&#39;, 然後任何在引用頁面定義的 value 都會被 merge 到此 array 中 # Filtering Attributes以下的 Laravel Blade example code 的意思是？ Example:&#123;&#123; $attributes-&gt;filter(fn ($value, $key) =&gt; $key == &#x27;foo&#x27;) &#125;&#125; Answer:在 Blade component view 中使用 $attributes-&gt;filter(), 唯有 closure return true 的 attribute 才會被保留 以下的 Laravel Blade example code 的意思是？ Example:&#123;&#123; $attributes-&gt;whereStartsWith(&#x27;wire:model&#x27;) &#125;&#125; Answer:取得 $attributes 中, key 為 &#39;wire:model&#39; 開頭的 attributes 以下的 Laravel Blade example code 的意思是？ Example:&#123;&#123; $attributes-&gt;whereStartsWith(&#x27;wire:model&#x27;)-&gt;first() &#125;&#125; Answer:取得 whereStartsWith() 篩選後的第一筆 attribute # Slots以下的 Laravel example code 的意思是？ Example:// component view page&lt;!-- /resources/views/components/alert.blade.php --&gt;&lt;span class=&quot;alert-title&quot;&gt;&#123;&#123; $title &#125;&#125;&lt;/span&gt;&lt;div class=&quot;alert alert-danger&quot;&gt; &#123;&#123; $slot &#125;&#125;&lt;/div&gt;// 引用頁面&lt;x-alert&gt; &lt;x-slot name=&quot;title&quot;&gt; Server Error &lt;/x-slot&gt; &lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong!&lt;/x-alert&gt; Answer:在 component view page 可定義 $slot 位置, 當引用該 component 時, 在該 component tag 內的內容都會 render 到 component view page 中 $slot 的位置, 如果想要在 component view page 定義多個 $slot 位置的話, 如上 example 可直接定義 variable, 在引用的 page 使用 &lt;x-slot name=&quot;yourSlot&quot; # Scoped Slots以下的 Laravel Blade example code 的意思是？ Example:&lt;x-alert&gt; &lt;x-slot name=&quot;title&quot;&gt; &#123;&#123; $component-&gt;formatAlert(&#x27;Server Error&#x27;) &#125;&#125; &lt;/x-slot&gt; &lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong!&lt;/x-alert&gt; Answer:可在 Blade component class 中定義 method, 在 slot 中使用 $component 調用定義好的 method # Inline Component Views以下位於 Component class 的 Laravel example code 的意思是？ Example:&lt;?phppublic function render()&#123; return &lt;&lt;&lt;&#x27;blade&#x27; &lt;div class=&quot;alert alert-danger&quot;&gt; &#123;&#123; $slot &#125;&#125; &lt;/div&gt; blade;&#125; Answer:當 component 的範圍比較小, 可能不太需要同時用到 component class 以及 component view page, 這時可以直接在 component class 的 render() return markup # Generating Inline View Components以下的 Laravel example command 的意思是？ Example:php artisan make:component Alert --inline Answer:當 component 的範圍比較小, 可能不太需要同時用到 component class 以及 component view page, 這時可以直接在 component class 的 render() return markup以上 command 可以直接建立一個 return inline view 的 component # Anonymous ComponentsLaravel Blade 中, 何謂 Anonymous Component?直接在 resources/views/components/ 資料夾底下定義一個 Blade view, 而不需建立 Component class Laravel Blade 中, component view 可以沒有 component class 而單獨存在嗎？可以, 又稱為 Anonymous component # Data Properties / Attributes以下的 Laravel Blade example code 的意思是？ Example:// 在 component view page&lt;!-- /resources/views/components/alert.blade.php --&gt;@props([&#x27;type&#x27; =&gt; &#x27;info&#x27;, &#x27;message&#x27;])&lt;div &#123;&#123; $attributes-&gt;merge([&#x27;class&#x27; =&gt; &#x27;alert alert-&#x27;.$type]) &#125;&#125;&gt; &#123;&#123; $message &#125;&#125;&lt;/div&gt;// 在引用 page&lt;x-alert type=&quot;error&quot; :message=&quot;$message&quot; class=&quot;mb-4&quot;/&gt; Answer:當使用 Anonymous Component 時, 因為沒有 associated class, 所以使用 @props() 直接在 component view page 定義 property, 效果同定義在 associated class # Dynamic Components以下的 Laravel Blade example code 的意思是？ Example:&lt;x-dynamic-component :component=&quot;$componentName&quot; class=&quot;mt-4&quot; /&gt; Answer:有時你可能需要渲染一個 component, 但只有在 runtime 的時候才知道要渲染哪一個 component, 這時候就可以使用 Dynamic Component從 :component 帶入指定的 component # Manually Registering Components以下的 Laravel Blade example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Blade;use VendorPackage\\View\\Components\\AlertComponent;public function boot()&#123; Blade::component(&#x27;package-alert&#x27;, AlertComponent::class);&#125; Answer:Laravel 預設會到 resources/views/components 以及 app\\Views\\Components 資料夾內尋找並註冊 component, 但如果你在 build 一個 package, 又或者你將 component 放在其他位置的話, 可以在 package service provider 內的 boot() 註冊 components # Autoloading Package Components以下的 Laravel Blade example code 的意思是？ Example:&lt;?php// 在 package service provider 中public function boot()&#123; Blade::componentNamespace(&#x27;Nightshade\\\\Views\\\\Components&#x27;, &#x27;nightshade&#x27;);&#125;// 在引用的 page 中&lt;x-nightshade::calendar /&gt;&lt;x-nightshade::color-picker /&gt; Answer:在 package service provider boot() 中, 註冊一個名為 &#39;nightshade&#39; 的 namespaceLaravel 預設會到 resources/views/components 以及 app\\Views\\Components 資料夾內尋找並註冊 component, 但如果你在 build 一個 package, 又或者你將 component 放在其他位置的話, 可以在 package service provider 內的 boot() 註冊。 # Stacks以下的 Laravel Blade example code 的意思是？ Example:&lt;?php@push(&#x27;scripts&#x27;) &lt;script src=&quot;/example.js&quot;&gt;&lt;/script&gt;@endpush Answer:將 directive 中的 script push 到名為 scripts 的 stack 以下的 Laravel Blade example code 的意思是？ Example:&lt;?php&lt;head&gt; &lt;!-- Head Contents --&gt; @stack(&#x27;scripts&#x27;)&lt;/head&gt; Answer:將 stack scripts 裡面的內容 pop 出來 以下的 Laravel Blade example code 的意思是？ Example:@push(&#x27;scripts&#x27;) This will be second...@endpush// Later...@prepend(&#x27;scripts&#x27;) This will be first...@endprepend Answer:當使用 @push, script 會依照順序執行, 越先 push 的越先執行, 但可以使用 @prepend 改變順序, 越後面 @prepend 的會越先執行 # Service Injection以下的 Laravel example code 的意思是？ Example:&lt;?php@inject(&#x27;metrics&#x27;, &#x27;App\\Services\\MetricsService&#x27;)&lt;div&gt; Monthly Revenue: &#123;&#123; $metrics-&gt;monthlyRevenue() &#125;&#125;.&lt;/div&gt; Answer:從 Laravel service container 取得 servicearg1 要將此 service assign to 的 variable, arg 為 Service 的位置 # Extending Blade以下的 Laravel Blade example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Blade;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Blade::directive(&#x27;datetime&#x27;, function ($expression) &#123; return &quot;&lt;?php echo ($expression)-&gt;format(&#x27;m/d/Y H:i&#x27;); ?&gt;&quot;; &#125;); &#125;&#125; Answer:在 AppServiceProvider 的 boot() 中, 可以使用 Blade 的 directive() 來註冊客製化的 Blade directive定義一個 Blade directive 名為 datetime, 邏輯定義於 closure 內 Laravel 中, 如果我更新了 Blade view, 需要清除 cache 嗎？如果有跑 php artisan view:cache 的話, 要執行 php artisan view:clear 清除 # Custom If Statements以下的 Laravel example code 的意思是？ Example:&lt;?php// 位於 AppServiceProviderpublic function boot()&#123; Blade::if(&#x27;disk&#x27;, function ($value) &#123; return config(&#x27;filesystems.default&#x27;) === $value; &#125;);&#125;// 引用 page@disk(&#x27;local&#x27;)@elsedisk(&#x27;s3&#x27;)@else@enddisk@unlessdisk(&#x27;local&#x27;)@enddisk Answer:&lt;?php// 定義一個客製化的 Blade If Statement, 邏輯定義於 closure 內public function boot()&#123; Blade::if(&#x27;disk&#x27;, function ($value) &#123; return config(&#x27;filesystems.default&#x27;) === $value; &#125;);&#125;// 位於引用 page@disk(&#x27;local&#x27;) &lt;!-- The application is using the local disk... --&gt;@elsedisk(&#x27;s3&#x27;) &lt;!-- The application is using the s3 disk... --&gt;@else &lt;!-- The application is using some other disk... --&gt;@enddisk@unlessdisk(&#x27;local&#x27;) &lt;!-- The application is not using the local disk... --&gt;@enddisk # AdditionalLaravel 中, blade view 的命名習慣是？會以資料夾做區分, 像是 withdraws/index.blade.php、withdraws/store.blade.php","link":"/zh-tw/laravel-frontend-blade-templates/"},{"title":"Laravel - 完全杜絕 N+1 issue 的可能","text":"# 前言有使用 Laravel 的朋友相信對 Eager loading 以及 Lazy loading 都不陌生有時專案很趕, API 一次要開很多支, 常常沒注意到就產生了 Lazy loading N+1 issue本篇文章提供一個概念性方法來完全的杜絕 N+1 issue, 不過各位朋友啊, 這只是個概念, 沒有真正實作於 Production 環境, 如果朋友不怕死你可以試試, 但出事千萬別找我啊！ # 建立新的 base model首先, 在 app 資料夾底下新增 Model 檔案, 內容如下： &lt;?phpnamespace App;use Exception;use Illuminate\\Database\\Eloquent\\Model as Eloquent;class Model extends Eloquent&#123; public function getRelationshipFromMethod($name) &#123; // 呼叫的 model $class = get_class($this); // $name = 被呼叫的 relation throw new Exception(&quot;Lazy-loading relationships is not allowed ($class::$name).&quot;); &#125;&#125; 主要是因為 getRelationshipFromMethod 會在 Lazy loading 之前被呼叫, 因此我們只要覆寫了這個 method, 並新增 throw Exception 的邏輯, 那當使用 lazy loading 時就會噴錯, 噴錯你就不能繼續開發, 不能繼續開發你就會想辦法解決 N+1 issue 啦！ # 變更 extended model以下為 example code, 假設我們有個 Customer model 想要套用以上設定, 就要 extend 我們上面新增的 model, 而因原本的 Eloquent Model &lt;?phpnamespace App;// 將原本這邊會 use Eloquent\\Model 拿掉, 就會 extend 同 namespace 下面我們上面新增的 model 啦！class Customer extends Model&#123; public function salesRep() &#123; return $this-&gt;belongsTo(User::class); &#125;&#125; # 驗證驗證的時候到了, 將下面的 with() comment 掉, 就會噴錯了 &lt;?phpnamespace App\\Http\\Controllers;use App\\Customer;class CustomersController extends Controller&#123; public function index() &#123; $customers = Customer::query() // -&gt;with(&#x27;salesRep&#x27;) -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;customers&#x27;, [&#x27;customers&#x27; =&gt; $customers]); &#125;&#125; # 結論再次重申, 這我也沒用在 Production 過, 想嘗試的朋友自己追一下 source code 再三思啊！","link":"/zh-tw/laravel-make-n-plus-1-issue-impossible/"},{"title":"Laravel - Package - Octane","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Installation以下的 Laravel example code 的意思是？ Example:composer require laravel/octanephp artisan octane:install Answer:安裝 octane Laravel Octane 的 PHP 最低版本是？PHP8.0 # Server Prerequisites# Swoole以下的 Laravel example code 的意思是？ Example:&lt;?php Answer:&lt;?php","link":"/zh-tw/laravel-octane/"},{"title":"Laravel - Packages - Backpack","text":"# IntroductionLaravel Backpack 的文件翻譯筆記 # Questions and Answers以下的 Laravel Backpack Field example code 的意思是？ Example:&lt;?php[ &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;suffix&#x27; =&gt; &#x27;&#x27;, &#x27;default&#x27; =&gt; &#x27;some value&#x27;, // set a default value &#x27;hint&#x27; =&gt; &#x27;Some hint text&#x27;, // helpful text, shows up after the input &#x27;attributes&#x27; =&gt; [ &#x27;placeholder&#x27; =&gt; &#x27;Some text when empty&#x27;, &#x27;class&#x27; =&gt; &#x27;form-control some-class&#x27;, &#x27;readonly&#x27;=&gt;&#x27;readonly&#x27;, &#x27;disabled&#x27;=&gt;&#x27;disabled&#x27;, ], // change the HTML attributes of your input &#x27;wrapperAttributes&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;form-group col-md-12&#x27; ], // change the HTML attributes for the field wrapper - mostly for resizing fields ] Answer:&lt;?php[ &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;suffix&#x27; =&gt; &#x27;&#x27;, &#x27;default&#x27; =&gt; &#x27;some value&#x27;, // set a default value &#x27;hint&#x27; =&gt; &#x27;Some hint text&#x27;, // helpful text, shows up after the input &#x27;attributes&#x27; =&gt; [ &#x27;placeholder&#x27; =&gt; &#x27;Some text when empty&#x27;, &#x27;class&#x27; =&gt; &#x27;form-control some-class&#x27;, &#x27;readonly&#x27;=&gt;&#x27;readonly&#x27;, &#x27;disabled&#x27;=&gt;&#x27;disabled&#x27;, ], // change the HTML attributes of your input &#x27;wrapperAttributes&#x27; =&gt; [ &#x27;class&#x27; =&gt; &#x27;form-group col-md-12&#x27; ], // change the HTML attributes for the field wrapper - mostly for resizing fields ] 以下的 Laravel Backpack Field example code 的意思是？ Example:&lt;?php[ &#x27;name&#x27; =&gt; &#x27;description&#x27;, &#x27;type&#x27; =&gt; &#x27;textarea&#x27;, &#x27;label&#x27; =&gt; &#x27;Article Description&#x27;,] Answer:name: 對應到資料庫中的欄位type: input typelabel: human readable 的 input 顯示 以下的 Laravel Backpack example code 的意思是？ Example:&lt;?phpphp artisan backpack:crud tagphp artisan backpack:base:add-custom-route &quot;CRUD::resource(&#x27;tag&#x27;, &#x27;TagCrudController&#x27;);&quot;php artisan backpack:base:add-sidebar-content &quot;&lt;li&gt;&lt;a href=&#x27;&#123;&#123; backpack_url(&#x27;tag&#x27;) &#125;&#125;&#x27;&gt;&lt;i class=&#x27;fa fa-tag&#x27;&gt;&lt;/i&gt; &lt;span&gt;Tags&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&quot; Answer:建立 Tag model, Tag request, 以及 TagCrudController建立一個 resource route 到 routes/backpack/custom.php 檔案中 (位於 admin prefix, auth middleware), url 為 tag, 目標 controller 為 TagCrudController產生 doll sidebar, 並定義其內容 以下的 Laravel Backpack example code 的意思是？ Example:&lt;?php&lt;?php namespace App\\Http\\Controllers\\Admin;use Backpack\\CRUD\\app\\Http\\Controllers\\CrudController;use App\\Http\\Requests\\TagCrudRequest as StoreRequest;use App\\Http\\Requests\\TagCrudRequest as UpdateRequest;class TagCrudController extends CrudController &#123; public function setup() &#123; $this-&gt;crud-&gt;setModel(&quot;App\\Models\\Tag&quot;); $this-&gt;crud-&gt;setRoute(&quot;admin/tag&quot;); $this-&gt;crud-&gt;setEntityNameStrings(&#x27;tag&#x27;, &#x27;tags&#x27;); $this-&gt;crud-&gt;setColumns([&#x27;name&#x27;, &#x27;slug&#x27;]); $this-&gt;crud-&gt;addField([ &#x27;name&#x27; =&gt; &#x27;name&#x27;, &#x27;type&#x27; =&gt; &#x27;text&#x27;, &#x27;label&#x27; =&gt; &quot;Tag name&quot; ]); $this-&gt;crud-&gt;addField([ &#x27;name&#x27; =&gt; &#x27;slug&#x27;, &#x27;type&#x27; =&gt; &#x27;text&#x27;, &#x27;label&#x27; =&gt; &quot;URL Segment (slug)&quot; ]); &#125; public function store(StoreRequest $request) &#123; return parent::storeCrud(); &#125; public function update(UpdateRequest $request) &#123; return parent::updateCrud(); &#125;&#125; Answer:&lt;?php&lt;?php namespace App\\Http\\Controllers\\Admin;use Backpack\\CRUD\\app\\Http\\Controllers\\CrudController;use App\\Http\\Requests\\TagCrudRequest as StoreRequest;use App\\Http\\Requests\\TagCrudRequest as UpdateRequest;class TagCrudController extends CrudController &#123; public function setup() &#123; // 設定使用的 model $this-&gt;crud-&gt;setModel(&quot;App\\Models\\Tag&quot;); // 設定 route, 位於 routes/custom.php $this-&gt;crud-&gt;setRoute(&quot;admin/tag&quot;); // 設定 entity 單複數, 供 Backpack 套件內部各模組使用 $this-&gt;crud-&gt;setEntityNameStrings(&#x27;tag&#x27;, &#x27;tags&#x27;); // 設定 GET 可得到的 column $this-&gt;crud-&gt;setColumns([&#x27;name&#x27;, &#x27;slug&#x27;]); // 設定前端顯示的 field // name: 對應到的 db 中的 column // type: filed kind, 像是 text, number, select2 // label: human readable input name, 如果不指定, 預設為 name $this-&gt;crud-&gt;addField([ &#x27;name&#x27; =&gt; &#x27;name&#x27;, &#x27;type&#x27; =&gt; &#x27;text&#x27;, &#x27;label&#x27; =&gt; &quot;Tag name&quot; ]); $this-&gt;crud-&gt;addField([ &#x27;name&#x27; =&gt; &#x27;slug&#x27;, &#x27;type&#x27; =&gt; &#x27;text&#x27;, &#x27;label&#x27; =&gt; &quot;URL Segment (slug)&quot; ]); &#125; // 若在 form 驗證沒過, 到不了這 public function store(StoreRequest $request) &#123; return parent::storeCrud(); &#125; public function update(UpdateRequest $request) &#123; return parent::updateCrud(); &#125;&#125; 以下的 Laravel Backpack example code 的意思是？ Example:&lt;?php// relationpublic function articles()&#123; return $this-&gt;belongsToMany(&#x27;App\\Models\\Article&#x27;, &#x27;article_tag&#x27;);&#125;// In CrudController$this-&gt;crud-&gt;addField([ &#x27;type&#x27; =&gt; &#x27;select2_multiple&#x27;, &#x27;name&#x27; =&gt; &#x27;articles&#x27;, &#x27;entity&#x27; =&gt; &#x27;articles&#x27;, &#x27;attribute&#x27; =&gt; &#x27;title&#x27;, &#x27;pivot&#x27; =&gt; true,], &#x27;update&#x27;); Answer:type: 定義 field, 類型為可多選 inputname: 該 model 的 relation nameentity: 該 model 的 relation nameattribute: Article model 中, 要顯示在 select input 的欄位pivot: 是否 cascade delete &amp; updateupdate: 指定該 filed 只會顯示在 update form, 而非 create form, 若不帶, 則兩邊都會出現 以下的 Laravel Backpack example code 的意思是？ Example:&lt;?php$this-&gt;crud-&gt;setFromDb() Answer:Backpack 會根據 DB column 的 type 自己決定 input type, 只適用於簡單的應用場景 以下的 Laravel Backpack example code 的意思是？ Example:&lt;?php$this-&gt;crud-&gt;addColumn($column_definition_array);$this-&gt;crud-&gt;addColumns([$column_definition_array_1, $column_definition_array_2]);$this-&gt;crud-&gt;removeColumn(&#x27;column_name&#x27;);$this-&gt;crud-&gt;removeColumns([&#x27;column_name_1&#x27;, &#x27;column_name_2&#x27;]);$this-&gt;crud-&gt;setColumnDetails(&#x27;column_name&#x27;, [&#x27;attribute&#x27; =&gt; &#x27;value&#x27;]);$this-&gt;crud-&gt;setColumnsDetails([&#x27;column_1&#x27;, &#x27;column_2&#x27;], [&#x27;attribute&#x27; =&gt; &#x27;value&#x27;]);$this-&gt;crud-&gt;setColumns([$column_definition_array_1, $column_definition_array_2]); Answer:&lt;?php// 可以定義 column 要用什麼方式回傳, 可以是 date, array// 增加一個指定 column 回傳值$this-&gt;crud-&gt;addColumn($column_definition_array);// 增加多個指定 column 回傳值$this-&gt;crud-&gt;addColumns([$column_definition_array_1, $column_definition_array_2]);// 移除一個指定 column 回傳值$this-&gt;crud-&gt;removeColumn(&#x27;column_name&#x27;); // remove a column from the table// 移除多個指定 column 回傳值$this-&gt;crud-&gt;removeColumns([&#x27;column_name_1&#x27;, &#x27;column_name_2&#x27;]);// 設定單個 column, 以及其 detail attribute, 只允許回傳該 column$this-&gt;crud-&gt;setColumnDetails(&#x27;column_name&#x27;, [&#x27;attribute&#x27; =&gt; &#x27;value&#x27;]);// 設定多個 column, 以及其 detail attribute, 只允許回傳這些 column$this-&gt;crud-&gt;setColumnsDetails([&#x27;column_1&#x27;, &#x27;column_2&#x27;], [&#x27;attribute&#x27; =&gt; &#x27;value&#x27;]);// 設定多個 columns, 只允許回傳這些 columns$this-&gt;crud-&gt;setColumns([$column_definition_array_1, $column_definition_array_2]);","link":"/zh-tw/laravel-package-backpack/"},{"title":"Laravel - Packages - Fortify","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Installation以下的 Laravel example code 的意思是？ Example:&lt;?phpcomposer require laravel/fortifyphp artisan vendor:publish --provider=&quot;Laravel\\Fortify\\FortifyServiceProvider&quot;php artisan migrate Answer:安裝 Laravel Fortify, 並使用 publish 取得 config, migration, FortifyServiceProvider, 以及將 Fortify’s actions 放到 app/Actions 資料夾 # The Fortify Service Provider當使用 Laravel Fortify 時, 需在哪個資料夾內註冊 FortifyServiceProvider?config/app.php # Fortify Features以下位於 Laravel Fortify config 的 example code 的意思是？ Example:&lt;?php&#x27;features&#x27; =&gt; [ Features::registration(), Features::resetPasswords(), Features::emailVerification(),], Answer:定義 Fortify 預設暴露的 feature # Disabling Views以下位於 Laravel Fortify Config 的 example code 的意思是？ Example:&lt;?php&#x27;views&#x27; =&gt; false, Answer:Laravel Fortify 預設會 return views, 當專案是 SPA 時, 可使用 false 把它關掉 # Disabling Views &amp; Password Reset當我使用 Laravel Fortify 時, 如果我 disable view, 那還需要定義 password reset view 嗎？ Example:&lt;?php&#x27;views&#x27; =&gt; false, Answer:還是需要定義一個 password.reset route, 用來顯示 reset password view因為 Illuminate\\Auth\\Notifications\\ResetPassword notification 會經由 password.reset 產生 password reset URL","link":"/zh-tw/laravel-packages-fortify/"},{"title":"Laravel - Packages - Sail","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Installation &amp; Setup# Installing Sail Into Existing Applications以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpcomposer require laravel/sail --dev Answer:如果是舊專案, 可以使用 composer 安裝 sail 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpphp artisan sail:install Answer:當專案的 vendor 中 sail 時, 可以使用 artisan 指令, 當 vendor 中的 docker-compose.yml publish 到 project root # Configuring A Bash Alias以下的 Laravel Testing example code 的意思是？ Example:&lt;?php./vendor/bin/sail up -d Answer:當 docker-compose.yml file 已經 publish 到 project root 後, 可以使用 ./vendor/bin/sail up 來啟動 container 在背景 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpalias sail=&#x27;bash vendor/bin/sail&#x27; Answer:如不想一直打 ./vendor/bin/sail 的話, 可設定 alias # Starting &amp; Stopping Sail以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpsail down Answer:stop 跑在 background 的 container # Executing Commands以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpsail artisan queue:work Answer:使用 sail 執行位於 sail container 中的 artisan # Executing PHP Commands以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpsail php --versionsail php script.php Answer:執行位於 sail container 中的 PHP 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpsail composer require laravel/sanctum Answer:執行位於 sail container 中的 composer # Installing Composer Dependencies For Existing Applications以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpdocker run --rm \\ -u &quot;$(id -u):$(id -g)&quot; \\ -v $(pwd):/opt \\ -w /opt \\ laravelsail/php80-composer:latest \\ composer install Answer:使用 docker 拉取 laravelsail/php80-composer image 來安裝專案的 composer dependency # Executing Node / NPM Commands以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpsail node --versionsail npm run prod Answer:使用 sail 來調用 container 內的 node 以及 npm # Running Tests以下的 Laravel example code 的意思是？ Example:&lt;?phpsail testsail test --group orderssail artisan test Answer:使用 sail run php test 或 artisan test # Laravel Dusk","link":"/zh-tw/laravel-packages-sail/"},{"title":"Laravel - Packages - Sanctum (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Installation以下的 Laravel example command 的意思是？ Example:composer require laravel/sanctumphp artisan vendor:publish --provider=&quot;Laravel\\Sanctum\\SanctumServiceProvider&quot;php artisan migrate Answer:安裝 sanctum package, vendor publish 會將 sanctum 的 config file 以及 migration file 放到 application 的預設資料夾, 最後 migrate 建立 API token 會使用到的 table 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;api&#x27; =&gt; [ \\Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful::class, &#x27;throttle:api&#x27;, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,], Answer:若要使用 sanctum 的驗證機制, 需在 app/Http/Kernel.php 中加入 sanctum 的 middleware # Migration Customization以下的 Laravel example code 的意思是？ Example:&lt;?phpclass AppServiceProvider extends ServiceProvider&#123; public function register() &#123; Sanctum::ignoreMigrations(); &#125; public function boot() &#123; // &#125;&#125; Answer:當使用 sanctum 時, 可在 AppServiceProvider 的 register() 中, 使用 Sanctum::ignoreMigrations(), 不使用 Sanctum 預設的 migration 以下的 Laravel example command 的意思是？ Example:php artisan vendor:publish --tag=sanctum-migrations Answer:export sanctum 的 default migration # Configuration# Overriding Default Models以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Laravel\\Sanctum\\PersonalAccessToken as SanctumPersonalAccessToken;class PersonalAccessToken extends SanctumPersonalAccessToken&#123; // ...&#125; Answer:透過 extends SanctumPersonalAccessToken, 可以自定義 sanctum 使用的預設 model 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\Passport\\PersonalAccessToken;use Laravel\\Sanctum\\Sanctum;public function boot()&#123; Sanctum::usePersonalAccessTokenModel(PersonalAccessToken::class);&#125; Answer:在自定義完成 PersonalAccessToken model 之後, 在任何一個 service provider 的 boot() 中可以指定 Sanctum 使用這個 model # API Token AuthenticationLaravel Sanctum 中的 API token 是用來幹嘛的？用來允許特定應用程式使用的 token, 所以通常期限都很長 Laravel Sanctum 的 SPA 驗證機制是使用 token 還是 cookie?cookie 可以使用 Sanctum 的 API token 機制來驗證 SPA 嗎？不要, 因為 API token 期限都很長, 使用情境為允許特定應用程式使用的單獨 token # Issuing API Tokens以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Laravel\\Sanctum\\HasApiTokens;class User extends Authenticatable&#123; use HasApiTokens, HasFactory, Notifiable;&#125; Answer:當要使用 sanctum 的 API token 時, 需先 use HasPoiTokens trait, 以使用其 method 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Http\\Request;Route::post(&#x27;/tokens/create&#x27;, function (Request $request) &#123; $token = $request-&gt;user()-&gt;createToken($request-&gt;token_name); return [&#x27;token&#x27; =&gt; $token-&gt;plainTextToken];&#125;); Answer:建立一個 sanctum API token, 並在存進資料庫前會先使用 sha256 hash, 可使用 plainTextToken 取得尚未 hash 前的 token 回傳, createToken() 的 parameter 為 token name, 想像當我們使用 Google API token 時, 會給 token 一個名字, 這樣才知道這個 token 是用在哪一個應用程式上 以下的 Laravel Sanctum example code 的意思是？ Example:&lt;?phpforeach ($user-&gt;tokens as $token) &#123; //&#125; Answer:當使用 Sanctum 時, 可使用 HasApiTokens trait 取得 user 的所有 token # Token Abilities以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $user-&gt;createToken(&#x27;token-name&#x27;, [&#x27;server:update&#x27;])-&gt;plainTextToken; Answer:當使用 Sanctum 的 creatToken() 時, 可在 arg2 定義該 token 的權限賦予該 token server:update 的權限 以下的 Laravel Sanctum example code 的意思是？ Example:&lt;?phpif ($user-&gt;tokenCan(&#x27;server:update&#x27;)) &#123; //&#125; Answer:當使用 Sanctum 時, 可使用 tokenCan() 來判斷該 token 的權限 # First-Party UI Initiated RequestsLaravel Sanctum 中, 如果 incoming request 是來自 first-party, 那 tokenCan() 會回傳？always return true 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $request-&gt;user()-&gt;id === $server-&gt;user_id &amp;&amp; $request-&gt;user()-&gt;tokenCan(&#x27;server:update&#x27;) Answer:當使用 Sanctum 預設驗證機制時, 所有來自 first-party 的 token 都會被 tokenCan() 判斷 true, 而在這樣的設定下, 如果我們要定義 first-party token 的權限時, 便可使用 Authorization Policy如果該 token 不是 first-party token, 那 tokenCan() 就會擋下, 如果該 token 是 first-party token 但擁有者並不符合定義的規則, 那 Authorization Policy 也會擋下 # Protecting Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Http\\Request;Route::middleware(&#x27;auth:sanctum&#x27;)-&gt;get(&#x27;/user&#x27;, function (Request $request) &#123; return $request-&gt;user();&#125;); Answer:使用 sanctum 的 middleware 來 protect routes # Revoking Tokens以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;tokens()-&gt;delete();$request-&gt;user()-&gt;currentAccessToken()-&gt;delete();$user-&gt;tokens()-&gt;where(&#x27;id&#x27;, $tokenId)-&gt;delete(); Answer:無效化 $user 的所有 token無效化當前 request 的 token無效化指定 token # SPA Authentication# Configuration# Configuration Your First-Party Domains以下位於 Sanctum 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;stateful&#x27; =&gt; explode(&#x27;,&#x27;, env( &#x27;SANCTUM_STATEFUL_DOMAINS&#x27;, &#x27;localhost,localhost:3000,127.0.0.1,127.0.0.1:8000,::1&#x27;)), Answer:如果 request 來自被包含在 stateful option 內的 domain 或 ip, 那針對這些 request 的 response 會附有帶著 authentication token 的 cookie 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Laravel\\Sanctum\\Http\\Middleware\\EnsureFrontendRequestsAreStateful;&#x27;api&#x27; =&gt; [ EnsureFrontendRequestsAreStateful::class, &#x27;throttle:api&#x27;, \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,], Answer:當使用 Sanctum 時, 在 api middleware group 內加入 Sanctum 的驗證 middleware, 確保就算來自於 first-party 的 request 是呼叫 API route, 也會收到 session cookies # CORS &amp; Cookies當使用 Laravel Sanctum 時, 務必確認要回傳 Access-Control-Allow-Credentials 為 true, 需在哪個檔案中設定？config/cors.php, 將 supports_credentials 設為 true 以下位於 config/cors.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;supports_credentials&#x27; =&gt; false, Answer:response 回傳 Access-Control-Allow-Credentials 為 true 以下位於 config/session.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;domain&#x27; =&gt; &#x27;.domain.com&#x27;, Answer:讓 session cookie 支援所有的 subdomain 以下的 Axios example code 的意思是？ Example:axios.defaults.withCredentials = true; Answer:若要 request 攜帶 cookie, 需打開 withCredentials # Authenticating# CSRF Protection以下的 Laravel example code 的意思是？ Example:&lt;?phpaxios.get(&#x27;/sanctum/csrf-cookie&#x27;).then(response =&gt; &#123; // Login...&#125;); Answer:當使用 Laravel Sanctum 驗證 SPA 時, 要登入前應先呼叫 /sanctum/csrf-cookie 來啟動 CSRF protection, 之後 Laravel 會在每一次的 request, 在瀏覽器 set cookie XSRF-TOKEN, 這時如果使用 Axios, Angular HttpClient 則會自動地將 XSRF-TOKEN cookie 附加到 X-XSRF-TOKEN 來避免 CSRF # Protecting Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Http\\Request;Route::middleware(&#x27;auth:sanctum&#x27;)-&gt;get(&#x27;/user&#x27;, function (Request $request) &#123; return $request-&gt;user();&#125;); Answer:使用 Sanctum middleware 來驗證通往該 route 的 request # Authorizing Private Broadcast Channels以下的 Laravel example code 的意思是？ Example:&lt;?php// routes/api.phpBroadcast::routes([&#x27;middleware&#x27; =&gt; [&#x27;auth:sanctum&#x27;]]); Answer:使用 Sanctum SPA 來驗證 private / presence broadcast channels 以下的 Laravel Echo example code 的意思是？ Example:&lt;?phpwindow.Echo = new Echo(&#123; broadcaster: &quot;pusher&quot;, cluster: process.env.MIX_PUSHER_APP_CLUSTER, encrypted: true, key: process.env.MIX_PUSHER_APP_KEY, authorizer: (channel, options) =&gt; &#123; return &#123; authorize: (socketId, callback) =&gt; &#123; axios.post(&#x27;/api/broadcasting/auth&#x27;, &#123; socket_id: socketId, channel_name: channel.name &#125;) .then(response =&gt; &#123; callback(false, response.data); &#125;) .catch(error =&gt; &#123; callback(true, error); &#125;); &#125; &#125;; &#125;,&#125;) Answer:使用 custom Pusher authorizer, 讓 Pusher 使用 axios # Mobile Application Authentication以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Hash;use Illuminate\\Validation\\ValidationException;Route::post(&#x27;/sanctum/token&#x27;, function (Request $request) &#123; $request-&gt;validate([ &#x27;email&#x27; =&gt; &#x27;required|email&#x27;, &#x27;password&#x27; =&gt; &#x27;required&#x27;, &#x27;device_name&#x27; =&gt; &#x27;required&#x27;, ]); $user = User::where(&#x27;email&#x27;, $request-&gt;email)-&gt;first(); if (! $user || ! Hash::check($request-&gt;password, $user-&gt;password)) &#123; throw ValidationException::withMessages([ &#x27;email&#x27; =&gt; [&#x27;The provided credentials are incorrect.&#x27;], ]); &#125; return $user-&gt;createToken($request-&gt;device_name)-&gt;plainTextToken;&#125;); Answer:當需求是使用 Sanctum 驗證 Mobile Device, 並且 issue token 時, 可在驗證 email, password 之後, issue 一個 token, 並命名為 $request-&gt;device_name # Protecting Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::middleware(&#x27;auth:sanctum&#x27;)-&gt;get(&#x27;/user&#x27;, function (Request $request) &#123; return $request-&gt;user();&#125;); Answer:使用 sanctum middleware 來 protect routes # Revoking Tokens以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;tokens()-&gt;delete();$user-&gt;tokens()-&gt;where(&#x27;id&#x27;, $tokenId)-&gt;delete(); Answer:刪除 $user 所有的 token刪除 $user 指定的 token # Testing以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;use Laravel\\Sanctum\\Sanctum;public function test_task_list_can_be_retrieved()&#123; Sanctum::actingAs( User::factory()-&gt;create(), [&#x27;view-tasks&#x27;] ); $response = $this-&gt;get(&#x27;/api/task&#x27;); $response-&gt;assertOk();&#125; Answer:使用 Sanctum 的 testing feature, 透過 User factory 建立一個 user 並給予 view-tasks 的權限 以下的 Laravel example code 的意思是？ Example:&lt;?phpSanctum::actingAs( User::factory()-&gt;create(), [&#x27;*&#x27;]); Answer:使用 Sanctum 的 testing feature, 透過 User factory 建立一個 user 並給予所有權限","link":"/zh-tw/laravel-packages-sanctum/"},{"title":"Laravel - Packages - Socialite","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Installation以下的 Laravel example code 的意思是？ Example:composer require laravel/socialite Answer:安裝 Socialite 以下位於 config/services.php 的 Laravel example code 的意思是？ Example:&#x27;github&#x27; =&gt; [ &#x27;client_id&#x27; =&gt; env(&#x27;GITHUB_CLIENT_ID&#x27;), &#x27;client_secret&#x27; =&gt; env(&#x27;GITHUB_CLIENT_SECRET&#x27;), &#x27;redirect&#x27; =&gt; &#x27;http://example.com/callback-url&#x27;,], Answer:輸入各服務的 config key 供 Socialite 使用 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Laravel\\Socialite\\Facades\\Socialite;Route::get(&#x27;/auth/redirect&#x27;, function () &#123; return Socialite::driver(&#x27;github&#x27;) -&gt;with([&#x27;foo&#x27; =&gt; &#x27;bar&#x27;]) -&gt;redirect();&#125;);Route::get(&#x27;/auth/callback&#x27;, function () &#123; $user = Socialite::driver(&#x27;github&#x27;)-&gt;user(); // $user-&gt;token&#125;); Answer:使用 Socialite 實作 OAuth 驗證使用 redirect() 導向 github 登入頁面使用 with 帶入 optional parameter使用 user() 取得 authenticated user info, callback 需為 services.php 中設定的 callback url 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Laravel\\Socialite\\Facades\\Socialite;return Socialite::driver(&#x27;github&#x27;) -&gt;scopes([&#x27;read:user&#x27;, &#x27;public_repo&#x27;]) -&gt;redirect(); Answer:使用 scopes() 新增 scope 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn Socialite::driver(&#x27;github&#x27;) -&gt;setScopes([&#x27;read:user&#x27;, &#x27;public_repo&#x27;]) -&gt;redirect(); Answer:使用 scopes() 重寫 scope, 會覆蓋原本的 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/auth/callback&#x27;, function () &#123; $user = Socialite::driver(&#x27;github&#x27;)-&gt;user(); // OAuth 2.0 providers... $token = $user-&gt;token; $refreshToken = $user-&gt;refreshToken; $expiresIn = $user-&gt;expiresIn; // OAuth 1.0 providers... $token = $user-&gt;token; $tokenSecret = $user-&gt;tokenSecret; // All providers... $user-&gt;getId(); $user-&gt;getNickname(); $user-&gt;getName(); $user-&gt;getEmail(); $user-&gt;getAvatar();&#125;); Answer:使用 Socialite 提供的 method 來取得 user 的各項資訊 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Laravel\\Socialite\\Facades\\Socialite;$user = Socialite::driver(&#x27;github&#x27;)-&gt;userFromToken($token); Answer:使用 userFromToken() 從 token 取得 user info (OAuth2) 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Laravel\\Socialite\\Facades\\Socialite;$user = Socialite::driver(&#x27;twitter&#x27;)-&gt;userFromTokenAndSecret($token, $secret); Answer:使用 userFromTokenAndSecret() 從 token 以及 secret 取得 user info (OAuth1)","link":"/zh-tw/laravel-packages-socialite/"},{"title":"Laravel - Package - Telescope (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Installation以下的 Laravel example code 的意思是？ Example:&lt;?phpcomposer require laravel/telescopephp artisan telescope:installphp artisan migrate Answer:安裝 telescope 套件安裝相關 UImigrate 資料庫 以下的 Laravel example code 的意思是？ Example:// terminalcomposer require laravel/telescope --devphp artisan telescope:installphp artisan migrate// AppServiceProviderpublic function register()&#123; if ($this-&gt;app-&gt;environment(&#x27;local&#x27;)) &#123; $this-&gt;app-&gt;register(\\Laravel\\Telescope\\TelescopeServiceProvider::class); $this-&gt;app-&gt;register(TelescopeServiceProvider::class); &#125;&#125;// composer.json&quot;extra&quot;: &#123; &quot;laravel&quot;: &#123; &quot;dont-discover&quot;: [ &quot;laravel/telescope&quot; ] &#125;&#125;, Answer:若只要安裝 telescope 在 dev要從 config/app.php 當中移除 telescope service provider在 AppServiceProvider 中另行註冊修改 composer.json 避免 auto-discover # Configuration以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_ENABLED&#x27;, true), Answer:可使用 env 來決定是否 enable Telescope更多設定可參考 config/telescope.php # Data Pruning以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;telescope:prune&#x27;)-&gt;daily(); Answer:定義一個 scheduled task, 每天清空 telescope 的紀錄 以下的 Laravel example code 的意思是？ Example:&lt;?php$schedule-&gt;command(&#x27;telescope:prune --hours=48&#x27;)-&gt;daily(); Answer:定義一個 scheduled task, 每天清空 telescope 48 小時前的紀錄 以下的 Laravel example code 的意思是？ Example:&lt;?php&#123; &quot;scripts&quot;: &#123; &quot;post-update-cmd&quot;: [ &quot;@php artisan telescope:publish --ansi&quot; ] &#125;&#125; Answer:當更新 Laravel Telescope 後, 務必要 re-publish Telescope’s asserts, 可以寫在 composer.json 中, 以免忘記 # Filtering以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function register()&#123; $this-&gt;hideSensitiveRequestDetails(); Telescope::filter(function (IncomingEntry $entry) &#123; if ($this-&gt;app-&gt;environment(&#x27;local&#x27;)) &#123; return true; &#125; return $entry-&gt;isReportableException() || $entry-&gt;isFailedJob() || $entry-&gt;isScheduledTask() || $entry-&gt;hasMonitoredTag(); &#125;);&#125; Answer:TelescopeServiceProvider 中的 Telescope::filter(), 可以定義哪些要 record, 哪些不要在 local env 下會 record 所有紀錄, 其他 env 會 record failed job, reportable exception, scheduled task, 以及 monitored tag, 可自定義 # Batches以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Collection;public function register()&#123; $this-&gt;hideSensitiveRequestDetails(); Telescope::filterBatch(function (Collection $entries) &#123; if ($this-&gt;app-&gt;environment(&#x27;local&#x27;)) &#123; return true; &#125; return $entries-&gt;contains(function ($entry) &#123; return $entry-&gt;isReportableException() || $entry-&gt;isFailedJob() || $entry-&gt;isScheduledTask() || $entry-&gt;hasMonitoredTag(); &#125;); &#125;);&#125; Answer:filter 只可 filter 單筆資料, 假如今天有一個 request 出了一個 exception, 而我想將該次 request 的所有資料都記錄下來, 那就可以使用 filterBatch 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function register()&#123; $this-&gt;hideSensitiveRequestDetails(); Telescope::tag(function (IncomingEntry $entry) &#123; return $entry-&gt;type === &#x27;request&#x27; ? [&#x27;status:&#x27;.$entry-&gt;content[&#x27;response_status&#x27;]] : []; &#125;); &#125; Answer:當使用 Telescope 時, 一般會自動為 entry 加上預設的 tag, 但若要自己加入 tag, 可在 TelescopeServiceProvider 的 register() 中, 使用 tag method, tag method 接受一個 closure, closure 回傳的 tag 會被 telescope 一起 attach 到該 entry # Available Watchers以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\CacheWatcher::class =&gt; true, Watchers\\CommandWatcher::class =&gt; true, ...], Answer:在 config/telescope 中, 可在 watchers array 指定哪些 watcher 要打開, 每個 watcher 都針對 Laravel 的一個模組, 像是 Cache, Command, Queue 等等 以下的 Laravel Telescope example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\QueryWatcher::class =&gt; [ &#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_QUERY_WATCHER&#x27;, true), &#x27;slow&#x27; =&gt; 100, ], ...], Answer:Telescope 中, 有些 watcher 提供額外選項 # Batch WatcherLaravel Telescope 的 Batch Watcher 紀錄了什麼？batch watcher 紀錄了 Laravel Queue Batch 的資料 # Cache WatcherLaravel Telescope 的 Cache Watcher 紀錄了什麼？當 cache key 被 hit, missed, updated, 或 forgotten, 會被記錄下來 # Command WatcherLaravel Telescope 的 Command Watcher 紀錄了什麼？command 的 arguments, options, exit code, output 以下的 Laravel Telescope example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\CommandWatcher::class =&gt; [ &#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_COMMAND_WATCHER&#x27;, true), &#x27;ignore&#x27; =&gt; [&#x27;key:generate&#x27;], ], ...], Answer:可在 config 中, 指定哪一些 command 不要被 record # Dump WatcherLaravel Telescope 的 Dump Watcher 紀錄了什麼？紀錄 dump 資訊 # Event WatcherLaravel Telescope 的 Event Watcher 紀錄了什麼？會紀錄 event 的 listener, payload, 以及 broadcast data, 但 Laravel 內部的 event 會被 ignore # Exception WatcherLaravel Telescope 的 Exception Watcher 紀錄了什麼？紀錄了 exception 的 data 以及 stack trace # Gate WatcherLaravel Telescope 的 Gate Watcher 紀錄了什麼？紀錄了 gate 以及 policy 的檢查結果以及其 data 以下的 Laravel Telescope example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\GateWatcher::class =&gt; [ &#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_GATE_WATCHER&#x27;, true), &#x27;ignore_abilities&#x27; =&gt; [&#x27;viewNova&#x27;], ], ...], Answer:可在 GateWatcher 中定義, 哪些 gate 是要 ignore 的 # Job WatcherLaravel Telescope 的 Job Watcher 紀錄了什麼？任何被 dispatched jon 的 data and status # Log WatcherLaravel Telescope 的 Log Watcher 紀錄了什麼？任何 Application 所寫下的 log # Mail WatcherLaravel Telescope 的 Mail Watcher 紀錄了什麼？Mail watcher 允許用瀏覽器來 preview sent emails 以及 associated data, 也可下載 .eml file # Model Watcher以下的 Laravel Telescope example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\ModelWatcher::class =&gt; [ &#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_MODEL_WATCHER&#x27;, true), &#x27;events&#x27; =&gt; [&#x27;eloquent.created*&#x27;, &#x27;eloquent.updated*&#x27;], ], ...], Answer:可在 Model Watcher 指定要記錄哪一些 model event 的資料 以下的 Laravel Telescope example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\ModelWatcher::class =&gt; [ &#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_MODEL_WATCHER&#x27;, true), &#x27;events&#x27; =&gt; [&#x27;eloquent.created*&#x27;, &#x27;eloquent.updated*&#x27;], &#x27;hydrations&#x27; =&gt; true, ], ...], Answer:Model Watcher 也可啟用 hydrations option # Notification WatcherLaravel Telescope 的 Notification Watcher 紀錄了什麼？記錄所有的 notification # Query Watcher以下的 Laravel Telescope example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\QueryWatcher::class =&gt; [ &#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_QUERY_WATCHER&#x27;, true), &#x27;slow&#x27; =&gt; 50, ], ...], Answer:Query Watcher 會紀錄下每個 query 的 raw SQL, bindings, 以及 executing time, 超過 100ms 的會被 tag slow, 可在 config 自定義 slow 的標準 # Redis WatcherLaravel Telescope 的 Redis Watcher 紀錄了什麼？記錄所有被執行的 redis commands # Request Watcher以下的 Laravel Telescope example code 的意思是？ Example:&lt;?php&#x27;watchers&#x27; =&gt; [ Watchers\\RequestWatcher::class =&gt; [ &#x27;enabled&#x27; =&gt; env(&#x27;TELESCOPE_REQUEST_WATCHER&#x27;, true), &#x27;size_limit&#x27; =&gt; env(&#x27;TELESCOPE_RESPONSE_SIZE_LIMIT&#x27;, 64), ], ...], Answer:Request Watcher 預設會紀錄每一個 request, 以及其 headers, session, 以及 response, 可透過 size_limit (kilobytes) 參數來限制大小 # Schedule WatcherLaravel Telescope 的 Schedule Watcher 紀錄了什麼？scheduled tasks 以及其 output # View WatcherLaravel Telescope 的 View Watcher 紀錄了什麼？view name, path, data, 以及 render 時用到的 composers # Displaying User Avatars以下的 Laravel Telescope example code 的意思是？ Example:&lt;?phppublic function register()&#123; // ... Telescope::avatar(function ($id, $email) &#123; return &#x27;/avatars/&#x27;.User::find($id)-&gt;avatar_path; &#125;);&#125; Answer:Telescope 預設使用 Gravatar 來顯示 user avatar, 也可在 TelescopeServiceProvider 的 register() 中, 使用 Telescope::avatar 來 return 一個 user avatar image url # 修改成 JWT 驗證# 新增 Admin model, migrationphp artisan make:model Admin -m # 修改 Admin model需 extend authenticatable, implement JWTSubjectJWT 部分可參考 文件 # 新增 Admins guard, Admins providerJWT 部分可參考 文件 # 新增 middlewarepublic function handle(Request $request, Closure $next)&#123; $response = $next($request); if ($request-&gt;route()-&gt;getName() != &#x27;telescope&#x27;) &#123; return $response; &#125; if ($request-&gt;cookie(&#x27;token&#x27;)) &#123; return $response; &#125; if (empty($token = $request-&gt;input(&#x27;token&#x27;))) &#123; return $response; &#125; $payload = JWTAuth::setToken($token)-&gt;getPayload(); $exp = $payload-&gt;get(&#x27;exp&#x27;); $minutes = floor(($exp - time()) / 60); $response = $next($request); $response-&gt;withCookie(cookie(&#x27;token&#x27;, $token, $minutes)); return $response;&#125; # 修改 Telescope config加上剛剛建立的 middleware, 並且將 ‘web’ 改成 auth middleware 並指定 guard &#x27;middleware&#x27; =&gt; [// &#x27;web&#x27;, \\App\\Http\\Middleware\\AppendTokenForTelescope::class, &#x27;auth:admins&#x27;, Authorize::class, ], # 修改 TelescopeServiceProvider這邊可自訂規則 protected function gate()&#123; Gate::define(&#x27;viewTelescope&#x27;, function (UserInterface $user) &#123; return $user-&gt;isAdmin(); &#125;);&#125; # 建立 Admin login API# 在資料庫中新增帳號密碼# 登入以取得 token# 測試輸入 https://projectName/telescope?token=yourToken在 production 環境也可存取 Telescope","link":"/zh-tw/laravel-packages-telescope/"},{"title":"Laravel - QRCODE","text":"# IntroductionLaravel QR code 相關 # QR code 上加入文字# 產生 QR code使用 Laravel simple qrcode package 產生 qrcode這邊的 size 以及 margin 會隨著 text size 而變動, 因為 image 的 size 太小, 可能 text 會看不清楚, 而 margin 太小, text 可能會破版或與 qr code 重疊, 因此視需求調整 &lt;?php$qrCode = QrCode::format(&#x27;png&#x27;)-&gt;size($size)-&gt;margin($margin)-&gt;generate($url); # 從 image string 產生 PHP image resource使用 imagecreatefromstring() 輸入 image string 取得 PHP image resource 做後續使用 &lt;?php$qrCode = imagecreatefromstring($qrCode); # 取得 font file會使用 PHP 的 imagettftext(), 因此會用到 font file, 可到網上找一個免費可供商用的 font file &lt;?php$fontFile = public_path(&#x27;webfonts/TaipeiSans.ttf&#x27;); # 定義 text color會使用 PHP 的 imagecolorallocate(), 來取得指定 image 當中的顏色代碼, $qrcode 為要將 text 插入的 imagecolor 為 RGB 代碼, 會輸出一個專屬於該 image 的 color code &lt;?php$color = $input-&gt;has([&#x27;text-color&#x27;]) ? $input[&#x27;text-color&#x27;] : [0, 0, 0];$textColor = imagecolorallocate($qrCode, ...$color); # 取得 text 座標使用 imagettfbbox() 來取得該 text 方塊的座標資訊, 即大小$textSize: 為 text 的大小$angle: 為傾斜度, 預設為 0, 如果要讓 text 是歪的, 就要調整, value 越大傾斜度越大$fontFile: 上面取得的 font filetext: 欲顯示的 text string &lt;?php$textCoordinates = imagettfbbox($textSize, $angle, $fontFile, $text); 回傳值會是一個 size 8 的 array, 分別為該 text 的座標, 依序為0 = 左下 x1 = 左下 y2 = 右下 x3 = 右下 y4 = 右上 x5 = 右上 y6 = 左上 x7 = 左上 y # 取得 text 方塊的長寬想像一下, 當我們有了一個長方形的四個點的座標, 是不是就能算出該長方形的長寬 &lt;?php$textWidth = $textCoordinates[2] - $textCoordinates[0];$textHeight = $textCoordinates[1] - $textCoordinates[7]; # 取得 image 的長寬使用 imagesx(), imagesy() 來取得 image 的 height 以及 width $imageWidth = imagesx($qrCode);$imageHeight = imagesy($qrCode); # 計算 text 方塊置於 image 中的位置PHP imagettftext() 可以定義一個 text 方塊在指定 image 當中的位置, 而我們有了 image 以及 text 方塊的長寬, 就可以透過計算取得 text 方塊應置於 image 當中的座標點我們的目標, 是要 text 方塊置於 image 的下方且置中所以 image 的一半寬, 再扣掉 text 方塊的一半寬, 會是 text 方塊放置的 x 座標點y 座標點則簡單地減去高度即可 x 越小, 則位置在 image 中越靠左, 反之則越靠右y 越小, 則位置在 image 中越靠上, 反之則越靠下 &lt;?php$x = ($imageWidth / 2) - ($textWidth / 2);$y = $imageHeight - $textHeight;imagettftext($qrCode, $textSize, $angle, $x, $y, $textColor, $fontFile, $text); # 不儲存圖片直接串流下載使用 Laravel Response facade 的 streamDownload() 直接印出 image string 觸發下載 &lt;?phpreturn \\Illuminate\\Support\\Facades\\Response::streamDownload(function () use ($qrCode) &#123; echo imagepng($qrCode);&#125;, &#x27;qrcode.png&#x27;); # 完整 example&lt;?phppublic function download(QrcodeDownloadRequest $request)&#123; $input = collect($request-&gt;validated()); $margin = $input-&gt;has([&#x27;margin&#x27;]) ? $input[&#x27;margin&#x27;] : 4; $size = $input-&gt;has([&#x27;size&#x27;]) ? $input[&#x27;size&#x27;] : config(&#x27;app.qrcode_size_for_download&#x27;); $url = $input[&#x27;url&#x27;]; $qrCode = QrCode::format(&#x27;png&#x27;)-&gt;size($size)-&gt;margin($margin)-&gt;generate($url); $qrCode = imagecreatefromstring($qrCode); if ($input-&gt;has(&#x27;text&#x27;)) &#123; $this-&gt;insertText($qrCode, $input); &#125; return \\Illuminate\\Support\\Facades\\Response::streamDownload(function () use ($qrCode) &#123; echo imagepng($qrCode); &#125;, &#x27;qrcode.png&#x27;);&#125;private function insertText($qrCode, Collection $input): void&#123; $fontFile = public_path(&#x27;webfonts/TaipeiSans.ttf&#x27;); $text = $input[&#x27;text&#x27;]; $color = $input-&gt;has([&#x27;text-color&#x27;]) ? $input[&#x27;text-color&#x27;] : [0, 0, 0]; $angle = $input-&gt;has(&#x27;text-angle&#x27;) ? $input[&#x27;text-angle&#x27;] : 0; $textSize = $input-&gt;has([&#x27;text-size&#x27;]) ? $input[&#x27;text-size&#x27;] : 8; $textColor = imagecolorallocate($qrCode, ...$color); $textCoordinates = imagettfbbox($textSize, $angle, $fontFile, $text); $imageWidth = imagesx($qrCode); $imageHeight = imagesy($qrCode); $textWidth = $textCoordinates[2] - $textCoordinates[0]; $textHeight = $textCoordinates[1] - $textCoordinates[7]; $x = ($imageWidth / 2) - ($textWidth / 2); $y = $imageHeight - $textHeight; imagettftext($qrCode, $textSize, $angle, $x, $y, $textColor, $fontFile, $text);&#125;","link":"/zh-tw/laravel-qrcode/"},{"title":"Laravel - Security - Authorization (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Gates# Writing GatesLaravel Authentication 中, 主要有哪兩種 authorization 方式？gates and policies 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; $this-&gt;registerPolicies(); Gate::define(&#x27;edit-settings&#x27;, function ($user) &#123; return $user-&gt;isAdmin; &#125;);&#125; Answer:在 AuthServiceProvider 的 boot() 當中, 使用 Gate::define 定義一個名為 &#39;edit-settings&#39; 的 closure gate 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; $this-&gt;registerPolicies(); Gate::define(&#x27;update-post&#x27;, &#x27;class@method&#x27;);&#125; Answer:在定義一個 Gate closure based rule 時, 也可以選擇由指定的 class@method 來執行驗證邏輯 # Authorizing ActionsLaravel Authentication 中, 當我使用 Gate 時, 需要帶入 current $user 嗎？不需要 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Gate::allows(&#x27;update-post&#x27;, $post)) &#123; // The current user can update the post...&#125; Answer:判斷當前 authenticated user 是否被允許 update $post, 會調用該 &#39;update-post&#39; closure gate 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Gate::denies(&#x27;update-post&#x27;, $post)) &#123; // The current user can&#x27;t update the post...&#125; Answer:判斷當前 authenticated user 是否不被允許 update $post, 會 closure gate update-post 的驗證邏輯 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Gate::forUser($user)-&gt;allows(&#x27;update-post&#x27;, $post)) &#123; // The user can update the post...&#125; Answer:判斷 $user 是否 被允許 update $post, 會執行 update-post 這個 closure gate 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Gate::any([&#x27;update-post&#x27;, &#x27;delete-post&#x27;], $post)) &#123; // The user can update or delete the post&#125; Answer:判斷當前 authenticated user 是否 被允許 update $post 或 delete $post, 會執行 update-post 以及 delete-post 這兩個 closure gate 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Gate::none([&#x27;update-post&#x27;, &#x27;delete-post&#x27;], $post)) &#123; // The user cannot update or delete the post&#125; Answer:判斷當前 authenticated user 是否 皆不被允許 update $post 以及 delete $post, 會執行 update-post 以及 delete-post closure gate # Authorizing Or Throwing Exceptions以下的 Laravel example code 的意思是？ Example:&lt;?phpGate::authorize(&#x27;update-post&#x27;, $post);// The action is authorized... Answer:當 current authenticated user 不具有 update-post 的權限時, throw 403 exception 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Gate::check(&#x27;create-post&#x27;, [$category, $extraFlag])) &#123; // The user can create the post...&#125; Answer:判斷當前 authenticated user 是否 被允許 create posts, 可使用 array 帶入複數的 parameters # Gate Responses以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Auth\\Access\\Response;use Illuminate\\Support\\Facades\\Gate;Gate::define(&#x27;edit-settings&#x27;, function ($user) &#123; return $user-&gt;isAdmin ? Response::allow() : Response::deny(&#x27;You must be a super administrator.&#x27;);&#125;); Answer:定義一個名為 ‘edit-settings’ 的 gate, 套用後, 如果 $user 為 admin 就允許, 如果不是則 deny 並 return deny message 以下的 Laravel example code 的意思是? Example:&lt;?php$response = Gate::inspect(&#x27;edit-settings&#x27;, $post);if ($response-&gt;allowed()) &#123; // The action is authorized...&#125; else &#123; echo $response-&gt;message();&#125; Answer:取得 Gate 回傳的完整 authorization response # Intercepting Gate Checks以下的 Laravel example code 的意思是？ Example:&lt;?phpGate::before(function ($user, $ability) &#123; if ($user-&gt;isSuperAdmin()) &#123; return true; &#125;&#125;); Answer:訂一個規則, 會在執行所有 Gate rule 之前先執行它, 比如說我要讓 superAdmin 有所有的權限 以下的 Laravel example code 的意思是？ Example:&lt;?phpGate::after(function ($user, $ability, $result, $arguments) &#123; if ($user-&gt;isSuperAdmin()) &#123; return true; &#125;&#125;); Answer:會在所有的 gate rule 執行完畢後, 才會執行 after 內定義的規則, 比如說, 我要先驗證一些必要驗證, 最後在驗證該使用者是否為 admin # Creating Policies# Generating PoliciesLaravel Authentication 中, 使用 CLI 建立的 policy 會位於哪裡？app/Policies 資料夾 以下的 Laravel example command 的意思是？ Example:php artisan make:policy PolicyName --model=ModelName Answer:使用 CLI 建立一個 policy 並且指定 model # Registering PoliciesLaravel Authentication 中, 當我建立了 policy 之後, 我需要在哪一個檔案中註冊它AuthServiceProvider.php 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use App\\Policies\\PostPolicy;use App\\Post;use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;use Illuminate\\Support\\Facades\\Gate;class AuthServiceProvider extends ServiceProvider&#123; protected $policies = [ Post::class =&gt; PostPolicy::class, ]; public function boot() &#123; $this-&gt;registerPolicies(); // &#125;&#125; Answer:在 AuthServiceProvider 的 policies property 中給 model 註冊 policy # Policy Auto-DiscoveryLaravel Authentication 中, 如果我不想要每次都手動註冊 policy, 我想要使用 Laravel 預設的 auto-discovery, 假設 model name 為 User, 那該 Policy name 須為？UserPolicy 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Gate;Gate::guessPolicyNamesUsing(function ($modelClass) &#123; // return policy class name...&#125;); Answer:Laravel 預設的 auto-discovery 的 convention 為 modelNamePolicyName, 假如 model 為 User, 那符合 auto-discovery 的命名規則為 UserPolicy可在 AuthServiceProvider 的 boot(), 使用 Gate::guessPolicyNamesUsing method 變更預設的 convention Laravel Authentication 中, 當我同時使用手動註冊 policy 以及 auto-discovery policy 時, 哪一個的優先順序較高？手動註冊 # Writing Policies# Policy Methods以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Policies;use App\\Post;use App\\User;class PostPolicy&#123; public function update(User $user, Post $post) &#123; return $user-&gt;id === $post-&gt;user_id; &#125;&#125; Answer:定義 PostPolicy 的 update method, 定義 user 是否有 update 該 post 的權限 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Policies;use App\\Post;use App\\User;class PostPolicy&#123; public function update(User $user, Post $post) &#123; return $user-&gt;id === $post-&gt;user_id; &#125;&#125; Answer:在 PostPolicy class, update method 中定義 $user 是否被允許 update $post # Policy Responses以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Auth\\Access\\Response;public function update(User $user, Post $post)&#123; return $user-&gt;id === $post-&gt;user_id ? Response::allow() : Response::deny(&#x27;You do not own this post.&#x27;);&#125; Answer:&lt;?php// 在 policy class 中, 定義 允許, 不被允許 的 responseuse Illuminate\\Auth\\Access\\Response;public function update(User $user, Post $post)&#123; return $user-&gt;id === $post-&gt;user_id // 允許則回覆 boolean true ? Response::allow() // 不允許則回傳 403, message : Response::deny(&#x27;You do not own this post.&#x27;);&#125; Laravel Authentication 中, 根據官方文件描述, 我可以使用 Gate::inspect method 來取得 policy 的 authorization response 嗎？可以 # Methods Without Models以下的 Laravel example code 的意思是？ Example:&lt;?php// 在 policy class 中public function create(User $user)&#123; //&#125; Answer:由於 create() 並不需要 model parameter, 因此使用 User $user 即可 # Guest UsersLaravel Authentication 中, 預設在 policy 以及 gate 如果沒有初始化一個 authenticated user 的話, authorization 會 return 什麼？false Laravel Authentication 中, 預設在 policy 以及 gate 如果沒有初始化一個 authenticated user 的話, 會 return false, 如果我想要讓沒有 authenticated user 也可以通過 authorization check 的話, 有哪兩種方式？？ optional type hint return null # Policy Filters以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function before($user, $ability)&#123; return false;&#125; Answer:在執行所有 policy 之前會先執行 before, 換言之, 以上的 example 總是會 return false, 代表任何 policy 都不可能會驗證通過比方說, 如果原本 $user-&gt;can(&#39;show&#39;, $post) 是 true, 加上上面的 example 之後, 就會 return false Laravel Authentication 中, 當我在 policy 中定義一個 before method 時, 如果該 policy class 中沒有任何 method 被呼叫, 那 before method 會被呼叫嗎？不會哦 # Authorizing Actions Using Polices# Via The User Model以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($user-&gt;can(&#x27;update&#x27;, $post)) &#123; //&#125; Answer:使用 can() 判斷 $user 是否有 update $post 的權限, 會調用 PostPolicy Laravel Authentication 中, 當我使用 can method 如下 example 時, 如果說我並沒有註冊這個 policy, 那 Laravel 會怎麼做？尋找 closure based Gate # Actions That Don’t Require Models以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Post;if ($user-&gt;can(&#x27;create&#x27;, Post::class)) &#123; // Executes the &quot;create&quot; method on the relevant policy...&#125; Answer:使用 can() 驗證 $user 是否可以在 Post model 中, 有 create 的權限, 如果是 update 類型的 method 會需要帶入指定的 $model, 因為 create 是不需要帶入指定的 $model 的, 所以帶入 Post model 的完整 class name 即可 # Via Middleware以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Post;Route::put(&#x27;/post/&#123;post&#125;&#x27;, function (Post $post) &#123; // The current user may update the post...&#125;)-&gt;middleware(&#x27;can:update,post&#x27;); Answer:使用 can middleware 驗證發 request 的 user 是否具有 update 該 post model 的權限, 第一個 arg 為 update 權限, 會執行 post policy 的 update method, 第二個 ‘post’ 為 url parameter 中帶入的該 post model, update method 會判斷該 user 是否有權限 update 該 post model # Actions That Don’t Require Models以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::post(&#x27;/post&#x27;, function () &#123; // The current user may create posts...&#125;)-&gt;middleware(&#x27;can:create,App\\Post&#x27;); Answer:使用 can middleware 驗證 $user 是否可以在 Post model 中, 有 create 的權限, 如果是 update 類型的 method 會需要帶入指定的 $model, 因為 create 是不需要帶入指定的 $model 的, 所以帶入 Post model 的完整 class name 即可 # Via Controller Helpers以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Post;use Illuminate\\Http\\Request;class PostController extends Controller&#123; public function update(Request $request, Post $post) &#123; $this-&gt;authorize(&#x27;update&#x27;, $post); // The current user can update the blog post... &#125;&#125; Answer:使用 authorize method, 會根據定義的 policy 判斷該 authenticated user 是否有 update 該 $post 的權限, 如果不允許, 會 throw 403 # Action That Don’t Require Models以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function create(Request $request)&#123; $this-&gt;authorize(&#x27;create&#x27;, Post::class); // The current user can create blog posts...&#125; Answer:使用 authorize(), 驗證 authenticated user 是否可以在 Post model 有 create 的操作權限, 該邏輯判斷定義在 PostPolicy, 若不可會直接 throw 403 # Authorizing Resource Controllers以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Post;use Illuminate\\Http\\Request;class PostController extends Controller&#123; public function __construct() &#123; $this-&gt;authorizeResource(Post::class, &#x27;post&#x27;); &#125;&#125; Answer:在 controller 的 construct() 中使用 authorizeResource(), arg1 為 policy model class name, arg2 為 url parameter $post, 會自動將 authorize 套用到該 Resource Controller 中的每個 method # Via Blade Templates以下的 Laravel example code 的意思是？ Example:&lt;?php@can(&#x27;update&#x27;, $post) &lt;!-- The Current User Can Update The Post --&gt;@elsecan(&#x27;create&#x27;, App\\Post::class) &lt;!-- The Current User Can Create New Post --&gt;@endcan Answer:在 Blade 中判斷 current user 是否 被允許 update 該 $post 的權限, 驗證邏輯定義在 PostPolicy class 以下的 Laravel example code 的意思是？ Example:&lt;?php@cannot(&#x27;update&#x27;, $post) &lt;!-- The Current User Cannot Update The Post --&gt;@elsecannot(&#x27;create&#x27;, App\\Post::class) &lt;!-- The Current User Cannot Create A New Post --&gt;@endcannot Answer:在 Blade 中判斷 current user 是否 不被允許 update 該 $post 的權限, 是否 不被允許 在 Post model 執行 ‘create’ 的操作, 驗證邏輯定義在 PostPolicy class Laravel Authentication 中, 以下的 blade template example 實際上是什麼的縮寫？ Example:&lt;?php@can(&#x27;update&#x27;, $post) &lt;!-- The Current User Can Update The Post --&gt;@endcan@cannot(&#x27;update&#x27;, $post) &lt;!-- The Current User Cannot Update The Post --&gt;@endcannot Answer:&lt;?php@if (Auth::user()-&gt;can(&#x27;update&#x27;, $post)) &lt;!-- The Current User Can Update The Post --&gt;@endif@unless (Auth::user()-&gt;can(&#x27;update&#x27;, $post)) &lt;!-- The Current User Cannot Update The Post --&gt;@endunless 以下的 Laravel example code 的意思是？ Example:&lt;?php@canany([&#x27;update&#x27;, &#x27;view&#x27;, &#x27;delete&#x27;], $post) // The current user can update, view, or delete the post@elsecanany([&#x27;create&#x27;], \\App\\Post::class) // The current user can create a post@endcanany Answer:判斷 current user 是否 被允許 update 或 view 或 delete $post model, 任意一項都算判斷 current user 是否 被允許 在 Post model 中實施 create 的操作以上的權限邏輯都定義在 PostPolicy # Actions That Don’t Require Models以下的 Laravel example code 的意思是？ Example:&lt;?php@can(&#x27;create&#x27;, App\\Post::class) &lt;!-- The Current User Can Create Posts --&gt;@endcan@cannot(&#x27;create&#x27;, App\\Post::class) &lt;!-- The Current User Can&#x27;t Create Posts --&gt;@endcannot Answer:使用 Blade authorization method判斷 current user 是否 被允許 對 Post model 操作 create 的權限判斷 current user 是否 不被允許 對 Post model 操作 create 的權限驗證邏輯會使用定義好的 policy # Supplying Additional ContextLaravel Authentication 中, 在定義 policy 時, 如果除了 user 以及 model 之外, 我還要帶入額外的參數來驗證, 在以下的 example 中, 參數可以帶在哪？ Example:&lt;?phppublic function update(User $user, Post $post, int $category)&#123; return $user-&gt;id === $post-&gt;user_id &amp;&amp; $category &gt; 3;&#125; Answer:定義 PostPolicy, 若有需要可帶入多個 args 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function update(Request $request, Post $post)&#123; $this-&gt;authorize(&#x27;update&#x27;, [$post, $request-&gt;input(&#x27;category&#x27;)]); // The current user can update the blog post...&#125; Answer:在 controller 的 update method 中, 使用 authorize() 來驗證 authenticated user 是否有 update 該 $post 的權限, 帶入兩個參數, 這兩個參數會被 pass 到 policy 或 closure based gate","link":"/zh-tw/laravel-security-authorization/"},{"title":"Laravel - Security - Authentication (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Introduction# Database ConsiderationsLaravel Authentication 中, 在建立 database schema for App\\User model 時, 務必確保 password 欄位要幾字元長？60 characters Laravel Authentication 中, 在建立 database schema for App\\User model 時, 務必確保 remember_token 欄位要幾字元長？100 characters # Authentication Quickstart# RoutingLaravel Authentication 中, 如果我要快速開始 Authentication, 可以什麼 CLI 直接安裝註冊登入功能？composer require laravel/uiphp artisan ui vue --auth Laravel Authentication 中, 以下 CLI 會自動產生哪一個 controller 來處理登入後的請求? CLI:composer require laravel/uiphp artisan ui vue --auth Answer: HomeController Laravel Authentication 中, 當我使用 CLI 來達成 Authentication Quickstart 時, 自動建立的 authentication controllers 會被建立在哪個 namespace 底下？App\\Http\\Controllers\\Auth Laravel Authentication 中, 當我使用 CLI 來達成 Authentication Quickstart 時, 自動建立的 RegisterController 處理什麼工作？註冊 Laravel Authentication 中, 當我使用 CLI 來達成 Authentication Quickstart 時, 自動建立的 LoginController 處理什麼工作？登入 Laravel Authentication 中, 當我使用 CLI 來達成 Authentication Quickstart 時, 自動建立的 ForgotPasswordController 處理什麼工作？發送 email 連結重設密碼 Laravel Authentication 中, 當我使用 CLI 來達成 Authentication Quickstart 時, 自動建立的 ResetPassword 處理什麼工作？重設密碼 以下的 Laravel example code 的意思是？ Example:&lt;?phpAuth::routes([&#x27;register&#x27; =&gt; false]); Answer:不使用 Scaffolding 的 RegisterController # Creating Applications Including Authentication以下的 Laravel example code 的意思是？ Example:laravel new projectName --auth Answer:建立新專案時, 一同建立 authentication scaffolding # ViewsLaravel Authentication 中, 使用 authentication scaffolding 建立的 view 會位於哪個資料夾內？resources/views/auth Laravel Authentication 中, 以下的 CLI 會將 base layouts 置於死地哪個資料夾中？resources/views/layouts # Authenticating# Path CustomizationLaravel Authentication 中, 當我使用 authentication scaffolding 時, 預設驗證成功的使用會被導向 /home URI, 如果我要重新定義成 /yourHome, 那該在哪一個檔案中定義？RouteServiceProvider 以下位於 RouteServiceProvider 的 Laravel example code 的意思是？ Example:&lt;?phppublic const HOME = &#x27;/yourHome&#x27;; Answer:Laravel Authentication 中, 當我使用 authentication scaffolding 時, 預設驗證成功的使用會被導向 /home URI, 可在 RouteServiceProvider 的 HOME property 定義要導向的位置 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass RouteServiceProvider extends ServiceProvider&#123; protected function authenticated(Request $request, $user) &#123; return response([ // ]); &#125;&#125; Answer:當使用 authentication scaffolding 時, 預設登入驗證成功後, user 會被導向 /home URI, 如果想要自己定義驗證成功後的行為, 可使用 RouteServiceProvider 的 authenticated method # Username Customization以下的 Laravel example code 的意思是? Example:&lt;?phppublic function username()&#123; return &#x27;name&#x27;;&#125; Answer:當使用 Laravel Authentication scaffolding 時, 會使用 email 以及 password 欄位作為預設驗證欄位, 可使用 LoginController 中的 username(), 將 email 變更為任何你自訂的欄位 # Guard Customization以下位於 Scaffolding - LoginController, RegisterController, ResetPasswordController 的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Auth;protected function guard()&#123; return Auth::guard(&#x27;guard-name&#x27;);&#125; Answer:在這些 scaffolding controller 中定義 guard, 所以會在預設的行為中使用定義的 guard # Validation / Storage Customization以下位於 Authentication Scaffolding - RegisterController 的 Laravel example code 的意思是？ Example:&lt;?phpprotected function validator(array $data)&#123; return Validator::make($data, [ &#x27;name&#x27; =&gt; [&#x27;required&#x27;, &#x27;string&#x27;, &#x27;max:255&#x27;], &#x27;email&#x27; =&gt; [&#x27;required&#x27;, &#x27;string&#x27;, &#x27;email&#x27;, &#x27;max:255&#x27;, &#x27;unique:users&#x27;], &#x27;password&#x27; =&gt; [&#x27;required&#x27;, &#x27;string&#x27;, &#x27;min:6&#x27;, &#x27;confirmed&#x27;], ]);&#125; Answer:當使用 Authentication Scaffolding 時, 可在 RegisterController 的 validator method 定義註冊會員時需要什麼資料, 以及驗證的 rule 以下位於 Authentication Scaffolding - RegisterController 的 Laravel example code 的意思是？ Example:&lt;?phpprotected function create(array $data)&#123; $user = User::create([ &#x27;name&#x27; =&gt; $data[&#x27;name&#x27;], &#x27;email&#x27; =&gt; $data[&#x27;email&#x27;], &#x27;password&#x27; =&gt; Hash::make($data[&#x27;password&#x27;]), ]); Stats::create([ &#x27;user_id&#x27; =&gt; $user-&gt;id ]); return $user;&#125; Answer:當使用 Authentication Scaffolding 時, 可在 RegisterController 中定義如何 create 一個 user, 資料要怎麼存 # Retrieving The Authenticated UserLaravel 中, 以下三種取得 authenticated user 的效果一樣嗎？ Example:&lt;?phpauth()-&gt;user()Auth::user()$request-&gt;user() Answer:一樣 # Determining If The Current User Is Authenticated以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Auth;if (Auth::check()) &#123; // The user is logged in...&#125; Answer:判斷 current user 是否 authenticated, 回傳 boolean # Protecting Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;profile&#x27;, function () &#123; // Only authenticated users may enter...&#125;)-&gt;middleware(&#x27;auth&#x27;); Answer:使用 auth middleware 來驗證目標 url 為 ‘profile’ 的請求 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass PostContoller extends Controller&#123; public function __construct() &#123; $this-&gt;middleware(&#x27;auth&#x27;); &#125;&#125; Answer:在 PostController 當中使用 auth middleware # Redirecting Unauthenticated UsersLaravel Authentication 中, 預設會將 unauthenticated user 重導向 login route, 如果我要自定義這個動作, 可以修改哪個檔案？app/Http/Middleware/Authenticate.php # Specifying A Guard以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function __construct()&#123; $this-&gt;middleware(&#x27;auth:api&#x27;);&#125; Answer:指定 auth middleware 的 guard 為 api, 預設有 web 跟 api # Password Confirmation以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/settings/security&#x27;, function () &#123;&#125;)-&gt;middleware([&#x27;auth&#x27;, &#x27;password.confirm&#x27;]); Answer:當 user 發 request 到這支 API 時, 除了會判斷身份是否 authenticated 之外, 還會導向特定頁面, 再次輸入密碼後方可存取該頁面 Laravel Authentication 中, 若我使用內建的 password.confirm middleware 來重新驗證密碼, 驗證過後, 預設有效時間是多長？3 小時 Laravel Authentication 中, 若我使用內建的 password.confirm middleware 來重新驗證密碼, 驗證過後有效期限是 3 小時, 如果我要自定義這個時間, 可以在什麼地方定義？auth.password_timeout # Login ThrottlingLaravel Authentication Scaffolding 中, 預設使用者輸入幾次帳密都錯誤, 會被 throttle 限制多久無法再登入？1 分鐘 Laravel Authentication Scaffolding 中, throttle 會根據哪兩項資訊來判斷使用者的獨一性？ username / email IP # Manually Authenticating Users以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Auth;class LoginController extends Controller&#123; public function authenticate(Request $request) &#123; $credentials = $request-&gt;only(&#x27;email&#x27;, &#x27;password&#x27;); if (Auth::attempt($credentials)) &#123; // Authentication passed... return redirect()-&gt;intended(&#x27;dashboard&#x27;); &#125; &#125;&#125; Answer:使用 Auth::attempt() 來驗證 $credentials 是否正確, 如果正確的話, redirect 到 request 原本的目標 url Laravel Authentication 中, Auth::attempt() method 除了 username 以及 password 之外, 還可以接受其他參數嗎？可以哦, 會自動對應資料庫的 column # Specifying Additional Conditions以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Auth::attempt([&#x27;email&#x27; =&gt; $email, &#x27;password&#x27; =&gt; $password, &#x27;active&#x27; =&gt; 1])) &#123; // The user is active, not suspended, and exists.&#125; Answer:Auth::attempt() 除了可帶入預設 email, password 之外, 也可驗證其他 column # Accessing Specific Guard InstancesLaravel Authentication 中, 什麼情況下, 我們可能會需要用到不同的 guard?當我的應用同時使用不同的 authenticatable models 或 user table 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Auth::guard(&#x27;admin&#x27;)-&gt;attempt($credentials)) &#123; //&#125; Answer:guard 預設為 api 或 web, 也可自定義 guard, example 中指定使用 guard &#39;admin&#39; 來驗證 # Remembering Users以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Auth::attempt([&#x27;email&#x27; =&gt; $email, &#x27;password&#x27; =&gt; $password], true)) &#123; // The user is being remembered...&#125; Answer:使用 Auth::attempt() 驗證, 且當使用 web route 時, 可在 arg2 帶入 true 啟動 remember_me feature, 會在 table 記下 remember_token Laravel Authentication 中, 當我使用 remember me 功能時, Laravel 會在 User table 中的哪一個欄位記下 token?remember_token 以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Auth::viaRemember()) &#123; //&#125; Answer:判斷 user 是否經由 remember_me token authenticated # Other Authentication Methods# Authenticate A User InstanceLaravel Authentication 中, 如果我要登入一個 model, 該 model 必須要是哪個 class 的 implementation?Illuminate\\Contracts\\Auth\\Authenticatable 以下的 Laravel example code 的意思是？ Example:&lt;?phpAuth::login($user, true); Answer:使用 $user model login, 並開啟 remember_me feature 以下的 Laravel example code 的意思是？ Example:&lt;?phpAuth::guard(&#x27;admin&#x27;)-&gt;login($user, true); Answer:使用指定的 guard admin 來 authenticate, 使用 $user model 登入, 並開啟 remember_me feature # Authenticate A User By ID以下的 Laravel example code 的意思是？ Example:&lt;?phpAuth::loginUsingId(1, true); Answer:使用 User 來 login, 並且開啟 remember_me 的功能 # Authenticate A User Once以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Auth::once($credentials)) &#123; //&#125; Answer:auth 過後並不會動用到 cookie 或 session 或 token, 也就是說相當於當下的 request 有效而已 # HTTP Basic Authentication以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;profile&#x27;, function () &#123; // Only authenticated users may enter...&#125;)-&gt;middleware(&#x27;auth.basic&#x27;); Answer:使用 HTTP Basic Authentication middleware, 這樣任何到 ‘profile’ 的 request 都會經過 HTTP Basic Authentication 驗證 Laravel Authentication 中, auth.basic middleware 預設會取哪一個 column 的值當作 username?email # A Note On FastCGILaravel Authentication 中, 當我使用 PHP FastCGI 並且想要使用 HTTP Basic Authentication 時, 需要在哪個檔案加入以下程式碼？ 程式碼:RewriteCond %&#123;HTTP:Authorization&#125; ^(.+)$RewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;] Answer: .htaccess file # Stateless HTTP Basic Authentication以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Illuminate\\Support\\Facades\\Auth;class AuthenticateOnceWithBasicAuth&#123; public function handle($request, $next) &#123; return Auth::onceBasic() ?: $next($request); &#125;&#125; Answer:若要使用 HTTP Basic Authentication, 且不在 server 記下 session, 即關閉瀏覽器後, 使用者便需要重新登入, 那可自定義以上 middleware # Logging out以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Auth;Auth::logout(); Answer:登出該使用者, 也就是說清除 server 上的 session 以及 token # Invalidating Sessions On Other DevicesLaravel Authentication 中, 當用戶更改完密碼後, 我必須要讓該用戶在所有其他裝置失效, 若要做到這點, 我必須要讓哪一個內建的 middleware un-commented? Example:&lt;?php&#x27;web&#x27; =&gt; [ // ... // 這裡是？ // ...], Answer:&lt;?php&#x27;web&#x27; =&gt; [ // ... \\Illuminate\\Session\\Middleware\\AuthenticateSession::class, // ...], 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Auth;Auth::logoutOtherDevices($password); Answer:當 user 變更密碼之後, 可能會需要把變更密碼前的所有裝置都 logout, 這時就可以使用 logoutOtherDevices method Laravel Authentication 中, 當用戶更改完密碼後, 我必須要讓該用戶在所有其他裝置失效, 當我啟動 AuthenticationSession middleware 來做到這點後, 如果我用來登入的 route 不是叫做 login, 那我必須要再來 exception handler 中 override 哪一個 method 來導向我設定的登入用 route?unauthenticated method # Social Authentication# Adding Custom GuardsLaravel Authentication 中, 如果我要自定義 guard, 可以在哪個檔案中的 boot method 定義？AuthServiceProvider Laravel Authentication 中, 如果我要自定義 guard, 可以在哪個 AuthServiceProvider 的 boot method 中, 使用哪一個 method?Auth::extend method # Closure Request GuardsLaravel Authentication 中, 如果我要使用 closure 來自定義 custom guard, 可以在哪個檔案中的 boot method 中定義？AuthServiceProvider Laravel Authentication 中, 如果我要使用 closure 來自定義 custom guard, 可以在 AuthServiceProvider 中的 哪個 method 定義？boot method Laravel Authentication 中, 如果我要使用 closure 來自定義 custom guard, 可以在 AuthServiceProvider 中的 boot method 中使用哪個 method？Auth::viaRequest 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\User;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Auth;public function boot()&#123; $this-&gt;registerPolicies(); Auth::viaRequest(&#x27;guardName&#x27;, function ($request) &#123; return User::where(&#x27;token&#x27;, $request-&gt;token)-&gt;first(); &#125;);&#125; Answer:自定義一個 guard, 名為 guardName closure 內為 guard 的規則 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\User;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Auth;public function boot()&#123; $this-&gt;registerPolicies(); Auth::viaRequest(&#x27;custom-token&#x27;, function ($request) &#123; // User instance or null &#125;);&#125; Answer:在 Auth Service Provider boot() 中, 使用 Auth::viaRequest 自定義一個 closure based guard, arg1 為 guard name, arg2 為驗證的 closure, 若驗證通過則 return user instance, 若否則為 null 以下位於 config/auth.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;guards&#x27; =&gt; [ &#x27;api&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;custom-token&#x27;, ],], Answer:Laravel 中, api guard 預設使用 driver 為 token, 即驗證的邏輯, 上面 example 中指定了 guard api 需使用自定義的 custom-token guard 來驗證 # Adding Custom User ProvidersLaravel Authentication 中, guard 跟 provider 的差別？ guard 是 Laravel 將把 authenticated user’s detail 存在哪, 像是 session, database, etc User provider 是 Laravel 如何 authenticate a user, 像是 Eloquent, 或 API, 或其他 Laravel Authentication 中, 如果我要自定義一個 user provider, 可以在哪個檔案中中的 boot method？AuthServiceProvider Laravel Authentication 中, 如果我要自定義一個 user provider, 可以在 AuthServiceProvider 中的 哪一個 method 定義？boot method # The User Provider ContractLaravel Authentication 中, Illuminate\\Contracts\\Auth\\UserProvider 的作用？透過各種 method 從 persistent storage system 中取出並回傳一個 Illuminate\\Contracts\\Auth\\Authenticatable implementation 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Illuminate\\Contracts\\Auth;interface UserProvider&#123; public function retrieveById($identifier);&#125; Answer:透過 id 取得 authenticatable implementation Laravel Authentication 中, 以下的 UserProvider contract 的作用是？ Example:&lt;?phpnamespace Illuminate\\Contracts\\Auth;interface UserProvider&#123; public function retrieveByToken($identifier, $token);&#125; Answer:透過 $identifier 以及 $token (remember_token) 取得 authenticatable implementation Laravel Authentication 中, 以下的 UserProvider contract 的作用是？ Example:&lt;?phpnamespace Illuminate\\Contracts\\Auth;interface UserProvider&#123; public function updateRememberToken(Authenticatable $user, $token);&#125; Answer:當使用者使用 rmemeber_me 功能登入, 或登出時更新 remember_token 的值 Laravel Authentication 中, 以下的 UserProvider contract 的作用是？ Example:&lt;?phpnamespace Illuminate\\Contracts\\Auth;interface UserProvider&#123; public function retrieveByCredentials(array $credentials);&#125; Answer:透過 $credential 來取得 authenticatable implementation Laravel Authentication 中, 以下的 UserProvider contract 的作用是？ Example:&lt;?phpnamespace Illuminate\\Contracts\\Auth;interface UserProvider&#123; public function validateCredentials(Authenticatable $user, array $credentials);&#125; Answer:驗證 $credential 並回傳 boolean # The Authenticatable ContractLaravel Authentication 中, 以下的 authenticatable method 的意思是？ Example:&lt;?phpnamespace Illuminate\\Contracts\\Auth;interface Authenticatable&#123; public function getAuthIdentifierName();&#125; Answer:取得 primary key 的欄位名稱 Laravel Authentication 中, 以下的 authenticatable method 的意思是？ Example:&lt;?phpnamespace Illuminate\\Contracts\\Auth;interface Authenticatable&#123; public function getAuthIdentifier();&#125; Answer:取得 primary key 欄位的 值 # EventsLaravel Authentication 中, 以下的 example 的用途是？ Example:&lt;?phpprotected $listen = [ &#x27;Illuminate\\Auth\\Events\\Registered&#x27; =&gt; [ &#x27;App\\Listeners\\LogRegisteredUser&#x27;, ], &#x27;Illuminate\\Auth\\Events\\Attempting&#x27; =&gt; [ &#x27;App\\Listeners\\LogAuthenticationAttempt&#x27;, ], &#x27;Illuminate\\Auth\\Events\\Authenticated&#x27; =&gt; [ &#x27;App\\Listeners\\LogAuthenticated&#x27;, ], &#x27;Illuminate\\Auth\\Events\\Login&#x27; =&gt; [ &#x27;App\\Listeners\\LogSuccessfulLogin&#x27;, ], &#x27;Illuminate\\Auth\\Events\\Failed&#x27; =&gt; [ &#x27;App\\Listeners\\LogFailedLogin&#x27;, ], &#x27;Illuminate\\Auth\\Events\\Logout&#x27; =&gt; [ &#x27;App\\Listeners\\LogSuccessfulLogout&#x27;, ], &#x27;Illuminate\\Auth\\Events\\Lockout&#x27; =&gt; [ &#x27;App\\Listeners\\LogLockout&#x27;, ], &#x27;Illuminate\\Auth\\Events\\PasswordReset&#x27; =&gt; [ &#x27;App\\Listeners\\LogPasswordReset&#x27;, ],]; Answer:每一個 authentication 的動作都有其 event, 可以註冊該 event 的 listener 來做相對應的事, 例如, log","link":"/zh-tw/laravel-security-authentication/"},{"title":"Laravel - Security - Email Verification (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Model Preparation以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Contracts\\Auth\\MustVerifyEmail;use Illuminate\\Foundation\\Auth\\User as Authenticatable;use Illuminate\\Notifications\\Notifiable;class User extends Authenticatable implements MustVerifyEmail&#123; use Notifiable; // ...&#125; Answer:在 User model 透過 implements MustVerifyEmail interface, 啟動 email verification feature Laravel Email Verification 中, 當我在 User model implement MustVerifyEmail interface 之後, 每當註冊成功, Laravel 都會做什麼事？會發確認 email 給該 user # Database ConsiderationsLaravel Email Verification 中, 一旦 verify 成功, Laravel 會在哪個 column 記錄下 verified 的時間？email_verified_at # Routing以下的 Laravel example code 的意思是？ Example:&lt;?phpAuth::routes([&#x27;verify&#x27; =&gt; true]); Answer:註冊使用內建的 Auth\\VerificationController # Protecting Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;profile&#x27;, function () &#123; // Only verified users may enter...&#125;)-&gt;middleware(&#x27;verified&#x27;); Answer:存取 example.com/profile 的 request, 需是通過 email verified 的 user 方可存取 Laravel Email Verification 中, 驗證使用者是否 email verified 的 middleware 是哪一個？Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified # ViewsLaravel Email Verification 中, email verification 的 view 可使用哪個 CLI 自動安裝？composer require laravel/uiphp artisan ui vue --auth Laravel Email Verification 中, 當我使用 CLI 安裝 authentication scaffolding 之後, email verification 的 view 定義在哪個檔案？resources/views/auth/verify.blade.php # After Verifying EmailsLaravel Email Verification 中, 當 email verification 完成後, 使用者會自動地被導向 /home, 若要自定義導向位置, 可在哪個檔案中的 protected $redirectTo property 定義？VerificationController 中 以下位於 VerificationController 的 example code 的意思是？ Example:&lt;?phpprotected $redirectTo = &#x27;/dashboard&#x27;; Answer:一般來說, Email Verification 完成後, 預設會導向 home, 上面的 property $redirectTo 可以自定義重導向的位置 # Events以下的 Laravel example code 的意思是？ Example:&lt;?phpprotected $listen = [ &#x27;Illuminate\\Auth\\Events\\Verified&#x27; =&gt; [ &#x27;App\\Listeners\\LogVerifiedUser&#x27;, ],]; Answer:在 EventServiceProvider 中註冊一個 listener, 監聽 email verified event","link":"/zh-tw/laravel-security-email-verification/"},{"title":"Laravel - Security - Encryption (官方文件原子化翻譯筆記)","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 IntroductionLaravel Encryption 中, 使用了哪個套件提供 Encryption?OpenSSL Laravel Encryption 中, 使用了 OpenSSL 提供哪兩種 Encryption? AES-256 AES-128 Laravel Encryption 中, 所有 encrypted 的 value 都使用什麼來簽名？message authentication code Encryption 中, MAC 的全寫是？message authentication code Encryption 中, MAC 的簡單解釋？傳送方使用雙方約定好的金鑰以及演算法對傳送內容加密, 加密後會得到一串驗證碼, 與傳送內容一同傳送給接收方, 接收方收到後, 會使用雙方約定好的金曜以及演算法對傳送內容加密, 看加密後得到的驗證碼與傳送方傳過來的驗證碼是否相同, 若相同, 則傳送內容為可信 ConfigurationLaravel Email Verification 中, 如何使用 CLI 來產生 key?php artisan key:generate Using The EncryptionEncrypting A ValueLaravel Encryption 中, encrypt helper 使用了什麼來加密？ OpenSSL AES-256-CBC cipher 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\User;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public function storeSecret(Request $request, $id) &#123; $user = User::findOrFail($id); $user-&gt;fill([ &#x27;secret&#x27; =&gt; encrypt($request-&gt;secret), ])-&gt;save(); &#125;&#125; Answer:使用 encrypt() 來加密, 並使用 fill() insert 到 $user model Encrypting Without SerializationLaravel Encryption 中, 當我使用 encrypt method 時, 會通過 serialize, 為什麼？為了可以 encrypt objects 以及 arrays 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Crypt;$encrypted = Crypt::encryptString(&#x27;Hello world.&#x27;);$decrypted = Crypt::decryptString($encrypted); Answer:Laravel 預設會使用 serialize 來 encrypt, 因為對象可能是 array 或 object, 但當 encrypt string 時, 可以使用 encryptString() 或 decryptString(), 這樣就不會使用 serialize Decrypting A Value以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Contracts\\Encryption\\DecryptException;try &#123; $decrypted = decrypt($encryptedValue);&#125; catch (DecryptException $e) &#123; //&#125; Answer:嘗試 decrypt $encryptedValue, 如果失敗, 會 throw 一個 DecryptException, 使用 cache 捕捉它","link":"/zh-tw/laravel-security-encryption/"},{"title":"Laravel - Security - Hashing (官方文件原子化翻譯筆記)","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 ConfigurationLaravel Hashing 中, 支援使用哪三種算法來 hash password? Argon2i Argon2id Bcrypt Basic Usage以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Hash;class UpdatePasswordController extends Controller&#123; public function update(Request $request) &#123; // Validate the new password length... $request-&gt;user()-&gt;fill([ &#x27;password&#x27; =&gt; Hash::make($request-&gt;newPassword) ])-&gt;save(); &#125;&#125; Answer:取得登入的 User model, 並將 password attribute 替換成 hash 過的 newPassword, 然後儲存 Adjusting The Bcrypt Work Factor以下的 Laravel example code 的意思是？ Example:&lt;?php$hashed = Hash::make(&#x27;password&#x27;, [ &#x27;rounds&#x27; =&gt; 12]); Answer:hash password, 並指定 iteration 次數 Adjusting The Argon2 Work Factor以下的 Laravel example code 的意思是？ Example:&lt;?php$hashed = Hash::make(&#x27;password&#x27;, [ &#x27;memory&#x27; =&gt; 1024, &#x27;time&#x27; =&gt; 2, &#x27;threads&#x27; =&gt; 2,]); Answer:指定 Hash 時, memory 用量, time 以及 thread 數量 Verifying A Password Against A Hash以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Hash::check(&#x27;plain-text&#x27;, $hashedPassword)) &#123; // The passwords match...&#125; Answer:使用 Hash::check, arg1 為尚未 hash 過的, arg2 為 hashed 過的, 比較是否一致 Checking If A Password Needs To Be Rehashed以下的 Laravel example code 的意思是？ Example:&lt;?phpif (Hash::needsRehash($hashed)) &#123; $hashed = Hash::make(&#x27;plain-text&#x27;);&#125; Answer:使用 Hash::needsRehash() 來確認 arg 是否與目前 Application 的 hash factor 一致, 若不一致則 return true","link":"/zh-tw/laravel-security-hashing/"},{"title":"Laravel - Security - Password Reset (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # IntroductionLaravel Password Reset 中, 若要使用預設的 password reset feature, User model 需要 use 哪一個 trait? Illuminate\\Notifications\\Notifiable trait Illuminate\\Auth\\Passwords\\CanResetPassword trait # Database ConsiderationsLaravel Password Reset 中, 若要使用預設 password reset feature, 務必 implement 哪一個 interface?Illuminate\\Contracts\\Auth\\CanResetPassword interface # Generating The Reset Token Table MigrationLaravel Password Reset 中, password reset 會儲存 password reset token 在資料庫, 這個預設的 migration 可使用哪個 CLI 建立？composer require laravel/uiphp artisan migrate # RoutingLaravel Password Reset 中, 預設已寫好發送 email password reset link 以及 reset user password 的 Auth\\ForgotPasswordController 以及 Auth\\ResetPasswordController, 若要使用 CLI 通往這兩個 Controller 的 route, 該怎麼做？composer requrie laravel/uiphp artisan ui vue --auth # ViewsLaravel Password Reset 中, 若要使用 CLI 來產生 password reset 的 view, 該怎麼做？composer require laravel/uiphp artisan ui vue --auth # After Resetting PasswordsLaravel Password Reset 中, 在 password reset 之後, 會自動重導到 /home, 若要將 /home 改成 /dashboard, 可以在哪個檔案中的 $redirectTo property 修改？ResetPasswordController 以下位於 ResetPasswordController 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $redirectTo = &#x27;/dashboard&#x27;; Answer:Laravel 預設當 password reset 後, 會自動 redirect 到 /home, 若要 redirect 到其他地方, 可在 ResetPasswordController 中的 $redirectTo property 定義 Laravel Password Reset 中, 預設 password reset tokens 會在幾個小時後失效？1 小時 Laravel Password Reset 中, 預設 password reset tokens 會在一個小時後失效, 若要自定義, 可在哪個檔案？config/auth.phpexpire option # Customization以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Password;public function broker()&#123; return Password::broker(&#x27;name&#x27;);&#125; Answer:如果你有一個以上的 user table 或 model, 有需求不使用預設設定的話, 可在 ForGotPasswordController 以及 ResetPasswordController 定義其他設定, &#39;name&#39; 為 &#39;config/auth.passwords&#39; 中的定義 # Reset Email Customization以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function sendPasswordResetNotification($token)&#123; $this-&gt;notify(new ResetPasswordNotification($token));&#125; Answer:Laravel 中, 當使用 scaffolding 時, 預設有 password reset 的功能, 如果想要變更通知的 notification class, 可在 Model 中使用 sendPasswordResetNotification method 自定義","link":"/zh-tw/laravel-security-password-reset/"},{"title":"Laravel - Testing - Console Tests (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Input / Output Expectations以下的 Laravel Console Testing example code 的意思是？ Example:&lt;?php// commandArtisan::command(&#x27;question&#x27;, function () &#123; $name = $this-&gt;ask(&#x27;What is your name?&#x27;); $language = $this-&gt;choice(&#x27;Which language do you prefer?&#x27;, [ &#x27;PHP&#x27;, &#x27;Ruby&#x27;, &#x27;Python&#x27;, ]); $this-&gt;line(&#x27;Your name is &#x27;.$name.&#x27; and you prefer &#x27;.$language.&#x27;.&#x27;);&#125;);// testing methodpublic function testConsoleCommand()&#123; $this-&gt;artisan(&#x27;question&#x27;) -&gt;expectsQuestion(&#x27;What is your name?&#x27;, &#x27;Taylor Otwell&#x27;) -&gt;expectsQuestion(&#x27;Which language do you prefer?&#x27;, &#x27;PHP&#x27;) -&gt;expectsOutput(&#x27;Your name is Taylor Otwell and you prefer PHP.&#x27;) -&gt;doesntExpectOutput(&#x27;Your name is Taylor Otwell and you prefer Ruby.&#x27;) -&gt;assertExitCode(0);&#125; Answer:artisan: 指定要斷言的 command nameexpectsQuestion: 定義要斷言的 key (questions), 以及 value (answers)expectsOutput: 斷言會有 line, error, info 等 method 的輸出doesntExpectOutput: 斷言不可有的 line, error, info 等 method 的輸出assertExitCode: 斷言 exit code, 即 $$ 為 0 # Confirmation Expectations以下的 Laravel Console Testing example code 的意思是？ Example:&lt;?php$this-&gt;artisan(&#x27;module:import&#x27;) -&gt;expectsConfirmation(&#x27;Do you really wish to run this command?&#x27;, &#x27;no&#x27;) -&gt;assertExitCode(1); Answer:斷言 command confirmation 以及其輸出 # Table Expectations以下的 Laravel Console Testing example code 的意思是？ Example:&lt;?php$this-&gt;artisan(&#x27;users:all&#x27;) -&gt;expectsTable([ &#x27;ID&#x27;, &#x27;Email&#x27;, ], [ [1, &#x27;taylor@example.com&#x27;], [2, &#x27;abigail@example.com&#x27;], ]); Answer:斷言 command 為 &#39;users:all&#39;, arg1 為 table header, arg2 為 table data","link":"/zh-tw/laravel-testing-console-tests/"},{"title":"Laravel - Testing - Database (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Introduction# Resetting The Database After Each Test以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; use RefreshDatabase; public function test_basic_example() &#123; $response = $this-&gt;get(&#x27;/&#x27;); // ... &#125;&#125; Answer:使用 RefreshDatabase trait, 這樣每次 testing 之前都會 refresh database, 不讓之前的 test 影響到這次的 test # Defining Model Factories# Concept OverviewModel Factories 部分請參考 Seeding # Running Seeders以下的 Laravel Testing example code 的意思是？ Example:&lt;?phppublic function test_orders_can_be_created()&#123; $this-&gt;seed(); $this-&gt;seed(OrderStatusSeeder::class); // ...&#125; Answer:在 testing 中可以直接使用 seed() 來執行定義好的 seeders 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; protected $seed = true; // ...&#125; Answer:在 testing class 中定義 $seed property 為 true, 那每次 refresh database 時都會自動執行 db:seed 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpuse Database\\Seeders\\OrderStatusSeeder;protected $seeder = OrderStatusSeeder::class; Answer:當 testing class 中的 $seed property 設為 true 時, 每一次 refresh database 都會自動執行 db:seed, 可在 seeder property 定義要執行哪一個 seed class # Available Assertions# assertDatabaseCount以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$this-&gt;assertDatabaseCount(&#x27;users&#x27;, 5); Answer:assert users table 中有五筆資料 # assertDatabaseHas以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$this-&gt;assertDatabaseHas(&#x27;users&#x27;, [ &#x27;email&#x27; =&gt; &#x27;sally@example.com&#x27;,]); Answer:assert users table 中有 email column 且 value 為 sally@example.com # assertDatabaseMissing以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$this-&gt;assertDatabaseMissing(&#x27;users&#x27;, [ &#x27;email&#x27; =&gt; &#x27;sally@example.com&#x27;,]); Answer:assert users table 中沒有 email column 且 value 為 sally@example.com 這筆資料 # assertDeleted以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;$user = User::find(1);$user-&gt;delete();$this-&gt;assertDeleted($user); Answer:assert 指定的 Eloquent model 已被刪除 以下的 Laravel Testing example code 的意思是？ Example:&lt;?php$this-&gt;assertSoftDeleted($user); Answer:assert 指定的 Eloquent model 已被 soft deleted # Additional以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function signIn($user = null)&#123; return $this-&gt;actingAs($user ?: User::factory()-&gt;create());&#125; Answer:建立並 login 一個 fake user Laravel testing 中, 若要 assert relation, 可以使用哪個 method?assertInstanceOf() 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;payment_method&#x27; =&gt; $this-&gt;faker-&gt;randomElement([&#x27;wechat&#x27;, &#x27;alipay&#x27;]), Answer:隨機選一個 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;paid_at&#x27; =&gt; $this-&gt;faker-&gt;dateTimeBetween(&#x27;-30 days&#x27;), Answer:30 天前到現在的任意時間","link":"/zh-tw/laravel-testing-database/"},{"title":"Laravel - Testing - Getting Started (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # EnvironmentLaravel Testing 中, 會使用 session 或 cache 嗎？不會, 會使用 array driver 代替 Laravel Testing 中, 設定檔是哪一個？phpunit.xml Laravel Testing 中, 若要複寫 .env 的設定, 提供一些 env 專為了 testing 環境而使用, 可以怎麼做？建立 .env.testing 檔案 # Creating &amp; Running Tests以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan make:test UserTestphp artisan make:test UserTest --unit Answer:&lt;?php// 建立 feature test, 通常用來測試整個 HTTP requestphp artisan make:test UserTest// 建立 unit test, 通常測試範圍為一個 methodphp artisan make:test UserTest --unit 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Tests\\Unit;use PHPUnit\\Framework\\TestCase;class ExampleTest extends TestCase&#123; public function testBasicTest() &#123; $this-&gt;assertTrue(true); &#125;&#125; Answer:建立一個 test 之後, 可以在裡面定義測試邏輯, 範例會 return true, 只是個範例 # Artisan Test Runner以下的 Laravel example command 的意思是？ Example:php artisan test --testsuite=Feature --stop-on-failure Answer:建立一個 test file, 指定類行為 feature, 並且失敗就停下","link":"/zh-tw/laravel-testing-getting-started/"},{"title":"Laravel - Testing - HTTP Tests (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Introduction以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Tests\\Feature;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use Illuminate\\Foundation\\Testing\\WithoutMiddleware;use Tests\\TestCase;class ExampleTest extends TestCase&#123; public function testBasicTest() &#123; $response = $this-&gt;get(&#x27;/&#x27;); $response-&gt;assertStatus(200); &#125;&#125; Answer:如果對 ‘/‘ 發 request, response 將會是 200, 如果不是則測試不通過 # Customizing Request Headers以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testBasicExample() &#123; $response = $this-&gt;withHeaders([ &#x27;X-Header&#x27; =&gt; &#x27;Value&#x27;, ])-&gt;json(&#x27;POST&#x27;, &#x27;/user&#x27;, [&#x27;name&#x27; =&gt; &#x27;Sally&#x27;]); $response -&gt;assertStatus(201) -&gt;assertJson([ &#x27;created&#x27; =&gt; true, ]); &#125;&#125; Answer:自訂 request 的 header, 然後以 POST 的方式帶著參數發到 ‘/user’ url並斷言需以 JSON 格式回傳 ‘created’ =&gt; true, status code 為 201 Laravel Testing 中, CSRF token 會運作嗎？不會 # Cookies以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testCookies() &#123; $response = $this-&gt;withCookie(&#x27;color&#x27;, &#x27;blue&#x27;)-&gt;get(&#x27;/&#x27;); $response = $this-&gt;withCookies([ &#x27;color&#x27; =&gt; &#x27;blue&#x27;, &#x27;name&#x27; =&gt; &#x27;Taylor&#x27;, ])-&gt;get(&#x27;/&#x27;); &#125;&#125; Answer:建立一個 test case, 定義 cookie 為 ‘color’ =&gt; ‘blue’, 並向 ‘/‘ 發 GET request, 上面兩種定義 cookie 的方式皆可 # Debugging Responses以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Tests\\Feature;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use Illuminate\\Foundation\\Testing\\WithoutMiddleware;use Tests\\TestCase;class ExampleTest extends TestCase&#123; public function testBasicTest() &#123; $response = $this-&gt;get(&#x27;/&#x27;); $response-&gt;dumpHeaders(); $response-&gt;dumpSession(); $response-&gt;dump(); &#125;&#125; Answer:對 ‘/‘ 發 GET request, 並印出 headers, session, 以及整個 response 方便 debug # Session / Authentication以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testApplication() &#123; $response = $this-&gt;withSession([&#x27;foo&#x27; =&gt; &#x27;bar&#x27;]) -&gt;get(&#x27;/&#x27;); &#125;&#125; Answer:定義 session 載入檔案 [‘foo’ =&gt; ‘bar’], 並發送 ‘/‘ GET request 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\User;class ExampleTest extends TestCase&#123; public function testApplication() &#123; $user = User::factory()-&gt;create(); $response = $this-&gt;actingAs($user, &#x27;api&#x27;) -&gt;withSession([&#x27;foo&#x27; =&gt; &#x27;bar&#x27;]) -&gt;get(&#x27;/&#x27;); &#125;&#125; Answer:建立一個 user, 並指定由這個 user 登入, 使用 ‘api’ guard 來驗證身份 (也可不設), 並帶著 session [‘foo’ =&gt; ‘bar’], 發送 ‘/‘ GET request # Testing JSON APIs以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testBasicExample() &#123; $response = $this-&gt;postJson(&#x27;/user&#x27;, [&#x27;name&#x27; =&gt; &#x27;Sally&#x27;]); $response -&gt;assertStatus(201) -&gt;assertJson([ &#x27;created&#x27; =&gt; true, ]); &#125;&#125; Answer:使用 JSON 格式發送 POST request, 發送位址為 ‘/user’, body 為 [‘name’ =&gt; ‘Sally’]並斷言回傳 status code 201, 以及 JSON “created” : “true” 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testBasicExample() &#123; $response = $this-&gt;postJson(&#x27;/user&#x27;, [&#x27;name&#x27; =&gt; &#x27;Sally&#x27;]); $this-&gt;assertTrue($response[&#x27;created&#x27;]); &#125;&#125; Answer:使用 JSON 格式發送 POST request, 發送位址為 &#39;/user&#39;, body 為 [&#39;name&#39; =&gt; &#39;Sally&#39;]並斷言回傳 的 JSON response 的 &#39;created&#39; value 為 true # Verifying An Exact JSON Match以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testBasicExample() &#123; $response = $this-&gt;json(&#x27;POST&#x27;, &#x27;/user&#x27;, [&#x27;name&#x27; =&gt; &#x27;Sally&#x27;]); $response -&gt;assertStatus(201) -&gt;assertExactJson([ &#x27;created&#x27; =&gt; true, ]); &#125;&#125; Answer:使用 JSON 格式發送 POST request, 發送位址為 &#39;/user&#39;, body 為 [&#39;name&#39; =&gt; &#39;Sally&#39;]並斷言 response 會是 JSON [&#39;created =&gt; true], 若不是則 test fail # Verifying JSON Paths以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testBasicExample() &#123; $response = $this-&gt;json(&#x27;POST&#x27;, &#x27;/user&#x27;, [&#x27;name&#x27; =&gt; &#x27;Sally&#x27;]); $response -&gt;assertStatus(201) -&gt;assertJsonPath(&#x27;team.owner.name&#x27;, &#x27;foo&#x27;); &#125;&#125; Answer:使用 JSON 格式發送 POST request, 發送位址為 &#39;/user&#39;, body 為 [&#39;name&#39; =&gt; &#39;Sally&#39;]並斷言 response 需包含 status code 201, 以及在 &#39;team.owner.name&#39; 的路徑, value 需為 &#39;foo&#39; # Testing File Uploads以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Tests\\Feature;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use Illuminate\\Foundation\\Testing\\WithoutMiddleware;use Illuminate\\Http\\UploadedFile;use Illuminate\\Support\\Facades\\Storage;use Tests\\TestCase;class ExampleTest extends TestCase&#123; public function testAvatarUpload() &#123; Storage::fake(&#x27;avatars&#x27;); $file = UploadedFile::fake()-&gt;image(&#x27;avatar.jpg&#x27;); $response = $this-&gt;json(&#x27;POST&#x27;, &#x27;/avatar&#x27;, [ &#x27;avatar&#x27; =&gt; $file, ]); Storage::disk(&#x27;avatars&#x27;)-&gt;assertExists($file-&gt;hashName()); Storage::disk(&#x27;avatars&#x27;)-&gt;assertMissing(&#x27;missing.jpg&#x27;); &#125;&#125; Answer:&lt;?phpnamespace Tests\\Feature;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use Illuminate\\Foundation\\Testing\\WithoutMiddleware;use Illuminate\\Http\\UploadedFile;use Illuminate\\Support\\Facades\\Storage;use Tests\\TestCase;class ExampleTest extends TestCase&#123; public function testAvatarUpload() &#123; // fake 一個 storage disk 名為 &#x27;avatars&#x27; Storage::fake(&#x27;avatars&#x27;); // fake 一個 image 名為 &#x27;avatar.jpg&#x27;, 並 assign 到 $file $file = UploadedFile::fake()-&gt;image(&#x27;avatar.jpg&#x27;); // 對 &#x27;/avatar&#x27; 發起一個 JSON POST Request, 帶著 [&#x27;avatar&#x27; =&gt; $file] $response = $this-&gt;json(&#x27;POST&#x27;, &#x27;/avatar&#x27;, [ &#x27;avatar&#x27; =&gt; $file, ]); // 斷言在 &#x27;avatars&#x27; 這個 storage disk 中, 有 $file 的 hash name, 若無則 test fails Storage::disk(&#x27;avatars&#x27;)-&gt;assertExists($file-&gt;hashName()); // 斷言在 &#x27;avatars&#x27; 這個 storage disk 中, 沒有 &#x27;missing.jpg&#x27; 這個檔案, 若有則 test fails Storage::disk(&#x27;avatars&#x27;)-&gt;assertMissing(&#x27;missing.jpg&#x27;); &#125;&#125; # Fake File Customization以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testBasicExample() &#123; UploadedFile::fake()-&gt;image(&#x27;avatar.jpg&#x27;, $width, $height)-&gt;size(100); &#125;&#125; Answer:fake 一個 image, 名為 &#39;avatar.jpg&#39;, 定義 width, height, 以及 size 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testBasicExample() &#123; UploadedFile::fake()-&gt;create(&#x27;document.pdf&#x27;, $sizeInKilobytes, &#x27;application/pdf&#x27;); &#125;&#125; Answer:使用 faker 的 create method 建立一個 PDF file, 可以指定 size 以及 mimeType (optional) # Testing Views以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testWelcomeView() &#123; $view = $this-&gt;view(&#x27;welcome&#x27;, [&#x27;name&#x27; =&gt; &#x27;Taylor&#x27;]); $view-&gt;assertSee(&#x27;Taylor&#x27;); &#125;&#125; Answer:test 的 view method 會 return 一個 Illuminate\\Testing\\TestView instance, 可帶入 view name 以及 parameters, TestView instance 也提供了很多 assertion method:assertsee, assertSeeInOrder, assertSeeText, assertSeeTextInOrder, assertDontSee, assertDontSeeText 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testWelcomeView() &#123; $contents = (string) $this-&gt;view(&#x27;welcome&#x27;); &#125;&#125; Answer:若有需要, 也可取得 raw, rendered view 的內容 # Sharing Errors以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function testWelcomeView() &#123; $view = $this-&gt;withViewErrors([ &#x27;name&#x27; =&gt; [&#x27;Please provide a valid name.&#x27;] ])-&gt;view(&#x27;form&#x27;); $view-&gt;assertSee(&#x27;Please provide a valid name.&#x27;); &#125;&#125; Answer:將模擬的 error message &#39;name&#39; =&gt; [&#39;Please provide a valid name.&#39;]待到指定的 view &#39;form&#39; # Rendering Blade &amp; Components以下的 Laravel Test example code 的意思是？ Example:&lt;?php$view = $this-&gt;blade( &#x27;&lt;x-component :name=&quot;$name&quot; /&gt;&#x27;, [&#x27;name&#x27; =&gt; &#x27;Taylor&#x27;]);$view-&gt;assertSee(&#x27;Taylor&#x27;); Answer:使用 blade()arg1 定義使用名為 component 的 component, 且定義帶入的參數為 $namearg2 定義 $name 為 &#39;Taylor&#39;最後斷言 $view 需可看到 &#39;Taylor&#39; 以下的 Laravel Test example code 的意思是？ Example:&lt;?php$view = $this-&gt;component(Profile::class, [&#x27;name&#x27; =&gt; &#x27;Taylor&#x27;]);$view-&gt;assertSee(&#x27;Taylor&#x27;); Answer:使用 component()arg1 使用的 component classarg2 定義帶入的 args key/value最後斷言 $view 需可看到 &#39;Taylor&#39; # Available Assertions# Response Assertions# assertCookie以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertCookie($cookieName, $value = null); Answer:斷言 response 帶有指定 $cookie # assertCookieExpired以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertCookieExpired($cookieName); Answer:斷言 response 帶有指定 $cookie, 且該 cookie 已過期 # assertCookieNotExpired以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertCookieNotExpired($cookieName); Answer:斷言 response 帶有指定 $cookie, 且該 cookie 還沒過期 # assertCookieMissing以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertCookieMissing($cookieName); Answer:斷言 response 未帶有指定 cookie # assertCreated以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertCreated(); Answer:斷言 response status code 為 201 # assertDontSee以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertDontSee($value, $escaped = true); Answer:斷言 response 含有指定 $value string預設會自動 escape string, 除非 arg2 為 false # assertDontSeeText以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertDontSeeText($value, $escaped = true); Answer:斷言 response text 中含有指定 $value string預設會自動 escape string, 除非 arg2 為 false在跑此 assertion 之前, 會先把 response 的內容用 PHP function strip_tags 跑過 # assertExactJson以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertExactJson(array $data); Answer:斷言 response 中, 含有完全符合指定 $data 的 JSON data # assertForbidden以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertForbidden(); Answer:斷言 response 含有 HTTP status code 403 # assertHeader以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertHeader($headerName, $value = null); Answer:斷言 response 含有指定的 header 以及其 value # assertHeaderMissing以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertHeaderMissing($headerName); Answer:斷言 response 不含有指定 header # assertJson以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJson(array $data, $strict = false); Answer:斷言 response 含有指定 JSON dataassertJson 會將 response 轉成 array, 並且使用 PHPUnit::assertArraySubset 確認指定的 array 存在於 JSON response, 所以如果該 JSON response 中有其他 property, test 也會 pass 過去 # assertJsonCount以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJsonCount($count, $key = null); Answer:斷言 response JSON 中, 指定的 $key 為 array, 而裡頭的 item 數量跟斷言的 $count 數量相符 # assertJsonFragment以下的 Laravel Test example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/users&#x27;, function () &#123; return [ &#x27;users&#x27; =&gt; [ [ &#x27;name&#x27; =&gt; &#x27;Taylor Otwell&#x27;, ], ], ];&#125;);$response-&gt;assertJsonFragment([&#x27;name&#x27; =&gt; &#x27;Taylor Otwell&#x27;]); Answer:斷言 response 中, 在某個位置有著 [&#39;name&#39; =&gt; &#39;Taylor Otwell&#39; # assertJsonMissing以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJsonMissing(array $data); Answer:斷言 response 中, 並無 JSON $data假如 Response 為 [&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2], 那如果 $data 為 [&#39;a&#39; =&gt; 2, &#39;b&#39; =&gt; 2], 這樣也算 fail # assertJsonMissingExact以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJsonMissingExact(array $data); Answer:斷言 response 中, 並無 JSON $data假如 Response 為 [&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2], 那如果 $data 為 [&#39;a&#39; =&gt; 2, &#39;b&#39; =&gt; 2], 因為沒有完全符合, 這樣便不算 fail, 然而測試結果為 not perform any assertion, 不確定這樣的行為是否正常, 預期行為應為 pass # assertJsonMissingValidationErrors以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJsonMissingValidationErrors($keys); Answer:斷言 response 中, 並無指定 $key 的 JSON validation error # assertJsonPath以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJsonPath($path, array $data, $strict = true); Answer:斷言 response 在指定的 $path 位置含有指定的 $data見範例如下: Demonstration:&lt;?php// response&#123; &quot;user&quot;: &#123; &quot;name&quot;: &quot;Steve Schoger&quot; &#125;&#125;// test method$response-&gt;assertJsonPath(&#x27;user.name&#x27;, &#x27;Steve Schoger&#x27;); # assertJsonStructure以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJsonStructure(array $structure); Answer:斷言 response 為定義的 JSON 結構見範例如下: Demonstration:&lt;?php// response&#123; &quot;user&quot;: &#123; &quot;name&quot;: &quot;Steve Schoger&quot; &#125;&#125;// test method$response-&gt;assertJsonStructure([ &#x27;user&#x27; =&gt; [ &#x27;name&#x27;, ]]); # assertJsonValidationErrors以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertJsonValidationErrors(array $data); Answer:斷言 response 需含有指定 keys 的 errors, 適用於 validator error 是以 JSON 結構回傳, 而不是置於 session 當中 # assertLocation以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertLocation($uri); Answer:斷言 response 的 Location header 的 value 為 $uri # assertNoContent以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertNoContent($status = 204) Answer:斷言 response 需為 no content, 且 status code 為 204 # assertNotFound以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertNotFound(); Answer:斷言 response status code 需為 404 # assertOk以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertOk() Answer:斷言 response status code 需為 200 # assertPlainCookie以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertPlainCookie($cookieName, $value = null); Answer:斷言 response 含有指定的 unencrypted cookie # assertRedirect以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertRedirect($uri); Answer:斷言 response 為 redirect 到 $uri # assertSee以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSee($value, $escaped = true); Answer:斷言 response 含有 string $value, 預設會 escape 此 string, 可指定為 false # assertSeeInOrder以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSeeInOrder(array $values, $escaped = true); Answer:斷言 response 中, string 的順序如 $values 的定義, 預設 escape, 可變更為 false # assertSeeText以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSeeText($value, $escaped = true); Answer:斷言 response text 中有 string $value, 預設會 escape string, 可改為 falseresponse 內容會先經過 strip_tags 處理過, 才會到 assertion # assertSeeTextInOrder以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSeeTextInOrder(array $values, $escaped = true); Answer:斷言 response text 中有 string $value, 並且照定義的順序排列, 預設會 escape string, 可改為 falseresponse 內容會先經過 strip_tags 處理過, 才會到 assertion # assertSessionHas以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionHas($key, $value = null); Answer:斷言 session $key 含有 $value # assertSessionHasInput以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionHasInput($key, $value = null); Answer:斷言 session 在 flashed input array 含有指定的 key / value # assertSessionHasAll以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionHasAll(array $data); Answer:斷言 session 在 含有指定的 array [key / value]例如 session 含有 name 及 status key, 可定義如下： Demonstration:&lt;?php$response-&gt;assertSessionHasAll([ &#x27;name&#x27; =&gt; &#x27;Taylor Otwell&#x27;, &#x27;status&#x27; =&gt; &#x27;active&#x27;,]); # assertSessionHasErrors以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionHasErrors( array $keys, $format = null, $errorBag = &#x27;default&#x27;); Answer:斷言 session 中含有指定的 errors, 可以只斷言 key, 也可 key / value這個適合用來測試會將 error 放入 session 的 route, 而不是將 error 導出 JSON response 的 route例如, 斷言 session 中有 error message filed name, email (demonstration 1)也可指定 error message key / value (demonstration 2) Demonstration1:&lt;?php$response-&gt;assertSessionHasErrors([&#x27;name&#x27;, &#x27;email&#x27;]); Demonstration2:&lt;?php$response-&gt;assertSessionHasErrors([ &#x27;name&#x27; =&gt; &#x27;The given name was invalid.&#x27;]); # assertSessionHasErrorsIn以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionHasErrorsIn($errorBag, $keys = [], $format = null); Answer:斷言 session 中, messageBag $errorBag 中含有指定的 error / message $keys, 可定義 key 以及 key / value # assertSessionHasNoErrors以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionHasNoErrors(); Answer:斷言 session 中沒有 validation errors # assertSessionDoesntHaveErrors以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionDoesntHaveErrors($keys = [], $format = null, $errorBag = &#x27;default&#x27;); Answer:斷言 session 中沒有指定的 error key # assertSessionMissing以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSessionMissing($key); Answer:斷言 session 中沒有指定的 $key # assertStatus以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertStatus($code); Answer:斷言 response 的 status code 為 $code # assertSuccessful以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertSuccessful(); Answer:斷言 response 的 status code 為 (&gt;= 200 and &lt; 300) # assertUnauthorized以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertUnauthorized(); Answer:斷言 response 的 status code 為 401 # assertViewHasAll以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertViewHasAll(array $data); Answer:&lt;?php// 斷言 response view 中含有指定的 keys 或是多組 key / value$rseponse-&gt;assertViewHasAll([ &#x27;name&#x27;, &#x27;email&#x27;,]);$rseponse-&gt;assertViewHasAll([ &#x27;name&#x27; =&gt; &#x27;Taylor Otwell&#x27;, &#x27;email&#x27; =&gt; &#x27;taylor@example.com,&#x27;,]); # assertViewIs以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertViewIs($value); Answer:斷言 response view name 跟 $value 一樣 # assertViewMissing以下的 Laravel Test example code 的意思是？ Example:&lt;?php$response-&gt;assertViewMissing($key); Answer:斷言 response view 中沒有 $key # Authentication Assertions# assertAuthenticated以下的 Laravel Test example code 的意思是？ Example:&lt;?php$this-&gt;assertAuthenticated($guard = null); Answer:斷言 user is authenticated # assertGuest以下的 Laravel Test example code 的意思是？ Example:&lt;?php$this-&gt;assertGuest($guard = null); Answer:斷言 user is not authenticated # assertAuthenticatedAs以下的 Laravel Test example code 的意思是？ Example:&lt;?php$this-&gt;assertAuthenticatedAs($user, $guard = null); Answer:斷言 $user is authenticated","link":"/zh-tw/laravel-testing-http-tests/"},{"title":"Laravel - The Basics - Controllers (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Basic Controllers# Defining ControllersLaravel 中, 如果不 extend basic controller 的話, 是有什麼影響？無法使用一些方便的功能, 像是 middleware, validate, 以及 dispatch # Controllers and NamespacesLaravel 中, 如果以下是我的 Controller 路徑, 那我該在 Route 中怎樣定義我的 Controller 位址？ 路徑:App\\Http\\Controllers\\Photos\\AdminController Answer:&lt;?phpRoute::get(&#x27;foo&#x27;, &#x27;Photos\\AdminController@method&#x27;); # Single Action ControllersLaravel 中, 如果我要從 CLI 建立一個 single action controller, 我可以怎麼做？php artisan make:controller ControllerName --invokable 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\User;class ShowProfile extends Controller&#123; public function __invoke($id) &#123; return view(&#x27;user.profile&#x27;, [&#x27;user&#x27; =&gt; User::findOrFail($id)]); &#125;&#125; Answer:使用 __invoke method, 表示該 controller 只有一個 method Laravel 中, 在 route 註冊 single action controller 時, 需要指定 method 嗎？不用 # Controller Middleware以下的 Laravel example code 的意思是？ Example:&lt;?phpclass UserController extends Controller&#123; public function __construct() &#123; $this-&gt;middleware(&#x27;auth&#x27;); $this-&gt;middleware(&#x27;log&#x27;)-&gt;only(&#x27;index&#x27;); $this-&gt;middleware(&#x27;subscribed&#x27;)-&gt;except(&#x27;store&#x27;); &#125;&#125; Answer:&lt;?phpclass UserController extends Controller&#123; public function __construct() &#123; // 指定該 controller 需使用 auth middleware $this-&gt;middleware(&#x27;auth&#x27;); // 指定只有該 controller 中的 index method 使用 log middleware $this-&gt;middleware(&#x27;log&#x27;)-&gt;only(&#x27;index&#x27;); // 指定除了該 controller 中的 store method 之外, 其餘 method 都使用 subscribed middleware $this-&gt;middleware(&#x27;subscribed&#x27;)-&gt;except(&#x27;store&#x27;); &#125;&#125; Laravel 中, 除了在 route, global, 以及 group 中指派 middleware 之外, 我還可以在什麼地方指派？Controller 以下位於 controller 中的 example code 的意思是？ Example:&lt;?php$this-&gt;middleware(function ($request, $next) &#123; // ... return $next($request);&#125;); Answer:在 controller 中定義一個 middleware Laravel 中, 如果我要在 controller 中定義 (非指派) 一個 middleware, 那我可以怎麼做？在 Controller 中 # Resource ControllersLaravel 中, 如果我要使用 CLI 來建立一個 Resource Controller, 我可以怎麼做？php artisan make:controller ControllerName --resource 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::resources([ &#x27;photos&#x27; =&gt; &#x27;PhotoController&#x27;, &#x27;posts&#x27; =&gt; &#x27;PostController&#x27;]); Answer:一次定義多個 resource controllerrecourse controller 可一次處理多種 action, 像是 create, edit, show, delete 等等…, 會根據 http method 以及 url 去判斷該 request 是屬於哪一種 action, 並導向該 controller 中相對應的 method # Specifying The Resource Model以下的 Laravel example code 的意思是？ Example:php artisan make:controller ControllerName --resorce --model=ModelName Answer:自動建立一個 Resource Controller, 即 Controller 內已經幫你建立好各種預設的 method, 像是 index, update, show …etc, 而 –model 代表這些 method 預設 type hint 的 model # Spoofing Form Methods以下的 Laravel example code 的意思是？ Example:&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt; @method(&#x27;PUT&#x27;)&lt;/form&gt; Answer:HTTP Form 並不支援 ‘PUT’ method, 所以使用 blade 語法來模擬 ‘PUT’ method # Partial Resource Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::resource(&#x27;photos&#x27;, &#x27;PhotoController&#x27;)-&gt;only([ &#x27;index&#x27;, &#x27;show&#x27;]); Answer:只開放 ‘index’ 以及 ‘show’ method, 也就是說只可 GET ‘example.com/photos’ 以及 ‘example.com/photos/{photo}’ 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::resource(&#x27;photos&#x27;, &#x27;PhotoController&#x27;)-&gt;except([ &#x27;create&#x27;, &#x27;store&#x27;, &#x27;update&#x27;, &#x27;destroy&#x27;]); Answer:只開放該 resource controller, 除了 [‘create’, ‘store’, ‘update’, ‘destroy’] 之外的 method # API Resource RouteapiResource route 跟 resource route 的差別在於？apiResource route 不包含 create 以及 edit method 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::apiResources([ &#x27;photos&#x27; =&gt; &#x27;PhotoController&#x27;, &#x27;posts&#x27; =&gt; &#x27;PostController&#x27;]); Answer:一次性的定義多個 apiResources routes 以下的 Laravel example command 的意思是？ Example:php artisan make:controller ControllerName --api Answer:使用 CLI 建立 apiResource controller # Nested Resources以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::resource(&#x27;photos.comments&#x27;, &#x27;PhotoCommentController&#x27;); Answer:建立一個 nested resources routeAPI 會像是 ‘example.com/api/photos/{photo}/comments/{comment}’情境為 Photo model 有多個 Comment model, 也就是說 Comment model 必須得 belongsTo Photo model # Shallow NestingLaravel 中, 如果我要定義一個 resource route 具有以下的模式, 那我可以怎麼樣來定義我的 route? Example: Answer:&lt;?phpRoute::resource(&#x27;photos.comments&#x27;, &#x27;CommentController&#x27;)-&gt;shallow(); # Naming Resource Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::resource(&#x27;photos&#x27;, &#x27;PhotoController&#x27;)-&gt;names([ &#x27;create&#x27; =&gt; &#x27;photos.build&#x27;]); Answer:Laravel resources controller 每個 action 都會有預設的 name, 如果要自定義, 可以使用 names method # Naming Resource Route Parameters以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::resource(&#x27;users&#x27;, &#x27;AdminUserController&#x27;)-&gt;parameters([ &#x27;users&#x27; =&gt; &#x27;admin_user&#x27;]); Answer:使用 resource route, 預設 url 為 ‘users/{user}’, 但因為使用 parameter method 修改, 所以 url 為 ‘users/{admin_user}’ # Localizing Resource URIs解釋以下的 Laravel example 的意思 Example:&lt;?phpuse Illuminate\\Support\\Facades\\Route;public function boot()&#123; Route::resourceVerbs([ &#x27;create&#x27; =&gt; &#x27;crear&#x27;, &#x27;edit&#x27; =&gt; &#x27;editar&#x27;, ]);&#125; Answer:當使用 resource route 時, Laravel 預設會定義 verb, 比如說 Route::resource(‘photos’, ‘PhotoController’), edit action 的 url 會是 ‘example.com/photos/{photo}/edit’若要變更 url 中的 resource verb, 可以在 AppServiceProvider 的 boot method 中, 如上 example 自定義 # Supplementing Resource ControllersLaravel 中, 當我使用了 resource route, 但我同時也定義了其他的 route 給同一個 controller 除了 resource 以外的 action, 那這些額外定義的 route 應該置於 resource route 之前還是之後？之前 Laravel 中, 如果你發現你常常需要增加額外的 method 到一個 resource controller, 那你可能該怎麼做？增加新的 Controller 讓 controller 的功能比較單一 # Dependency Injection and ControllersLaravel 中, 在 Controller 中可以使用哪兩種 dependency injection 方式? Constructor Injection Method Injection 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Repositories\\UserRepository;class UserController extends Controller&#123; protected $users; public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125; Answer:使用 Controller 中的 construct injection, inject UserRepository 這個 class 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public function store(Request $request) &#123; $name = $request-&gt;name; // &#125;&#125; Answer:使用 method injection 的方式, inject Request 到 store method 中 以下的 Laravel example code 的意思是？ Example:&lt;?php// 在 .../routes/web.phpRoute::put(&#x27;user/&#123;id&#125;&#x27;, &#x27;UserController@update&#x27;);// 在 controller 中namespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public function update(Request $request, $id) &#123; // &#125;&#125; Answer:將從 url parameter 中取得的 {id}, 帶入到 UserController 中的 update method, 沒有使用 model binding # Route CachingLaravel 中, closure based routes 可以被 cached 嗎？不行哦 Laravel 中, route cache 的優點是？可以大幅的縮小註冊 routes 的時間 Laravel 中, 如果我要用 CLI 來 cache route, 我可以怎麼做？php artisan route:cache Laravel 中, 在我使用了 route:cache 之後, 如果我又新增了一個 route, 那我該怎麼樣讓它生效？php artisan route:clearphp artisan route:cache","link":"/zh-tw/laravel-the-basics-controllers/"},{"title":"Laravel - The Basics - CSRF Protection (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # IntroductionCSRF 的全寫是？cross-site request forgery CSRF 是什麼？利用使用者的 token 或 cookie 送出不合法的請求, 藉此更改使用者在後端的資料或其他惡意的動作。 以下的 Laravel example code 的意思是？ Example:&lt;form method=&quot;POST&quot; action=&quot;/profile&quot;&gt; @csrf ...&lt;/form&gt; Answer:在 form 表單中附加 CSRF token, 當表單提交時會帶回該 CSRF token, server 會比對該 token 是否是 server 發出以判斷該 form 表單的來源是否可信 Laravel 中, 哪一個 middleware 會去檢驗 form 裡頭的 CSRF token 是否正確？VerifyCsrfToken # CSRF Token &amp; JavaScriptLaravel 中, 哪個檔案中有提供 Axios HTTP library, 可以自動的將 XSRF_TOKEN cookie 的值利用 X-XSRF-TOKEN header 發送？resources/js/bootstrap.js # Excluding URLs From CSRF Protection以下的 Laravel example 是什麼意思？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;class VerifyCsrfToken extends Middleware&#123; protected $except = [ &#x27;stripe/*&#x27;, &#x27;http://example.com/foo/bar&#x27;, &#x27;http://example.com/foo/*&#x27;, ];&#125; Answer:在 $except property 中的 url 將不會被 VerifyCsrfToken middleware 驗證 Laravel 中, 在 tests 中, CSRF middleware 還會運作嗎？不會 # X-CSRF-TOKENLaravel VerifyCsrfToken middleware 除了會從 POST parameter 中檢查 CSRF token 之外, 還會從哪裡檢查？request 的 X-CSRF-TOKEN header Laravel 中, 我可以將 CSRF token 發到 HTML 的哪一個 tag?meta 以下的 Laravel 中的 HTML 程式碼的意思是？ Example:&lt;meta name=&quot;csrf-token&quot; content=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt; Answer:將 csrf token 放到 meta tag 中 以下的 Laravel 中使用 AJAX 的程式碼的意思是？, Example:$.ajaxSetup(&#123; headers: &#123; &#x27;X-CSRF-TOKEN&#x27;: $(&#x27;meta[name=&quot;csrf-token&quot;]&#x27;).attr(&#x27;content&#x27;) &#125;&#125;); Answer:使用 AJAX 取出 name=”csrf-token” 的 meta tag, 並將內容設定到 headers ‘X-CSRF-TOKEN’ # X-XSRF-TokenLaravel 預設會將 CSRF token 存在 Response 的哪？XSRF_TOKEN cookie Laravel 中, 前端可以從哪一個 cookie 中來設定 X-XSRF-TOKEN？XSRF-TOKEN cookie 一些 JavaScript 框架, 像是 Angular 以及 Axios, 預設會取 哪個 cookie 中帶入同源請求的 哪個 header 中？ XSRF-TOKEN cookie X-XSRF-TOKEN header","link":"/zh-tw/laravel-the-basics-csrf-protection/"},{"title":"Laravel - Testing - Mocking (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Mocking Objects以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Service;use Mockery;use Mockery\\MockInterface;public function test_something_can_be_mocked()&#123; $this-&gt;instance( Service::class, Mockery::mock(Service::class, function (MockInterface $mock) &#123; $mock-&gt;shouldReceive(&#x27;process&#x27;)-&gt;once(); &#125;) );&#125; Answer:將 service::class 綁到 service container 當中, 當完成綁定後, service container 將會使用 mocked class, 而不是原本的 object, 並指定 process method 會被呼叫一次 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Service;use Mockery\\MockInterface;$mock = $this-&gt;mock(Service::class, function (MockInterface $mock) &#123; $mock-&gt;shouldReceive(&#x27;process&#x27;)-&gt;once();&#125;); Answer:將 service::class 綁到 service container 當中, 當完成綁定後, service container 將會使用 mocked class, 而不是原本的 object, 並指定 process method 會被呼叫一次 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Service;use Mockery\\MockInterface;$mock = $this-&gt;partialMock(Service::class, function (MockInterface $mock) &#123; $mock-&gt;shouldReceive(&#x27;process&#x27;)-&gt;once();&#125;); Answer:使用 partialMock() 將 Service::class 綁定 container, 所以 container 會使用 mocked class, 而不是實際上的 object, 並使用 shouldReceive() 宣告 process method 會被呼叫, once() 定義次數partialMock 只 mock 被呼叫的 method, 其他 method 如果在 testing 過程中有被呼叫, 則正常執行 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Tests\\Feature;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use Illuminate\\Foundation\\Testing\\WithoutMiddleware;use Illuminate\\Support\\Facades\\Cache;use Tests\\TestCase;class UserControllerTest extends TestCase&#123; public function testGetIndex() &#123; Cache::shouldReceive(&#x27;get&#x27;) -&gt;once() -&gt;with(&#x27;key&#x27;) -&gt;andReturn(&#x27;value&#x27;); $response = $this-&gt;get(&#x27;/users&#x27;); // ... &#125;&#125; Answer:mock Cache facade, 並使用 shouldReceive 斷言 get() 將被呼叫, once() 代表次數, with() 代表 parameter, 而 return value 代表回傳的值, 如果沒有達到以上的斷言, 則 fail Laravel testing 中, 如果要 mock config, 該使用？config::set Laravel testing 中, 如果要 mock http testing, 該使用？http testing method # Facade Spies以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Cache;public function test_values_are_be_stored_in_cache()&#123; Cache::spy(); $response = $this-&gt;get(&#x27;/&#x27;); $response-&gt;assertStatus(200); Cache::shouldHaveReceived(&#x27;put&#x27;)-&gt;once()-&gt;with(&#x27;name&#x27;, &#x27;Taylor&#x27;, 10);&#125; Answer:使用 spy() method 來紀錄下所有 testing 過程與 Cache facade 的互動, 並在最後 assert, 若不符合 assertion 則報錯 # Bus Fake以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Tests\\Feature;class ExampleTest extends TestCase&#123; public function test_orders_can_be_shipped() &#123; Bus::fake(); // Perform order shipping... Bus::assertDispatched(ShipOrder::class); Bus::assertNotDispatched(AnotherJob::class); &#125;&#125; Answer:使用 Bus facade 的 fake(), 任何使用到 Bus facade dispatch 的 job 將不會真正的被 dispatch最後可使用 assertDispatched(), assertNotDispatched() 來斷言哪個 job 被 dispatch 了, 哪個沒有 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpBus::assertDispatched(function (ShipOrder $job) use ($order) &#123; return $job-&gt;order-&gt;id === $order-&gt;id;&#125;); Answer:當使用 Bus facade 的 assertDispatched(), assertNotDispatched() 時, 可帶入 closure 來判定被 dispatched 的 job 有通過一定的規則 # Job Chains以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Jobs\\RecordShipment;use App\\Jobs\\ShipOrder;use App\\Jobs\\UpdateInventory;use Illuminate\\Support\\Facades\\Bus;Bus::assertChained([ ShipOrder::class, RecordShipment::class, UpdateInventory::class]); Answer:assert 指定的 job 有被 chained 且 dispatched 以下的 Laravel example code 的意思是？ Example:&lt;?phpBus::assertChained([ new ShipOrder, new RecordShipment, new UpdateInventory,]); Answer:assert 指定的 job 有被 chained 且 dispatched, 除了可帶入 class name, 也可帶入 class instance # Job Batches以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Bus\\PendingBatch;use Illuminate\\Support\\Facades\\Bus;Bus::assertBatched(function (PendingBatch $batch) &#123; return $batch-&gt;name == &#x27;import-csv&#x27; &amp;&amp; $batch-&gt;jobs-&gt;count() === 10;&#125;); Answer:使用 assertBatched() 來斷言 batch of jobs 已被 dispatched, 可在 closure 內取得 PendingBatch, 取得該 batch 的資料, 並定義該 batch 應該要有的條件 # Event Fake以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function test_orders_can_be_shipped() &#123; Event::fake(); // Perform order shipping... Event::assertDispatched(OrderShipped::class); Event::assertDispatched(OrderShipped::class, 2); Event::assertNotDispatched(OrderFailedToShip::class); Event::assertNothingDispatched(); &#125;&#125; Answer:使用 fake(), 則該 event 的 listener 將不會真正的 dispatchassertDispatched() 斷言指定的 event 需被 dispatchedassertDispatched() arg2 代表該 event 需被 dispatched 2 次assertNotDispatched 斷言該 event 沒被 dispatchedassertNothingDispatched 斷言沒有任何 event 被 dispatched 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpEvent::assertDispatched(function (OrderShipped $event) use ($order) &#123; return $event-&gt;order-&gt;id === $order-&gt;id;&#125;); Answer:使用 closure 來斷言, 符合定義條件的 job 有被 dispatched 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpEvent::assertListening( OrderShipped::class, [SendShipmentNotification::class, &#x27;handle&#x27;]); Answer:斷言指定的 listener 有 listen 定義的 event 以下的 Laravel testing 中, 如果有使用到 Factory 的 model event, Event::fake() 需使用在 Factory 之後, 原因為何？因為一旦使用了 Event::fake(), 所有 event 都不會被執行 # Faking A Subset Of Events以下的 Laravel testing example code 的意思是？ Example:&lt;?phppublic function test_orders_can_be_processed()&#123; Event::fake([ OrderCreated::class, ]); $order = Order::factory()-&gt;create(); Event::assertDispatched(OrderCreated::class); // Other events are dispatched as normal... $order-&gt;update([...]);&#125; Answer:可帶入 class 到 Event::fake(), 這樣只有該 event 會被 fake, 其餘的 event 照常執行 Scoped Event Fakes以下的 Laravel testing example code 的意思是？ Example:&lt;?phpclass ExampleTest extends TestCase&#123; public function test_orders_can_be_processed() &#123; $order = Event::fakeFor(function () &#123; $order = Order::factory()-&gt;create(); Event::assertDispatched(OrderCreated::class); return $order; &#125;); $order-&gt;update([...]); &#125;&#125; Answer:只有 fakeFor() 內, closure 範圍內的 event 才會被 fake, 其餘的照常執行 # HTTP Fake可參考 Fake HTTP Client # Mail Fake以下的 Laravel testing example code 的意思是？ Example:&lt;?phppublic function test_orders_can_be_shipped()&#123; Mail::fake(); Mail::assertNothingSent(); Mail::assertSent(OrderShipped::class); Mail::assertSent(OrderShipped::class, 2); Mail::assertNotSent(AnotherMailable::class);&#125; Answer:使用 Mail::fake(), 模擬 mail 寄出 testing, 實際上不會真的寄出assert 沒有任何 mailable 被送出assert 指定的 mailable 被發送assert 指定的 mailable 被發送兩次assert 指定的 mailable 沒有被送出 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpMail::assertQueued(OrderShipped::class);Mail::assertNotQueued(OrderShipped::class);Mail::assertNothingQueued(); Answer:當要測試用 queue 發送的 mailable 時, 使用 assertQueued()assert OrderShipped mailable 由 queue 發送assert OrderShipped mailable 沒有由 queue 發送assert 沒有任何 mailable 經由 queue 被發送 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpMail::assertSent(function (OrderShipped $mail) use ($order) &#123; return $mail-&gt;order-&gt;id === $order-&gt;id;&#125;); Answer:assertSent 以及 assertNotSent 也可帶入 closure, 判斷是否有通過 closure 內條件的 mailable 被發送 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpMail::assertSent(OrderShipped::class, function ($mail) use ($user) &#123; return $mail-&gt;hasTo($user-&gt;email) &amp;&amp; $mail-&gt;hasCc(&#x27;...&#x27;) &amp;&amp; $mail-&gt;hasBcc(&#x27;...&#x27;);&#125;); Answer:除了 assert 指定 mailable 被送出外, 還可以 assert寄給誰cc 給誰bcc 給誰 # Notification Fake以下的 Laravel testing example code 的意思是？ Example:&lt;?phppublic function test_orders_can_be_shipped()&#123; Notification::fake(); // Perform order shipping... Notification::assertNothingSent(); Notification::assertSentTo( [$user], OrderShipped::class ); Notification::assertNotSentTo( [$user], AnotherNotification::class );&#125; Answer:使用 Notification::fake()斷言沒有任何 notification sent斷言指定的 notification sent to a given user斷言指定的 notification not sent to a given user 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpNotification::assertSentTo( $user, function (OrderShipped $notification, $channels) use ($order) &#123; return $notification-&gt;order-&gt;id === $order-&gt;id; &#125;); Answer:assertSentTo 可帶入 closure, 若有符合 closure 內條件的 mailable sent, 則 assertion 成立 # On-Demand Notifications以下的 Laravel testing example code 的意思是？ Example:&lt;?phpuse Illuminate\\Notifications\\AnonymousNotifiable;Notification::assertSentTo( new AnonymousNotifiable, OrderShipped::class); Answer:當測試 On-Demand notification 時, 原本帶入 user 的 arg1, 改帶入 AnonymousNotifiable instance 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpNotification::assertSentTo( new AnonymousNotifiable, OrderShipped::class, function ($notification, $channels, $notifiable) use ($user) &#123; return $notifiable-&gt;routes[&#x27;mail&#x27;] === $user-&gt;email; &#125;); Answer:當測試 on-demand notification 時, 可帶入 closure, assert 實際上發送的 mail 與指定 user 的 mail 相同 # Queue Fake以下的 Laravel testing example code 的意思是？ Example:&lt;?phppublic function test_orders_can_be_shipped()&#123; Queue::fake(); // Perform order shipping... Queue::assertNothingPushed(); Queue::assertPushedOn(&#x27;queue-name&#x27;, ShipOrder::class); Queue::assertPushed(ShipOrder::class, 2); Queue::assertNotPushed(AnotherJob::class);&#125; Answer:fake queue facade, 所以不會真的把 job push 到 queue 當中assert 沒有任何 job 被 pushassert ShipOrder job 被 push 到 queue-nameassert ShipOrder job 被 push 兩次assert AnotherJob 沒有被 push 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpQueue::assertPushed(function (ShipOrder $job) use ($order) &#123; return $job-&gt;order-&gt;id === $order-&gt;id;&#125;); Answer:可 pass closure 到 assertPushed(), assertNotPushed(), 更明確的斷言是哪些 job 被 push 或沒被 push # Job Chains以下的 Laravel testing example code 的意思是？ Example:&lt;?phpQueue::assertPushedWithChain(ShipOrder::class, [ RecordShipment::class, UpdateInventory::class]); Answer:斷言哪些 queue 被 queue chained, arg1 為第一個 job, arg2 為其餘的 jobs 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpQueue::assertPushedWithChain(ShipOrder::class, [ new RecordShipment, new UpdateInventory,]); Answer:assertPushedWithChain() 可 pass class name, 也可 pass instance 以下的 Laravel testing example code 的意思是？ Example:&lt;?phpQueue::assertPushedWithoutChain(ShipOrder::class); Answer:使用 assertPushedWithoutChain() 來斷言 ShipOrder job 沒有被 chained # Storage Fake以下的 Laravel testing example code 的意思是？ Example:&lt;?phppublic function test_albums_can_be_uploaded()&#123; Storage::fake(&#x27;photos&#x27;); $response = $this-&gt;json(&#x27;POST&#x27;, &#x27;/photos&#x27;, [ UploadedFile::fake()-&gt;image(&#x27;photo1.jpg&#x27;), UploadedFile::fake()-&gt;image(&#x27;photo2.jpg&#x27;) ]); Storage::disk(&#x27;photos&#x27;)-&gt;assertExists(&#x27;photo1.jpg&#x27;); Storage::disk(&#x27;photos&#x27;)-&gt;assertExists([&#x27;photo1.jpg&#x27;, &#x27;photo2.jpg&#x27;]); Storage::disk(&#x27;photos&#x27;)-&gt;assertMissing(&#x27;missing.jpg&#x27;); Storage::disk(&#x27;photos&#x27;)-&gt;assertMissing([&#x27;missing.jpg&#x27;, &#x27;non-existing.jpg&#x27;]);&#125; Answer:使用 Storage fake() 一個 fake disk產生 fake image斷言 fake disk photos 存在某些檔案斷言 fake disk photos 不存在某些檔案 以下的 Laravel testing example code 的意思是？ Example:&lt;?php$response = $this-&gt;json(&#x27;POST&#x27;, &#x27;/photos&#x27;, [ UploadedFile::fake()-&gt;image(&#x27;photo1.jpg&#x27;), UploadedFile::persistentFake()-&gt;image(&#x27;photo2.jpg&#x27;)]); Answer:使用 fake 時, 該 fake file 會在 testing 結束後從 temp dir 中被刪除若要保留, 可使用 persistentFake() # Interacting With Time以下的 Laravel testing example code 的意思是？ Example:&lt;?phppublic function testTimeCanBeManipulated()&#123; $this-&gt;travel(5)-&gt;milliseconds(); $this-&gt;travel(5)-&gt;seconds(); $this-&gt;travel(5)-&gt;minutes(); $this-&gt;travel(5)-&gt;hours(); $this-&gt;travel(5)-&gt;days(); $this-&gt;travel(5)-&gt;weeks(); $this-&gt;travel(5)-&gt;years(); $this-&gt;travel(-5)-&gt;hours(); $this-&gt;travelTo(now()-&gt;subHours(6)); $this-&gt;travelBack();&#125; Answer:&lt;?phppublic function testTimeCanBeManipulated()&#123; // Travel into the future... $this-&gt;travel(5)-&gt;milliseconds(); $this-&gt;travel(5)-&gt;seconds(); $this-&gt;travel(5)-&gt;minutes(); $this-&gt;travel(5)-&gt;hours(); $this-&gt;travel(5)-&gt;days(); $this-&gt;travel(5)-&gt;weeks(); $this-&gt;travel(5)-&gt;years(); // Travel into the past... $this-&gt;travel(-5)-&gt;hours(); // Travel to an explicit time... $this-&gt;travelTo(now()-&gt;subHours(6)); // Return back to the present time... $this-&gt;travelBack();&#125; 可使用 travel() method, 定義當前時間以方便測試 # Additional以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andSet($property, $value);// or$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;set($property, $value); Answer:給 mock object 設定 public property 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andThrow(&#x27;exception_name&#x27;, &#x27;message&#x27;, 123456789); Answer:定義指定的 method return 指定的 exception, message, 以及 status code 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andThrow(new Exception); Answer:定義指定的 mock method return 指定的 exception 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturnSelf(); Answer:return mock class name 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturnArg(1); Answer:定義 return value 為 index 1 的 arg 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturnUsing(closure, ...); Answer:若要對 return value 做計算, 可使用 andReturnUsing() 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturnNull();// or$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturn([null]); Answer:定義 method return value 為 null 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturnValues([$value1, $value2, ...]) Answer:使用 andReturn() 定義 return value, 會按順序 return $value, 若呼叫次數大於定義 value 數量, 會總回傳最後一個 value 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;)-&gt;andReturn(1, 2, 3);$mock-&gt;foo(); // int(1)$mock-&gt;foo(); // int(2)$mock-&gt;foo(); // int(3)$mock-&gt;foo(); // int(3) Answer:使用 andReturn() 定義 return value, 會按順序 return $value, 若呼叫次數大於定義 value 數量, 會總回傳最後一個 value 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturn($value1, $value2, ...) Answer:andReturn() 亦可定義多個回傳值, 第一次呼叫回傳 $value1, 第二次 value2, 以此類推 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;andReturn($value); Answer:andReturn() 定義回傳值 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;withNoArgs(); Answer:定義 expectation, 該 method 沒有 args 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;withAnyArgs(); Answer:定義 expectation, 該 method 不管 pass 什麼 arg 都可以 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;withAnyArgs(); Answer:定義 expectation, 該 method 不管 pass 什麼 arg 都可以 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;withSomeOfArgs(1, 2);$mock-&gt;foo(1, 2, 3); $mock-&gt;foo(3, 2, 1); $mock-&gt;foo(&#x27;1&#x27;, &#x27;2&#x27;); $mock-&gt;foo(3); Answer:判斷實際上有無帶入 withSomeOfArgs() 定義的 method, 有包含即可, 多帶也可, 少了就不行// matches the expectation// matches the expectation (passed order doesn’t matter)// throws a NoMatchingExpectationException (type should be matched)// throws a NoMatchingExpectationException###### 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;withArgs(closure); Answer:withArgs() 內也可帶入 closure, closure return 將帶入的 args, 不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;)-&gt;with(&#x27;Hello&#x27;);$mock-&gt;foo(&#x27;Goodbye&#x27;); // throws a NoMatchingExpectationException Answer:使用 with() 來定義將帶入 mocked method 的 args, 若不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;with($arg1, $arg2, ...);// or$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;withArgs([$arg1, $arg2, ...]); Answer:使用 with() 或 withArgs() 來定義將帶入 mocked method 的 args, 若不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldNotReceive(&#x27;name_of_method&#x27;); Answer:定義指定 method 不該被呼叫 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;, [&#x27;name_of_method_1&#x27; =&gt; &#x27;return value 1&#x27;, &#x27;name_of_method_2&#x27; =&gt; &#x27;return value 2&#x27;]); Answer:定義多個 expectation 以及其 shortcut 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive([ &#x27;name_of_method_1&#x27; =&gt; &#x27;return value 1&#x27;, &#x27;name_of_method_2&#x27; =&gt; &#x27;return value 2&#x27;,]); Answer:可定義多個 expectation 以及其 return value 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method_1&#x27;, &#x27;name_of_method_2&#x27;); Answer:可以定義多個 expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php\\Mockery::mock(&#x27;MyClass&#x27;)-&gt;shouldIgnoreMissing()-&gt;asUndefined(); Answer:PHP 7.0 ~ 7.1 的版本, 會根據不同的 type 回傳不同的值, 可使用 asUndefined() 一律回傳 null 以下的 Laravel example code 的意思是？ Example:&lt;?php\\Mockery::mock(&#x27;MyClass&#x27;)-&gt;shouldIgnoreMissing(); Answer:將 MyClass 中沒有定義 expectation 的 method, 一律 return null與 makePartial 的差異在於, makePartial() 會去呼叫 parent class, 而 shouldIgnoreMissing() 則是 return null 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;, [$constructorArg1, $constructorArg2]);$mock = \\Mockery::mock(&#x27;MyClass&#x27;, &#x27;MyInterface&#x27;, [$constructorArg1, $constructorArg2]); Answer:當 mock class 時, 可 pass constructor arguments 以下的 Laravel example code 的意思是？ Example:&lt;?php// 待測 classclass Fetcher&#123; const SUCCESS = 0; const FAILURE = 1; public function fetch() &#123; // Fetcher gets something for us from somewhere... return self::SUCCESS; &#125;&#125;// testing code\\Mockery::getConfiguration()-&gt;setConstantsMap([ &#x27;Fetcher&#x27; =&gt; [ &#x27;SUCCESS&#x27; =&gt; &#x27;success&#x27;, &#x27;FAILURE&#x27; =&gt; &#x27;fail&#x27;, ]]);$mock = \\Mockery::mock(&#x27;Fetcher&#x27;);var_dump($mock::SUCCESS); // (string) &#x27;success&#x27;var_dump($mock::FAILURE); // (string) &#x27;fail&#x27; Answer:Mockery 預設並不會 mock class constant, 因此使用 setConstantsMap() 來定義 class constant 以下的 Laravel example code 的意思是？ Example:&lt;?php// to-be test classclass Fetcher&#123; const SUCCESS = 0; const FAILURE = 1; public function fetch() &#123; // Fetcher gets something for us from somewhere... return self::SUCCESS; &#125;&#125;class MyClass&#123; public function doFetching($fetcher) &#123; $response = $fetcher-&gt;fetch(); if ($response == Fetcher::SUCCESS) &#123; echo &quot;Thanks!&quot; . PHP_EOL; &#125; else &#123; echo &quot;Try again!&quot; . PHP_EOL; &#125; &#125;&#125;// testclass FetcherStub&#123; const SUCCESS = 0; const FAILURE = 1;&#125;$mock = \\Mockery::nameMock(&#x27;Fetcher&#x27;, &#x27;FetcherStub&#x27;)$mock-&gt;shouldReceive(&#x27;fetch&#x27;) -&gt;andReturn(0);$myClass = new MyClass();$myClass-&gt;doFetching($mock); Answer:Mockery 當 mock 一個 class 時, 並不會 mock class constant, 因此可以建立一個 stub class, 裡頭定義 class contant, 並使用 nameMock() 來 mock 待測的 class, 並 extend stub class 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ClassToTest &#123; public function methodToTest() &#123; return MyClass::someStaticMethod(); &#125;&#125;public function testNewMethodToTest()&#123; $mock = Mockery::mock(&#x27;alias:MyClass&#x27;); $mock-&gt;shouldreceive(&#x27;someStaticMethod&#x27;)-&gt;andReturn(&#x27;someResult&#x27;); $classToTest = new ClassToTest(); $result = $classToTest-&gt;methodToTest(); $this-&gt;assertEquals(&#x27;someResult&#x27;, $result);&#125; Answer:使用 alias 來 test public static method 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ClassToTest &#123; public function methodToTest() &#123; $myClass = new MyClass(); $result = $myClass-&gt;someMethod(); return $result; &#125;&#125;public function testMethodToTest()&#123; $mock = Mockery::mock(&#x27;overload:MyClass&#x27;); $mock-&gt;shouldreceive(&#x27;someMethod&#x27;)-&gt;andReturn(&#x27;someResult&#x27;); $classToTest = new ClassToTest(); $result = $classToTest-&gt;methodToTest(); $this-&gt;assertEquals(&#x27;someResult&#x27;, $result);&#125; Answer:使用 overload make an instance mock, 當一個 class 被建立, 會使用 overload mock 來替代這個 class 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(new MyClass); Answer:如果該 class 或其 method 已被 marked final, 可以 mock new class, 但這個 mock class 的 type hint check 將無作用 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Foo &#123; function foo() &#123; return 123; &#125; function bar() &#123; return $this-&gt;foo(); &#125;&#125;$foo = mock(&quot;Foo[!foo]&quot;);$foo-&gt;foo(); // int(123)$foo-&gt;bar(); // error, no expectation set Answer:指定除了 foo method 之外的 method 都 mock, 但建議使用 runtime partial, 因為直接 mock 特定的 method 會去呼叫 origin constructor, 可能會有意料外的行為 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Foo &#123; function foo() &#123; return 123; &#125; function bar() &#123; return $this-&gt;foo(); &#125;&#125;$foo = mock(&quot;Foo[foo]&quot;);$foo-&gt;foo(); // error, no expectation set$foo-&gt;shouldReceive(&#x27;foo&#x27;)-&gt;andReturn(456);$foo-&gt;foo(); // int(456)// setting an expectation for this has no effect$foo-&gt;shouldReceive(&#x27;bar&#x27;)-&gt;andReturn(999);$foo-&gt;bar(); // int(456) Answer:可以 mock 特定的 class 中的 method, 但建議使用 runtime partial, 因為直接 mock 特定的 method 會去呼叫 origin constructor, 可能會有意料外的行為 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass BigParentClass&#123; public function doesEverything() &#123; // sets up database connections // writes to log files &#125;&#125;class ChildClass extends BigParentClass&#123; public function doesOneThing() &#123; // but calls on BigParentClass methods $result = $this-&gt;doesEverything(); // does something with $result return $result; &#125;&#125;$childClass = \\Mockery::mock(&#x27;ChildClass&#x27;)-&gt;makePartial();$childClass-&gt;shouldReceive(&#x27;doesEverything&#x27;) -&gt;andReturn(&#x27;some result from parent&#x27;);$childClass-&gt;doesOneThing(); // string(&quot;some result from parent&quot;); Answer:建立一個 runtime partial test double of ChildClass, 並且只 mock doesEverything method 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$spy = \\Mockery::spy(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;)-&gt;andReturn(42);$mockResult = $mock-&gt;foo();$spyResult = $spy-&gt;foo();$spy-&gt;shouldHaveReceived()-&gt;foo();var_dump($mockResult); // int(42)var_dump($spyResult); // null Answer:spy always return null as the result of method 以下的 Laravel example code 的意思是？ Example:&lt;?php$spy = \\Mockery::spy(&#x27;MyClass, MyInterface, OtherInterface&#x27;); Answer:建立一個 spy, type 為 MyClass, implement MyInterface 跟 OtherInterface 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass, MyInterface, OtherInterface&#x27;); Answer:mock MyClass, 且 implement MyInterface 以及 OtherInterface 以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan queue:work --name=notifications Answer:給 worker 一個名字, 更易於 identified 以下的 Laravel example code 的意思是？ Example:&lt;?phpdispatch( new SendInvoice($order))-&gt;afterCommit(); Answer:使用 dispatch(), 在所有 transaction 都 commit 之後才 dispatch 該 job 以下的 Laravel example code 的意思是？ Example:&lt;?phpdispatch( new SendInvoice($order))-&gt;afterResponse(); Answer:使用 dispatch(), 在 connection close 之後, 保持 PHP process alive 來執行 job, 建議只執行簡單的 job 以下的 Laravel example code 的意思是？ Example:&lt;?phpBus::chain([ new DownloadRepo, new RunTests, new Deploy])-&gt;dispatch() Answer:使用 Bus::chain() dispatch chained job, job 會按順序執行 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass OrderController&#123; public function store() &#123; // ... Bus::dispatchAfterResponse(new ReleaseLocks()); return response(&#x27;OK!&#x27;); &#125;&#125; Answer:如果 job 很簡單, 可以不需要 dispatch 到 queue, 而是在 response 後處理當 close connection with browser 後, 保持 PHP process alive 執行該 job但如果該 job 不是很簡短, 那還是建議跑 queue 以下的 example 中, 若 RestartNginx job 沒有 use InteractWithQueue, 以及 Queueable trait, 那 Bus 會使用哪個 driver dispatch 該 job? Example:&lt;?phpclass DeployProject implements ShouldQueue&#123; public function handle() &#123; // Deployment logic... Bus::dispatchNow(new RestartNginx()); &#125;&#125; Answer:會直接 invoke, 不會觸發 queue event Laravel queue 中, 當 dispatch with sync queue driver, 會觸發 job failed event 嗎？會 Laravel queue 中, 當 dispatch with sync queue driver, 會觸發 queue event 嗎？會 以下的 example 中, 若 RestartNginx job use InteractWithQueue, 以及 Queueable trait, 那 Bus 會使用哪個 driver dispatch 該 job? Example:&lt;?phpclass DeployProject implements ShouldQueue&#123; public function handle() &#123; // Deployment logic... Bus::dispatchNow(new RestartNginx()); &#125;&#125; Answer:sync queue driver 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Bus;Bus::dispatchToQueue( new SendInvoice($order)); Answer:使用 Bus facade 來 dispatch a single job 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass TenancyProvider extends ServiceProvider&#123; public function boot() &#123; Queue::createPayloadUsing(function () &#123; return [&#x27;tenant_id&#x27; =&gt; Tenant::get()-&gt;id]; &#125;); Event::listen(JobProcessing::class, function ($event)&#123; $tenant = Tenant::find( $event-&gt;job-&gt;payload()[&#x27;tenant_id&#x27;] ); $tenant-&gt;configureDatabaseConnection(); $tenant-&gt;setAsCurrent(); &#125;); &#125; &#125; Answer:listen job processed event, 在該 job 被 pick up 但還未執行前, 設定特定資料庫的連線使用 Queue::createPayloadUsing() 來 insert tenant_id 到 raw payload, 之後當 worker 取出該 job, 就可以透過先前 insert 的 tenant_id 來取得 tenant, 並完成連線設定 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ResetStateMiddleware&#123; public function handle($job, $next) &#123; app()-&gt;setLocale(&#x27;en&#x27;); Vendor::$name = &#x27;Laravel&#x27;; return $next($job); &#125;&#125; Answer:因為 worker 是一個 process, 不會隨著 job 完成就釋放, 因此像是 static property 會改變 之後 worker 的狀態, 包括所以務必在處理完當下 job 之後, 把狀態改回來使用 middleware 的方式在每次 job 執行前 reset locale 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass SendReport&#123; public function handle() &#123; Vendor::$name = $this-&gt;vendor-&gt;name; // Run the job logic... Vendor::$name = &#x27;Laravel&#x27;; &#125; public function failed($e) &#123; Vendor::$name = &#x27;Laravel&#x27;; &#125;&#125; Answer:因為 worker 是一個 process, 不會隨著 job 完成就釋放, 因此像是 static property 會改變 之後 worker 的狀態, 包括所以務必在處理完當下 job 之後, 把狀態改回來 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass SendReport&#123; public function __construct($report, $locale) &#123; // ... &#125; public function handle() &#123; app()-&gt;setLocale($this-&gt;locale); // Run the job logic... app()-&gt;setLocale(&#x27;en&#x27;); &#125;&#125; Answer:因為 worker 是一個 process, 不會隨著 job 完成就釋放, 因此像是 app()-&gt;setLocale() 這種 global method 會改變 worker 的狀態, 包括所以務必在處理完當下 job 之後, 把狀態改回來 以下的 Laravel job 中, 何謂 idempotent job？表示不管執行幾次都不會有副作用, 像是 public function handle()&#123; if ($this-&gt;invoice-&gt;refunded) &#123; return $this-&gt;delete(); &#125; $this-&gt;invoice-&gt;refund(); &#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass GenerateReport implements ShouldQueue&#123; use SerializesModels; public function __construct(Report $report) &#123; $this-&gt;report = $report; &#125; public function handle() &#123; app( \\Illuminate\\Contracts\\Cache\\Factory::class )-&gt;get(...); &#125;&#125; Answer:若使用 dependency injection, Factory 會需要經過 unserialised / serialised, 會增加很大的 CPU overhead, 若使用 service container 對 worker 來說會非常簡單Model 部分, 使用 SerializesModels trait, 只 pass model identifier, 等到 execute 時在取出相對應的 model, 同樣降低很多的 overhead Laravel testing 中, 如果呼叫了沒使用 shouldHaveReceived 定義的 method, 會噴錯嗎？不會, 除非使用 shouldNotHaveReceived() Laravel testing 中, 如果呼叫了沒使用 shouldReceive 定義的 method, 會噴錯嗎？會 以下的 Laravel example code 的意思是？ Example:&lt;?php// classclass Reservation&#123; public $tickets; public $email; public function __construct($tickets, $email) &#123; $this-&gt;tickets = $tickets; $this-&gt;email = $email; &#125; public function complete($paymentGateway, $paymentToken) &#123; $charge = $paymentGateway-&gt;charge($this-&gt;totalPrice(), $paymentToken); return Order::forReservation($this, $charge); &#125; private function totalPrice() &#123; return $this-&gt;tickets-&gt;sum(&#x27;price&#x27;); &#125;&#125;// testclass ReservationTest extends PHPUnit_Framework_TestCase&#123; function test_the_reservation_is_completed_successfully() &#123; // Arrange $tickets = collect([ [&#x27;price&#x27; =&gt; 1250], [&#x27;price&#x27; =&gt; 1250], [&#x27;price&#x27; =&gt; 1250], ]); $paymentGateway = Mockery::spy(&#x27;PaymentGateway&#x27;); // Act $reservation = new Reservation($tickets, &#x27;adam@example.com&#x27;); $order = $reservation-&gt;complete($paymentGateway, &#x27;tok_valid-token&#x27;); // Assert $this-&gt;assertEquals(&#x27;adam@example.com&#x27;, $order-&gt;email); $paymentGateway-&gt;shouldHaveReceived(&#x27;charge&#x27;)-&gt;with(3750, &#x27;tok_valid-token&#x27;)-&gt;once(); &#125; &#125; Answer:使用 spy() 來記下所有 paymentGateway class 在這個 test 過程中的 interaction使用 shouldHaveReceived() 來判定上述的 interaction 中, 是否 charge method 有被呼叫使用 with() 來判定, 是否 interaction 中, 有帶入指定的 parameter使用 once() 來判定, 在 interaction 中, 是否有被呼叫一次 以下的 Laravel example code 的意思是？ Example:&lt;?php// classclass Reservation&#123; public $tickets; public $email; public function __construct($tickets, $email) &#123; $this-&gt;tickets = $tickets; $this-&gt;email = $email; &#125; public function complete($paymentGateway, $paymentToken) &#123; $charge = $paymentGateway-&gt;charge($this-&gt;totalPrice(), $paymentToken); return Order::forReservation($this, $charge); &#125; private function totalPrice() &#123; return $this-&gt;tickets-&gt;sum(&#x27;price&#x27;); &#125;&#125;// testclass ReservationTest extends PHPUnit_Framework_TestCase&#123; function test_the_reservation_is_completed_successfully() &#123; $tickets = collect([ [&#x27;price&#x27; =&gt; 1250], [&#x27;price&#x27; =&gt; 1250], [&#x27;price&#x27; =&gt; 1250], ]); $paymentGateway = Mockery::mock(&#x27;PaymentGateway&#x27;); $paymentGateway-&gt;shouldReceive(&#x27;charge&#x27;)-&gt;with(3750, &#x27;tok_valid-token&#x27;)-&gt;once(); $reservation = new Reservation($tickets, &#x27;adam@example.com&#x27;); $order = $reservation-&gt;complete($paymentGateway, &#x27;tok_valid-token&#x27;); &#125;&#125; Answer:mock PaymentGateway, 所以該 class 不會真的被呼叫使用 shouldReceive() 來定義 mock PaymentGateway 在這個 test 中會被呼叫哪個 methodwith() 定義了將會帶進去的參數once() 表示呼叫一次如果跟以上的定義不相符, 則噴錯 何謂單元測試 3A 原則？Arrange, Act, Assert Laravel test mocking 中, spy 與 mock 的差異是？mock 預先定義 mocked class 中使用 shouldReceive(), with() 指定 method 應該 如何 被呼叫, 包含 parameter 以及次數, 以及 return 值, 若不相符則 failspy 則是會自動在過程中記下 mocked class 指定的 method 被帶入什麼值, 在最後可以使用 shouldHaveReceived 來判斷帶入值與結果是否跟預料的是一樣 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;between($min, $max); Answer:mock ‘MyClass’ class, 並斷言 ‘name_of_method’ method 至少會被呼叫 $min 次, 最多 $max 次, 若不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;atMost() -&gt;times(3); Answer:mock ‘MyClass’ class, 並斷言 ‘name_of_method’ method 最多會被呼叫 3 次, 若不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;atLeast() -&gt;times(3); Answer:mock ‘MyClass’ class, 並斷言 ‘name_of_method’ method 至少會被呼叫 3 次, 若不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;never(); Answer:mock ‘MyClass’ class, 並斷言 ‘name_of_method’ method 不會收到任何呼叫, 若不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;twice(); Answer:mock ‘MyClass’, 並斷言 ‘name_of_method’ method 將被呼叫 2 次, 若不符合則報錯 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;times($n); Answer:mock ‘MyClass’, 並斷言 ‘name_of_method’ method 會被呼叫 ‘$n’ 次, 若不符合則報錯 Laravel Mockery 中, 務必在 each test 結束呼叫哪個 method, 否則 call count expectation 會無法正常運作？\\Mockery::close() 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;name_of_method&#x27;) -&gt;zeroOrMoreTimes(); Answer:mock MyClass, 並預測 name_of_method method 會被呼叫 0 或多次 以下的 Laravel example code 的意思是？ Example:&lt;?php$helperMock = Mockery::mock(&#x27;Acme\\Helper&#x27;);$helperMock -&gt;shouldReceive(&#x27;trans_c&#x27;) -&gt;once() -&gt;passthru(); Answer:mock Helper class, 預設 trans_c 會被呼叫一次, 實際上 mock 只會判斷 trans_c 是否有被呼叫, 卻不會真正執行 trans_c(), 若有需求要執行 trans_c() 真正的程式碼, 可以加上 passthru() 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;foo&#x27;)-&gt;shouldReceive(&#x27;foo&#x27;)-&gt;andReturn(1)-&gt;getMock(); Answer:取得 mock object from expectation chain 以下的 Laravel example code 的意思是？ Example:&lt;?php$this-&gt;mock-&gt;shouldReceive(&#x27;foo&#x27;)-&gt;with(&#x27;test1&#x27;)-&gt;andReturn(&#x27;bar1&#x27;)-&gt;byDefault(); Answer:使用 byDefault() 可以省略掉在類似的 unit test 中不停的 mock 相同的 object 以下的 Laravel example code 的意思是？ Example:&lt;?php$request = \\Mockery::mock(&#x27;Silhouette\\Http\\Request&#x27;);$response = \\Mockery::mock(&#x27;Silhouette\\Http\\Response&#x27;);$response-&gt;shouldReceive(&quot;setContent&quot;)-&gt;globally()-&gt;ordered();$db = \\Mockery::mock(&#x27;Dabble\\Database&#x27;);$configData = \\Mockery::mock(&#x27;Silhouette\\Configuration\\ConfigurationData&#x27;);$configData-&gt;shouldReceive(&quot;get&quot;)-&gt;andReturn(array(18, 23))-&gt;globally()-&gt;ordered(); Answer:使用 ordered() 來定義 mock object method 被呼叫的順序, 若要在不同 mock object 排序, 可使用 globally()-&gt;ordered()若只需在同一個 mock object 排序, 只需使用 order() 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::ducktype(&#x27;foo&#x27;, &#x27;bar&#x27;)); Answer:可 pass object, 只要該 object 內有 expected 的 method, 就算符合, 若無則不 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::pattern(&#x27;/^foo/&#x27;));// Hamcrest equivalent$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(matchesPattern(&#x27;/^foo/&#x27;)); Answer:可使用 pattern(), 用 regular expression 來判斷 arg 是否符合 expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php$closure = function ($odd, $even, $sum = null) &#123; $result = ($odd % 2 != 0) &amp;&amp; ($even % 2 == 0); if (!is_null($sum)) &#123; return $result &amp;&amp; ($odd + $even == $sum); &#125; return $result;&#125;;$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;)-&gt;withArgs($closure);$mock-&gt;foo(1, 2); // It matches the expectation: the optional argument is not needed$mock-&gt;foo(1, 2, 3); // It also matches the expectation: the optional argument pass the validation$mock-&gt;foo(1, 2, 4); // It doesn&#x27;t match the expectation: the optional doesn&#x27;t pass the validation Answer:可以 pass closure 到 withArgs(), 若 return 值為 true, 則符合 expectation, 若 false 則不 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::on(function ($argument) &#123; if ($argument % 2 == 0) &#123; return true; &#125; return false; &#125;)); Answer:當 return true 時, 符合 expectation, false 則報錯$mock-&gt;foo(4); // matches the expectation$mock-&gt;foo(3); // throws a NoMatchingExpectationException 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&quot;foo&quot;) -&gt;with(\\Mockery::any());// Hamcrest equivalent$mock-&gt;shouldReceive(&quot;foo&quot;) -&gt;with(anything()) Answer:不限制 arg type 或 value, 帶啥都行 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock-&gt;shouldReceive(&quot;foo&quot;) -&gt;with(equalTo(new stdClass)); Answer:當 with() 帶入 object 時, 預設使用 strict comparison, 若要使用 loose comparison, 可使用 equalTo() 以下的 Laravel example code 的意思是？ Example:&lt;?php$object = new stdClass();$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&quot;foo&quot;) -&gt;with($object);// Hamcrest equivalent$mock-&gt;shouldReceive(&quot;foo&quot;) -&gt;with(identicalTo($object)); Answer:當 with() 帶入 object 時, 預設使用 strict comparison 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;expects() -&gt;name_of_method_1($arg1) -&gt;twice() -&gt;andReturn(&#x27;return value&#x27;); Answer:預設 expects() 斷言只被呼叫一次, 相當於 once(), 若要斷言被呼叫多次, 可加入語法, 像是 twice() 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;expects() -&gt;name_of_method_1($arg1) -&gt;andReturn(&#x27;return value&#x27;); Answer:mock ‘MyClass’ object, 並斷言該 method 必須得被呼叫, 以及斷言 arg, 且定義 return value同 should()-&gt;once()-&gt;with()-&gt;andReturn() 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;allows() -&gt;name_of_method_1($arg1) -&gt;andReturn(&#x27;return value&#x27;); Answer:mock ‘MyClass’ object, 並斷言將被呼叫的 method, arg, 以及定義將 return 的 value, 至於 method 被呼叫幾次, 或者根本沒被呼叫都沒差同 shouldHave()-&gt;with() 語法 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;allows([ &#x27;name_of_method_1&#x27; =&gt; &#x27;return value&#x27;, &#x27;name_of_method_2&#x27; =&gt; &#x27;return value&#x27;,]); Answer:mock ‘MyClass’ object, 並斷言將被呼叫的 method 以及定義將 return 的 value, 至於 method 被呼叫幾次或者根本沒被呼叫都沒差同 shouldHave() 語法 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::hasValue(value)); Answer:若 arg 為含有指定 value 的 array, 則符合 expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::hasKey(key)); Answer:若 arg 為含有指定 key 的 array, 則符合 expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::contains(value1, value2)); Answer:當 arg 為含有 value1, value2 的 array, 符合 expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::subset(array(0 =&gt; &#x27;foo&#x27;))); Answer:若 arg 為含有 foo value 的 array, 則符合 expectation, key/value 都會被 compared 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::notAnyOf(1, 2)); Answer:只要不符合 1 或 2, 就符合 args expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::anyOf(1, 2));// Hamcrest equivalent$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(anyOf(1,2)); Answer:只要符合 1 或 2, 就符合 args expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(\\Mockery::not(2));// Hamcrest equivalent$mock-&gt;shouldReceive(&#x27;foo&#x27;) -&gt;with(not(2)); Answer:只要 arg 不是 2 就符合 args expectation 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;MyClass&#x27;);$mock-&gt;shouldReceive(&quot;foo&quot;) -&gt;with(\\Mockery::capture($bar)); Answer:會將實際上 pass 到 foo() 的 arg captured 到 $bar variable, 然後可以在 test 中進一步的 assert $bar 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass MyClass&#123; protected function foo() &#123; &#125;&#125;$mock = \\Mockery::mock(&#x27;MyClass&#x27;) -&gt;shouldAllowMockingProtectedMethods();$mock-&gt;shouldReceive(&#x27;foo&#x27;); Answer:使用 shouldAllowMockingProtectedMethods() 來 mock protected method 以下的 Laravel example code 的意思是？ Example:&lt;?php$spy-&gt;shouldHaveReceived() -&gt;foo(&#x27;bar&#x27;) -&gt;twice(); Answer:斷言 method ‘foo’ with args ‘bar’ 會被呼叫 2 次 以下的 Laravel example code 的意思是？ Example:&lt;?php$spy-&gt;shouldNotHaveReceived(&#x27;foo&#x27;, [&#x27;bar&#x27;]); Answer:斷言 foo method 不會被呼叫, 且 args 為 bar, args 可多個 以下的 Laravel example code 的意思是？ Example:&lt;?php$spy-&gt;shouldHaveReceived(&#x27;foo&#x27;, [&#x27;bar&#x27;]); Answer:斷言 foo method 會被呼叫, 且 args 為 bar, args 可多個 以下的 Laravel example code 的意思是？ Example:&lt;?php// Point.php&lt;?phpnamespace App;class Point &#123; public function setPoint($x, $y) &#123; echo &quot;Point (&quot; . $x . &quot;, &quot; . $y . &quot;)&quot; . PHP_EOL; &#125;&#125;// Rectangle.php&lt;?phpnamespace App;use App\\Point;class Rectangle &#123; public function create($x1, $y1, $x2, $y2) &#123; $a = new Point(); $a-&gt;setPoint($x1, $y1); $b = new Point(); $b-&gt;setPoint($x2, $y1); $c = new Point(); $c-&gt;setPoint($x2, $y2); $d = new Point(); $d-&gt;setPoint($x1, $y2); $this-&gt;draw([$a, $b, $c, $d]); &#125; public function draw($points) &#123; echo &quot;Do something with the points&quot;; &#125;&#125;// test class&lt;?phpclass MyTest extends PHPUnit\\Framework\\TestCase &#123; public function testCreate() &#123; $point = Mockery::mock(&quot;App\\Point&quot;); // check if our mock is called $point-&gt;shouldReceive(&quot;setPoint&quot;)-&gt;andThrow(Exception::class); $rect = Mockery::mock(&quot;App\\Rectangle&quot;)-&gt;makePartial(); $rect-&gt;shouldReceive(&quot;draw&quot;); // pass the App\\Point mock into App\\Rectangle as an alternative // to using new App\\Point() in-place. $rect-&gt;shouldReceive(&quot;newPoint&quot;)-&gt;andReturn($point); $this-&gt;expectException(Exception::class); $rect-&gt;create(0, 0, 100, 100); Mockery::close(); &#125;&#125; Answer:建立一個 custom function 來封裝 new keyword, 然後可以 pass mock class 來取代 auto-loaded new class 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace AppTest;use Mockery as m;/** * @runTestsInSeparateProcesses * @preserveGlobalState disabled */class ServiceTest extends \\PHPUnit_Framework_TestCase&#123; public function testCallingExternalService() &#123; $externalMock = m::mock(&#x27;overload:App\\Service\\External&#x27;); $externalMock-&gt;allows(&#x27;sendSomething&#x27;); $externalMock-&gt;shouldReceive(&#x27;__construct&#x27;) -&gt;once() -&gt;with(5); $service = new \\App\\Service(); $result = $service-&gt;callExternalService($param); &#125;&#125; Answer:test constructor argument 以下的 Laravel example code 的意思是？ Example:&lt;?php\\Mockery::getConfiguration()-&gt;enableReflectionCache();\\Mockery::getConfiguration()-&gt;disableReflectionCache(); Answer:Mockery 大量的使用 reflection(), 所以會 cache, 但 cache 可能會產生一些問題。 如果出現 Error: Internal error: Failed to retrieve the reflection object, 可以把它關掉 以下的 Laravel example code 的意思是？ Example:&lt;?php\\Mockery::getConfiguration()-&gt;allowMockingNonExistentMethods(bool); Answer:設定 Mockery, allow mock non-existent method","link":"/zh-tw/laravel-testing-mocking/"},{"title":"Laravel - The Basics - Error Handling (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # ConfigurationLaravel 中, 哪個設定會決定當遇到錯誤時, 是否印出 stack of trace information？config/app.php 中的 APP_DEBUG option # The Exception Handler# Report MethodLaravel 中, 所有的 exceptions 都是由哪一個 class 所處理？App\\Exceptions\\Handler Laravel 中, 如果我要 log exceptions 或傳送到外部服務, 可以使用 哪一個 class 的 哪一個 method App\\Exceptions\\Handler class report method 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function report(Throwable $exception)&#123; if ($exception instanceof CustomException) &#123; // &#125; parent::report($exception);&#125; Answer:如果 exception 為自定義的某個 exception, 那就執行特別邏輯, 若否, 則執行預設的 log 邏輯 # Global Log ContextLaravel 預設會將目前的 user id 加到 exception 的 log message 當中, 如果我想要增加新的資訊到預設輸出, 我可以在 哪個 class 的 哪個 method 定義這件事？ App\\Exceptions\\Handler class context method 以下位於 App\\Exceptions\\Handler 的 Laravel example code 的意思是？ Example:&lt;?phpprotected function context()&#123; return array_merge(parent::context(), [ &#x27;foo&#x27; =&gt; &#x27;bar&#x27;, &#x27;ray&#x27; =&gt; &#x27;owner&#x27; ]);&#125; Answer:將 [&#39;foo&#39; =&gt; &#39;bar&#39;, &#39;ray&#39; =&gt; &#39;owner&#39;] 加到預設的 context, 即 exception 的 log message 中 # The Report Helper以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function isValid($value)&#123; try &#123; // Validate the value... &#125; catch (Throwable $e) &#123; report($e); return false; &#125;&#125; Answer:catch Throwable error, 將之 report 之後, return false, 原本的行為為 throw($e), 讓 Laravel 預設的 handler 去 render # Ignoring Exceptions By TypeLaravel 中, 解釋以下的 example Example:&lt;?phpprotected $dontReport = [ \\Illuminate\\Auth\\AuthenticationException::class, \\Illuminate\\Auth\\Access\\AuthorizationException::class, \\Symfony\\Component\\HttpKernel\\Exception\\HttpException::class, \\Illuminate\\Database\\Eloquent\\ModelNotFoundException::class, \\Illuminate\\Validation\\ValidationException::class,]; Answer:定義你不想要記錄到 log file 的 exceptions # Render Method解釋以下的 Laravel example Example:&lt;?phppublic function render($request, Throwable $exception)&#123; if ($exception instanceof CustomException) &#123; return response()-&gt;view(&#x27;errors.custom&#x27;, [], 500); &#125; return parent::render($request, $exception);&#125; Answer:&lt;?php// 使用 render method 來定義 exception 的 responsepublic function render($request, Throwable $exception)&#123; // 如果 exception 為指定的 if ($exception instanceof CustomException) &#123; // 做相對應的客製化 response return response()-&gt;view(&#x27;errors.custom&#x27;, [], 500); &#125; // 若非指定 exception, 採用預設 response return parent::render($request, $exception);&#125; # Reportable &amp; Renderable ExceptionsLaravel 中, 如果我想要建立客製化的 exception, 可以在哪個資料夾內建立？app/Exceptions 解釋以下 Laravel example Example:&lt;?phpnamespace App\\Exceptions;use Exception;class RenderException extends Exception&#123; public function report() &#123; // &#125; public function render($request) &#123; return response(...); &#125;&#125; Answer:&lt;?phpnamespace App\\Exceptions;use Exception;// 使用客製化 exception, 並 extend Exeeption, 另一個方法是在 Exception Handler 中的 render() 使用 type hint catch 指定的 exceptionclass RenderException extends Exception&#123; // 可在 report 內定義該 exception 被 throw 時的行為, 即該 log exception 或是導向外部 service, 預設是 log public function report() &#123; // &#125; // 可在 render 內定義該 exception 被 throw 時的行為 public function render($request) &#123; return response(...); &#125;&#125; # HTTP ExceptionsLaravel 中, 如果我要立即的回傳一個 exception, 帶著我指定的 error code, 那我可以使用哪一個 global helper?abort helper 以下的 Laravel example code 的意思是？ Example:&lt;?phpabort(403, &#x27;Unauthorized action.&#x27;); Answer:回傳 exception 403, 並帶著 exception message # Custom HTTP Error PagesLaravel 中, 如果我想要客製化 HTTP Error pages, 可以將檔案至於哪個資料夾下？resources/views/errors/ Laravel 中, 如果我想要客製化 HTTP Error pages, 假設我要客製化的 error code 為 404, 那在資料夾 resources/views/errors/ 中, 我的檔案名稱為？404.blade.php 以下的 Laravel example code 的意思是？ Example:&lt;h2&gt;&#123;&#123; $exception-&gt;getMessage() &#125;&#125;&lt;/h2&gt; Answer:在 view 中取出 exception message 以下的 Laravel example command 的意思是？ Example:php artisan vendor:publish --tag=laravel-errors Answer:會將 vendor 中的 error view publish 到 resources/views 資料夾內, 可以完全自定義","link":"/zh-tw/laravel-the-basics-error-handling/"},{"title":"Laravel - The Basics - Logging (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Configuration# Configuring The Channel NameLaravel 中, 預設的 channel name 是？當前的 environment, 像是 production 或 local 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;stack&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;stack&#x27;, &#x27;name&#x27; =&gt; &#x27;foo&#x27;, &#x27;channels&#x27; =&gt; [&#x27;single&#x27;, &#x27;slack&#x27;],], Answer:定義 stack channel 的資訊driver 為 stackname 為 foo, 會出現在 log 開頭, 如下圖, 預設為當前 environment當 stack channel 被使用時, 定義於 channels 裡頭的 channel 都會被使用 # Available Channel DriversLaravel 中, 預設的 channel driver 是？stack # Configuring The Single and Daily ChannelsLaravel logging 中, single 及 daily channel 有哪三個配置選項？ bubble permission locking Laravel logging 中, single 及 daily channel 的配置選項中, bubble 的意思是？在這個 channel 處理完後, 是否流到別的 channel 去 Laravel logging 中, single 及 daily channel 的配置選項中, bubble 的預設值是？true Laravel logging 中, single 及 daily channel 的配置選項中, permission 的預設值是？0644 Laravel logging 中, single 及 daily channel 的配置選項中, permission 的意思是？log 的預設權限 Laravel logging 中, single 及 daily channel 的配置選項中, locking 的預設值是？false Laravel logging 中, single 及 daily channel 的配置選項中, locking 的用途是？在寫 log 進去之前, 先把它鎖住 # Configuring The Papertrail ChannelLaravel logging 中, 是否有支援 PaperTrail 服務？有 # Configuring The Slack ChannelLaravel logging 中, 是否有支援 Slack 服務？有 # Building Log StacksLaravel logging 中, 如果我想要結合多個 channel, 我可以使用哪一個 channel driver?stack 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;channels&#x27; =&gt; [ &#x27;stack&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;stack&#x27;, &#x27;channels&#x27; =&gt; [&#x27;syslog&#x27;, &#x27;slack&#x27;], ], &#x27;syslog&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;syslog&#x27;, &#x27;level&#x27; =&gt; &#x27;debug&#x27;, ], &#x27;slack&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;slack&#x27;, &#x27;url&#x27; =&gt; env(&#x27;LOG_SLACK_WEBHOOK_URL&#x27;), &#x27;username&#x27; =&gt; &#x27;Laravel Log&#x27;, &#x27;emoji&#x27; =&gt; &#x27;:boom:&#x27;, &#x27;level&#x27; =&gt; &#x27;critical&#x27;, ],], Answer:&lt;?php&#x27;channels&#x27; =&gt; [ &#x27;stack&#x27; =&gt; [ // driver 為預設的 stack &#x27;driver&#x27; =&gt; &#x27;stack&#x27;, // 當 stack 被呼叫時, channels 裡頭的 channel 都會被使用 &#x27;channels&#x27; =&gt; [&#x27;syslog&#x27;, &#x27;slack&#x27;], ], // syslog channel &#x27;syslog&#x27; =&gt; [ // driver 為預設的 syslog &#x27;driver&#x27; =&gt; &#x27;syslog&#x27;, &#x27;level&#x27; =&gt; &#x27;debug&#x27;, ], // slack channel &#x27;slack&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;slack&#x27;, &#x27;url&#x27; =&gt; env(&#x27;LOG_SLACK_WEBHOOK_URL&#x27;), &#x27;username&#x27; =&gt; &#x27;Laravel Log&#x27;, &#x27;emoji&#x27; =&gt; &#x27;:boom:&#x27;, &#x27;level&#x27; =&gt; &#x27;critical&#x27;, ],], # Log LevelsLaravel logging 中, level option 的用途是？定義 channel level, 這樣當我們使用 Log::debug 或 Log::info 時, 所有 level 在 Log level 層級以下的 channel 都會被使用 以下的 Laravel logging example 中, 如果我的 log 等級是 critical, 共會 log 到哪些 channel？ Example:&lt;?php&#x27;channels&#x27; =&gt; [ &#x27;stack&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;stack&#x27;, &#x27;channels&#x27; =&gt; [&#x27;syslog&#x27;, &#x27;slack&#x27;], ], &#x27;syslog&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;syslog&#x27;, &#x27;level&#x27; =&gt; &#x27;debug&#x27;, ], &#x27;slack&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;slack&#x27;, &#x27;url&#x27; =&gt; env(&#x27;LOG_SLACK_WEBHOOK_URL&#x27;), &#x27;username&#x27; =&gt; &#x27;Laravel Log&#x27;, &#x27;emoji&#x27; =&gt; &#x27;:boom:&#x27;, &#x27;level&#x27; =&gt; &#x27;critical&#x27;, ],], Answer:syslog, slack因為 critical 這個 log level 是高於 syslog channel 的 level debug, 所有 level 低於或等於 log level 的 channel 都會被使用 # Writing Log Messages# Writing To Specific Channels以下的 Laravel example code 的意思是？ Example:&lt;?phpLog::channel(&#x27;slack&#x27;)-&gt;info(&#x27;Something happened!&#x27;); Answer:log ‘something happened!’ 到 channel slack, 並指定等級為 info # Advanced Monolog Channel Customization解釋以下 Laravel example Example:&lt;?phpnamespace App\\Components;use Monolog\\Formatter\\JsonFormatter as BaseJsonFormatter;class JsonFormatter extends BaseJsonFormatter&#123; public function format(array $record) &#123; $newRecord = [ &#x27;time&#x27; =&gt; $record[&#x27;datetime&#x27;]-&gt;format(&#x27;Y-m-d H:i:s&#x27;), &#x27;result&#x27; =&gt; json_decode($record[&#x27;message&#x27;], true), ]; if (!empty($record[&#x27;context&#x27;])) &#123; $newRecord = array_merge($newRecord, $record[&#x27;context&#x27;]); &#125; $json = $this-&gt;toJson($newRecord) . ($this-&gt;appendNewline ? &quot;\\n&quot; : &#x27;&#x27;); return $json; &#125;&#125; Answer:&lt;?phpnamespace App\\Components;// 繼承 Monolog 的 JsonFormatter 來達到我們的需求use Monolog\\Formatter\\JsonFormatter as BaseJsonFormatter;class JsonFormatter extends BaseJsonFormatter&#123; public function format(array $record) &#123; // 加入我們需要的資料 $newRecord = [ &#x27;time&#x27; =&gt; $record[&#x27;datetime&#x27;]-&gt;format(&#x27;Y-m-d H:i:s&#x27;), // message 就是我們原本的 log // 注意：這邊的 log 已經被轉換成字串了，並不會是 array，因此建議直接以 JSON 傳遞資料 &#x27;result&#x27; =&gt; json_decode($record[&#x27;message&#x27;], true), ]; // Contextual Information if (!empty($record[&#x27;context&#x27;])) &#123; $newRecord = array_merge($newRecord, $record[&#x27;context&#x27;]); &#125; // 轉換成 JSON 並換行 $json = $this-&gt;toJson($newRecord) . ($this-&gt;appendNewline ? &quot;\\n&quot; : &#x27;&#x27;); return $json; &#125;&#125; Laravel logging 中, 我可以自定義 log 的 format 嗎？可以哦 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;single&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;single&#x27;, &#x27;tap&#x27; =&gt; [App\\Logging\\CustomizeFormatter::class], &#x27;path&#x27; =&gt; storage_path(&#x27;logs/laravel.log&#x27;), &#x27;level&#x27; =&gt; &#x27;debug&#x27;,], Answer:使用 tap, 指定 CustomizeFormatter 為 formatter Laravel logging 中, 如果我想要自定義一個 formatter, 可以放在哪一個資料夾內？app/Logging # Customizing Monolog For ChannelsLaravel logging 中, 如果我想要建立自訂義的 channel, 我可以使用哪一個 driver?monolog 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;logentries&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;monolog&#x27;, &#x27;handler&#x27; =&gt; Monolog\\Handler\\SyslogUdpHandler::class, &#x27;with&#x27; =&gt; [ &#x27;host&#x27; =&gt; &#x27;my.logentries.internal.datahubhost.company.com&#x27;, &#x27;port&#x27; =&gt; &#x27;10000&#x27;, ],], Answer:自定義 channel, 並使用 monolog 底下的 SyslogUdpHandler, 使用 with(), 將 ‘host’ 及 ‘port’ 作為 args 帶入 handler 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;logentries&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;monolog&#x27;, &#x27;handler&#x27; =&gt; Monolog\\Handler\\SyslogUdpHandler::class, &#x27;with&#x27; =&gt; [ &#x27;host&#x27; =&gt; &#x27;example.com&#x27;, &#x27;port&#x27; =&gt; &#x27;8883&#x27;, ],], Answer:使用 SyslogUdpHandler, 並帶入 parameter [&#39;host&#39; =&gt; &#39;example.com&#39;, &#39;port&#39; =&gt; &#39;8883&#39;] # Creating Monolog Handler Channels# Monolog FormattersLaravel logging 中, 當我使用 Monolog 時, 預設的 formatter 是？LineFormatter 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;newrelic&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;monolog&#x27;, &#x27;handler&#x27; =&gt; Monolog\\Handler\\NewRelicHandler::class, &#x27;formatter&#x27; =&gt; &#x27;default&#x27;,], Answer:使用 driver 為 monolog, 且使用的 handler 中已有自己的 formatter # Creating Channels Via Factories以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;channels&#x27; =&gt; [ &#x27;custom&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;custom&#x27;, &#x27;via&#x27; =&gt; App\\Logging\\CreateCustomLogger::class, ],], Answer:不使用預設的 Monolog, 要完全的客制 Monolog, 將 driver 設為 custom, 而 ‘via’ 則是客制 Monolog 的 class 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Logging;use Monolog\\Logger;class CreateCustomLogger&#123; public function __invoke(array $config) &#123; return new Logger(...); &#125;&#125; Answer:建立一個客製化的 logger","link":"/zh-tw/laravel-the-basics-logging/"},{"title":"Laravel - The Basics - Responses (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Creating Responses# Strings &amp; Arrays以下的 Laravel example code 的意思是？ Example&lt;?phpRoute::get(&#x27;/&#x27;, function () &#123; return &#x27;Hello World&#x27;;&#125;); Answer:當收到 &#39;example.com/&#39; 的 GET request 時, return string &#39;Hello World&#39; 以下的 Laravel 範例回以什麼格式 return? Example:&lt;?phpRoute::get(&#x27;/&#x27;, function () &#123; return [1, 2, 3];&#125;); Answer:JSON Laravel 中, 如果我 return 一個 Eloquent collection, 最終會以什麼格式 return?JSON # Response Objects以下的 Laravel example 的意思是？ Example:&lt;?phpRoute::get(&#x27;home&#x27;, function () &#123; return response(&#x27;Hello World&#x27;, 200) -&gt;header(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);&#125;); Answer:&lt;?phpRoute::get(&#x27;home&#x27;, function () &#123; // return stirng &#x27;Hello World&#x27;, status code 為 200 return response(&#x27;Hello World&#x27;, 200) // header Content-type 為 text/plain -&gt;header(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);&#125;); # Attaching Headers To ResponsesLaravel 中, attach header 有哪兩種方式？ chain header method withHeaders method 解釋以下的 Laravel 範例 Example:&lt;?phpreturn response($content) -&gt;header(&#x27;Content-Type&#x27;, $type) -&gt;header(&#x27;X-Header-One&#x27;, &#x27;Header Value&#x27;) -&gt;header(&#x27;X-Header-Two&#x27;, &#x27;Header Value&#x27;); Answer:利用 header chain 的方式 attach 多個 header 解釋以下的 Laravel 範例 Example:&lt;?phpreturn response($content) -&gt;withHeaders([ &#x27;Content-Type&#x27; =&gt; $type, &#x27;X-Header-One&#x27; =&gt; &#x27;Header Value&#x27;, &#x27;X-Header-Two&#x27; =&gt; &#x27;Header Value&#x27;, ]); Answer:使用 withHeaders method 的方式 attach 一個 array # Cache Control MiddlewareLaravel 中, 如果我要快速地針對特定 route 設定 Cache-Control header, 那我可以使用哪個 middleware?cache.headers middleware 解釋下面的 Laravel example Example:&lt;?phpRoute::middleware(&#x27;cache.headers:public;max_age=2628000;etag&#x27;)-&gt;group(function () &#123; Route::get(&#x27;privacy&#x27;, function () &#123; // ... &#125;); Route::get(&#x27;terms&#x27;, function () &#123; // ... &#125;);&#125;); Answer:&lt;?php// 使用 cache.header middleware 來對特定 route 做 Cache-Controel, 語法可參考 // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control// etag 會針對 response 內容做一個 MD5 hash 以做為識別器Route::middleware(&#x27;cache.headers:public;max_age=2628000;etag&#x27;)-&gt;group(function () &#123; Route::get(&#x27;privacy&#x27;, function () &#123; // ... &#125;); Route::get(&#x27;terms&#x27;, function () &#123; // ... &#125;);&#125;); # Attaching Cookies To Responses同 Requests Documentation # Cookies &amp; Encryption以下位於 EncryptCookies middleware 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $except = [ &#x27;cookie_name&#x27;,]; Answer:Laravel 預設會對 cookie encrypt 以及 sign, 所以他們無法被 client 修改或讀取, 如果要取消這個動作, 可以在 &#39;EncryptCookies&#39; middleware 中的 $except property 加入 cookie name # RedirectsLaravel 中, redirect responses 是哪一個 class 的 instance?Illuminate\\Http\\RedirectResponse 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;dashboard&#x27;, function () &#123; return redirect(&#x27;home/dashboard&#x27;);&#125;); Answer:將 &#39;dashboard&#39; 的 GET request redirect 到 &#39;home/dashboard&#39; 這個 route 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::post(&#x27;user/profile&#x27;, function () &#123; // Validate the request... return back()-&gt;withInput();&#125;); Answer:redirect 回上一個位置, 帶著 input # Redirecting To Named RoutesLaravel 中, 當我使用 redirect method without no parameters, 會 return 哪一個 class 的 instance?Illuminate\\Routing\\Redirector 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn redirect()-&gt;route(&#x27;login&#x27;, [&#x27;id&#x27; =&gt; 1]); Answer:redirect 到名為 &#39;login&#39; 的 route, 並帶著 parameter [&#39;id&#39; =&gt; 1] # Populating Parameters Via Eloquent Models以下的 Laravel example code 的意思是？ Example:&lt;?php// For a route with the following URI: profile/&#123;id&#125;return redirect()-&gt;route(&#x27;profile&#x27;, [$user]); Answer:如果要導向的 route 有著 &#123;id&#125; url parameter, 可以直接 pass model 過去, id 會自動被取出 # Redirecting To Controller Actions以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn redirect()-&gt;action(&#x27;HomeController@index&#x27;); Answer:redirect 到一個 controller 名為 HomeController@index 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn redirect()-&gt;action( &#x27;UserController@profile&#x27;, [&#x27;id&#x27; =&gt; 1]); Answer:帶著 parameter 並 redirect 到 UserController@profile # Redirecting To External Domains以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn redirect()-&gt;away(&#x27;https://www.google.com&#x27;); Answer:redirect 到一個非 route 範圍內的 url # Redirecting With Flashed Session Data以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::post(&#x27;user/profile&#x27;, function () &#123; // Update the user&#x27;s profile... return redirect(&#x27;dashboard&#x27;)-&gt;with(&#x27;status&#x27;, &#x27;Profile updated!&#x27;);&#125;); Answer:處理完 POST request 後, redirect 到 &#39;dashboard&#39; route, 並將 message 存到 session 帶過去 以下的 Laravel example code 的意思是？ Example code:&lt;?phpRoute::post(&#x27;user/profile&#x27;, function () &#123; // Update the user&#x27;s profile... return redirect(&#x27;dashboard&#x27;)-&gt;with(&#x27;status&#x27;, &#x27;Profile updated!&#x27;);&#125;); Example blade:&lt;?php@if (session(&#x27;status&#x27;)) &lt;div class=&quot;alert alert-success&quot;&gt; &#123;&#123; session(&#x27;status&#x27;) &#125;&#125; &lt;/div&gt;@endif Answer:redirect 到 dashboard route, 將 status 存到 session 並帶過去, 在 blade page 中拿出 session # Other Responses TypesLaravel 中, 當 response helper 被呼叫並且不帶任何參數時, 會回傳哪一個 class?Illuminate\\Contracts\\Routing\\ResponseFactory # View Responses解釋以下 Laravel example Example:&lt;?phpreturn response() -&gt;view(&#x27;hello&#x27;, $data, 200) -&gt;header(&#x27;Content-Type&#x27;, $type); Answer:&lt;?php// 使用 response global helperreturn response() // return view, customized status code -&gt;view(&#x27;hello&#x27;, $data, 200) // return header -&gt;header(&#x27;Content-Type&#x27;, $type); # JSON Responses以下的 Laravel example code 的意思是？ Example:&lt;?php$array = [&#x27;name&#x27; =&gt; &#x27;Abigail&#x27;, &#x27;state&#x27; =&gt; &#x27;CA&#x27;];return response()-&gt;json($array); Answer:將 $array 變成 json 並回傳 解釋以下 Laravel example Example:&lt;?phpreturn response() -&gt;json([&#x27;name&#x27; =&gt; &#x27;Abigail&#x27;, &#x27;state&#x27; =&gt; &#x27;CA&#x27;]) -&gt;withCallback($request-&gt;input(&#x27;callback&#x27;)); Answer:建立一個 JSONP response # File Downloads以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn response()-&gt;download($pathToFile); Answer:直接觸發瀏覽器下載這個檔案 解釋以下的 Laravel example Example:&lt;?phpreturn response()-&gt;download($pathToFile, $name, $headers); Answer:讓瀏覽器下載檔案, 指定使用者方看到的檔案名稱, 並且指定 header 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn response()-&gt;download($pathToFile)-&gt;deleteFileAfterSend(); Answer:觸發瀏覽器下載一個檔案, 下載完畢後, server 端刪除此檔案 # Streamed Downloads以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn response()-&gt;streamDownload(function () &#123; echo GitHub::api(&#x27;repo&#x27;) -&gt;contents() -&gt;readme(&#x27;laravel&#x27;, &#x27;laravel&#x27;)[&#x27;contents&#x27;];&#125;, &#x27;laravel-readme.md&#x27;); Answer:觸發使用者瀏覽器直接下載檔案, 但分批讀取檔案, 避免檔案的讀取將記憶體吃光 # File Responses以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn response()-&gt;file($pathToFile); Answer:觸發瀏覽器開啟一個檔案, 而不是下載 # Response MacrosLaravel 中, 如果我想要自己建一個 service provider, 那我可以建立在哪一個資料夾中？app/Providers 解釋以下 Laravel example Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Response;use Illuminate\\Support\\ServiceProvider;class ResponseMacroServiceProvider extends ServiceProvider&#123; public function boot() &#123; Response::macro(&#x27;caps&#x27;, function ($value) &#123; return Response::make(strtoupper($value)); &#125;); &#125;&#125; Answer:&lt;?php// 在 App/Providers 資料夾下, 建立一個檔案, 並指定好 namespacenamespace App\\Providers;// 會用到 Facades\\Responseuse Illuminate\\Support\\Facades\\Response;use Illuminate\\Support\\ServiceProvider;// 自定義的 class 需 extends 內建 ServiceProviderclass ResponseMacroServiceProvider extends ServiceProvider&#123; // 在 boot method 中 public function boot() &#123; // 使用 macro method 來定義名為 caps 的 response Response::macro(&#x27;caps&#x27;, function ($value) &#123; // 該 response 的邏輯 return Response::make(strtoupper($value)); &#125;); &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Response;use Illuminate\\Support\\ServiceProvider;class ResponseMacroServiceProvider extends ServiceProvider&#123; public function boot() &#123; Response::macro(&#x27;caps&#x27;, function ($value) &#123; return Response::make(strtoupper($value)); &#125;); &#125;&#125;return response()-&gt;caps(&#x27;foo&#x27;); Answer:使用自定義的 ‘caps’ response, 將 response 的 value 轉大寫","link":"/zh-tw/laravel-the-basics-responses/"},{"title":"Laravel - The Basics - Requests (官方文件原子化翻譯)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Accessing The Request以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public function store(Request $request) &#123; $name = $request-&gt;input(&#x27;name&#x27;); // &#125;&#125; Answer:使用 dependency injection 取得當前 HTTP request # Dependency Injection &amp; Route Parameters以下的 Laravel example code 的意思是？ Example:&lt;?php// 位於 .../Routes/web.phpRoute::put(&#x27;user/&#123;id&#125;&#x27;, &#x27;UserController@update&#x27;);// 位於 controllernamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; public function update(Request $request, $id) &#123; // &#125;&#125; Answer:從 route url parameter 取得 $id, 並 inject 到 update method 當中 # Accessing The Request Via Route Closures以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Http\\Request;Route::get(&#x27;/&#x27;, function (Request $request) &#123; //&#125;); Answer:在 route closure 內 inject 當前 HTTP request, 然後可在 closure 內存取 # Requests Path &amp; Method# Retrieving The Request PathLaravel 中, 假設我的 request URL 是 http://domain.com/foo/bar, 以下的 example code 會取得什麼樣的輸出？ Example:&lt;?php$uri = $request-&gt;path(); Answer:foo/bar 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($request-&gt;is(&#x27;admin/*&#x27;)) &#123; //&#125; Answer:驗證 request path 是否為 admin 開頭 # Retrieving The Request URL以下的 Laravel example code 的意思是？ Example:&lt;?php$url = $request-&gt;fullurl(); Answer:取得全部的 Request URL例如 http://domain.com/foo/bar?appearance=handsome&amp;personality=humourous 全部 以下的 Laravel example code 的意思是？ Example:&lt;?php$url = $request-&gt;url();// URL 為 http://domain.com/foo/bar?appearance=handsome&amp;personality=humourous Answer:取得除了 query string 之前的 url例如http://domain.com/foo/bar?appearance=handsome&amp;personality=humourous # Retrieving The Request Method以下的 Laravel example code 的意思是？ Example:&lt;?php$method = $request-&gt;method(); Answer:取得當前 Request 的 HTTP method 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($request-&gt;isMethod(&#x27;post&#x27;)) &#123; //&#125; Answer:判斷當前 Request 的 HTTP method 是否為 POST # PSR-7 RequestsLaravel 中, 如果我想要取得 PSR-7 request, 而不是 Laravel request, 我需要安裝哪兩個套件？composer require symfony/psr-http-message-bridgecomposer require nyholm/psr7 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Psr\\Http\\Message\\ServerRequestInterface;Route::get(&#x27;/&#x27;, function (ServerRequestInterface $request) &#123; //&#125;); Answer:取得 PSR-7 Request, 需先安裝必要套件 Laravel 中, 當我 return 一個 PSR7 request, Laravel 默認會把它轉成什麼？Laravel response instance # Input Trimming &amp; Normalization以下位於 …/Http/Kernel 的 Laravel example code 的意思是？ Example:&lt;?phpprotected $middleware = [// \\App\\Http\\Middleware\\TrimStrings::class,// \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class,]; Answer:TrimStrings 會將 string input 的前後空白 trim 掉, 而 ConvertEmptyStringsToNull 會將 empty string 轉成 null, 如果不想這些效果, 可在 Http/Kernel 內的 $middleware property 將這兩個 middleware comment 掉 # Retrieving Input# Retrieving All Input Data以下的 Laravel example code 的意思是？ Example:&lt;?php$input = $request-&gt;all() Answer:取得當前 Request 的所有 input data, 型別為 array # Retrieving An Input Value以下的 Laravel example code 的意思是？ Example:&lt;?php$name = $request-&gt;input(&#x27;name&#x27;); Answer:取得當前 Request 當中, input 為 ‘name’ 的值 以下的 Laravel example code 的意思是？ Example:&lt;?php$name = $request-&gt;input(&#x27;name&#x27;, &#x27;Sally&#x27;); Answer:取得 input ‘name’ 的值, 若 ‘name’ 不存在, 則回傳值 ‘Sally’ 以下的 Laravel example code 的意思是？ Example:&lt;?php$name = $request-&gt;input(&#x27;products.*.name&#x27;); Answer:products 會是一個 array, 底下有多個 index, 每個 index 都會有 name input, 這會取得所有 index 的 name input 以下的 Laravel example code 的意思是？ Example:&lt;?php$input = $request-&gt;input() Answer:取得 request 的所有 input # Retrieving Input From The Query String以下的 Laravel example code 的意思是？ Example:&lt;?php$name = $request-&gt;query(&#x27;name&#x27;, &#x27;Helen&#x27;); Answer:從 request 的 query 中取得 name input, 若 name 不存在, 則回傳 ‘Helen’ 以下的 Laravel example code 的意思是？ Example:&lt;?php$name = $request-&gt;query(); Answer:從當前 request 中取得所有的 query key/value # Retrieving Input Via Dynamic PropertiesLaravel 中, 當我使用 Request 的 Dynamic Properties 時, Laravel 會先找 request payload 還是 route parameters?request payload Laravel 中, $request-&gt;name 以及 $request-&gt;input(‘name’) 的差異？ $request-&gt;name 會先尋找 request payload, 再尋找 route parameter 的 field $request-&gt;input(‘name’) 只會從 request payload 中尋找 # Retrieving JSON Input Values以下的 Laravel example code 的意思是? Example:&lt;?php$name = $request-&gt;input(&#x27;user.name&#x27;); Answer:如果說 content type 是 JSON, 從 user object 取得 key 為 name 的 value # Retrieving Boolean Input Values以下的 Laravel example code 的意思是? Example:&lt;?php$archived = $request-&gt;boolean(&#x27;archived&#x27;); Answer:假設 archived file 的 value 為 0 / 1, 會自動轉為 boolean Laravel 中, Request 的 boolean method 會將哪些值轉化成 true? 1 “1” true “true” “on” “yes” # Retrieving A Portion Of The Input Data以下的 Laravel example code 的意思是? Example:&lt;?php$input = $request-&gt;only([&#x27;username&#x27;, &#x27;password&#x27;]); Answer:只取得 username 以及 password input 以下的 Laravel example code 的意思是? Example:&lt;?php$input = $request-&gt;except(&#x27;credit_card&#x27;); Answer:取得 ‘create_card’ 之外的所有 input # Determining If An Input Value Is Present以下的 Laravel example code 的意思是? Example:&lt;?phpif ($request-&gt;has(&#x27;name&#x27;)) &#123; //&#125; Answer:判斷 request 中是否有 ‘name’ 這個 input, 有沒有 value 則不管 以下的 Laravel example code 的意思是? Example:&lt;?phpif ($request-&gt;has([&#x27;name&#x27;, &#x27;email&#x27;])) &#123; //&#125; Answer:判斷 request 中是否 ‘name’ 跟 ‘email’ input 有 present 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($request-&gt;hasAny([&#x27;name&#x27;, &#x27;email&#x27;])) &#123; //&#125; Answer:判斷 Request 中是否有 &#39;name&#39; 或 &#39;email&#39; input present 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($request-&gt;filled(&#x27;name&#x27;) &#123; //&#125; Answer:判斷 request 中, &#39;name&#39; key 是否存在, 且值是否不為 empty, filled() 回傳 boolean 以下的 Laravel example code 的意思是？ Example:&lt;?phpif ($request-&gt;missing(&#x27;name&#x27;) &#123; //&#125; Answer:如果 $request 中沒有 ‘name’ 這個 input key, 返回 true # Old Input# Flashing Input To The Session以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;flashOnly([&#x27;username&#x27;, &#x27;email&#x27;]); Answer:只將 $request 中的 input username, 以及 email 存到 session 當中 以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;flash(); Answer:將 Request 載入到 session 當中 以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;flashExcept(&#x27;password&#x27;); Answer:將 $request 中, 除了 password 之外的 attributes 都存到 session # Flashing Input Then Redirecting以下的 Laravel example code 的意思是? Example:&lt;?phpreturn redirect(&#x27;form&#x27;)-&gt;withInput( $request-&gt;except(&#x27;password&#x27;)); Answer:導向 &#39;form&#39; web route, 並將 Request 中除了 &#39;password&#39; 之外的 data 都存到 session, 並帶過去 # Retrieving Old Input以下的 Laravel example code 的意思是? Example:&lt;?php$username = $request-&gt;old(&#x27;username&#x27;); Answer:從 session 中取得上一次 request 的資料 以下的 Laravel example code 的意思是? Example&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&#123;&#123; old(&#x27;username&#x27;) &#125;&#125;&quot;&gt; Answer:從 old global helper 中取得 session 中上一次 request 的 username Laravel 中, 當我使用 global helper old 來取得 session 中的 request 資料時, 如果該資料不存在, old helper 會 return 什麼？null # Cookies# Retrieving Cookie From Requests由 Laravel 建立的 cookies 都會被經過怎麼樣的處理以確保安全性？加密以及簽名 **以下的 Laravel example code 的意思是?**？ Example:&lt;?php$value = $request-&gt;cookie(&#x27;name&#x27;); Answer:從 request 中取得 cookie 中的 &#39;name&#39; field 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Cookie;$value = Cookie::get(&#x27;name&#x27;); Answer:取得 cookie 中的 name field # Attaching Cookies To Responses以下的 Laravel example code 的意思是? Example:&lt;?phpreturn response(&#x27;Hello World&#x27;)-&gt;cookie( &#x27;name&#x27;, &#x27;value&#x27;, $minutes); Answer:定義 response 中的 cookie 的 name, value, 以及有效時間 以下的 Laravel 程式碼的意思是？ Example:&lt;?phpreturn response(&#x27;Hello World&#x27;)-&gt;cookie( &#x27;name&#x27;, &#x27;value&#x27;, $minutes, $path, $domain, $secure, $httpOnly); Answer:設定 cookie, 參數細節可參考 PHP Document 以下的 Laravel 程式碼的意思是？ Example:&lt;?phpCookie::queue(Cookie::make(&#x27;name&#x27;, &#x27;value&#x27;, $minutes));Cookie::queue(&#x27;name&#x27;, &#x27;value&#x27;, $minutes); Answer:定義 cookie, 該 cookie 會隨著當次的 response 送出 Laravel 若要定義 cookie, 除了使用 Response instance 的 cookie method 之外, 還可以使用 哪一個 class 的 哪一個 method? Cookie class queue method 以下的 Laravel example code 的意思是? Example:&lt;?phpCookie::queue(&#x27;name&#x27;, &#x27;value&#x27;, $minutes); Answer:定義 cookie 的 name, value 以及有效期限, 該 cookie 會隨著當次的 response 送出 # Generating Cookie Instances以下的 Laravel example code 的意思是? Example:&lt;?php$cookie = cookie(&#x27;name&#x27;, &#x27;value&#x27;, $minutes);return response(&#x27;Hello World&#x27;)-&gt;cookie($cookie); Answer:定義 cookie 內容, 並將之 attach 到該 response # Files# Retrieving Uploaded FilesLaravel 中, Request class 的 file method 會 return 哪一個 instance??Illuminate\\Http\\UploadedFile 以下的 Laravel example code 的意思是? Example:&lt;?php$file = $request-&gt;file(&#x27;photo&#x27;);$file = $request-&gt;photo; Answer:從 request 取得名為 photo 的 file, 兩種方式皆可 以下的 Laravel example code 的意思是? Example:&lt;?phpif ($request-&gt;hasFile(&#x27;photo&#x27;)) &#123; //&#125; Answer:判斷 request 是否有 attribute name 為 &#39;photo&#39; 的 file # Validating Successful Uploads以下的 Laravel example code 的意思是? Example:&lt;?phpif ($request-&gt;file(&#x27;photo&#x27;)-&gt;isValid()) &#123; //&#125; Answer:判斷 file photo 是否有上傳成功 # File Paths &amp; Extensions以下的 Laravel example code 的意思是？ Example&lt;?php$path = $request-&gt;photo-&gt;path(); Answer:取得 photo file 儲存的 path 以下的 Laravel example code 的意思是？ Example&lt;?php$extention = $request-&gt;photo-&gt;extension(); Answer:從 $request 中取得 file photo 的 extension # Other File MethodLaravel 中, 更多 UploadedFile class 的 method 可以參考哪裏？API documentation for the class # Storing Uploaded Files以下的 Laravel example 是什麼意思？ Example:&lt;?php$path = $request-&gt;photo-&gt;store(&#x27;images&#x27;); Answer:將 photo 這個 uploaded file 存到 env 檔設定的 storage 的路徑 images, 檔名自動產生 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = $request-&gt;photo-&gt;store(&#x27;images&#x27;, &#x27;s3&#x27;); Answer:將 photo 這個 uploaded file 存到的 s3 storage, 路徑 images, 檔名自動產生 以下的 Laravel example code 的意思是？ Example:&lt;?php$path = $request-&gt;photo-&gt;storeAs(&#x27;images&#x27;, &#x27;filename.jpg&#x27;, &#x27;s3&#x27;); Answer:儲存一個 uploaded file 到 storage, storage 特別指定是 s3, storage 內的路徑為 images, 檔名特別指定為 filename.jpg # Configuration Trusted ProxiesLaravel 中, 當我們把應用運行在 LB 後面, 這時可能無法正確的產生 HTTPS 連結, 這時哪一個 middleware 可以解決這個問題？TrustProxies 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Fideloper\\Proxy\\TrustProxies as Middleware;use Illuminate\\Http\\Request;class TrustProxies extends Middleware&#123; protected $proxies = [ &#x27;192.168.1.1&#x27;, &#x27;192.168.1.2&#x27;, ]; protected $headers = Request::HEADER_X_FORWARDED_ALL;&#125; Answer:&lt;?phpnamespace App\\Http\\Middleware;use Fideloper\\Proxy\\TrustProxies as Middleware;use Illuminate\\Http\\Request;class TrustProxies extends Middleware&#123; // 加入信任的 proxies ip, 這樣才可以正確的產生 HTTPS 連結 protected $proxies = [ &#x27;192.168.1.1&#x27;, &#x27;192.168.1.2&#x27;, ]; // 在定義 ip 後, 可定義 $header 以進一步辨識 request 的來源 protected $headers = Request::HEADER_X_FORWARDED_ALL;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Fideloper\\Proxy\\TrustProxies as Middleware;use Illuminate\\Http\\Request;class TrustProxies extends Middleware&#123; protected $headers = Request::HEADER_X_FORWARDED_AWS_ELB&#125; Answer:當使用 AWS Elastic Load Balancing, 需定義以上 header Laravel 中, 如果我有使用 LB, 但我不知道我 LB 的 IP, 所以我想要信任所有的 proxy, 那我可以怎麼做？ Example:&lt;?phpnamespace App\\Http\\Middleware;use Fideloper\\Proxy\\TrustProxies as Middleware;use Illuminate\\Http\\Request;class TrustProxies extends Middleware&#123; protected $proxies = &#x27;*&#x27;;&#125; Answer:如果有使用 LB, 但不知道 LB 的 IP, 因而想要信任所有 proxy 的話, 可設為 &#39;*&#39; # Additional以下的 Laravel example code 的意思是？ Example:&lt;?php$row = request(&#x27;row&#x27;, (new Deposit)-&gt;getPerPage()); Answer:若 $request 中有指定的值, 如 ‘row’, 則使用該值, 若該值不存在, 則使用第二個自己指定的值","link":"/zh-tw/laravel-the-basics-requests/"},{"title":"Laravel - The Basics - URL Generation (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # The Basics# Generating Basic URLs解釋以下 Laravel example Example:&lt;?php$post = App\\Post::find(1);echo url(&quot;/posts/&#123;$post-&gt;id&#125;&quot;);// http://example.com/posts/1 Answer:&lt;?php$post = App\\Post::find(1);// 使用 url helper 產生 urlecho url(&quot;/posts/&#123;$post-&gt;id&#125;&quot;);// http://example.com/posts/1 # Accessing The Current URL以下的 Laravel example code 的意思是？ Example:&lt;?phpecho url()-&gt;current(); Answer:使用 url helper 取得當前 url, 但不包含 query string 以下的 Laravel example code 的意思是？ Example:&lt;?php// Get the current URL including the query string...echo url()-&gt;full(); Answer:取得當前 request url, 包含 query string 以下的 Laravel example code 的意思是？ Example:&lt;?php// Get the full URL for the previous request...echo url()-&gt;previous(); Answer:使用 url helper 取得上一次請求的 request url Laravel 中, 除了可以使用 url helper 取得 url 之外, 我還可以使用哪一個 class?URL facade # URLs For Named RoutesLaravel 中, 除了使用 actual url 來產生 url 之外, 我還可以使用什麼來產生 url, 而且就算之後 actual url 變更了, 我也不會影響到我的邏輯？可以使用 route name 以下的 example 產生 ‘example.com/post/1’ 的 url, 為什麼？ Example:&lt;?php// 直接帶入 Post modelecho route(&#x27;post.show&#x27;, [&#x27;post&#x27; =&gt; $post]); Answer:因為 Laravel 會自動地從該 Post model 取出 &#39;id&#39; 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/post/&#123;post&#125;/comment/&#123;comment&#125;&#x27;, function () &#123; //&#125;)-&gt;name(&#x27;comment.show&#x27;);echo route(&#x27;comment.show&#x27;, [&#x27;post&#x27; =&gt; 1, &#x27;comment&#x27; =&gt; 3]); Answer:產生一個 route url &#39;example.com/post/1/comment/3&#39; # Signed URLsLaravel 中, Signed URLs 可以用在什麼情境上？提供一個 email 到客戶信箱, “unsubscribe” 的 link 解釋以下的 Laravel example code Example:&lt;?phpuse Illuminate\\Support\\Facades\\URL;return URL::signedRoute(&#x27;unsubscribe&#x27;, [&#x27;user&#x27; =&gt; 1]); Answer:&lt;?phpuse Illuminate\\Support\\Facades\\URL;// 產生 signed url, unsubscribe 為 route name, user 為 parameterreturn URL::signedRoute(&#x27;unsubscribe&#x27;, [&#x27;user&#x27; =&gt; 1]); 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\URL;return URL::signedRoute(&#x27;unsubscribe&#x27;, [&#x27;role&#x27; =&gt; 2]); Answer:產生一個 route name 為 unsubscribe 的 signedRoute 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\URL;return URL::temporarySignedRoute( &#x27;unsubscribe&#x27;, now()-&gt;addMinutes(30), [&#x27;role&#x27; =&gt; 2]); Answer:產生一個 route &#39;unsubscribe&#39; 的暫時 url, 有效期限為 30 分鐘, 並帶入 parameter &#39;role&#39; =&gt; 2 # Validating Sighed Route Requests以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Http\\Request;Route::get(&#x27;/unsubscribe/&#123;user&#125;&#x27;, function (Request $request) &#123; if (! $request-&gt;hasValidSignature()) &#123; abort(401); &#125; // ...&#125;)-&gt;name(&#x27;unsubscribe&#x27;); Answer:驗證該 User 帶進來的 signature 是否正確 解釋以下的 Laravel example code Example:&lt;?phpprotected $routeMiddleware = [ &#x27;signed&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,]; Answer:註冊 ValidateSignature middleware 來驗證 signed url 正確性 # URLs For Controller Actions以下的 Laravel example code 的意思是？ Example:&lt;?php$url = action([HomeController::class], &#x27;index&#x27;);$url = action(&#x27;HomeController@index&#x27;); Answer:必須先定義 route功能跟 route(‘routeName’) 是一樣的, 使用 action 會 return 定義該 controller 的 route 的 url 以下的 Laravel example code 的意思是？ Example:&lt;?php$url = action(&#x27;UserController@profile&#x27;, [&#x27;id&#x27; =&gt; 1]); Answer:產生一個導向 &#39;UserControlelr&#39; 的 &#39;profile&#39; method 的 url, 並帶入 parameter # Default Values解釋以下的 Laravel example code Example:&lt;?phpnamespace App\\Http\\Middleware;use Closure;use Illuminate\\Support\\Facades\\URL;class SetDefaultLocaleForUrls&#123; public function handle($request, Closure $next) &#123; URL::defaults([&#x27;locale&#x27; =&gt; $request-&gt;user()-&gt;locale]); return $next($request); &#125;&#125; Answer:當我 return 一個 url 時, 若是該 route 需要帶入 url parameter, 我便需要每次都特別指定, 尤其若是有許多 route 都有相同的情況, 但我便需要增加很多 code 來定義回傳的 url 中 parameter 的值可以自訂一個 middleware 統一定義 ‘locale’ 這個 url parameter, 作用範圍為回傳的 url, 與 model binding 不相衝突","link":"/zh-tw/laravel-the-basics-url-generation/"},{"title":"Laravel - The Basics - Views (官方文件原子化翻譯筆記)","text":"# 前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Creating &amp; Rendering Views以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;/&#x27;, function () &#123; return view(&#x27;greeting&#x27;, [&#x27;name&#x27; =&gt; &#x27;James&#x27;]);&#125;); Answer:return 定義好的 view, 定義於 resources/views 資料夾下, 帶著 variable $name = &#39;James&#39; 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\View;return View::make(&#x27;greeting&#x27;, [&#x27;name&#x27; =&gt; &#x27;James&#x27;]); Answer:使用 View facade, return 定義好的 view, 定義於 resources/views 資料夾下, 帶著 variable $name = &#39;James&#39; # Nested View Directories以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn view(&#x27;admin.profile&#x27;, $data); Answer:return view, view 的 location 為 /resources/views/admin/profile, 並帶著 $data 過去, $data 為一個 array # Creating The First Available View以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\View;return View::first([&#x27;custom.admin&#x27;, &#x27;admin&#x27;], $data); Answer:return first() 的 arg1 array 中的 first existing view, 並帶入 $data # Determining If A View Exists以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\View;if (View::exists(&#x27;emails.customer&#x27;)) &#123; //&#125; Answer:判斷 resources/views/emails/customer view 是否存在 # Passing Data To Views以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn view(&#x27;greetings&#x27;, [&#x27;name&#x27; =&gt; &#x27;Victoria&#x27;]);// on view page&lt;?php echo $name; ?&gt; Answer:將 $name = &#39;Victoria&#39; 傳到 view, 所以在 view page 可以 access $name 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn view(&#x27;greeting&#x27;) -&gt;with(&#x27;name&#x27;, &#x27;Victoria&#x27;) -&gt;with(&#x27;occupation&#x27;, &#x27;Astronaut&#x27;); Answer:將 $name = &#39;Victoria&#39;, $occupation = &#39;Astronaut&#39; pass 給 view, 所以在 view page 可以存取 $name, $occupation # Sharing Data With All Views以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\View;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; View::share(&#x27;key&#x27;, &#x27;value&#x27;); &#125;&#125; Answer:在 AppServiceProvider 的 boot(), 使用 View::share(), 可以將註冊的 data share 到所有的 views, 註冊後所有的 views 都可以存取 key # View Composers以下的 Laravel example code 的意思是？ Example:&lt;?php// 在自己建立的 ViewServiceProvidernamespace App\\Providers;use App\\Http\\View\\Composers\\ProfileComposer;use Illuminate\\Support\\Facades\\View;use Illuminate\\Support\\ServiceProvider;class ViewServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; View::composer(&#x27;profile&#x27;, ProfileComposer::class); View::composer(&#x27;dashboard&#x27;, function ($view) &#123; // &#125;); &#125;&#125;// ProfileComposernamespace App\\Http\\View\\Composers;use App\\Repositories\\UserRepository;use Illuminate\\View\\View;class ProfileComposer&#123; protected $users; public function __construct(UserRepository $users) &#123; // Dependencies automatically resolved by service container... $this-&gt;users = $users; &#125; public function compose(View $view) &#123; $view-&gt;with(&#x27;count&#x27;, $this-&gt;users-&gt;count()); &#125;&#125; Answer:在自己建立的 ViewServiceProvider 的 boot() 針對特定的 view 註冊 view composer, 並且定義 view composer, 該 view page 在 render 時會執行 view composer, 在此 example 中, profile view page 在 render 時會執行 ProfileComposer, 因此 profile view page render 後可在該頁面存取 $count = $users-&gt;count() 資料建立 ViewServiceProvider 後, 需要到 config/app.php, 加 ViewServiceProvider 加到 providers array # Attaching A Composer To Multiple Views以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Http\\Views\\Composers\\MultiComposer;View::composer( [&#x27;profile&#x27;, &#x27;dashboard&#x27;], MultiComposer::class); Answer:可以將 view composer 附加到多個 view 上 以下的 Laravel example code 的意思是？ Example:&lt;?phpView::composer(&#x27;*&#x27;, function ($view) &#123; //&#125;); Answer:可將 view composer 附加到所有的 view 上 # View Creators以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Http\\View\\Creators\\ProfileCreator;use Illuminate\\Support\\Facades\\View;View::creator(&#x27;profile&#x27;, ProfileCreator::class); Answer:註冊 view creator, 效果跟 view composer 差不多, 差別在於 creator 在 instantiate 時就執行, composer 會在 render 時才執行, 具體的差別在於, 當使用 creator 時, 可在 controller overwrite creator 定義的 variable, 而 composer 則不行 # Optimizing Views以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan view:cachephp artisan view:clear Answer:Laravel 在每次 request 都會檢查並 compile blade view, 這對效能會有負面影響, 可將之 cache 住以避免每次都 compile, 當然, 若是修改了 code 之後, 也要 clear 並重新 cache","link":"/zh-tw/laravel-the-basics-views/"},{"title":"Laravel - Eloquent ORM - API Resources","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Generating Resources在 Laravel 中, 如何使用 CLI 產生一個 resourcephp artisan make:resource resourceName 在 Laravel 中, 如何使用 CLI 產生一個 resource collection Answer1:php artisan make:resource resourceName --collection Answer2:php artisan make:resource resourceNameCollection # Concept Overview1在 Laravel 中, Resource 中的 toArray method 的作用是？將 model 以及自定義的值轉成 array, 然後 Laravel 會自動將 array 轉成 JSON 輸出 在 Laravel 中, 如何在 controller 或 route 中回傳 resource?直接帶入 closure 回傳 &lt;?phpuse App\\Http\\Resources\\User as UserResource;use App\\User;Route::get(&#x27;/user&#x27;, function () &#123; return new UserResource(User::find(1));&#125;); 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Http\\Resources\\User as UserResource;use App\\User;Route::get(&#x27;/user&#x27;, function () &#123; return UserResource::collection(User::all());&#125;); Answer:使用 UserResource 的 collection method, User models 會依照 UserResource 定義的格式回傳資料, 也可使用 UserCollection 在 Laravel 的 resource 當中, 當我們使用 collection method 時, 是否可回傳額外的 meta data?不可 在 Laravel 的 resource 當中, 如果我要回傳一個 collection, 或是有分頁的 response, 應該使用？使用 resource collection 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class UserCollection extends ResourceCollection&#123; public function toArray($request) &#123; return [ &#x27;data&#x27; =&gt; $this-&gt;collection, &#x27;links&#x27; =&gt; [ &#x27;self&#x27; =&gt; &#x27;link-value&#x27;, ], ]; &#125;&#125; Answer:在 resource return 的 collection 中, 在 links array 中新增 ‘self’ =&gt; ‘link-value’, 所以 return JSON 如下&#123; &quot;data&quot;: [], &quot;links&quot;: &#123; &quot;first&quot;: &quot;http:\\/\\/example-api.test\\/api\\/admin\\/withdraws?status=11&amp;page=1&quot;, &quot;last&quot;: null, &quot;prev&quot;: null, &quot;next&quot;: null, &quot;self&quot;: &quot;link-value&quot; &#125;, &quot;meta&quot;: &#123; &quot;current_page&quot;: 1, &quot;from&quot;: null, &quot;path&quot;: &quot;http:\\/\\/example-api.test\\/api\\/admin\\/withdraws&quot;, &quot;per_page&quot;: 20, &quot;to&quot;: null &#125;&#125; 在 Laravel 的 resource 當中, 如何在 route 或 controller 中利用 resource collection 回傳?&lt;?phpuse App\\Http\\Resources\\UserCollection;use App\\User;Route::get(&#x27;/users&#x27;, function () &#123; return new UserCollection(User::all());&#125;); In Laravel 的 Resource 當中, collection 預設會繼承 resource 嗎？ 會的 # Customizing The Underlying Resource Class以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class UserCollection extends ResourceCollection&#123; public $collects = &#x27;App\\Http\\Resources\\Member&#x27;;&#125; Answer:指定 UserCollection resource 的來源, 預設是 User Resource # Writing ResourcesLaravel resource 中, 如何帶入 relation?&lt;?php/** * Transform the resource into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */public function toArray($request)&#123; return [ &#x27;id&#x27; =&gt; $this-&gt;id, &#x27;name&#x27; =&gt; $this-&gt;name, &#x27;email&#x27; =&gt; $this-&gt;email, &#x27;posts&#x27; =&gt; PostResource::collection($this-&gt;posts), &#x27;created_at&#x27; =&gt; $this-&gt;created_at, &#x27;updated_at&#x27; =&gt; $this-&gt;updated_at, ];&#125; # Data Wrapping以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Http\\Resources\\Json\\Resource;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Resource::withoutWrapping(); &#125;&#125; Answer:在 AppServiceProvider, boot() 中使用 withoutWrapping(), 可以移除 Laravel 預設的 Resource response 的 key data 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class CommentsCollection extends ResourceCollection&#123; public function toArray($request) &#123; return [&#x27;data&#x27; =&gt; $this-&gt;collection]; &#125;&#125; Answer:在 Collection class 的 toArray method 中, 使用 [] 在包一層, 修改之後, 底下任何巢狀的資料都會使用 &quot;data&quot; : &#123;&#125; or [] 的方式在包一層 Laravel collection 當中, 如果我有做分頁, 還能取消最外層包住的 data key 嗎？ 不行, 因為分頁預設就會有 links, meta 等 keyLaravel resource 當中, 如果我要有條件地顯示 secret, 可以用哪一個 clause?&lt;?php/** * Transform the resource into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */public function toArray($request)&#123; return [ &#x27;id&#x27; =&gt; $this-&gt;id, &#x27;name&#x27; =&gt; $this-&gt;name, &#x27;email&#x27; =&gt; $this-&gt;email, &#x27;secret&#x27; =&gt; $this-&gt;when(Auth::user()-&gt;isAdmin(), &#x27;secret-value&#x27;), &#x27;created_at&#x27; =&gt; $this-&gt;created_at, &#x27;updated_at&#x27; =&gt; $this-&gt;updated_at, ];&#125; Laravel 的 resource 當中, 如果我有兩個以上的值想要有條件的顯示, 要就一起顯示, 要就都不顯示, 可以怎麼做？&lt;?phppublic function toArray($request)&#123; return [ &#x27;id&#x27; =&gt; $this-&gt;id, &#x27;name&#x27; =&gt; $this-&gt;name, &#x27;email&#x27; =&gt; $this-&gt;email, $this-&gt;mergeWhen(Auth::user()-&gt;isAdmin(), [ &#x27;first-secret&#x27; =&gt; &#x27;value&#x27;, &#x27;second-secret&#x27; =&gt; &#x27;value&#x27;, ]), &#x27;created_at&#x27; =&gt; $this-&gt;created_at, &#x27;updated_at&#x27; =&gt; $this-&gt;updated_at, ];&#125; Laravel 的 collection 當中, 如果我想要有條件的顯示 relationship, 該 model 有載入 relation 的話我才顯示, 不載入不顯示, 該怎麼做？&lt;?phppublic function toArray($request)&#123; return [ &#x27;id&#x27; =&gt; $this-&gt;id, &#x27;name&#x27; =&gt; $this-&gt;name, &#x27;email&#x27; =&gt; $this-&gt;email, &#x27;posts&#x27; =&gt; PostResource::collection($this-&gt;whenLoaded(&#x27;posts&#x27;)), &#x27;created_at&#x27; =&gt; $this-&gt;created_at, &#x27;updated_at&#x27; =&gt; $this-&gt;updated_at, ];&#125; 以下位於 Resources 的 Laravel example code 的意思是？ Example:&lt;?phppublic function toArray($request)&#123; return [ &#x27;id&#x27; =&gt; $this-&gt;id, &#x27;name&#x27; =&gt; $this-&gt;name, &#x27;expires_at&#x27; =&gt; $this-&gt;whenPivotLoaded(&#x27;role_user&#x27;, function () &#123; return $this-&gt;pivot-&gt;expires_at; &#125;), ];&#125; Answer:當 pivot table &#39;role_user&#39; 有載入時, 才取得 pivot table 中的 expires_at 值若無載入 &#39;role_user&#39;, resource 回傳的 &#39;expires_at&#39; 將為 null 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class UserCollection extends ResourceCollection&#123; public function toArray($request) &#123; return parent::toArray($request); &#125; public function with($request) &#123; return [ &#x27;meta&#x27; =&gt; [ &#x27;key&#x27; =&gt; &#x27;value&#x27;, ], ]; &#125;&#125; Answer:在 meta 中加入自定義的 key / value 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn (new UserCollection(User::all()-&gt;load(&#x27;roles&#x27;))) -&gt;additional([&#x27;meta&#x27; =&gt; [ &#x27;key&#x27; =&gt; &#x27;value&#x27;, ]]); Answer:在 user resource collection 的 meta array 中, 新增 ‘key’ =&gt; ‘value’ Laravel Collection 當中, additional method 的 class是什麼？ Resource 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Http\\Resources\\User as UserResource;use App\\User;Route::get(&#x27;/user&#x27;, function () &#123; return (new UserResource(User::find(1))) -&gt;response() -&gt;header(&#x27;X-Value&#x27;, &#x27;True&#x27;);&#125;); Answer:以 UserResource 的格式 return, 再利用 response() 指定 header ‘X-Value’ 為 ‘true’ 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\JsonResource;class User extends JsonResource&#123; public function toArray($request) &#123; return [ &#x27;id&#x27; =&gt; $this-&gt;id, ]; &#125; public function withResponse($request, $response) &#123; $response-&gt;header(&#x27;X-Value&#x27;, &#x27;True&#x27;); &#125;&#125; Answer:在 resource file 中使用 withResponse() 來定義 header # Additional操作 Resource 的 controller, 通常命名的規則是？該 Resource 對應的名稱, 如 IpController 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass EmployeeGenderInfo extends JsonResource&#123; function __construct(Employee $model) &#123; parent::__construct($model); &#125; public function toArray($request) &#123; return [ &#x27;id&#x27; =&gt; $this-&gt;id, &#x27;name&#x27; =&gt; $this-&gt;name, &#x27;gender_name&#x27; =&gt; $this-&gt;gender-&gt;name, ]; &#125;&#125; Answer:建立一個自定義名稱的 resource, 並指定該 recourse 要使用的 model","link":"/zh-tw/laravelEloquentORMAPIResources/"},{"title":"Laravel - Getting Started - Configuration","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Environment Configuration如果使用 Composer 安裝, 專案內會有 .env 檔案嗎？ 會哦, 會自動被 cp 一份當執行 PHPUnit 時, 如何替換掉 .env？ 建立 .env.testing # Environment Variable Types在 Laravel .env 檔中, 如果 value 是含有空白的字串, 該怎麼做？&lt;?phpAPP_NAME=&quot;My Application&quot; # Determining The Current Environment以下的 Laravel example code 的意思是？ Example:&lt;?phpif (App::environment(&#x27;local&#x27;)) &#123; // The environment is local&#125;if (App::environment([&#x27;local&#x27;, &#x27;staging&#x27;])) &#123; // The environment is either local OR staging...&#125; Answer:判斷目前環境, 並做相對應的事 # Hiding Environment Variables From Debug Pages當 Laravel 的環境變數 APP_DEBUG 為 true 時, 默認會輸出所有的環境變數以及內容, 假如我有一些變數不想顯示, 我可以怎麼做？&lt;?php// 修改 config/app.php 檔案中的 debug_blacklistreturn [ // ... &#x27;debug_blacklist&#x27; =&gt; [ &#x27;_ENV&#x27; =&gt; [ &#x27;APP_KEY&#x27;, &#x27;DB_PASSWORD&#x27;, ], &#x27;_SERVER&#x27; =&gt; [ &#x27;APP_KEY&#x27;, &#x27;DB_PASSWORD&#x27;, ], &#x27;_POST&#x27; =&gt; [ &#x27;password&#x27;, ], ],]; # Accessing Configuration Values在 Laravel 中, 若要取得 config 的值, 可以怎麼做？&lt;?php$value = config(&#x27;app.timezone&#x27;); 在 Laravel 中, 若要在程式碼中設定 config 的值, 可以怎麼做？&lt;?phpconfig([&#x27;app.timezone&#x27; =&gt; &#x27;America/Chicago&#x27;]); # Configuration Cachingphp artisan config:cache 做了什麼事？ 將所有的 config 檔案 cache 成一份檔案, 以加速運行php artisan config:cache 建議在 production 還是 develop 運行？ production運行 php artisan config:cache 時, 會否讀 .env 檔？ 不會哦所有 Laravel 的設定檔都放在哪裡？ config 資料夾底下 # Maintenance Mode在 Laravel 中, 如果要啟動維護模式, 可以怎麼做？php artisan down 在 Laravel 中, 如果要啟動維護模式, 並且客制 message 以及 retry 可以怎麼做？php artisan down --message=&quot;Upgrading Database&quot; --retry=60 在 Laravel 中, 以下的 –retry 代表什麼意思？php artisan down --message=&quot;Upgrading Database&quot; --retry=60 會設定一個 `Retry-After` HTTP header, 目前大概只有 Google Bot 會特別去偵測, 在你指定的 downtime 時間不會去爬你的網站 以下的 Laravel example command 的意思是？ Example:php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16 Answer:在維護模式中, 僅僅對指定的 IP 開放 在 Laravel 維護模式中, queue job 還會被處理嗎？不會哦 # AdditionalLaravel 的時區設定檔位置在？config 中的 app.php Laravel 當中, 哪裡可以設定 queue 的名字？config 資料夾中的 queue","link":"/zh-tw/laravelGettingStartedConfiguration/"},{"title":"Laravel - Getting Started - Deployment","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Server ConfigurationNginxserver &#123; // 監聽 80 port listen 80; server_name example.com; // Document root root /example.com/public; // iframe 以及 object 保護 add_header X-Frame-Options &quot;SAMEORIGIN&quot;; // XSS 保護 add_header X-XSS-Protection &quot;1; mode=block&quot;; // 禁止 NGINX 自動判斷資源型態 add_header X-Content-Type-Options &quot;nosniff&quot;; index index.html index.htm index.php; charset utf-8; location / &#123; // 先尋找 $uri, 在尋找 $uri/, 都沒有的話, 重寫規則成 /index.php?query_string try_files $uri $uri/ /index.php?$query_string; &#125; // 若 location 等於 /favicon.ico, 不記入 log location = /favicon.ico &#123; access_log off; log_not_found off; &#125; // 若 location 等於 /robots.txt, 不記入 log location = /robots.txt &#123; access_log off; log_not_found off; &#125; // error 導向 /index.php, 由 Laravel 處理 error_page 404 /index.php; // 結尾是 .php 結尾的話, 進入此 location location ~ \\.php$ &#123; // 經由 unix 通道 pass, 若跨主機或使用容器的話, 需使用 TCP fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; fastcgi_index index.php; // fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\\.(?!well-known).* &#123; deny all; &#125;&#125; add_header X-Frame-Options 的用途是？ 用來指示文件是否能夠載入 &lt;frame&gt;, &lt;iframe&gt;, 以及 &lt;object&gt; add_header X-Frame-Options header 中, SAMEORIGIN 的用途是？ 唯有當符合同源政策下, 才能被嵌入到 frame 中 add_header X-Frame-Options header 中, DENY 的用途是？ 表示文件無論如何都不可被嵌入到 frame 中, 即使自家網站也不行 add_header X-Frame-Options header 中, ALLOW-FROM uri 的用途是？ 唯有列表許可的 URI 才能嵌入到 frame 中 add_header X-XSS-Protection “1; mode=block”, 1 代表什麼意思？ 0: 禁用 XSS 保護1: 啟用 XSS 保護1; mode=blck; 啟用 XSS 保護, 並在檢查到 XSS 攻擊時, 停止渲染頁面 add_header X-Content-Type-Options “nosniff”; 的用途？ 網路上的資源有各種類型, 通常瀏覽器會根據 header 的 Content-Type 來分辨它們的類型。如：&quot;text/html&quot; 代表 html 文檔, &quot;image/png&quot; 是 PNG 圖片, &quot;text/css&quot; 是 CSS 樣式文檔。然而, 有些資源的 Content-Type 是錯的或者未定義。這時, 某些瀏覽器會啟用 MIME-sniffing 來猜測該資源的類型, 解析內容並執行。例如, 我們即使給一個 html 文檔指定 Content-Type 為 &quot;text/plain&quot;, 在 IE8 中這個文檔依然會被當做 html 來解析。利用瀏覽器的這個特性, 攻擊者甚至可以讓原本應該解析為圖片的請求被解析為 JavaScript 。通過下面這個響應頭可以禁用瀏覽器的類型猜測行為： OptimizationAutoloader Optimization 部署 Production 環境時, 如何優化 Composer 的 class autoloader map?composer install --optimize-autoloader --no-dev Optimizing Configuration Loading 部署 Laravel 到 production 時, 如何優化 cache? php artisan config:cache 當執行 php artisan config:cache, .env 檔會失效, 那該如何在程式碼中使用 .env 呢？ 可以寫在 config 裡 Optimizing Route Loading 當部署 Laravel 到 production 時, 該怎麼優化 route?php artisan route:cache","link":"/zh-tw/laravelGettingStartedDeployment/"},{"title":"Laravel - The Basics - Routing (官方文件原子化翻譯)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Basic Routing# Available Router Methods以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::match([&#x27;get&#x27;, &#x27;post&#x27;], &#x27;/&#x27;, function () &#123; //&#125;);Route::any(&#x27;/&#x27;, function () &#123; //&#125;); Answer:&lt;?php// 該 route 可以接收 get 以及 post HTTP method requestRoute::match([&#x27;get&#x27;, &#x27;post&#x27;], &#x27;/&#x27;, function () &#123; //&#125;);// 該 route 可以接收任何 HTTP method 的 request Route::any(&#x27;/&#x27;, function () &#123; //&#125;); # CSRF ProtectionLaravel 中, 哪些 HTTP method 會有 CSRF Protection?POSTPUTDELETE Laravel 的 CSRF Protection 中, 是如何將 XSRF TOKEN 傳給前端的？1. Laravel 把 token 存在 Session 當中2. 把 Session 對應的 Cookie 傳給前端3. 前端帶著對應的 Cookie, token 上來4. Laravel 用 Cookie 找 Session 對應的值, 並驗證前端送來的 tokenLaravel =&gt; Cookie, token =&gt; 前端 =&gt; Cookie, token =&gt; Laravel Laravel 的 CSRF Protection 中, XSRF Token 會放在哪裡傳給前端？Cookie Laravel 的 CSRF Protection 中, XSRF Token 會否加密再傳給前端？ 會的Laravel 的 CSRF Protection 中, 後端會傳什麼給前端？與 Session 相對應的 Cookie 以及寫在 Cookie 內的 token Laravel 的 CSRF Protection 中, 前端會傳什麼給後端？後端之前傳來的 Cookie 資訊以及裡頭的 token # Redirect RoutesHTTP 轉址中, 301 跟 302 差在哪？301: 永久轉址, 搜尋引擎會把新網址當作唯一 url302: 暫時轉址, 搜尋引擎會知道這只是暫時的 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::redirect(&#x27;/here&#x27;, &#x27;/there&#x27;); Answer:將 uri 為 /here 的 request 轉址到 /there 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::redirect(&#x27;/here&#x27;, &#x27;/there&#x27;, 301); Answer:將 uri 為 /here 的 request 轉址到 /there, 並帶上狀態碼 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::permanentRedirect(&#x27;/here&#x27;, &#x27;/there&#x27;); Answer:將 uri 為 /here 的 request 轉址到 /there, 並帶上狀態碼 301 # View Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::view(&#x27;/welcome&#x27;, &#x27;welcome&#x27;, [&#x27;name&#x27; =&gt; &#x27;Taylor&#x27;]); Answer:收到 /welcome request, 導向 welcome view page, 帶著參數 [&#39;name&#39; =&gt; &#39;Taylor&#39;] 過去 # Route Parameters# Required Parameters以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;user/&#123;id&#125;&#x27;, function ($id) &#123; return &#x27;User &#x27;.$id;&#125;); Answer:假如收到 request user/2, 那 $id 便會是 2 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;posts/&#123;post&#125;/comments/&#123;comment&#125;&#x27;, function ($postId, $commentId) &#123; //&#125;); Answer:當收到 request **posts/1/comments/2 時, $postId 為 1, $commentId 為 2, 看順序取值 Laravel 中, 定義 URL 中的參數時, 可以用 - 嗎？ 如果不行, 那要用什麼?不可可使用 underscore (_) Laravel 中, 取得從 URL 中定義的參數時, 是看名字, 還是看順序？順序, controller 參數的名字不重要, 隨便亂取都可以, 只看順序 以下的 Laravel example code 中, 假設 a = 1, b = 2, 那 dd() 的結果是？ Example:&lt;?php public function index($d, MerchantDepositIndex $request, $c, DepositManager $manager) &#123; dd($c, $d); // 結果是？ &#125; Route::apiResource(&#x27;deposits/&#123;a&#125;/&#123;b&#125;&#x27;, &#x27;DepositController&#x27;)-&gt;only([&#x27;index&#x27;, &#x27;show&#x27;]); Answer:2, 1Laravel 會自動找到參數並按照帶入的順序排列 # Optional Parameters以下的 Laravel example code 的意思是？ Example:&lt;?php Answer:&lt;?php 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;user/&#123;name?&#125;&#x27;, function ($name = null) &#123; return $name;&#125;);Route::get(&#x27;user/&#123;name?&#125;&#x27;, function ($name = &#x27;John&#x27;) &#123; return $name;&#125;); Answer:&lt;?php// 定義 optional 的 uri parameter, 可定義預設值// 若是不使用 `?`, 則一定要帶值, 不可事先定義// 若沒帶值, 例如 request 為 &#x27;example.com/user&#x27;, 則 $name = null// 若有帶值, 例如 request 為 &#x27;example.com/user/2&#x27;, 則 $name = 2Route::get(&#x27;user/&#123;name?&#125;&#x27;, function ($name = null) &#123; return $name;&#125;);// 若沒帶值, 例如 request 為 &#x27;example.com/user&#x27;, 則 $name = &#x27;John&#x27;// 若有帶值, 例如 request 為 &#x27;example.com/user/2&#x27;, 則 $name = 2Route::get(&#x27;user/&#123;name?&#125;&#x27;, function ($name = &#x27;John&#x27;) &#123; return $name;&#125;); # Regular Expression Constraints以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;user/&#123;name&#125;&#x27;, function ($name) &#123; //&#125;)-&gt;where(&#x27;name&#x27;, &#x27;[A-Za-z]+&#x27;);Route::get(&#x27;user/&#123;id&#125;&#x27;, function ($id) &#123; //&#125;)-&gt;where(&#x27;id&#x27;, &#x27;[0-9]+&#x27;);Route::get(&#x27;user/&#123;id&#125;/&#123;name&#125;&#x27;, function ($id, $name) &#123; //&#125;)-&gt;where([&#x27;id&#x27; =&gt; &#x27;[0-9]+&#x27;, &#x27;name&#x27; =&gt; &#x27;[a-z]+&#x27;]); Answer:對 url parameter 加上正則的驗證, 格式須符合正則規則 # Global Constraints以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; Route::pattern(&#x27;id&#x27;, &#x27;[0-9]+&#x27;); parent::boot();&#125; Answer:在 RouteServiceProvider針對 url parameter 定義一個 global 的正則規則, 此規則作用範圍為所有的 url parameter 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;search/&#123;search&#125;&#x27;, function ($search) &#123; return $search;&#125;)-&gt;where(&#x27;search&#x27;, &#x27;.*&#x27;); Answer:允許 &#123;search&#125; url parameter 以任何格式, 像是 / 也允許 在 Laravel 中, 如果我想要定義一個 URL parameter, 這個 parameter 可能是一個 /, 那只有在 URL 的哪一個位置是容許的？最後一個區塊 # Named Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;user/profile&#x27;, function () &#123; //&#125;)-&gt;name(&#x27;profile&#x27;);Route::get(&#x27;user/profile&#x27;, &#x27;UserProfileController@show&#x27;)-&gt;name(&#x27;profile&#x27;); Answer:將該 route 命名為 profile, 之後可以使用, 例如 redirect()-&gt;route(&#39;profile&#39;) 以下的 Laravel example code 的意思是？ Example:&lt;?php// Generating Redirects...return redirect()-&gt;route(&#x27;profile&#x27;); Answer:redirect 到已命名為 name 的 route 以下的 Laravel example code 的意思是？ Example:&lt;?php// Generating URLs...$url = route(&#x27;profile&#x27;); Answer:取得名為 profile 的 route url 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;user/&#123;id&#125;/profile&#x27;, function ($id) &#123; //&#125;)-&gt;name(&#x27;profile&#x27;);$url = route(&#x27;profile&#x27;, [&#x27;id&#x27; =&gt; 1]); Answer:命名一個 route 為 profile再取得名為 profile 的 route url, 並帶入 id 為 1 在以下 Laravel 的 route 中, 產生的 url 會長怎樣？ Example:&lt;?phpRoute::get(&#x27;user/&#123;id&#125;/profile&#x27;, function ($id) &#123; //&#125;)-&gt;name(&#x27;profile&#x27;);$url = route(&#x27;profile&#x27;, [&#x27;id&#x27; =&gt; 1, &#x27;photos&#x27; =&gt; &#x27;yes&#x27;]); Answer:/user/1/profile?photos=yes 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;user/&#123;id&#125;/profile&#x27;, function ($id) &#123; //&#125;)-&gt;name(&#x27;profile&#x27;);$url = route(&#x27;profile&#x27;, [&#x27;id&#x27; =&gt; 1, &#x27;photos&#x27; =&gt; &#x27;yes&#x27;]);// /user/1/profile?photos=yes Answer:命名為 profile 的 route, 並取得名為 profile 的 route url, 帶入 url parameter id, 因為 photos 並沒有被定義在 route url parameter, 因此在 url 中會以 query 呈現 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle($request, Closure $next)&#123; if ($request-&gt;route()-&gt;named(&#x27;profile&#x27;)) &#123; // &#125; return $next($request);&#125; Answer:判斷當前 request 的 route 是否名為 profile # Route Groups# Middleware以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::middleware([&#x27;first&#x27;, &#x27;second&#x27;])-&gt;group(function () &#123; Route::get(&#x27;/&#x27;, function () &#123; // &#125;); Route::get(&#x27;user/profile&#x27;, function () &#123; // &#125;);&#125;); Answer:為複數 route 定義複數 middleware對 example 中的兩個 route 的 request 都將必須通過 ‘first’, ‘second’ 兩個 middleware # Namespaces以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::namespace(&#x27;Admin&#x27;)-&gt;group(function () &#123; //&#125;); Answer:將 namespace ‘Admin’ 套用到 closure 內的所有 controller # Sub-Domain Routing以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::domain(&#x27;&#123;account&#125;.myapp.com&#x27;)-&gt;group(function () &#123; Route::get(&#x27;user/&#123;id&#125;&#x27;, function ($account, $id) &#123; // &#125;);&#125;); Answer:domain 為 {account}.myapp.com 的 request 都會到 example 中的 route, 並且從 domain 取得 account parameter, 以及從 url 中取得 id parameter 在 Laravel 中, 為了確保 sub-domain routing 可被存取, 當我們在定義時, 應該先定義 sub-domain routes 還是 root domain routes?sub-domain routes # Route Prefixes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::prefix(&#x27;admin&#x27;)-&gt;group(function () &#123; Route::get(&#x27;users&#x27;, function () &#123; &#125;);&#125;); Answer:將 prefix ‘admin’ 作用到 group 內的 route, 所以 request 的 url 為 /admin/users 以下的 Laravel route 將符合什麼樣的 URL ? Example:&lt;?phpRoute::prefix(&#x27;admin&#x27;)-&gt;group(function () &#123; Route::get(&#x27;users&#x27;, function () &#123; &#125;);&#125;); Answer:/admin/users # Route Name Prefixes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::name(&#x27;admin.&#x27;)-&gt;group(function () &#123; Route::get(&#x27;users&#x27;, function () &#123; // &#125;)-&gt;name(&#x27;users&#x27;);&#125;); Answer:closure 內的 routes 的 name 都會有 ‘admin.’ 這個前綴, 所以 example 中的 route name 為 ‘admin.users’ # Route Model Binding# Implicit Binding以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::get(&#x27;api/users/&#123;user&#125;&#x27;, function (App\\User $user) &#123; return $user-&gt;email;&#125;); Answer:新增 {user} url parameter, 透過 function() 內的 model binding, 可直接透過 $user 取得 User model, 預設透過 primary_key 取得 Laravel 中, 如果 Model Binding 沒有找到相對應的 Model, 會回傳什麼？?404 # Customizing the key Name以下的 Laravel example code 的意思是？ Example:&lt;?phpclass User extends Authenticatable;&#123; public function getRouteKeyName() &#123; return &#x27;slug&#x27;; &#125;&#125; Answer:model binding 中, 預設使用 primary_key 取得 model, 可在 model 中使用 getRouteKeyName() 來定義使用 ‘slug’ column 來取得 model # Explicit Binding以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; parent::boot(); Route::model(&#x27;user&#x27;, App\\User::class);&#125; Answer:如果不想使用 type-hinted variable 來實現 model binding, 想要經由 url 的 parameter name 來實現 model binding 的話, 可以再 RouteServiceProvider 的 boot method使用 Route class 的 model method 來將 url 中的 ‘user’ parameter 與 ‘App\\User’ model 相關聯 # Customizing The Resolution LogicLaravel 的 model binding 中, 如果我想要定義比單一 column 更複雜的規則, 有哪兩種做法？ RouteServiceProvider 增加規則 在 Model 中定義 method 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass User extends Authenticatable&#123; public function resolveRouteBinding($value) &#123; return $this-&gt;where(&#x27;name&#x27;, $value)-&gt;firstOrFail(); &#125;&#125; Answer:在 model 中定義 model binding 的規則, 比方說, 當我在 controller 使用 model binding, (User $user), 則取得 $User-&gt;where(‘name’, $value)-&gt;firstOrFail() 的 model 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; parent::boot(); Route::bind(&#x27;user&#x27;, function ($value) &#123; return App\\User::where(&#x27;name&#x27;, $value)-&gt;firstOrFail(); &#125;);&#125; Answer:預設在 controller method inject model binding 時, 像是 index(User $user), Laravel 的預設 convention 使用 id 尋找對應 model可在 RouteServiceProvider 的 boot() 定義 model binding 規則, 當 binding 指定的 Model 為 User 時, 會到 User Model 以 where(‘name’, $value)-&gt;firstOrFail() 的方式取得 model # Fallback Routes以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::fallback(function () &#123; //&#125;); Answer:預設未找到 route 的 request 會回傳 404, 可透過自定義 fallback route 來定義後續動作 在 Laravel 中, fallback route 的位置應該要放在什麼地方？最後 # Rate Limiting以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::middleware(&#x27;auth:api&#x27;, &#x27;throttle:60,1&#x27;)-&gt;group(function () &#123; Route::get(&#x27;/user&#x27;, function () &#123; // &#125;);&#125;); Answer:使用 auth:api middleware 來驗證 user, 使用 throttle middleware 來限制 1 分鐘最多可存取 60 次 以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::middleware(&#x27;throttle:10|60,1&#x27;)-&gt;group(function () &#123; //&#125;); Answer:使用 throttle middleware 來限制存取次數, authenticated user 1 分鐘最多可存取 60 次, 而 unauthenticated user 1 分鐘最多存取 10 次 # Dynamic Rate Limiting以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::middleware(&#x27;auth:api&#x27;, &#x27;throttle:rate_limit,1&#x27;)-&gt;group(function () &#123; Route::get(&#x27;/user&#x27;, function () &#123; // &#125;);&#125;); Answer:使用 auth:api middleware 來驗證 user, 使用 throttle middleware 來動態的限制使用者存取次數rate_limit 代表 authenticated user 在資料庫內的欄位, 須為數字, 代表 1 分鐘內可存取次數的上限 # Distanct Guest &amp; Authenticated User Rate Limits以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::middleware(&#x27;auth:api&#x27;, &#x27;throttle:10|rate_limit,1&#x27;)-&gt;group(function () &#123; Route::get(&#x27;/user&#x27;, function () &#123; // &#125;);&#125;); Answer:unauthenticated user 1 分鐘最多訪問 10 次authenticated user 1 分鐘最多訪問次數定義在 user 的 rate_limit column # Form Method Spoofing使用 HTML Form 發 API 時, 常常遇到 PUT, PATCH, DELETE 方法不可用, 根本的原因是什麼？HTML Forms 不支援以上的 HTTP method 哪幾種 HTTP method 是不被 HTML Form 支援的？PUT, PATCH, DELETE 以下的 Laravel example code 的意思是？ Example:&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt;&lt;/form&gt; Answer:讓 HTML form 可以支援 PUT, PATCH, DELETE 等 HTTP Method 以下的 Laravel example code 的意思是？ Example:&lt;form action=&quot;/foo/bar&quot; method=&quot;POST&quot;&gt; @method(&#x27;PUT&#x27;) @csrf&lt;/form&gt; Answer:讓 HTML form 可以支援 PUT, PATCH, DELETE 等 HTTP Method, 使用 blade 的方法來發 PUT method # Accessing The Current Route以下的 Laravel example code 的意思是？ Example:&lt;?php$name = \\Illuminate\\Support\\Facades\\Route::currentRouteName(); Answer:取得當前 route name 以下的 Laravel example code 的意思是？ Example:&lt;?php$name = \\Illuminate\\Support\\Facades\\Route::current(); Answer:取得當前的 route object 以下的 Laravel example code 的意思是？ Example:&lt;?php$name = \\Illuminate\\Support\\Facades\\Route::currentRouteAction(); Answer:取得當前 request 存取的 controller Laravel 中, route 的 action 長什麼樣子？App\\Http\\Controllers\\Admin\\controllerName@controllerMethodName 下面提供所以可以被取得的 route methodunderlyingClass of the Route facadeRoute instance # Additional以下的 Laravel example code 的意思是？ Example:&lt;?phpRoute::middleware([&#x27;throttle:uploads&#x27;])-&gt;group(function () &#123; Route::post(&#x27;/audio&#x27;, function () &#123; // &#125;); Route::post(&#x27;/video&#x27;, function () &#123; // &#125;);&#125;); Answer:attached 在 RouteServiceProvider 定義完成的 rate limiter 到指定的 route group 以下的 Laravel example code 的意思是？ Example:&lt;?phpRateLimiter::for(&#x27;login&#x27;, function (Request $request) &#123; return [ Limit::perMinute(500), Limit::perMinute(3)-&gt;by($request-&gt;input(&#x27;email&#x27;)), ];&#125;); Answer:使用 configureRateLimiting() 來定義多個 rate limiter, throttle 每分鐘次數, 每分鐘可 500 次, 但同個 mail 每分鐘最多 3 次 以下的 Laravel example code 的意思是？ Example:&lt;?php// RouteServiceProviderRateLimiter::for(&#x27;uploads&#x27;, function (Request $request) &#123; return $request-&gt;user() ? Limit::perMinute(100)-&gt;by($request-&gt;user()-&gt;id) : Limit::perMinute(10)-&gt;by($request-&gt;ip());&#125;); Answer:使用 configureRateLimiting() 來定義一個 rate limiter, throttle 每分鐘次數, authenticated user 每分鐘 100 次, guest per ip 每分鐘 10 次 以下的 Laravel example code 的意思是？ Example:&lt;?php// RouteServiceProviderRateLimiter::for(&#x27;uploads&#x27;, function (Request $request) &#123; return $request-&gt;user()-&gt;vipCustomer() ? Limit::none() : Limit::perMinute(100)-&gt;by($request-&gt;ip());&#125;); Answer:使用 configureRateLimiting() 來定義一個 rate limiter, throttle 每分鐘次數, 如果 user 是 vip, 就無限制, 否則每分鐘, 每 IP 100 次 以下的 Laravel example code 的意思是？ Example:&lt;?php// RouteServiceProviderRateLimiter::for(&#x27;uploads&#x27;, function (Request $request) &#123; return $request-&gt;user()-&gt;vipCustomer() ? Limit::none() : Limit::perMinute(100);&#125;); Answer:使用 configureRateLimiting() 來定義一個 rate limiter, throttle 每分鐘次數, 如果 user 是 vip, 就無限制, 否則每分鐘 100 次 以下的 Laravel example code 的意思是？ Example:&lt;?php// RouteServiceProviderRateLimiter::for(&#x27;global&#x27;, function (Request $request) &#123; return Limit::perMinute(1000)-&gt;response(function () &#123; return response(&#x27;Custom response...&#x27;, 429); &#125;);&#125;); Answer:使用 configureRateLimiting() 來定義一個 rate limiter, throttle 每分鐘次數, 並定義 response 以下的 Laravel example code 的意思是？ Example:&lt;?php// RouteServiceProviderprotected function configureRateLimiting()&#123; RateLimiter::for(&#x27;global&#x27;, function (Request $request) &#123; return Limit::perMinute(1000); &#125;);&#125; Answer:使用 configureRateLimiting() 來定義一個 rate limiter, throttle 每分鐘次數","link":"/zh-tw/laravelTheBasicsRouting/"},{"title":"Laravel - Digging Deeper - Queues (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Connection Vs. Queues以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Jobs\\ProcessPodcast;ProcessPodcast::dispatch();ProcessPodcast::dispatch()-&gt;onQueue(&#x27;emails&#x27;); Answer:將 job 送到 connection 定義的 default queue將 job 送到 connection emails 定義的 default queue 以下的 Laravel example code 的意思是？ Example:php artisan queue:work --queue=high,default Answer:啟動 queue daemon, 並排序 queue 的優先順序 high,default # Driver Notes &amp; Prerequisites# Database在 Laravel 中, 如果我使用的 driver 為 database, 該如何建立 queue table?php artisan queue:tablephp artisan migrate # Redis在 Laravel 的 QUEUE 當中, 如果我使用 redis 為 driver, 該如何設定 redis 的 database connection?在 config/database.php 檔案中 # Redis Cluster以下的位於 config/queue.php Laravel example code 的意思是？ Example:&#x27;redis&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;redis&#x27;, &#x27;connection&#x27; =&gt; &#x27;default&#x27;, &#x27;queue&#x27; =&gt; &#x27;&#123;default&#125;&#x27;, &#x27;retry_after&#x27; =&gt; 90,], Answer:定義 redis cluster, 因此 queue 需 enclosed &#123; &#125; # Blocking以下的位於 config/queue.php Laravel example code 的意思是？ Example:&#x27;redis&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;redis&#x27;, &#x27;connection&#x27; =&gt; &#x27;default&#x27;, &#x27;queue&#x27; =&gt; &#x27;default&#x27;, &#x27;retry_after&#x27; =&gt; 90, &#x27;block_for&#x27; =&gt; 5,], Answer:retry_after 表示每個 job 最多維持 reserved state 90 秒, 以避免 worker crash 之後一個 job 永遠不被執行block_for 表示 worker 在進入下一輪的循環之前, 會先 block 5 秒看有沒有新的 job 進來, 可參考 Mohamed Said 的 video # Creating Jobs# Generating Job ClassesLaravel 中, 一般 job 都會放在哪？app/Jobs Laravel 中, 如何建立一個 Job?php artisan make:job jobName 在 Laravel 中, 當我們注入一個 Model 到 Job, 是會整個 Model 都被注入, 還是只會注入該 Model 的一個辨識物？Only an identifier will be stored in the job 在 Laravel 中, 當我在 job 中注入一個 model, 當這個 job 被在 queue 中被取出執行時, 請入該 model 會是我當初注入時的狀態, 還是目前資料庫中最新的狀態？資料庫中的狀態 # Handling Relationships以下位於 job 的 Laravel example code 的意思是？ Example:&lt;?phppublic function __construct(Podcast $podcast)&#123; $this-&gt;podcast = $podcast-&gt;withoutRelations();&#125; Answer:當注入 model 到 job 時, 預設會載入 relations, 可指定不載入 # Job Middleware在 Laravel Queue 中, 可以建立一個 Job middleware 嗎？可以 在 Laravel Queue 中, 如果我想要建立一個 Job Middleware, 可以建立在什麼位置？什麼位置都可以, 官方範例位置為 app/Jobs/Middleware 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Jobs\\Middleware;use Illuminate\\Support\\Facades\\Redis;class RateLimited&#123; public function handle($job, $next) &#123; Redis::throttle(&#x27;key&#x27;) -&gt;block(0)-&gt;allow(1)-&gt;every(5) -&gt;then(function () use ($job, $next) &#123; $next($job); &#125;, function () use ($job) &#123; $job-&gt;release(5); &#125;); &#125;&#125;// in job classpublic function middleware()&#123; return [new RateLimited];&#125; Answer:建立一個 job middleware, 利用 redis throttle 限制 job 每 5 秒可以執行 1 次, 並在 job 中使用該 middleware # Dispatching Jobs以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast); &#125;&#125; Answer:dispatch 一個 job # Delayed Dispatching以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast) -&gt;delay(now()-&gt;addMinutes(10)); &#125;&#125; Answer:delay dispatch 該 job 的時間, 10 分鐘後在 dispatch 在 Laravel Queue 中, AWS 的 SQS 最多支援到 delay 多久？15 分鐘 # Synchronous Dispatching以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatchNow($podcast); &#125;&#125; Answer:立即 dispatch 這個 job, 不使用 queue # Job Chaining在 Laravel Job chaining 中, 如果其中一個 job 失敗了, 後面的還會繼續執行嗎？不會 在 Laravel Job chaining 中, 如果我使用 $this-&gt;delete(), 會終止後面的 job 執行嗎？不會 以下的 Laravel example code 的意思是？ Example:&lt;?phpProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast])-&gt;dispatch(); Answer:使用 withChain() 實現 job chaining, job 會按照順序執行 # Chain Connection &amp; Queue以下的 Laravel example code 的意思是？ Example:&lt;?phpProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast])-&gt;dispatch()-&gt;allOnConnection(&#x27;redis&#x27;)-&gt;allOnQueue(&#x27;podcasts&#x27;); Answer:使用 withChain() 實現 job chaining, 並指定該 chaining 的 connection 以及 queue # Customizing The Queue &amp; Connection# Dispatching To A Particular Queue以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast)-&gt;onQueue(&#x27;processing&#x27;); &#125;&#125; Answer:使用 onQueue() 來指定 queue # Dispatching To A Particular Connection以下的 Laravel example code 的意思是？ Example:&lt;?Phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast)-&gt;onConnection(&#x27;sqs&#x27;); &#125;&#125; Answer:如果我使用不只一個 connection, 可使用 onConnection() 指定特定的 connection 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Jobs;class ProcessPodcast implements ShouldQueue&#123; public $connection = &#x27;sqs&#x27;;&#125; Answer:在 job class 中, 可使用 $connection property 指定該 job 的 connection 以下的 Laravel example code 的意思是？ Example:&lt;?phpProcessPodcast::dispatch($podcast) -&gt;onConnection(&#x27;sqs&#x27;) -&gt;onQueue(&#x27;processing&#x27;); Answer:dispatch 時指定該 job 的 connection 以及 queue # Specifying Max Job Attempts / Timeout Values# Max Attempts以下的 Laravel example code 的意思是？ Example:php artisan queue:work --tries=3 Answer:指定 worker 的嘗試次數, 會嘗試執行 job 最多 3 次, 第一次也算一次, release() 也算一次, 如果 3 次都失敗, 才會把它放到 failed_job table 內 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Jobs;class ProcessPodcast implements ShouldQueue&#123; public $tries = 5;&#125; Answer:指定該 job 的最大嘗試次數, 如果 5 次都執行失敗, release() 也算 1 次, 第一次也算, 那 worker 就會將這個 job 放到 failed_job table 中, 不再嘗試執行 Laravel job 當中, 當我同時在 job class 中, 以及 CLI 中都指令最大嘗試次數, Laravel 會以誰為準？job class 中指定的 property # Time Based Attempts以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function retryUntil()&#123; return now()-&gt;addSeconds(5);&#125; Answer:為這個 job 定義一個可被執行的時間限制, 超過 5 秒後, 這個 job 就會被放到 failed_table 中 # Timeout以下的 Laravel example code 的意思是？ Example:php artisan queue:work --timeout=30 Answer:該 worker 最多執行一個 job 30 秒, 若超過 30 秒視為 timeout 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Jobs;class ProcessPodcast implements ShouldQueue&#123; public $timeout = 120;&#125; Answer:指定 timeout, 為該 job 可執行的最大秒數, 通過即視為失敗, 失敗超過 tries property 限制即視為 failed Laravel job 當中, 如果我再 CLI 以及 job 的 class 同時定義的 timeout, 哪一個的優先權比較大？job class # Rate LimitingLaravel queue 當中, 如果我想使用 rate limiting, 哪一個服務會是必要的？redis 以下的 Laravel example code 的意思是？ Example:&lt;?phpRedis::throttle(&#x27;key&#x27;)-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); Answer:定義特定的 key, 可以是 job 的類型 + 該 Eloquent Model 的 id每 60 秒最大可執行 10 次, 若失敗的話, 10 秒後 release job 下面的 Laravel 程式碼中, 當我 release 該 job, 這樣還會增加該 job 的 attempt 次數嗎？ Example:&lt;?phpRedis::throttle(&#x27;key&#x27;)-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); Answer:會哦 以下的 Laravel example code 的意思是？ Example:&lt;?phpRedis::funnel(&#x27;yourKey&#x27;)-&gt;limit(1)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); Answer:使用 redis 記錄一個 key, 並給予這個 key 一個 job, 限制有著該 key 的 job 每次只能由一個 worker 執行 # Queueing Closures在 Laravel 中, 什麼情況我們可能會需要 dispatch 一個 closure?當我們想要執行一個簡單的任務, 且需要它被在請求之外的週期執行 在 Laravel 中, 如何 dispatch 一個 closure?&lt;?php$podcast = App\\Podcast::find(1);dispatch(function () use ($podcast) &#123; $podcast-&gt;publish();&#125;); # Running The Queue Worker在 Laravel 中, 怎麼樣啟動 worker 來執行 queued job?php artisan queue:work 在 Laravel 中, 要維持 worker 持續運行, 我們需要額外啟動什麼？程序管理器, 像是 supervisor, 或 pm2 在 Laravel 中, 當我使用 php artisan queue:work, 當我代碼有變更時, 我需要重新啟動 queue 嗎？需要 在 Laravel 中, 如果我運行 php artisan queue:listen, 然後我變更了代碼, 我需要再重新啟動 queue 嗎？不需要 在 Laravel 中, 如果我不想要每次變更代碼就重新啟動 queue, 我可以使用哪一個 CLI?php artisan queue:listen 在 Laravel 中, php artisan queue:work 跟 php artisan queue:listen 何者較有效率？php artisan queue:work # Specifying The Connection &amp; Queue在 Laravel 中, 如何透過 CLI 指定 queue connection?php artisan queue:work redis 在 Laravel 中, 如何透過 CLI 給特定的 queue 指定特定 connection?php artisan queue:work redis --queue=emails # Processing A Single Job在 Laravel 中, 如何透過 CLI 指定 worker 只執行 queued job 一次php artisan queue:work --once # Processing All Queued Jobs &amp; Then Exiting以下的 Laravel example command 的意思是？ Example:php artisan queue:work --stop-when-empty Answer:該 worker 執行完所有的 queue job 之後就會關閉 以下的 Laravel 指令什麼時候可能會用到？ Example:php artisan queue:work --stop-when-empty Answer:當我們利用容器運行 worker, 而我們需要工作都完成後自動關閉 container 時 # Resource Considerations在 Laravel 的 queue 中, 因為會緩存在 RAM 中運行, 所以如果我有執行到未釋放的資源, 像是 image 之類的, 那我是否要在 job 執行完成之後釋放掉這些資源？要哦 # Queue Priorities以下的 Laravel example code 的意思是？ Example:php artisan queue:work --queue=high,low Answer:定義 queue 的 priority 順序 # Queue Workers &amp; Deployment# Job Expiration在 Laravel 的 queue 監聽程序中, 我要如何重啟 queue？php artisan queue:restart 在 Laravel 的 queue 監聽 CLI php artisan queue:restart, 會不會讓我丟失執行到一半的工作？不會哦, 它會 gracefully restart, 完成目前手邊工作之後再重啟 Laravel 中, 在沒有使用 supervisor 的情況下, 如果我執行 php artisan queue:restart, 會發生什麼事？worker 會關閉 Laravel 中, 若要使用 php artisan queue:restart, 務必先要確認什麼服務已經設置好？cache Laravel 中, 當我使用 php artisan queue:restart, queue 會將 restart 的 signal 存在什麼地方？cache Laravel queue 中, 如果我要 globally 定義 job 在執行之後多久時間之後才可以再被執行 (如果沒被刪除的話), 我可以怎麼做？在 queue.php 的 config 檔案中, 可以設定 retry_after 的參數 Laravel queue 中, 哪一個服務無法在 queue.php config 中設定 retry_after 參數Amazon SQS # Worker TimeoutsLaravel queue 中, --timeout 跟 retry_after 的差別在哪？--timeout: queue 的 master 程序需等待多久的時間才可以殺掉一個執行同樣一個 job 的子程序retry_after: queue 的 master 程序需要隔多久才可以重啟一個子程序來執行之前執行過的 job Laravel queue 中, --timeout 跟 retry_after 的時間, 哪個長哪個短？--retry_after 需要比 --timeout 來得長 Laravel queue 中, 如果 retry_after 比 --timeout 設定的時間還短, 可能會發生什麼事？同一個 job 會被執行兩次 # Worker Sleep DurationLaravel queue 中, 如果我要讓 worker 沒有新的 job 時會進入休眠狀態, 那我可以怎麼做？php artisan queue:work --sleep=3 Laravel queue 中, 如果我有使用 --sleep 的 option, 當 queue 裡頭有很多 job 還沒有執行完畢時, worker 會進入 sleep 狀態嗎？不會, 會等到所有 job 都處理完畢, 沒有新的 job 了 worker 才會進入 sleep 狀態 Laravel queue 中, 如果我有使用 --sleep 的 option, 當 worker 處於 sleep 的狀態時, 如果有新的 job 進來, worker 會等到 sleep 結束再處理, 還是會立即處理？待 sleep 結束才會處理 # Supervisor Configuration# Installing Supervisor如何安裝 supervisor ?sudo apt-get install supervisor Supervisor 的設定檔位置在哪？/etc/supervisor/conf.d 以下的 supervisor config example 的意思是？ Example:[program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3autostart=trueautorestart=trueuser=forgenumprocs=8redirect_stderr=truestdout_logfile=/home/forge/app.com/worker.logstopwaitsecs=3600 Answer:[program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3// 是否隨 supervisor 啟動一起啟動autostart=true// 程序異常退出後自動重啟autorestart=trueuser=forgenumprocs=8// 是否教錯誤的 log 一併記錄到 stdoutredirect_stderr=true// 一般輸出的記錄檔案位址stdout_logfile=/home/forge/app.com/worker.log// 刪除一個 job 的等待時間, 這邊需設定大於會執行最久的 job 的時間, 不然會在執行完畢前被砍掉stopwaitsecs=3600 # Starting Supervisor以下的 supervisor example command 的意思是？ Example:sudo supervisorctl reread Answer:重新讀取 config 檔, 但不重啟 process 以下的 supervisor example command 的意思是？ Example:sudo supervisorctl update Answer:重新讀取 config 檔, 並依照 config 檔案重啟 process 以下的 supervisor example command 的意思是？ Example:sudo supervisorctl start laravel-worker:* Answer:啟動 supervisor Supervisor 官方文件位址?Supervisor 官方文件 # Dealing With Failed JobsLaravel queue 中, 當一個 job 一直執行失敗, 超出了指定的 tries 的限制, 那這個 job 會跑到哪裡去？failed_jobs Laravel queue 中, 如何建立 failed_jobs table?php artisan queue:failed-tablephp artisan migrate 以下的 Laravel example code 的意思是？ Example:php artisan queue:work redis --tries=3 --delay=3 Answer:如果失敗, 最多嘗試 3 次, 超過 3 次的會被歸類到 fail job 中, 每次嘗試的間隔最少 3 秒 以下位於 job 的 Laravel example code 的意思是？ Example:&lt;?phppublic $retryAfter = 3;public $backOff = 3; Answer:定義該 job 如果執行失敗了, 或被 release 回 queue 中, 要間隔多久時間才會再被 worker pick up 執行。 有時失敗是因為第三方服務短時間內故障, 若不定義間隔時間, 很可能會在短時間內將 tries 的次數全部耗光, 如此便失去了給第三方服務時間恢復正常的空間$backOff 為 Laravel 8 的用法 # Cleaning Up After Failed Jobs以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Jobs;class ProcessPodcast implements ShouldQueue&#123; use InteractsWithQueue, Queueable, SerializesModels; protected $podcast; public function __construct(Podcast $podcast) &#123; $this-&gt;podcast = $podcast; &#125; public function handle(AudioProcessor $processor) &#123; // Process uploaded podcast... &#125; public function failed(Exception $exception) &#123; // Send user notification of failure, etc... &#125;&#125; Answer:handle() 內定義邏輯, failed() 內定義當 job failed 之後要做的事 # Failed Job Events以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Queue;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Queue\\Events\\JobFailed;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Queue::failing(function (JobFailed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;exception &#125;); &#125;&#125; Answer:在 AppServiceProvider 的 boot method 中, 使用 Queue class 的 failing method, 定義了當 job 失敗時, 就會觸發這個事件, 並執行 closure 內的邏輯 # Retrying Failed Jobs以下的 Laravel example code 的意思是？ Example:php artisan queue:failed Answer:從 failed_jobs table 中檢視所有的 failed jobs 以下的 Laravel example code 的意思是？ Example:php artisan queue:failed Answer:取得 failed job id 以下的 Laravel example code 的意思是？ Example:php artisan queue:retry 5 Answer:retry 特定 failed job, 5 為 failed job ID 以下的 Laravel example code 的意思是？ Example:php artisan queue:retry all Answer:retry 所有的 failed jobs 以下的 Laravel example code 的意思是？ Example:php artisan queue:forget 5 Answer:刪除一個 failed job5 為 failed job ID 以下的 Laravel example code 的意思是？ Example:php artisan queue:flush Answer:刪除所有的 failed jobs # Ignoring Missing ModelsLaravel Queue 中, 我們注入一個 Eloquent model 到一個 job 當中, 而當執行該 job 時, 該 model 已遭刪除, 這時會發生什麼事？這個 job 會失敗, ModelNotFoundException 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic $deleteWhenMissingModels = true; Answer:當注入一個 Eloquent model 到一個 job 當中, 而當執行該 job 時, 該 model 已遭刪除, 這時會報錯, ModelNotFoundException, 可以使用 job class 中的 $deleteWhenMissingModel property, 當出現此狀況時會自動餐除該 job # Job Events以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Queue;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Queue\\Events\\JobProcessed;use Illuminate\\Queue\\Events\\JobProcessing;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Queue::before(function (JobProcessing $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); Queue::after(function (JobProcessed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); &#125;&#125; Answer:如果想在 job 開始或結束後做一些事, 可在 AppServiceProvider 的 boot() 中註冊 before() 以及 after() event, 並在 closure 內做事在 AppServiceProvider 中 Laravel Queue 中, 以下的程式碼通常可以應用在什麼情況？ Example:&lt;?php Answer:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Queue;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Queue\\Events\\JobProcessed;use Illuminate\\Queue\\Events\\JobProcessing;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Queue::before(function (JobProcessing $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); Queue::after(function (JobProcessed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); &#125;&#125; Output:記 log統計特定 job 運行次數 以下的 Laravel example code 的意思是？ Example:&lt;?phpQueue::looping(function () &#123; while (DB::transactionLevel() &gt; 0) &#123; DB::rollBack(); &#125;&#125;); Answer:在 AppServiceProvider boot() 中可以註冊 looping(), 在 worker fetch job 之前都會執行這個 closure, 將 active 的 transaction rollback # Additional以下的 Laravel example code 的意思是？ Example:&lt;?phpclass DeployProject implements ShouldQueue, ShouldBeUniqueUntilProcessing&#123; public $uniqueFor = 60; public function uniqueId() &#123; return $this-&gt;project-&gt;id; &#125;&#125; Answer:若 implement ShouldBeUniqueUntilProcessing interface, 則當該 job 被 processing 時, 就允許相同 unique id 的 job 被 dispatch 到 queue 中, 適用場景為, 如果說這個 job 是用來 deploy 最新的 commit, 只要該 queue 中有這個 job, 那就不需要有額外的 job 存在於該 queue, 但一旦該 job starts be processed, 可能就會出現新的 commit, 因此這時就允許這個 job 再度被 dispatch 到 queue 來 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass UpdateBalanceJob implements ShouldQueue, ShouldBeUnique&#123; public $uniqueId = &#x27;products&#x27;; public $uniqueFor = 60; public function uniqueId() &#123; return $this-&gt;category-&gt;id; &#125;&#125; Answer:Implement ShouldBeUnique, Laravel 會確保 queue 中, 該 $uniqueId 只會有這麼一個 job, 重複的都會被 ignore, ShouldBeUnique 跟 withoutOverlapping 的差異在於, 前者限制的是該 job 在 queue 中必須為 unique, 後者允許 multiple unique job 同時出現在 queue 中, 但只會一次執行一個$uniqueFor 代表 atomic lock 鎖住的時間, 單位為秒 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; RateLimiter::for(&#x27;reports&#x27;, function ($job) &#123; return $job-&gt;customer-&gt;onPremiumPlan() ? Limit::perHour(100)-&gt;by($job-&gt;customer-&gt;id) : Limit::perHour(10)-&gt;by($job-&gt;customer-&gt;id); &#125;);&#125;public function middleware()&#123; return [ new RateLimited(&#x27;reports&#x27;) ];&#125; Answer:先在 Service Provider 中定義 名為 report 的 RateLimiter middleware, 然後可以在 job 中使用該 middleware 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass UpdateBalanceJob implements ShouldQueue&#123; // The job handle method... public function middleware() &#123; return [ new WithoutOverlapping($this-&gt;customer-&gt;id)-&gt;expireAfter(10) ]; &#125;&#125; Answer:UpdateBalanceJob 將不會 run customer-&gt;id concurrently, 且在 10 秒後釋放 lock, 這樣即使該 job crashes 也不會讓該 lock 一直鎖住 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass UpdateBalanceJob implements ShouldQueue&#123; // The job handle method... public function middleware() &#123; return [ new WithoutOverlapping($this-&gt;customer-&gt;id)-&gt;dontRelease() ]; &#125;&#125; Answer:UpdateBalanceJob 將不會 run customer-&gt;id concurrently, 且會刪除 concurrent job 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass UpdateBalanceJob implements ShouldQueue&#123; // The job handle method... public function middleware() &#123; return [ new WithoutOverlapping($this-&gt;customer-&gt;id)-&gt;releaseAfter(10) ]; &#125;&#125; Answer:UpdateBalanceJob 將不會 run customer-&gt;id concurrently, 且會 delay 10 秒後在 release 到 queue 當中讓 worker attempts picking up 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass UpdateBalanceJob implements ShouldQueue&#123; // The job handle method... public function middleware() &#123; return [ new WithoutOverlapping() ]; &#125;&#125; Answer:UpdateBalanceJob 將不會 run concurrently 以下的 Laravel Horizon example configuration 的意思是？ Example:&#x27;environments&#x27; =&gt; [ &#x27;environment&#x27; =&gt; [ &#x27;supervisor-1&#x27; =&gt; [ &#x27;nice&#x27; =&gt; 5, ], ],] Answer:設定 worker 的 priority 不要高於其他的 server process 以下的 Laravel Horizon example configuration 的意思是？ Example:&#x27;fast_termination&#x27; =&gt; false, Answer:php artisan horizon process 預設會等到所有的 worker 都退出, 自己才會退出, 即 Supervisor 會等到所有的 worker 結束才會啟動新的 Horizon process, 但如果此時正好有 long running worker 的話, 可能就會造成 delay, 如果設定 fast_termination = true, 那 Horizon 在送出 exit signal 給所有 worker 後自己就會退出並重啟, 所以會出現新舊 worker process 共存, old worder process 處理完後會退出 以下的 Laravel Horizon example configuration 的意思是？ Example:&#x27;trim&#x27; =&gt; [ &#x27;recent&#x27; =&gt; 10080, &#x27;completed&#x27; =&gt; 10080, &#x27;pending&#x27; =&gt; 10080, &#x27;recent_failed&#x27; =&gt; 10080, &#x27;failed&#x27; =&gt; 10080, &#x27;monitored&#x27; =&gt; 10080,]; Answer:Horizon 會將一些 metrics 存在 Redis 中, 即 server memory 中, 可定義多久之後的 metrics 該被釋放 以下的 Laravel Horizon example configuration 的意思是？ Example:&#x27;memory_limit&#x27; =&gt; 64, Answer:定義 Horizon process 的 memory limit 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic $shouldBeEncrypted = true; Answer:在存到 store 之前, encrypt, 只有 worker 可以 decrypt 這些 job 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function uniqueVia()&#123; return Cache::store(&#x27;redis&#x27;); &#125; Answer:Laravel 預設會使用 default cache 來取得 atomic lock, 可指定其他的 cache instance 以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan queue:work --once Answer:worker 只執行一次就重啟, 通常用於需要執行完後立即釋放 memory, 但會消耗較多的 CPU, 因為每次都要重啟一個 application process 以下的 Laravel example code 的意思是？ Example:&lt;?phpWorker::popUsing(&#x27;notifications&#x27;, function ($pop) &#123; $queues = time()-&gt;atNight() ? [&#x27;mail&#x27;, &#x27;webhooks&#x27;] : [&#x27;push-notifications&#x27;, &#x27;sms&#x27;, &#x27;mail&#x27;, &#x27;webhooks&#x27;]; foreach ($queues as $queue) &#123; if (!is_null($job = $pop($queue))) &#123; return $job; &#125; &#125;&#125;); Answer:使用 Worker::popUsing(), customize 名為 notifications 的 worker, 如果時間是晚上, 就從 mail, webhooks queue 中 consume jobs, 反之則從其他的 queue 中 consume job 以下的 Laravel example code 的意思是？ Example:sudo supervisorctl stop group-name:* cd /home/forge/mysite.com# ...$FORGE_PHP artisan migrate --force sudo supervisorctl start group-name:* Answer:當更新部署時, 若 database schema 更新了, 但 worker 的 code 沒有更新, 那會造成 worker 的 last job fails, 所以先關掉所有的 worker, 等到 migration 更新完畢, 在啟動新的 worker, 不過如果 database schema 沒有更動的話, 不建議每次都 stop workers 以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan queue:work --tries=3 --backoff=30,90,300class SendInvoice implements ShouldQueue&#123; public $backoff = [30, 90, 300]; public function backoff() &#123; return [30, 90, 300]; &#125; &#125;&#125; Answer:使用不同的方式來設定 backoff, 即 job fails 之後, 要經過多久時間才 retry, 第一次 30 秒, 第二次 90 秒, 第三次 300 秒 Laravel Vapor 中, 如果我有一些 job 需要 high memory, 而有些 job 只需要比較低的 memory, 建議的做法是？建立一個 environment configuration 來啟動 high memory worker, 並將 heavy memory job 放到一個特別的 queue, 這個 worker 就專門 pick up 這個 queue 中的 job Laravel Vapor 中, 以什麼計費？container 啟動並執行 job 的時間 Laravel Vapor 中, 什麼是 cold start?當 Vapor 呼叫 AWS Lambda 啟動 container as worker, 會需要一些時間來啟動, 取決於 project size, 這個步驟又稱為 cold start SQS 可以設定哪個選項來避免 duplicated job?VisibilityTimeout Laravel Vapor 的最大 timeout 是多久？900 秒 為避免 memory leaking, Vapor 會在處理幾個 job 後重啟 worker container?250 jobs AWS 的 default concurrency limit 是多少？1000 per region 以下的 vapor configuration 意思是？ Example:&lt;?phpid: 1name: laravel-queues-in-action environments: production: queue-concurrency: 10 queue-memory: 1024 queue-timeout: 300 Answer:使用 vapor 時, 可定義可同時執行的 queue job 的數量, 等同於啟動 10 個 workers一個 job 最多使用 1024 mb一個 job 最多執行 300 秒, 之後 worker container 會關閉 如果要使用 Redis 在不同的用途, 假如是同一個 Redis instance, 那如果有一個應用的 traffic 特別高, 會影響其他的應用嗎？會, 因為 single thread nature 如果要使用 Redis 在不同的用途, 例如不同應用的 cache 以及 queue, 建議 practice 是？分別使用不同的資料庫 以下的 Laravel example code 的意思是？ Example:&lt;?phpQueue::connection(&#x27;database&#x27;)-&gt;size(&#x27;invoices&#x27;) Answer:取得 queue 中的 job 數量 Laravel 中, 如果使用 sync driver, 是跑在 memory 還是 database?memory Laravel 中, 如果使用 SQS 當作 queue driver, 可以使用 retry_after configuration 嗎？不行, 需到 AWS console 設定 “Default Visibility Timeout” Laravel 中, 如果使用 Sever Redis 當作 queue driver, 可以確保 job 只被 dispatch 一次嗎？可以, 因為 single thread Laravel 中, 如果使用 SQS 當作 queue driver, 可以確保 job 只被 dispatch 一次嗎？不可以 Laravel 中, 如果使用 SQS 當作 queue driver, job 的最長生命週期多長？12 小時 以下的 Laravel example code 的意思是？ Example:&lt;?php// controller$job = new SendOrderToSupplier($order);try &#123; retry(2, function () use ($job) &#123; dispatch($job)-&gt;onQueue(&#x27;high&#x27;); &#125;, 5000);&#125; catch (Throwable $e) &#123; DB::table(&#x27;dead_letter_queue&#x27;)-&gt;insert([ &#x27;message&#x27; =&gt; serialize(clone $job), &#x27;failed_at&#x27; =&gt; now() ]);&#125;// failed handlingDB::table(&#x27;dead_letter_queue&#x27;)-&gt;take(50)-&gt;each(function($record) &#123; try &#123; dispatch( unserialize($record-&gt;message) ); &#125; catch (Throwable $e) &#123; return; &#125; DB::table(&#x27;dead_letter_queue&#x27;)-&gt;where(&#x27;id&#x27;, $record-&gt;id)-&gt;delete(); &#125;) Answer:失敗時, 將 failed job serialize 並放到 table 中, 使用 cron 固定從該 table 中取出, 再次執行, 若執行成功則刪除該筆紀錄 以下的 Laravel example code 的意思是？ Example:&lt;?phpretry(2, function() &#123; GenerateReport::dispatch();&#125;, 5000); Answer:避免因為 network 的關係 dispatch 到 queue store 失敗, 所以使用 retry dispatch 兩次, 這邊要記得設定 unique SQS 每個 message 的 size 限制是多少？256 kb 以下的 Laravel example code 的意思是？ Example:&lt;?php$queuedMessage = [ &#x27;job&#x27; =&gt; serialize(clone $job), &#x27;payload&#x27; =&gt; [ // attempts, timeout, backoff, retryUntil, ... ] ]; return json_encode($queuedMessage); Answer:Laravel 會先把 queued job serialized 並放到 array, 在發送到 queue store 之前, json encoded, 所以務必確保 job instance 以及所有的 dependency 都是 serializable 以下的 Laravel example code 的意思是？ Example:&lt;?php0 * * * * forge php /home/forge/laravel.com/artisan horizon:terminate Answer:每小時關閉 horizon, 防止 memory leak 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;environments&#x27; =&gt; [ &#x27;production&#x27; =&gt; [ &#x27;supervisor-1&#x27; =&gt; [ &#x27;queue&#x27; =&gt; [&#x27;deployments&#x27;, &#x27;notifications&#x27;], &#x27;balance&#x27; =&gt; &#x27;auto&#x27;, &#x27;min_processes&#x27; =&gt; 1, &#x27;max_processes&#x27; =&gt; 10, &#x27;balanceMaxShift&#x27; =&gt; 3, &#x27;balanceCooldown&#x27; =&gt; 1 ], ],] Answer:使用 Horizon 的 auto balance strategy, 自動依照 queue busy 的程度來啟動 worker, 最小 1 個 worker, 最多 10 個每 1 秒 (balanceCooldown) 可以增加或減少 3 個 (balanceMaxShift) worker 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;environments&#x27; =&gt; [ &#x27;production&#x27; =&gt; [ &#x27;supervisor-1&#x27; =&gt; [ &#x27;connection&#x27; =&gt; &#x27;redis&#x27;, &#x27;queue&#x27; =&gt; [&#x27;deployments&#x27;, &#x27;notifications&#x27;], &#x27;balance&#x27; =&gt; &#x27;simple&#x27;, &#x27;processes&#x27; =&gt; 10, &#x27;tries&#x27; =&gt; 1, ], ],] Answer:使用 simple balance strategy, Horizon 會依照 queue priority 來分配 worker 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;environments&#x27; =&gt; [ &#x27;production&#x27; =&gt; [ &#x27;deployments&#x27; =&gt; [ // ... &#x27;timeout&#x27; =&gt; 300, &#x27;processes&#x27; =&gt; 7, &#x27;queue&#x27; =&gt; &#x27;deployments&#x27; // ... ], &#x27;notifications&#x27; =&gt; [ // ... &#x27;timeout&#x27; =&gt; 60, &#x27;processes&#x27; =&gt; 3, &#x27;queue&#x27; =&gt; &#x27;notifications&#x27; // ... ], ],] Answer:使用 Horizon 在 production 下, 啟動 7 個 worker for queue deployments, 3 個 worker for notifications 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;environments&#x27; =&gt; [ &#x27;production&#x27; =&gt; [ &#x27;supervisor-1&#x27; =&gt; [ &#x27;connection&#x27; =&gt; &#x27;redis&#x27;, &#x27;queue&#x27; =&gt; [&#x27;deployments&#x27;, &#x27;notifications&#x27;], &#x27;balance&#x27; =&gt; &#x27;off&#x27;, &#x27;processes&#x27; =&gt; 10, &#x27;tries&#x27; =&gt; 1, ], ],] Answer:Horizon 會執行如下指令, 並確保有 10 個 worker, 如果其中有的掛了, 會自動啟動, 若有其他要設定的, 例如 backoff, 也可以加到 config 檔中artisan horizon:work redis --name=default --supervisor=host-tdjk:supervisor-1--backoff=0--memory=128 --queue=deployments,notifications --sleep=3--timeout=60--tries=1 以下的 Laravel example code 的意思是？ Example:// commandphp artisan horizon// configuration[program:horizon] command=php artisan horizonprocess_name=%(program_name)s autostart=true autorestart=true stopasgroup=trueuser=forge stdout_logfile=/home/forge/.forge/notifications-workers.log stopwaitsecs=3600// 位置/etc/supervisor/conf.d/horizon.conf Answer:將 configuration 置於 .../conf.d/horizon.conf, 由 horizon 來統一控管所有的 worker, 不需要指定 numprocess, 這些參數將設定在 Horizon 的 config file, 由 Horizon 統一控管 以下的 Laravel example code 的意思是？ Example:*/5 * * * * forge php /home/forge/laravel.com/artisan queue:work --stop-when-empty --max-time=240 Answer:每 5 分鐘起動一個 worker, 結束工作後即自動退出, 若 server 的記憶體有限, 為避免 worker 越起越多 (如果 queue 非常 busy 的話), 可定義最長多少時間要退出 以下的 Laravel example code 的意思是？ Example:*/5 * * * * forge php /home/forge/laravel.com/artisan queue:work --stop-when-empty*/5 * * * * forge php /home/forge/laravel.com/artisan queue:work --stop-when-empty*/5 * * * * forge php /home/forge/laravel.com/artisan queue:work --stop-when-empty Answer:每 5 分鐘啟動三個 worker, 工作結束後自動關閉 以下的 Laravel example code 的意思是？ Example:&lt;?php// on schedule$schedule-&gt;call(function () &#123; if (Queue::size(&#x27;orders&#x27;) &lt; 30) &#123; return $this-&gt;scaleDown(); &#125; Cache::increment(&#x27;timer&#x27;); if (Cache::get(&#x27;timer&#x27;) == 4) &#123; return $this-&gt;scaleUp(); &#125;&#125;)-&gt;everyMinute();public function scaleDown()&#123; Cache::forget(&#x27;timer&#x27;); Process::fromShellCommandline( &#x27;sudo supervisorctl stop extra-workers:*&#x27; )-&gt;run();&#125;public function scaleUp()&#123; Cache::forget(&#x27;timer&#x27;); Process::fromShellCommandline( &#x27;sudo supervisorctl start extra-workers:*&#x27; )-&gt;run();&#125; Answer:如果連續四次, 即四分鐘檢測, 如果 queue orders 中的 job 數量都保持在 30 個以上的話, 即啟動 extra worker, 如果 job 數量低於 30, 則關閉 extra workers 以下的 Laravel example code 的意思是？ Example:// supervisor[program:extra-workers]command=php artisan queue:work notifications -- queue=orders,notificationsprocess_name=%(program_name)s_%(process_num)02d autostart=falseautorestart=truestopasgroup=trueuser=forgenumprocs=3 stdout_logfile=/home/forge/.forge/extra-workers.log stopwaitsecs=3600// suvisor commandsupervisorctl rereadsupervisorctl update// cron0 7 * * * root supervisorctl start extra-workers:* 0 11 * * * root supervisorctl stop extra-workers:* Answer:rush hour scaling, 少了 autostart, 所以當 restart supervisor 時, 不會自動啟動這個 groupreread 並 update, 將這個 group 更新到 supervisor memory使用 cron 來管理 start and stop 以下的 Laravel example code 的意思是？ Example:php artisan queue:work --max-jobs=1000 --max-time=3600 Answer:定義 worker 最多執行 1000 個 job, 以及最長的執行一小時, 達到任一時, 會自動重啟, 以避免 memory leakworker 會在每次完成一個 job 後, 檢查是否達到條件來決定退出或繼續 pick up job 以下的 cron example 的意思是？ Example:0 * * * * forge php /home/forge/laravel.com/artisan queue:restart Answer:每小時 restart worker 來避免 memory leak 以下的 supervisor 的意思是？ Example:supervisorctl restart notification-workers:* supervisorctl restart reports-workers:* Answer:當 code 更新時, worker 的 code 並未更新, 所以必須 restart 當使用 supervisor stop 時, 會中斷執行到一半的 task 嗎？不會, 會送出 stop signal, 讓 worker 先完成手邊的工作, 並停止 pick up new task, 然後退出 以下的 supervisor example 的意思是？ Example:[program:notification-workers]command=php artisan queue:work notifications --tries=3 --memory=256process_name=%(program_name)s_%(process_num)02d autostart=trueautorestart=truestopasgroup=trueuser=forgenumprocs=4 stdout_logfile=/home/forge/.forge/notifications-workers.log stopwaitsecs=3600 Answer:stopasgroup=true, 如果這個選項開啟, 當要求 supervisor stop this group 時, signal 會被發送到 every process in this group Laravel 中, 如果一個 worker 吃光了 PHP 可用的所有 memory, 那會發生什麼事？該 worker 會 exit with a fetal error 以下的 Laravel Testing example code 的意思是？ Example:&lt;?phpphp artisan queue:work --memory=256 Answer:指定每個 worker 可以使用的最大 memory size, worker-level 使用的 memory 不可超過定義在 php.ini 中, 分配給 PHP 的 memory limit 以下的 Laravel Queue example code 的意思是？ Example:&lt;?phpSomeClass::$property[] = $item;SomeClass::$property = []; Answer:當使用 singleton 方法 cache value 時, 在 job 結束時別忘了 clean resource Laravel 中, 如果 server 是一台 single CPU server, and jobs involve a lot of waiting, 那建議啟動幾個 worker?可以啟用多個, 因為當一個 worker waiting 時, 其他 worker 可以使用 CPU Laravel 中, 如果 server 是一台 single CPU server, 而 job 是 CPU intensive job, 那建議啟動幾個 worker?一個, 因為該 worker 將會使用掉大部分的 CPU 以下的 Laravel example code 的意思是？ Example:&lt;?phpwhile (true) &#123; $job = $this-&gt;getNextJob(); if ($job) &#123; $this-&gt;process($job); &#125; else &#123; sleep(3); &#125;&#125; Answer:worker 實際的運作模式 以下的 Laravel Testing example code 的意思是？ Example:&lt;?php// Event listenerclass EventServiceProvider extends ServiceProvider&#123; protected $listen = [ NewOrderSubmitted::class =&gt; [ UpdateCustomerMetrics::class, SendInvoice::class, SendGiftCoupon::class, ], ];&#125;// Controllerclass OrderController&#123; public function store() &#123;// ... event(new NewOrderSubmitted($order)); return redirect(&#x27;/thanks&#x27;); &#125;&#125;// Jobclass SendGiftCoupon implements ShouldQueue&#123; public function handle(NewOrderSubmitted $event) &#123; $customer = $event-&gt;customer; $coupon = Coupon::createForCustomer($customer); Mail::to($customer)-&gt;send(new CouponGift($coupon) ); &#125; public function shouldQueue(NewOrderSubmitted $event) &#123; return $event-&gt;customer-&gt;eligibleForRewards(); &#125;&#125; Answer:使用 shouldQueue 來判斷 customer 是否 eligibleForRewards, 如果 return false, 則該 job 不會被放到 queue 中如果不使用 shouldQueue 而在 handle() 中寫 if 判斷, 一是無法掌握判斷的時機點, 因為 job 何時會被 pick up 是無法掌握的, 二是萬一是 false 的話, 會浪費資源執行一個沒有動作的 job 以下的 Laravel example code 的意思是？ Example:&lt;?phpnice -n 10 php artisan queue:workphp artisan queue:work --rest=0.5 --sleep=5 Answer:給 worker 指派較低的 priority, 這樣 CPU 會讓 request 優先的被處理, 像是 php-fpm, nginx可指定 0 到 19, 越高則 priority 越低rest 0.5 秒, 可讓 worker 在處理完 job 後, 停頓 0.5s, 讓 OS 有機會分配更多的 CPU 給 high priority 的 process Laravel queue 中, 使用 queue 的要點是什麼？job payload 越小越好 Laravel queue 中, 當使用 Redis 為 queue driver 時, 務必要讓 job 越可能得越快被執行越好, 為什麼？因為未處理的 job 會堆積在 redis 中 以下的 Laravel queue example code 的意思是？ Example:&lt;?phppublic function handle()&#123; app(&#x27;queue.worker&#x27;)-&gt;shouldQuit = 1;&#125; Answer:如果有某些 job 會耗費大量的 memory, 那麼極有可能在該 worker 完成該 job 後, 會累積大量 PHP garbage collector 無法偵測到的 reference 在 server memory 中, 可在 handle method 的結尾, 指定該 worker restart 以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan queue:work --max-jobs=1000 --max-time=3600 Answer:隨著 worker 處理 job, 會慢慢地堆積一些 reference, 這些 reference 不會被 PHP garbage collector 偵測並回收, 會累積在 server memory, 直到累積到某個點, 造成 server crash, 因此可定義讓 worker 執行到達某個量的 job 或時間便自動釋放重啟 以下的 Laravel example code 的意思是？ Example:&lt;?php// In controllerpublic function store()&#123; Messenger::dispatch($customer);&#125;// In Messenger Jobpublic $tries = 0;public function handle()&#123; if (!$this-&gt;customer-&gt;is_active) &#123; return $this-&gt;fail( new \\Exception(&#x27;Customer account is not active!&#x27;) ); &#125; $messages = Messages::where(&#x27;customer&#x27;, $this-&gt;customer-&gt;id)-&gt;where(&#x27;status&#x27;, &#x27;pending&#x27;) -&gt;orderBy(&#x27;timestamp&#x27;)-&gt;limit(10)-&gt;get(); if (!$messages-&gt;count()) &#123; return $this-&gt;release(5); &#125; foreach ($messages as $message) &#123; $this-&gt;chained[] = $this-&gt;serializeJob(new ProcessMessage($message)); &#125; $this-&gt;chained[] = $this-&gt;serializeJob(new self($this-&gt;customer)); Bus::chain($this-&gt;chained)-&gt;dispatch();&#125;// In ProcessMessage Jobpublic $tries = 0;public function handle()&#123; if ($this-&gt;attemps() &gt; 5) &#123; Log::error(...); return; &#125; Intercom::send($this-&gt;message); $this-&gt;message-&gt;update([ &#x27;status&#x27; =&gt; &#x27;sent&#x27; ]);&#125; Answer:&lt;?php// In controller// 當建立新的 customer 時, 啟動該 jobpublic function store()&#123; Messenger::dispatch($customer);&#125;// In Messenger Job// $treis 設為 0, 因為這個 job 將會無限制次數的一直跑在背景, 監聽著 databasepublic $tries = 0;public function handle()&#123; // 如果該 customer 帳號為啟動, 則 return 該 job, 啟動時需 dispatch messenger job if (!$this-&gt;customer-&gt;is_active) &#123; return $this-&gt;fail( new \\Exception(&#x27;Customer account is not active!&#x27;) ); &#125; // Laravel 會將 chain&#x27;s jobs payloads 存在第一個 the payload of the first job in the chain // 所以使用 limit() 以避免 payload size 過大 $messages = Messages::where(&#x27;customer&#x27;, $this-&gt;customer-&gt;id)-&gt;where(&#x27;status&#x27;, &#x27;pending&#x27;) -&gt;orderBy(&#x27;timestamp&#x27;)-&gt;limit(10)-&gt;get(); // 如果目前資料庫中沒有未處理的 message, 則 5 秒後再看一次 if (!$messages-&gt;count()) &#123; return $this-&gt;release(5); &#125; // 取得將會用到的 job foreach ($messages as $message) &#123; $this-&gt;chained[] = $this-&gt;serializeJob(new ProcessMessage($message)); &#125; // 最後, 將 messenger 這個 job 放在最後, 這樣當所有的 message 都處理完成 // 會再次執行 messenger job, 再檢查一次資料庫 $this-&gt;chained[] = $this-&gt;serializeJob(new self($this-&gt;customer)); // dispatch chained jobs Bus::chain($this-&gt;chained)-&gt;dispatch();&#125;// In ProcessMessage Job// $tries 需設為 0, 這樣才不會因為失敗被 mark as failed// 才不會讓後面的 job 都無法被執行public $tries = 0;public function handle()&#123; // 因為 $tries 設為 0, 所以這邊要手動的處理 failure // 如果嘗試超過 5 次, 就 log 並 return, 執行下一個 message job if ($this-&gt;attemps() &gt; 5) &#123; Log::error(...); return; &#125; Intercom::send($this-&gt;message); $this-&gt;message-&gt;update([ &#x27;status&#x27; =&gt; &#x27;sent&#x27; ]);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass RefundAttendee implements ShouldQueue, ShouldBeUnique&#123; public $uniqueFor = 10; // ... public function __construct($attendee) &#123; $this-&gt;attendee = $attendee; &#125; public function handle() &#123; if (!$this-&gt;attendee-&gt;invoice-&gt;wasRefunded()) &#123; $this-&gt;attendee-&gt;invoice-&gt;refund(); &#125; Mail::to($this-&gt;attendee)-&gt;send(...); &#125; public function uniqueId() &#123; return $this-&gt;attendee-&gt;invoice-&gt;id; &#125;&#125; Answer:Laravel 8 的新功能, 如果擔心一個 job 會被 dispatch 多次, 那可以 implement ShouldBeUnique interface, 當 queue 內已有該 instance, 後面 dispatch 的都會被忽略如果需要 dispatch 多個相同的 job class, 但根據帶入的 parameter 而不同的話, 可使用 uniqueId() 來作為 unique keyLaravel 在底層會嘗試取得該 job 該 unique key 的 lock, 只要該 lock 存在, 後面 dispatch 的 job 都會被忽略通常 lock 會在該 job fails 或 finish 之後 release, 若要自定義釋放時間, 可使用 $uniqueFor property 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ReportGenerationPlan&#123; public static function start($report) &#123; Bus::chain([ new ExtractData($report), function () use ($report) &#123; static::step2($report); &#125; ])-&gt;catch(function () use ($report) &#123; static::failed($report); &#125;)-&gt;dispatch(); &#125; private static function step2($report) &#123; $jobs = $report-&gt;chunks-&gt;mapInto(TransformChunk::class); Bus::batch($jobs) -&gt;then(function () use ($report) &#123; static::step3($report); &#125;)-&gt;dispatch(); &#125; private static function step3($report) &#123; Bus::chain([ new StoreData($report), new GenerateSummary($report) ])-&gt;dispatch(); &#125; private static function failed($report) &#123; // Run any cleaning work ... $report-&gt;update([ &#x27;status&#x27; =&gt; &#x27;failed&#x27; ]); &#125;&#125;// in controller$report = Report::create([...]); ReportGenerationPlan:::start($report); Answer:START-&gt; RUN ExtractData THEN-&gt; DISPATCH multiple TransformChunk jobs THEN-&gt; RUN all TransformChunk jobs from the batch THEN-&gt; DISPATCH a chain THEN-&gt; RUN StoreData THEN-&gt; RUN GenerateSummary END 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function store()&#123; $database = Database::create([ &#x27;status&#x27; =&gt; &#x27;provisioning&#x27; ]); Bus::chain( new EnsureANetworkExists(), new EnsureNetworkHasInternetAccess(), new CreateDatabase($database) )-&gt;catch(function () &#123; $network = Network::first(); if (!$network-&gt;usedByOtherResources()) &#123; $network-&gt;delete(); return; &#125; if (!$network-&gt;activeDatabases()-&gt;count()) &#123; $network-&gt;removeInternetAccess(); &#125; &#125;)-&gt;dispatch();&#125; Answer:多個 job 會按照 chain() 內的順序執行, 當第一個成功了才會執行下一個, 如果第一個一直 retry 直到 attempt 好耗盡而失敗, 那便會 invoke cache() 內的 closure先確定 network 存在, 否則則建立, 在確認 network 有 internet access, 否則則建立, 最後確認 database 是否有被 attached, 若無, 則 attach 到 network若失敗, 先確認 network 是否有被其他 resource 使用, 若無, 則直接刪除該 network, 若有被其他資源使用, 但無連接 active database, 則移除 internet access 以下的 Laravel example code 的意思是？ Example:&lt;?php// in controllerpublic function store()&#123; $temporaryFilePath = request()-&gt;file(&#x27;video&#x27;) -&gt;store(&#x27;uploaded-videos&#x27;); CompressAndStoreVideo::dispatch($temporaryFilePath);&#125;// in jobpublic function handle()&#123; if (!app(&#x27;files&#x27;)-&gt;exists($this-&gt;temporaryFilePath)) &#123; report(new \\Exception(&#x27;Temporary file not found!&#x27;)); return $this-&gt;delete(); &#125; $newFile = VideoProcessesor::compress($this-&gt;temporaryFilePath); app(&#x27;files&#x27;)-&gt;delete($this-&gt;temporaryFilePath);&#125;public function failed(Exception $e)&#123; // 如果之後不重試, 也可立即刪掉 DeleteFile::dispatch($this-&gt;temporaryFilePath)-&gt;delay(now()-&gt;addHours(24));&#125; Answer:在 controller 中, 將 file 先存到 default disk, 並取得 path, dispatch path 到 jobjob handle method 中, 檢查該 path file 是否依然存在, 如果不存在則 report 並刪掉該 job如果存在, 則 compress 該 file, 完成後刪掉該 file如果失敗了, 延遲 24 小時後刪除, 在這期間可以手動嘗試 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ModelIdentifier&#123; public function __construct( $class, $id, $relations, $connection ) &#123; $this-&gt;id = $id; $this-&gt;class = $class; $this-&gt;relations = $relations; $this-&gt;connection = $connection; &#125;&#125; Answer:Laravel 為了減少 job payload size, 當 queued job 如果其中有 model, 只會記住該 model identifier, 待真正執行該 job 時才會依照 identifier 取出 model 以下的 Laravel job middleware example code 的意思是？ Example:&lt;?phppublic function handle($job, $next)&#123; $this-&gt;lastFailureTimestamp = Cache::get(&#x27;circuit:open&#x27;); // Check if the circuit is open and release the job. if (!$this-&gt;shouldRun()) &#123; return $job-&gt;release( $this-&gt;lastFailureTimestamp + $this-&gt;secondsToCloseCircuit + rand(1, 120) ); &#125; // If the circuit is closed or half-open, we will try // running the job and catch exceptions. try &#123; $next($job); // If the job passes, we&#x27;ll close the circuit if it&#x27;s // open and reset the failures counter. $this-&gt;closeCircuit(); &#125; catch (RequestException $e) &#123; if ($e-&gt;response-&gt;serverError()) &#123; $this-&gt;handleFailure($job); &#125; &#125; catch (ConnectionException $e) &#123; $this-&gt;handleFailure($job); &#125;&#125; Answer:將 circuit pattern 的概念寫成一個 job middleware, 當 error 達到一定程度時打開 circuit breaker, 打開一段時間後啟動 half open 狀態, 放一個 job 過去, 要是該 job 成功, 則關掉 circuit breaker, 要是失敗則重新計算 circuit breaker 時間, 同時根據 exception 的不同使用不同的方式來 handle failure, request exception 或 connection exception 以下的 Laravel job example code 的意思是？ Example:&lt;?phpclass RateLimitingJobMiddleware&#123; public $key; public function __construct($key) &#123; $this-&gt;key = $key; &#125; public function handle($job, $next) &#123; Redis::throttle( $this-&gt;key ) // ... &#125;&#125;// job classpublic function middleware()&#123; return [ new BulkHeadingJobMiddleware(&#x27;slow_service&#x27;), new CircuitBreakerJobMiddleware(&#x27;unstable_service&#x27;) ];&#125; Answer:可 pass parameter 到 job middleware, 以 limit 特定的 job 以下位於 job 中的 Laravel example code 的意思是？ Example:&lt;?phppublic function middleware()&#123; return [ new RateLimitingJobMiddleware($this-&gt;customer-&gt;id) ];&#125; Answer:在 job class 中的 middleware method 中可定義該 job 會經過哪一些 middleware, 並且可 pass parameter 到 middleware 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass RateLimitingJobMiddleware&#123; public function handle($job, $next) &#123; Redis::throttle(&#x27;job-limiter&#x27;) -&gt;allow(5) -&gt;every(60) -&gt;then(function () use ($job, $next) &#123; $next($job); &#125;, function () use ($job) &#123; $job-&gt;release(60); &#125;); &#125;&#125; Answer:使用 job middleware 來限制最多可以 concurrent 執行的 job 數量, Redis 的 throttle method 會鎖住 job-limiter 字段, 使該字段只能最多 5 個 current job 被 worker pick up, $next($job) 代表執行該 job 的 handle(), 也可透過 property 來取代字段, 這樣就可以限制同類型的 job 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; if ($lastFailureTimestamp = Cache::get(&#x27;circuit:open&#x27;)) &#123; if (time() - $lastFailureTimestamp &lt; 8 * 60) &#123; return $this-&gt;release( $lastFailureTimestamp + 600 + rand(1, 120) ); &#125; else &#123; $halfOpen = true; &#125; &#125; $response = Http::acceptJson()-&gt;timeout(10) -&gt;get(&#x27;...&#x27;); if ($response-&gt;serverError()) &#123; if (isset($halfOpen)) &#123; Cache::put(&#x27;circuit:open&#x27;, time(), 600); return $this-&gt;release(600); &#125; if (!$failures = Cache::get(&#x27;failures&#x27;)) &#123; Cache::put(&#x27;failures&#x27;, 1, 60); &#125; else &#123; Cache::increment(&#x27;failures&#x27;); &#125; if (Cache::get(&#x27;failures&#x27;) &gt; 10) &#123; Cache::put(&#x27;circuit:open&#x27;, time(), 600); &#125; return $this-&gt;release(600); &#125; Cache::forget(&#x27;failures&#x27;); Cache::forget(&#x27;circuit:open&#x27;); // Use the response to run the business logic.&#125; Answer:circuit pattern如果第三方服務失敗超過 10 次, 則開啟斷路器, 10 分鐘後再嘗試若斷路器已開啟超過 8 分鐘, 先放一個 job 過去試試看, 若成功則關閉斷路器, 失敗則更新斷路器開啟時間, 重新計算 10 分鐘 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; Redis::throttle($this-&gt;report-&gt;customer_id)-&gt;allow(5) -&gt;every(60 * 60) -&gt;then(function () &#123; $results = ReportGenerator::generate($this-&gt;report); $this-&gt;report-&gt;update([ &#x27;status&#x27; =&gt; &#x27;done&#x27;, &#x27;results&#x27; =&gt; $results ]); &#125;, function () &#123; return $this-&gt;release(60 * 10); &#125;);&#125; Answer:每 1 個小時只允許每個 customer_id 可以最多產生 5 份 report, 如果 5 個 slots 都滿了, 則 acquire lock 失敗的 job 會被在 10 分鐘後 release, 60 分鐘從第一個 slot 被佔據之後開始計算時間 以下的 Laravel example code 的意思是？ Example:&lt;?phpRedis::funnel($this-&gt;report-&gt;customer_id)-&gt;releaseAfter(5 * 60)-&gt;block(...)-&gt;limit(...)-&gt;then(...) Answer:funnel limiter 預設會在 60 秒後清掉 slot, 若該 job 執行時間超過 60 秒, limiter 會清掉該 slot, 但原本的 job 還在執行中, 這樣會變成又有一個新的 job 可被執行, 這樣就超出了我們預期 limiter 的最大限制, 可使用 releaseAfter 定義 timeout 時間 以下的 Laravel example code 的意思是？ Example:&lt;?phpRedis::funnel($this-&gt;report-&gt;customer_id)-&gt;block(5) -&gt;limit(...)-&gt;then(...); Answer:funnel 預設會嘗試 acquire lock 3 秒, 可使用 block() 指定嘗試時間 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; public $tries = 10; public $maxExceptions = 2; Redis::funnel($this-&gt;report-&gt;customer_id)-&gt;limit(5) -&gt;then(function () &#123; $results = ReportGenerator::generate($this-&gt;report); $this-&gt;report-&gt;update([ &#x27;status&#x27; =&gt; &#x27;done&#x27;, &#x27;results&#x27; =&gt; $results ]); &#125;, function () &#123; return $this-&gt;release(10); &#125;);&#125; Answer:限制同一個 customer_id 最多只能同時有 5 筆 job 被執行, 若成功取得 lock 則會執行 closure, 若無法取得 lock (預設 3 秒), 則執行 second closure, 10 秒後可重新被 worker pick up 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function handle()&#123; if ($timestamp = Cache::get(&#x27;api-limit&#x27;)) &#123; return $this-&gt;release( $timestamp - time()); &#125; $response = Http::acceptJson()-&gt;timeout(10) -&gt;withToken(&#x27;...&#x27;)-&gt;get(&#x27;https://...&#x27;); if ($response-&gt;failed() &amp;&amp; $response-&gt;status() == 429) &#123; $secondsRemaining = $response-&gt;header(&#x27;Retry-After&#x27;); Cache::put(&#x27;api-limit&#x27;, now()-&gt;addSeconds($secondsRemaining)-&gt;timestamp, $secondsRemaining ); return $this-&gt;release($secondsRemaining ); &#125; // ...&#125; Answer:&lt;?phppublic function handle()&#123; // 所有會呼叫此外部服務的 job 會在第一個判斷重新被 release, 如果該外部服務 // 目前處於 429 的狀態的話 // 如果 cache 中存在 api-limit 這個 key, 代表還處於 429 狀態 // api-limit 的 value 為實際上允許再被存取的時間, 所以這個時間扣掉當前 // 的時間就會是距離可再被存取還需經過的秒數 if ($timestamp = Cache::get(&#x27;api-limit&#x27;)) &#123; return $this-&gt;release( $timestamp - time()); &#125; $response = Http::acceptJson()-&gt;timeout(10) -&gt;withToken(&#x27;...&#x27;)-&gt;get(&#x27;https://...&#x27;); // 如果 response failed, 且 status 為 429, 代表 too many attempt // 得出可再被存取的時間點, 並將這個時間點存去 cache if ($response-&gt;failed() &amp;&amp; $response-&gt;status() == 429) &#123; $secondsRemaining = $response-&gt;header(&#x27;Retry-After&#x27;); Cache::put(&#x27;api-limit&#x27;, now()-&gt;addSeconds($secondsRemaining)-&gt;timestamp, $secondsRemaining ); return $this-&gt;release($secondsRemaining ); &#125; // ...&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?php// Controllerforeach (User::all() as $user) &#123; $exchangeRate = Currency::exchangeRateFor($user-&gt;currency); GenerateInvoice::dispatch($user, $month, $exchangeRate);&#125;// Currency Classpublic static $rates = [];public static function exchangeRateFor($currency)&#123; if (!isset(static::$rates[$currency])) &#123; static::$rates[$currency] = ExchangeRateApi::get(&#x27;USD&#x27;, $currency); &#125; return static::$rates[$currency];&#125;// Job handle methodpublic function handle()&#123; $amountInLocalCurrency = $amount * $this-&gt;exchangeRate; $taxInLocalCurrency = ($amount * 14 / 100) * $this-&gt;exchangeRate; $total = $amountInLocalCurrency + $taxInLocalCurrency; Mail::to($this-&gt;user)-&gt;send(&quot;Your usage last month was &#123;$total&#125;&#123;$this-&gt;user-&gt;currency&#125;&quot;);&#125; Answer:發送月帳單給客戶使用 memorization tech 取得 exchange rate, 避免重複呼叫 API取得 exchange rate 之後在 pass 到 job, 因為 job 運行在 memory 中的 single instance, 若是在 job 中使用 memorization tech, 那將會一直使用該 instance 中的初始得到的 exchange rate 以下的 Laravel example code 的意思是？ Example:&lt;?php// controllerforeach (Site::all() as $site) &#123; if ($site-&gt;current_visitors &gt;= $site-&gt;threshold) &#123; SendSpikeDetectionNotification::dispatch( $site, $site-&gt;current_visitors); &#125;&#125;// job classprivate $site;private $visitors;public function __construct(Conference $site, $visitors)&#123; $this-&gt;site = $site; $this-&gt;visitors = $visitors;&#125;public function handle()&#123; SMS::send( $this-&gt;site-&gt;owner, &quot;Spike detected on &#123;$this-&gt;site-&gt;name&#125;! Current visitors: &#123;$this-&gt;visitors&#125;&quot; );&#125; Answer:當偵測到某個 site 的 visitor 已達 threshold, 發送 notification, 且 pass 當時的 value因為 job execute 可能會有 delay, 若是在 job 中使用 model, serialization 會讓 job 取得最新的 model 狀態, 因此可能會出現 notification 中的資訊並非當時觸發 threshold 的數字, 而是 delay 之後可能降下來的數字 以下兩個 job class example, 差異處在於？ Job Example 1:&lt;?phpprivate $site;public function __construct(Conference $site)&#123; $this-&gt;site = $site;&#125; public function handle()&#123; SMS::send( $this-&gt;site-&gt;owner, &quot;Spike detected on &#123;$this-&gt;site-&gt;name&#125;! Current visitors: &#123;$this-&gt;site-&gt;current_visitors&#125;&quot; );&#125; Job Example 2:&lt;?phpprivate $site;private $visitors;public function __construct(Conference $site, $visitors)&#123; $this-&gt;site = $site; $this-&gt;visitors = $visitors;&#125; public function handle()&#123; SMS::send( $this-&gt;site-&gt;owner, &quot;Spike detected on &#123;$this-&gt;site-&gt;name&#125;! Current visitors: &#123;$this-&gt;visitors&#125;&quot; );&#125; Answer:當 job 被 queue 時, serialization 會記下 model identifier 而非 model instance, 因此example 1 中, 因為是在 job 中 fetch model attribute, 會取得 model attribute 最新的狀態, 值可能會跟 dispatch 時不同example 2 中, 因為是在 job 中取得 job class property, 因此值會跟 dispatch 時一樣 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function store()&#123; DB::transaction(function () use ($conference) &#123; $attendee = Attendee::create([ &#x27;conference_id&#x27; =&gt; $conference-&gt;id, &#x27;name&#x27; =&gt; request(&#x27;name&#x27;), &#x27;reference&#x27; =&gt; $reference = Str::uuid() // ... ]); $invoice = BillingProvider::invoice([ &#x27;customer_reference&#x27; =&gt; $reference, &#x27;card_token&#x27; =&gt; request(&#x27;card_token&#x27;), // ... ]); &#125;); SendTicketInformation::dispatch($attendee);&#125; Answer:在 transaction 內, 建立 attendee 並 bill, 如果失敗則回滾並 throw exception, 如果都成功, 則 dispatch SendTicketInformation job, 若要在 transaction 內 dispatch 也可, 只要設定 delay 就可, 確保 transaction commit 完成之後 worker 才去 pick up job 以下的 Laravel example code 的意思是？ Example:&lt;?phpBus::batch($jobs)-&gt;allowFailures() -&gt;then(...) -&gt;catch(...)-&gt;finally(function ($batch) &#123; $conference = Conference::firstWhere(&#x27;refunds_batch&#x27;, &#x27;=&#x27;, $batch-&gt;id); Mail::to($conference-&gt;organizer)-&gt;send( &#x27;Refunding attendees completed!&#x27; ); &#125;)-&gt;dispatch(); Answer:當所有 job 都執行完畢, 儘管有些 fail, 有些 succeed, 那便會觸發 finally(), 通知 organizer 以下的 Laravel example code 的意思是？ Example:&lt;?phpBus::batch($jobs) -&gt;allowFailures() -&gt;then(...) -&gt;catch(function ($batch, $e) &#123; $conference = Conference::firstWhere(&#x27;refunds_batch&#x27;, &#x27;=&#x27;, $batch-&gt;id); Mail::to($conference-&gt;organizer)-&gt;send( &#x27;We failed to refund some of the attendees!&#x27; ); &#125;) -&gt;dispatch(); Answer:當首次有 job fails 時, 會執行 cache() 內的 closure, 通知 organizer, 如果有 job fails 就不會觸發 then() 以下的 Laravel example code 的意思是？ Example:&lt;?phpBus::batch($jobs)-&gt;allowFailures()-&gt;then(function ($batch) &#123; $conference = Conference::firstWhere(&#x27;refunds_batch&#x27;, &#x27;=&#x27;, $batch-&gt;id); Mail::to($conference-&gt;organizer)-&gt;send( &#x27;All attendees were refunded successfully!&#x27; );&#125;)-&gt;dispatch(); Answer:當 batch 內所有的 job 都 successfully executed, 會執行 then() 內的 closure, 發 mail 通知 organizer 以下的 Laravel example code 的意思是？ Example:&lt;?php$batch = Bus::findBatch($conference-&gt;refunds_batch);return [ &#x27;progress&#x27; =&gt; $batch-&gt;progress().&#x27;%&#x27;, &#x27;remaining_refunds&#x27; =&gt; $batch-&gt;pendingJobs, &#x27;has_failures&#x27; =&gt; $batch-&gt;hasFailures(), &#x27;is_cancelled&#x27; =&gt; $batch-&gt;canceled()]; Answer:取得 batch 目前的整體進度 (1-100, int)取得目前 pending jobs 的數量 (int)取得是否有 failed job (boolean)取得該 batch 是否 cancelled (boolean) 以下的 Laravel example command 的意思是？ Example:php artisan queue:retry-batch &#123;batch_id&#125; Answer:使用 CLI retry 指定 batch 中的 failed jobs 以下的 Laravel example code 的意思是？ Example:&lt;?php$batch = Bus::batch($jobs)-&gt;allowFailures()-&gt;dispatch(); Answer:當使用 batch dispatch jobs, 預設如果其中一個 job fails, 那該 batch 就會終止, 使用 allowFailures(), 即使有 job fails 該 batch 也會 dispatch 其他 job 以下的 Laravel example code 的意思是？ Example:&lt;?php$batch = Bus::findBatch($conference-&gt;refunds_batch);$batch-&gt;cancel();// in job classuse Batchable;public function handle()&#123; if ($this-&gt;batch()-&gt;canceled()) &#123; return; &#125; // Actual refunding code here ... $this-&gt;attendee-&gt;update([ &#x27;refunded&#x27; =&gt; true ]);&#125; Answer:從存在資料庫的 batch_id 取得該 batch, 並執行 cancel(), 該 batch 會被 marked as cancelled在 job handle() 中, 判斷如果該 job 的 batch 已經被 marked as cancelled, 那立即 return 該 job, 若否則繼續執行藉此當我們 mark batch as cancelled 之後, 所以在 queue 中尚未執行的 job 都會被 cancelled 以下的 Laravel example command 的意思是？ Example:php artisan queue:batches-table Answer:Laravel 會將 batch 資料存在 table, 因此需要建立該 table 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Bus\\Batchable;class RefundAttendee implements ShouldQueue&#123; use Batchable;&#125; Answer:若要 job 可被 batch dispatch, 需 use Batchable trait 以下的 Laravel example code 的意思是？ Example:&lt;?php$jobs = $this-&gt;conference-&gt;attendees-&gt;map(function ($attendee) &#123; return new RefundAttendee($attendee); &#125;);$batch = Bus::batch($jobs)-&gt;dispatch();$this-&gt;conference-&gt;update([ &#x27;refunds_batch&#x27; =&gt; $batch-&gt;id]); Answer:使用 batch(), 一次性的 queue 複數的 jobs, 相當於用一句 command 將複數的 job push 到 queue, 而不是分成多句 command並將 batch id 儲存在資料庫 以下的 Laravel job example 中, 要是 worker 在取得 lock 之後 crash 了, 那會發生什麼事？ Example:&lt;?phppublic function handle()&#123; $invoice = $this-&gt;attendee-&gt;invoice; Cache::lock(&#x27;refund.&#x27;.$invoice-&gt;id) -&gt;get(function() &#123; if (! $invoice-&gt;wasRefunded()) &#123; $invoice-&gt;refund(); &#125; Mail::to($this-&gt;attendee)-&gt;send(...); &#125;);&#125; Answer:因為 lock 並沒有設定持有秒數, 所以會永遠持有, 那當該 job reserved tag 被移除後, 其他 worker 會嘗試 pick up 該 job, 但會卡在 lock 處, 直到 $timeout, 最後耗盡 $tries 次數 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass RefundAttendee implements ShouldQueue&#123; public $tries = 3; public $timeout = 60; public $backoff = 11; private $attendee; public function __construct(Attendee $attendee) &#123; $this-&gt;attendee = $attendee; &#125; public function handle() &#123; $invoice = $this-&gt;attendee-&gt;invoice; Cache::lock(&#x27;refund.&#x27;.$invoice-&gt;id, 10) -&gt;get(function() &#123; if (! $invoice-&gt;wasRefunded()) &#123; $invoice-&gt;refund(); &#125; Mail::to($this-&gt;attendee)-&gt;send(...); &#125;); &#125;&#125;// wasRefunded public function wasRefunded()&#123; $response = HTTP::timeout(5)-&gt;get(&#x27;../invoice/&#x27;.$id)-&gt;throw() -&gt;json(); return $response[&#x27;invoice&#x27;][&#x27;status&#x27;] == &#x27;refunded&#x27;;&#125; Answer:使用 lock, 這樣當不小心 dispatch 同一個 job 兩次時, 也不用擔心 worker 會執行兩次設定 lock 秒數, 如果沒設定, 假如 worker obtain lock 之後 crash, 那該 job 將永遠不會被執行, 直到 $tries 耗盡, 因為 lock 並沒有釋放$backoff 設定 11 秒, 以避免 lock 10 秒期間 worker 不停的嘗試 obtain lock在真正 refund 之前, 都呼叫 billing provider 以確定該 invoice 是否已經 refunded, 以避免 refund 兩次 以下的 Laravel example code 的意思是？ Example:&lt;?php// on controller$this-&gt;conference-&gt;attendees-&gt;each(function ($attendee) &#123; RefundAttendee::dispatch($attendee);&#125;);// on job classclass RefundAttendee implements ShouldQueue&#123; public $tries = 3; public $timeout = 60; private $attendee; public function __construct(Attendee $attendee) &#123; $this-&gt;attendee = $attendee; &#125; public function handle() &#123; $this-&gt;attendee-&gt;invoice-&gt;refund(); Mail::to($this-&gt;attendee)-&gt;send(...); &#125;&#125;// workerphp artisan queue:work --queue=cancelations,default php artisan queue:work --queue=default,cancelations Answer:假如一場 conference 忽然要取消, 我取消 refund 這場 conference 中的每一個 attendee, 可將 refund 作業分拆成多個 small job使用兩個 worker, 定義不同的 priority 以避免 starvation 的狀況 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;connections&#x27; =&gt; [ &#x27;database&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;database&#x27;, &#x27;retry_after&#x27; =&gt; 60, ], &#x27;database_long_running&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;database&#x27;, &#x27;retry_after&#x27; =&gt; 18060, ],], Answer:retry_after 會將 job 的 reserved tag 移除, 以避免 worker crash 後該 job 始終保持 reserved 狀態而永遠不被執行但一個 connection 只能設定一個 retry_after, 所以如果有 job 運行時間會比較久 的需求時, 很可能需要第二個 connection或是盡可能地避免這種狀況, 將需要運行比較久的 job 分拆成多個 job 以下的 Laravel example code 的意思是？ Example:&lt;?php// jobclass CancelConference implements ShouldQueue&#123; public $timeout = 18000;&#125;// config/queue.php&#x27;connections&#x27; =&gt; [ &#x27;database&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;database&#x27;, &#x27;table&#x27; =&gt; &#x27;jobs&#x27;, &#x27;queue&#x27; =&gt; &#x27;default&#x27;, &#x27;retry_after&#x27; =&gt; 18060, ],], Answer:假如該 job timeout, 給 worker 60 秒的時間完成清理工作, 不管如何, 18060 秒之後, 該 job 都會被移除 reserved tag 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass ProvisionServer implements ShouldQueue&#123; private $server; private $payload; public $tries = 20; public $maxExceptions = 3; public function __construct(Server $server, $payload) &#123; $this-&gt;server = $server; $this-&gt;payload = $payload; &#125; public function handle() &#123; if (!$this-&gt;server-&gt;forge_server_id) &#123; $response = Http::timeout(5)-&gt;post( &#x27;.../servers&#x27;, $this-&gt;payload)-&gt;throw()-&gt;json(); $this-&gt;server-&gt;update([ &#x27;forge_server_id&#x27; =&gt; $response[&#x27;id&#x27;] ]); return $this-&gt;release(120); &#125; if ($this-&gt;server-&gt;stillProvisioning($this-&gt;server)) &#123; return $this-&gt;release(60); &#125; $this-&gt;server-&gt;update([ &#x27;is_ready&#x27; =&gt; true ]); &#125; public function failed(Exception $e) &#123; Alert::create([ // ... &#x27;message&#x27; =&gt; &quot;Provisioning failed!&quot; ]); $this-&gt;server-&gt;delete(); &#125;&#125; Answer:如果沒有 forge_server_id, 代表 Forge server 尚未建立, 所以呼叫 Forge API, 建立 server 並取得 server id, 將 job 丟回 queue, 指定 120 秒後再執行一次如果 server 處於 provisioning 狀態, 丟回 queue, 60 秒後再執行一次建立完成後, 更新 Server model 中的 id_ready 為 true該 job 可被執行最多達 20 次, 但如果是 exception, 最多 3 次如果失敗, 建立 Alert 並刪除此筆 server record 以下位於 config/queue.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;connections&#x27; =&gt; [ &#x27;database&#x27; =&gt; [ &#x27;driver&#x27; =&gt; &#x27;database&#x27;, // ... &#x27;retry_after&#x27; =&gt; 90, ],], Answer:當一個 worker pick up 一個 job 時, 會在這個 job mark reserved, 這樣其他 worker 就不會嘗試 pick up 這個 job, 但當一個 worker 在執行這個 job 時 crash 了, 會導致這個 job 的 reserved mark 不會被清除, 導致這個 job 永遠不會被執行。 Laravel 為了預防這一點, 定義了一個 job 最長可以處於 reserved state 多久, 就是 retry_after Laravel Queue 中, 當一個 worker 執行一個 job 時, 為何其他 worker 不會執行同一個 job?因為當一個 worker pick up 一個 job 時, 會 mark job as reserved Laravel Queue 中, 當使用 job 的 retry_until = 120, 代表該 job 在 120 秒後就會立即被執行嗎？不是哦, 這只代表該 job 在 release 或 dispatch 後的 120 秒內不會被執行, 如果 worker 都很忙, 10 分鐘後才被執行也是有可能的 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic $tries = 0;public function handle()&#123; $response = Http::timeout(...)-&gt;post(...); if ($response-&gt;failed()) &#123; $this-&gt;release( now()-&gt;addMinutes(15 * $this-&gt;attempts())); &#125;&#125;public function retryUntil()&#123; return now()-&gt;addDay();&#125;public function failed(Exception $e)&#123; Mail::to($this-&gt;integration-&gt;developer_email )-&gt;send(...);&#125; Answer:如果 request 失敗的話, 逐次的遞增再次執行該 job 的時間間隔, 最多嘗試一天(會從第一次 dispatch 時開始計算時間), 在一天內可以無限次數嘗試(依照定義的時間間隔頻率), 若超過一天則視為 failed job失敗的話, 採取相對應動作 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass CheckoutController&#123; public function store() &#123; $order = Order::create([ &#x27;status&#x27; =&gt; Order::PENDING, // ... ]); MonitorPendingOrder::dispatch($order)-&gt;delay(900); // also ... delay(now()-&gt;addMinutes(15)) &#125;&#125;// MonitorPendingOrder class public $tries = 4; public function handle() &#123; if ($this-&gt;order-&gt;status == Order::CONFIRMED || $this-&gt;order-&gt;status == Order::CANCELED) &#123; return; &#125; if ($this-&gt;order-&gt;olderThan(59, &#x27;minutes&#x27;)) &#123; $this-&gt;order-&gt;markAsCanceled(); return; &#125; SMS::send(...); $this-&gt;release(now()-&gt;addMinutes(15) ); &#125; Answer:常常使用者建立訂單後, 忽然決定不買了, 但也不會手動取消這張訂單如上 example 邏輯訂單建立後每 15 分鐘提醒使用者有這張訂單存在若過了 59 分鐘後, 訂單並未被 confirmed, 也未 cancelled, 這時 job 就取消這張訂單public $tries 確保這個 job 能被執行 4 次, 這邊 4 次還是有點太少了, 可以在設大一點 以下的 Laravel example command 的意思是？ Example:php artisan queue:work --backoff=60,120 Answer:定義該 worker 在嘗試 job 的時間間隔, 比如說嘗試執行 job A 失敗了, 第一次要間隔 60 秒之後才可嘗試再次執行, 第二次之後都要間隔至少 120 秒Laravel 8 之前又叫做 –delay 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Jobs;class SendVerificationMessage implements ShouldQueue&#123; public $tries = 3; public $backoff = [60, 120];&#125; Answer:$tries 定義該 job 最多會被執行 3 次, release() 也算一次, 如果 3 次過了還在 queue 當中, 那就會被放到 failed_job 當中$backoff 定義每次嘗試執行 job 的時間間隔, 第一次為 60 秒, 之後都間隔 120 秒, Laravel 8.0 之前叫做 retryAfter 以下的 Laravel example code 的意思是？ Example:php artisan queue:work --queue=payments,default php artisan queue:work --queue=default,payments Answer:讓兩個 worker 分別執行兩個 queue, 以避免一個執行完就處於 idle 狀態 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; Event::listen(function (QueueBusy $event) &#123; Notification::route(&#x27;mail&#x27;, &#x27;dev@example.com&#x27;) -&gt;notify(new QueueHasLongWaitTime( $event-&gt;connection, $event-&gt;queue, $event-&gt;size )); &#125;);&#125; Answer:當使用 queue:monitor 檢查到 queue 的 job size 超過 threshold, 且觸發 QueueBusy event, 可監聽此事件來做通知 以下的 Laravel example command 的意思是？ Example:php artisan queue:monitor redis:default,redis:deployments --max=100 --threshold=8 Answer:列出指定 queue 中的 job size, 若超過 threshold 則觸發 QueueBusy event","link":"/zh-tw/laravelDiggingDeeperQueues/"},{"title":"Laravel 學習筆記","text":"# 前言本篇為 Laravel 的學習筆記, 主要將看到的, 學到的技術轉換成 Q&amp;A 的方式以加速學習 # Production 優化# PHPphp.ini 文件php.ini 中的 memory_limit 用於設定單個 PHP process 可以使用的系統內存最大值 # Laravel timezone 與 MySQL timezone# 當 Laravel 收到沒有時區的時間 預設此時間為 Laravel timezone, 不另外做轉換直接帶給資料庫, 如下圖:sequenceDiagram participant Client participant Laravel participant MySQL NOTE OVER Client,Laravel: 假設 Laravel 時區為 Asia/Taipei Client-->>Laravel: 給你 2021-02-05 15:27:46 NOTE OVER Client,Laravel: Laravel 會默認上述時間為 Asia/Taipei Laravel-->>MySQL: 給你 2021-02-05 15:27:46 # 當 Laravel 收到有時區的時間 將時間轉為 Laravel 時區, 如下圖:sequenceDiagram participant Client participant Laravel participant MySQL NOTE OVER Client,Laravel: 假設 Laravel 時區為 Asia/Taipei Client-->>Laravel: 給你 2021-02-05T15:27:46+0400 NOTE OVER Client,Laravel: Laravel 會將上面的時間轉為 Asia/Taipei NOTE OVER Client,Laravel: 即 2021-02-05T19:27:46+0800 Laravel-->>MySQL: 給你 2021-02-05 19:27:46 # Laravel 回傳時間sequenceDiagram participant Client participant Laravel participant MySQL NOTE OVER Client,Laravel: 假設 Laravel 時區為 Asia/Taipei MySQL-->>Laravel: 給你 2021-02-05 19:27:46 NOTE OVER Client,Laravel: Laravel 默認上面時間的時區為 Asia/Taipei NOTE OVER Client,Laravel: 即 2021-02-05T11:27:46+0000 (預設回傳 ISO8601) Laravel-->>Client: 給你 2021-02-05T11:27:46+0000 # 當 MySQL 的 column 為 datetimesequenceDiagram participant Laravel participant MySQL Laravel-->>MySQL: 給你 2021-02-05 19:27:46 NOTE OVER Laravel,MySQL: 當 column type 為 datetime, 不做任何變更 NOTE OVER Laravel,MySQL: 實存 2021-02-05 19:27:46 到資料庫 # 當 MySQL 的 column 為 timestampsequenceDiagram participant Laravel participant MySQL Laravel-->>MySQL: 給你 2021-02-05 19:27:46 NOTE OVER Laravel,MySQL: MySQL column type 為 timestamp, 假設 MySQL timezone 為 Asia/Taipei NOTE OVER Laravel,MySQL: 使用 default timezone 將該時間轉為 UTC 儲存 NOTE OVER Laravel,MySQL: 實存 2021-02-05T11:27:46+0000, 顯示 2021-02-05 19:27:46 NOTE OVER Laravel,MySQL: 之後若是更換時區, 會以 2021-02-05T11:27:46+0000 來轉換為該時區時間顯示 # 調整 MySQL timezone 對 Laravel 輸出的影響 (datetime)sequenceDiagram participant Laravel participant MySQL NOTE OVER Laravel,MySQL: 時區為 Asia/Taipei Laravel-->>MySQL: 給你 2021-02-05 19:27:46 NOTE OVER Laravel,MySQL: 實存 2021-02-05 19:27:46 NOTE OVER Laravel,MySQL: 修改時區為 UTC MySQL->>Laravel: 給你 2021-02-05 19:27:46 NOTE OVER Laravel,MySQL: datetime 不受更換時區影響 # 調整 MySQL timezone 對 Laravel 輸出的影響 (timestamp)sequenceDiagram participant Laravel participant MySQL NOTE OVER Laravel,MySQL: 時區為 Asia/Taipei Laravel-->>MySQL: 給你 2021-02-05 19:27:46 NOTE OVER Laravel,MySQL: 實存 2021-02-05T11:27:46+0000 NOTE OVER Laravel,MySQL: 修改時區為 UTC MySQL->>Laravel: 給你 2021-02-05 11:27:46 NOTE OVER Laravel,MySQL: timestamp 會因為修改時區而回傳不一樣的 datetime string # Questions and AnswersIoC container, 具體 IoC 反轉了什麼？IoC 出現之前, 假設 A 對象需要 C 資源, 需要在 A 對象中主動獲取 C 資源IoC 出現之後, 由 container 獲取 C 資源, 注入 A 對象, 這樣的行為稱為反轉 IoC container, 某對象, 外部資源, 三者中, 誰控制誰？ 控制了什麼?container 控制某對象, 控制對象實例的創建 IoC container, 某對象, 外部資源, 三者中, 誰注入誰？container 注入外部資源到某對象 IoC container, 某對象, 外部資源, 三者中, 誰依賴誰？ 為什麼？某對象依賴於 container, 因為需要 container 提供外部資源 IoC container 中, 一般有哪三個參與者？(1) 某對象, 即任意一個 class(2) container, 即 IoC container(3) 外部資源, 即某對象需要的, 但從某對象外部獲取的資源 以下的 Laravel example code 的意思是？ Example:&lt;?phpcollect([1,2,3,4])-&gt;shift()// 1collect([1,2,3,4])-&gt;shift(3)// [1,2,3] Answer:shift 可帶入要 shift 的數量 以下的 Laravel example code 的意思是？ Example:&lt;?phpcollect([1,2,3,4])-&gt;pop(3)// [2,3,4] Answer:pop 可帶入要 pop 的數量 以下的 Laravel example code 的意思是？ Example:&lt;?php// Before[ &#x27;email&#x27;=&gt; [ Rule::unique(&#x27;users&#x27;)-&gt;whereNull(&#x27;deleted_at&#x27;), ],];// After[ &#x27;email&#x27;=&gt; [ Rule::unique(&#x27;users&#x27;)-&gt;ignoreTrashed(), ],]; Answer:使用 ignoreTrashed() 忽略 soft-deleted 資料 以下的 Laravel example code 的意思是？ Example:composer require laravel/octanephp artisan octane:install Answer:安裝 octane Laravel 中, cursor paginator 有什麼限制？(1) 跟 simple pagination 一樣, 只可顯示上一頁以及下一頁(2) 排序需基於 1 個或多個 unique key 以下的 Laravel example code 的意思是？ Example:&lt;?php$users = DB::table(&#x27;users&#x27;)-&gt;orderBy(&#x27;id&#x27;)-&gt;cursorPaginate(15); Answer:建立一個 cursorPaginator, 主要是使用 compare operator, 而不是 offset, 所以在效能上比較好 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function currentPricing()&#123; return $this-&gt;hasOne(Price::class)-&gt;ofMany([ &#x27;published_at&#x27; =&gt; &#x27;max&#x27;, &#x27;id&#x27; =&gt; &#x27;max&#x27;, ], function ($query) &#123; $query-&gt;where(&#x27;published_at&#x27;, &#x27;&lt;&#x27;, now()); &#125;);&#125; Answer:定義 one of many relationship, 從 hasMany relationshipo price model 中, 取得 published_at 以及 id 最新的那筆資料, 且 published_at 需 &lt; now() 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function largestOrder()&#123; return $this-&gt;hasOne(Order::class)-&gt;ofMany(&#x27;price&#x27;, &#x27;max&#x27;);&#125; Answer:定義 one of many relationship, 從 hasMany relationshipo price max 的那一筆資料 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function oldestOrder()&#123; return $this-&gt;hasOne(Order::class)-&gt;oldestOfMany();&#125; Answer:定義 one of many relationship, 從 hasMany relationshipo 中取得最舊的那一筆, 預設 id 排序 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function latestOrder()&#123; return $this-&gt;hasOne(Order::class)-&gt;latestOfMany();&#125; Answer:定義 one of many relationship, 從 hasMany relationshipo 中取得最新的那一筆, 預設 id 排序 Laravel 中, 為何不建議使用 MySQL 作為 queue driver?因為 MySQL 8 之前的版本可能會造成死鎖 以下的 Laravel example code 的意思是？ Example:&lt;?php$response-&gt;assertDownload();$response-&gt;assertDownload(&#x27;image.jpg&#x27;); Answer:斷言 response 有觸發下載動作 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Post extends Model&#123; use BroadcastsEvents, HasFactory; public function user() &#123; return $this-&gt;belongsTo(User::class); &#125; public function broadcastOn($event) &#123; return match($event) &#123; &#x27;deleted&#x27; =&gt; [], default =&gt; [$this, $this-&gt;user], &#125;; &#125;&#125; Answer:use BroadcastsEvents trait, 且定義 broadcastOn method, 這樣在每次 model event 被觸發時, 會自動 broadcast 給指定的 user 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Services\\Transistor;use App\\Services\\PodcastParser;$this-&gt;app-&gt;scoped(Transistor::class, function ($app) &#123; return new Transistor($app-&gt;make(PodcastParser::class));&#125;); Answer:與 singleton 類似, 差別在於, scoped() binded class 會在每次新的 Laravel life cycle flush, 像是 queue worker process a new job, Octane worker process a new request 以下的 Laravel example code 的意思是？ Example:&lt;?phpRequest::macro(&#x27;xml&#x27;, function () &#123; return CustomSuperDuperXmlParser::parse($this-&gt;body());&#125;);Http::fake([ &#x27;example.com/*&#x27; =&gt; function (Request $request) &#123; $this-&gt;assertSame($request-&gt;xml()-&gt;someProperty, &#x27;some value&#x27;) return Http::response(); &#125;,]); Answer:使用 Requset 的 macro 來建立 customized method 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Facades\\Storage;$disk = Storage::build([ &#x27;driver&#x27; =&gt; &#x27;local&#x27;, &#x27;root&#x27; =&gt; &#x27;/path/to/root&#x27;,]);$disk-&gt;put(&#x27;image.jpg&#x27;, $content); Answer:可以在 runtime 利用 configuration 建立一個沒有事先定義於 config 檔中的 storage 以下的 Laravel example code 的意思是？ Example:&lt;?php# Default 24 hoursphp artisan prune:failed# Specify hoursphp artisan prune:failed --hours=12 Answer:利用 artisan command 清除 failed job table 以下的 Laravel example code 的意思是？ Example:&lt;?phpphp artisan route:list --sort precedence Answer:使用 route resolved 的順序來排列 以下的 Laravel example code 的意思是？ Example:&lt;?php$response = new Response(&#x27;foo&#x27;);$response-&gt;setStatusCode(404);$response-&gt;statusText(); // i.e., Not Found Answer:可使用 statusText() 取得 status 的 text 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass AssignRequestId&#123; public function handle($request, Closure $next) &#123; $requestId = (string) Str::uuid(); Log::withContext([ &#x27;request-id&#x27; =&gt; $requestId ]); return $next($request)-&gt;header(&#x27;Request-Id&#x27;, $requestId); &#125;&#125; Answer:使用 Log::withContext method, 給該 request 中的每一個 log 都加上一個 request-id 作為識別 以下的 Laravel example code 的意思是？ Example:&lt;?phpIlluminate\\Database\\Connection::forgetRecordModificationState() Answer:可在 boot() 中使用, 當讀寫分離時, 讓 queue worker 可以忘掉之前的狀態, 以免在 sticky 的設定下, 重複的使用 write 連線 Laravel 中, cookie driver 會將 session 存在哪？存在瀏覽器的 cookie 中, 並且加密過 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Exceptions\\InternalException; protected function refundInstallmentItem(InstallmentItem $item) &#123; $refundNo = $this-&gt;order-&gt;refund_no.&#x27;_&#x27;.$item-&gt;sequence; switch ($item-&gt;payment_method) &#123; case &#x27;wechat&#x27;: app(&#x27;wechat_pay&#x27;)-&gt;refund([ &#x27;transaction_id&#x27; =&gt; $item-&gt;payment_no, &#x27;total_fee&#x27; =&gt; $item-&gt;total * 100, &#x27;refund_fee&#x27; =&gt; $item-&gt;base * 100, &#x27;out_refund_no&#x27; =&gt; $refundNo, &#x27;notify_url&#x27; =&gt; &#x27;&#x27; // todo, ]); $item-&gt;update([ &#x27;refund_status&#x27; =&gt; InstallmentItem::REFUND_STATUS_PROCESSING, ]); break; case &#x27;alipay&#x27;: $ret = app(&#x27;alipay&#x27;)-&gt;refund([ &#x27;trade_no&#x27; =&gt; $item-&gt;payment_no, &#x27;refund_amount&#x27; =&gt; $item-&gt;base, &#x27;out_request_no&#x27; =&gt; $refundNo, ]); if ($ret-&gt;sub_code) &#123; $item-&gt;update([ &#x27;refund_status&#x27; =&gt; InstallmentItem::REFUND_STATUS_FAILED, ]); &#125; else &#123; $item-&gt;update([ &#x27;refund_status&#x27; =&gt; InstallmentItem::REFUND_STATUS_SUCCESS, ]); &#125; break; default: throw new InternalException(&#x27;未知订单支付方式：&#x27;.$item-&gt;payment_method); break; &#125; &#125;&#125; Answer:&lt;?phpuse App\\Exceptions\\InternalException; protected function refundInstallmentItem(InstallmentItem $item) &#123; // 退款单号使用商品订单的退款号与当前还款计划的序号拼接而成 $refundNo = $this-&gt;order-&gt;refund_no.&#x27;_&#x27;.$item-&gt;sequence; // 根据还款计划的支付方式执行对应的退款逻辑 switch ($item-&gt;payment_method) &#123; case &#x27;wechat&#x27;: app(&#x27;wechat_pay&#x27;)-&gt;refund([ &#x27;transaction_id&#x27; =&gt; $item-&gt;payment_no, // 这里我们使用微信订单号来退款 &#x27;total_fee&#x27; =&gt; $item-&gt;total * 100, //原订单金额，单位分 &#x27;refund_fee&#x27; =&gt; $item-&gt;base * 100, // 要退款的订单金额，单位分，分期付款的退款只退本金 &#x27;out_refund_no&#x27; =&gt; $refundNo, // 退款订单号 // 微信支付的退款结果并不是实时返回的，而是通过退款回调来通知，因此这里需要配上退款回调接口地址 &#x27;notify_url&#x27; =&gt; &#x27;&#x27; // todo, ]); // 将还款计划退款状态改成退款中 $item-&gt;update([ &#x27;refund_status&#x27; =&gt; InstallmentItem::REFUND_STATUS_PROCESSING, ]); break; case &#x27;alipay&#x27;: $ret = app(&#x27;alipay&#x27;)-&gt;refund([ &#x27;trade_no&#x27; =&gt; $item-&gt;payment_no, // 使用支付宝交易号来退款 &#x27;refund_amount&#x27; =&gt; $item-&gt;base, // 退款金额，单位元，只退回本金 &#x27;out_request_no&#x27; =&gt; $refundNo, // 退款订单号 ]); // 根据支付宝的文档，如果返回值里有 sub_code 字段说明退款失败 if ($ret-&gt;sub_code) &#123; $item-&gt;update([ &#x27;refund_status&#x27; =&gt; InstallmentItem::REFUND_STATUS_FAILED, ]); &#125; else &#123; // 将订单的退款状态标记为退款成功并保存退款订单号 $item-&gt;update([ &#x27;refund_status&#x27; =&gt; InstallmentItem::REFUND_STATUS_SUCCESS, ]); &#125; break; default: // 原则上不可能出现，这个只是为了代码健壮性 throw new InternalException(&#x27;未知订单支付方式：&#x27;.$item-&gt;payment_method); break; &#125; &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Jobs;class RefundInstallmentOrder implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $order; public function __construct(Order $order) &#123; $this-&gt;order = $order; &#125; public function handle() &#123; if ($this-&gt;order-&gt;payment_method !== &#x27;installment&#x27; || !$this-&gt;order-&gt;paid_at || $this-&gt;order-&gt;refund_status !== Order::REFUND_STATUS_PROCESSING) &#123; return; &#125; if (!$installment = Installment::query()-&gt;where(&#x27;order_id&#x27;, $this-&gt;order-&gt;id)-&gt;first()) &#123; return; &#125; foreach ($installment-&gt;items as $item) &#123; if (!$item-&gt;paid_at || in_array($item-&gt;refund_status, [ InstallmentItem::REFUND_STATUS_SUCCESS, InstallmentItem::REFUND_STATUS_PROCESSING, ])) &#123; continue; &#125; try &#123; $this-&gt;refundInstallmentItem($item); &#125; catch (\\Exception $e) &#123; \\Log::warning(&#x27;分期退款失败：&#x27;.$e-&gt;getMessage(), [ &#x27;installment_item_id&#x27; =&gt; $item-&gt;id, ]); continue; &#125; &#125; $allSuccess = true; foreach ($installment-&gt;items as $item) &#123; if ($item-&gt;paid_at &amp;&amp; $item-&gt;refund_status !== InstallmentItem::REFUND_STATUS_SUCCESS) &#123; $allSuccess = false; break; &#125; &#125; if ($allSuccess) &#123; $this-&gt;order-&gt;update([ &#x27;refund_status&#x27; =&gt; Order::REFUND_STATUS_SUCCESS, ]); &#125; &#125; protected function refundInstallmentItem(InstallmentItem $item) &#123; // todo &#125;&#125; Answer:&lt;?phpnamespace App\\Jobs;class RefundInstallmentOrder implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $order; public function __construct(Order $order) &#123; $this-&gt;order = $order; &#125; public function handle() &#123; // 如果商品订单支付方式不是分期付款、订单未支付、订单退款状态不是退款中，则不执行后面的逻辑 if ($this-&gt;order-&gt;payment_method !== &#x27;installment&#x27; || !$this-&gt;order-&gt;paid_at || $this-&gt;order-&gt;refund_status !== Order::REFUND_STATUS_PROCESSING) &#123; return; &#125; // 找不到对应的分期付款，原则上不可能出现这种情况，这里的判断只是增加代码健壮性 if (!$installment = Installment::query()-&gt;where(&#x27;order_id&#x27;, $this-&gt;order-&gt;id)-&gt;first()) &#123; return; &#125; // 遍历对应分期付款的所有还款计划 foreach ($installment-&gt;items as $item) &#123; // 如果还款计划未支付，或者退款状态为退款成功或退款中，则跳过 if (!$item-&gt;paid_at || in_array($item-&gt;refund_status, [ InstallmentItem::REFUND_STATUS_SUCCESS, InstallmentItem::REFUND_STATUS_PROCESSING, ])) &#123; continue; &#125; // 调用具体的退款逻辑， try &#123; $this-&gt;refundInstallmentItem($item); &#125; catch (\\Exception $e) &#123; \\Log::warning(&#x27;分期退款失败：&#x27;.$e-&gt;getMessage(), [ &#x27;installment_item_id&#x27; =&gt; $item-&gt;id, ]); // 假如某个还款计划退款报错了，则暂时跳过，继续处理下一个还款计划的退款 continue; &#125; &#125; // 设定一个全部退款成功的标志位 $allSuccess = true; // 再次遍历所有还款计划 foreach ($installment-&gt;items as $item) &#123; // 如果该还款计划已经还款，但退款状态不是成功 if ($item-&gt;paid_at &amp;&amp; $item-&gt;refund_status !== InstallmentItem::REFUND_STATUS_SUCCESS) &#123; // 则将标志位记为 false $allSuccess = false; break; &#125; &#125; // 如果所有退款都成功，则将对应商品订单的退款状态修改为退款成功 if ($allSuccess) &#123; $this-&gt;order-&gt;update([ &#x27;refund_status&#x27; =&gt; Order::REFUND_STATUS_SUCCESS, ]); &#125; &#125; protected function refundInstallmentItem(InstallmentItem $item) &#123; // todo &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?php$mock = \\Mockery::mock(&#x27;CaptainsConsole&#x27;);$mock-&gt;shouldReceive(&#x27;foo-&gt;bar-&gt;zebra-&gt;alpha-&gt;selfDestruct&#x27;)-&gt;andReturn(&#x27;Ten!&#x27;); Answer:當一個 object 會呼叫多個 method chain 時, 可帶入整個 chain, 並定義 return value, mockery 會忽略中間所有被呼叫的 method 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Model&#123; public function test(&amp;$data) &#123; return $this-&gt;doTest($data); &#125; protected function doTest(&amp;$data) &#123; $data[&#x27;something&#x27;] = &#x27;wrong&#x27;; return $this; &#125;&#125;class Test extends \\PHPUnit\\Framework\\TestCase&#123; public function testModel() &#123; $mock = \\Mockery::mock(&#x27;Model[test]&#x27;)-&gt;shouldAllowMockingProtectedMethods(); $mock-&gt;shouldReceive(&#x27;test&#x27;) -&gt;with(\\Mockery::on(function(&amp;$data) &#123; $data[&#x27;something&#x27;] = &#x27;wrong&#x27;; return true; &#125;)); $data = array(&#x27;foo&#x27; =&gt; &#x27;bar&#x27;); $mock-&gt;test($data); $this-&gt;assertTrue(isset($data[&#x27;something&#x27;])); $this-&gt;assertEquals(&#x27;wrong&#x27;, $data[&#x27;something&#x27;]); &#125;&#125; Answer:通常比較少遇到這種案例, 帶入 reference parameter 到 protected method, 可 mock 上一層的 public method with shouldAllowMockingProtectedMethods(), 這個 public method 會被當作是 protected method 的 proxy 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Console\\Commands\\Cron;class CalculateInstallmentFine extends Command&#123; protected $signature = &#x27;cron:calculate-installment-fine&#x27;; protected $description = &#x27;计算分期付款逾期费&#x27;; public function handle() &#123; InstallmentItem::query() // 预加载分期付款数据，避免 N + 1 问题 -&gt;with([&#x27;installment&#x27;]) -&gt;whereHas(&#x27;installment&#x27;, function ($query) &#123; // 对应的分期状态为还款中 $query-&gt;where(&#x27;status&#x27;, Installment::STATUS_REPAYING); &#125;) // 还款截止日期在当前时间之前 -&gt;where(&#x27;due_date&#x27;, &#x27;&lt;=&#x27;, Carbon::now()) // 尚未还款 -&gt;whereNull(&#x27;paid_at&#x27;) // 使用 chunkById 避免一次性查询太多记录 -&gt;chunkById(1000, function ($items) &#123; // 遍历查询出来的还款计划 foreach ($items as $item) &#123; // 通过 Carbon 对象的 diffInDays 直接得到逾期天数 $overdueDays = Carbon::now()-&gt;diffInDays($item-&gt;due_date); // 本金与手续费之和 $base = big_number($item-&gt;base)-&gt;add($item-&gt;fee)-&gt;getValue(); // 计算逾期费 $fine = big_number($base) -&gt;multiply($overdueDays) -&gt;multiply($item-&gt;installment-&gt;fine_rate) -&gt;divide(100) -&gt;getValue(); // 避免逾期费高于本金与手续费之和，使用 compareTo 方法来判断 // 如果 $fine 大于 $base，则 compareTo 会返回 1，相等返回 0，小于返回 -1 $fine = big_number($fine)-&gt;compareTo($base) === 1 ? $base : $fine; $item-&gt;update([ &#x27;fine&#x27; =&gt; $fine, ]); &#125; &#125;); &#125;&#125; Answer:跑 cron 例行檢查逾期款項, 並算出逾期金額 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function testCanOverrideExpectedParametersOfInternalPHPClassesToPreserveRefs()&#123; \\Mockery::getConfiguration()-&gt;setInternalClassMethodParamMap( &#x27;MongoCollection&#x27;, &#x27;insert&#x27;, array(&#x27;&amp;$data&#x27;, &#x27;$options = array()&#x27;) ); $m = \\Mockery::mock(&#x27;MongoCollection&#x27;); $m-&gt;shouldReceive(&#x27;insert&#x27;)-&gt;with( \\Mockery::on(function(&amp;$data) &#123; if (!is_array($data)) return false; $data[&#x27;_id&#x27;] = 123; return true; &#125;), \\Mockery::any() ); $data = array(&#x27;a&#x27;=&gt;1,&#x27;b&#x27;=&gt;2); $m-&gt;insert($data); $this-&gt;assertTrue(isset($data[&#x27;_id&#x27;])); $this-&gt;assertEquals(123, $data[&#x27;_id&#x27;]); \\Mockery::resetContainer();&#125; Answer:一般來說, mockery 可以 mock call by reference, 但對 internal method 不起作用。 可以使用 setInternalClassMethodParamMap() 來 map class, method, 以及 args Laravel 當中, 以下的語法代表什麼意思？列出 $users query builder 的 query 語法以及帶入的變數 &lt;?phpdd($users-&gt;toSql(), $users-&gt;getBindings()); Laravel 當中, 以下代碼代表什麼意思？當 $user-&gt;address 可獲得時, 取值, 不可獲得時, 回傳 null &lt;?phpreturn optional($user-&gt;address)-&gt;street; 以下的 Laravel 程式碼代表什麼意思？&lt;?php $users = User::merchant() -&gt;with(&#x27;owner&#x27;) -&gt;when($q, function ($query, $q) &#123; return $query-&gt;where(&#x27;username&#x27;, &#x27;LIKE&#x27;, &#x27;%&#x27;.$q.&#x27;%&#x27;) -&gt;orWhere(&#x27;name&#x27;, &#x27;LIKE&#x27;, &#x27;%&#x27;.$q.&#x27;%&#x27;) -&gt;orWhere(&#x27;email&#x27;, &#x27;LIKE&#x27;, &#x27;%&#x27;.$q.&#x27;%&#x27;); &#125;); public function scopeMerchant(Builder $query) &#123; return $query-&gt;where(&#x27;role_id&#x27;, Role::MERCHANT); &#125; 取得 User model 的 merchant scope, eager load owner relation, 當 $q 不為 null, 執行 closure, 接上 closure 中的 query builder, 在 username, name, email 三個欄位中模糊搜尋 $q 以下的 Laravel 程式碼的 appends 邏輯是什麼? 在 Laravel 的分頁模式中, 若未將全部來自於前端的 query 帶入, 那分頁的 url 將會缺少必要的 query, 等於只有第一頁會有 帶入的 query 結果&lt;?phpreturn new UserCollection($users-&gt;paginate($row)-&gt;appends(request()-&gt;query-&gt;all())); 以下的 Laravel 程式碼中的 latest 代表什麼意思？ 以 id 排序&lt;?php$transactions = auth()-&gt;user()-&gt;transactions() -&gt;whereBetween(&#x27;created_at&#x27;, [$startedAt, $endedAt]) -&gt;latest(&#x27;id&#x27;) -&gt;with(&#x27;wallet&#x27;) -&gt;paginate() -&gt;appends($request-&gt;query-&gt;all()); 以下的 Laravel 程式碼中的 fill 代表什麼意思？ 將值注入 userBankCard model, 帶入參數可以是一個 array&lt;?php$userBankCard-&gt;fill( $request-&gt;only( &#x27;card_holder_name&#x27;, &#x27;card_number&#x27;, &#x27;bank_name&#x27; )); 以下的 Laravel 程式碼中, 為什麼要使用 collect function？ 這樣如果前端帶錯, 帶成 string 的話, 會先將 string 轉成 collection, 再轉成 array&lt;?php$userBankCards = UserBankCard::when(request()-&gt;q, function ($query, $q) &#123; $query-&gt;where(function ($query) use ($q) &#123; $query-&gt;where(&#x27;card_holder_name&#x27;, &#x27;LIKE&#x27;, &#x27;%&#x27; . $q . &#x27;%&#x27;) -&gt;orWhere(&#x27;card_number&#x27;, &#x27;LIKE&#x27;, &#x27;%&#x27; . $q . &#x27;%&#x27;) -&gt;orWhere(&#x27;bank_name&#x27;, &#x27;LIKE&#x27;, &quot;%$q%&quot;); &#125;);&#125;) -&gt;when(request()-&gt;status, function ($query, $status) &#123; $query-&gt;whereIn(&#x27;status&#x27;, collect($status)-&gt;toArray()); &#125;) -&gt;where(&#x27;user_id&#x27;, auth()-&gt;user()-&gt;getKey()) -&gt;paginate($row) -&gt;appends(request()-&gt;query-&gt;all()); 以下的 Laravel 程式碼代表什麼意思？&lt;?php$depositStats = Deposit::whereBetween(&#x27;created_at&#x27;, [$startDate, $endDate])-&gt;where(&#x27;status&#x27;, Deposit::STATUS_SUCCESS)-&gt;groupBy(&#x27;system_bank_card_type&#x27;)-&gt;get([ &#x27;system_bank_card_type&#x27;, DB::raw(&#x27;SUM(amount) AS total_amount, SUM(fee) AS total_fee, COUNT(id) AS total_count&#x27;)])-&gt;keyBy(&#x27;system_bank_card_type&#x27;); 取得 Deposit model, 以帶入日期過濾, 以 SUCCESS status 過濾, 以 system_bank_card_type 分類, 在取得四個值, 分別是 system_bank_card_type, total_amount, total_fee, total_count, 若照預設, 會是一個 collection 裡面有兩個 model, index 為 0 跟 1, 使用 keyBy 來將 0 跟 1 依照 system_bank_card_type 做區分, 所以會變成一個 collection 裡頭有兩個 model, 以 system_bank_card_type 做區分 以下的 Laravel 程式碼為什麼要使用 first？ 因為該 query 撈出來後, 只會有一筆 model, 如果是用 get 的話, 會是一個 collection 裡有一個 model, 所以直接使用 first() 即可&lt;?php$withdrawStat = Withdraw::whereBetween(&#x27;created_at&#x27;, [$startDate, $endDate]) -&gt;where(&#x27;status&#x27;, Withdraw::STATUS_SUCCESS) -&gt;first([ DB::raw(&#x27;SUM(amount) AS total_amount, SUM(fee) AS total_fee, COUNT(id) AS total_count&#x27;)]); 以下的 Laravel 程式碼中, keyBy 的用途是？如果不使用 keyBy 的話, 正常來說一個 collection 裡頭有多個 model 會以默認 index, 0, 1, 2 …, keyBy 可以使用指定的 key 來給 model 分組, 在這個例子中, 就是以 model 下的 slug 欄位的值做分組 &lt;?php$wallets = auth()-&gt;user()-&gt;wallets()-&gt;get()-&gt;keyBy(&#x27;slug&#x27;); 以下的 Laravel 程式碼中, data_get 的用途是？$depositStats 結構像是這樣 $depositStats = [&#39;BankCard::TYPE_FEE&#39; =&gt; [&#39;total_count&#39;, &#39;total_amount&#39;, &#39;total_count&#39;, &#39;total_amount&#39;]], data_get 可以取得一個 collection 裡頭的巢狀 array 值 &lt;?phpreturn response()-&gt;json([ &#x27;data&#x27; =&gt; [ &#x27;fee_wallet_deposit_success_count&#x27; =&gt; data_get($depositStats, [BankCard::TYPE_FEE, &#x27;total_count&#x27;], 0), &#x27;fee_wallet_deposit_success_amount&#x27; =&gt; data_get($depositStats, [BankCard::TYPE_FEE, &#x27;total_amount&#x27;], 0) / 100, // todo remove hard code &#x27;withdraw_wallet_deposit_success_count&#x27; =&gt; data_get($depositStats, [BankCard::TYPE_WITHDRAW, &#x27;total_count&#x27;], 0), &#x27;withdraw_wallet_deposit_success_amount&#x27; =&gt; data_get($depositStats, [BankCard::TYPE_WITHDRAW, &#x27;total_amount&#x27;], 0) / 100, // todo remove hard code &#x27;withdraw_success_count&#x27; =&gt; $withdrawStat-&gt;total_count ?? 0, &#x27;withdraw_success_amount&#x27; =&gt; ($withdrawStat-&gt;total_amount ?? 0) / 100, // todo remove hard code &#x27;fee_wallet_balance&#x27; =&gt; data_get($wallets, [User::SLUG_FEE_WALLET, &#x27;balanceFloat&#x27;], 0), &#x27;withdraw_wallet_balance&#x27; =&gt; data_get($wallets, [User::SLUG_WITHDRAW_WALLET, &#x27;balanceFloat&#x27;], 0), ],]); 以下的 Laravel 程式碼代表什麼意思？定義一個 unique rule, 並且將範圍限定在特定的 user 上, 代表不同 user 之間的訂單不需要 unique &lt;?php$orderNumberUniqueRule = Rule::unique($withdrawTable, &#x27;order_number&#x27;)-&gt;where(function ($query) use ($user) &#123; $query-&gt;where(&#x27;user_id&#x27;, $user-&gt;getKey());&#125;); 以下的 Laravel function 的作用是什麼？ 將 request 裡的參數除了 sign 之外都調出來 排列這些 key 首先使用 http_build_query function 針對剛剛的參數來產生一組 url 加密的字串, 然後將這字串與 user 的 secret_key 欄位內的值相串, 然後使用 url 解密這一整個字串, 最後再使用 md5 處理取得 hash 值, 我們比對這個值跟帶進來的 sign 有沒有一樣, 如果不一樣就是不合法 唯有知道 secret_key 的雙方可以對內容加解密, 而經由這樣的加解密驗證, 確保 request 的內容再傳送過程中未被串改&lt;?phpprivate function signValid(Request $request, $secretKey)&#123; $allParametersExceptSign = $request-&gt;except(&#x27;sign&#x27;); ksort($allParametersExceptSign); return strcasecmp( md5(urldecode(http_build_query($allParametersExceptSign)) . $secretKey), $request-&gt;sign ) === 0;&#125; 以下的 Laravel function 的作用是什麼？ 宣告 lock-key 以及持有時間 嘗試取得 lock-key, 如果不可得, 持續嘗試五秒 用 transaction 實作, 若有任何錯誤皆返回 如果無法取得 lock-key, 返回錯誤 回返錯誤訊息 如果 lock-key 還被持有中, 釋放 lock-key&lt;?phppublic function lock(User $user, $action)&#123; $lock = Cache::lock($user-&gt;lockKey(), 10); try &#123; $lock-&gt;block(5); return DB::transaction($action); &#125; catch (LockTimeoutException $e) &#123; abort(Response::HTTP_CONFLICT, &#x27;请稍候再试&#x27;); &#125; finally &#123; optional($lock)-&gt;release(); &#125;&#125; 以下的 Laravel 程式碼中, balance 是扣款前還是扣款後？扣款前, 因為 $transaction 還沒被執行完畢 &lt;?php$transaction = $user-&gt;withdrawFloat($request-&gt;input(&#x27;amount&#x27;), [ &#x27;before_balance&#x27; =&gt; $user-&gt;balance,]); 以下的 Laravel 程式碼是什麼意思呢？將資料存入 mysql 中的 json 欄位 &lt;?php$deposit-&gt;user_bank_meta = (object)[ &#x27;subbranch&#x27; =&gt; $userBankCard-&gt;subbranch, &#x27;province&#x27; =&gt; $userBankCard-&gt;province, &#x27;city&#x27; =&gt; $userBankCard-&gt;city,]; 下面的 Laravel 程式碼是什麼意思？將檔案存在 $deposit-&gt;getTable(), 檔名為 $deposit-&gt;system_order_number, 使用 filesystem.cloud, 可設為 s3 &lt;?php$request-&gt;file(&#x27;payment_instrument&#x27;) -&gt;storeAs($deposit-&gt;getTable(), $deposit-&gt;system_order_number, config(&#x27;filesystems.cloud&#x27;)); 下面的 Laravel Requests 代表什麼意思？使用 captcha 的 extension captcha_api 來驗證, 因為該驗證器一定需要一個 key, 如果在 validation 期間 key 為 null, 那直接就回 500 了, 所以這邊處理, 當沒有 captcha_key 時, 給一個隨機 10 碼, 這樣會驗不過(key 沒帶原本就應該驗不過), 但是不會 500 &lt;?phppublic function rules()&#123; return [ &#x27;username&#x27; =&gt; &#x27;required_without:email|string&#x27;, &#x27;email&#x27; =&gt; &#x27;required_without:username|email&#x27;, &#x27;password&#x27; =&gt; &#x27;required|string&#x27;, &#x27;captcha_key&#x27; =&gt; &#x27;required&#x27;, &#x27;captcha&#x27; =&gt; &#x27;required|captcha_api:&#x27;.($this-&gt;request-&gt;get(&#x27;captcha_key&#x27;) ?? Str::random(10)), ];&#125; 以下的 Laravel 程式碼中, where 內為什麼只有一個參數？Laravel 中, 如果 request 中的 parameter 與資料庫中的欄位名稱相同, 就可以直接用這種方式 query &lt;?php $bankCard = BankCard::where($request-&gt;only(&#x27;card_number&#x27;)) -&gt;withTrashed() -&gt;first() ?? BankCard::create($data); 以下的 Laravel 程式碼是什麼意思？1. query 出 card_number 的 model2. withTrashed 代表強制顯示已被 soft deleted 的 model3. 取出第一筆4. 若無結果, 則根據輸入的資料建立一張卡5. 更新 bankCard6. 若 bankCard 為 soft deleted, 解除它 &lt;?php$bankCard = BankCard::where($request-&gt;only(&#x27;card_number&#x27;))-&gt;withTrashed()-&gt;first() ?? BankCard::create($data);$bankCard-&gt;update($data);$bankCard-&gt;restore(); 在 Laravel 中, 如何從一個 collection 當中取得其中一個 model, 而該 model 中的 price 欄位的值是在這個 collection 的所有 model 之中最小或最大的？&lt;?php$min = $data-&gt;where(&#x27;price&#x27;, $data-&gt;min(&#x27;price&#x27;))-&gt;first(); // [&#x27;name&#x27; =&gt; &#x27;test&#x27;, &#x27;price&#x27; =&gt; 10]$max = $data-&gt;where(&#x27;price&#x27;, $data-&gt;max(&#x27;price&#x27;))-&gt;first(); // [&#x27;name&#x27; =&gt; &#x27;test&#x27;, &#x27;price&#x27; =&gt; 600] 以下的 Laravel example code 的意思是？ Example:&lt;?phpcollection-&gt;push($model) Answer:將 $model push 到該 collection 中 以下的 Laravel 程式碼代表什麼意思?1. 帶入欄位的名稱需與資料庫的欄位一樣2. 依序檢查指定的欄位3. 若 request 中的該欄位是有值的, 並且該值與目前資料庫中的值是不同的, 這代表有變更產生4. 將變更的 key 跟 value 放入空的 collection $updateAttributes 中5. 如果這個 collection 含有 card_number, 這代表卡號變更了, 將 balance =&gt; 0 放入 updateAttributes6. 如果 updateAttributes 是存在的, 開始更新 &lt;?php$updatedAttributes = collect();foreach ([&#x27;card_holder_name&#x27;, &#x27;card_number&#x27;, &#x27;bank_name&#x27;, &#x27;type&#x27;, &#x27;auto_withdraw&#x27;] as $attribute) &#123; if (!is_null($request-&gt;$attribute) &amp;&amp; ($request-&gt;$attribute != $bankCard-&gt;$attribute)) &#123; $updatedAttributes = $updatedAttributes-&gt;merge([$attribute =&gt; $request-&gt;$attribute]); &#125;&#125;if ($updatedAttributes-&gt;has(&#x27;card_number&#x27;)) &#123; $updatedAttributes = $updatedAttributes-&gt;merge([&#x27;balance&#x27; =&gt; 0]);&#125;if ($updatedAttributes-&gt;isNotEmpty()) &#123;$bankCard-&gt;update($updatedAttributes-&gt;toArray());&#125; Laravel 中, Model 的命名通常是單數還是複數?單數 Laravel 中的變數命名習慣是？camel case Laravel 中, 如何將 namespace, prefix, middleware 同時作用到複數的 route 上？&lt;?phpRoute::group([ &#x27;namespace&#x27; =&gt; &#x27;Worker&#x27;, &#x27;prefix&#x27; =&gt; &#x27;worker&#x27;, &#x27;middleware&#x27; =&gt; &#x27;check.worker.token&#x27;,], function () &#123; Route::apiResource(&#x27;working-tasks&#x27;, &#x27;WorkingTaskController&#x27;)-&gt;only(&#x27;store&#x27;, &#x27;update&#x27;); Route::apiResource(&#x27;bank-cards&#x27;, &#x27;BankCardController&#x27;)-&gt;only(&#x27;update&#x27;); Route::post(&#x27;captcha-cracks&#x27;, &#x27;CrackCaptchaController&#x27;);&#125;); Laravel 中, 可否在 route 的 group 內再使用一個 group?可以的 Laravel 中, 巢狀內的 route group 的屬性會不會繼承外層的 group 的屬性？會的, 像是 &lt;?phpRoute::group([ &#x27;middleware&#x27; =&gt; [&#x27;auth&#x27;]], function () &#123; Route::get(&#x27;me&#x27;, &#x27;AuthController@me&#x27;); Route::group([ &#x27;namespace&#x27; =&gt; &#x27;Admin&#x27;, &#x27;prefix&#x27; =&gt; &#x27;admin&#x27;, &#x27;middleware&#x27; =&gt; [&#x27;check.role.admin&#x27;, &#x27;check.source.admin&#x27;], ], function () &#123; Route::post(&#x27;users/&#123;user&#125;/reset-password&#x27;, &#x27;UsersController@resetPassword&#x27;); Route::post(&#x27;users/&#123;user&#125;/reset-withdraw-password&#x27;, &#x27;UsersController@resetWithdrawPassword&#x27;); Route::post(&#x27;users/&#123;user&#125;/reset-google2fa-secret&#x27;, &#x27;UsersController@resetGoogle2faSecret&#x27;); Route::post(&#x27;users/&#123;user&#125;/reset-secret-key&#x27;, &#x27;UsersController@resetSecretKey&#x27;); Route::put(&#x27;users/&#123;user&#125;/delete-group&#x27;, &#x27;UsersController@deleteGroup&#x27;) -&gt;where([&#x27;user&#x27; =&gt; &#x27;[0-9]+&#x27;]); &#125;);&#125;); 以下的 Laravel 程式碼中, 邏輯是怎麼樣的？如果環境是在 production 的話, 檢查來源 ip, 來源 ip 可能有很多個, 取最後一個代表 client, 若不存在則拒絕存取 &lt;?php public function handle($request, Closure $next) &#123; if (app()-&gt;environment([&#x27;production&#x27;])) &#123; abort_if(!IPs::where(&#x27;address&#x27;, Arr::last($request-&gt;ips()))-&gt;exists(), Response::HTTP_UNAUTHORIZED, &#x27;Invalid source&#x27;); &#125; return $next($request); &#125; 以下的兩段 Laravel 在 Resource 中的程式碼, 有什麼差異？ &lt;?php&#x27;withdraws&#x27; =&gt; $this-&gt;whenLoaded(&#x27;withdraws&#x27;, Withdraw::collection($this-&gt;withdraws)) &lt;?php&#x27;withdraws&#x27; =&gt; $this-&gt;whenLoaded(&#x27;withdraws&#x27;, function () &#123;return Withdraw::collection($this-&gt;withdraws);&#125;) 第一個 block 中, PHP 會先去執行作為參數帶入的 $this-&gt;withdraws, 再將結果帶入 whenLoaded, 這便符合了 whenLoaded 的 relation 載入條件, 所以依然會將當前 resource 下的 relation 顯示出來, 實際運行上因為會先執行 $this-&gt;withdraws, 因此也會造成效能上的浪費 第二個 block 中, closure 在被呼叫之前, PHP 並不會去解析它, 所以會先執行 whenLoaded 函式, 如果條件吻合, 才會執行 closure, 所以不會去執行 $this-&gt;withdraws, 自然 whenLoaded 的條件就不會吻合, resource 中也就不會多撈一層 Laravel 中, 如何將 array 存到資料庫？ 資料庫類別為 json&lt;?phpSchema::table(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;json(&#x27;iAmarray&#x27;)-&gt;nullable();&#125;); 存到資料庫前, 先使用 json_encode&lt;?phpdata = json_encode($iAmArray); 在 model 加入&lt;?phpprotected $casts = [ &#x27;iAmArray&#x27; =&gt; &#x27;array&#x27;]; 當我在 Route 當中使用 apiResource 如下, 自動帶入 controller 的 model binding 的變數名稱為？sub_account &lt;?phpRoute::apiResource(&#x27;sub-accounts&#x27;, &#x27;SubAccountsController&#x27;)-&gt;only([&#x27;store&#x27;, &#x27;update&#x27;]); Laravel 中, 當我使用 scheduler, 腳本內的 user 務必要使用?與 webserver 同一個 user 以下的 Laravel 程式碼的邏輯是？ 程式碼:&lt;?php $canSeeSecretKey = optional(auth()-&gt;user())-&gt;isAdmin() || $this-&gt;is(auth()-&gt;user()); Answer: 如果 auth()-&gt;user() 的身份是 admin 的話 如果被帶入 resource 中的 model 的身份跟 auth()-&gt;user() 是同一個人的話(代表本人) 以下的 Laravel 程式碼的作用是? code:&lt;?php public static function depositTypeText() &#123; return collect((new ReflectionClass(__CLASS__))-&gt;getConstants()) -&gt;filter( function ($value, $key) &#123; return Str::startsWith($key, &#x27;TYPE_DEPOSIT&#x27;); &#125; ) -&gt;mapWithKeys( function ($value, $key) &#123; return [$value =&gt; $key]; &#125; ); &#125; Answer: RefectionClass: 取得指定 class 中的資料 __class__: 代表當前 class getConstants: 取得 constants filter: 只取符合條件的 key mapWithKeys: 取得符合條件的 key/value pair 以下的 Laravel 程式碼的邏輯是? Example:&lt;?php if ($endedAt-&gt;diffInDays($startedAt) &gt; 31) &#123; $request-&gt;merge( [ &#x27;ended_at&#x27; =&gt; (clone $startedAt)-&gt;addDays(31)-&gt;format(&#x27;Y-m-d H:i:s&#x27;), ] ); &#125; Answer:如果 $endedAt 跟 $startedAt 相差大於 31 天, 那就把範圍定在最多相差 31 天 2.7 GHz 的 processor, 每秒可以跑多少 cycle?2,700,000,000 Laravel 中, 何謂 I/O bound code?Waits for DB queries, HTTP requests, etc… Laravel 中, 何謂 CPU bound code?Do a lot of calculation Laravel 中, 如何增加 php-fpm worker 的數量？update pm.max_children inside the /etc/php/&#123;version&#125;/fpm/pool.d/www.conf file Laravel 中, 為何不建議以下的 example 語法？ Example:&lt;?php$posts = POST::whereDate(&#x27;created_at&#x27;, &#x27;&gt;=&#x27;, now() )-&gt;get(); Answer:會使用到 MYSQL function, 變成 full table scan Laravel 中, 何時該使用 chunkById()?只要 id 是 auto increment primary key, 都使用 chunkById() Laravel 中, chunkById() 與 chunk() 的差異是？ chunk:select * from posts offset 0 limit 100select * from posts offset 101 limit 100 chunkById:select * from posts order by id asc limit 100select * from posts where id &gt; 100 order by id asc limit 100 Laravel 中, 何時使用 cursor(), 何時使用 chunkById()?當 DB memory 比較充裕時, 使用 cursor(), 當 APP memory 比較充裕時, 使用 chunkById() 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function getIsYearFeeLateAttribute(): bool&#123; return $this-&gt;memberDetail-&gt;&#123;__FUNCTION__&#125;();&#125; Answer:從 relational model 執行此 function name, 所以在別處也可以用這個寫在 relational model 的 method, 不需要重寫 以下的 Laravel example picture 的意思是？ Example: Answer:當 client 端傳來的時間是沒有時區的, Laravel 會默認該時間的時區為 Laravel 的 default timezone, 不多做處理直接存到資料庫 以下的 Laravel example picture 的意思是？ Example: Answer:當 client 端傳來的時間有時區的, Laravel 會將傳來的時間轉換為 default timezone 的時區, 再存到資料庫 以下的 Laravel example picture 的意思是？ Example: Answer:當 Laravel 從資料庫取得時間後, 會將該時間的時區默認為 Laravel default timezone, 並轉成 ISO8601 格式給 client 以下的 Laravel example picture 的意思是？ Example: Answer:當 MySQL 的 column type 為 datetime 時, 收到什麼就存什麼, 不另外轉換 以下的 Laravel example picture 的意思是？ Example: Answer:當 MySQL 的 column type 為 timestamp 時, 會將收到的時間的時區設為當下 MySQL default timezone, 並轉為 UTC timezone 儲存下來, 當使用 select 時, MySQL 會將實際上存為 UTC 的時間轉換為當下 MySQL timezone 的時間 以下的 Laravel example picture 的意思是？ Example: Answer:當 MySQL 時區為 datetime 時, 不管怎麼調整 MySQL 的時區, 都不會影響回傳的結果 以下的 Laravel example picture 的意思是？ Example: Answer:當 MySQL 時區為 timestamp 時, 如果去修改 MySQL timezone, 會先將實際儲存的 UTC timezone 時間轉換為該 timezone 的時間, 再回傳 以下的 Laravel example code 的意思是？ Example:&lt;?php$branchManagers = BranchManager::query() -&gt;select([&#x27;branch_managers.account&#x27;, &#x27;branch_managers.created_at&#x27;, &#x27;shops.name&#x27;, &#x27;branch_managers.status_id&#x27;]) -&gt;join(&#x27;shops&#x27;, &#x27;branch_managers.shop_id&#x27;, &#x27;=&#x27;, &#x27;shops.id&#x27;) -&gt;when($search, function ($query) use ($search) &#123; $query-&gt;whereIn(&#x27;branch_managers.id&#x27;, function ($query) use ($search) &#123; $query-&gt;select(&#x27;id&#x27;) -&gt;from(function ($query) use ($search) &#123; $query-&gt;select(&#x27;id&#x27;) -&gt;from(&#x27;branch_managers&#x27;) -&gt;whereRaw(&#x27;match(account) against (? in boolean mode)&#x27;, [$search]) -&gt;union( $query-&gt;newQuery() -&gt;select(&#x27;branch_managers.id&#x27;) -&gt;from(&#x27;branch_managers&#x27;) -&gt;join(&#x27;shops&#x27;, &#x27;branch_managers.shop_id&#x27;, &#x27;=&#x27;, &#x27;shops.id&#x27;) -&gt;whereRaw(&#x27;match(name) against (? in boolean mode)&#x27;, [$search]) ); &#125;, &#x27;matches&#x27;); &#125;); &#125;)-&gt;get(); Answer:無法直接使用 orWhereRaw (match(…) …) 這樣子的 full text search 在多個表格, 因此統一取得 id, 在使用 where in 取得最後需要的資料使用 union 來取得兩個 select query 取得的不重複 id使用 derived table, 避免 where in 與 union query 之間的 dependency 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass OrderRequest extends Request&#123; public function rules() &#123; return [ &#x27;address_id&#x27; =&gt; [ &#x27;required&#x27;, Rule::exists(&#x27;user_addresses&#x27;, &#x27;id&#x27;)-&gt;where(&#x27;user_id&#x27;, $this-&gt;user()-&gt;id), ], &#x27;items.*.sku_id&#x27; =&gt; [ &#x27;required&#x27;, function ($attribute, $value, $fail) &#123; if (!$sku = ProductSku::find($value)) &#123; return $fail(&#x27;该商品不存在&#x27;); &#125; if (!$sku-&gt;product-&gt;on_sale) &#123; return $fail(&#x27;该商品未上架&#x27;); &#125; if ($sku-&gt;stock === 0) &#123; return $fail(&#x27;该商品已售完&#x27;); &#125; preg_match(&#x27;/items\\.(\\d+)\\.sku_id/&#x27;, $attribute, $m); $index = $m[1]; $amount = $this-&gt;input(&#x27;items&#x27;)[$index][&#x27;amount&#x27;]; if ($amount &gt; 0 &amp;&amp; $amount &gt; $sku-&gt;stock) &#123; return $fail(&#x27;该商品库存不足&#x27;); &#125; &#125;, ], &#x27;items.*.amount&#x27; =&gt; [&#x27;required&#x27;, &#x27;integer&#x27;, &#x27;min:1&#x27;], ]; &#125;&#125; Answer:檢查該 address 是否屬於該 user從 items 中使用正則找到該 sku_id, 並檢查庫存是否足夠 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;class Order extends Model&#123; use HasFactory; protected static function boot() &#123; parent::boot(); // 监听模型创建事件，在写入数据库之前触发 static::creating(function ($model) &#123; // 如果模型的 no 字段为空 if (!$model-&gt;no) &#123; // 调用 findAvailableNo 生成订单流水号 $model-&gt;no = static::findAvailableNo(); // 如果生成失败，则终止创建订单 if (!$model-&gt;no) &#123; return false; &#125; &#125; &#125;); &#125; public static function findAvailableNo() &#123; // 订单流水号前缀 $prefix = date(&#x27;YmdHis&#x27;); for ($i = 0; $i &lt; 10; $i++) &#123; // 随机生成 6 位的数字 $no = $prefix.str_pad(random_int(0, 999999), 6, &#x27;0&#x27;, STR_PAD_LEFT); // 判断是否已经存在 if (!static::query()-&gt;where(&#x27;no&#x27;, $no)-&gt;exists()) &#123; return $no; &#125; &#125; \\Log::warning(&#x27;find order no failed&#x27;); return false; &#125;&#125; Answer:在 order model 建立時, 觸發 creating event, 建立訂單流水號 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Requests;use App\\Models\\ProductSku;class AddCartRequest extends Request&#123; public function rules() &#123; return [ &#x27;sku_id&#x27; =&gt; [ &#x27;required&#x27;, function ($attribute, $value, $fail) &#123; if (!$sku = ProductSku::find($value)) &#123; return $fail(&#x27;该商品不存在&#x27;); &#125; if (!$sku-&gt;product-&gt;on_sale) &#123; return $fail(&#x27;该商品未上架&#x27;); &#125; if ($sku-&gt;stock === 0) &#123; return $fail(&#x27;该商品已售完&#x27;); &#125; if ($this-&gt;input(&#x27;amount&#x27;) &gt; 0 &amp;&amp; $sku-&gt;stock &lt; $this-&gt;input(&#x27;amount&#x27;)) &#123; return $fail(&#x27;该商品库存不足&#x27;); &#125; &#125;, ], &#x27;amount&#x27; =&gt; [&#x27;required&#x27;, &#x27;integer&#x27;, &#x27;min:1&#x27;], ]; &#125;&#125; Answer:使用 closure 驗證商品是否存在, 是否上架, 是否售完, 以及是否有數量但實際庫存不足 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace Database\\Factories;use App\\Models\\UserAddress;use Illuminate\\Database\\Eloquent\\Factories\\Factory;class UserAddressFactory extends Factory&#123; protected $model = UserAddress::class; public function definition() &#123; $addresses = [ [&quot;北京市&quot;, &quot;市辖区&quot;, &quot;东城区&quot;], [&quot;河北省&quot;, &quot;石家庄市&quot;, &quot;长安区&quot;], [&quot;江苏省&quot;, &quot;南京市&quot;, &quot;浦口区&quot;], [&quot;江苏省&quot;, &quot;苏州市&quot;, &quot;相城区&quot;], [&quot;广东省&quot;, &quot;深圳市&quot;, &quot;福田区&quot;], ]; $address = $this-&gt;faker-&gt;randomElement($addresses); return [ &#x27;province&#x27; =&gt; $address[0], &#x27;city&#x27; =&gt; $address[1], &#x27;district&#x27; =&gt; $address[2], &#x27;address&#x27; =&gt; sprintf(&#x27;第%d街道第%d号&#x27;, $this-&gt;faker-&gt;randomNumber(2), $this-&gt;faker-&gt;randomNumber(3)), &#x27;zip&#x27; =&gt; $this-&gt;faker-&gt;postcode, &#x27;contact_name&#x27; =&gt; $this-&gt;faker-&gt;name, &#x27;contact_phone&#x27; =&gt; $this-&gt;faker-&gt;phoneNumber, ]; &#125;&#125; Answer:利用 factory 產生住址 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function getSpecifiedConstants($className, $needle)&#123; return collect((new \\ReflectionClass($className))-&gt;getConstants()) -&gt;filter(function ($value, $key) use ($needle) &#123; return Str::startsWith($key, $needle); &#125;);&#125; Answer:使用 ReflectionClass(), 從指定的 class 中取得定義於該 class 中的 constants, 在使用特定的條件篩選 以下的 Laravel example code, 有何差異？ Example:&lt;?php$rows = [$row1, $row2, $row3]DB::table(&#x27;voucher_statements&#x27;)-&gt;insert($rows);Voucher::insert($row1); Answer:前者可支援多筆, 但不會 insert created_at 跟 updated_at, 後者只能一次一筆, 但會 insert created_at, updated_at 以下的 Laravel example code 會使用幾筆 SQL query？ Example:&lt;?php$rows = [$row1, $row2, $row3]DB::table(&#x27;voucher_statements&#x27;)-&gt;insert($rows); Answer:一筆 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $customers = Customer::inRandomOrder()-&gt;take(1)-&gt;get(); $regions = Region::hasCustomer($customers-&gt;first())-&gt;get(); return view(&#x27;customers&#x27;, [ &#x27;customers&#x27; =&gt; $customers, &#x27;regions&#x27; =&gt; $regions, ]);&#125;public function scopeHasCustomer($query, Customer $customer)&#123; $query-&gt;whereRaw(&#x27;ST_Contains(regions.geometry, ?)&#x27;, [$customer-&gt;location]);&#125; Answer:&lt;?phppublic function index()&#123; // 取得 random user $customers = Customer::inRandomOrder()-&gt;take(1)-&gt;get(); // 取得該 customer 所在的 region $regions = Region::hasCustomer($customers-&gt;first())-&gt;get(); return view(&#x27;customers&#x27;, [ &#x27;customers&#x27; =&gt; $customers, &#x27;regions&#x27; =&gt; $regions, ]);&#125;public function scopeHasCustomer($query, Customer $customer)&#123; // 使用 ST_Contains function, arg1 為 regions table 的 geometry column, arg2 為帶入的 customer location, 以取得該 customer 所在的 region $query-&gt;whereRaw(&#x27;ST_Contains(regions.geometry, ?)&#x27;, [$customer-&gt;location]);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $regions = Region::all(); $customers = Customer::query() -&gt;inRegion(Region::where(&#x27;name&#x27;, &#x27;The Prairies&#x27;)-&gt;first()) -&gt;get(); return view(&#x27;customers&#x27;, [ &#x27;customers&#x27; =&gt; $customers, &#x27;regions&#x27; =&gt; $regions, ]);&#125;public function scopeInRegion($query, Region $region)&#123; $query-&gt;whereRaw(&#x27;ST_Contains(?, customers.location)&#x27;, [$region-&gt;geometry]);&#125; Answer:&lt;?phppublic function index()&#123; $regions = Region::all(); // 目標在於 select 出, 位於 &#x27;The Prairies&#x27; 這個 region 的 user $customers = Customer::query() -&gt;inRegion(Region::where(&#x27;name&#x27;, &#x27;The Prairies&#x27;)-&gt;first()) -&gt;get(); return view(&#x27;customers&#x27;, [ &#x27;customers&#x27; =&gt; $customers, &#x27;regions&#x27; =&gt; $regions, ]);&#125;public function scopeInRegion($query, Region $region)&#123; // 使用 ST_Contains, arg1 為 geometry format, arg2 為 user location, 所以會 select 出 location 位於此 geometry 的 users $query-&gt;whereRaw(&#x27;ST_Contains(?, customers.location)&#x27;, [$region-&gt;geometry]);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpprotected function seedRegions()&#123; $this-&gt;getRegions()-&gt;each(fn ($region) =&gt; Region::create([ &#x27;name&#x27; =&gt; $region[&#x27;name&#x27;], &#x27;color&#x27; =&gt; $region[&#x27;color&#x27;], &#x27;geometry&#x27; =&gt; (function () use ($region) &#123; return DB::raw(&quot;ST_SRID(ST_GeomFromText(&#x27;&quot;.$region[&#x27;geometry&#x27;].&quot;&#x27;), 4326)&quot;); &#125;)(), ]));&#125; Answer:取得 Regions 後, 在 Region table 建立資料, geometry column, 使用 ST_SRID 來設定 spatial reference ID, 4326 表示 world, 使用 ST_GeomFrom Text function, 從 text 建立 geometry data, geometry 格式如下：&#x27;geometry&#x27; =&gt; &#x27;MultiPolygon (((-136.21070809681475566 57.03101434136195991, -133.72877891703720366 54.61201637520210284, -133.47202762257742847 53.45604439614419334, -131.01862636440651499 51.6878513109907729, -126.28299137770447658 48.97546429328855311, -125.05629074861900563 48.48622934024960074, -123.37102414358200519 48.11059520996249717, -122.52069777133300477 48.99007009784259736, -113.96448759224449532 48.98897113447335272, -114.59407626641420563 50.4166998690063437, -119.86365984910806048 53.47639943303917676, -119.94099441499190561 59.97238022147455894, -140.92938615814153991 60.06202748779399059, -140.74999819452486349 59.61135341849296054, -138.11897472814712273 58.90840120048653006, -136.21070809681475566 57.03101434136195991)))&#x27;, 以下的 Laravel example code 中, Multipolygon 的意思是？ Example:public function getRegions()&#123; return collect([ [ &#x27;name&#x27; =&gt; &#x27;British Columbia&#x27;, &#x27;color&#x27; =&gt; &#x27;#F56565&#x27;, &#x27;geometry&#x27; =&gt; &#x27;MultiPolygon (((-136.21070809681475566 57.03101434136195991, -133.72877891703720366 54.61201637520210284, -133.47202762257742847 53.45604439614419334, -131.01862636440651499 51.6878513109907729, -126.28299137770447658 48.97546429328855311, -125.05629074861900563 48.48622934024960074, -123.37102414358200519 48.11059520996249717, -122.52069777133300477 48.99007009784259736, -113.96448759224449532 48.98897113447335272, -114.59407626641420563 50.4166998690063437, -119.86365984910806048 53.47639943303917676, -119.94099441499190561 59.97238022147455894, -140.92938615814153991 60.06202748779399059, -140.74999819452486349 59.61135341849296054, -138.11897472814712273 58.90840120048653006, -136.21070809681475566 57.03101434136195991)))&#x27;, ], ]);&#125; Answer:用多個 point 來代表一個區域 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function up()&#123; Schema::create(&#x27;regions&#x27;, function (Blueprint $table) &#123; $table-&gt;geometry(&#x27;geometry&#x27;); &#125;);&#125; Answer:geometry column type, 可以用多個 point 連起來代表一個區塊 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $myLocation = [-79.47, 43.14]; $stores = Store::query() -&gt;selectDistanceTo($myLocation) -&gt;withinDistanceTo($myLocation, 10000) // 10km -&gt;orderByDistanceTo($myLocation) -&gt;paginate(); return view(&#x27;stores&#x27;, [&#x27;stores&#x27; =&gt; $stores]);&#125;public function scopeOrderByDistanceTo($query, array $coordinates, string $direction = &#x27;asc&#x27;)&#123; $direction = strtolower($direction) === &#x27;asc&#x27; ? &#x27;asc&#x27; : &#x27;desc&#x27;; $query-&gt;orderByRaw(&#x27;ST_Distance( location, ST_SRID(Point(?, ?), 4326) ) &#x27;.$direction, $coordinates);&#125; Answer:&lt;?phppublic function scopeOrderByDistanceTo($query, array $coordinates, string $direction = &#x27;asc&#x27;)&#123; // 由於 $direction 是從外部帶入, 若要直接使用於 orderByRaw, 需要消毒 $direction = strtolower($direction) === &#x27;asc&#x27; ? &#x27;asc&#x27; : &#x27;desc&#x27;; // ST_Distance function 取得距離, 第一個 location 為資料庫中的 location column, 第二個為 request user // 的 location, 由於 ST_Distance 只接受 valid geographic object, 所以要先轉成 SRID // 空一格之後, 再接 $direction $query-&gt;orderByRaw(&#x27;ST_Distance( location, ST_SRID(Point(?, ?), 4326) ) &#x27;.$direction, $coordinates);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function up()&#123; Schema::create(&#x27;stores&#x27;, function (Blueprint $table) &#123; $table-&gt;point(&#x27;location&#x27;, 4326); &#125;);&#125; Answer:point 為 geographic 的一種形式, 需使用類似 $user-&gt;location = \\Illuminate\\Support\\Facades\\DB::raw(&#39;ST_SRID(Point(&#39;.$l.&#39;, &#39;.$a.&#39;), 4326)&#39;); 這種方式儲存, $l 為longitude, $a 為 Latitude 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $myLocation = [-79.47, 43.14]; $stores = Store::query() -&gt;selectDistanceTo($myLocation) -&gt;withinDistanceTo($myLocation, 10000) // 10km -&gt;paginate(); return view(&#x27;stores&#x27;, [&#x27;stores&#x27; =&gt; $stores]);&#125;public function scopeWithinDistanceTo($query, array $coordinates, int $distance)&#123; $query-&gt;whereRaw(&#x27;ST_Distance( location, ST_SRID(Point(?, ?), 4326) ) &lt;= ?&#x27;, [...$coordinates, $distance]);&#125; Answer:&lt;?phppublic function index()&#123; $myLocation = [-79.47, 43.14]; $stores = Store::query() // select 出 distance column -&gt;selectDistanceTo($myLocation) // 取得距離在 10km 裡的 record // ST_DISTANCE function 得到的結果為 meter // 而 10000 meter = 10km -&gt;withinDistanceTo($myLocation, 10000) // 10km -&gt;paginate(); return view(&#x27;stores&#x27;, [&#x27;stores&#x27; =&gt; $stores]);&#125;public function scopeWithinDistanceTo($query, array $coordinates, int $distance)&#123; // 使用 ST_Distance function // arg1 為 store 的 location, 可使用 point type column // 在儲存時就存成 point 格式, 這樣會增進 select 效能 // Point(?, ?) 為當前 User 的座標 // 最後取得 distance &lt;= 10km 的 record $query-&gt;whereRaw(&#x27;ST_Distance( location, ST_SRID(Point(?, ?), 4326) ) &lt;= ?&#x27;, [...$coordinates, $distance]);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $myLocation = [-79.47, 43.14]; $stores = Store::query() -&gt;selectDistanceTo($myLocation) -&gt;paginate(); return view(&#x27;stores&#x27;, [&#x27;stores&#x27; =&gt; $stores]);&#125;public function scopeSelectDistanceTo($query, array $coordinates)&#123; if (is_null($query-&gt;getQuery()-&gt;columns)) &#123; $query-&gt;select(&#x27;*&#x27;); &#125; $query-&gt;selectRaw(&#x27;ST_Distance( location, ST_SRID(Point(?, ?), 4326) ) as distance&#x27;, $coordinates);&#125; Answer:&lt;?phppublic function index()&#123; $myLocation = [-79.47, 43.14]; // 取得當前 user 的座標與各個 store 之間的距離 $stores = Store::query() -&gt;selectDistanceTo($myLocation) -&gt;paginate(); return view(&#x27;stores&#x27;, [&#x27;stores&#x27; =&gt; $stores]);&#125;public function scopeSelectDistanceTo($query, array $coordinates)&#123; // 如果當前 $query 沒有取得任何 column 的話, 那就 select 所有 column // 因為如果沒這麼做的話, 下面的 query 只會取得 selectRaw 的那一個 column if (is_null($query-&gt;getQuery()-&gt;columns)) &#123; $query-&gt;select(&#x27;*&#x27;); &#125; // 使用 MySQL 的 ST_Distance 來取得兩個點的距離 // ST_Distance function 要求的 args 必須要是 valid geographic object // 所以使用 ST_SRID function 來取得 // ST_SRID args 為兩個座標, 以及使用的 spatial reference ID, 4326 代表World $query-&gt;selectRaw(&#x27;ST_Distance( location, ST_SRID(Point(?, ?), 4326) ) as distance&#x27;, $coordinates);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function up()&#123; DB::statement(&#x27;CREATE FULLTEXT INDEX posts_fulltext_index ON posts(title, body) WITH PARSER ngram&#x27;);&#125; Answer:加入 fulltext index 到 posts table 的 title, body column, 使用 ngram parser 取代預設 parser 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $posts = Post::query() -&gt;with(&#x27;author&#x27;) -&gt;when(request(&#x27;search&#x27;), function ($query, $search) &#123; $query-&gt;whereRaw(&#x27;match(title, body) against(? in boolean mode)&#x27;, [$search]) -&gt;selectRaw(&#x27;*, match(title, body) against(? in boolean mode) as score&#x27;, [$search]); &#125;, function ($query) &#123; $query-&gt;latest(&#x27;published_at&#x27;); &#125;) -&gt;paginate(); return view(&#x27;posts&#x27;, [&#x27;posts&#x27; =&gt; $posts]);&#125; Answer:&lt;?phppublic function index()&#123; $posts = Post::query() -&gt;with(&#x27;author&#x27;) // 當 $request-&gt;search === true -&gt;when(request(&#x27;search&#x27;), function ($query, $search) &#123; // 使用 match method, 須事先先加 full-text index, boolean mode 效能較佳 $query-&gt;whereRaw(&#x27;match(title, body) against(? in boolean mode)&#x27;, [$search]) // 增加 score column 代表命中程度 -&gt;selectRaw(&#x27;*, match(title, body) against(? in boolean mode) as score&#x27;, [$search]); // 當 $request-&gt;search === false, 照 published_at 排序, 因為 match score 排序跟 published_at 排序不同 &#125;, function ($query) &#123; $query-&gt;latest(&#x27;published_at&#x27;); &#125;) -&gt;paginate(); return view(&#x27;posts&#x27;, [&#x27;posts&#x27; =&gt; $posts]);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $devices = Device::query() -&gt;orderByRaw(&#x27;naturalsort(name)&#x27;) -&gt;paginate(); return view(&#x27;devices&#x27;, [&#x27;devices&#x27; =&gt; $devices]);&#125; Answer:使用 natual sort, 但 MySQL 不支援, 所以必須先在 MySQL 中增加 natualsort function MySQL 不支援 natural sort, 該怎麼做？自己增加一個 MySQL function, 如下： Example:&lt;?phppublic function up()&#123; if (config(&#x27;database.default&#x27;) === &#x27;mysql&#x27;) &#123; // https://www.drupal.org/project/natsort DB::unprepared(&quot; drop function if exists naturalsort; create function naturalsort(s varchar(255)) returns varchar(255) no sql deterministic begin declare orig varchar(255) default s; declare ret varchar(255) default &#x27;&#x27;; if s is null then return null; elseif not s regexp &#x27;[0-9]&#x27; then set ret = s; else set s = replace(replace(replace(replace(replace(s, &#x27;0&#x27;, &#x27;#&#x27;), &#x27;1&#x27;, &#x27;#&#x27;), &#x27;2&#x27;, &#x27;#&#x27;), &#x27;3&#x27;, &#x27;#&#x27;), &#x27;4&#x27;, &#x27;#&#x27;); set s = replace(replace(replace(replace(replace(s, &#x27;5&#x27;, &#x27;#&#x27;), &#x27;6&#x27;, &#x27;#&#x27;), &#x27;7&#x27;, &#x27;#&#x27;), &#x27;8&#x27;, &#x27;#&#x27;), &#x27;9&#x27;, &#x27;#&#x27;); set s = replace(s, &#x27;.#&#x27;, &#x27;##&#x27;); set s = replace(s, &#x27;#,#&#x27;, &#x27;###&#x27;); begin declare numpos int; declare numlen int; declare numstr varchar(255); lp1: loop set numpos = locate(&#x27;#&#x27;, s); if numpos = 0 then set ret = concat(ret, s); leave lp1; end if; set ret = concat(ret, substring(s, 1, numpos - 1)); set s = substring(s, numpos); set orig = substring(orig, numpos); set numlen = char_length(s) - char_length(trim(leading &#x27;#&#x27; from s)); set numstr = cast(replace(substring(orig,1,numlen), &#x27;,&#x27;, &#x27;&#x27;) as decimal(13,3)); set numstr = lpad(numstr, 15, &#x27;0&#x27;); set ret = concat(ret, &#x27;[&#x27;, numstr, &#x27;]&#x27;); set s = substring(s, numlen+1); set orig = substring(orig, numlen+1); end loop; end; end if; set ret = replace(replace(replace(replace(replace(replace(replace(ret, &#x27; &#x27;, &#x27;&#x27;), &#x27;,&#x27;, &#x27;&#x27;), &#x27;:&#x27;, &#x27;&#x27;), &#x27;.&#x27;, &#x27;&#x27;), &#x27;;&#x27;, &#x27;&#x27;), &#x27;(&#x27;, &#x27;&#x27;), &#x27;)&#x27;, &#x27;&#x27;); return ret; end; &quot;); &#125; if (config(&#x27;database.default&#x27;) === &#x27;sqlite&#x27;) &#123; throw new \\Exception(&#x27;This lesson does not support SQLite.&#x27;); &#125; if (config(&#x27;database.default&#x27;) === &#x27;pgsql&#x27;) &#123; // http://www.rhodiumtoad.org.uk/junk/naturalsort.sql DB::unprepared(&#x27; create or replace function naturalsort(text) returns bytea language sql immutable strict as $f$ select string_agg(convert_to(coalesce(r[2],length(length(r[1])::text) || length(r[1])::text || r[1]),\\&#x27;SQL_ASCII\\&#x27;),\\&#x27;\\x00\\&#x27;) from regexp_matches($1, \\&#x27;0*([0-9]+)|([^0-9]+)\\&#x27;, \\&#x27;g\\&#x27;) r; $f$; &#x27;); &#125;&#125;public function down()&#123; if (config(&#x27;database.default&#x27;) === &#x27;mysql&#x27;) &#123; DB::unprepared(&#x27;drop function if exists naturalsort&#x27;); &#125; if (config(&#x27;database.default&#x27;) === &#x27;sqlite&#x27;) &#123; throw new \\Exception(&#x27;This lesson does not support SQLite.&#x27;); &#125; if (config(&#x27;database.default&#x27;) === &#x27;pgsql&#x27;) &#123; DB::unprepared(&#x27;drop function if exists naturalsort&#x27;); &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $devices = [&#x27;iPhone 3&#x27;, &#x27;iPhone 11&#x27;]; sort($devices, SORT_NATUAL); return $devices;&#125; Answer:使用 PHP 的 natual sort 參數, 正常 sort 是 iPhone 11, iPhone 3, natual sort 是 iPhone 3, iPhone 11 什麼是 natual sorting?跟 Alphabetical Sort 幾乎相同, 唯一的不同在於, natual sorting 會將多位數的數字當成一個單一字符換句話說, [&#39;3&#39;, &#39;11&#39;, &#39;2&#39;] Alphabetical 排序會是 11, 2, 3, 而 natual sort 會是 2, 3, 11 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function scopeOrderByUpcomingBirthdays()&#123; $query-&gt;orderByRaw(&#x27; case when (birth_date + interval (year(?) - year(birth_date)) year) &gt;= ? then (birth_date + interval (year(?) - year(birth_date)) year) else (birth_date + interval (year(?) - year(birth_date)) + 1 year) end &#x27;, [ array_fill(0, 4, Carbon::now()-&gt;startOfWeek()-&gt;toDateString()), ]);&#125; Answer:&lt;?phppublic function scopeOrderByUpcomingBirthdays()&#123; // 概念為, 將 &#x27;birth_date&#x27; 加上 &#x27;今年到你生日那年總共間隔多少年&#x27; 會等於你的 birth_date, 但 // 年份換成是今年, 如果這個值大於今天的年月日的話, 那代表你的生日還沒過, 反之, 如果這個值小於的話 // 那代表今年你的生日已經過了, 所以會排到明年去。 // 這樣一來便可以 order by upcoming birthday $query-&gt;orderByRaw(&#x27; case when (birth_date + interval (year(?) - year(birth_date)) year) &gt;= ? then (birth_date + interval (year(?) - year(birth_date)) year) else (birth_date + interval (year(?) - year(birth_date)) + 1 year) end &#x27;, [ // 從 index 0 開始 fill, fill 4 次, fill 這個禮拜的第一天, 以 dateString 的格式 // 這邊我覺得是看需求, 如果是 weekly email notification 的話, 那就用 startOfWeek() // 但若是即時查詢的話, 就要用 now(), 否則會取得生日已經過了的 model array_fill(0, 4, Carbon::now()-&gt;startOfWeek()-&gt;toDateString()), ]);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $users = User::query() -&gt;whereBirthdayThisWeek() -&gt;orderByBirthday() // -&gt;orderByUpcomingBirthdays() -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125; public function scopeOrderByBirthday($query) &#123; $query-&gt;orderByRaw(&#x27;date_format(birth_date, &quot;%m-%d&quot;)&#x27;); &#125; Answer:&lt;?phppublic function index()&#123; $users = User::query() -&gt;whereBirthdayThisWeek() -&gt;orderByBirthday() // -&gt;orderByUpcomingBirthdays() -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125;public function scopeOrderByBirthday($query)&#123; // order by raw &#x27;birth_date&#x27; 欄位, 並以 &quot;%m-%d&quot; 格式排序 $query-&gt;orderByRaw(&#x27;date_format(birth_date, &quot;%m-%d&quot;)&#x27;);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function up()&#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;rawIndex(&quot;(date_format(birth_date, &#x27;%m-%d&#x27;)), name&quot;, &#x27;users_birthday_name_index&#x27;); &#125;);&#125; Answer:&lt;?phppublic function up()&#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; // 增加 compound index, 欄位為使用 date_format function // reformat 過的 birth_date column, 以及 name column $table-&gt;rawIndex(&quot;(date_format(birth_date, &#x27;%m-%d&#x27;)), name&quot;, &#x27;users_birthday_name_index&#x27;); &#125;);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $users = User::query() -&gt;whereBirthdayThisWeek() -&gt;orderByBirthday() // -&gt;orderByUpcomingBirthdays() -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125;public function scopeWhereBirthdayThisWeek($query)&#123; $dates = Carbon::now()-&gt;startOfWeek() -&gt;daysUntil(Carbon::now()-&gt;endOfWeek()) -&gt;map(fn ($date) =&gt; $date-&gt;format(&#x27;m-d&#x27;)); $query-&gt;whereRaw(&#x27;date_format(birth_date, &quot;%m-%d&quot;) in (?,?,?,?,?,?,?)&#x27;, iterator_to_array($dates));&#125; Answer:&lt;?phppublic function index()&#123; $users = User::query() // 取得生日在本週的 User model -&gt;whereBirthdayThisWeek() -&gt;orderByBirthday() -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125;public function scopeWhereBirthdayThisWeek($query)&#123; // 取得 this week 的每一個 date 的日期, 並轉成 &#x27;m-d&#x27; 格式 $dates = Carbon::now()-&gt;startOfWeek() -&gt;daysUntil(Carbon::now()-&gt;endOfWeek()) -&gt;map(fn ($date) =&gt; $date-&gt;format(&#x27;m-d&#x27;)); // 取得 birth_date 為這個禮拜的 model, 之所以使用 in 而不是 between, 那是 // 因為當遇到 12-25 到 1-2 的情況時, 因為前者比後者大, 會出現 query 沒有結果的 // 問題, 而之所以使用 iterator_to_array, 那是因為 Carbon 會 return 一個 // generator object $query-&gt;whereRaw(&#x27;date_format(birth_date, &quot;%m-%d&quot;) in (?,?,?,?,?,?,?)&#x27;, iterator_to_array($dates));&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function up()&#123; Schema::create(&#x27;features&#x27;, function (Blueprint $table) &#123; $table-&gt;rawIndex(&quot;( case when status = &#x27;Requested&#x27; then 1 when status = &#x27;Approved&#x27; then 2 when status = &#x27;Completed&#x27; then 3 end )&quot;, &#x27;features_status_ranking_index&#x27;); &#125;);&#125; Answer:&lt;?phppublic function up()&#123; Schema::create(&#x27;features&#x27;, function (Blueprint $table) &#123; // 當使用 orderRaw(&quot;( // case // when status = &#x27;Requested&#x27; then 1 // when status = &#x27;Approved&#x27; then 2 // when status = &#x27;Completed&#x27; then 3 // end // )&quot;) // 時, 可加上 index $table-&gt;rawIndex(&quot;( case when status = &#x27;Requested&#x27; then 1 when status = &#x27;Approved&#x27; then 2 when status = &#x27;Completed&#x27; then 3 end // 命名 index )&quot;, &#x27;features_status_ranking_index&#x27;); &#125;);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass FeaturesController extends Controller&#123; public function index() &#123; $features = Feature::query() -&gt;withCount(&#x27;comments&#x27;, &#x27;votes&#x27;) -&gt;when(request(&#x27;sort&#x27;), function ($query, $sort) &#123; switch ($sort) &#123; case &#x27;title&#x27;: return $query-&gt;orderBy(&#x27;title&#x27;, request(&#x27;direction&#x27;)); case &#x27;status&#x27;: return $query-&gt;orderByStatus(request(&#x27;direction&#x27;)); case &#x27;activity&#x27;: return $query-&gt;orderByActivity(request(&#x27;direction&#x27;)); &#125; &#125;) -&gt;latest() -&gt;paginate(); return view(&#x27;features&#x27;, [&#x27;features&#x27; =&gt; $features]); &#125; public function scopeOrderByActivity($query, $direction) &#123; $query-&gt;orderBy( DB::raw(&#x27;-(votes_count + (comments_count * 2))&#x27;), $direction ); &#125;&#125; Answer:&lt;?phpclass FeaturesController extends Controller&#123; public function index() &#123; $features = Feature::query() // 取得 comments 以及 votes column counts -&gt;withCount(&#x27;comments&#x27;, &#x27;votes&#x27;) // &#x27;sort&#x27; === &#x27;title&#x27; || &#x27;status&#x27; || &#x27;activity&#x27; // request[&#x27;direction&#x27;] 為 desc, 或 asc -&gt;when(request(&#x27;sort&#x27;), function ($query, $sort) &#123; switch ($sort) &#123; case &#x27;title&#x27;: return $query-&gt;orderBy(&#x27;title&#x27;, request(&#x27;direction&#x27;)); case &#x27;status&#x27;: return $query-&gt;orderByStatus(request(&#x27;direction&#x27;)); case &#x27;activity&#x27;: return $query-&gt;orderByActivity(request(&#x27;direction&#x27;)); &#125; &#125;) -&gt;latest() -&gt;paginate(); return view(&#x27;features&#x27;, [&#x27;features&#x27; =&gt; $features]); &#125; public function scopeOrderByActivity($query, $direction) &#123; // 我可以使用 query 中實際或虛擬的 column 來排序 // - 表示顛倒排序結果 // 若 votes_count 以及 comments_count 取自虛擬 column, 那是無法做 index 的 // 可以考慮實際增加兩個欄位, 或是用 virtual column $query-&gt;orderBy( DB::raw(&#x27;-(votes_count + (comments_count * 2))&#x27;), $direction );&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass FeaturesController extends Controller&#123; public function index() &#123; $features = Feature::query() -&gt;withCount(&#x27;comments&#x27;, &#x27;votes&#x27;) -&gt;when(request(&#x27;sort&#x27;), function ($query, $sort) &#123; switch ($sort) &#123; case &#x27;title&#x27;: return $query-&gt;orderBy(&#x27;title&#x27;, request(&#x27;direction&#x27;)); case &#x27;status&#x27;: return $query-&gt;orderByStatus(request(&#x27;direction&#x27;)); case &#x27;activity&#x27;: return $query-&gt;orderByActivity(request(&#x27;direction&#x27;)); &#125; &#125;) -&gt;latest() -&gt;paginate(); return view(&#x27;features&#x27;, [&#x27;features&#x27; =&gt; $features]); &#125; public function scopeOrderByStatus($query, $direction) &#123; $query-&gt;orderBy(DB::raw(&quot; case when status = &#x27;Requested&#x27; then 1 when status = &#x27;Approved&#x27; then 2 when status = &#x27;Completed&#x27; then 3 end &quot;), $direction); &#125;&#125; Answer:&lt;?phpclass FeaturesController extends Controller&#123; public function index() &#123; $features = Feature::query() // 取得 comments 以及 votes column counts -&gt;withCount(&#x27;comments&#x27;, &#x27;votes&#x27;) // &#x27;sort&#x27; === &#x27;title&#x27; || &#x27;status&#x27; || &#x27;activity&#x27; // request[&#x27;direction&#x27;] 為 desc, 或 asc -&gt;when(request(&#x27;sort&#x27;), function ($query, $sort) &#123; switch ($sort) &#123; case &#x27;title&#x27;: return $query-&gt;orderBy(&#x27;title&#x27;, request(&#x27;direction&#x27;)); case &#x27;status&#x27;: return $query-&gt;orderByStatus(request(&#x27;direction&#x27;)); case &#x27;activity&#x27;: return $query-&gt;orderByActivity(request(&#x27;direction&#x27;)); &#125; &#125;) -&gt;latest() -&gt;paginate(); return view(&#x27;features&#x27;, [&#x27;features&#x27; =&gt; $features]); &#125; public function scopeOrderByStatus($query, $direction) &#123; // 預設 &#x27;Requested&#x27;, &#x27;Approved&#x27;, &#x27;Completed&#x27; 這三個 value 會依照 Alph 方式排序 // 若想變更排序規則, 可使用以下的方式, 將 value 依照自己想要的順序 return 成數字 // DB 會依照數字順序排列 $query-&gt;orderBy(DB::raw(&quot; case when status = &#x27;Requested&#x27; then 1 when status = &#x27;Approved&#x27; then 2 when status = &#x27;Completed&#x27; then 3 end &quot;), $direction); &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $users = User::query() -&gt;when(request(&#x27;sort&#x27;) === &#x27;town&#x27;, function ($query) &#123; if (config(&#x27;database.default&#x27;) === &#x27;mysql&#x27; || config(&#x27;database.default&#x27;) === &#x27;sqlite&#x27;) &#123; $query-&gt;orderByRaw(&#x27;town is null&#x27;) -&gt;orderBy(&#x27;town&#x27;, request(&#x27;direction&#x27;)); &#125; if (config(&#x27;database.default&#x27;) === &#x27;pgsql&#x27;) &#123; $query-&gt;orderByNullsLast(&#x27;town&#x27;, request(&#x27;direction&#x27;)); &#125; &#125;) -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125; Answer:&lt;?phppublic function index()&#123; $users = User::query() -&gt;when(request(&#x27;sort&#x27;) === &#x27;town&#x27;, function ($query) &#123; if (config(&#x27;database.default&#x27;) === &#x27;mysql&#x27; || config(&#x27;database.default&#x27;) === &#x27;sqlite&#x27;) &#123; // 如果不加這一行, 那 order by 時會將 null 的顯示在最前面, 加了這一行後, 值為 null 的 row 會被排到最後 $query-&gt;orderByRaw(&#x27;town is null&#x27;) -&gt;orderBy(&#x27;town&#x27;, request(&#x27;direction&#x27;)); &#125; if (config(&#x27;database.default&#x27;) === &#x27;pgsql&#x27;) &#123; $query-&gt;orderByNullsLast(&#x27;town&#x27;, request(&#x27;direction&#x27;)); &#125; &#125;) -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; Builder::macro(&#x27;orderByNullsLast&#x27;, function ($column, $direction = &#x27;asc&#x27;) &#123; $column = $this-&gt;getGrammar()-&gt;wrap($column); $direction = strtolower($direction) === &#x27;asc&#x27; ? &#x27;asc&#x27; : &#x27;desc&#x27;; return $this-&gt;orderByRaw(&quot;$column $direction nulls last&quot;); &#125;);&#125; Answer:&lt;?phppublic function boot()&#123; // 建立一個 new query builder method, 名為 orderByNullsLast Builder::macro(&#x27;orderByNullsLast&#x27;, function ($column, $direction = &#x27;asc&#x27;) &#123; // wrap $column, 因為 $column 為外部帶入參數, 並且又使用 raw method, 為避免 SQL injection, 需使用 wrap $column = $this-&gt;getGrammar()-&gt;wrap($column); $direction = strtolower($direction) === &#x27;asc&#x27; ? &#x27;asc&#x27; : &#x27;desc&#x27;; // 此為 PostgreSQL 語法, 效果為將值為 null 的 column 排在最後 return $this-&gt;orderByRaw(&quot;$column $direction nulls last&quot;); &#125;);&#125; Laravel 中, updateOrCreate() 與 MySQL 中的 INSERT … ON DUPLICATE KEY UPDATE 的差異是？基本上兩者的效果相同, 但實作原理不同, 效能也不同INSERT … ON DUPLICATE KEY UPDATE 為 MySQL 內建語法, 會透過 unique key 去判斷該 row 是否為 duplicate keyupdateOrCreate() 為複數 query 實作而成的 method, 會先 select 比較, 再決定 insert or update前者的效能較佳 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $books = Book::query() -&gt;select(&#x27;book.*&#x27;) -&gt;join(&#x27;checkouts&#x27;, &#x27;checkouts.book_id&#x27;, &#x27;=&#x27;, &#x27;books.id&#x27;) -&gt;groupBy(&#x27;books.id&#x27;) -&gt;orderByRaw(&#x27;max(checkouts.borrowed_date) desc&#x27;) -&gt;withLastCheckout() -&gt;with(&#x27;lastCheckout.user&#x27;) -&gt;paginate(); return view(&#x27;books&#x27;, [&#x27;books&#x27; =&gt; $books]);&#125;public function scopeWithLastCheckout($query)&#123; $query-&gt;addSelect([&#x27;last_checkout_id&#x27; =&gt; Checkout::select(&#x27;checkouts.id&#x27;) -&gt;whereColumn(&#x27;book_id&#x27;, &#x27;books.id&#x27;) -&gt;latest(&#x27;borrowed_date&#x27;) -&gt;limit(1), ])-&gt;with(&#x27;lastCheckout&#x27;);&#125; Answer:&lt;?phppublic function index()&#123; $books = Book::query() -&gt;select(&#x27;books.*&#x27;) -&gt;join(&#x27;checkouts&#x27;, &#x27;checkouts.book_id&#x27;, &#x27;=&#x27;, &#x27;books.id&#x27;) // 如果不使用 group by, 則或出現多個重複的 book model, 因為每一個 book model 都會對應到多個 checkouts model -&gt;groupBy(&#x27;books.id&#x27;) // 取得最大的 borrowed_date, 即最後借出日期, 在 query 過程中, 每個 row 都會新增一個 column 名為 borrowed_date // 其值為 max(checkouts.borrowed_date), 最後 order by 這個 column // 這邊 INDEX 是不吃的, 若要優化, 可在 book table 中新增一個 last_checkout_id column, 每次 book 被 checkout 時 // 都更新這個欄位 -&gt;orderByRaw(&#x27;max(checkouts.borrowed_date) desc&#x27;) // dynanmic relation 的概念, 每個 book model 對應多個 checkout model, 但我們只取其中一筆 checkout model -&gt;withLastCheckout() // 已事先於 checkout model 中定義 user belongsTo relation, 所以直接 eager load 對應的 user model -&gt;with(&#x27;lastCheckout.user&#x27;) -&gt;paginate(); return view(&#x27;books&#x27;, [&#x27;books&#x27; =&gt; $books]);&#125;public function scopeWithLastCheckout($query)&#123; // 新增 &#x27;last_checkout_id&#x27; column $query-&gt;addSelect([&#x27;last_checkout_id&#x27; =&gt; Checkout::select(&#x27;checkouts.id&#x27;) // 將 checkout table 與 book table 對應起來 -&gt;whereColumn(&#x27;book_id&#x27;, &#x27;books.id&#x27;) // 以 borrowed_date 排序 -&gt;latest(&#x27;borrowed_date&#x27;) // 只取第一筆 -&gt;limit(1), // 取得 last_checkout_id 之後, 便可利用 dynanmic relation 的概念, 取得事先定義的 lastCheckout belongsTo relation ])-&gt;with(&#x27;lastCheckout&#x27;);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $books = Book::query() -&gt;orderBy(User::select(&#x27;name&#x27;) -&gt;join(&#x27;checkouts&#x27;, &#x27;checkouts.user_id&#x27;, &#x27;=&#x27;, &#x27;users.id&#x27;) -&gt;whereColumn(&#x27;checkouts.book_id&#x27;, &#x27;books.id&#x27;) -&gt;latest(&#x27;checkouts.borrowed_date&#x27;) -&gt;take(1) ) -&gt;withLastCheckout() -&gt;with(&#x27;lastCheckout.user&#x27;) -&gt;paginate(); return view(&#x27;books&#x27;, [&#x27;books&#x27; =&gt; $books]);&#125;public function scopeWithLastCheckout($query)&#123; $query-&gt;addSelect([&#x27;last_checkout_id&#x27; =&gt; Checkout::select(&#x27;checkouts.id&#x27;) -&gt;whereColumn(&#x27;book_id&#x27;, &#x27;books.id&#x27;) -&gt;latest(&#x27;borrowed_date&#x27;) -&gt;limit(1), ])-&gt;with(&#x27;lastCheckout&#x27;);&#125; Answer:&lt;?phppublic function index()&#123; $books = Book::query() // 以 name 排序 -&gt;orderBy(User::select(&#x27;name&#x27;) // 透過 join, 取得 user 的所有借書紀錄 -&gt;join(&#x27;checkouts&#x27;, &#x27;checkouts.user_id&#x27;, &#x27;=&#x27;, &#x27;users.id&#x27;) // 透過 where, 取得每一個 book row 對應到的 data, 如果不使用 where 來把 book.id // 以及 checkouts.book_id 做關聯, 那 user name 永遠都會是一樣的 // 但加上 where 之後, 就可以取得每一個 book 的所有借閱紀錄, 並取得最後借出的那個 user name // 最後再 order by 這個 user name -&gt;whereColumn(&#x27;checkouts.book_id&#x27;, &#x27;books.id&#x27;) // 因為要取得最後借出的 user, 所以要先加以排序 -&gt;latest(&#x27;checkouts.borrowed_date&#x27;) // 因為要取得最後借出的 user, 因此只取最後的那一個 user -&gt;take(1) ) // 利用 dynanmic relation 的概念, 先新增一個 last_checkout_id 虛擬欄位, 再透過 // book model 中的 belongs to relation, 經由這個虛擬的 last_checkout_id 取得 // 最後 checkout 的那一筆 checkout 資料 -&gt;withLastCheckout() // checkout model 中已有先定義與 user 的 belongsTo relation, 因此可以取得與 // 該 checkout model 相關的 user model -&gt;with(&#x27;lastCheckout.user&#x27;) -&gt;paginate(); return view(&#x27;books&#x27;, [&#x27;books&#x27; =&gt; $books]);&#125;public function scopeWithLastCheckout($query)&#123; $query-&gt;addSelect([&#x27;last_checkout_id&#x27; =&gt; Checkout::select(&#x27;checkouts.id&#x27;) // 透過 where, 可取得與每一行 book 相關的 checkout records -&gt;whereColumn(&#x27;book_id&#x27;, &#x27;books.id&#x27;) // 因為每一個 book model 都會有多筆的 checkout records, 因此須加以排序 -&gt;latest(&#x27;borrowed_date&#x27;) // 排序後只取得最新的那一筆, 即最後借出那一筆紀錄, 至此, 只為了取得這一筆 records 的 id -&gt;limit(1), ])-&gt;with(&#x27;lastCheckout&#x27;);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $users = User::query() -&gt;orderByLastLogin() -&gt;withLastLogin() -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125;public function scopeOrderByLastLogin($query)&#123; $query-&gt;orderByDesc(Login::select(&#x27;created_at&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;) -&gt;latest() -&gt;take(1) );&#125;public function scopeWithLastLogin($query)&#123; $query-&gt;addSelect([&#x27;last_login_id&#x27; =&gt; Login::select(&#x27;id&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;) -&gt;latest() -&gt;take(1), ])-&gt;with(&#x27;lastLogin&#x27;);&#125; Answer:&lt;?phppublic function index()&#123; $users = User::query() -&gt;orderByLastLogin() -&gt;withLastLogin() -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125;public function scopeOrderByLastLogin($query)&#123; // 每個 User 都有很多個 Login, 所以在 orderByDesc 當中使用 subquery // 取得與該 user 相關的 login records 之後, 再排序, 然後取第一筆 // 所以會 orderByDesc 每個 user 的最新一筆 login $query-&gt;orderByDesc(Login::select(&#x27;created_at&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;) -&gt;latest() -&gt;take(1) );&#125;public function scopeWithLastLogin($query)&#123; // 每個 User 都有 many Login, 利用 addSelect 新增一個 column &#x27;last_login_id&#x27; // 正常來說 User 跟 Login 的 relationship 應該是 User hasMany Login // 但這邊為 dynamic model 的概念, 目的為從 hasMany 眾多 records 當中 // 只 load 想要的那筆資料, 大幅增進效能 $query-&gt;addSelect([&#x27;last_login_id&#x27; =&gt; Login::select(&#x27;id&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;) -&gt;latest() -&gt;take(1), ])-&gt;with(&#x27;lastLogin&#x27;);&#125;public function lastLogin()&#123; // 正常來說 User 跟 Login 的 relationship 應該是 User hasMany Login // 但這邊為 dynamic model 的概念, 目的為從 hasMany 眾多 records 當中 // 只 load 想要的那筆資料, 大幅增進效能 return $this-&gt;belongsTo(Login::class);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function index()&#123; $users = User::query() -&gt;select(&#x27;users.*&#x27;) -&gt;join(&#x27;companies&#x27;, &#x27;companies.user_id&#x27;, &#x27;=&#x27;, &#x27;users.id&#x27;) -&gt;orderBy(&#x27;companies.name&#x27;) -&gt;with(&#x27;company&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]);&#125; Answer:當需要 orderBy hasOne relationship 的某一個 column, 務必使用 join approach 以下的 Laravel example code 的意思是？ Example:&lt;?php public function index() &#123; $users = User::query() -&gt;select(&#x27;users.*&#x27;) -&gt;join(&#x27;companies&#x27;, &#x27;companies.user_id&#x27;, &#x27;=&#x27;, &#x27;users.id&#x27;) -&gt;orderBy(&#x27;companies.name&#x27;) -&gt;with(&#x27;company&#x27;) -&gt;paginate(); return view(&#x27;users&#x27;, [&#x27;users&#x27; =&gt; $users]); &#125; Answer:當需要 orderBy belognsTo relationship 的某一個 column, 務必使用 join approach Laravel 中, 當使用 pagination 時, 務必要使用 orderBy, 為什麼？因為 pagination 會 offset 並 limit record 數量, 若無使用 orderBy 的話, 很可能每一次的排序都有所不同, 這將導致 pagination 的每一頁的結果是沒有順序性的 Laravel 中, 以下的 migration example code 中, 如果使用 orderBy(‘first_name’)-&gt;orderBy(‘last_name’), index 會生效嗎？？ Example:&lt;?php public function up() &#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;index([&#x27;last_name&#x27;, &#x27;first_name&#x27;]); &#125;); &#125; Answer:不會, 因為 orderBy 順序必須符合 index 的順序 Laravel 中, 以下的 example code 的意思是？ Example:&lt;?phppublic function index()&#123; Auth::login(User::where(&#x27;name&#x27;, &#x27;Sarah Seller&#x27;)-&gt;first()); $customers = Customer::query() -&gt;visibleTo(Auth::user()) -&gt;with(&#x27;salesRep&#x27;) -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); return view(&#x27;customers&#x27;, [&#x27;customers&#x27; =&gt; $customers]);&#125;public function scopeVisibleTo($query, User $user)&#123; if (! $user-&gt;is_owner) &#123; $query-&gt;where(&#x27;sales_rep_id&#x27;, $user-&gt;id); &#125;&#125; Answer:情境為, 當 user 為 owner 時, 可以看到所有的 customer, 而當 user 為 salesRep 時, 只可看到自己底下的 customer主要概念為, 若有這樣的情境限制, 務必將 filter 做在 database layer Laravel 中, 以下的 migration example code 的意思是？ Example:&lt;?php public function up() &#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;index([&#x27;last_name&#x27;, &#x27;first_name&#x27;]); &#125;); &#125; Answer:增加一個 compound index, 若是使用 orderBy 時, 順序必須跟 compound index 的順序相同 Laravel 中, 以下的 example code 的意思是？ Example:&lt;?phppublic function scopeSearch($query, string $terms = null)&#123; collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; $term = preg_replace(&#x27;/[^A-Za-z0-9]/&#x27;, &#x27;&#x27;, $term).&#x27;%&#x27;; $query-&gt;whereIn(&#x27;id&#x27;, function ($query) use ($term) &#123; $query-&gt;select(&#x27;id&#x27;) -&gt;from(function ($query) use ($term) &#123; $query-&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) -&gt;where(&#x27;users.first_name_normalized&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;users.last_name_normalized&#x27;, &#x27;like&#x27;, $term) -&gt;union( $query-&gt;newQuery() -&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) -&gt;join(&#x27;companies&#x27;, &#x27;users.company_id&#x27;, &#x27;=&#x27;, &#x27;companies.id&#x27;) -&gt;where(&#x27;companies.name_normalized&#x27;, &#x27;like&#x27;, $term) ); &#125;, &#x27;matches&#x27;); &#125;); &#125;);&#125; Answer:&lt;?phppublic function scopeSearch($query, string $terms = null)&#123; collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; // 將 $term 中 &quot;非 A-Za-z0-9&quot; 的內容都替換成 &#x27;&#x27;, 也就是刪去 $term = preg_replace(&#x27;/[^A-Za-z0-9]/&#x27;, &#x27;&#x27;, $term).&#x27;%&#x27;; // 之所以不在 $query-&gt;whereIn(&#x27;id&#x27;, function ($query) use ($term) &#123; $query-&gt;select(&#x27;id&#x27;) -&gt;from(function ($query) use ($term) &#123; $query-&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) // 從 first_name_normalized virtual column 中 query // 因為若使用 whereRaw 的 regular expression 語法, 將無法 // 使用 index -&gt;where(&#x27;users.first_name_normalized&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;users.last_name_normalized&#x27;, &#x27;like&#x27;, $term) -&gt;union( $query-&gt;newQuery() -&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) -&gt;join(&#x27;companies&#x27;, &#x27;users.company_id&#x27;, &#x27;=&#x27;, &#x27;companies.id&#x27;) -&gt;where(&#x27;companies.name_normalized&#x27;, &#x27;like&#x27;, $term) ); &#125;, &#x27;matches&#x27;); &#125;); &#125;);&#125; Laravel 中, 以下的 example code 的意思是？ Example:&lt;?phppublic function up()&#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; $table-&gt;foreignId(&#x27;company_id&#x27;)-&gt;constrained(&#x27;companies&#x27;); $table-&gt;string(&#x27;first_name_normalized&#x27;)-&gt;virtualAs(&quot;regexp_replace(first_name, &#x27;[^A-Za-z0-9]&#x27;, &#x27;&#x27;)&quot;)-&gt;index(); $table-&gt;string(&#x27;last_name&#x27;); $table-&gt;string(&#x27;last_name_normalized&#x27;)-&gt;virtualAs(&quot;regexp_replace(last_name, &#x27;[^A-Za-z0-9]&#x27;, &#x27;&#x27;)&quot;)-&gt;index(); &#125;);&#125; Answer:&lt;?phppublic function up()&#123; Schema::create(&#x27;users&#x27;, function (Blueprint $table) &#123; // foreignId 為 unsignedBigInteger 的 alias, 而 constrained 會自動為 // users table 中的 company_id 與 companies table 中的 id column 建立 foreign key index $table-&gt;foreignId(&#x27;company_id&#x27;)-&gt;constrained(&#x27;companies&#x27;); // virtualAs 作用為建立一個 virtual column, 此行 code 會將 first_name column 中 // 只要不是 a-zA-Z0-9 的都替換成 &#x27;&#x27;, 然後再將內容存到 first_name_normalized 這個 // 虛擬 column, 並建立 index $table-&gt;string(&#x27;first_name_normalized&#x27;)-&gt;virtualAs(&quot;regexp_replace(first_name, &#x27;[^A-Za-z0-9]&#x27;, &#x27;&#x27;)&quot;)-&gt;index(); $table-&gt;string(&#x27;last_name&#x27;); // 同上 $table-&gt;string(&#x27;last_name_normalized&#x27;)-&gt;virtualAs(&quot;regexp_replace(last_name, &#x27;[^A-Za-z0-9]&#x27;, &#x27;&#x27;)&quot;)-&gt;index(); &#125;);&#125; Laravel 中, 以下的 example code 的意思是？ Example:&lt;?phppublic function scopeSearch($query, string $terms = null)&#123; collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; $term = $term.&#x27;%&#x27;; $query-&gt;whereIn(&#x27;id&#x27;, function ($query) use ($term) &#123; $query-&gt;select(&#x27;id&#x27;) -&gt;from(function ($query) use ($term) &#123; $query-&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) -&gt;where(&#x27;users.first_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;users.last_name&#x27;, &#x27;like&#x27;, $term) -&gt;union( $query-&gt;newQuery() -&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) -&gt;join(&#x27;companies&#x27;, &#x27;users.company_id&#x27;, &#x27;=&#x27;, &#x27;companies.id&#x27;) -&gt;where(&#x27;companies.name&#x27;, &#x27;like&#x27;, $term) ); &#125;, &#x27;matches&#x27;); &#125;); &#125;);&#125; Answer:&lt;?phppublic function scopeSearch($query, string $terms = null)&#123; collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; $term = $term.&#x27;%&#x27;; // 最終目的, 是要找到符合 query 條件的 users, 又要讓 index 生效 // 這邊是 select * from users whereIn(&#x27;id&#x27;, nextQuery) $query-&gt;whereIn(&#x27;id&#x27;, function ($query) use ($term) &#123; // 這邊是 select id from derived table, 之所以使用 derived table, 是為了 // 不要讓內外 query 相互依賴, 如果單純在 whereIn 當中使用 subquery 的話, 就會 // 產生互相依賴, 造成 index 無法生效 $query-&gt;select(&#x27;id&#x27;) -&gt;from(function ($query) use ($term) &#123; $query-&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) -&gt;where(&#x27;users.first_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;users.last_name&#x27;, &#x27;like&#x27;, $term) // 使用 union 來串接兩句語法 -&gt;union( $query-&gt;newQuery() -&gt;select(&#x27;users.id&#x27;) -&gt;from(&#x27;users&#x27;) -&gt;join(&#x27;companies&#x27;, &#x27;users.company_id&#x27;, &#x27;=&#x27;, &#x27;companies.id&#x27;) -&gt;where(&#x27;companies.name&#x27;, &#x27;like&#x27;, $term) ); // derived table 必須要有一個 alias &#125;, &#x27;matches&#x27;); &#125;); &#125;);&#125; Laravel 中, 以下的 example code 的意思是？ Example:&lt;?phppublic function scopeSearch($query, string $terms = null)&#123; collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; $term = $term.&#x27;%&#x27;; $query-&gt;where(function ($query) use ($term) &#123; $query-&gt;where(&#x27;first_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;last_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhereIn(&#x27;company_id&#x27;, Company::query() -&gt;where(&#x27;name&#x27;, &#x27;like&#x27;, $term) -&gt;pluck(&#x27;id&#x27;) ); &#125;); &#125;);&#125; Answer:雖然沒有使用 sub query 造成 query 的數量增加了, 但 users table 因為沒有使用 sub query 的關係而使 index 生效, 雖然 query 數量較多, 但速度卻變快了 Laravel 中, 以下的 example code 的意思是？ Example:&lt;?php public function scopeSearch($query, string $terms = null) &#123; collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; $term = $term.&#x27;%&#x27;; $query-&gt;where(function ($query) use ($term) &#123; $query-&gt;where(&#x27;first_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;last_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhereIn(&#x27;company_id&#x27;, function ($query) use ($term) &#123; $query-&gt;select(&#x27;id&#x27;) -&gt;from(&#x27;companies&#x27;) -&gt;where(&#x27;name&#x27;, &#x27;like&#x27;, $term); &#125;); &#125;); &#125;); &#125; Answer:&lt;?php public function scopeSearch($query, string $terms = null) &#123; // str_getcsv 會將 &#x27; &#x27; (空白) 分出來, &quot; (double quote) 也分出來, return 一個 array // 再把這個 array 使用 each 迭代 collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; // prefix 不用 %, 因為 prefix % 不適用於 index $term = $term.&#x27;%&#x27;; $query-&gt;where(function ($query) use ($term) &#123; $query-&gt;where(&#x27;first_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;last_name&#x27;, &#x27;like&#x27;, $term) // 這邊不使用 orWhereHas, 因為 SQL 語法會關聯兩張表, // 這個 dependency 會造成 company_name 不適用 index // 因此使用 whereIn 來避開此 dependency -&gt;orWhereIn(&#x27;company_id&#x27;, function ($query) use ($term) &#123; $query-&gt;select(&#x27;id&#x27;) -&gt;from(&#x27;companies&#x27;) -&gt;where(&#x27;name&#x27;, &#x27;like&#x27;, $term); &#125;); &#125;); &#125;); &#125; Laravel 中, 以下的 example code 的意思是？ Example:&lt;?php public function scopeSearch($query, string $terms = null) &#123; collect(str_getcsv($terms, &#x27; &#x27;, &#x27;&quot;&#x27;))-&gt;filter()-&gt;each(function ($term) use ($query) &#123; $term = $term.&#x27;%&#x27;; $query-&gt;where(function ($query) use ($term) &#123; $query-&gt;where(&#x27;first_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhere(&#x27;last_name&#x27;, &#x27;like&#x27;, $term) -&gt;orWhereHas(&#x27;company&#x27;, function ($query) use ($term) &#123; $query-&gt;where(&#x27;name&#x27;, &#x27;like&#x27;, $term); &#125;); &#125;); &#125;); &#125; Answer:str_getcsv 會把空白隔開的當成一個 value, &quot; 內的也當成一個 value, 再把各個 value 變成 $term 下去 query Laravel 中, 以下的 example code 的意思是？ Example:&lt;?phppublic function show(Feature $feature)&#123; $feature-&gt;load(&#x27;comments.user&#x27;); $feature-&gt;comments-&gt;each-&gt;setRelation(&#x27;feature&#x27;, $feature); return view(&#x27;feature&#x27;, [&#x27;feature&#x27; =&gt; $feature]);&#125; Answer:&lt;?phppublic function show(Feature $feature)&#123; $feature-&gt;load(&#x27;comments.user&#x27;); // 這裡手動的為每個 comments 建立 relation 名為 feature, 代入當前已載入 memory 的 $feature // 如此一來, 在上一行 eager load comments 之後, 每一個 comments 都還會有在上一行已經完成 // eager load 的 feature relation, 那當我們執行 $feature-&gt;comments-&gt;feature-&gt;comments // 時就不會重複 SQL 語法, 也不會重複的加載 model // 當執行 $feature-&gt;comments-&gt;feature-&gt;comments 時, 如果不使用 eager loading, 會有 // n+1 issue, 但如果使用 with(&#x27;comments.feature.comments&#x27;) 的話, 則會 n*n 的加載不必要 // 的 model // 這樣的 relation 又稱為 circular relation $feature-&gt;comments-&gt;each-&gt;setRelation(&#x27;feature&#x27;, $feature); return view(&#x27;feature&#x27;, [&#x27;feature&#x27; =&gt; $feature]);&#125; Laravel 中, 動態 model 的技術概念是？假設 User model 跟 Login model 的 relation 為 hasMany, 但我在取得 User model 時, 我只想要取得最近 login 的 Login model所以先用 subquery 來取得一個虛擬的 column 為 login_id, 這時再用這個 login_id 透過 belongsTo 的 relation 取得單筆 model Laravel 中, 假設今天我想要取得 hasMany relation 中的一筆 record, 這時如果使用 with() 的話會 load 所有的 model, 不使用 with() 的話又會執行很多次 query, 有什麼好的解法？ Example:&lt;?php$users = User::query() -&gt;with(&#x27;login&#x27;) -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); Answer:&lt;?php// 使用 subquery, 從 hasMany relation 中只 query 出我們要的那筆資料, 再將這筆資料變成主 query 中的一個 column$users = User::query() -&gt;addSelect([&#x27;last_login_at&#x27; =&gt; Login::select(&#x27;created_at&#x27;) -&gt;whereColumn(&#x27;user_id&#x27;, &#x27;users.id&#x27;) -&gt;latest() -&gt;take(1) ]) -&gt;orderBy(&#x27;name&#x27;) -&gt;paginate(); Laravel 中, 如果使用 composer 安裝套件時, 超過容許的 memory 限制, 可以使用哪個 flag 讓容許 memory 無上限？COMPOSER_MEMORY_LIMIT=-1 安裝完新的 PHP Extension, 記得要做些什麼事？重啟 PHP, 重啟 Web server, 若使用 valet, 記得重啟 valet 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;use App\\Models\\Installment;... public function payByInstallment(Order $order, Request $request) &#123; // 判断订单是否属于当前用户 $this-&gt;authorize(&#x27;own&#x27;, $order); // 订单已支付或者已关闭 if ($order-&gt;paid_at || $order-&gt;closed) &#123; throw new InvalidRequestException(&#x27;订单状态不正确&#x27;); &#125; // 订单不满足最低分期要求 if ($order-&gt;total_amount &lt; config(&#x27;app.min_installment_amount&#x27;)) &#123; throw new InvalidRequestException(&#x27;订单金额低于最低分期金额&#x27;); &#125; // 校验用户提交的还款月数，数值必须是我们配置好费率的期数 $this-&gt;validate($request, [ &#x27;count&#x27; =&gt; [&#x27;required&#x27;, Rule::in(array_keys(config(&#x27;app.installment_fee_rate&#x27;)))], ]); // 删除同一笔商品订单发起过其他的状态是未支付的分期付款，避免同一笔商品订单有多个分期付款 Installment::query() -&gt;where(&#x27;order_id&#x27;, $order-&gt;id) -&gt;where(&#x27;status&#x27;, Installment::STATUS_PENDING) -&gt;delete(); $count = $request-&gt;input(&#x27;count&#x27;); // 创建一个新的分期付款对象 $installment = new Installment([ // 总本金即为商品订单总金额 &#x27;total_amount&#x27; =&gt; $order-&gt;total_amount, // 分期期数 &#x27;count&#x27; =&gt; $count, // 从配置文件中读取相应期数的费率 &#x27;fee_rate&#x27; =&gt; config(&#x27;app.installment_fee_rate&#x27;)[$count], // 从配置文件中读取当期逾期费率 &#x27;fine_rate&#x27; =&gt; config(&#x27;app.installment_fine_rate&#x27;), ]); $installment-&gt;user()-&gt;associate($request-&gt;user()); $installment-&gt;order()-&gt;associate($order); $installment-&gt;save(); // 第一期的还款截止日期为明天凌晨 0 点 $dueDate = Carbon::tomorrow(); // 计算每一期的本金 $base = big_number($order-&gt;total_amount)-&gt;divide($count)-&gt;getValue(); // 计算每一期的手续费 $fee = big_number($base)-&gt;multiply($installment-&gt;fee_rate)-&gt;divide(100)-&gt;getValue(); // 根据用户选择的还款期数，创建对应数量的还款计划 for ($i = 0; $i &lt; $count; $i++) &#123; // 最后一期的本金需要用总本金减去前面几期的本金 if ($i === $count - 1) &#123; $base = big_number($order-&gt;total_amount)-&gt;subtract(big_number($base)-&gt;multiply($count - 1)); &#125; $installment-&gt;items()-&gt;create([ &#x27;sequence&#x27; =&gt; $i, &#x27;base&#x27; =&gt; $base, &#x27;fee&#x27; =&gt; $fee, &#x27;due_date&#x27; =&gt; $dueDate, ]); // 还款截止日期加 30 天 $dueDate = $dueDate-&gt;copy()-&gt;addDays(30); &#125; return $installment; &#125;... Answer:分期付款的 example 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Services;use App\\Models\\Category;class CategoryService&#123; // 这是一个递归方法 // $parentId 参数代表要获取子类目的父类目 ID，null 代表获取所有根类目 // $allCategories 参数代表数据库中所有的类目，如果是 null 代表需要从数据库中查询 public function getCategoryTree($parentId = null, $allCategories = null) &#123; if (is_null($allCategories)) &#123; // 从数据库中一次性取出所有类目 $allCategories = Category::all(); &#125; return $allCategories // 从所有类目中挑选出父类目 ID 为 $parentId 的类目 -&gt;where(&#x27;parent_id&#x27;, $parentId) // 遍历这些类目，并用返回值构建一个新的集合 -&gt;map(function (Category $category) use ($allCategories) &#123; $data = [&#x27;id&#x27; =&gt; $category-&gt;id, &#x27;name&#x27; =&gt; $category-&gt;name]; // 如果当前类目不是父类目，则直接返回 if (!$category-&gt;is_directory) &#123; return $data; &#125; // 否则递归调用本方法，将返回值放入 children 字段中 $data[&#x27;children&#x27;] = $this-&gt;getCategoryTree($category-&gt;id, $allCategories); return $data; &#125;); &#125;&#125; Answer:使用遞迴, 將資料庫中多層 category 的結構, 撈出並組成 multi array 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\Category;... public function index(Request $request) &#123; $builder = Product::query()-&gt;where(&#x27;on_sale&#x27;, true); if ($search = $request-&gt;input(&#x27;search&#x27;, &#x27;&#x27;)) &#123; . . . &#125; // 如果有传入 category_id 字段，并且在数据库中有对应的类目 if ($request-&gt;input(&#x27;category_id&#x27;) &amp;&amp; $category = Category::find($request-&gt;input(&#x27;category_id&#x27;))) &#123; // 如果这是一个父类目 if ($category-&gt;is_directory) &#123; // 则筛选出该父类目下所有子类目的商品 $builder-&gt;whereHas(&#x27;category&#x27;, function ($query) use ($category) &#123; // 这里的逻辑参考本章第一节 $query-&gt;where(&#x27;path&#x27;, &#x27;like&#x27;, $category-&gt;path.$category-&gt;id.&#x27;-%&#x27;); &#125;); &#125; else &#123; // 如果这不是一个父类目，则直接筛选此类目下的商品 $builder-&gt;where(&#x27;category_id&#x27;, $category-&gt;id); &#125; &#125; . . . &#125;... Answer:使用 path string 來取得所有 children rows 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse App\\Models\\Category;use Illuminate\\Database\\Seeder;class CategoriesSeeder extends Seeder&#123; public function run() &#123; $categories = [ [ &#x27;name&#x27; =&gt; &#x27;手机配件&#x27;, &#x27;children&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;手机壳&#x27;], [&#x27;name&#x27; =&gt; &#x27;贴膜&#x27;], [&#x27;name&#x27; =&gt; &#x27;存储卡&#x27;], [&#x27;name&#x27; =&gt; &#x27;数据线&#x27;], [&#x27;name&#x27; =&gt; &#x27;充电器&#x27;], [ &#x27;name&#x27; =&gt; &#x27;耳机&#x27;, &#x27;children&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;有线耳机&#x27;], [&#x27;name&#x27; =&gt; &#x27;蓝牙耳机&#x27;], ], ], ], ], [ &#x27;name&#x27; =&gt; &#x27;电脑配件&#x27;, &#x27;children&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;显示器&#x27;], [&#x27;name&#x27; =&gt; &#x27;显卡&#x27;], [&#x27;name&#x27; =&gt; &#x27;内存&#x27;], [&#x27;name&#x27; =&gt; &#x27;CPU&#x27;], [&#x27;name&#x27; =&gt; &#x27;主板&#x27;], [&#x27;name&#x27; =&gt; &#x27;硬盘&#x27;], ], ], [ &#x27;name&#x27; =&gt; &#x27;电脑整机&#x27;, &#x27;children&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;笔记本&#x27;], [&#x27;name&#x27; =&gt; &#x27;台式机&#x27;], [&#x27;name&#x27; =&gt; &#x27;平板电脑&#x27;], [&#x27;name&#x27; =&gt; &#x27;一体机&#x27;], [&#x27;name&#x27; =&gt; &#x27;服务器&#x27;], [&#x27;name&#x27; =&gt; &#x27;工作站&#x27;], ], ], [ &#x27;name&#x27; =&gt; &#x27;手机通讯&#x27;, &#x27;children&#x27; =&gt; [ [&#x27;name&#x27; =&gt; &#x27;智能机&#x27;], [&#x27;name&#x27; =&gt; &#x27;老人机&#x27;], [&#x27;name&#x27; =&gt; &#x27;对讲机&#x27;], ], ], ]; foreach ($categories as $data) &#123; $this-&gt;createCategory($data); &#125; &#125; protected function createCategory($data, $parent = null) &#123; // 创建一个新的类目对象 $category = new Category([&#x27;name&#x27; =&gt; $data[&#x27;name&#x27;]]); // 如果有 children 字段则代表这是一个父类目 $category-&gt;is_directory = isset($data[&#x27;children&#x27;]); // 如果有传入 $parent 参数，代表有父类目 if (!is_null($parent)) &#123; $category-&gt;parent()-&gt;associate($parent); &#125; // 保存到数据库 $category-&gt;save(); // 如果有 children 字段并且 children 字段是一个数组 if (isset($data[&#x27;children&#x27;]) &amp;&amp; is_array($data[&#x27;children&#x27;])) &#123; // 遍历 children 字段 foreach ($data[&#x27;children&#x27;] as $child) &#123; // 递归调用 createCategory 方法，第二个参数即为刚刚创建的类目 $this-&gt;createCategory($child, $category); &#125; &#125; &#125;&#125; Answer:使用遞迴來儲存 nested 階層 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class Category extends Model&#123; protected $fillable = [&#x27;name&#x27;, &#x27;is_directory&#x27;, &#x27;level&#x27;, &#x27;path&#x27;]; protected $casts = [ &#x27;is_directory&#x27; =&gt; &#x27;boolean&#x27;, ]; protected static function boot() &#123; parent::boot(); // 监听 Category 的创建事件，用于初始化 path 和 level 字段值 static::creating(function (Category $category) &#123; // 如果创建的是一个根类目 if (is_null($category-&gt;parent_id)) &#123; // 将层级设为 0 $category-&gt;level = 0; // 将 path 设为 - $category-&gt;path = &#x27;-&#x27;; &#125; else &#123; // 将层级设为父类目的层级 + 1 $category-&gt;level = $category-&gt;parent-&gt;level + 1; // 将 path 值设为父类目的 path 追加父类目 ID 以及最后跟上一个 - 分隔符 $category-&gt;path = $category-&gt;parent-&gt;path.$category-&gt;parent_id.&#x27;-&#x27;; &#125; &#125;); &#125; public function parent() &#123; return $this-&gt;belongsTo(Category::class); &#125; public function children() &#123; return $this-&gt;hasMany(Category::class, &#x27;parent_id&#x27;); &#125; public function products() &#123; return $this-&gt;hasMany(Product::class); &#125; // 定义一个访问器，获取所有祖先类目的 ID 值 public function getPathIdsAttribute() &#123; // trim($str, &#x27;-&#x27;) 将字符串两端的 - 符号去除 // explode() 将字符串以 - 为分隔切割为数组 // 最后 array_filter 将数组中的空值移除 return array_filter(explode(&#x27;-&#x27;, trim($this-&gt;path, &#x27;-&#x27;))); &#125; // 定义一个访问器，获取所有祖先类目并按层级排序 public function getAncestorsAttribute() &#123; return Category::query() // 使用上面的访问器获取所有祖先类目 ID -&gt;whereIn(&#x27;id&#x27;, $this-&gt;path_ids) // 按层级排序 -&gt;orderBy(&#x27;level&#x27;) -&gt;get(); &#125; // 定义一个访问器，获取以 - 为分隔的所有祖先类目名称以及当前类目的名称 public function getFullNameAttribute() &#123; return $this-&gt;ancestors // 获取所有祖先类目 -&gt;pluck(&#x27;name&#x27;) // 取出所有祖先类目的 name 字段作为一个数组 -&gt;push($this-&gt;name) // 将当前类目的 name 字段值加到数组的末尾 -&gt;implode(&#x27; - &#x27;); // 用 - 符号将数组的值组装成一个字符串 &#125;&#125; Answer:使用 path 字串來快速取得 parent 以及 children 以下的 Laravel example code 的意思是？ Example:foreach ( [&#x27;status&#x27;, &#x27;system_order_number&#x27;, &#x27;order_number&#x27;, &#x27;user_card_number&#x27;, &#x27;system_card_number&#x27;] as $availableFilterKey) &#123; $deposits-&gt;when($request-&gt;&#123;$availableFilterKey&#125;, function (Builder $builder, $filterValue) use ($availableFilterKey) &#123; $builder-&gt;where($availableFilterKey, $filterValue); &#125;);&#125; Answer:foreach 依序 loop array 當中的每一個 value$availableFilterKey 這裡表示 array 當中的 valuewhen 表示條件句, [boolean, executeIfTrue, executeIfFalse]$builder 代表 $deposit$filterValue 代表 $request-&gt;availableFilterKey 在 Laravel 中, 如何取得 query builder?$query = yourModel::query(); 在 Laravel 中, ** 代表什麼意思？power operator, 如果是 2 ** 16, 代表 2 * 2 * .. 16 次 在 Laravel 中, 如何取得 parent 的 method?# 如果沒複寫, 直接呼叫即可$this-&gt;method# 如果有複寫, 也是直接呼叫$this-&gt;method# 除非你有複寫, 但你要沒複寫的版本parent::method參考出處： https://stackoverflow.com/questions/11237511/multiple-ways-of-calling-parent-method-in-php 資料庫欄位 int, 什麼是 signed 跟 unsigned?signed 的數值範圍橫跨正負數, unsigned 只有正數, 且為 signed 的兩倍, 但最小的負數為 0可參考文件如下： https://dev.mysql.com/doc/refman/8.0/en/integer-types.html Laravel 中, 什麼是 coroutine?像是 thread, 但不會 context switching, 因為 OS 並不知道它的存在, 所以當 Library support non-blocking I/O 時, I/O bound work 可以 run concurrently, CPU bound work 還是 synchronously (因為每一個 process 被分配到的 CPU usage 是相同的)","link":"/zh-tw/laravel/"},{"title":"Laravel - EloquentORM - Relationships","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Defining Relationships# One To One在 Laravel relationship 當中, 如何建立一個 one to one relation?&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * Get the phone record associated with the user. */ public function phone() &#123; return $this-&gt;hasOne(&#x27;App\\Phone&#x27;); &#125;&#125; Laravel hasOne relationship 當中, 預設 foreign key 的條件是什麼？model name Laravel hasOne relationship 當中, 如果我要自定義 foreign key, 我可以怎麼做？&lt;?phpreturn $this-&gt;hasOne(&#x27;App\\Phone&#x27;, &#x27;foreign_key&#x27;); Laravel hasOne relationship 當中, 預設 foreign key 的值需要對應 parent table 上的哪一個 column 的值?id 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $this-&gt;hasOne(&#x27;App\\Phone&#x27;, &#x27;foreign_key&#x27;, &#x27;local_key&#x27;); Answer:自定義要使用哪個 owner table 與 foreign table 上的 key 來做連結, local_key 代表在 owner table, 即 $this, 上的 column name, foreign_key 代表在 ‘App\\Phone’ table 上的 column # Defining The Inverse Of The RelationshipLaravel one to one relationship 中, 如何定義反向的存取?&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Phone extends Model&#123; /** * Get the user that owns the phone. */ public function user() &#123; return $this-&gt;belongsTo(&#x27;App\\User&#x27;); &#125;&#125; Laravel one to one relationship 中, 預設定義 belongsTo 的 foreign key 的規則是？根據 belongsTo method 的名稱, 在 method 名稱後加上 _id Laravel one to one relationship 中, 如何自訂義 foreign key?&lt;?php/** * Get the user that owns the phone. */public function user()&#123; return $this-&gt;belongsTo(&#x27;App\\User&#x27;, &#x27;foreign_key&#x27;);&#125; Laravel one to one relationship 當中, 在 belongsTo method 當中, 如果我的 parent table 不是使用 id 作為 primary key, 而我想要自定義, 我可以怎麼做？&lt;?php/** * Get the user that owns the phone. */public function user()&#123; return $this-&gt;belongsTo(&#x27;App\\User&#x27;, &#x27;foreign_key&#x27;, &#x27;other_key&#x27;);&#125; # One To ManyLaravel one to many relationship 中, 如果我要建立一個 one to many 的 relation, 我可以怎麼做？&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get the comments for the blog post. */ public function comments() &#123; return $this-&gt;hasMany(&#x27;App\\Comment&#x27;); &#125;&#125; 以下的 relation 中, foreign key 預設是什麼？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; public function comments() &#123; return $this-&gt;hasMany(&#x27;App\\Comment&#x27;); &#125;&#125; Answer:post_id, 預設, Laravel 會在擁有者 model 使用 “snake_case”, 並在最後加上 _id Laravel one to many relationship 中, 如何取得 relation？&lt;?php$comments = App\\Post::find(1)-&gt;comments;foreach ($comments as $comment) &#123; //&#125; Laravel one to many relationship 中, 如何取得 relation 的 query builder？&lt;?php$comment = App\\Post::find(1)-&gt;comments()-&gt;where(&#x27;title&#x27;, &#x27;foo&#x27;)-&gt;first(); 以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $this-&gt;hasMany(&#x27;App\\Comment&#x27;, &#x27;foreign_key&#x27;);return $this-&gt;hasMany(&#x27;App\\Comment&#x27;, &#x27;foreign_key&#x27;, &#x27;local_key&#x27;); Answer:定義 one to many relation 時, 指定 foreign_key 以及 local_key # One To Many (Inverse)Laravel one to many relation 中, 如何定義一個反向的 relation?&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * Get the post that owns the comment. */ public function post() &#123; return $this-&gt;belongsTo(&#x27;App\\Post&#x27;); &#125;&#125; Laravel one to many relationship 中, 如何自訂義 foreign key 以及 primary key?&lt;?php/** * Get the post that owns the comment. */public function post()&#123; return $this-&gt;belongsTo(&#x27;App\\Post&#x27;, &#x27;foreign_key&#x27;, &#x27;other_key&#x27;);&#125; # Many To ManyLaravel Relationship 中, 當我要建立一個 many to many 的中間表格, 表格的命名是什麼規格？alphabetical Laravel Relationship 中, 當我要建立一個 users, roles 的 many to many 的中間表格, 中間表格必須至少有什麼 column？user_id, role_id Laravel Relationship 中, 當我要建立一個 users, roles 的 many to many 的 relationship, 在 User 的 model 中, 我可以怎麼做？&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;); &#125;&#125; 承上面 Laravel 程式碼, 在 Laravel Relationship 中, 如果我已經在 User 跟 Role model 之間建立了 many to many relationship, 當我想要從 user model 取 roles, 我可以怎麼做？&lt;?php$user = App\\User::find(1);foreach ($user-&gt;roles as $role) &#123; //&#125; 承上面 Laravel 程式碼, 在 Laravel Relationship 中, 如果我已經在 User 跟 Role model 之間建立了 many to many relationship, 當我想要取 roles 並 chain query 時, 我可以怎麼做？&lt;?php$roles = App\\User::find(1)-&gt;roles()-&gt;orderBy(&#x27;name&#x27;)-&gt;get(); 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function roles() &#123; return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;, &#x27;table_name&#x27;); &#125;&#125; Answer:定義 User belongsTo Role relation, 並指定 pivot table 為 ‘table_name’ 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function roles() &#123; return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;, &#x27;role_user&#x27;, &#x27;currentModel&#x27;, &#x27;joiningToModel&#x27;); &#125;&#125; Answer:定義 pivot table name, pivot table 上代表 current model 的 column 以及 foreign model 上的 column 在 Laravel many to many relationship 中, 如果我想要自定義中間表格中 column 的名稱, 我可以怎麼做？ # Retrieving Intermediate Table Columns在 Laravel many to many relationship 中, 如果我想要取得中間表格的資料, 我可以怎麼做？&lt;?php$user = App\\User::find(1);foreach ($user-&gt;roles as $role) &#123; echo $role-&gt;pivot-&gt;created_at;&#125; 在 Laravel many to many relationship 中, 當我取得 related model, related model 預設會載入中間 model 嗎？會哦 在 Laravel many to many relationship 中, 當我取得 related model, 自動載入的中間 model 預設只會有什麼資料？model key 在 Laravel many to many relationship 中, 當我取得 related model, 自動載入的中間 model 預設只會有 model key, 如果我想要讓他自動載入時自動載入其他特定 column 的資料, 我可以怎麼做？&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;withPivot(&#x27;column1&#x27;, &#x27;column2&#x27;); &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function roles() &#123; return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;withTimestamps(); &#125;&#125; Answer:使用 withTimestamps method, Model User 與 Model Role 的 many to many relationship 的 pivot table 上的 created_at 以及 updated_at 會被自動維護 # Customizing The pivot Attribute Name以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function roles() &#123; return $this-&gt;belongsToMany(&#x27;App\\Podcast&#x27;) -&gt;as(&#x27;subscription&#x27;) -&gt;withTimestamps(); &#125;&#125; Answer:定義 pivot table name 為 subscription, 且自動維護 pivot table 的 created_at 以及 updated_at 呈上, 如何存取這個 subscription 中間表格？&lt;?php$users = User::with(&#x27;podcasts&#x27;)-&gt;get();foreach ($users-&gt;flatMap-&gt;podcasts as $podcast) &#123; echo $podcast-&gt;subscription-&gt;created_at;&#125; # Filtering Relationships Via Intermediate Table Columns以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;wherePivot(&#x27;approved&#x27;, 1);return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;wherePivotIn(&#x27;priority&#x27;, [1, 2]);return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;wherePivotNotIn(&#x27;priority&#x27;, [1, 2]); Answer:&lt;?php// 定義了 $this 與 &#x27;App\\Role&#x27; 的 belongsToMany relationship// 除了 primary key 與 foreign key 條件符合之外// 還需 wherePivot(&#x27;approved&#x27;, 1) 的條件滿足, 才算是此 relationship 的範圍return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;wherePivot(&#x27;approved&#x27;, 1);// 還需 wherePivotIn(&#x27;priority&#x27;, [1, 2]) 的條件滿足, 才算是此 relationship 的範圍return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;wherePivotIn(&#x27;priority&#x27;, [1, 2]);// 還需 wherePivotNotIn(&#x27;priority&#x27;, [1, 2]) 的條件滿足, 才算是此 relationship 的範圍return $this-&gt;belongsToMany(&#x27;App\\Role&#x27;)-&gt;wherePivotNotIn(&#x27;priority&#x27;, [1, 2]); # Defining Custom Intermediate Table Models以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Role extends Model&#123; public function users() &#123; return $this-&gt;belongsToMany(&#x27;App\\User&#x27;)-&gt;using(&#x27;App\\RoleUser&#x27;); &#125;&#125; Answer:在定義 many to many relation 的同時, 指定 pivot Model 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Role extends Model&#123; public function users() &#123; return $this-&gt;belongsToMany(&#x27;App\\User&#x27;) -&gt;using(&#x27;App\\RoleUser&#x27;) -&gt;withPivot([ &#x27;created_by&#x27;, &#x27;updated_by&#x27;, ]); &#125;&#125; Answer:在定義 Role belongsToMany User 的 relation 的同時, 指定 pivot table, 且指定 pivot table 上預設載入 ‘created_by’, 以及 ‘updated_by’ column Laravel many to many relation 中, pivot model 可以使用 SoftDeletes trait 嗎？不行哦 # Custom Pivot Models And Incrementing IDsLaravel many to many relation 中, 為了讓 table 中的 primary key 運作正常, pivot model 中需要加什麼屬性？&lt;?php/** * Indicates if the IDs are auto-incrementing. * * @var bool */public $incrementing = true; # Has One Through以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Supplier extends Model&#123; public function userHistory() &#123; return $this-&gt;hasOneThrough(&#x27;App\\History&#x27;, &#x27;App\\User&#x27;); &#125;&#125; Answer:Supplier hasOne User, 而 User hasOne History, 第一個參數為 目標 model, 第二個參數為 中間 model, 定義好後可從 Supplier 直接取得 History model 以下的 Laravel example code 的意思是？ Example:&lt;?phpSupplier extends Model&#123; public function userHistory() &#123; return $this-&gt;hasOneThrough( &#x27;App\\History&#x27;, &#x27;App\\User&#x27;, &#x27;supplier_id&#x27;, // Foreign key on users table... &#x27;user_id&#x27;, // Foreign key on history table... &#x27;id&#x27;, // Local key on suppliers table... &#x27;id&#x27; // Local key on users table... ); &#125;&#125; Answer:使用 hasOneThrough relation, 並定義 local key 以及 foreign key # Has Many Through以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Country extends Model&#123; public function posts() &#123; return $this-&gt;hasManyThrough(&#x27;App\\Post&#x27;, &#x27;App\\User&#x27;); &#125;&#125; Answer:Country hasOne User, 而 User hasOne Post, 第一個參數為 目標 model, 第二個參數為 中間 model, 定義好後可從 Country 直接取得 Post model 在 Laravel one to many through method 中, 如果我要自定義 foreign key 以及 local key, 我可以怎麼做？&lt;?phpclass Country extends Model&#123; public function posts() &#123; return $this-&gt;hasManyThrough( &#x27;App\\Post&#x27;, &#x27;App\\User&#x27;, &#x27;country_id&#x27;, // Foreign key on users table... &#x27;user_id&#x27;, // Foreign key on posts table... &#x27;id&#x27;, // Local key on countries table... &#x27;id&#x27; // Local key on users table... ); &#125;&#125; # Polymorphic Relationships# One To One (Polymorphic)# Table Structure在 Laravel 中, 如果說我有一個 image model, 而 user model 跟 post model 都跟 image 有 one to one 的關係, 那我可以使用什麼樣的 relation?One To One (Polymorphic) 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; public function image() &#123; return $this-&gt;morphOne(&#x27;App\\Image&#x27;, &#x27;imageable&#x27;); &#125;&#125; Answer:每個 Post 都有一個 Image, 而其他的 model 也可能會用到 Image, 因此使用 polymorphic one to one relation Laravel 中, 假設我的 Post model 有一個 Image model, 而 User model 也有一個 Image model, 現在我要定義 one to one (polymorphic) relation, 若要在 Post model 中定義與 Image model 的關係, 可以怎麼做？以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; public function image() &#123; return $this-&gt;morphOne(&#x27;App\\Image&#x27;, &#x27;imageable&#x27;); &#125;&#125; Answer:User hasOne Image, 而其他 model 也有 hasOne Image relationship, 這樣就可以使用 morph relation, 可以共用一個 images table, Image model 的不同 relation 會在 ‘imageable_type’ 做區分, 例如 ‘App\\User’ 或是 ‘App\\Post’ 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Image extends Model&#123; public function imageable() &#123; return $this-&gt;morphTo(); &#125;&#125; Answer:定義一個 polymorphic one to one 的 relation, Image model 可同時 belongs to 一個以上的 model 以下的 Laravel one to one (Polymorphic) relation table structure 當中, imageable_id 跟 imageable_type 分別代表什麼？ Example:posts id - integer name - stringusers id - integer name - stringimages id - integer url - string imageable_id - integer imageable_type - string Answer: imageable_id: user_id 或 post_idimageable_type: user model name 或 post model name # Retrieving The Relationship在 Laravel one to one (Polymorphic) relation 當中, 假設以下為我的 relation 定義, 如果我要從 parent model 拿到 child model, 那我可以怎麼做？ Relation 定義:&lt;?phpclass Post extends Model&#123; public function image() &#123; return $this-&gt;morphOne(&#x27;App\\Image&#x27;, &#x27;imageable&#x27;); &#125;&#125; 取得 relation:&lt;?php$post = App\\Post::find(1);$image = $post-&gt;image; 在 Laravel one to one (Polymorphic) relation 當中, 假設以下為我的 relation 定義, 如果我要從 child model 取得 parent model, 我可以怎麼做？ Relation 定義：&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Image extends Model&#123; /** * Get the owning imageable model. */ public function imageable() &#123; return $this-&gt;morphTo(); &#125;&#125; 取得 relation&lt;?php$image = App\\Image::find(1);$imageable = $image-&gt;imageable; # One To Many (Polymorphic)# Table StructureLaravel 當中, 如果說在我的應用中的 user 可以同時在 video 以及 post 中留下 comments, 那我可以使用怎麼樣的 relation?one to many (Polymorphic) Laravel one to many (Polymorphic) 當中, 以下的 table structure 中的 commentable_id 以及 commentable_type 代表什麼？posts id - integer title - string body - textvideos id - integer title - string url - stringcomments id - integer body - text commentable_id - integer commentable_type - string commentable_id: 代表 foreign key commentable_type: 代表 relation 的 model name # Model StructureLaravel 當中, 假設每一個 Video model 以及 Post model 都有多個 Comment model, 現在我要定義一個 one to many (polymorphic) relation, 若要從 Video model 中定義與 Comment model 的 relation, 可以怎麼做？&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Video extends Model&#123; /** * Get all of the video&#x27;s comments. */ public function comments() &#123; return $this-&gt;morphMany(&#x27;App\\Comment&#x27;, &#x27;commentable&#x27;); &#125;&#125; Laravel 當中, 假設每一個 Video model 以及 Post model 都有多個 Comment model, 現在我要定義一個 one to many (polymorphic) relation, 若要從 Post model 中定義與 Comment model 的 relation, 可以怎麼做？&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get all of the post&#x27;s comments. */ public function comments() &#123; return $this-&gt;morphMany(&#x27;App\\Comment&#x27;, &#x27;commentable&#x27;); &#125;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; public function commentable() &#123; return $this-&gt;morphTo(); &#125;&#125; Answer:Comment model 同時與一個以上的 model 有 belongsTo 的 relation, 所以可以使用 polymorphic relation, 當使用 commentable relation 時, 會經由 commentable_type 以及 commentable_id 取得相對應的 relational model 以及 id # Retrieving The RelationshipLaravel one to many (Polymorphic) relation 當中, 如果我要從 parent model 取得 child model, 我可以怎麼做？ 假設以下為我的 relation 定義 Relation 定義：&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * Get the owning commentable model. */ public function commentable() &#123; return $this-&gt;morphTo(); &#125;&#125;class Post extends Model&#123; /** * Get all of the post&#x27;s comments. */ public function comments() &#123; return $this-&gt;morphMany(&#x27;App\\Comment&#x27;, &#x27;commentable&#x27;); &#125;&#125;class Video extends Model&#123; /** * Get all of the video&#x27;s comments. */ public function comments() &#123; return $this-&gt;morphMany(&#x27;App\\Comment&#x27;, &#x27;commentable&#x27;); &#125;&#125; 取得 relation&lt;?php$post = App\\Post::find(1);foreach ($post-&gt;comments as $comment) &#123; //&#125; 在 Laravel one to many (Polymorphic) relation 當中, 假設以下為我的 relation 定義, 現在我要從 child model 取得 parent model, 那我可以怎麼做？ relation 定義：&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * Get the owning commentable model. */ public function commentable() &#123; return $this-&gt;morphTo(); &#125;&#125;class Post extends Model&#123; /** * Get all of the post&#x27;s comments. */ public function comments() &#123; return $this-&gt;morphMany(&#x27;App\\Comment&#x27;, &#x27;commentable&#x27;); &#125;&#125;class Video extends Model&#123; /** * Get all of the video&#x27;s comments. */ public function comments() &#123; return $this-&gt;morphMany(&#x27;App\\Comment&#x27;, &#x27;commentable&#x27;); &#125;&#125; 取得 relation&lt;?php$comment = App\\Comment::find(1);$commentable = $comment-&gt;commentable; # Many To Many (Polymorphic)# Table Structure在 Laravel many to many (Polymorphic) relation 當中, 假如說我有 video 跟 post model, 而兩者都跟 tag model 有 many to many 的關係, 那我可以怎樣定義我的 table?posts id - integer name - stringvideos id - integer name - stringtags id - integer name - stringtaggables tag_id - integer taggable_id - integer taggable_type - string # Model Structure以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; public function tags() &#123; return $this-&gt;morphToMany(&#x27;App\\Tag&#x27;, &#x27;taggable&#x27;); &#125;&#125; Answer:定義 Post model 跟 Tag model 之間 polymorphic many to many relation試想, 一篇 post 可以有多個 tags, 而我也可以經由一個 tag 取得多個 posts, 這樣就構成 many to many relationship同時, 一部 video 可以有多個 tags, 而我也可以經由一個 tag 取得多部 video, 這樣也構成 many to many relationship那我需要建立兩個 tags table 以及兩個 pivot table 嗎？ 可以使用 polyMorphic many to many relation, 這樣只需要一個 tags table 以及一個 pivot table 就夠了 # Defining The Inverse Of The Relationship以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Tag extends Model&#123; public function posts() &#123; return $this-&gt;morphedByMany(&#x27;App\\Post&#x27;, &#x27;taggable&#x27;); &#125; public function videos() &#123; return $this-&gt;morphedByMany(&#x27;App\\Video&#x27;, &#x27;taggable&#x27;); &#125;&#125; Answer:定義 tags 分別與 videos 以及 posts table 之間的 polymorphic many to many relationship試想, 一篇 post 可以有多個 tags, 而我也可以經由一個 tag 取得多個 posts, 這樣就構成 many to many relationship同時, 一部 video 可以有多個 tags, 而我也可以經由一個 tag 取得多部 video, 這樣也構成 many to many relationship那我需要建立兩個 tags table 以及兩個 pivot table 嗎？ 可以使用 polyMorphic many to many relation, 這樣只需要一個 tags table 以及一個 pivot table 就夠了 在 Laravel many to many polymorphic relation 當中, 假如我有 Post 跟 Video model, 而兩者都與 Tag model 有 many to many 的 relationship, 現在我要在 Tag 定義 many to many polymorphic relation, 我可以怎麼做？ # Retrieving The RelationshipLaravel many to many polymorphic relationship 當中, 如果我的 relation 定義如下, 現在我要從 Post model 取得 Tag relation, 我該怎麼做？ Relation 定義:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get all of the tags for the post. */ public function tags() &#123; return $this-&gt;morphToMany(&#x27;App\\Tag&#x27;, &#x27;taggable&#x27;); &#125;&#125; Answer:&lt;?php$post = App\\Post::find(1);foreach ($post-&gt;tags as $tag) &#123; //&#125; Laravel many to many polymorphic relationship 當中, 如果我的 relation 定義如下, 現在我要從 Tag model 取得 Post relation, 我該怎麼做？ Relation 定義：&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Tag extends Model&#123; /** * Get all of the posts that are assigned this tag. */ public function posts() &#123; return $this-&gt;morphedByMany(&#x27;App\\Post&#x27;, &#x27;taggable&#x27;); &#125; /** * Get all of the videos that are assigned this tag. */ public function videos() &#123; return $this-&gt;morphedByMany(&#x27;App\\Video&#x27;, &#x27;taggable&#x27;); &#125;&#125; Answer:&lt;?php$tag = App\\Tag::find(1);foreach ($tag-&gt;videos as $video) &#123; //&#125; # Custom Polymorphic Types在 Laravel polymorphic relationship 當中, 預設 commentable_type 的內容會是像什麼樣的？model 的名稱, 像是 App\\Post 或是 App\\Video 在 Laravel polymorphic relationship 當中, polymorphic 關係的對應預設是依照 polymorphic type column 中的值來對應的, 格式預設是 App/ModelName, 如果我不想要使用這個預設格式, 我想要變更的話, 我可以在什麼地方變更？AppServiceProvider 的 boot function 內 在 Laravel polymorphic relationship 當中, 如果我要在 AppServiceProvider 當中自定義 polymorphic table 中的 type column 的值, 我可以怎麼做？&lt;?phpuse Illuminate\\Database\\Eloquent\\Relations\\Relation;Relation::morphMap([ &#x27;posts&#x27; =&gt; &#x27;App\\Post&#x27;, &#x27;videos&#x27; =&gt; &#x27;App\\Video&#x27;,]); 在 Laravel polymorphic relationship 當中, 如果我在 AppServiceProvider 當中自定義 polymorphic table 中的 type column 的值之後, 原本的 App\\Post 形式的 model 名稱需要依照自定義的名稱做變更嗎？需要哦 # Querying Relations以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$user-&gt;posts() -&gt;where(function (Builder $query) &#123; return $query-&gt;where(&#x27;active&#x27;, 1) -&gt;orWhere(&#x27;votes&#x27;, &#x27;&gt;=&#x27;, 100); &#125;) -&gt;get();// select * from posts// where user_id = ? and (active = 1 or votes &gt;= 100) Answer:使用 where function, 在其 closure 內限制 where constraints 的範圍 # Querying Relationship Existence在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我只要取得至少有一個 Comment 的 Post, 那我可以怎麼做？&lt;?php// Retrieve all posts that have at least one comment...$posts = App\\Post::has(&#x27;comments&#x27;)-&gt;get(); 以下的 Laravel example code 的意思是？ Example:&lt;?php$posts = App\\Post::has(&#x27;comments&#x27;, &#x27;&gt;=&#x27;, 3)-&gt;get(); Answer:取得有 3 個以上 (含 3 個) 的 Post model 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我只要取得有至少一個以上 Comment 的 Post, 且這個 comment 的 content 要含有 ‘foo’, 那我可以怎麼做？&lt;?php// Retrieve posts with at least one comment containing words like foo%...$posts = App\\Post::whereHas(&#x27;comments&#x27;, function (Builder $query) &#123; $query-&gt;where(&#x27;content&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;);&#125;)-&gt;get(); 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我只要取得有十個以上 Comment 的 Post, 且 10 個 Comment 的 content 都要含有 ‘foo’, 那我可以怎麼做？&lt;?php// Retrieve posts with at least ten comments containing words like foo%...$posts = App\\Post::whereHas(&#x27;comments&#x27;, function (Builder $query) &#123; $query-&gt;where(&#x27;content&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;);&#125;, &#x27;&gt;=&#x27;, 10)-&gt;get(); # Querying Relationship Absence在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我要取得沒有任何 comments 的 post, 那我可以怎麼做？&lt;?php$posts = App\\Post::doesntHave(&#x27;comments&#x27;)-&gt;get(); 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::whereDoesntHave(&#x27;comments&#x27;, function (Builder $query) &#123; $query-&gt;where(&#x27;content&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;);&#125;)-&gt;get(); Answer:取得 Post models, 其 comment relation model 的 content 不包含 ‘foo%’ 在 Laravel relationship 中, 假設我有 post, comment, 以及 author Model, 現在我要取得 comment 的 author 未被 banned 的 post (以 post 的 comment 的 author 為條件 query), 那我可以怎麼做？&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::whereDoesntHave(&#x27;comments.author&#x27;, function (Builder $query) &#123; $query-&gt;where(&#x27;banned&#x27;, 1);&#125;)-&gt;get(); # Querying Polymorphic Relationships以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;// Retrieve comments associated to posts or videos with a title like foo%...$comments = App\\Comment::whereHasMorph( &#x27;commentable&#x27;, [&#x27;App\\Post&#x27;, &#x27;App\\Video&#x27;], function (Builder $query) &#123; $query-&gt;where(&#x27;title&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;); &#125;)-&gt;get(); Answer:取得 polymorphic many to many relation 的 Post, Video relation, 並從中篩選 title 含有 ‘foo%’ 的 model 在 Laravel polymorphic relationship 當中, 假如 Post 與 Video Model 都有多個 Comment Model, 現在我要取得 comment, 所屬的 video 或 post 的 title 含有 foo%, 那我可以怎麼做？Laravel 中, 如果今天我的 Comment model 與 video 以及 post 有 polymorphic 的 relation, 那我想要取得 comment, 且該 comment 所屬的 post 的 title 不可含有 foo, 那我可以怎麼做？&lt;?php// Retrieve comments associated to posts with a title not like foo%...$comments = App\\Comment::whereDoesntHaveMorph( &#x27;commentable&#x27;, &#x27;App\\Post&#x27;, function (Builder $query) &#123; $query-&gt;where(&#x27;title&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;); &#125;)-&gt;get(); Laravel 中, 假如 Post model, Video model 與 Comment model 有 polymorphic 的關係, 現在我想要取得某些 Comment, 條件是 Video 的 title 必須含有 foo, 而 Post 的 title 或 content 必須含有 foo, 那我可以怎麼做？&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$comments = App\\Comment::whereHasMorph( &#x27;commentable&#x27;, [&#x27;App\\Post&#x27;, &#x27;App\\Video&#x27;], function (Builder $query, $type) &#123; $query-&gt;where(&#x27;title&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;); if ($type === &#x27;App\\Post&#x27;) &#123; $query-&gt;orWhere(&#x27;content&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;); &#125; &#125;)-&gt;get(); 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$comments = App\\Comment::whereHasMorph(&#x27;commentable&#x27;, &#x27;*&#x27;, function (Builder $query) &#123; $query-&gt;where(&#x27;title&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;);&#125;)-&gt;get(); Answer:一次性取得所有的 morph model, 不管我有幾個, 並且從這些 relation 當中搜尋任何 title 含有 foo 的 comment # Counting Relate ModelsLaravel relationship 中, 假設今天我的 Post model 有很多 Comment model, 我想要拿到每個 Post model 下有幾個 Comment model, 那我可以怎麼做？&lt;?php$posts = App\\Post::withCount(&#x27;comments&#x27;)-&gt;get();foreach ($posts as $post) &#123; echo $post-&gt;comments_count;&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::withCount([&#x27;votes&#x27;, &#x27;comments&#x27; =&gt; function (Builder $query) &#123; $query-&gt;where(&#x27;content&#x27;, &#x27;like&#x27;, &#x27;foo%&#x27;);&#125;])-&gt;get();echo $posts[0]-&gt;votes_count;echo $posts[0]-&gt;comments_count; Answer:取出 Post model 的 relation model ‘Votes’, 以及 ‘Comments’ 的數量, 並且, 針對 Comments model 有特別篩選, 條件為 where(‘content, ‘like’, ‘foo%’)載入後, 可在每一個 Post model 使用 ‘votes_count’ 以及 ‘comments_count’ Laravel relationship 中, 當我使用了 withCount method, Laravel 會在取得的 model 中加入哪一個欄位？&#123;relation&#125;_count 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::withCount([ &#x27;comments&#x27;, &#x27;comments as pending_comments_count&#x27; =&gt; function (Builder $query) &#123; $query-&gt;where(&#x27;approved&#x27;, false); &#125;,])-&gt;get();echo $posts[0]-&gt;comments_count;echo $posts[0]-&gt;pending_comments_count; Answer:取得兩種 Post model 的 relation Comment model count, 一個有加特定 constraints, 並 alias 為 pending_comments_count Laravel relationship 中, 假設今天我的 Post model 有 comments 的 relationships, 假如現在我要取得每個 Post 有幾個 comment, 以及我要自定義一個 comment 叫做 pending_comments_count, 條件是該 comment 的 approved 必須是 false, 那我可以怎麼做？Laravel Query Builder 當中, 如果我要同時使用 select 以及 withCount, 哪一種需排在前面？select 以下的 Laravel example code 的意思是？ Example:&lt;?php$posts = App\\Post::select([&#x27;title&#x27;, &#x27;body&#x27;])-&gt;withCount(&#x27;comments&#x27;)-&gt;get();echo $posts[0]-&gt;title;echo $posts[0]-&gt;body;echo $posts[0]-&gt;comments_count; Answer:使用 select() 取得 title, body column使用 withCount() 取得 comments relation 的數量 Laravel 當中, 如果我的 Book model 有很多 genres model relation, 現在我已取得特定的那一個 Book model, 我要再取得所屬的 genres 的數量, 那我可以怎麼做？&lt;?php$book = App\\Book::first();$book-&gt;loadCount(&#x27;genres&#x27;); 以下的 Laravel example code 的意思是？ Example:&lt;?php$book-&gt;loadCount([&#x27;reviews&#x27; =&gt; function ($query) &#123; $query-&gt;where(&#x27;rating&#x27;, 5);&#125;]) Answer:取得 $book 的 Reviews relation model 的數量, 並針對 Reviews model 使用 where(&#39;rating&#39;, 5) 做篩選 # Eager Loading以下的 Laravel 程式碼中, author 為 book model 的 relation, 假設 $books 有 25 個 book model, 那以下的程式碼共會 query 幾次？ 程式碼:&lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; answer:26 次, 取所有的 book model 共花一次, 取各個 model 的 author relation 再花 25 次 Laravel 中, 假設以下為我的原始程式碼, 我要如何使用 eager loading 將所有的 author relation 一次取出? 原始程式碼：&lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; Answer:&lt;?php$books = App\\Book::with(&#x27;author&#x27;)-&gt;get();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; 以下的 Laravel 程式碼中, 實際上下的 MySQL query 是哪兩句？ 程式碼：&lt;?php$books = App\\Book::with(&#x27;author&#x27;)-&gt;get();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; query 語法:select * from booksselect * from authors where id in (1, 2, 3, 4, 5, ...) # Eager Loading Multiple Relationships在以下的 Laravel 程式碼中, 我如果想要一次性的 eager load relations author 跟 publisher, 我可以怎麼做？ 程式碼：&lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; Answer:&lt;?php$books = App\\Book::with([&#x27;author&#x27;, &#x27;publisher&#x27;])-&gt;get(); # Nested Eager Loading以下的 Laravel example code 的意思是？ Example：&lt;?php$books = App\\Book::with(&#x27;author.contacts&#x27;)-&gt;get(); Answer:eager load Book model 的 relation author, 以及 author 的 relation contacts # Nested Eager Loading morphTo Relationships以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Database\\Eloquent\\Relations\\MorphTo;$activities = ActivityFeed::query() -&gt;with([&#x27;parentable&#x27; =&gt; function (MorphTo $morphTo) &#123; $morphTo-&gt;morphWith([ Event::class =&gt; [&#x27;calendar&#x27;], Photo::class =&gt; [&#x27;tags&#x27;], Post::class =&gt; [&#x27;author&#x27;], ]); &#125;])-&gt;get(); Answer: ActivityFood morphTo EventActivityFood morphTo PhotoActivityFood morphTo PostEvent has relation with calendarPhoto has relation with tagsPost has relation with author一次性的從 ActivityFeed eager loading 上面的六個 relationships # Eager Loading Specific Columns在以下的 Laravel 程式碼中, 如果我只想要 eager load author relation 中的 id 以及 name columns, 我可以怎麼做？ 程式碼:&lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; Answer:&lt;?php$books = App\\Book::with(&#x27;author:id,name&#x27;)-&gt;get(); 在 Laravel 當中, 如果說我今天使用 eager loading 來取得部份的 column, 有哪一個 column 是必須的？id # Eager Loading By Default在以下的 Laravel relation definition 當中, 如果說我想要預設 eager load author 這一個 relation, 那我可以怎麼做？ Relation definition:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Book extends Model&#123; /** * Get the author that wrote the book. */ public function author() &#123; return $this-&gt;belongsTo(&#x27;App\\Author&#x27;); &#125;&#125; Answer:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Book extends Model&#123; /** * The relationships that should always be loaded. * * @var array */ protected $with = [&#x27;author&#x27;]; /** * Get the author that wrote the book. */ public function author() &#123; return $this-&gt;belongsTo(&#x27;App\\Author&#x27;); &#125;&#125; 在以下的 Laravel relation definition 當中, 如果說我想要從某次的 query 當中移除 $with 所賦予的 default eager loading 效果, 那我可以怎麼做？ Relation definition:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Book extends Model&#123; protected $with = [&#x27;author&#x27;]; public function author() &#123; return $this-&gt;belongsTo(&#x27;App\\Author&#x27;); &#125;&#125; Answer:&lt;?php$books = App\\Book::without(&#x27;author&#x27;)-&gt;get(); # Constraining Eager Loads在以下的 Laravel eager loading 範例程式碼中, 如果我想要指定 eager load title 含有 first 的 posts model, 那我可以怎麼做？ 範例程式碼:&lt;?php$users = App\\User::with(&#x27;posts&#x27;)-&gt;get(); Answer:&lt;?php$users = App\\User::with([&#x27;posts&#x27; =&gt; function ($query) &#123; $query-&gt;where(&#x27;title&#x27;, &#x27;like&#x27;, &#x27;%first%&#x27;);&#125;])-&gt;get(); 在以下的 Laravel 範例程式碼中, 我可以加入額外的 query builder method 嗎？ 範例程式碼:&lt;?php$users = App\\User::with([&#x27;posts&#x27; =&gt; function ($query) &#123; $query-&gt;where(&#x27;title&#x27;, &#x27;like&#x27;, &#x27;%first%&#x27;);&#125;])-&gt;get(); Answer:可以 Laravel eager loading constrain 當中, 像是以下的 Laravel 範例程式碼, 有哪些 query builder method 不適用？ 範例:&lt;?php$users = App\\User::with([&#x27;posts&#x27; =&gt; function ($query) &#123; $query-&gt;orderBy(&#x27;created_at&#x27;, &#x27;desc&#x27;);&#125;])-&gt;get(); Answer:limit 及 take # Lazy Eager Loading假如我的 Book model 有 author 以及 publisher 的 relation, 但我想要在特定的條件下才 eager load relation 如以下的範例程式碼, 那我可以怎麼做？ 範例程式碼:&lt;?php$books = App\\Book::all();if ($someCondition) &#123; // eager load here&#125; Answer:&lt;?php$books = App\\Book::all();if ($someCondition) &#123; $books-&gt;load(&#x27;author&#x27;, &#x27;publisher&#x27;);&#125; 以下的 Laravel example code 的意思是？ Example:&lt;?php$author-&gt;load([&#x27;books&#x27; =&gt; function ($query) &#123; $query-&gt;orderBy(&#x27;published_date&#x27;, &#x27;asc&#x27;);&#125;]); Answer:eager load author 的 books relation model, 並且針對 books model 做 orderBy 排序 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function format(Book $book)&#123; $book-&gt;loadMissing(&#x27;author&#x27;); return [ &#x27;name&#x27; =&gt; $book-&gt;name, &#x27;author&#x27; =&gt; $book-&gt;author-&gt;name, ];&#125; Answer:假設我們在一開頭就取出了 User model 的 Author relation model ‘$user = User::with(‘author)’然而, $user 後面又新增了 Author relation model ‘$user-&gt;authors()-&gt;attach($newAuthor)’這時 $user 上原本載入的 Author model 就沒有這個新的 $newAuthor, 這時就可以使用 loadMissing() # Nested Lazy Eager Loading &amp; morphTo以下的 Laravel example code 的意思是？ Example:&lt;?php$activities = ActivityFeed::with(&#x27;parentable&#x27;) -&gt;get() -&gt;loadMorph(&#x27;parentable&#x27;, [ Event::class =&gt; [&#x27;calendar&#x27;], Photo::class =&gt; [&#x27;tags&#x27;], Post::class =&gt; [&#x27;author&#x27;], ]); Answer:先透過 with() eager load parentable relation, 在使用 loadMorph eager load 所有 parentable model 各自對應的 relations Laravel 中, 假設我有一個 ActivityFeed Model, 它跟 Event, Photo, Post Model 有 morphTo 的關係, 如下面範例。 而 Event 又與 Calendar 有關, Photo 與 Tag 有關, 而 Post 與 Author 有關。 現在我要先 eager load ActivityFeed 的 morphTo 關係, 再使用 lazy eager loading 取得以上 morphTo 各自的 relationship, 我可以怎麼做？ 範例 relation:&lt;?phpuse Illuminate\\Database\\Eloquent\\Model;class ActivityFeed extends Model&#123; /** * Get the parent of the activity feed record. */ public function parentable() &#123; return $this-&gt;morphTo(); &#125;&#125; Answer: # Inserting &amp; Updating Related Models# The save method以下的 Laravel example code 的意思是？ 範例程式碼:&lt;?php$comment = new App\\Comment([&#x27;message&#x27; =&gt; &#x27;A new comment.&#x27;]);$post = App\\Post::find(1);$post-&gt;comments()-&gt;save($comment); Answer:使用帶入 model 的方式來新增 relation 在 Laravel 當中, 在以下的範例程式碼當中, 我要如何一次儲存複數的 model? 範例程式碼:&lt;?php$comment = new App\\Comment([&#x27;message&#x27; =&gt; &#x27;A new comment.&#x27;]);$post = App\\Post::find(1);$post-&gt;comments()-&gt;save($comment); Answer:&lt;?php$post = App\\Post::find(1);$post-&gt;comments()-&gt;saveMany([ new App\\Comment([&#x27;message&#x27; =&gt; &#x27;A new comment.&#x27;]), new App\\Comment([&#x27;message&#x27; =&gt; &#x27;Another comment.&#x27;]),]); # Recursively Saving Models &amp; Relationships以下的 Laravel 程式碼代表什麼意思? 程式碼:&lt;?php$post = App\\Post::find(1);$post-&gt;comments[0]-&gt;message = &#x27;Message&#x27;;$post-&gt;comments[0]-&gt;author-&gt;name = &#x27;Author Name&#x27;;$post-&gt;push(); Answer:指定 post 的 comment relation 的第一個 model 的 message 為 ‘Message’指定 post 的 comment relation 的第一個 model 的 author relation 的 name 為 ‘Author Name’ Laravel 當中, 如果我的 relation 是 Post-&gt;hasMany-&gt;comment, 現在我要變更第一個 comment 的 message 欄位為 ‘Message’, 以及 comment 的 author relation 的 name 欄位為 ‘Author Name’, 我可以怎麼做？&lt;?php$post = App\\Post::find(1);$post-&gt;comments[0]-&gt;message = &#x27;Message&#x27;;$post-&gt;comments[0]-&gt;author-&gt;name = &#x27;Author Name&#x27;;$post-&gt;push(); # The create MethodLaravel relationship 當中, save 跟 create method 的差別在於？ save 接受的參數為 model create 接受的參數為 array 以下的 Laravel 程式碼代表什麼意思？ 程式碼:&lt;?php$post = App\\Post::find(1);$comment = $post-&gt;comments()-&gt;create([ &#x27;message&#x27; =&gt; &#x27;A new comment.&#x27;,]); Answer:使用 array 內的資料來建立一筆 Post 與 Comment 的關係 以下的 Laravel example code 的意思是？ Example:&lt;?php$post = App\\Post::find(1);$comment = $post-&gt;comments()-&gt;create([ &#x27;message&#x27; =&gt; &#x27;A new comment.&#x27;,]); Answer:使用 create(), 帶入 array 來建立 Post hasMany Comment relation 以下的 Laravel 程式碼中, 該怎麼儲存 post 與 comment 的 relation? 程式碼:&lt;?php$post = App\\Post::find(1);$comment = [&#x27;message&#x27; =&gt; &#x27;A new comment.&#x27;]; Answer:&lt;?php$post = App\\Post::find(1);$comment = [&#x27;message&#x27; =&gt; &#x27;A new comment.&#x27;];$comment = $post-&gt;comments()-&gt;create($comment); 以下的 Laravel example code 的意思是？ Example:&lt;?php$post = App\\Post::find(1);$post-&gt;comments()-&gt;createMany([$comment1, $comment2]); Answer:使用 createMany(), 帶入多個 array 來建立多個 Comments model 並儲存於資料庫, Post model hasMany Comment model 如果我要使用多個 array 來建立 relation, 我可以使用哪一個 method?createMany # Belongs To Relationships以下的 Laravel 程式碼是什麼意思？ 程式碼:&lt;?php$account = App\\Account::find(10);$user-&gt;account()-&gt;associate($account);$user-&gt;save(); Answer:取得目標 account在該 user 的 account relation 中新增上面取得的 account model 以下的 Laravel 程式碼是什麼意思？ 程式碼:&lt;?php$manager = auth()-&gt;user();$sub_account-&gt;manager()-&gt;dissociate();$sub_account-&gt;save(); Answer:sub_account belongs to manager將 sub_account 的 foreign key 設為 null 以下的 Laravel 程式碼是什麼意思？ 程式碼:&lt;?php$manager = auth()-&gt;user();$sub_account-&gt;manager()-&gt;associate($manager);$sub_account-&gt;save(); Answer:sub_account belongs to manager將 sub_account 的 foreign key 設為 $manager 以下的 Laravel 程式碼中, $manager 可以是什麼？ 程式碼:&lt;?php$manager = auth()-&gt;user();$sub_account-&gt;manager()-&gt;associate($manager);$sub_account-&gt;save(); Answer:Eloquent Model也可以是任意字元, 會儲存在 foreign key Laravel relation 當中, 如果我要更新 belongs to 的 relation, subAccount belongs to Manager, 如下面的程式碼中, 我已取得 manager 的 model, 除了直接使用 update method 去更新該 table 之外, 我可以使用哪個 method? 程式碼:&lt;?php$manager = App\\Manager::find(10); Answer:&lt;?php$manager = App\\Manager::find(10);$sub_account-&gt;manager()-&gt;associate($manager);$sub_account-&gt;save(); 以下的 Laravel example code 的意思是？ Example:&lt;?php$sub_account-&gt;manager()-&gt;dissociate();$sub_account-&gt;save(); Answer:從 $sub_account 的 belongsTo relation manager model 中, 移除 foreign key, 即移除彼此的 relation # Default ModelsLaravel 當中, 哪些種類的 relation 可以定義 default model?belongsTohasOnehasOneThroughmorphOne 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function user()&#123; return $this-&gt;belongsTo(&#x27;App\\User&#x27;)-&gt;withDefault([ &#x27;name&#x27; =&gt; &#x27;Guest Author&#x27;, ]);&#125;// or public function user()&#123; return $this-&gt;belongsTo(&#x27;App\\User&#x27;)-&gt;withDefault(function ($user, $post) &#123; $user-&gt;name = &#x27;Guest Author&#x27;; &#125;);&#125; Answer:給該 relation 定義 default model, 當 Post 沒有 relational user 時, 回傳 default relational model 以下的 Laravel relation definition, 如果該 relation 不存在, 會回傳什麼？ 範例 relation definition:&lt;?php/** * Get the author of the post. */public function user()&#123; return $this-&gt;belongsTo(&#x27;App\\User&#x27;)-&gt;withDefault([ &#x27;name&#x27; =&gt; &#x27;Guest Author&#x27;, ]);&#125; Answer:&#123; &quot;name&quot;: &quot;Guest Author&quot;&#125; # Many To Many Relationships# Attaching / DetachingLaravel many to many relation 中, 如果我要單純新增一筆 relation 紀錄, 我可以怎麼做?&lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;attach($roleId); 以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;roles()-&gt;attach($roleId, [&#x27;expires&#x27; =&gt; $expires]); Answer:為 $user model 新增指定的一筆 $roldId many to many relation, 並且額外指定要新增到 pivot table 中的 column/value 以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;roles()-&gt;detach($roleId); Answer:在 many to many relation 中, 移除該 User model 指定的一筆 Role relation model Laravel many to many relation 中, 如果我要單純的移除多筆筆 relation 紀錄, 我可以怎麼做？&lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;detach([1, 2, 3]); 以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;roles()-&gt;detach(); Answer:移除 $user 的 many to many relation Role 所有的 records, 相當於移除 pivot table 中所有 $user 的 role relation model 以下的 Laravel example code 的意思是？ Example:&lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;attach([ 1 =&gt; [&#x27;expires&#x27; =&gt; $expires], 2 =&gt; [&#x27;expires&#x27; =&gt; $expires],]); Answer:新增多筆 relation records, 並 insert $expires to expires column 以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;roles()-&gt;sync([1, 2, 3]); Answer:在 many to many relation 中, 可使用 sync method, 資料庫會同步帶入的 parameters, 在此 example 中, 資料庫內如果沒有 1, 2, 3 則會新增, 並刪除除了 1, 2, 3 之外的資料 Laravel many to many relation 中, 帶入一筆或多筆 relation 紀錄, 資料庫內需與帶入的資料完全符合, 沒有的新增, 多的刪除, 我還要再額外的欄位新增資訊, 那我可以怎麼做？&lt;?php$user-&gt;roles()-&gt;sync([1 =&gt; [&#x27;expires&#x27; =&gt; true], 2, 3]); 以下的 Laravel example code 的意思是？ Example:&lt;?php$user-&gt;roles()-&gt;syncWithoutDetaching([1, 2, 3]); Answer:如果資料庫並不存在 array 內的資料, 則新增如果資料庫已存在 array 內的資料, 則保留 # Toggling AssociationsLaravel many to many relation 中, 如果我要帶入一組 relation 紀錄, 資料庫裡頭, 若沒有則則新增, 若有的話則移除, 那我可以怎麼做？&lt;?php$user-&gt;roles()-&gt;toggle([1, 2, 3]); # Saving Additional Data On A Pivot TableLaravel many to many relation 中, 如果我要新增一筆 relation 紀錄, 同時如果此 relation 的對象不存在的話則建立, 再建立 relation 紀錄, 那我可以怎麼做？&lt;?phpApp\\User::find(1)-&gt;roles()-&gt;save($role, [&#x27;expires&#x27; =&gt; $expires]); # Updating A Record On A Pivot Table以下的 Laravel example code 的意思是？ Example:&lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;updateExistingPivot($roleId, $attributes); Answer:更新 many to many relation 的 pivot table, $attribute 為帶有 column/value 的 array # Touching Parent Timestamps以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; protected $touches = [&#x27;post&#x27;]; public function post() &#123; return $this-&gt;belongsTo(&#x27;App\\Post&#x27;); &#125;&#125; Answer:使用 $touches property, 這樣當我更新 pivot table 時, 也會一併的更新 Post model 中的 timestamp # Additional解釋以下的 Laravel example Example:&lt;?php public function scopeOf(Builder $query, ...$models) &#123; foreach ($models as $model) &#123; /** @var $model Model */ $query-&gt;where($model-&gt;getForeignKey(), $model-&gt;getKey()); &#125; &#125; Answer:&lt;?php // 可帶入多個 model public function scopeOf(Builder $query, ...$models) &#123; // loop 每個 model foreach ($models as $model) &#123; /** @var $model Model */ // 取得該 model 的 `foreign key name`, 以及 `primary key value` // 所以可以在目標 model 使用其他 model 為條件來 query $query-&gt;where($model-&gt;getForeignKey(), $model-&gt;getKey()); &#125; &#125;","link":"/zh-tw/laravelEloquentORMRelationships/"},{"title":"利用 Let's Encrypt 來自動簽署並更新 SSL 憑證 (wildcard)","text":"前言本篇主要分享，如何利用 Let&#39;s Encrypt 的 cert bot 來自動簽署以及更新 SSL 憑證 (wildcard)什麼是 wildcard? 比方說你的域名是 example.com, 那一個 wildcard 的憑證將會適用於以下的網站: abc.example.comaaa.example.comwhatever.example.com wildcard 憑證不包含以下的域名, 但是照文章內的指令申請, 可以一併申請 example.com 總之不管前面是什麼，都可以適用。要使用 Certbot 來取得 wildcard 的 certificate 需要安裝 DNS 提供商的插件，或者其他的手動插件，本篇文章採用 DNS 提供商為 Google 的情況 參考網頁官網 環境 Server: NginX OS: Ubuntu 18.04 DNS Provider: Google 確認你的 DNS Provider 是否支援看你的 DNS Provider 有無被 Certbot 支援, 看這份清單 沒支援如果你的 DNS provider 沒有被支援，在這停下。 參考這份文件，使用手動插件運行 Certbot 執行以下程式碼 certbot certonly --manual -d *.example.com -d example.com --preferred-challenges dns 執行後先別按下 Enter, 請看下一步 到你的 DNS 服務商去新增相對應的 hostName 以及指向的 value, type 為 TXT dig -t txt hostName 確認該 hostName 是否指向 上一步新增的 value 回到 terminal 按下 enter 大功告成 有支援如果你的 DNS provider 有支援，順著以下的步驟繼續 SSH 到你的 ServerSSH 到你的 server, 該使用者須擁有 sudo 權限 加入 Certbot PPA你將需要把 Certbot PPA 加入到 repository 清單，執行以下指令來加入： sudo apt-get update; sudo apt-get install software-properties-common; sudo add-apt-repository universe; sudo add-apt-repository ppa:certbot/certbot; sudo apt-get update 安裝 Certbot執行以下指令來安裝 Certbot sudo apt-get install certbot python-certbot-nginx 安裝正確的 DNS 插件執行以下指令以安裝插件，本教程中使用的 DNS 提供商為 Google 範例 sudo apt-get install python3-certbot-dns-\\&lt;PLUGIN\\&gt; 本教程情境 sudo apt-get install python3-certbot-dns-google 設定 credentials你將需要設定 DNS credentials。依循各 DNS 提供商文件中的 “Credentials” 區塊來建立或存取適當的 credential 設定檔點擊這份文件 來尋找指定 DNS 提供商的 credential 教學。 設定 Google Credentials需要哪些權限？由 Certbot 的 Google 文件, 可以得知 Certbot 需要的權限如下： dns.changes.createdns.changes.getdns.managedZones.listdns.resourceRecordSets.createdns.resourceRecordSets.deletedns.resourceRecordSets.listdns.resourceRecordSets.update 建立 role從 Navigation menu &gt; IAM &amp; admin &gt; role , 進到 role 頁面後點擊 CRETE ROLE, 然後點擊 ADD PERMISSION 按鈕。 在 filter 欄位中，逐一輸入上面的權限來將需求的權限加入 全部都加入之後，請在 title 以及其他欄位依照個人需求填入名稱，若覺得預設挺好的，也可以保留預設即可。 選擇 CREATE, 共有七項。 建立 Service Account 從左側選單點擊 Navigation menu &gt; IAM &amp; admin &gt; Service accounts , 進到 Service accounts 頁面後，點擊上方 CREATE SERVICE ACCOUNT 按鈕。 依照個人喜好輸入 Service account name 以及 Service account description 選擇 role, 想當然爾，自然是輸入我們上一步建立的 role 啦！ 然後點擊 CONTINUE 最後是建立一把 json key, 點擊 CREATE KEY 最後點擊 DONE, 結束這一回合 選擇你想要怎麼樣執行 Certbot, 是單純拿到 certificate 或要安裝這邊官網有提供兩種方式，一種是全自動安裝，不只獲得憑證還幫你安裝，另外一種是只有安裝。不過我看過 Google 的插件之後，發現好像只有獲得憑證的選項，因此下面的指令會是單純獲得憑證的方式，若有人知道怎麼同時安裝的，也可以提供哦！ 下面指令為 Google 版的，其他版的請勿使用哦！ certbot certonly --dns-google --dns-google-credentials yourCredentailLocation -d *.example.com. -d example.com. -i nginx 上面的 yourCredentailLocation 為上面我的建立的 Google Service Account JSON Key, 假如我放在 /home/ray/serviceAccountKey.json, 那上面的指令將會如下： certbot certonly --dns-google --dns-google-credentials /home/ray/serviceAccountKey.json -d *.example.com. -d example.com. -i nginx 拿到憑證之後，我們可以設定一個測試站來看 wildcard 憑證是否有效 建立測試 site 檔案vim example.com server &#123; server_name abc.example.com; listen 80; listen 443 ssl; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;&#125; 憑證的位置我們在上一步成功拿到憑證之後，輸出訊息會顯示憑證放置位置。 我們也可以把它放到任何我們想要的地方。 測試 syntax nginx -t 重啟 Nginx systemctl restart nginx.service 到域名服務商去新增 abc.example.com 這筆 A record, 然後 IP 為你 Server 的位置 給 DNS 一些時間來生效 在瀏覽器輸入 https://abc.example.com 來拜訪測試站，若成功的話可以看到 Welcome to nginx! 測試自動更新Certbot 套件附有 cron job 或是 systemd timer，可以在憑證過期前自動的更新你的憑證。 你將不需要再執行 Certbot, 除非你更動了你的設定。 你可以運行下面的指令來測試自動更新: sudo certbot renew --dry-run 自動更新 certbot 的指令安裝在以下位置： /etc/crontab//etc/cron.*/*systemctl list-timers 確認 Certbot 正確的設定我們的憑證拜訪你的網站，然後看左方鎖頭的圖案。如果你想看更多資訊，試試看這個網站故障排除請參考這份文件若需要更多客製化的設定，請參考這份文件若覺得 Certbot 不錯，也可以贊助 失敗了？如果有看到錯誤訊息如下：Encountered error deleting TXT record: &lt;HttpError 412 when requesting https://dns.googleapis.com/dns/v1/projects/yourProject/managedZones/yourZoneNumber/changes?alt=json returned &quot;Precondition not met for &#39;entity.change.deletions[0]&#39;&quot;&gt; 那檢查一下是不是之前有手動申請憑證，並且驗證完畢之後沒有把 TXT 檔刪掉","link":"/zh-tw/letsEncryptWildcard/"},{"title":"利用 Let's Encrypt 來自動簽署並更新 SSL 憑證","text":"前言本篇主要分享，如何利用 Let&#39;s Encrypt 的 cert bot 來自動簽署以及更新 SSL 憑證 參考網頁官網 環境 Server: NginX OS: Ubuntu 18.04DNS 設定先將 DNS 設定好, 建一個 A record, 將我們喜歡的 domain 指向我們的 IP 設定檔 這邊使用最簡單的設定, 反向代理 server 內的 9527 port, 若無反向代理需求，可以單純指向專案的 Document root 即可 sudo vim /etc/nginx/sites-available/yourSiteName server &#123; listen 80; server_name yourDomainName; access_log /var/log/nginx/test_access_log; location / &#123; proxy_pass http://127.0.0.1:9527; &#125;&#125; 測試 syntax sudo nginx -t 啟用設定 sudo ln -s /etc/nginx/sites-available/yourSiteName /etc/nginx/sites-enabled/yourSiteName 設完之後，重啟 nginx sudo service nginx restart 測試設定設定好之後，如果我們 curl http://yourIPOrDomain/endpoint , 應該要可以存取服務 新增 cerbot PPA (Personal Package Archives)sudo apt-get update &amp;&amp; sudo apt-get install software-properties-common &amp;&amp; sudo add-apt-repository universe &amp;&amp; sudo add-apt-repository ppa:certbot/certbot 安裝 Let’s Encryptsudo apt-get install certbot python-certbot-nginx 運行 cerbot全自動模式如果你希望 cerbot 可以幫我們全自動完成設定，輸入 sudo certbot --nginx 半自動模式如果你希望 cerbot 只幫我們拿到憑證，其他我們自己來的話，輸入 sudo certbot certonly --nginx 測試自動更新到這裡，應該已經可以自動更新憑證了，輸入以下指令測試 sudo certbot renew --dry-run cerbot 安裝在以下路徑之一: /etc/crontab/ /etc/cron.*/* systemctl list-timers 測試簽證是否成功測試網頁","link":"/zh-tw/letsencrypt/"},{"title":"使用 Stackdriver 在 Kubernetes Engine 上做紀錄","text":"概述Stackdriver Logging 可以讓你在所有的 GCP 資源，或是其他平台的資源做紀錄，然後針對紀錄以及指標做集中式的儲存。 紀錄被加總，並且可在提供的 Stackdriver Logging UI 內被檢視。 他們也可以被匯出到接收器來支援更多使用情境。 目前， Stackdriver Logging 支援匯出到下面的接收器: Cloud Storage Pub/Sub BigQuery 在這個教程，你將會部署一個簡單的 Kubernetes 應用，這個應用將轉發紀錄事件到 Stackdriver Logging 。 Terraform 一個強調基礎架構就是程式碼的工具， 可以使用配置檔來自動化部署，是雲端基礎架構的進化。 配置檔同時也會建立一個 Cloud Storage 儲存區，以及 BigQuery 資料組來接受被匯出的紀錄 本教程由 GKE Helmsman 的工程師所建立，為了讓你對 Stackdriver Logging 有更好地理解。 你可以在 Github 上檢視這個範例。 我們也鼓勵以及歡迎任何想對我們專案做出貢獻的開發者！ 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 架構Terraform 配置將會建立一個 Kubernetes Engine 叢集，這個叢集會產生可被 Stackdriver 處理的紀錄以及指標。 這個腳本也會同時建立紀錄的匯出接收器，有 CloudStorage, BigQuery, 以及 Cloud Pub/Sub。 這一切包含資料流，可參考下面的圖片 設定及要求 Qwiklabs setup在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Quiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Quiclabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Clone 範例clone 本教程需要的資源，執行以下指令 git clone https://github.com/GoogleCloudPlatform/gke-logging-sinks-demo 進到專案內 cd gke-logging-sinks-demo 設定你的 region 和 zone某些 Compute Engine 的資源位於 regions 以及 zones 。 region 是一個特定的地理位置，你只能在這個執行 region 運行你的資源, 每一個 region 有一個或多個 zone 如果你想要了解更多有關 region 以及 zone, 可以參考官方文件 執行以下指令來設定本教程中的 region 以及 zone (你可以使用對你來說最佳的 region 跟 zone) 部署遵從 程式碼及基本架構 以及 不可改變的基礎架構 , Terraform 支援利用陳述性的描述來決定理想的基礎架構狀態。 當述詞被採用， Terraform 使用 GCP APIs 來提供以及更新資源的狀態已符合述詞。 Terraform 比較想要的狀態以及目前的狀態，所以漸進式增加的變更不需要刪除任何東西，或者重新開始，即可被套用。 例如說，Terraform 可以建立 GCP 專案以及 compute 執行個體等等… 甚至是設定一個 Kubernetes Engine 叢集，並且部署應用到上面。 當要求改變了，敘詞可以被更新，然後 Terraform 將會相對應的更新雲端基礎設施 這個範例將會開始一個 Kubernetes Engine 叢集，然後部署一個簡單的範例應用上去。 預設， GCP Kubernetes Engine 叢集內建一個事先配置好的 Fluented 收集器，他會轉發記錄到 Stackdriver 更新 provider.tf 檔案 在 Terraform 的 provider.tf 腳本中，移除 provider 版本 編輯 provider.tf 腳本 nano ~/gke-logging-sinks-demo/terraform/provider.tf 如果檔案含有 google 提供者的靜態版本字串，像下圖一樣，請移除 ....provider &quot;google&quot; &#123; project = var.project version = &quot;~&gt; 2.10.0&quot;&#125; 儲存檔案 部署叢集 本教程提供的範例檔案中，有三個 Teffaform 的配置檔。 第一個， main.tf ，是一個 Terraform 的起始點。 他描述了會使用到的功能，以及會被操縱到的資源，還有會輸出的結果。 第二個檔案是 provider.tf , 這個檔案顯示 Terraform 指令的目標是哪一個雲端提供者以及其版本，在這個範例中，是 GCP 。 最後一個檔案是 variables.tf ，它含有一個變數清單，用來當作 Terraform 的輸入。 任何沒有在 variables.tf 但有用在 main.tf 的變數都會在執行過程中跳出。 要建立環境，可以執行以下指令 make create 備註： 如果你收到跟 zone 變數相關的廢棄警告，請無視，繼續本教程 驗證如果在部署過程中沒有顯示任何錯誤，在幾分鐘之後，你應該會在 GCP 主控台看到 Kubernetes Engine 叢集 到 Navigation menu &gt; Kubernetes Engine 來看同一個被部署的應用 若要驗證這個範例是否正確的部署，執行 make validate 輸出看起來如下： 現在，應用已經被部署到 Kubernetes Engine, 它可以產生紀錄資料，然後可以使用 Stackdriver 或其他工具來檢視它 產生紀錄這個使用 Terraform 部署的範例應用提供一個簡單網頁的功能。 每次你在瀏覽器打開這個應用，這個應用將會發布紀錄事件到 Stackdriver Logging 。 重整頁面幾次來產生一些紀錄事件。 要取得應用頁面的 URL , 執行以下步驟: 在 GCP 主控台，從 Navigation menu, 移動到 Networking section, 然後點擊 Network services 在預設的 Load balancing 頁面，點擊已經設定好的 TCP load balancer 在 Load balancer detail 頁面，最上面已被下標籤 Fronted 複製 IP:Port URL, 打開一個新的瀏覽器然後貼上，瀏覽器應該會顯示類似以下的畫面： 在 Stackdiver 的紀錄Stackdriver 提供 UI 介面來檢視紀錄事件。 基本的搜尋以及篩選的功能都有提供，當在 Debug 系統問題時，這非常的有用。 Stackdriver Logging 最適合用來檢視比較近的紀錄事件，若對長期紀錄事件有要求的使用者，應該考慮其他一些工具，下面會介紹到 若要存取 Stackdriver Logging 主控台，執行以下的步驟： 在 GCP 主控台，從 Navigation menu Stackdriver 區塊，選擇 Logging 變更資源篩選器 GKE Container &gt; stackdriver-logging &gt; default ( stackdriver-logging 是叢集，而 default 是命名空間) 在這個頁面上，你可以展開紀錄來檢視紀錄數據更多的細節 在紀錄主控台，你可以執行任何類型的文字搜尋，或是嘗試很多紀錄類型的篩選器，事件等級，時間區間等等 檢視紀錄匯出Terraform 配置建立了兩個紀錄匯出接收器。 若要檢視接收器，執行以下的步驟: 你應該還在 Stackdriver -&gt; Logging 頁面 在左邊導航選單，點擊 Exports 選單選項 這會導引你到 Exports 頁面，在紀錄匯出的清單，你應該會看到兩個接收器 在接收器右手邊點擊 context 選單 (三個小點), 然後選擇 Edit sink, 你可以編輯/檢視這些接受器 另外，在導航視窗的頂部點擊 Create Export 選項，你可以建立額外的客制匯出接收器 在 Cloud Storage 的紀錄紀錄事件可以被儲存在 Cloud Storage, 這是一個適合用來儲存歸檔資料的物件儲存系統。 Cloud Storage 儲存區的政策可以被配置，舉例來說，久置的資料可變為過期，然後自動刪除，而新的資料可以依照不同的類別被儲存，類別會影響到價格以及可用性。 Terraform 配置檔建立了一個 Cloud Storage 儲存區，名為 Stackdriver-gke-logging-, 中長期的紀錄都會被匯出，然後儲存在這。 在這個範例中，儲存類別被定義為 Nearline, 因為正式環境中，紀錄中長期的紀錄不會經常性地被儲存（這將有助於管理中長期儲存成本）。 在正式環境中，儲存區也可以包含一個生命週期的政策，他可以將內容移動到 Coldline 儲存區，這樣對長期儲存記錄的成本會更低 要在 Cloud Storage 存取 Stackdriver 紀錄, 執行下面的步驟： 在 GCP 主控台， 從 Navigation menu 點擊 Storage 找到名為 stackdriver-gke-logging-&lt;random-Id&gt; 的儲存區，點擊名稱 你應會看到一系列與跑到叢集中的 pod 相對應的資料夾 (就是， autoscaler, dnsmasq, 等等) 你可以點擊任何一個資料夾來瀏覽特定的紀錄細節，像是 heapster, kubedns, sidecar, 等等… 在 BigQuery 的紀錄Stackdriver 紀錄事件可以被設定成發佈在 BigQuery, 一個快速的，精細的，供龐大資料查詢的資料儲存工具 Terraform 配置將會建立一個 BigQuery 資料組, 名為 gke_logs_dataset。 這個資料組將會被設定成包含所有與 Kubernetes Engine 相關的距今一個小時的紀錄 (設定預設的資料組表格過期時間)。 Stackdriver 匯出將會被建立且將 Kubernetes Engine 容器紀錄推送到資料組 若想要從 BigQuery 存取 Stackdriver 紀錄，執行下面的步驟： 在 GCP 主控台的 Navigation menu, 在 Big Data 的區塊點擊 BigQuery 在左邊的選單，點擊你的專案名稱。 你應會看到一個名為 gke_logs_dataset 的資料組。 展開這個資料組來檢視存在的表格 ( Note: 這個資料組會立即被建立，但表格會再當紀錄產生了，且新的表格有需要時建立) 點擊其中一個表格來檢視表格細節 檢視表格結構，並且注意到欄位的名稱以及他們的資料類型。 這些資訊在你下一步要對表格做查詢時會用到 點擊右上方 Query Table 來對表格執行客製化查詢 這會在查詢編輯器裡增加一個查詢，你它有一個語法錯誤 編輯這個查詢，在 after 之後增加一個星號 (*) 來從這個表格調出所有的細節。 備註: 一個 Select * 查詢通常是非常昂貴，且不建議的。 在本教程中，資料組被限制上最近一個小時的紀錄，所以整體上資料庫的相對小的。 點擊 Run 來執行查詢，並且從表格得到一些結果 結果視窗應該會顯示一些行和列，你可以捲動回傳的多行資料。如果你想要，執行一些客制的查詢從原本查詢的結果中篩選一些特定的資料 刪除安裝Qwiklabs 會將所有本教程中使用到的資源關掉，但是這邊可能需要你做的是清理你的環境來節省成果，當一個好雲端公民！ make teardown 因為 Terraform 有對所有建立的資源做追蹤，所以他可以將他們全部清除 正式環境的故障排除執行 Terraform 時，安裝腳本失敗了，並且回傳 Permission denied。Terraform 使用的帳號沒有提供必須的權限來在選擇的專案中建立資源。 確保列在 gcloud config list 中的專案有必要的權限來建立資源。 如果它有，使用 gcloud auth application-default login 來重新產生應用預設帳號 Cloud Storage 儲存區沒有載入 。一旦 Terraform 配置已經完成，那 Cloud Storage 儲存區將會被建立。 但不是每次都會立即地將 Kubernetes Engine 叢集中的紀錄資料立即載入。 給這個程序一點時間，因為他可能會花上最多 2-3 個小時讓第一筆資料出現。 (參考資料) BigQuery 資料組中沒有表格一旦 Terraform 配置完成， BigQuery 資料組將自動被建立但表格不會總是在你檢視結果的時候就已經建立。 表格很少立即的載入資訊。 給這個程序一點時間，(最少 5 分鐘), 在你下可能出錯的判斷之前。 恭喜，你已完成本教程","link":"/zh-tw/loggingWithStackdriverOnKubernetesEngine/"},{"title":"Laravel - The Basics - Validation (官方文件原子化翻譯筆記)","text":"# Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 # Validation Quickstart# Writing The Validation Logic在 Laravel validation 中, 如果請求的是 HTTP request, 那 validation 會回什麼？redirect response 在 Laravel validation 中, 如果請求的是 AJAX request, 那 validation 會回什麼？JSON response Laravel validation rules 可以用哪兩種方式指定？ | delimited string array 以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;validateWithBag(&#x27;blog&#x27;, [ &#x27;title&#x27; =&gt; [&#x27;required&#x27;, &#x27;unique:posts&#x27;, &#x27;max:255&#x27;], &#x27;body&#x27; =&gt; [&#x27;required&#x27;],]); Answer:指定該 validation 的 message bag name, 如果該 page 呼叫多個 API 的話, 便可以經由 message bag name 辨別不同 form 的 error message # Stopping On First Validation Failure以下的 Laravel example code 的意思是？ 範例程式碼:&lt;?php$request-&gt;validate([ &#x27;title&#x27; =&gt; &#x27;bail|required|unique:posts|max:255&#x27;, &#x27;body&#x27; =&gt; &#x27;required&#x27;,]); Answer:bail rule, 當驗證沒通過時立即停下, 不再繼續往下驗 # A Note On Nested Attributes以下的 Laravel example code 的意思是？ Example:&lt;?php$request-&gt;validate([ &#x27;title&#x27; =&gt; &#x27;required|unique:posts|max:255&#x27;, &#x27;author.name&#x27; =&gt; &#x27;required&#x27;, &#x27;author.description&#x27; =&gt; &#x27;required&#x27;,]); Answer:如果 author 是個 array 或 json, 驗證 author 下 key 為 name 以及 description 都需 present, 且 value 不可為空 # Displaying The Validation ErrorsLaravel validation 中, 我們不需要特別的 bind error message 以及 GET route, 但卻能夠把 error message 帶過去, 為什麼？因為 Laravel 將 error message 放在 flash session 當中 Laravel validation 中, $errors 變數是什麼的 instance?Illuminate\\Support\\MessageBag Laravel validation 中, $errors 變數是被哪一個 middleware 將之與 view 連接在一起?Illuminate\\View\\Middleware\\ShareErrorsFromSession 以下的 Laravel example code 的意思是？ Example:&lt;!-- /resources/views/post/create.blade.php --&gt;&lt;h1&gt;Create Post&lt;/h1&gt;@if ($errors-&gt;any()) &lt;div class=&quot;alert alert-danger&quot;&gt; &lt;ul&gt; @foreach ($errors-&gt;all() as $error) &lt;li&gt;&#123;&#123; $error &#125;&#125;&lt;/li&gt; @endforeach &lt;/ul&gt; &lt;/div&gt;@endif&lt;!-- Create Post Form --&gt; Answer:在 blade view page 中, 如果 $error 存在, 印出 $errorRoute 可以是 back()-&gt;withErrors($validation) # The @error Directive以下的 Laravel example code 的意思是？ Example:&lt;!-- /resources/views/post/create.blade.php --&gt;&lt;label for=&quot;title&quot;&gt;Post Title&lt;/label&gt;&lt;input id=&quot;title&quot; type=&quot;text&quot; class=&quot;@error(&#x27;title&#x27;) is-invalid @enderror&quot;&gt;@error(&#x27;title&#x27;) &lt;div class=&quot;alert alert-danger&quot;&gt;&#123;&#123; $message &#125;&#125;&lt;/div&gt;@enderror Answer:如果 error &#39;title&#39; 存在的話, 就執行 @error directive 內的動作 # A Note On Optional FieldsLaravel 中, 空的 string 會被轉化成 null, 這是為什麼?因為以下兩個 global middleware TrimStrings ConvertEmptyStringsToNull Laravel validation 當中, 如果我要 input 是允許 null 的, 我可以加入哪一個 rule?nullable # Form Request Validation# Creating Form RequestsLaravel 中, 如果我要用 CLI 建立一個 “form request”, 我可以怎麼做？php artisan make:request StoreBlogPort 以下位於 form request 的 Laravel example code 的意思是？ Example:&lt;?phppublic function rules(Deposit $deposit)&#123; return [ &#x27;title&#x27; =&gt; &#x27;required|unique:posts|max:255&#x27;, &#x27;body&#x27; =&gt; &#x27;required&#x27;, ];&#125; Answer:定義該 FORM REQUEST 的 rule, 並 inject 需要的 dependency 以下位於 Controller 的 Laravel example code 的意思是？ Example:&lt;?phppublic function store(StoreBlogPost $request)&#123; $validated = $request-&gt;validated();&#125; Answer:使用 Form request 來驗證, 並取得 validated request 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function withValidator($validator)&#123; $validator-&gt;after(function ($validator) &#123; if ($this-&gt;somethingElseIsInvalid()) &#123; $validator-&gt;errors()-&gt;add(&#x27;field&#x27;, &#x27;Something is wrong with this field!&#x27;); &#125; &#125;);&#125; Answer:在 validate 之後再做其他的驗證 # Authorizing Form RequestsLaravel 中, 如果我想要在 “form requests” 當中驗證一個 user 是否有相關 policy 定義的存取權限, 我可以使用哪一個 method?authorize() Laravel 中, 如果 “form request” 中的 authorize method return false, Laravel 會直接回什麼樣的 Response?403 Laravel 中, 如果我不打算使用 “form request” 中的 authorize, 我想在其他地方驗證權限部分, 那我必須要讓 authorize method return 什麼 response?true # Customizing The Error Messages在 Laravel 中, 如果我要客製化 “form request” 的錯誤訊息, 我可以使用哪一個 method?messages 以下位於 Form request 的 Laravel example code 的意思是？ Example:&lt;?phppublic function messages()&#123; return [ &#x27;title.required&#x27; =&gt; &#x27;A title is required&#x27;, &#x27;body.required&#x27; =&gt; &#x27;A message is required&#x27;, ];&#125; Answer:使用 message(), 定義 error message, 當 title 的 required rule 驗證失敗, 錯誤訊息為 &#39;A title is required&#39; # Customizing The Validation Attributes以下位於 Form request 的 Laravel example code 的意思是？ Example:&lt;?phppublic function attributes()&#123; return [ &#x27;email&#x27; =&gt; &#x27;test email&#x27;, ];&#125; Answer:將 error message 中原本顯示為 email 的 attribute 改為 test email # Prepare Input For Validation以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Support\\Str;protected function prepareForValidation()&#123; $this-&gt;merge([ &#x27;slug&#x27; =&gt; Str::slug($this-&gt;slug), ]);&#125; Answer:Form request 中的 prepareForValidation 可以讓 Request 在 validate 之前先被處理過, 如上 example, 將 slug input 的 value 跑過 Str::slug(), 假如 input value 為 ‘a b c d’, 到了 validation 那則會變成 ‘a-b-c-d’ # Manually Creating Validators以下的 Laravel 範例程式碼是什麼意思？ 範例程式碼:&lt;?phpnamespace App\\Http\\Controllers;class PostController extends Controller&#123; public function store(Request $request) &#123; $validator = Validator::make($request-&gt;all(), [ &#x27;title&#x27; =&gt; &#x27;required|unique:posts|max:255&#x27;, &#x27;body&#x27; =&gt; &#x27;required&#x27;, ]); if ($validator-&gt;fails()) &#123; return redirect(&#x27;post/create&#x27;) -&gt;withErrors($validator) -&gt;withInput(); &#125; // Store the blog post... &#125;&#125; Answer:&lt;?phpnamespace App\\Http\\Controllers;class PostController extends Controller&#123; public function store(Request $request) &#123; // 手動建立一個 validator, make 的第一個 parameter 為 request, 第二個為 rules $validator = Validator::make($request-&gt;all(), [ &#x27;title&#x27; =&gt; &#x27;required|unique:posts|max:255&#x27;, &#x27;body&#x27; =&gt; &#x27;required&#x27;, ]); // 如果 validator 驗證失敗 if ($validator-&gt;fails()) &#123; // 重導向 post/create return redirect(&#x27;post/create&#x27;) // 將 error 存到 session -&gt;withErrors($validator) // 將指定的 input 存到 session, 若有帶則為帶入的 input array, 若沒帶則為 request-&gt;input, 可參考 https://github.com/laravel/framework/blob/6.x/src/Illuminate/Http/RedirectResponse.php#L74 -&gt;withInput(); &#125; // Store the blog post... &#125;&#125; Laravel validation 中, 什麼情況之下我會需要手動建立一個 validator?如果我想要控制 驗證到錯誤之後要做些什麼事 的情況 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Http\\Controllers;class PostController extends Controller&#123; public function store(Request $request) &#123; $validator = Validator::make($request-&gt;all(), [ &#x27;title&#x27; =&gt; &#x27;required|unique:posts|max:255&#x27;, &#x27;body&#x27; =&gt; &#x27;required&#x27;, ]); if ($validator-&gt;fails()) &#123; return redirect(&#x27;post/create&#x27;) -&gt;withErrors($validator) -&gt;withInput(); &#125; // Store the blog post... &#125;&#125; Answer:一般來說, 如果使用 validate(), Laravel 預設會 return 相對應的 error, 使用 $validator-&gt;fails() 可以客製化抓到錯誤之後的動作 # Automatic Redirection以下的 Laravel example code 的意思是？ 程式碼:&lt;?phpValidator::make($request-&gt;all(), [ &#x27;title&#x27; =&gt; &#x27;required|unique:posts|max:255&#x27;, &#x27;body&#x27; =&gt; &#x27;required&#x27;,])-&gt;validate(); Answer:使用 validator, make method, arg1 為要驗的來源, arg2 為 rules, 最後 validated() 會執行 Laravel default 驗證, 若驗證失敗會自動跳轉 (HTTP request) 或回應 JSON(當 client 指定 content type Application/json) # Named Error Bags以下的 Laravel example code 的意思是？ Example:&lt;?phpreturn redirect(&#x27;register&#x27;) -&gt;withErrors($validator, &#x27;login&#x27;); Answer:重導向 register page, 帶著名為 login 的 $validation error, 若前端有多個 form 呼叫多個 API 的話, 不同名稱的 MessageBag instance 可幫助前端辨別不同 form 的 error 以下的 Laravel Blade example code 的意思是？ Example:&#123;&#123; $errors-&gt;login-&gt;first(&#x27;email&#x27;) &#125;&#125; Answer:取出名為 login 的 MessageBag, 並從中取出 &#39;email&#39; error message # After Validation Hook以下的 Laravel example code 的意思是？ Example:&lt;?php$validator = Validator::make(...);$validator-&gt;after(function ($validator) &#123; if ($this-&gt;somethingElseIsInvalid()) &#123; $validator-&gt;errors()-&gt;add(&#x27;field&#x27;, &#x27;Something is wrong with this field!&#x27;); &#125;&#125;);if ($validator-&gt;fails()) &#123; //&#125; Answer:&lt;?php// 自訂一個 validator$validator = Validator::make(...);// 在通過 validation rules 的驗證後, 在驗證其他 custom 的 rule$validator-&gt;after(function ($validator) &#123; if ($this-&gt;somethingElseIsInvalid()) &#123; $validator-&gt;errors()-&gt;add(&#x27;field&#x27;, &#x27;Something is wrong with this field!&#x27;); &#125;&#125;);// 判斷驗證結果if ($validator-&gt;fails()) &#123; //&#125; # Working With Error MessagesLaravel 中, 如果我呼叫 validator 的 errors method, 我會拿到 哪一個 class 的 instance?Illuminate\\Support\\MessageBag Laravel 中, $errors 這個全域變數是 哪一個 class 的 instance?Illuminate\\Support\\MessageBag # Retrieving The First Error Message For A Field以下的 Laravel example code 的意思是？ Example:&lt;?php$errors = $validator-&gt;errors();echo $errors-&gt;first(&#x27;email&#x27;); Answer:取得 email 欄位的第一項錯誤 # Retrieving All Error Messages For A Field以下的 Laravel example code 的意思是？ Example:&lt;?php Answer:&lt;?php 以下的 Laravel example code 的意思是？ Example:&lt;?php$errors = $validator-&gt;errors();foreach ($errors-&gt;get(&#x27;email&#x27;) as $message) &#123; //&#125; Answer:從 $errors 中取出 &#39;email&#39; 的所有錯誤訊息 以下的 Laravel example code 的意思是？ Example:&lt;?php$errors = $validator-&gt;errors();foreach ($errors-&gt;get(&#x27;attachments.*&#x27;) as $message) &#123; //&#125; Answer:attachments 為一個 array, 下面有多個 index, 因此每個 index 都可能會有各自的 error message, 使用 * 取出所有 index 的 error message # Retrieving All Error Messages For All Fields以下的 Laravel example code 的意思是？ Example:&lt;?php$errors = $validator-&gt;errors();foreach ($errors-&gt;all() as $message) &#123; //&#125; Answer:取得所有驗證過的欄位的錯誤訊息 # Determining If Messages Exist For A Field以下的 Laravel example code 的意思是？ Example:&lt;?php$errors = $validator-&gt;errors();if ($errors-&gt;has(&#x27;email&#x27;)) &#123; //&#125; Answer:判斷 &#39;email&#39; column 是否有 error # Custom Error Messages以下的 Laravel example code 的意思是？ Example:&lt;?php$messages = [ &#x27;required&#x27; =&gt; &#x27;The :attribute field is required.&#x27;,]; Answer:客製化驗證錯誤時的訊息, :attribute 代表 $request 中的 input 名稱 以下的 Laravel example code 的意思是？ 錯誤訊息:&lt;?php$messages = [ &#x27;required&#x27; =&gt; &#x27;The :attribute field is required.&#x27;,];$validator = Validator::make($input, $rules, $messages); Answer:帶入 validator::make() 的 arg3 來客製化 error message Laravel validation 中, 如果我想要查詢各種在錯誤訊息中代表的相對應的 field, 我可以到哪一個檔案查詢？resources/lang/xx/validation.php, xx = 語言種類, 比如說, en # Specifying A Custom Message For A Given Attribute以下的 Laravel example code 的意思是？ Example:&lt;?php$messages = [ &#x27;email.required&#x27; =&gt; &#x27;We need to know your e-mail address!&#x27;,]; Answer:客製化 input &#39;email&#39;, rule &#39;required&#39; 的 error message, 可將 $message 帶入 Validator::make() 的 arg3 # Specifying Custom Messages In Language FilesLaravel validation 中, 如果我要全域的客製化錯誤訊息, 可以在哪一個檔案中做修改?resources/lang/xx/validation.php, xx = 語言種類, 比如說, en 以下位於 resources/lang/en/validation.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;custom&#x27; =&gt; [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27; =&gt; &#x27;We need to know your e-mail address!&#x27;, ],], Answer:Global 定義 input 為 email, rule 為 required 的錯誤訊息 # Specifying Custom Attributes In Language Files以下位於 resources/lang/en/validation.php 的 Laravel example code 的意思是？ Example:&lt;?php&#x27;attributes&#x27; =&gt; [ &#x27;email&#x27; =&gt; &#x27;email address&#x27;,], Answer:global 定義 attribute, 定義完成後, input 為 email 的 error message 都會顯示 email address # Specifying Custom Values In Language Files以下的 Laravel example code 的意思是？ Example:&lt;?phpValidator::make($request-&gt;all(), [ &#x27;credit_card_number&#x27; =&gt; &#x27;required_if:payment_type,cc&#x27;]);// 錯誤訊息The credit card number field is required when payment type is cc.// 在 resources/lang/en/validation.php 修改&#x27;values&#x27; =&gt; [ &#x27;payment_type&#x27; =&gt; [ &#x27;cc&#x27; =&gt; &#x27;credit card&#x27; ],],// 新錯誤訊息The credit card number field is required when payment type is credit card. Answer:如果 input payment_type 的 value 為 cc, 那就使用 rule required 驗 input credit_card_numberLaravel 預設的 error message 會拿 payment 的 value 來回覆, 所以可以在 &#39;resources/lang/en/validation.php&#39; 檔案中自定義, 若 input payment_type 的 value 為 cc, 則在 error message 終將之轉換為 credit card # Available Validation Rules# acceptedLaravel validation 中, 如果我要驗證一個 input 的 value 必須是 yes, on, 1, 或 true, 那我可以使用哪一個 rule?accepted # active_urlLaravel validation 中, 如果我要驗證一個 input 的 value 必須是一個 url, 經過 DNS 正解之後必須是 A 或 AAAA record, 我可以使用哪一個 rule?active_url # after:date以下的 Laravel Validation example code 的意思是？ Example:&lt;?php&#x27;start_date&#x27; =&gt; &#x27;required|date|after:tomorrow&#x27; Answer:input start_date 必須 present 及 filled, 須符合 date format, 且日期需在明天之後 以下的 Laravel validation example code 的意思是？ 第一個 input validation:&lt;?php&#x27;finish_date&#x27; =&gt; &#x27;required|date|after:start_date&#x27; Answer:&#39;finish_date&#39; 為 required, 格式需為 date, 且日期需在 &#39;start_date&#39; 這個 input 之後 # after_or_equal:date以下的 Laravel validation example code 的意思是？ Example:&lt;?php&#x27;start_date&#x27; =&gt; &#x27;required|date|after_or_equal:tomorrow&#x27; Answer:&#39;start_date&#39; 為 required, 格式需為 date, 且需為明天或明天之後的日期 # alphaLaravel 中, 如果我要驗證一個 input 單純由字母所組成, 我可以使用哪一個 validation rule?alpha # alpha_dashLaravel 中, 如果我驗證一個 input 只可含有 字母, 數字, - 或 _, 我可以使用哪一個 validation rule?alpha_dash # alpha_numLaravel 中, 如果我驗證一個 input 只可含有 字母, 數字, 我可以使用哪一個 validation rule?alpha_num # arrayLaravel 中, 如果我要驗證一個 input 必須是一個 array, 我可以使用哪一個 validation rule?array # before:dateLaravel 中, 如果我要驗證一個 input 必須是在某個指定的日期之前, 我可以使用哪一個 validation rule?before:date # before_or_equal:dateLaravel 中, 如果我要驗證一個 input 必須是相等於某個指定的日期, 或在這個日期之前, 那我可以使用哪一個 validation rule?before_or_equal:date # between:min,maxLaravel 中, 如果我要驗證一個 input 必須是介於兩個數值之間, 這兩個數值可以是 string, number, array 或 files, 我可以使用哪一個 validation rule?between:min,max # booleanLaravel 中, 如果我要驗證一個 input 必須是 boolean, 即 true, false, 1, 0, &quot;1&quot;, 或 &quot;0&quot;, 那我可以使用哪一個 validation rule?boolean # confirmedLaravel 中, 如果我在 password input 使用了 confirmed rule, 那我必須還要有另外一個 input 的名稱叫做什麼？password_confirmation Laravel 中, 如果我想要驗證兩個 input 必須有一模一樣的 value, 舉例來說, 讓用戶輸入密碼以及再次輸入密碼來確保用戶沒有不小心輸入錯誤, 那我可以使用哪一個 validation rule?confirmed # dateLaravel 中, 如果我要驗證一個 input 必須是 non-relative 的日期格式, 那我可以使用哪一個 validation rule?date # date_equals:dateLaravel中, 如果我要驗證一個 input 必須是一個日期且需與指定的日期相同, 那我可以使用哪一個 validation rule?date_equals:date # date_format:formatLaravel 中, 如果我要驗證一個 input 需跟我指定的日期格式相同, 那我可以使用哪一個 validation rule?date_format:format Laravel validation rule 當中, date_format 與 date 可否混用?不可 # different:fieldLaravel validation 中, 如果我要驗證兩個 input 的 value 必須要是不同的, 那我可以使用哪一個 validation rule?different:field # digits:valueLaravel 中, 如果我要驗證一個 input 必須是 numeric, 且需與指定的位數一樣, 不可負數, 那我可以使用哪一個 validation rule?digits:value Laravel validation rule 中, digits:value 這個 rule 可否含有小數點？不可 Laravel validation rule 中, digits:value 這個 rule 可否含有負數？不可 # digits_between:min,maxLaravel 中, 如果我要驗證一個 input 必須為 numeric, 且長度須介於我指令的兩個 value, 那我可以使用哪一個 validation rule?digits_between:min,max # dimensions以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpdimensions:min_width=minWidth,max_width=maxWidth,min_height=minHeight,max_height=maxHeight,ratio=ratio1/ratio2 Answer:定義 input image 須符合的最小寬度, 最大寬度, 最小高度, 最大高度, 以及長寬比 以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpdimensions:width=width,height=height Answer:定義 input image 須符合的寬度, 高度 以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpRule::dimensions()-&gt;maxWidth(1000)-&gt;maxHeight(500)-&gt;ratio(3 / 2) Answer:使用 Rule class 的 dimensions() 來定義最大寬度, 最大高度, 以及長寬比 # distinctLaravel 中, 假如我要驗一個 input, 這個 input 是一個 array, 我要確保 array 下的 field 的 value 必須不可重複, 舉例來說, foo array 下 不同 element 的 id field 的 value 必須不可相同, 我可以使用哪一個 validation rule?distinct # emailLaravel 中, 如果我要驗證一個 input, 其 value 必須是 email 格式, 我可以使用哪一個 validation rule?email Laravel 中, 可以使用不同的規則驗證 email 嗎？可以, 可參考官方文件 Laravel 中, validation email rule 預設使用哪一個 validation?RFCValidation # ends_with:foo,bar,…Laravel 中, 如果我要驗證 input 必須是指定的 value 結尾, 我可以使用哪一個 validation rule?ends_with # exclude_if:anotherfield,value以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpexclude_if:anotherfield,value Answer:當另外一個指定的 field 的 value 為某值, 排除此 input 的驗證 # exclude_unless:anotherfield,value以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpexclude_unless:anotherfield,value Answer:除非指定的 field 的 value 為某值, 否則一律排除此 input 的驗證 # exists:table,columnLaravel 中, 如果我要驗證一個 input, 這個 input 必須存在於指定的 table 中的指定 column, 那我可以使用哪一個 validation rule?exists:table,column Basic Usage Of Exists Rule以下的 Laravel validation rule 當中, 什麼情況之下可以不需指定 column 名稱？ validation rule:&lt;?php&#x27;state&#x27; =&gt; &#x27;exists:states&#x27; Answer:當 input 的 field 名稱跟 column 一樣時 Specifying A Custom Column Name以下的 Laravel validation rule 當中, abbreviation 代表的是？ validation rule:&lt;?php&#x27;state&#x27; =&gt; &#x27;exists:states,abbreviation&#x27; Answer:指定該 table 中的 column 以下的 Laravel Validation example code 的意思是？ Example:&lt;?php&#x27;email&#x27; =&gt; &#x27;exists:connection.staff,email&#x27; Answer:input email 的 value 需存在於 database connection, table staff, column email Laravel 中, exists validation rule 可以指定 model 來代替 table name 嗎？可以哦 以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;user_id&#x27; =&gt; &#x27;exists:App\\User,id&#x27; Answer:使用 model name 代替 table name 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27;, Rule::exists(&#x27;staff&#x27;)-&gt;where(function ($query) &#123; $query-&gt;where(&#x27;account_id&#x27;, 1); &#125;), ],]); Answer:input email 的 value 需存在於 table staff, 條件 where(‘account_id’, 1) 的 column email 當中 # fileLaravel 中, 如果我要驗一個 input 必須是 file, 那我可以使用哪一個 validation rule?file # filledLaravel 中, 如果我要驗一個 input, 內容不可為 empty, 我可以使用哪一個 validation rule?filled # gt:fieldLaravel 中, 如果我要驗一個 input, 其 value 必須大於另外一個指定的 input, 我可以使用哪一個 validation rule?gt:field # gte:fieldLaravel 中, 如果我要驗一個 input, 其 value 必須大於或等於另外一個指定的 input, 我可以使用哪一個 validation rule?gte:field # imageLaravel 中, 如果我要驗一個 input, 其 value 必須是一個 image, 即 jpeg, png, bmp, gif, svg, webp, etc…, 我可以使用哪一個 validation rule?image # in:foo,bar,…Laravel 中, 如果我要驗一個 input, 其 value 必須要被你指定的 value list 包含在內, 那我可以使用哪一個 validation rule?in:foo,bar,… 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;zones&#x27; =&gt; [ &#x27;required&#x27;, Rule::in([&#x27;first-zone&#x27;, &#x27;second-zone&#x27;]), ],]); Answer:指定 input ‘zones’ 的 value 必須為 ‘first-zone’, 或 ‘second-zone’, 同資料庫中 enum type 的概念 Laravel 中, 如果我要使用 Rule 來定義一個 in 規則, 我可以怎麼做？ # in_array:anotherfield.*Laravel 中, 如果我要驗證一個 input, 其 value 必須被 另外一個 input 的 value 包含在內, 所以說另外一個 input 的 value 可能會是一個 array, 那我可以使用哪一個 validation rule?in_array:anotherfield.* # integerLaravel 中, 如果我要驗一個 input, 其 value 必須是一個 integer, 我可以使用哪一個 validation rule?integer Laravel 中, validation rule integer, 會去驗證 input 的型別是否是 integer 嗎？不會 Laravel 中, validation rule integer, 實際上是驗證什麼？string 或是有著 數字的 string, 換句話說, 若是全數字的 string 也算通過 # ipLaravel 中, 如果我要驗一個 input 是否一個 IP address, 我可以使用哪一個 validation rule?ip # ipv4Laravel 中, 如果我要驗一個 input, 其 value 是否符合 IPv4 address 格式, 我可以使用哪一個 validation rule?ipv4 # ipv6Laravel 中, 如果我要驗一個 input, 其 value 是否符合 IPv6 address 格式, 我可以使用哪一個 validation rule?ipv6 # jsonLaravel 中, 如果我要驗一個 input, 其 value 是否為一個 json 字串, 我可以使用哪一個 validation rule?json # lt:fieldLaravel 中, 如果我要驗一個 input, 其 value 必須小於另外一個指定的 input, 我可以使用哪一個 validation rule?lt:field # lte:fieldLaravel 中, 如果我要驗一個 input, 其 value 必須小於或等於另外一個指定的 input, 我可以使用哪一個 validation rule?lte:field # max:valueLaravel 中, 如果我要驗一個 input, 其 value 必須 小於或等於 一個指定的 value, 那我可以使用哪一個 validation rule?max:value # mimetypes:text/plain,…以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;video&#x27; =&gt; &#x27;mimetypes:video/avi,video/mpeg,video/quicktime&#x27; Answer:驗證 input video 的 minetypes Laravel 中, 當我使用 validation rule minetypes 時, 框架會真正去讀這個檔案嗎?會哦 Laravel 中, 當我使用 validation rule minetypes 時, 有可能框架驗到的跟 client 提供的 minetypes 不同嗎? 為什麼? 會哦 因為框架會自己去讀檔案, 不會以 client 提供的為依據 Laravel 中, validation rule minetypes, 是會比對實際上框架讀的 minetypes, 還是讀到 minetypes 之後再去取得相對應得副檔名？實際上框架讀的 minetypes # mines:foo,barLaravel 中, 如果我要驗一個 input, 其 value 必須要是我指定的 minetype 相對應的副檔名, 那我可以使用哪一個 validation rule?mines:foo,bar,… Laravel 中的 validation rule mines 會去呼叫哪一個 method?guessExtension Laravel 中的 validation rule mines 會去呼叫 guessExtension, 然後 guessExtension 會去呼叫哪一個 method? getMineType Laravel 中的 validation rule mines 會去讀檔案內容以判斷其 minetypes 嗎？會的 哪裡可以找到 minetype 以及其相對應的 extension?文件 # min:valueLaravel 中, 如果我要驗證一個 input, 其 value 必須大於或等於我所指定的一個值, 那我可以使用哪一個 validation rule?min:value # not_in:foo,bar,…Laravel 中, 如果我要驗一個 input, 其 value 不可被包含在我所提供的一個 list 當中, 即該 list 可以是一個 array, 那我可以使用哪一個 validation rule?not_in:foo,bar,… 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;toppings&#x27; =&gt; [ &#x27;required&#x27;, Rule::notIn([&#x27;sprinkles&#x27;, &#x27;cherries&#x27;]), ],]); Answer:使用 Rule class 的定義 notIn rule, input toppings 的 value 不可為 sprinkles 或 cherries # not_regex:patternLaravel 中, 如果我要驗一個 input, 其 value 不可符合我所定義的 regex pattern, 那我可以使用哪一個 validation rule?not_regex:pattern Laravel 中, 當我使用 not_regex 及 regex 預設 validation rule 時, 該使用 array 形式, 還是 pipe 形式？array, 如下 example: Example:&lt;?php$validatedData = $request-&gt;validate([ &#x27;password&#x27; =&gt; [&#x27;required&#x27;, &#x27;regex:^(?=.*[a-z]|.*[A-Z])(?=.*[\\d])(?=.*[\\W])[\\w@$%\\^&amp;]&#123;8,16&#125;$&#x27;],]); Larevel 的 validation rule regex 以及 not_regex, 其格式須符合 PHP 的哪一個 function?preg_match # numericLaravel 中, 如果我要驗一個 input, 其 value 需為 numeric, 那我可以使用哪一個 validation rule?numeric Laravel validation rule 中的 numeric 跟 integer 差別在哪？numeric 可以有小數點, integer 為整數 # passwordLaravel 中, 如果我要驗一個 input, 其 value 必須可以通過登入者的 password 驗證, 那我可以使用哪一個 validation rule?password Laravel 的 validation rule password 可否指定 guard? 怎麼做？ 可&#x27;password&#x27; =&gt; &#x27;password:api&#x27; # presentLaravel 中, 如果說我要驗一個欄位必須要出現在 request 的 input list 裡, 至於有沒有 value 的話不管, 那我可以使用哪一個 validation rule?present # requiredLaravel 中, 如果我要驗一個 input, 該欄位必須要出現在 input data 之中, 且欄位的值不可為 null, 那我可以使用哪一個 validation rule?required Laravel validation rule required 中, 欄位在哪四種情況下會被視為 “empty”? The value is null. The value is an empty string. The value is an empty array or empty Countable object. The value is an uploaded file with no path. Laravel 中, required 的驗證條件是？ input data 中必須要有該欄位 該欄位不可為 null 以下的 Laravel validation example code 的意思是？ Example:&lt;?phppresent:field_name Answer:input data 中必須要有該欄位就可, 欄位是否為空不驗 Laravel 中, filled 的驗證條件是？ input data 中如果有出現的欄位, 其欄位不可為 empty, 如果沒出現則不管 # required_if:anotherfield,value,…以下的 Laravel Validation example code 的意思是？ Example:&lt;?phprequired_if:anotherfield,value,... Answer:如果 anotherfield 的 value 為某值時, require 此 input Laravel 中, 如果我使用 Rule class 來定義 required_if, 那 requiredIf method 接受什麼樣的 arguments? boolean closure Laravel 中, 如果我使用 Rule class 來定義 required_if, 並且帶入 closure, 那 closure 的輸出必須要是什麼型別？boolean 以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($request-&gt;all(), [ &#x27;role_id&#x27; =&gt; Rule::requiredIf($request-&gt;user()-&gt;is_admin),]); Answer:如果 $request-&gt;user()-&gt;is_admin 為 true 的話, 就 require input role_id, 也可帶入 closure 以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($request-&gt;all(), [ &#x27;role_id&#x27; =&gt; Rule::requiredIf(function () use ($request) &#123; return $request-&gt;user()-&gt;is_admin; &#125;),]); Answer:如果 $request-&gt;user()-&gt;is_admin 為 true 的話, 就 require input role_id, 也可在 requiredIf() 內直接帶入 $request-&gt;user()-&gt;is_admin # required_unless:anotherfield,value,…以下的 Laravel Validation example code 的意思是？ Example:&lt;?phprequired_unless:anotherfield,value,.. Answer:一律 require input, 除非 anotherfield 的 value 為某值 # required_with:foo,bar,…以下的 Laravel Validation example code 的意思是？ Example:&lt;?phprequired_with:foo,bar,... Answer:require input 當指定的 field present # required_with_all:foo,bar,…以下的 Laravel Validation example code 的意思是？ Example:&lt;?phprequired_with_all:foo,bar,... Answer:require input 當指定的 fields 全部都有 present # required_without:foo,bar,…以下的 Laravel Validation example code 的意思是？ Example:&lt;?phprequired_without:foo,bar,... Answer:如果指定的 field 沒有 present, 那就 require input # required_without_all:foo,bar,…以下的 Laravel Validation example code 的意思是？ Example:&lt;?phprequired_without_all:foo,bar,... Answer:如果指定的 field 全部都沒有 present, 則 require input # same:fieldLaravel 當中, 如果我要驗一個 field, 其 value 必須跟我指定的另外一個 field 的 value 是一樣的, 那我可以使用哪一個 validation rule?same:field # size:valueLaravel 當中, 如果我要驗一個 field, 其 value 的 size 必須要跟我指定的相同, 那我可以使用哪一個 validation rule?size:value Laravel validation rule size:value 中, 如果 input 是 string, 那 value 會是？string 的字元數目 Laravel validation rule size:value 中, 如果 input 是 integer, 那 value 會是？integer 的值 Laravel validation rule size:value 中, 如果 input 是 array, 那 value 會是？array 的 count Laravel validation rule size:value 中, 如果 input 是 files, 那 value 會是？files 的大小 Laravel validation rule size:value 中, 如果 input 是 files, 那 value 會是 files 大小, 以什麼為單位？kilobytes # starts_with:foo,bar,…Laravel 中, 如果我要驗一個 field, 其 value 必須要是指定的 value 開頭, 那我可以使用哪一個 validation rule?starts_with:foo,bar,… # stringLaravel 當中, 如果我要驗一個 field, 其 value 必須是不可為 null 的 string, 那我可以使用哪一個 validation rule?string # timezoneLaravel 當中, 如果我要驗一個 input, 其 value 必須是一個可被 PHP function timezone_identifiers_list 驗證合法的 timezone, 那我可以使用哪一個 validation rule?timezone # unique:table,column,except,idColumn以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpunique:table,column,except,idColumn Answer:input 的 value 必須不存在於指定的 table, columnarg3 為 except, arg4 為 except 的 column, 預設為 id 可不帶比如說, unique:users,name,ray@example.com,email, 這樣就會用 unique rule 去驗 users table 的 name column, 但略過 email column 為 &#x72;&#97;&#121;&#x40;&#101;&#x78;&#x61;&#x6d;&#x70;&#108;&#101;&#46;&#x63;&#x6f;&#109; 的 row Specifying A Custom Table / Column Name:Laravel validation rule unique 中, 除了指定 table 之外, 我可否指定 model?可 Laravel validation rule unique 中, 什麼樣的條件之下我可以不需指定 column ?當我 input 的 field name 跟 column name 一樣時 Custom Database Connection以下的 Laravel Validation example code 的意思是？ Example:&lt;?php&#x27;email&#x27; =&gt; &#x27;unique:connection.users,email_address&#x27; Answer:指定 database 為 connection Forcing A Unique Rule To Ignore A Given ID:以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27;, Rule::unique(&#x27;users&#x27;)-&gt;ignore($user-&gt;id), ],]); Answer:&#39;email&#39; value 在 users table, email column 中需為 unique, 但忽略 $user-&gt;id 的 row 以下的 Laravel example 中, ignore() 的 parameter 可以從 request 直接取得嗎？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27;, Rule::unique(&#x27;users&#x27;)-&gt;ignore($user-&gt;id), ],]); Answer:不可, 為避免 SQL injection, 若要帶入 Request 的 attributes 那要先 sanitise 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27;, Rule::unique(&#x27;users&#x27;)-&gt;ignore($user), ],]); Answer:&#39;email&#39; value 在 users table, email column 中需為 unique, 但忽略 $user-&gt;id 的 row, 預設會尋找 id, 所以可直接帶入 $user model 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27;, Rule::unique(&#x27;users&#x27;)-&gt;ignore($user-&gt;id, &#x27;user_id&#x27;), ],]); Answer:&#39;email&#39; value 在 users table, email column 中需為 unique, 但忽略 $user-&gt;id 的 row, 此 example 中 primary key column 不叫 id, 而是叫 user_id 以下的 Laravel example code 的意思是？ Example:&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ &#x27;email&#x27; =&gt; [ &#x27;required&#x27;, Rule::unique(&#x27;users&#x27;, &#x27;email_address&#x27;)-&gt;ignore($user-&gt;id, &#x27;user_id&#x27;), ],]); Answer:&#39;email&#39; value 在 users table, email column 中需為 unique, 此 example 中, email column 實際名稱為 &#39;email_address&#39;, 若是跟 input 相同的話 arg2 可省略。忽略 $user-&gt;id 的 row。此 example 中 primary key column 不叫 id, 而是叫 user_id Adding Additional Where Clauses以下的 Laravel example code 的意思是？ Example:&lt;?php&#x27;email&#x27; =&gt; Rule::unique(&#x27;users&#x27;)-&gt;where(function ($query) &#123; return $query-&gt;where(&#x27;account_id&#x27;, 1);&#125;) Answer:&#39;email&#39; input 的 value 在 users table, email column, where(‘account_id’, 1) 的篩選後的 records 中, 需為 unique # urlLaravel 中, 如果我要驗一個 input, 其 value 必須要是一個 url, 那我可以使用哪一個 validation rule?url # uuidLaravel 中, 如果我要驗一個 input, 其 value 必須要是一個 uuid, 那我可以使用哪一個 validation rule?uuid # Conditionally Adding Rules# Validating When PresentLaravel 中, 如果我要驗一個 input, 如果該 input 有出現在 request 的 input array 中的話我才驗, 若是不存在我就不驗, 那我可以使用哪一個 validation rule?sometimes 以下的 Laravel Validation example code 的意思是？ Example:&lt;?php$v = Validator::make($data, [ &#x27;email&#x27; =&gt; &#x27;sometimes|required|email&#x27;,]); Answer:required rule 會驗證該 input 必須要 present 且 filled, 但若是使用 sometimes rule, 當該 input 不存在時, 後面的 rule 都不會實施 # Complex Conditional Validation請解釋以下的 Laravel 程式碼的語意？ 程式碼&lt;?php$v-&gt;sometimes(&#x27;reason&#x27;, &#x27;required|max:500&#x27;, function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); Answer:如果 closure 的 return 值為 true, 就驗 reason 這個 input, rule 為 required|max:500 以下的 Laravel example code 的意思是？ 程式碼&lt;?php$v-&gt;sometimes([&#x27;reason&#x27;, &#x27;cost&#x27;], &#x27;required|max:500&#x27;, function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); Answer:當 closure return true, 驗證 &#39;reason&#39;, &#39;cost&#39; input, 使用 &#39;required|max:500&#39; rule 以下的 Laravel 程式碼中, $input 是哪一個 class 的 instance? 程式碼&lt;?php$v-&gt;sometimes(&#x27;reason&#x27;, &#x27;required|max:500&#x27;, function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); Answer:Illuminate\\Support\\Fluent # Validating ArraysLaravel validation 當中, 如果說 photos 是一個 array, 我要驗證該 photos 裡 key 為 profile 的 value, 該 value, 規則為 required|image, 那我可以怎麼做？&lt;?php$validator = Validator::make($request-&gt;all(), [ &#x27;photos.profile&#x27; =&gt; &#x27;required|image&#x27;,]); 以下的 Laravel example code 的意思是？ Example:&lt;?php$validator = Validator::make($request-&gt;all(), [ &#x27;person.*.email&#x27; =&gt; &#x27;email|unique:users&#x27;, &#x27;person.*.first_name&#x27; =&gt; &#x27;required_with:person.*.last_name&#x27;,]); Answer:(1) 對 person array 下的每一個 element 中的 email 驗證(2) 對 person array 下的每一個 element 中的 first_name 驗證, 且當前 element 下需有 last_name 我才驗 required rule # Custom Validation RulesLaravel 中, 如果我要客製 validation rule 的話, 有哪幾種方式？ rule object closure extensions # Using Rule ObjectsLaravel 中, 如果我要使用 CLI 建立一個 rule, 指令該怎麼下？php artisan make:rule RuleName 以下的 Laravel example code 的意思是？ Example:&lt;?phpnamespace App\\Rules;use Illuminate\\Contracts\\Validation\\Rule;class Uppercase implements Rule&#123; public function passes($attribute, $value) &#123; return $value === 1; &#125; public function message() &#123; return &#x27;The :attribute must be uppercase.&#x27;; &#125;&#125; Answer:$passes() 需 return boolean, 代表該 rule 驗證通過與否$message() 為驗證失敗時, 錯誤訊息$attribute 為 input name$value 為 input value 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function message()&#123; return trans(&#x27;validation.uppercase&#x27;);&#125; Answer:客製 error message, 從自定義的 translation file 中取得 error message 以下的 Laravel Validation example code 的意思是？ Example:&lt;?phpuse App\\Rules\\Uppercase;$request-&gt;validate([ &#x27;name&#x27; =&gt; [&#x27;required&#x27;, &#x27;string&#x27;, new Uppercase],]); Answer:使用自定義的 rule Uppercase # Using Closures以下的 Laravel example code 的意思是？ Example:&lt;?php$validator = Validator::make($request-&gt;all(), [ &#x27;title&#x27; =&gt; [ &#x27;required&#x27;, &#x27;max:255&#x27;, function ($attribute, $value, $fail) &#123; if ($value === &#x27;foo&#x27;) &#123; $fail($attribute.&#x27; is invalid.&#x27;); &#125; &#125;, ],]); Answer:定義一個 closure based validation rule$attribute 等於 input name, 即 ‘title’$value 等於 input value$fail 裡頭是 error message # Using ExtensionsLaravel 中, 請解釋以下的 extension example Example:&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Support\\Facades\\Validator;class AppServiceProvider extends ServiceProvider&#123; public function register() &#123; // &#125; public function boot() &#123; Validator::extend(&#x27;foo&#x27;, function ($attribute, $value, $parameters, $validator) &#123; return $value == &#x27;foo&#x27;; &#125;, &#x27;The value must be foo&#x27;); &#125;&#125; Answer:在 AppServiceProvider 的 boot method 中, 使用 validator class 的 extend method 來定義新的 validation rule# 1. 新的 validation rule 名稱為 foo# 2. $attribute 為 input 名稱# 3. $value 為 input value# 4. $parameters 為一個 array, 可帶入 rule 的參數# 5. $validator 為 Validator instance# 6. extend() 的第三個 argument 可自訂 error message 以下的 Laravel example code 的意思是？ Example:&lt;?phpValidator::extend(&#x27;foo&#x27;, &#x27;FooValidator@validate&#x27;); Answer:當使用 validator class 的 extend method 自定義新的 validation rule 時, 也可指定 controller 來取代 closure # Defining The Error MessageLaravel 中, 當我使用 extension 來自定義 validation rule 時, 我可以經 Error Message 定義在 language validation file 的哪一層中？第一層 Laravel 中, 當我使用 extension 來自定義 validation rule 時, 我可以經 Error Message 定義在 language validation file 的第一層, 為什麼不是定義在 custom 層下？因為這是一個新的 rule 的 message, 不是 attribute-specific message 以下的 Laravel example code 的意思是？ Example:&lt;?phppublic function boot()&#123; Validator::extend(...); Validator::replacer(&#x27;foo&#x27;, function ($message, $attribute, $rule, $parameters) &#123; return str_replace(array(&#x27;:value&#x27;, &#x27;:other&#x27;), $parameters, $message); &#125;);&#125; Answer:在 AppServiceProvider 中, 針對 validation extend rule ‘foo’ 做佔位符帶入, 比方說, $message = ‘The :value must be greater than :other’, 而 $parameter 便可以是一個 array([‘price’, ‘cost’]), 因此錯誤訊息會是 ‘The price must be greater than cost’ # Implicit Extensions以下的 Laravel validation example 的結果會是 true 還是 false? Why? Example:&lt;?php$rules = [&#x27;name&#x27; =&gt; &#x27;unique:users,name&#x27;];$input = [&#x27;name&#x27; =&gt; &#x27;&#x27;];Validator::make($input, $rules)-&gt;passes(); Answer:true, 因為 rule 對於沒有 present 的 attribute, 或值為 empty string 的 attribute 不會生效 以下的 Laravel example code 的意思是？ Example:&lt;?phpValidator::extendImplicit(&#x27;foo&#x27;, function ($attribute, $value, $parameters, $validator) &#123; return $value == &#x27;foo&#x27;;&#125;); Answer:Laravel 預設不會執行 rule, 當 attribute 沒有出現在 input array list, 除了使用 required 之外, 可使用 extendImplicit method 強制執行 以下的 Laravel example code 中, implement ImplicitRule 的意思是？ Example:&lt;?phpclass CheckMerchantChannelValidForAssigning implements ImplicitRule &#123; protected $withdraw; public function __construct(Withdraw $withdraw) &#123; $this-&gt;withdraw = $withdraw; &#125; public function passes($attribute, $value) &#123; return in_array($value, MerchantChannel::ofSuitableForAssigningToWithdraw($this-&gt;withdraw)-&gt;get()-&gt;pluck(&#x27;id&#x27;)-&gt;toArray()); &#125; public function message() &#123; return &#x27;The merchant channel is invalid&#x27;; &#125;&#125; Answer:當使用 Laravel validation rule object 時, 如果驗證對象 attribute 沒有出現在 input array list 當中的話, Laravel 預設不會執行這個 rule, 那如果我要強制執行該 rule, implement implicitRule 可以強制執行該 rule # AdditionalLaravel 當中, 以下的 agent_id 驗證 exists 邏輯代表什麼意思？在 users table 當中, 帶入的 agent_id 必須要跟 table 裡頭的 id 相同, 且 role_id 必須得跟 Role::AGENT 相同 &lt;?php request()-&gt;validate([ &#x27;q&#x27; =&gt; &#x27;nullable | string | max:255&#x27;, &#x27;row&#x27; =&gt; &#x27;nullable | int | digits_between:1,3&#x27;, &#x27;agent_id&#x27; =&gt; &#x27;nullable | exists:users,id,role_id,&#x27;.Role::AGENT, ]); 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass SendReviewRequest extends Request&#123; public function rules() &#123; return [ &#x27;reviews&#x27; =&gt; [&#x27;required&#x27;, &#x27;array&#x27;], &#x27;reviews.*.id&#x27; =&gt; [ &#x27;required&#x27;, Rule::exists(&#x27;order_items&#x27;, &#x27;id&#x27;)-&gt;where(&#x27;order_id&#x27;, $this-&gt;route(&#x27;order&#x27;)-&gt;id) ], &#x27;reviews.*.rating&#x27; =&gt; [&#x27;required&#x27;, &#x27;integer&#x27;, &#x27;between:1,5&#x27;], &#x27;reviews.*.review&#x27; =&gt; [&#x27;required&#x27;], ]; &#125;&#125; Answer:在 request 中, 可以使用 $this-&gt;route 取得 route parameter 中的 order model 以下的 Laravel example code 的意思是？ Example:&lt;?php$v = new Validator( $trans, [ &#x27;foo&#x27; =&gt; &#x27;true&#x27;, &#x27;bar&#x27; =&gt; &#x27;aaa&#x27; ], [ &#x27;foo&#x27; =&gt; &#x27;accepted_if:bar,aaa&#x27; ]); $this-&gt;assertTrue($v-&gt;passes()); Answer:使用 accepted_if, 如果 bar field 為 aaa, 則 foo 需為 accepted 以下的 Laravel example code 的意思是？ Example:&lt;?phpPassword::min(8)Password::min(8)-&gt;letters()Password::min(8)-&gt;mixedCase()Password::min(8)-&gt;numbers()Password::min(8)-&gt;symbols() Answer:&lt;?php// require 至少 8 個 charactersPassword::min(8)// require 至少一個字母Password::min(8)-&gt;letters()// require 至少一個大寫字母一個小寫字母Password::min(8)-&gt;mixedCase()// require 至少一個 numberPassword::min(8)-&gt;numbers()// require 至少一個特殊符號Password::min(8)-&gt;symbols()// 產生的密碼必須沒有被曝光過Password::min(8)-&gt;uncompromised() 以下的 Laravel example code 的意思是？ Example:&lt;?php// 任一 service provideruse Illuminate\\Validation\\Rules\\Password;public function boot()&#123; Password::defaults(function () &#123; $rule = Password::min(8); return $this-&gt;app-&gt;isProduction() ? $rule-&gt;mixedCase()-&gt;uncompromised() : $rule; &#125;);&#125;&#x27;password&#x27; =&gt; [&#x27;required&#x27;, Password::defaults()], Answer:註冊 default password rule","link":"/zh-tw/laravelTheBasicsValidation/"},{"title":"Leetcode 筆記","text":"# 前言Leetcode 奮鬥筆記 出來混總是要還的, 一天一小步, 一年一大步。 Practice makes perfection # 正文# array# 59. Spiral Matrix II 示意圖: 思路： 這題也是卡了我很久。 初次接觸這種題型, 我覺得可以先把圖畫出來, 先定義一下邏輯該怎麼走, 再來思考該怎麼實作 可參考上圖, 不同顏色代表不同的方向, 以及每次 insert 的範圍。 由上圖可以得到一些資訊(1) 第一層的 offset 為 1(2) 第二層開始, 每層的 offset 固定為 2(3) 若 $n / 2 !== 0, 則會有中間單獨一個數字存在, 其位置為 $res[floor($n / 2)][floor($n / 2)](4) 可以看到, 輸出會是 [$n 個 array](5) 共有 $n 層 有了上面歸納出的規則, 我們就可以開始實作, 具體參考代碼 時間複雜度, 由於需要 insert $n 的二次方個數, 所以時間複雜度會是 O(n 的平方) 題目連結 solution example class Solution &#123; /** * @param Integer $n * @return Integer[][] */ function generateMatrix($n) &#123; $res = array_fill(0, $n, array_fill(0, $n, 0)); $loop = $mid = (int) ($n / 2); $x = $y = 0; $offset = 1; $count = 1; while ($loop &gt; 0) &#123; $i = $x; $j = $y; for (; $i &lt; $x + $n - $offset; $i++) &#123; $res[$j][$i] = $count++; &#125; for (; $j &lt; $y + $n - $offset; $j++) &#123; $res[$j][$i] = $count++; &#125; for (; $i &gt; $x; $i--) &#123; $res[$j][$i] = $count++; &#125; for (; $j &gt; $y; $j--) &#123; $res[$j][$i] = $count++; &#125; $loop--; $x++; $y++; $offset+=2; &#125; if ($n%2 !== 0) &#123; $res[$mid][$mid] = $count; &#125; return $res; &#125;&#125; # 雙指針# 26. Remove Duplicates from Sorted Array 思路這題主要是用雙指針的概念 $left 由 $nums 的第一個 index 開始, 也就是 0 $right 開始往後 loop, 只要 $right 當下的值跟 $left 不相同, 那就代表不同的數出現了, 這時就可以更新 $left 指針, 由於 $nums 本身是 sorted array, 因此可以保證只要 loop 到的值不等同 $left, 那就一定是一個新的數, 不可能是 $left 已經跑過的數 由於 output 求的是重新排列後數組的長度 (不包含重複的數), 而 $left 是從 0 開始跑的, 因此要將 $left+1 題目連結 solution example class Solution &#123; /** * @param Integer[] $nums * @return Integer */ function removeDuplicates(&amp;$nums) &#123; $left = 0; for ($right = 0; $right &lt; count($nums); $right++) &#123; if ($nums[$right] !== $nums[$left]) &#123; $nums[++$left] = $nums[$right]; &#125; &#125; return $left+1; &#125;&#125; # 209. Minimum Size Subarray Sum 思路：這題最直接的暴力解法, 應該就是跑 double loop, 依序 loop 每一個 index, 並從每一個 index 再往後 loop, 不斷的相加更新 $sum 直到 $sum 大於 $target, 至此得到 $curLen, 然後重複這個步驟不停的 loop 直到比較完所有的 $curLen 並得到 $minLen, 這樣的時間複雜度為 O(n 的二次方)進階一點, 可使用 sliding window 概念 首先定義 $left, $right, 我們必須在演算法過程中不斷的更新這兩個數, 而這兩者的區間便是合法的 subarray, 而最小的 subarray 長度便是我們要的答案一開始 $right 往右 loop, 並與上一個 $right 相加維護 $sum, 只要 $sum 大於等於 $target, 至此, 便得到一個合法的 subarray, 此時我們記下他的長度 接下來我們更新 $left, 將 $sum - $left 直到 $sum 小於 $target, 在這個過程中, 如果 $sum 依然大於等於 $target, 這表示此 subarray 依然合法, 我們記下他的長度, 並將 $left++ 繼續 loop $left, 直到 $sum 小於等於 $target, 至此, subarray 不再合法, 我們可以再回到 $right 重複上面的步驟, 相當於不斷的在維護一個 sliding window, 並在過程中記下所有合法的 window 的長度, 而最小的 window 長度便是我們要的答案。 此解法的時間複雜度為 O(n) 題目連結 solution example class Solution &#123; /** * @param Integer $target * @param Integer[] $nums * @return Integer */ function minSubArrayLen($target, $nums) &#123; $left = 0; $minLen = count($nums) + 1; for ($right = 0; $right &lt; count($nums); $right++) &#123; $curRV = $nums[$right]; $sum += $curRV; while ($sum &gt;= $target) &#123; $curLen = $right - $left + 1; if ($curLen &lt; $minLen) &#123; $minLen = $curLen; &#125; $sum -= $nums[$left]; $left++; &#125; &#125; if ($minLen === count($nums) + 1) &#123; return 0; &#125; return $minLen; &#125;&#125; # 167. Two Sum II - Input Array Is Sorted首先先明確題目的目標, 是要取得 $numbers 中, 兩個數相加會剛好等於 $target 的這兩個數的位置, 即 index + 1 dictionary:主要是維護一個 dictionary, loop $numbers, loop 到每一個 index 我們都用 $target 去扣掉當前的 value 得到 $diff, 並到 dictionary 去查這個 $diff 在嗎, 如果在, 那就代表兩個數相加等於 $target 這個條件是成立的, 接著我們只要取得當前的 index 以及 dictionary 當中等同 $diff 的 index 即可, 若是沒找到, 那就把當前的 value 放到 dictionary 中, 且記下其 index, 重複此步驟, 最多 loop 完整個 $numbers 即可得到這兩個數的位置 此法時間複雜度為 O(n), 空間複雜度為 O(n) (因為 dictionary 可能會有 n 個 index) two pointer:由於 $numbers 是一個 sorted array, 由小至大, 所以可以使用雙指針來解 首先定義 $left 以及 $right, 並將其相加得到一個 $sum, 如果 $sum 等同 $target, 直接破案拿到 $left 跟 $right 的位置, 如果 $sum 小於 $target, 代表 $left 可以往右移一格, 因為 $numbers 是有序的, 所以當前 $left 的下一個數勢必為此 array 中僅大於當前 $left 的數, 因此由此數來替換當前 $left 可取得下一個僅大於當前 $sum 的由兩個數相加的 $sum, 並用他再來跟 $target 比較一次 如果 $sum &gt; $target, 原理同上, 則移動 $right 往左推, 取得下一個僅小於當前 $right 的數 此法時間複雜度為 O(n), 空間複雜度為 O(1) (不管 n 是多少, 都只維護 $left, $right, $sum) 題目連結 雙指針 solution example class Solution &#123; /** * @param Integer[] $numbers * @param Integer $target * @return Integer[] */ function twoSum($numbers, $target) &#123; $map = []; for ($i = 0; $i &lt; count($numbers); $i++) &#123; $diff = $target - $numbers[$i]; if (array_key_exists($diff, $map)) &#123; return [$map[$diff]+1, $i+1]; &#125; $map[$numbers[$i]] = $i; &#125; &#125;&#125; dictionary solution example class Solution &#123; /** * @param Integer[] $numbers * @param Integer $target * @return Integer[] */ function twoSum($numbers, $target) &#123; $left = 0; $right = count($numbers) - 1; while ($left &lt; $right) &#123; $sum = $numbers[$left] + $numbers[$right]; if ($sum === $target) &#123; return [$left+1, $right+1]; &#125; elseif ($sum &gt; $target) &#123; $right--; &#125; elseif ($sum &lt; $target) &#123; $left++; &#125; &#125; &#125;&#125; # 二分查找# 34. Find First and Last Position of Element in Sorted Array 思路這題的暴力解法, 可以使用單層 loop, 從 index 0 依序往後遍歷, 若無符合 target 則為 [-1, -1], 若有找到, 則記下為 $left &amp; $right, 並繼續往後 loop, 若走到下個數時, $left 已存在, 則只更新 $right, 遍歷完整個 array 後可得到 $left &amp; $right, 時間複雜度為 O(n) 較進階的解法: 由於這是一個 sorted array, 因此可以採用二分查找 首先必須找到 $left, 根據 solution 中的 code, (int) ($left + ($right - $left) / 2);這邊確保了若 $left 與 $right 之間的數的數量非為基數 (也就是沒有一個剛好的中間點), 則 pivot 需是往左偏的, 這樣用意是為了避免無限迴圈, 因為 $nums[$pivot] &gt;= $target, $right = $pivot, 如果遇到 $left 與 $right 緊鄰彼此, 這時 $pivot 是偏右的話, 那就會無限迴圈了 $nums[$pivot] &gt;= $target, $right = $pivot, $nums 中同時有多個數值都為 $target 時, $right 會無限往左縮, 直到 $nums[$pivot] &lt; $target , 此時代表 $target 位於 $pivot 的右邊, 所以調整 $left 往右 題目連結 solution example class Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function searchRange($nums, $target) &#123; $left = 0; $right = count($nums) - 1; // 先假設 $target 不存在 $result = [-1, -1]; // 當 $left, $right 重疊也要斷開 while ($left &lt; $right) &#123; // $pivot 需偏左 $pivot = (int) ($left + ($right - $left) / 2); if ($nums[$pivot] &gt;= $target) &#123; $right = $pivot; &#125; else &#123; $left = $pivot + 1; &#125; &#125; // 如果 $nums[$left] 不存在 (超出 $nums 範圍), 或 $nums[$left] 不等於 $target, 則代表不存在直接 return if (!isset($nums[$left]) || $nums[$left] !== $target) &#123; return $result; &#125; $result[0] = $left; $right = count($nums) - 1; // 邏輯同上, 只是 $pivot 需偏右, 這樣 $left 往右推時, 當 $left 與 $right 緊鄰時, $pivot 才會偏右, 若偏左, 則 `$nums[$pivot] &lt;= $target` 這個條件會造成無限迴圈 while ($left &lt; $right) &#123; $pivot = (int) ($left + ($right - $left) / 2 + 1); if ($nums[$pivot] &lt;= $target) &#123; $left = $pivot; &#125; else &#123; $right = $pivot - 1; &#125; &#125; $result[1] = $right; return $result; &#125;&#125; # 長度最小/大子數組# 904 fruit into baskets 題目連結 sliding window, 花了一天且又參考別人的 code 才終於搞懂, 基本上原理同一般的 sliding window, 用我自己可以理解的話來說, 假設 $fruits 是一個 array, 裡面有很多水果,目的是要取出兩種水果持續出現最長的那一段。 window 的 right 會一直往右跑, 每跑一次, 我們都將當前的水果種類以及總共的數量放到 basket 中, 並且 right 每跑一次, 我們都記下當前長度, 以及最大長度。 而當basket 出現了三種水果, 這表示這個 subarray 已經不合乎標準了, 我們需要從 window 的另一端開始往後推, 每推一次, 就把籃子中對應的該水果數量減一, 而當該水果的數量歸零, 我們就把該水果拿掉,這下子籃子裡頭又恢復成兩種水果, 此時 start 的位置就是合法的 subarray 的起點, 這邊花了我很多時間理解, 為什麼籃子變成兩種水果時, subarray 就合法了？ 因為我們是從 start 按順序往後推的, 而之前right 也是按順序往後跑, 一個個的將水果加到籃子裡去, 所以只要移除的順序跟放入的順序是一致的, 當籃子水果回到兩種時, 那就可以說, 籃子裡頭剩下的種類以及數量, 都是屬於 start 跟 right 之間的水果, 而此時這段array 也符合了條件, 因此可以再次計算它的長度, 以及比較是否可以取代最大長度 class Solution &#123; /** * @param Integer[] $fruits * @return Integer */ function totalFruit($fruits) &#123; // $fruits array 中, 合法 subarray 的起點 $start = 0; $maxLen = 0; // 籃子, 主要用來統計已放入的水果的種類 &amp; 數量 $basket = []; for ($current = 0; $current &lt; count($fruits); $current++) &#123; // 當前要放入的水果 $currentFruit = $fruits[$current]; // 將當前水果放入籃子 $basket[$currentFruit]++; // 當籃子中有了三種水果, 這表示該 subarray 已經不合法, 要移動 start 位置使其再次合法 while (count($basket) &gt;= 3) &#123; // 從籃子中, 將起點指向的水果數量減一 $basket[$fruits[$start]]--; // 如果減完, 發現該水果數量已經歸零, 則從籃子中移除, 這樣就會恢復到兩種水果 if ($basket[$fruits[$start]] === 0) unset($basket[$fruits[$start]]); // 起點往後移 $start++; &#125; // 上面的 while loop 會讓 subarray 合法, 即將 start 移動到正確的位置, 所以一旦走到這行, 表示 start 已經位於正確的位置, 就可以計算目前合法 subarray 的長度 $currentLen = $current - $start + 1; // 比較目前 subarray 的長度是否可以取代最大長度 $maxLen = $currentLen &gt; $maxLen ? $currentLen : $maxLen; &#125; return $maxLen; &#125;&#125; # 76. Minimum Window Substring目標是要在一個 array 中, 找到符合目標 array 的最小 subarray。 這樣講有點抽象, 請通過題目連結去看看題目敘述 這題的暴力解, 是跑雙層 loop, 先 loop 每一個 $s index, 再從每一個 $sindex 往後 loop, 直到找到符合目標的 subarray, 並記下 left 以及長度, 最後再回傳最小的 subarray, 時間複雜度是 O(n 的平方)。 較佳的解法, 採用 sliding window, 藉由維護一個map, 由這個 map 來判斷 window 是否符合, 若是, 則比較長度, 若為最小長度, 則記下 left 以及長度 首先, 先建立一個 tMap, 這個 map 記錄著 $t 的 value 以及其數量, 接著開始 loop$s, 我們將每一個存在於 $t 中的 value 都存入 $wMap 由於存入是依照 $s 的 loop 順序存入的, 因此當 $wMap[$index] &lt;= $tMap[$index] 時, 代表距離目標又更近一步, 因此$distance++, 若 $wMap[$index] &gt; $tMap[$index], 則代表該 value 的數量在之前已經滿足了, 此時不需增加 $distance, 但一樣存入 $wMap 當 $distance 數量與 $t的長度相等, 這代表 $wMap 中有的 value 已經滿足 $t 的要求, 由於題目要求的是最小的 subarray, 因此我們需要從 window 的 left 開始往前推, 不斷的從 $wMap 中依序拿掉 value, 只要$distance 與 $t 的長度依然相等, 那就代表介於當下 $left 與 $right 之間的 window 是合法的, 我們取得這個 window 的長度並比較它是否是至今最小的, 如果是則記錄下當下的 left, 以及此長度 若$distance 再度小於 $tLen, 則代表當下介於 $left 與 $right 之間的 window 已經不再合乎要求, 即停止 $left 的推進, 回到 $right, 繼續從 $right 往右邊遍歷 重複這個步驟,直到完全遍歷 $s 題目連結 solution example code: class Solution &#123; /** * @param String $s * @param String $t * @return String */ function minWindow($s, $t) &#123; $sLen = strlen($s); $tLen = strlen($t); $begin = $left = $right = $distance = 0; $minStr = &#x27;&#x27;; $wMap = []; $tMap = []; $minLen = $sLen + 1; if ($sLen === 0 || $tLen === 0 || $sLen &lt; $tLen) &#123; return $minStr; &#125; // 建立 $tMap for ($tIndex = 0; $tIndex &lt; $tLen; $tIndex++) &#123; $curTV = $t[$tIndex]; $tMap[$curTV]++; &#125; while ($right &lt; $sLen) &#123; $curRV = $s[$right]; if (!array_key_exists($curRV, $tMap)) &#123; $right++; continue; &#125; $wMap[$curRV]++; // 表示距離目標近了一步, distance ++ if ($wMap[$curRV] &lt;= $tMap[$curRV]) &#123; $distance++; &#125; // 表示 window 已滿足條件 while ($distance === $tLen) &#123; $curLV = $s[$left]; if (!array_key_exists($curLV, $tMap)) &#123; $left++; continue; &#125; $curLen = $right - $left + 1; // 如果當下的長度是最短的, 則記下 $left 以及長度 if ($curLen &lt; $minLen) &#123; $minLen = $curLen; $begin = $left; &#125; $wMap[$curLV]--; // 如果 $wMap 中的 value 與 $tMap 不再相等, 那代表 window 不再合法 if ($wMap[$curLV] &lt; $tMap[$curLV]) &#123; $distance--; &#125; $left++; &#125; $right++; &#125; if ($minLen === $sLen + 1) &#123; return &#x27;&#x27;; &#125; return substr($s, $begin, $minLen); &#125;&#125; # BST# 653. Two Sum IV - Input is a BST 題目連結 先不管 root 是不是 BST 結構, two sum 的條件, 當 input 任兩個值相加等於 $k, 則結果為 true, 反之為 false 。 我們假設 $root 是一個 array, 最暴力的解法當然是直接雙層loop, 這樣時間複雜度會是 n 的平方, 好一點的解法是利用 map, 將 loop 跑過的 value 存到一個 map 中作為 key, 而下一個 loop 到的值, 只要用 $k - value 得到的值, 看看 map中存不存在這個 key, 如果存在, 代表這個 input 中確實有兩個 value 相加後等於 $k, 如果跑完 loop 都不存在, 那代表結果為 false, 這樣只需要跑一次 loop, 且 map 找 key 為 O(1),所以時間複雜度為 O(n), n 為 input 內的數量。 因為這題的 input 結構為 BST, 所以我們可以利用 BST 的特性, 用遞迴來跑, 然而其時間複雜度還是 O(n) solution example code: /** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution &#123; /** * @param TreeNode $root * @param Integer $k * @return Boolean */ function findTarget($root, $k) &#123; $map = []; return $this-&gt;find($root, $map, $k); &#125; function find($node, &amp;$map, $k) &#123; if (is_null($node)) &#123; return false; &#125; $difference = $k - $node-&gt;val; if (array_key_exists($difference, $map)) &#123; return true; &#125; $map[$node-&gt;val] = true; return $this-&gt;find($node-&gt;left, $map, $k) || $this-&gt;find($node-&gt;right, $map, $k); &#125;&#125; # 977. Squares of a Sorted Array暴力解： 最後使用較基本的解法, 先 square 整個 array, 在使用原生 sort(), 底層應使用歸併演算法, 因此時間複雜度為 O(n log n)雙指針： 時間複雜度為 O(n) 題目連結 solution example code 1: class Solution &#123; /** * @param Integer[] $nums * @return Integer[] */ function sortedSquares($nums) &#123; $left = 0; $right = $end = count($nums) - 1; $output = array_fill(0, count($nums), 0); while ($left &lt;= $right) &#123; if ($nums[$left]**2 &gt; $nums[$right]**2) &#123; $output[$end] = $nums[$left]**2; $left++; &#125; else &#123; $output[$end] = $nums[$right]**2; $right--; &#125; $end--; &#125; return $output; &#125;&#125; solution example code 2: class Solution &#123; /** * @param Integer[] $nums * @return Integer[] */ function sortedSquares($nums) &#123; for ($i = 0; $i &lt; count($nums); $i++) &#123; $nums[$i] = $nums[$i]**2; &#125; sort($nums); return $nums; &#125;&#125; # binary search# 69. Sqrt(x)暴力解： 直接從 0 開始 loop 到 $x, 用 ($x / $i === $i) 去判斷 $i 是否為解, 時間複雜度為 O(n)二分法： 簡單來說, 如果二分法中, $pivot === $target 的答案不存在, 而求 inserted position 的話, 那結果會是 $left, 如果是求僅次於 inserted position 的上一個位置的話,那結果會是 $right, 這題求得屬於 inserted position 的上一個位置, 因此是 return $right 時間複雜度為 O(log n) 題目連結 solution example code: class Solution &#123; /** * @param Integer $x * @return Integer */ function mySqrt($x) &#123; $left = 0; $right = $x; while ($left &lt;= $right) &#123; $pivot = (int) ($left + ($right - $left) / 2); if ($pivot*$pivot === $x) &#123; return $pivot; &#125; elseif ($pivot*$pivot &gt; $x) &#123; $right = $pivot - 1; &#125; else &#123; $left = $pivot + 1; &#125; &#125; return $right; &#125;&#125; # 367. Valid Perfect Square這題的暴力解, 就 loop 整個 1 ~ $num 的範圍, 每一個 index 都用 $value ** 2 === $num 去判斷, 即可得到結果, 時間複雜度為 O(n), 空間複雜度為 O(1)可使用 binary serach 概念來解, 設 $left = 1, $right = $num, 開始二分, 只要 $pivot**2 === $num 即為答案, 時間複雜度為 O(log n), 空間複雜度為 O(1) 題目連結 solution example code: class Solution &#123; /** * @param Integer $num * @return Boolean */ function isPerfectSquare($num) &#123; $left = 1; $right = $num; while ($left &lt;= $right) &#123; $pivot = (int) ($left + ($right - $left) / 2); if ($pivot**2 === $num) &#123; return true; &#125; elseif ($num &gt; $pivot**2) &#123; $left = $pivot + 1; &#125; else &#123; $right = $pivot - 1; &#125; &#125; return false; &#125;&#125; # 704. Binary Search這題的暴力解就是用 loop 把 $nums 全部跑過一次, 時間複雜度是 O(n)較進階的解法, 可以使用 binary search, 時間複雜度為 O(log n) 題目連結 solution example code: class Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer */ function search($nums, $target) &#123; $left = 0; $right = count($nums) - 1; while ($left &lt;= $right) &#123; $pivot = (int) ($left + ($right - $left) / 2); if ($nums[$pivot] === $target) &#123; return $pivot; &#125; elseif ($nums[$pivot] &gt; $target) &#123; $right = $pivot - 1; &#125; elseif ($nums[$pivot] &lt; $target) &#123; $left = $pivot + 1; &#125; &#125; return -1; &#125;&#125; # string# 雙指針# 844. Backspace String Compare首先看完題目後, 先搞清楚一個邏輯, 那就是今天不管兩個 string 的長度分別是多少, 如果這兩個 string 最後的結果相同這件事情成立的話, 那先決條件就是, 當 backspace 往後刪除到一個定點後 (也就是暫時沒遇到 ‘#’ 符號了, 且往後刪的次數都有確實跑了), 那這兩個 string 當前的值必須是要一樣的。 儘管此時兩個 string 的長度可能不一, 那是因為還沒跑過的地方可能還存在 ‘#’ 符號, 但只要刪除到了一個定點, 那兩個 string當前的值勢必要相同。 搞清楚這個邏輯後, 我們便可使用 two pointer 的概念來實作 首先, $pos 是由 string 的最後一個位置開始往前跑, 那我們設定兩個條件, 只要這兩個條件成立, 那這兩個 string相同這件事就會成立 第一, 如上所敘, string 往前刪除到一個定點後, 兩個 string 的當前值必須相同 第二, 不管一開始的位置是什麼, 兩個相同的 string 代表其長度也相同, 所以最終兩個 string 的位置都必須停在-1, 即全部都刪光了 如下 example code, 需注意 substr() 不比 array, 當 index 為 -1 時代表從最後往前數, 所以在往前刪除的 loop 記得要判斷 -1 就不可繼續, 因為從最後開始算,有可能剛好最後一個值就是 ‘#’, 這樣就又成立了 題目連結 solution example code: class Solution &#123; /** * @param String $s * @param String $t * @return Boolean */ function backspaceCompare($s, $t) &#123; $sIndex = strlen($s) - 1; $tIndex = strlen($t) - 1; while ($sIndex &gt;= 0 || $tIndex &gt;= 0) &#123; $back = 0; while ($sIndex &gt;= 0 &amp;&amp; (substr($s, $sIndex, 1) === &#x27;#&#x27; || $back !== 0)) &#123; $back += substr($s, $sIndex, 1) === &#x27;#&#x27; ? 1 : -1; $sIndex--; &#125; $back = 0; while ($tIndex &gt;= 0 &amp;&amp; (substr($t, $tIndex, 1) === &#x27;#&#x27; || $back !== 0)) &#123; $back += substr($t, $tIndex, 1) === &#x27;#&#x27; ? 1 : -1; $tIndex--; &#125; if ($sIndex &gt;= 0 &amp;&amp; $tIndex &gt;= 0 &amp;&amp; substr($s, $sIndex, 1) === substr($t, $tIndex, 1)) &#123; $sIndex--; $tIndex--; &#125; else &#123; break; &#125; &#125; return $sIndex === -1 &amp;&amp; $tIndex === -1; &#125;&#125; # Linked List# 203. Remove Linked List Elementsdummy head:主要思路是採用迭代的方式, 如果當前的 node-&gt;val 等於 $val 的話, 則把上一個 node 的 next 接到下一個 node 考量到 head 可能也是要刪掉的 node, 因此建立一個 dummy head 題目連結 solution dummy head example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val = 0, $next = null) &#123; * $this-&gt;val = $val; * $this-&gt;next = $next; * &#125; * &#125; */class Solution &#123; /** * @param ListNode $head * @param Integer $val * @return ListNode */ function removeElements($head, $val) &#123; if (is_null($head)) &#123; return $head; &#125; $dummyHead = new ListNode(-1, $head); $pre = $dummyHead; $cur = $head; while (!is_null($cur)) &#123; if ($cur-&gt;val === $val) &#123; $pre-&gt;next = $cur-&gt;next; &#125; else &#123; $pre = $cur; &#125; $cur = $cur-&gt;next; &#125; return $dummyHead-&gt;next; &#125;&#125; solution example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val = 0, $next = null) &#123; * $this-&gt;val = $val; * $this-&gt;next = $next; * &#125; * &#125; */class Solution &#123; /** * @param ListNode $head * @param Integer $val * @return ListNode */ function removeElements($head, $val) &#123; // 如果符合刪除條件, 往下跳, 目的在於取得不符合刪除條件的 head while ($head-&gt;val === $val) &#123; $head = $head-&gt;next; &#125; // 如果取得的 head 是 null, 直接 return if (is_null($head)) &#123; return $head; &#125; // 已知該 $head 不符合刪除條件, 可作為 $pre $pre = $head; // $head-&gt;next 尚未知是否該被刪除, 進入迭代判斷 $cur = $head-&gt;next; while (!is_null($cur)) &#123; if ($cur-&gt;val === $val) &#123; $pre-&gt;next = $cur-&gt;next; &#125; else &#123; $pre = $cur; &#125; $cur = $cur-&gt;next; &#125; return $head; &#125;&#125; # 2. Add Two Numbers將 $l1, $carry 以及 $l2 的 val 相加, 若超過 10 則代表需進位, 記下 $carry, 以此模式不斷迭代持續相加, 直到 $l1 以及 $l2 皆為 null, 至此已完成所有 node 的相加, 除了最後一個$carry, 接著判斷 $carry 是否為 0, 若否, 則代表最後一次相加是大於 0 的, 在迴圈外補上最後一個 node, 時間複雜度為 O(n), n 為 $l1 或 $l2, 視乎哪個較長 題目連結 solution dummy head example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val = 0, $next = null) &#123; * $this-&gt;val = $val; * $this-&gt;next = $next; * &#125; * &#125; */class Solution &#123; /** * @param ListNode $l1 * @param ListNode $l2 * @return ListNode */ function addTwoNumbers($l1, $l2) &#123; $result = new ListNode(); $resultForIterate = $result; $sum = 0; $carry = 0; while (!is_null($l1) || !is_null($l2)) &#123; $l1Num = is_null($l1) ? 0 : $l1-&gt;val; $l2Num = is_null($l2) ? 0 : $l2-&gt;val; $sum = $l1Num + $l2Num + $carry; $carry = $sum &gt;= 10 ? 1 : 0; $resultForIterate-&gt;next = new ListNode($sum%10); $resultForIterate = $resultForIterate-&gt;next; $l1 = $l1-&gt;next; $l2 = $l2-&gt;next; &#125; if ($carry === 1) &#123; $resultForIterate-&gt;next = new ListNode($carry); &#125; return $result-&gt;next; &#125;&#125; # 206. Reverse Linked List實作的邏輯示意圖如下: 實作步驟拆解： $temp = $cur-&gt;next, 這邊是將 $cur-&gt;next 指向的地址存到 $temp $cur-&gt;next = $pre, 這邊改變了 $cur 的 next 指向, 變成指向 $pre $pre = $cur, 這獲得 $cur 的位址, 存到 $pre $cur = $temp, 獲得 $temp 的位址, 存到 $cur 題目連結 solution dummy head example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val = 0, $next = null) &#123; * $this-&gt;val = $val; * $this-&gt;next = $next; * &#125; * &#125; */class Solution &#123; /** * @param ListNode $head * @return ListNode */ function reverseList($head) &#123; $pre = null; $cur = $head; while ($cur) &#123; $temp = $cur-&gt;next; $cur-&gt;next = $pre; $pre = $cur; $cur = $temp; &#125; return $pre; &#125;&#125; # 24. Swap Nodes in Pairs實作步驟拆解, 假如 input 為四個 node 的 linked list 預設會有一個 dummy head, 避免一些需要特別處理的邏輯 $next = $cur-&gt;next, 取得下一個 node, 準備用來當第一個 $cur-&gt;next = $cur-&gt;next-&gt;next, 將第一個 node 的 next 指向第三個 node $next-&gt;next = $cur, 將第二個 node 的 next 指向第一個 node, 承 3, 此時的第一個 node 的 next 已指向第三個 node $pre-&gt;next = $next, 最後, 將 $dummyHead 的 next 指向第二個 node, 至此, 轉換步驟完成 $cur = $next-&gt;next-&gt;next, 將 $cur 重新定義為第三個 node $pre = $next-&gt;next, 將 $pre 重新定義為第二個 node 重複以上步驟直到 $cur-&gt;next === null, 代表最後不成對 題目連結 solution dummy head example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val = 0, $next = null) &#123; * $this-&gt;val = $val; * $this-&gt;next = $next; * &#125; * &#125; */class Solution &#123; /** * @param ListNode $head * @return ListNode */ function swapPairs($head) &#123; $dummyHead = new ListNode(null, $head); $pre = $dummyHead; $cur = $dummyHead-&gt;next; if (is_null($cur)) &#123; return $head; &#125; while ($cur-&gt;next) &#123; $next = $cur-&gt;next; $cur-&gt;next = $cur-&gt;next-&gt;next; $next-&gt;next = $cur; $pre-&gt;next = $next; $cur = $next-&gt;next-&gt;next; $pre = $next-&gt;next; &#125; return $dummyHead-&gt;next; &#125;&#125; # 19. Remove Nth Node From End of List以下為解題拆解： 首先使用 dummyHead 避免一些不必要的判斷 概念是使用雙指針, right 指針先跑到第 $n 個 node, 這時的 left 指針指向第一個 node, 如果說此時的 right 已經是在最後一個 node, 那 left 恰好是從 end 往前數的第 $n 個 node 首先先把 right 往前推, 推 $n - 1 次的話可以到第 $n 個 node, 但我們要推 $n 次, 因為我們要 left 是指向從結尾往前數的第 $n+1 個 node, 相當於目標 node 的前一個, 這樣才方便刪除 因為我們有使用 dummyHead, 如果說往前跑 $n 次, 而 right 正指向最後一個 node, 此時 $pre 會等於 $dummyHead, 而 target node 會是 $dummyHead-&gt;next,也就是第一個 node, 如果說, 往前跑 $n 次之後, right 指向 null, 這代表這個 $n 實際上已經超出了這個 linked list 的長度, 不符合條件 取得 right node 之後, 我們讓 left 指向 dummyHead, 然後開始繼續往下跑, 直到 right 指向最後一個 node 此時的 left 剛好會是從結尾往前數的第 $n + 1 個 node 最後再實施刪除動作, 就完成了 題目連結 solution dummy head example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val = 0, $next = null) &#123; * $this-&gt;val = $val; * $this-&gt;next = $next; * &#125; * &#125; */class Solution &#123; /** * @param ListNode $head * @param Integer $n * @return ListNode */ function removeNthFromEnd($head, $n) &#123; $dummyHead = new ListNode(null, $head); $right = $dummyHead; for ($i = 1; $i &lt; $n + 1; $i++) &#123; $right = $right-&gt;next; &#125; if (is_null($right)) &#123; return false; &#125; $left = $dummyHead; while ($right-&gt;next) &#123; $left = $left-&gt;next; $right = $right-&gt;next; &#125; $pre = $left; $cur = $pre-&gt;next; $next = $cur-&gt;next; if ($next) &#123; $pre-&gt;next = $next; &#125; else &#123; $pre-&gt;next = null; &#125; return $dummyHead-&gt;next; &#125;&#125; # 160. Intersection of Two Linked Lists以下為解題拆解： 先計算兩個 list 的長度 取得兩個長度的差值, 為 $diff 將比較長的 list 的 head 跳 $diff 個 node 至此, 兩個 list 的 head 距離 intersection node 已經一致 開始比較兩個 head 是否相同, 直至結束, 有找到則 return head, 沒找到則 return null 題目連結 solution dummy head example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val) &#123; $this-&gt;val = $val; &#125; * &#125; */class Solution &#123; /** * @param ListNode $headA * @param ListNode $headB * @return ListNode */ function getIntersectionNode($headA, $headB) &#123; $lenA = 0; $lenB = 0; $tempA = $headA; $tempB = $headB; while ($tempA) &#123; $lenA++; $tempA = $tempA-&gt;next; &#125; while ($tempB) &#123; $lenB++; $tempB = $tempB-&gt;next; &#125; $diff = abs($lenA - $lenB); if ($lenA &gt; $lenB) &#123; $long = $headA; $short = $headB; &#125; else &#123; $long = $headB; $short = $headA; &#125; while ($diff !== 0) &#123; $long = $long-&gt;next; $diff--; &#125; while ($long) &#123; if ($long === $short) &#123; return $long; &#125; $long = $long-&gt;next; $short = $short-&gt;next; &#125; return null; &#125;&#125; # 142. Linked List Cycle II 以下為雙指針解題拆解：(1) 示意圖：(2) 首先, 我們定義 fast 以及 slow 指針, fast 走兩格, slow 走一格, 如果最終兩個指針指向同一個點, 那代表是有 circle 存在的, 否則 fast 會先到達終點變成 null(3) 從上圖可以看到, 如果兩個指針相交, 那肯定是在 circle 裡相交, 否則 fast 就先變成 null 了, 沒機會相交(4) 如示意圖, 我們假設 x 為起始點至入口點的距離, y 為入口點至相遇點的距離, z 為相遇點至入口點的距離(5) slow = x+y, fast = x+n*(y+z)+y, 由於 fast 走兩格, slow 走一格, 所以當相遇的那一刻, fast 走過的距離會剛好等於 slow 的兩倍,所以 2*(x+y) = x+n*(y+z)+y(6) 我們慢慢的化簡公式, x+y = n*(y+z), x = n*(y+z) - y, 化簡到這其實就可以得到一個結果, 那就是 x 到入口點的距離, 剛好會等於從入口點開始走, 走了 n 圈之後再扣掉 y 的距離,換言之, 如果是從相遇點開始走的話, 那走 n 圈之後再走 z 剛好會等於 x(7) 從以上的結論, 我們可以得到一個邏輯, 讓一個指針從起始點開始走, 另一個指針從相遇點開始走, 每次都走一格, 直到兩者相遇, 那個點就是 circle 的入口點 題目連結 solution example code: /** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val) &#123; $this-&gt;val = $val; &#125; * &#125; */class Solution &#123; /** * @param ListNode $head * @return ListNode */ function detectCycle($head) &#123; $fast = $head-&gt;next-&gt;next; $slow = $head-&gt;next; while ($fast &amp;&amp; $slow) &#123; if ($fast === $slow) &#123; $index1 = $head; $index2 = $fast; while ($index1 !== $index2) &#123; $index1 = $index1-&gt;next; $index2 = $index2-&gt;next; &#125; return $index1; &#125; $fast = $fast-&gt;next-&gt;next; $slow = $slow-&gt;next; &#125; return null; &#125;&#125; # hash table# 242. Valid Anagram建立一個 hash table, 遍歷 string s, key 為字母, value 為數量, 然後在遍歷 string t, 逐一扣掉 hash table, 若最後該 hash table 為 empty, 代表兩個 string含有一樣的字母, 時間複雜度為 O(m+n), 空間複雜度, 由於是 a-z 26 個字母, 因此為 O(1) 題目連結 solution example code: class Solution &#123; /** * @param String $s * @param String $t * @return Boolean */ function isAnagram($s, $t) &#123; $dic = []; for ($i = 0; $i &lt; strlen($s); $i++) &#123; $dic[substr($s, $i, 1)]++; &#125; for ($i = 0; $i &lt; strlen($t); $i++) &#123; $curChr = substr($t, $i, 1); $dic[$curChr]--; if ($dic[$curChr] === 0) &#123; unset($dic[$curChr]); &#125; &#125; return empty($dic); &#125;&#125; # 1002. Find Common Characters 思路 因為 string 有限制在 lowercase 英文字母, 所以會介於 ASCII 97~122 共 26 個字母 概念就是, 將所有 string 轉成 hash table, 記錄下 $key = 字母, $value =出現次數, 然後最終取得每個字母的最小出現次數, 換言之, 如果有個字母在某個 string 中沒出現過, 那就會是 0, 如果在 string 1 出現過三次, 但在 string 2 只出現過一次, 那就只算一次最後將這個紀錄著最小出現次數的 hash table 再轉成相對應的 array 輸出, 便是解答 時間複雜度為 O(n), 空間複雜度為 O(1) 題目連結 solution example code: class Solution &#123; /** * @param String[] $words * @return String[] */ function commonChars($words) &#123; $firstDic = array_fill(97, 26, 0); $firstWord = $words[0]; for ($i = 0; $i &lt; strlen($firstWord); $i++) &#123; $asic = ord(substr($firstWord, $i, 1)); $firstDic[$asic]++; &#125; for ($i = 1; $i &lt; count($words); $i++) &#123; $otherDic = array_fill(97, 26, 0); $word = $words[$i]; for ($j = 0; $j &lt; strlen($word); $j++) &#123; $asic = ord(substr($word, $j, 1)); $otherDic[$asic]++; &#125; for ($k = 97; $k &lt;= 122; $k++) &#123; $firstDic[$k] = min($firstDic[$k], $otherDic[$k]); &#125; &#125; $output = []; foreach($firstDic as $key =&gt; $value) &#123; $chr = chr($key); while ($value) &#123; array_push($output, $chr); $value--; &#125; &#125; return $output; &#125;&#125; # 349. Intersection of Two Arrays 思路 先將其中一個 array 轉成 hash table, 然後在 loop 另外一個 array 來判斷 each item 是否存在於 hash table, 使用 hash table 的原因是因為 hash table 找key 的時間複雜度為 O(1), 而 array 為 O(n)時間複雜度為 O(m+n), 空間複雜度為 O(m+n) 題目連結 solution example code: class Solution &#123; /** * @param Integer[] $nums1 * @param Integer[] $nums2 * @return Integer[] */ function intersection($nums1, $nums2) &#123; $res = []; $nums2Map = []; for ($i = 0; $i &lt; count($nums2); $i++) &#123; $nums2Map[$nums2[$i]] = true; &#125; for ($i = 0; $i &lt; count($nums1); $i++) &#123; if (array_key_exists($nums1[$i], $nums2Map)) &#123; $res[] = $nums1[$i]; &#125; unset($nums2Map[$nums1[$i]]); &#125; return $res; &#125;&#125; # 454. 4Sum II 思路 對我來說, 這題難的地方在於數學邏輯, 求的是共有幾種 output = 0 的組合, 要先有數學概念, 假如 n1 + n2 等於 -3 有兩組, 而 n3 + n4 等於 3 的有兩組, 那就是 2*2=4, 共有四種組合先將 n1+n2 的所有組合都記錄下來, 存在 $dic, key 為 sum, value 為該 $sum 出現的次數, 接下來一樣去 loop n3 以及 n4, 假如 0 - (n3 + n4) 的值出現在 $dic 中,則代表當前 n3+n4 + n1+n2 會等於 0, 而 $dic 中記錄著 n1+n2 出現該值的組合次數, 所以當我們在 loop n3+n4 時, 如果在 $dic 中存在的話, 都必須加上 $dic 中紀錄的次數 題目連結 solution example code: class Solution &#123; /** * @param Integer[] $nums1 * @param Integer[] $nums2 * @param Integer[] $nums3 * @param Integer[] $nums4 * @return Integer */ function fourSumCount($nums1, $nums2, $nums3, $nums4) &#123; $dic = []; for ($i = 0; $i &lt; count($nums1); $i++) &#123; for ($j = 0; $j &lt; count($nums2); $j++) &#123; $sum = $nums1[$i] + $nums2[$j]; $dic[$sum]++; &#125; &#125; $count = 0; for ($i = 0; $i &lt; count($nums3); $i++) &#123; for ($j = 0; $j &lt; count($nums4); $j++) &#123; $sum = $nums3[$i] + $nums4[$j]; $diff = 0 - $sum; if (isset($dic[$diff])) &#123; $count += $dic[$diff]; &#125; &#125; &#125; return $count; &#125;&#125; # 383. Ransom Note 思路 這題直接使用 map 來記錄 ransom note 裡頭需要的字以及字數, 在 loop magazine, 把 magazine 裡頭出現相同的字扣掉, 如果 loop 完 magazine 之後, ransom notemap 為空, 代表 ransom note 裡頭需要的字母以及字數 magazine 都有符合, 時間複雜度為 O(m+n), 空間複雜度為 O(m), m 為 $ransomNote 長度, n 為 $magazine 長度 題目連結 solution example code: class Solution &#123; /** * @param String $ransomNote * @param String $magazine * @return Boolean */ function canConstruct($ransomNote, $magazine) &#123; $noteMap = []; for ($i = 0; $i &lt; strlen($ransomNote); $i++) &#123; $noteMap[substr($ransomNote, $i, 1)]++; &#125; for ($i = 0; $i &lt; strlen($magazine); $i++) &#123; $chr = substr($magazine, $i, 1); if (isset($noteMap[$chr])) &#123; $noteMap[$chr]--; if ($noteMap[$chr] === 0) &#123; unset($noteMap[$chr]); &#125; &#125; &#125; return empty($noteMap); &#125;&#125; # 15. 3Sum 思路 使用雙指針法, 可參考下面的連結 每一次的 loop 都會再次執行 $left &amp; $right 配對, 所以時間複雜度為 O(n 的平方), 空間複雜度為 O(1) 參考連結 題目連結 solution example code: class Solution &#123; /** * @param Integer[] $nums * @return Integer[][] */ function threeSum($nums) &#123; sort($nums); $res = []; for ($i = 0; $i &lt; count($nums); $i++) &#123; if ($nums[$i] &gt; 0) &#123; return $res; &#125; if ($nums[$i] === $nums[$i-1]) &#123; continue; &#125; $left = $i + 1; $right = count($nums) - 1; while ($left &lt; $right) &#123; if ($nums[$i] + $nums[$left] + $nums[$right] &gt; 0) &#123; $right--; while ($nums[$right] === $nums[$right+1]) &#123; $right--; &#125; &#125; elseif ($nums[$i] + $nums[$left] + $nums[$right] &lt; 0) &#123; $left++; while ($nums[$left] === $nums[$left-1]) &#123; $left++; &#125; &#125; else &#123; $res[] = [$nums[$i], $nums[$left], $nums[$right]]; while ($nums[$left] === $nums[$left+1]) &#123; $left++; &#125; while ($nums[$right] === $nums[$right-1]) &#123; $right--; &#125; $right--; $left++; &#125; &#125; &#125; return $res; &#125;&#125; # 18. 4Sum 思路 使用雙指針法, 可參考下面的連結 這類型的題目, 有一個很重要的點, 看似 loop 很多層, 但基本原則就是每一個最小的 loop 都是 n 個固定數 + 兩個指針根據總合來判斷移動 right or left。 由於最小loop 為兩個指針來移動, 總共有四個數, 所以會是兩個固定數 + 兩個指針 由於已經完成排序, 所以可以確定, 只要我們將兩個固定數其中一個往右移, 那該 loop 所得到的結果必然不會跟之前得到的結果重複,因為往右移代表原先的數已經不會再出現了(因為已經排序過了, 數只會越來越大, 過了就是過了)上面提到最小 loop 的行為是兩個固定數 + 雙指針移動, 而要求得所有的可能性, 我們需要雙層 loop 來代表兩個固定數 參考連結 題目連結 solution example code: class Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer[][] */ function fourSum($nums, $target) &#123; $res = []; sort($nums); for ($i = 0; $i &lt; count($nums); $i++) &#123; if ($nums[$i] &gt; 0 &amp;&amp; $nums[$i]*4 &gt; $target) &#123; return $res; &#125; if ($nums[$i] === $nums[$i-1]) &#123; continue; &#125; for ($j = $i+1; $j &lt; count($nums); $j++) &#123; if ($j &gt; $i+1 &amp;&amp; $nums[$j] === $nums[$j-1]) &#123; continue; &#125; $left = $j+1; $right = count($nums) - 1; while ($left &lt; $right) &#123; $sum = $nums[$i] + $nums[$j] + $nums[$left] + $nums[$right]; if ($sum &gt; $target) &#123; $right--; while ($nums[$right] === $nums[$right+1]) $right--; &#125; elseif ($sum &lt; $target) &#123; $left++; while ($nums[$left] === $nums[$left-1]) $left++; &#125; else &#123; $res[] = [$nums[$i], $nums[$j], $nums[$left], $nums[$right]]; while ($nums[$left] === $nums[$left+1]) $left++; while ($nums[$right] === $nums[$right-1]) $right--; $left++; $right--; &#125; &#125; &#125; &#125; return $res; &#125;&#125; # String# 344. Reverse String 思路 思路很簡單, 一開始愣是沒想明白, 真是菜雞 就是使用雙指針, 將第一個與最後一個交換, 然後雙指針各往中間前進一格 時間複雜度為 O(n), 空間複雜度為 O(1) 題目連結 solution example code: class Solution &#123; /** * @param String[] $s * @return NULL */ function reverseString(&amp;$s) &#123; $left = 0; $right = count($s) - 1; while ($left &lt; $right) &#123; $leftV = $s[$left]; $rightV = $s[$right]; $s[$left] = $rightV; $s[$right] = $leftV; $left++; $right--; &#125; return $s; &#125;&#125; # 541. Reverse String II 思路 題目說, 如果 剩下的長度 &lt; 2k &amp;&amp; 剩下的長度 &gt;= k 個字, 那就逆轉前 k 個字, 如果 剩下的長度 &lt; k, 那就逆轉剩下的所有字, 第一個條件很明顯是廢話, 這句話真的有點繞,所以簡單來說, 剩下的長度 &gt; k, 則逆轉 k 個字, 否則則逆轉剩下的所有字我們讓 $i += 2k, 當作錨點, 每一次的 left 以及 right 都從這個 anchor 來取 left 會等於 anchor, 而 right 會等於 anchor + k - 1, 如果 anchor 超過總長度則break 綜合以上所有邏輯, 就可以求得解答, 時間複雜度為 O(n), 空間複雜度為 O(1) 題目連結 solution example code: class Solution &#123; /** * @param String $s * @param Integer $k * @return String */ function reverseStr($s, $k) &#123; $len = strlen($s); for ($i = 0; $i &lt; $len; $i += 2*$k) &#123; $left = $i; $right = $left + $k - 1; $right = $right &lt; $len - 1 ? $right : $len - 1; while ($left &lt; $right) &#123; $tempL = $s[$left]; $s[$left] = $s[$right]; $s[$right] = $tempL; $left++; $right--; &#125; &#125; return $s; &#125;&#125; # 202. Happy Number 思路 這題主要應該是比較偏數學問題, 首先必須要有意識到, 這樣的 loop 下, 已經出現過的 sum 是會重複出現的 明白這一點之後, 就可以使用 map 來處理, 將計算過的 sum 存起來, 如果之後重複了就直接 returnfalse, 直到取得 sum 為 1 的數, return true 題目連結 solution example code: class Solution &#123; /** * @param Integer $n * @return Boolean */ function isHappy($n) &#123; $dic = []; while ($n !== 1 &amp;&amp; $n &gt; 0) &#123; if (isset($dic[$n])) &#123; return false; &#125; $dic[$n] = true; $res = 0; while ($n &gt; 0) &#123; $temp = $n % 10; $res += $temp*$temp; $n = (int) ($n/10); &#125; $n = $res; &#125; return true; &#125;&#125; # Stack# 20. Valid Parentheses 思路: 根據此題的規則, ( 要對應 ), &#123; 要對應 &#125;, 而 [ 要對應 ], 而且順序也必須符合規則, ()[]&#123;&#125; 為 true, ([&#123;&#125;]) 為 true, (] 為false, (&#123;&#125;[)) 為 false, 所以此題可以利用 Stack 的特性來解題。 stack 特性為先進後出, 所以我們可以遍歷 input, 當為 ([&#123; 時, 我們依序的在 stack 中放入 )]&#125;, 而當input 為 )]&#125; 時, 我們 pop stack, 並比較 input 與 stack pop 的值是否相等, 若不相等就表示對不上了。 照這個規則, 如果 input 是個合乎規格的 string, 那遍歷完整個 input時, stack 應為 empty, 因為有幾個 ([&#123; 就會 push 幾次, 而有幾個 )]&#125; 就會 pop 幾次, 而 stack 的特性保證了順序正確 複雜度： 時間複雜度是 O(n), 空間複雜度為 O(n) 題目連結 solution example code: class Solution &#123; /** * @param String $s * @return Boolean */ function isValid($s) &#123; $stack = []; $parentheses = [ &#x27;(&#x27; =&gt; &#x27;)&#x27;, &#x27;[&#x27; =&gt; &#x27;]&#x27;, &#x27;&#123;&#x27; =&gt; &#x27;&#125;&#x27; ]; for ($i = 0; $i &lt; strlen($s); $i++) &#123; $parenthesis = $s[$i]; if (in_array($parenthesis, [&#x27;(&#x27;, &#x27;[&#x27;, &#x27;&#123;&#x27;])) &#123; array_push($stack, $parentheses[$parenthesis]); continue; &#125; if ($parenthesis !== array_pop($stack)) &#123; return false; &#125; &#125; return empty($stack); &#125;&#125; # 1047. Remove All Adjacent Duplicates In String 思路: 題目主要是要刪除相鄰重複的數, 所以可以簡單比較相鄰的兩個數, 若相同則 $left 往回退, 若不相同則直接加上, 若 $left === -1 代表目前 stack 內其實已經沒有任何數了, 此時無條件加上 複雜度： 時間複雜度 O(n), 空間複雜度 O(1) 題目連結 solution example code: class Solution &#123; /** * @param String $s * @return String */ function removeDuplicates($s) &#123; $left = -1; for ($right = 0; $right &lt; strlen($s); $right++) &#123; if ($left === -1 || $s[$left] !== $s[$right]) &#123; $s[++$left] = $s[$right]; continue; &#125; if ($s[$left] === $s[$right]) &#123; $left--; continue; &#125; &#125; return substr($s, 0, $left+1); &#125;&#125; # 347. Top K Frequent Elements 思路: 這題是使用 priority queue 來解, 順便理解了一下 heap 資料結構。 這題用 array_flip 來解我覺得也是可以的, 但時間複雜度會增加為 O(n log n) 複雜度： 時間複雜度 O(n), 空間複雜度 O(n) 題目連結 solution example code: &lt;?phpclass Solution &#123; /** * @param Integer[] $nums * @param Integer $k * @return Integer[] */ function topKFrequent($nums, $k) &#123; $queue = new SplPriorityQueue(); $map = array_count_values($nums); foreach($map as $key =&gt; $value) &#123; $queue-&gt;insert($key, $value); &#125; $res = []; while ($k &gt; 0 &amp;&amp; $queue-&gt;count &gt;= 0) &#123; $res[] = $queue-&gt;extract(); $k--; &#125; return $res; &#125;&#125; # 150. Evaluate Reverse Polish Notation 思路: 這題我覺得難的主要是 ERPN 的概念, 先把這個概念搞懂了, 邏輯其實不難。 ERPN 可以 Google 先了解一下他的定義。 簡單來說, 我們建立一個 stack, 依序的 loop $tokens, 只要值不是 +, -, *, /, 我們就直接塞進 stack, 如果是的話, 那代表要做計算, 就依序 pop 兩個數出來當作 operand1 &amp; operand2, 然後做完計算後, 再將結果 push 進 stack。 照這個流程, 只要 $tokens array 是 valid, 那 stack 中最後一個數就是 answer 複雜度： 時間複雜度 O(n), 空間複雜度 O(n) 題目連結 solution example code:class Solution &#123; /** * @param String[] $tokens * @return Integer */ function evalRPN($tokens) &#123; $stack = []; for ($i = 0; $i &lt; count($tokens); $i++) &#123; if (!in_array($tokens[$i], [&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;])) &#123; $stack[] = $tokens[$i]; continue; &#125; $operand2 = array_pop($stack); $operand1 = array_pop($stack); $result = $this-&gt;calculate($tokens[$i], $operand1, $operand2); $stack[] = $result; &#125; return array_pop($stack); &#125; function calculate($operator, $operand1, $operand2) &#123; switch ($operator) &#123; case &#x27;+&#x27;: return intval($operand1 + $operand2); case &#x27;-&#x27;: return intval($operand1 - $operand2); case &#x27;*&#x27;: return intval($operand1 * $operand2); case &#x27;/&#x27;: return intval($operand1 / $operand2); &#125; &#125;&#125; # 239. Sliding Window Maximum 思路: 這題的目標在於取得每次移動的 sliding window 中最大的數, 邏輯思路在於維護一個 queue win, 兩個 method enqueue, dequeue, enqueue 的功能會把每一次要新放入 win 當中的數, 依序地跟 win 當中的數做比較, 若新的數比較大, 則 pop 當前 win 中的數, 最多可以 pop 完所有 win 當中的數, 最後再把新的數放入 win 中, 這樣可以確保 win 的第一個數一定是最大的 dequeue 的功能, 會比較 win 當中的第一個數是否跟要移除的數相同, 若否, 則代表該數已經在之前的 enqueue 操作中被移除了, 故不做任何動作。 若是, 則將該數從 win 當中移除 每次 enqueue 以及 dequeue 時, 都會更新 winLeft, winRight, 因為 PHP array 直接指定 index 的時間複雜度為 O(1) 在每一次的 loop, 都將 win 當中的第一個數複製到 res 當中, res 即解答 複雜度: 時間複雜度為 O(n), 空間複雜度為 O(n) 題目連結 solution example code: class Solution &#123; /** * @param Integer[] $nums * @param Integer $k * @return Integer[] */ protected $winLeft = 0; protected $winRight = 0; protected $win = []; function maxSlidingWindow($nums, $k) &#123; $numsRight = 0; $numsLeft = 0; $numsLen = count($nums); $res = []; while ($numsRight &lt; $k) &#123; $this-&gt;enqueue($nums[$numsRight]); $numsRight++; &#125; $res[] = $this-&gt;win[$this-&gt;winLeft]; while ($numsRight &lt; $numsLen) &#123; $this-&gt;enqueue($nums[$numsRight]); $this-&gt;dequeue($nums[$numsLeft]); $res[] = $this-&gt;win[$this-&gt;winLeft]; $numsRight++; $numsLeft++; &#125; return $res; &#125; function enqueue($value) &#123; if (empty($this-&gt;win)) &#123; $this-&gt;win[] = $value; $this-&gt;winRight++; &#125; while ($value &gt; $this-&gt;win[$this-&gt;winRight] &amp;&amp; $this-&gt;winRight &gt;= $this-&gt;winLeft) &#123; array_pop($this-&gt;win); $this-&gt;winRight--; &#125; $this-&gt;win[] = $value; $this-&gt;winRight++; &#125; function dequeue($value) &#123; if ($this-&gt;win[$this-&gt;winLeft] === $value) &#123; $this-&gt;winLeft++; &#125; &#125;&#125; # Binary Tree# 144. Binary Tree Preorder Traversal 思路: preorder 的順序是 中, 左, 右, 所以照著這個順序來遞迴就行了 複雜度： 時間複雜度 O(n), 空間複雜度 O(n) 題目連結 solution example code (遞迴) &lt;?php/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution &#123; /** * @param TreeNode $root * @return Integer[] */ function preorderTraversal($root) &#123; $res = []; $this-&gt;traverse($root, $res); return $res; &#125; function traverse($node, &amp;$res) &#123; if (is_null($node)) &#123; return; &#125; $res[] = $node-&gt;val; $this-&gt;traverse($node-&gt;left, $res); $this-&gt;traverse($node-&gt;right, $res); &#125;&#125; solution example code (stack) &lt;?php/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution &#123; /** * @param TreeNode $root * @return Integer[] */ function preorderTraversal($root) &#123; $stack = []; $res = []; array_push($stack, $root); while (count($stack) !== 0) &#123; $node = array_pop($stack); $res[] = $node-&gt;val; if (!is_null($node-&gt;right)) $stack[] = $node-&gt;right; if (!is_null($node-&gt;left)) $stack[] = $node-&gt;left; &#125; return $res; &#125;&#125; # 145. Binary Tree Postorder Traversal 思路: postorder 的順序是 左, 右, 中, 所以照著這個順序來遞迴就行了 複雜度： 時間複雜度 O(n), 空間複雜度 O(n) 題目連結 solution example code:&lt;?php/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution &#123; /** * @param TreeNode $root * @return Integer[] */ function postorderTraversal($root) &#123; $res = []; $this-&gt;traverse($root, $res); return $res; &#125; function traverse($node, &amp;$res) &#123; if (is_null($node)) &#123; return; &#125; $this-&gt;traverse($node-&gt;left, $res); $this-&gt;traverse($node-&gt;right, $res); $res[] = $node-&gt;val; &#125;&#125; # 94. Binary Tree Inorder Traversal 思路: inorder 的順序是 左, 中, 右, 所以照著這個順序來遞迴就行了 複雜度： 時間複雜度 O(n), 空間複雜度 O(n) 題目連結 solution example code:/** * Definition for a binary tree node. * class TreeNode &#123; * public $val = null; * public $left = null; * public $right = null; * function __construct($val = 0, $left = null, $right = null) &#123; * $this-&gt;val = $val; * $this-&gt;left = $left; * $this-&gt;right = $right; * &#125; * &#125; */class Solution &#123; /** * @param TreeNode $root * @return Integer[] */ function inorderTraversal($root) &#123; $res = []; $this-&gt;traverse($root, $res); return $res; &#125; function traverse($node, &amp;$res) &#123; if (is_null($node)) &#123; return; &#125; $this-&gt;traverse($node-&gt;left, $res); $res[] = $node-&gt;val; $this-&gt;traverse($node-&gt;right, $res); &#125;&#125;","link":"/zh-tw/leetcode-note/"},{"title":"Markdown 學習筆記","text":"前言這是我的 Markdown 學習筆記，看什麼學什麼記什麼！ 特殊字符符號 | 解釋 | 代碼— | — |← | 左箭頭 | &amp;larr;→ | 右箭頭 | &amp;rarr;↑ | 上箭頭 | &amp;uarr;↓ | 下箭頭 | &amp;darr;↔ | 水平箭頭 | &amp;harr;↕ | 豎直箭頭 | &amp;varr;⇐ | 雙線左箭頭 | &amp;lArr;⇒ | 雙線右箭頭 | &amp;rArr;⇑ | 雙線上箭頭 | &amp;uArr;⇓ | 雙線上箭頭 | &amp;dArr;⇔ | 雙線水平雙箭頭 | &amp;hArr;⇕ | 雙線豎直箭頭 | &amp;vArr;","link":"/zh-tw/markdown/"},{"title":"Kubernetes - Resources Limit","text":"# 概述哈囉！ 本篇來介紹 Kubernetes 中的 Compute Resource。 接下來要介紹的可不是一般的 Resource, 像是元件那些, 而是可計算資源。簡單來說, 我們在定義 Pod 的時候, 可以定義啟動這個 Pod 需要多少資源, 以及這個 Pod 最多可以使用多少資源, 這樣夠淺顯易懂吧！ 下面就是詳細介紹了。 當你指定一個 Pod, 你可以選擇性的指定每個容器需要多少 CPU 以及 memory (RAM), 當你有指定 資源要求 (resource request) 給容器, scheduler 可以更加的分配 Pods 到 nodes 上。 而當你有指定容器的 資源限制 (resource limits), 在 node 上的資源競爭將以指定的方式來處理。 更多 requests 以及 limits 的不同之處可以參考 Resource QoS # 資源類型CPU 以及 memory 為 資源類型 (resource type), 資源類型有其基本單位。 CPU 以 cores 為單位, 而 memory 以 bytes 為單位。 如果你使用的是 Kubernetes v1.14 或更新的版本, 你可以指定 巨頁 (huge page) 資源。 Huge pages 是 Linux 上特定的功能, node 的 kernel 可以分配比預設 page 更大的 memory。 比如說, 在預設 page 大小為 4KiB 的系統, 你可以指定一個限制, hugepages-2Mi: 80Mi。 如果容器試圖分配超過 40 2MiB huge pages (總共 80MiB), 則分配將失敗。Ray 第一次聽到 Huge Page 的概念時也是 一臉矇逼, 不過本著學習者的心態 Google 了幾下之後, 就不再那麼矇了。 簡單來說, memory 有過被管理的單位叫做 頁 (page), 在很多系統中預設是 4Ki, 所以 1Mi 的 memory 就有 256 pages, 沒問題吧？ 而有個硬體叫做 TLB (Translation Lookaside Buffer), 它是個大小固定的緩存硬體, 而虛擬記憶體對應實體記憶體的 mapping 會緩存 TLB 上。簡單來說, 如果是使用 4Ki 為 page 為單位的話, 那就要有很多 page, 而越多 page 記憶體的位置就需要越大的緩存去管理, 偏偏 TLB 這東西又是固定大小, 所以能怎麼做？ 那自然就是加大 page 的大小, 讓總 page 的數量下降, 這樣緩存就不需要那麼大的空間來記住那麼多的記憶體位置了。 這便是 huge page 的簡單概念。 注意: 跟 memory 以及 cpu 資源不同, 你無法過量使用 hugepages-* 資源 CPU 以及 memory 都被歸類在 compute resources, 或 resources。 Compute resources 為可被要求, 分配, 以及消耗的可量測數量。 他們與 [API resources] 不同。 API resources, 像是 Pod 以及 Services 為可通過 Kubernetes API server 讀取以及修改的物件。 # Pod 以及 Container 的資源要求以及資源限制每個 Container 或 Pod 可被指定下列一個或多個條件： spec.containers[].resources.limits.cpu spec.containers[].resources.limits.memory spec.containers[].resources.limits.hugepages-&lt;size&gt; spec.containers[].resources.requests.cpu spec.containers[].resources.requests.memory spec.containers[].resources.requests.hugepages-&lt;size&gt; 儘管 requests 以及 limits 只可被指定再單獨的 Container 上, 但要計算出 Pod 的 request 以及 limits 也很方便。 Pod 對某項特定資源的 request/limit 就等於該 Pod 裡的所有容器的 request/limit 總和。 # CPU 解釋CPU 資源的 limits 以及 requests 都以 cpu 為單位衡量。 1 cpu, 在 Kubernetes 中, 相當於以下單位: 1 AWS vCPU 1 GCP Core 1 Azure vCore 1 IBM vCPU 1 Hyperthread, Hyperthreading 的 Intel bare-metal 處理器 小數的資源請求是容許的。 spec.container[].resources.requests.cpu 如果設為 0.5, 那相當於要求 1 CPU 的一半。 0.1 相等於 100m, 100m 也可讀為 “100 millicpu”。 有些人說 “100 millicores”, 都可理解為同樣的東西。 有小數點的請求, 像是 0.1, 會被 API 轉換到 100m, 而精度最小為 1m, 所以設定 100m 會是比較理想的 CPU 都是絕對數字, 不會是相對數字; 舉例來說, 0.1 在 1-core, 2-core, 或 48-core 的機器中代表的量都是一樣的。 # Memory 解釋Memory 中的 limits 以及 requests 資源管理以 bytes 為單位。 記憶體可被表示為簡單的 integer, 或固定位數的 integer, 可使用以下後綴： E, P, T, G, M, K 。 你也可以使用: Ei, Pi, Ti, Gi, Mi, Ki, 舉例來說, 下面都代表大約相同的值： 128974848, 129e6, 129M, 123Mi 這邊有個範例, 下面的 Pod 含有兩個容器。 每個容器都有 resource requests, 0.25 cpu 以及 64MiB 記憶體。 每個容器都有 resource limits 0.5 cpu 以及 128 MiB 記憶體。 可以說, 這個 Pod 有 resource requests 0.5 cpu 以及 128 MiB 記憶體, resource limits 1 cpu 以及 256 MiB 記憶體 apiVersion: v1kind: Podmetadata: name: frontendspec: containers: - name: db image: mysql env: - name: MYSQL_ROOT_PASSWORD value: &quot;password&quot; resources: requests: memory: &quot;64Mi&quot; cpu: &quot;250m&quot; limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; - name: wp image: wordpress resources: requests: memory: &quot;64Mi&quot; cpu: &quot;250m&quot; limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; # 有 resource requests 的 Pod 是被如何調度的？當你建立 Pod, Kubernetes scheduler 會挑選一個 node 來運行該 Pod。 每個 node 針對每種資源類型都有最大容量: 也就是說, 有多少 CPU 以及 memory 可以分配給 Pods。 Scheduler 會確保被調度的容器的各類型資源總和會小於該 Node 的資源總量。 注意到, 就算 node 上的資源使用量非常低, 如果容量確認沒過的話, Scheduler 還是不會分配 Pod 到這個 node 上。 這確保在 node 上資源短缺, 比如說, 在每日的資源用量高峰。 # 有 resource limits 的 Pod 是如何被調度？當 Kubelet 啟動 Pod 中的一個 Container, 它會將 CPU 以及 memory limits 帶入到該 container runtime。當使用 Docker: spec.containers[].resources.requests.cpu 會被轉換成 core 值, 它可能會是有小數點的, 以及會被乘以 1024。 在 docker run 指令中使用 --cpu-shares, 可以設定比這更高的數字或 2 spec.containers[].resources.limits.cpu 會被轉換成 millicore 值以及乘以 100。 結果值為容器在每 100ms (也就是十分之一秒)的 CPU time 中可使用的總量, 容器無法使用超過被分到的 CPU 配額, 這個部分如果看不是很懂, 有興趣的話最下面會有補充說明。 注意: 預設的 quota period 為 100ms, 最小為 1ms spec.containers[].resources.limits.memory 會被轉換成 integer, 如同 docker run 指令的 [--memory] flag 的效果 如果容器超出了其 memory limits 限制, 它會被終止。 如果它設置為可重啟, 跟其他的 runtime failure 一樣, kubelet 將會重啟它。如果容器超出了其 memory request 限制, 當 node memory 耗光了之後, 就會把該 Pod 砍了, Ray 看到這一段的時候也有點矇逼, 下面會再補充解釋！容器可能會或者可能不會被允許超出其 CPU limit 限制, 然而, 超出了也不會被砍了。要得知容器是否無法被分配, 或者因為資源限制被殺掉了, 可以參考 Troubleshooting 區塊 # 監控資源使用量資源使用率會以 Pod 狀態的部分回報 # Troubleshooting# 容器顯示 pending 以及事件訊息 failedScheduling如果 Scheduler 在 node 上無法找到足夠的資源來置放 Pod, 這個 Pod 將會持續處於未分配的狀態, 直到 Scheduler 找到足夠的資源。 每次 Scheduler 找不到足夠資源而分配失敗的話, 都會產生一個事件, 就像這樣： 取得事件：kubectl describe pod frontend | grep -A 3 Events 輸出：Events: FirstSeen LastSeen Count From Subobject PathReason Message 36s 5s 6 &#123;scheduler &#125; FailedScheduling Failed for reason PodExceedsFreeCPU and possibly others 在上面的例子中, 因為 node 的 CPU 資源不足, 所以 Scheduler 無法分配名為 “frontend” 的 Pod。 類似的錯誤訊息也會出現在 memory 不足時 (PodExceedsFreeMemory)。 另外, 如果 Pod 顯示這類型的錯誤訊息, 並卡住, 你可以試試下面的操作: 增加更多的 nodes 到叢集 終止不必要的 Pods, 騰出空間給 pending Pods 確認 Pod 沒有比所有的 nodes 大, 比方說, 如果所有的 Nodes 都有 cpu: 1 的容量, 然後 Pod 的 requests 限制為 cpu: 1.1, 那這個 pod 將無法被分配 可以使用 kubectl describe nodes 指令來確認可用容量以及已經分配出去的容量, 比如說： 執行指令kubectl describe nodes e2e-test-node-pool-4lw4 輸出:Name: e2e-test-node-pool-4lw4[ ... lines removed for clarity ...]Capacity: cpu: 2 memory: 7679792Ki pods: 110Allocatable: cpu: 1800m memory: 7474992Ki pods: 110[ ... lines removed for clarity ...]Non-terminated Pods: (5 in total) Namespace Name CPU Requests CPU Limits Memory Requests Memory Limits --------- ---- ------------ ---------- --------------- ------------- kube-system fluentd-gcp-v1.38-28bv1 100m (5%) 0 (0%) 200Mi (2%) 200Mi (2%) kube-system kube-dns-3297075139-61lj3 260m (13%) 0 (0%) 100Mi (1%) 170Mi (2%) kube-system kube-proxy-e2e-test-... 100m (5%) 0 (0%) 0 (0%) 0 (0%) kube-system monitoring-influxdb-grafana-v4-z1m12 200m (10%) 200m (10%) 600Mi (8%) 600Mi (8%) kube-system node-problem-detector-v0.1-fj7m3 20m (1%) 200m (10%) 20Mi (0%) 100Mi (1%)Allocated resources: (Total limits may be over 100 percent, i.e., overcommitted.) CPU Requests CPU Limits Memory Requests Memory Limits ------------ ---------- --------------- ------------- 680m (34%) 400m (20%) 920Mi (12%) 1070Mi (14%) 從上面的輸出可以看到, Allocatable 就是可分配的資源, 而 Allocated resources 就是已經分配出去的資源, 所以如果 Pod 被定義 requests 限制超過 1120m CPUs, 或 6.23Gi memory, 那這個 Pod 將無法被分配在這個 node, 因為資源不足啊！ 從 Pods 區塊中可以看到每個 Pod 各使用了這個 node 多少的資源。 Pod 可用的資源總量小於該 node 的 capacity, 因為系統 daemons 使用了一部分的可用資源。 allocatable 欄位 NodeStatus 提供了可分配給 Pods 的資源。 更多資訊, 可參考 Node Allocatable Resources resource quota 功能可用來設置資源可被消耗的最大限制。 如果使用在 namespaces 上, 那可以有效防止一個團隊佔據了所有的資源。 # 容器被終止容器可能會因為資源耗盡而被終止。 若要確認容器是否有因為達到資源限制而被殺掉, 使用 kubectl describe pod PodName 執行指令kubectl describe pod simmemleak-hra99 範例輸出Name: simmemleak-hra99Namespace: defaultImage(s): saadali/simmemleakNode: kubernetes-node-tf0f/10.240.216.66Labels: name=simmemleakStatus: RunningReason:Message:IP: 10.244.2.75Replication Controllers: simmemleak (1/1 replicas created)Containers: simmemleak: Image: saadali/simmemleak Limits: cpu: 100m memory: 50Mi State: Running Started: Tue, 07 Jul 2015 12:54:41 -0700 Last Termination State: Terminated Exit Code: 1 Started: Fri, 07 Jul 2015 12:54:30 -0700 Finished: Fri, 07 Jul 2015 12:54:33 -0700 Ready: False Restart Count: 5Conditions: Type Status Ready FalseEvents: FirstSeen LastSeen Count From SubobjectPath Reason Message Tue, 07 Jul 2015 12:53:51 -0700 Tue, 07 Jul 2015 12:53:51 -0700 1 &#123;scheduler &#125; scheduled Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f Tue, 07 Jul 2015 12:53:51 -0700 Tue, 07 Jul 2015 12:53:51 -0700 1 &#123;kubelet kubernetes-node-tf0f&#125; implicitly required container POD pulled Pod container image &quot;k8s.gcr.io/pause:0.8.0&quot; already present on machine Tue, 07 Jul 2015 12:53:51 -0700 Tue, 07 Jul 2015 12:53:51 -0700 1 &#123;kubelet kubernetes-node-tf0f&#125; implicitly required container POD created Created with docker id 6a41280f516d Tue, 07 Jul 2015 12:53:51 -0700 Tue, 07 Jul 2015 12:53:51 -0700 1 &#123;kubelet kubernetes-node-tf0f&#125; implicitly required container POD started Started with docker id 6a41280f516d Tue, 07 Jul 2015 12:53:51 -0700 Tue, 07 Jul 2015 12:53:51 -0700 1 &#123;kubelet kubernetes-node-tf0f&#125; spec.containers&#123;simmemleak&#125; created Created with docker id 87348f12526a 上面的 example 中, Restart Count: 5 顯示容器 simmemleak 容器已被終止並重啟五次 你可以呼叫 kubectl get pod 以及 option -o go-template=... 來取得之前中止的容器狀態 執行指令kubectl get pod -o go-template=&#x27;&#123;&#123;range.status.containerStatuses&#125;&#125;&#123;&#123;&quot;Container Name: &quot;&#125;&#125;&#123;&#123;.name&#125;&#125;&#123;&#123;&quot;\\r\\nLastState: &quot;&#125;&#125;&#123;&#123;.lastState&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; simmemleak-hra99 範例輸出Container Name: simmemleakLastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]] 可以看到, 容器因為 reason:OOM killed 而被殺掉, OOM 表示 Out Of Memory # Local ephemeral storageFEATURE STATE: kubernetes v1.17kubernetes 版本 1.8 介紹了一個新的資源, 用來管理本地臨時儲存空間的 ephemeral-storage。 在每一個 node 中, kubelet 的 root 資料夾 (預設 /var/lib/kubelet) 以及 log 資料夾 (預設 /var/log) 都被儲存在 root 分區。 這個分區同時也經由 emptyDir volumes, container logs, image layers 以及 container writable layers 被 Pods 共享 # 本地臨時儲存區的 Requests 以及 Limits 資源限制設定每個 Pod 中的容器都可以指定一個或多個以下的限制： spec.containers[].resources.limits.ephemeral-storage spec.containers[].resources.requests.ephemeral-storage ephemeral-storage 的 limits 以及 requests 資源管理以 bytes 為單位。 儲存區可被表示為簡單的 integer, 或固定位數的 integer, 可使用以下後綴： E, P, T, G, M, K 。 你也可以使用: Ei, Pi, Ti, Gi, Mi, Ki, 舉例來說, 下面都代表大約相同的值： 128974848, 129e6, 129M, 123Mi 舉例來說, 以下的 Pod 有兩個容器。 每個容器都有 2 GiB 的 本地臨時儲存區 request 限制, 而每個容器都有 4GiB 的本地臨時儲存區 limit 限制。 因此, 這個 Pod 有 4GiB 的本地臨時儲存 request 限制以及 8GiB 的 limit 限制 apiVersion: v1kind: Podmetadata: name: frontendspec: containers: - name: db image: mysql env: - name: MYSQL_ROOT_PASSWORD value: &quot;password&quot; resources: requests: ephemeral-storage: &quot;2Gi&quot; limits: ephemeral-storage: &quot;4Gi&quot; - name: wp image: wordpress resources: requests: ephemeral-storage: &quot;2Gi&quot; limits: ephemeral-storage: &quot;4Gi&quot; # 有 ephemeral-storage request 限制的 Pod 是如何被分配的？當建立一個 Pod 時, Kubernetes scheduler 會挑選 node 來運行該 Pod。 每個 node 都有 local ephemeral storage 可提供給 Pods 的最大值。 更多資訊可參考 Node Allocatable Scheduler 會確保被分配的容器的 request 限制小於 node 的容量 # 有 ephemeral-storage limit 限制的 Pod 是如何被分配的？從容器等級隔離層面來說, 如果容器的可寫層 (writable layer) 以及 logs 使用量超過了儲存限制, 那們 Pod 會被殺掉。 從 Pod 等級隔離層面來說, 如果該 Pod 內的容器 ephemeral storage 使用量超過了限制, 以及該 Pods 的 emptyDir volumes 超過了限制, 該 Pod 也會被殺掉。 官方文件就先到這裡, 以下為針對 Memory 以及 CPU 的進一步分析 # 頗析 (Memory)首先, 先針對 memory 的部分來頗析 limits 跟 requests 的詳細運作 # 建立一個沒有資源限制的 pod 輸入kubectl run limit-test --image=busybox --command -- /bin/sh -c &quot;while true; do sleep 2; done&quot; 輸出deployment.apps &quot;limit-test&quot; created # 使用 Kubectl 來驗證看看 Kubernetes 是否建立沒有資源限制的 pod 輸入kubectl get pods limit-test-7cff9996fc-zpjps -o=jsonpath=&#x27;&#123;.spec.containers[0].resources&#125;&#x27; 輸出map[] # 現在我們 ssh 到該 node, 然後使用以下指令看看 docker 是如何運行這個容器 輸入以下指令取得容器名稱docker ps | grep busy | cut -d&#x27; &#x27; -f1 得到容器名稱5c3af3101afb 輸入指令取得容器限制的 memory valuedocker inspect 5c3af3101afb -f &quot;&#123;&#123;.HostConfig.Memory&#125;&#125;&quot; 得到輸出0 .HostConfig.Memory 代表的意思是？對應到 docker run 的 –memory 參數 # 讓我們繼續往下追, 追到最終的 cgroup 取得容器 pid ps ax | grep /bin/sh 輸出 9513 ? Ss 0:00 /bin/sh -c while true; do sleep 2; done 取得該 pid cgroup sudo cat /proc/9513/cgroup 輸出 ...6:memory:/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574 (1)kubepods: 程序將會繼承所有這個 group 中的屬性(2)burstable: 可參考burstable QOS class 取得細節, 將上面的路徑 append 到 /sys/fs/cgroups/memoryls -l /sys/fs/cgroup/memory/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574 輸出...-rw-r--r-- 1 root root 0 Oct 27 19:53 memory.limit_in_bytes-rw-r--r-- 1 root root 0 Oct 27 19:53 memory.soft_limit_in_bytes # 先來看 memory.limit_in_bytes, 這是設定 memory limit 的 cgroup, 他等同於 docker 裡頭的 --memory, 以及 Kubernetes 限制的 memory limit 輸入以下指令取得數值 sudo cat /sys/fs/cgroup/memory/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574/memory.limit_in_bytes 輸出 9223372036854771712 這個數據代表沒有限制 memory, 可參考 Stackoverflow我們一開始在 Kubernetes 沒有設定 memory 限制, 導致 docker 建立一個 HostConfig.Memory 設定為 0 的容器, 最終導致這個容器的程序被放到 memory.limit_in_bytes 屬性設為 “no limit” 的 memory cgroup # 現在讓我們來建立另外一個 pod, 限制 memory limit 為 100Mi 執行以下指令kubectl run limit-test --image=busybox --limits &quot;memory=100Mi&quot; --command -- /bin/sh -c &quot;while true; do sleep 2; done&quot; 輸出deployment.apps &quot;limit-test&quot; created # 驗證這個 pod 有被設置特定的 limit 執行以下指令 kubectl get pods limit-test-5f5c7dc87d-8qtdx -o=jsonpath=&#x27;&#123;.spec.containers[0].resources&#125;&#x27; 輸出 map[limits:map[memory:100Mi] requests:map[memory:100Mi]] 這邊可以看到, 如果我們有設置 limits resource, 但是沒設置 requests resource 的時候, Kubernetes 預設將 requests 設為 limits # 取得容器 id 執行以下指令 docker ps | grep busy | cut -d&#x27; &#x27; -f1 輸出 8fec6c7b6119 # 取得容器 pid 輸入以下指令ps ax | grep /bin/sh 輸出29532 ? Ss 0:00 /bin/sh -c while true; do sleep 2; done # 取得該容器的 memory cgroup 輸入以下指令sudo cat /proc/29532/cgroup 輸出...6:memory:/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11 # 印出 memory cgroup 中的 memory.limit_in_bytes 數值 輸入以下指令sudo cat /sys/fs/cgroup/memory/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11/memory.limit_in_bytes 輸出104857600 # 最後, 讓我們來看看前面跳過的, 位於 memory cgroup 當中的 momery.soft_limit_in_bytes 輸入以下指令sudo cat /sys/fs/cgroup/memory/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11/memory.soft_limit_in_bytes 輸出9223372036854771712 從上面的值可以得知, 就算我們有設定 requests 的限制, kubernetes 也不會命令 docker 去做這件事, 儘管 docker run 的參數 --memory-reservation 是可以做到這件事的 # 頗析 (CPU)CPU 的頗析模式大致上與 memory 相同, 但還是有不一樣的地方, 讓我們繼續看下去。 # 建立一個有 request CPU 限制的 pod 輸入以下指令建立 podkubectl run limit-test --image=busybox --requests &quot;cpu=50m&quot; --command -- /bin/sh -c &quot;while true; do sleep 2; done&quot; 輸出deployment.apps &quot;limit-test&quot; created # 使用 kubectl 來檢視 pod 的資源限制資訊 輸入以下指令kubectl get pods limit-test-5b4c495556-p2xkr -o=jsonpath=&#x27;&#123;.spec.containers[0].resources&#125;&#x27; 輸出map[requests:map[cpu:50m]] 從輸出可看到 kubernetes 有確實的設定 request 資源限制 # 取得容器 id 輸入以下指令docker ps | grep busy | cut -d&#x27; &#x27; -f1 輸出f2321226620e # 查看 Docker 是否確實設定資源限制 輸入以下指令docker inspect f2321226620e --format &#x27;&#123;&#123;.HostConfig.CpuShares&#125;&#125;&#x27; 輸出51 為什麼不是 50? 那是因為 Docker 以及 cgroup 都將 core 分成 1024 份, 而 Kubernetes 則是分成 1000 份 # 取得容器 pid 輸入以下指令ps ax | grep /bin/sh 輸出60554 ? Ss 0:00 /bin/sh -c while true; do sleep 2; done # 取得容器的 CPU cgroup 輸入以下指令sudo cat /proc/60554/cgroup 輸出...4:cpu,cpuacct:/kubepods/burstable/pode12b33b1-db07-11e8-b1e1-42010a800070/3be263e7a8372b12d2f8f8f9b4251f110b79c2a3bb9e6857b2f1473e640e8e75 # 取得 cgroup 屬性 輸入以下指令ls -l /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pode12b33b1-db07-11e8-b1e1-42010a800070/3be263e7a8372b12d2f8f8f9b4251f110b79c2a3bb9e6857b2f1473e640e8e75 輸出total 0drwxr-xr-x 2 root root 0 Oct 28 23:19 .drwxr-xr-x 4 root root 0 Oct 28 23:19 .....-rw-r--r-- 1 root root 0 Oct 28 23:19 cpu.shares 以上輸出可知, Docker 的 HostConfig.CpuShares 屬性映射到 cgroup 的 cpu.shares 屬性 # 取得 cpu.shares 的值 輸入以下指令/sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/podb5c03ddf-db10-11e8-b1e1-42010a800070/64b5f1b636dafe6635ddd321c5b36854a8add51931c7117025a694281fb11444/cpu.shares 輸出51 咦, 以上的行為跟 memory 不太一樣對吧? 限制 memory 的 resource limit 是不會作用到 cgroup 的 soft limits 的 # 接下來, 建立一個有著 limit resource 的 pod 輸入以下指令kubectl run limit-test --image=busybox --requests &quot;cpu=50m&quot; --limits &quot;cpu=100m&quot; --command -- /bin/sh -c &quot;while true; dosleep 2; done&quot; 輸出deployment.apps &quot;limit-test&quot; created # 使用 kubectl 來檢視第二個 pod 的資源限制資訊 輸入以下指令kubectl get pods limit-test-5b4fb64549-qpd4n -o=jsonpath=&#x27;&#123;.spec.containers[0].resources&#125;&#x27; 輸出map[limits:map[cpu:100m] requests:map[cpu:50m]] 從輸出可看到 kubernetes 有確實的設定 request 資源限制 # 取得第二個容器 id 輸入以下指令docker ps | grep busy | cut -d&#x27; &#x27; -f1 輸出f2321226620e # 查看 Docker 是否確實設定資源限制 輸入以下指令docker inspect 472abbce32a5 --format &#x27;&#123;&#123;.HostConfig.CpuShares&#125;&#125; &#123;&#123;.HostConfig.CpuQuota&#125;&#125; &#123;&#123;.HostConfig.CpuPeriod&#125;&#125;&#x27; 輸出51 10000 100000 Dokcer 使用了兩個值來代表 memory resource limit, HostConfig.CpuPeriod 跟 HostConfig.CpuQuota, 而這兩個值又分別映射到 cgroup 的兩個屬性 cpu.cfs_period_us 跟 cpu.cfs_quota_us # 取得 cpu.cfs_period_us 跟 cpu.cfs_quota_us 的值 輸入以下指令sudo cat /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod2f1b50b6-db13-11e8-b1e1-42010a800070/f0845c65c3073e0b7b0b95ce0c1eb27f69d12b1fe2382b50096c4b59e78cdf71/cpu.cfs_period_us 輸出100000 輸入以下指令sudo cat /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod2f1b50b6-db13-11e8-b1e1-42010a800070/f0845c65c3073e0b7b0b95ce0c1eb27f69d12b1fe2382b50096c4b59e78cdf71/cpu.cfs_quota_us 輸出10000 # CPU 頗析的總結 period 為百萬分之一秒 quota 為程序容許在 period 中可調動的 CPU 100 m 就剛好是 1/10 core, 也是 10000/100000 百萬分之一秒 CPU 的資源限制中, request 是會作用到 cgroup 的, 該種類在 memory 是不會作用到 cgroup 的 # 以下是幫助釐清觀念的 Q&amp;A以下的 Kubernetes 範例輸出中, 為什麼 node 的可用資源比 node 的 capacity 少？ Example:Name: e2e-test-node-pool-4lw4[ ... lines removed for clarity ...]Capacity: cpu: 2 memory: 7679792Ki pods: 110Allocatable: cpu: 1800m memory: 7474992Ki pods: 110[ ... lines removed for clarity ...]Non-terminated Pods: (5 in total) Namespace Name CPU Requests CPU Limits Memory Requests Memory Limits --------- ---- ------------ ---------- --------------- ------------- kube-system fluentd-gcp-v1.38-28bv1 100m (5%) 0 (0%) 200Mi (2%) 200Mi (2%) kube-system kube-dns-3297075139-61lj3 260m (13%) 0 (0%) 100Mi (1%) 170Mi (2%) kube-system kube-proxy-e2e-test-... 100m (5%) 0 (0%) 0 (0%) 0 (0%) kube-system monitoring-influxdb-grafana-v4-z1m12 200m (10%) 200m (10%) 600Mi (8%) 600Mi (8%) kube-system node-problem-detector-v0.1-fj7m3 20m (1%) 200m (10%) 20Mi (0%) 100Mi (1%)Allocated resources: (Total limits may be over 100 percent, i.e., overcommitted.) CPU Requests CPU Limits Memory Requests Memory Limits ------------ ---------- --------------- ------------- 680m (34%) 400m (20%) 920Mi (12%) 1070Mi (14%) Answer:因為系統 daemons 使用了一部分的資源 以下的 Kubernetes 範例輸出中, requests CPU Request 限制還有多少 quota 可分配？ Example:Name: e2e-test-node-pool-4lw4[ ... lines removed for clarity ...]Capacity: cpu: 2 memory: 7679792Ki pods: 110Allocatable: cpu: 1800m memory: 7474992Ki pods: 110[ ... lines removed for clarity ...]Non-terminated Pods: (5 in total) Namespace Name CPU Requests CPU Limits Memory Requests Memory Limits --------- ---- ------------ ---------- --------------- ------------- kube-system fluentd-gcp-v1.38-28bv1 100m (5%) 0 (0%) 200Mi (2%) 200Mi (2%) kube-system kube-dns-3297075139-61lj3 260m (13%) 0 (0%) 100Mi (1%) 170Mi (2%) kube-system kube-proxy-e2e-test-... 100m (5%) 0 (0%) 0 (0%) 0 (0%) kube-system monitoring-influxdb-grafana-v4-z1m12 200m (10%) 200m (10%) 600Mi (8%) 600Mi (8%) kube-system node-problem-detector-v0.1-fj7m3 20m (1%) 200m (10%) 20Mi (0%) 100Mi (1%)Allocated resources: (Total limits may be over 100 percent, i.e., overcommitted.) CPU Requests CPU Limits Memory Requests Memory Limits ------------ ---------- --------------- ------------- 680m (34%) 400m (20%) 920Mi (12%) 1070Mi (14%) Answer:1800m - 680m = 1120m Kubernetes 中, 每次當 Scheduler 無法在 node 上找到足夠的資源來置放 Pod 時, 都會產生一個什麼事件？Events: FirstSeen LastSeen Count From Subobject PathReason Message 36s 5s 6 &#123;scheduler &#125; FailedScheduling Failed for reason PodExceedsFreeCPU and possibly others Kubernetes 的可計算資源管理中, 所指定的資源配額是絕對數字還是相對數字？絕對數字 Kubernetes compute resource management 中, 如果我 CPU 設為 0.1, 在單核, 雙核, 甚至 48核的機器中, 代表的量會有所不同嗎？不會哦 什麼是 TLB?Translation lookaside buffer, 緩存虛擬記憶體到實體記憶體的 mapping 在 Linux 系統中, 虛擬記憶體管理系統中, 最小的 memory 單位是什麼？page Kubernetes resource limit management 中, huge page 是什麼?size 較大的 page Kubernetes 中, 如果一個 Pod 卡在 pending status, 那很有可能是甚麼原因？沒有 Node 有足夠的資源來運行這個 Pod Kubernetes 中, Resource 的限制可分為 CPU 以及 Memory, 限制類型主要分成哪兩種？ Request Limit Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, request 主要代表的是？這個 Pod 正常需要多少的資源可以正常運行 Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 在 Kubernetes 各元件當中, request resource 對哪一個元件格外重要？scheduler Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 在 Kubernetes 各元件當中, limit resource 對哪一個元件格外重要？kubelet Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 當 Scheduler 在選擇要在哪一個 Node 上面運行 Pod 時, 主要會考量哪一種類？request Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 當 Scheduler 跟 request 的關係是？Scheduler 會選擇有足夠資源 (request 要求的資源) 的 node 來運行該 pod 以下的 Kubernetes yaml 檔所代表的意思是? yaml 檔:resources: requests: cpu: 50m memory: 50Mi limits: cpu: 100m memory: 100Mi Answer:# 定義資源限制resources: # 定義 requests 種類限制, scheduler 會選擇有足夠 request 資源的 Node 來運行該 Pod requests: cpu: 50m memory: 50Mi # 定義 limits 種類限制, Kubelet 會根據 limits 資源來決定是否重啟該 Pod limits: cpu: 100m memory: 100Mi Kubernetes 中, 1 MiB 等於多少？1 MiB = 1024 KiB = 1024 * 1024 = 1048576 Bytes Kubernetes 中, 1 MB 等於多少？1 MB = 1000 KB = 1000 * 1000 = 1000000 Bytes Kubernetes 中, 一個 Pod 的資源總限制是 什麼 的總和？該 Pod 內所有容器的資源限制加總 Cgroup 的全寫是？Control Group Cgroup 簡單解釋?有著一系列相關屬性的容器, 控制 kernel 如何運行程序 Kubernetes resource limit 中, 當我們只設置 limits, 但沒設置 requests 時, 會發生什麼事？Kubernetes 會將 requests 設為 limits 的值 當宿主機面臨記憶體壓力時, 會做什麼事？會殺掉程序 當一個程序使用了超過在 cgroup 中規定的 memory 時, 會發生什麼事？該程序會被列入要殺掉的優先名單中 Server 中的 OOM 的全寫是??Out Of Memory Kubernetes resource limit 當中, 當我設定了 requests 的限制, Kubernetes 會否要求 docker 去設定 memory cgroup 中的 soft_limit?不會 Kubernetes resource limit 當中, requests 若設得太高會發生什麼事？可能會出現沒有 node 可以運行這個 pod, 明明這個 pod 正常不會需要這麼高的 memory Kubernetes resource limit 當中, requests 若設得太低會發生什麼事？如果一個 node 的剩餘空間已經沒有很多了, 因為 request 設得低, 所以依然會被分派到這個 node, 但該 pod 實際需要的資源遠高於 request 值, 所以該 node 面臨記憶體壓力時就會優先砍掉這個 pod Kubernetes 中, 一個 core 為幾 m?1000 m Kubernetes 將一個 core 分成幾份？1000 Docker 將一個 core 分成幾份？1024 CGroup 將一個 core 分成幾份？1024 Kubernetes 中, 當設定 memory 的 request limit 後, 會作用到 cgroup 嗎？不會 Kubernetes 中, 當設定 CPU 的 request limit 後, 會作用到 cgroup 嗎？會 Kubernetes resource limit 中, request resource 是由哪一個 cgroup 系統所管理的?cpu shares system cgroup cpu.cfs_period_us 中的 period 代表幾秒？1/10 秒 或 100000 microseconds (百萬分之一秒) cgroup cpu.cfs_quota_us 中的 quota 代表什麼？一個程序在 period 中容許可調用的最大值 假如我的 CPU request limit 是 200m, 那我的 cpu.cfs_period_us 以及 cpu.cfs_quota_us 分別是多少？ cpu.cfs_period_us: 100000 cpu.cfs_quota_us: 20000 cpu.cfs_period_us 跟 cpu.cfs_quota_us 是屬於哪一個 cgroup?cpu,cpuacct cpu.cfs_period_us 跟 cpu.cfs_quota_us 中的 cfs 的意思是?Completely Fair Scheduler Linux 的預設 CPU scheduler 是哪一個?CFS (Completely Fair Scheduler) Kubernetes 中, 當設定 CPU 的 request resource 限制, 會作用到 cgroup 嗎？會哦 Kubernetes 中, 程序可以超出 CPU request resource 限制 規定的用量嗎？不行 Kubernetes 中, 當程序使用了超過 CPU request resource 限制 規定的用量的話, 會發生什麼事？不會有這種情況, 因為 CPU request resource 限制 規定的用量不允許超出 Kubernetes resource limit 中, 如果我只設定了 limits, 但沒設定 requests, 會發生什麼事？requests 的預設值會被設為跟 limits 一樣 Kubernetes resource limit 中, 如果我只設定了 requests, 但沒設定 limits, 會發生什麼事？scheduler 會正常根據 requests 的資源數據啟動 pod, 但該 process 的資源使用量將無法被限制 以下的 Kubernetes yaml 設定檔的意思是? yaml 檔:apiVersion: v1kind: LimitRangemetadata: name: default-limitspec: limits: - default: memory: 100Mi cpu: 100m defaultRequest: memory: 50Mi cpu: 50m - max: memory: 512Mi cpu: 500m - min: memory: 50Mi cpu: 50m type: Container Answer:# API 版本apiVersion: v1# 種類為 LimitRangekind: LimitRange# 該 LimitRange 的 metadatametadata: # 該 LimitRange 的 name name: default-limit# 該 LimitRange 運行的規格spec: # 定義 limits limits: # 預設的 resource limits, 若該 namespace 下的 pod 在建立時沒有指定資源限制, 將套用此預設設定 - default: memory: 100Mi cpu: 100m # 預設的 resource requested, 若該 namespace 下的 pod 在建立時沒有指定資源限制, 將套用此預設設定 defaultRequest: memory: 50Mi cpu: 50m # 若欲在此 namespace 下建立 pod, 而該 pod 若指定資源限制高於此設定, 將不允許建立 - max: memory: 512Mi cpu: 500m # 若欲在此 namespace 下建立 pod, 而該 pod 若指定資源限制低於此設定, 將不允許建立 - min: memory: 50Mi cpu: 50m # 限制的類型為 container type: Container Kubernetes request resource 限制中, 1 core = 1000 m, 那允許的最小設定值是多少？1m Kubernetes 中, 要如何查看 node 有多少可用資源？kubectl describe nodes nodeName Kubernetes 中, 如何知道容器有沒有因為資源達到限制而被砍掉？ 取得 pod 資訊kube describe pod podName 取得前一個 pod 被砍掉的原因kubectl get pod -o go-template=&#x27;&#123;&#123;range.status.containerStatuses&#125;&#125;&#123;&#123;&quot;Container Name: &quot;&#125;&#125;&#123;&#123;.name&#125;&#125;&#123;&#123;&quot;\\r\\nLastState: &quot;&#125;&#125;&#123;&#123;.lastState&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; simmemleak-hra99 Kubernetes 中, local ephemeral storage 指的是什麼地方？root partition Kubernetes 中, emptyDir volumes, container logs, image layers, container writable layers, 這些都是使用哪一塊空間？root partition 以下的 Kubernetes yaml 檔是什麼意思呢？ yaml 檔apiVersion: v1kind: Podmetadata: name: frontendspec: containers: - name: db image: mysql env: - name: MYSQL_ROOT_PASSWORD value: &quot;password&quot; resources: requests: ephemeral-storage: &quot;2Gi&quot; limits: ephemeral-storage: &quot;4Gi&quot; - name: wp image: wordpress resources: requests: ephemeral-storage: &quot;2Gi&quot; limits: ephemeral-storage: &quot;4Gi&quot; Answer:# API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: frontend# 該 pod 運行的規格spec: # 定義容器規格 containers: # 容器名稱 - name: db # 鏡像名稱 image: mysql # 定義變數 env: # 變數名稱 - name: MYSQL_ROOT_PASSWORD # 變數值 value: &quot;password&quot; # 定義資源限制 resources: # 定義 requests 資源限制 requests: # 限制 ephemeral-storage ephemeral-storage: &quot;2Gi&quot; # 定義 limits 資源限制 limits: # 限制 ephemeral-storage ephemeral-storage: &quot;4Gi&quot; # 容器名稱 - name: wp # 鏡像名稱 image: wordpress # 定義資源限制 resources: # 定義 requests 資源限制 requests: # 限制 ephemeral-storage ephemeral-storage: &quot;2Gi&quot; # 定義 limits 資源限制 limits: # 限制 ephemeral-storage ephemeral-storage: &quot;4Gi&quot; Kubernetes, 哪一個元件依據 ephemeral-storage 資源分配 pod 到適當的 node?scheduler Kubernetes, 如果一個 pod 裡頭的某個容器的 writable layer 以及 logs 使用量超過的 ephemeral-storage 的資源限制, 會發生什麼事？該 pod 會被砍了 Kubernetes, 如果一個 pod 裡頭的所有容器使用的 ephemeral-storage 用量以及 emptyDir volumes 超過了資院限制, 會發生什麼事？該 pod 會被砍了 # 參考資源 Understanding resource limits in Kubernetes: memory Understanding resource limits in kubernetes: cpu time Docker Documentation Kubernetes Documentation Kubernetes/enhancements","link":"/zh-tw/managing-compute-resources-for-containers/"},{"title":"Cloud Functions 上的監控與紀錄","text":"概述你可以在 GCP 主控台檢視你的 Cloud Functions 的執行時間，執行次數，記憶體用量。 這些指標在 Stackdriver Monitoring 上也有，你可以在這裡根據這些指標來設定你的客製化警告。 更多資訊請參考 Stackdriver Monitoring 文件 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Quiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Quiclabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 Stackdriver 工作區在 Navigation menu, 點擊 Monitoring 當你看到 Stackdriver 的主控台時， 工作區已準備完畢 在 Stackdriver 檢視 Cloud Functions 的紀錄 &amp; 指標現在你將會建立一個可以被監控的 Hello World 的 cloud function 回到主控台，在左邊的選單，點擊 Cloud Functions, 然後 Create function 使用以下的設定來建立你的 function: Name: qwiklabsDemo Trigger: HTTP Index.js tab: 將 placeholder 替換成下面的代碼 /** * Cloud Function. * * */exports.qwiklabsDemo = function qwiklabsDemo (req, res) &#123; res.send(`Hello $&#123;req.body.name || &#x27;World&#x27;&#125;!`); console.log(req.body.name);&#125; Function to execute: qwiklabsDemo 當你準備好時，點擊 Create cloud function 將會自動部署，且部署完畢後你可以在 Overview 頁面看到它。 這會需要幾分鐘的時間。 當你可以在名字的旁邊看到一個綠色的確認符號，這代表 cloud function 已經部署完畢。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 在 Cloud Shell, 執行以下的代碼來下載一個叫做 vegeta 的工具，它可以讓我們傳送一些測試用流量到 cloud function wget &#x27;https://github.com/tsenart/vegeta/releases/download/v6.3.0/vegeta-v6.3.0-linux-386.tar.gz&#x27; 輸入以下指令來解壓縮 vegeta tar xvzf vegeta-v6.3.0-linux-386.tar.gz 在主控台，點擊 cloud function 的名字, 然後點擊 trigger, 最後點擊下面的 URL 如果新的視窗開啟，並且你有看到 Hello World!, 這代表 cloud function 正常運作中。 現在傳送一些流量到 cloud function 執行以下的代碼，將 YOUR_PROJECT_ID 替換成你的 Project ID echo &quot;GET https://us-central1-&lt;YOUR_PROJECT_ID&gt;.cloudfunctions.net/qwiklabsDemo&quot; | ./vegeta attack -duration=300s &gt; results.bin 建立基於紀錄的指標現在你將建立一個分佈類型 (Distribution type) 的紀錄指標，使用正則表達式，從記錄數據的 textPayload 欄位取得延遲的值 點擊 Navigation menu 回到左方選單，然後在 Stackdriver section 區塊點擊 Logging, 你將會被引導到紀錄畫面 從第一個下拉選單選擇 Cloud Function，然後從所有的紀錄下拉選項裡選擇 cloud-functions, 然後點擊 OK, 這樣我們只會看到 Cloud Function 的紀錄： 在 *Filter By… 的欄位，輸入 “function execution took” (包含雙引號) 來篩選你的紀錄 然後在畫面上方點擊 Create Metric 在指標編輯器： 將指標命名為 CloudFunctionLatency-Logs 將 Type 改為 Distribution Field Name 請輸入 textPayload 點擊位於 Extraction regular expression 欄位旁的 Build 在 Regular Expression 欄位裡，輸入以下的代碼： execution took (\\d+) 指標編輯器應該看起來像這樣： 點擊 Create Metric 現在你會看到這個使用者自定義的指標已經被加到 Logs-based Metric 頁面 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 Metrics Explorer (指標探索器)接下來，使用指標探索器來檢視 cloud function 的資料 在 Stackdriver tab 的視窗，到 Resources &gt; Metrics Explorer 來檢視一些 Cloud Functions 的指標。 開始在欄位中輸入 execution, 然後從建議指標中選擇 Executions。 在圖表的上方的下拉選單，將圖表類型變更為 stacked bar 現在試試看不同的指標來看看有什麼其他的圖形選項。 點擊 Metric 旁邊的 X, 然後選擇 Execution times 圖表預設為 heatmap, 但你可以更改承認和你喜歡的類型 你也可以檢視不同的加總，例如百分位排名第 95 位： 客製化顯示面板客製化一個顯示面板是一個非常好的方式來儲存對你來說重要的指標圖表。 你將再次設定這些圖表，但這次他們會儲存在你的顯示面板 在 Stackdriver 主控台，點擊 Dashboards &gt; Create Dashboard 將這個顯示面板取名為 “Results”, 然後點擊 Add Chart 點擊到 Find resource type and metric 欄位，然後選擇我們在上面最後建立的表格的資源類型以及指標, 點擊 Add Chart 來建立下一個 在選擇指標後，圖表會自動被命名, 但你可以重新命名 當你完成這一切，你的圖表將會出現在你的顯示面板，提供一個快速的參考值來顯示目前資源的狀況 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 恭喜！你已完成本教程","link":"/zh-tw/monitoringAndLoggingForCloudFunctions/"},{"title":"使用 GCP Kubernetes Engine 來管理部署","text":"概述Dev Ops 實踐通常使用多重部署的方法來管理應用部署情境, 像是 “持續部署”, “Blue-Green 部署”, “Canary 部署”, 等等… 本教程主要提供擴充以及管理容器的方法, 所以你可以完成這些使用多重部署的通用情境。 你將會做什麼？ Kubectl 工具的練習 建立 deployment yaml 檔案 啟動, 更新, 以及擴充 deployments 更新 deployments 以及 部署風格的練習 事先準備 在開始本教程之前, 你應該至少完成 Introduction to Docker 以及 Hello Node Kubernetes Linux 系統管理技能 Dev Ops 理論： 持續部署的概念 deployments 介紹Heterogeneous deployments (多種類部署) 一般來說包含兩個或多個基礎設施或地區以解決特定技術或運作需求。 Heterogeneous deployments 又被稱為 “hybrid”, “multi-cloud”, 或 “public-private”, 取決於部署細節。在本教程中, heterogeneous deployments 包含地區橫跨單一雲端環境, 多公開雲端環境 (multi-cloud), 或是內部部署以及公開雲端的結合 (hybrid 或 public-private) 單一環境或地區的部署可能會在業務邏輯上或技術上有一些問題 資源耗盡: 在單一環境中, 尤其是內部部署環境, 你可能沒有正式環境需要的計算, 網路, 或儲存資源 被限制的觸及地區: 單一環境的部署需要不同區域的人們存取不同區域的部署, 他們的流量可能會繞了世界一周之後才到達一個中間地區 被限制的可用性: 網路擴充流量模式對應用保持容錯以及適應, 會是一個挑戰 供應商鎖定: 供應商等級的平台以及基礎設施抽象將讓應用移植變得困難 不靈活的資源: 你的資源可能會被限制在一組特定的計算機, 儲存區, 或網路 Heterogeneous 可幫我們解決這些難題, 但他們必須被建構在可程式化以及確定性的程序以及步驟。 一次性的或點對點的部署步驟會造成部署或程序脆弱, 以及容錯能力降低。 點對點程序會丟失資料或丟棄流量。 一個好的部署程序需要是可重複的, 使用已確認可用的方法來管理提供, 設定, 以及維護。 三個 heterogeneous 通用的情境, 分別是 multi-cloud deployments (多雲端部署), fronting on-premises data (前端導向內部資料), 以及 CI/CD (持續整合 / 持續部署) 程序 以下的練習會實作一些 heterogeneous deployments 通用使用情境, 以及透過良好架構的 Kubernetes 方法以及其他的基礎設施資源來達成 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 設定 zone執行以下指令來設定你的 GCP zone, 將 local zone us-central1-a 替換掉 gcloud config set compute/zone us-central1-a 取得本教程範例程式碼取得建立, 運行容器以及 deployments 的範例程式碼 git clone https://github.com/googlecodelabs/orchestrate-with-kubernetes.gitcd orchestrate-with-kubernetes/kubernetes 建立一個含有 5 台 n1-standard-1 node 的叢集 (會需要幾分鐘時間完成) gcloud container clusters create bootcamp --num-nodes 5 --scopes &quot;https://www.googleapis.com/auth/projecthosting,storage-rw&quot; 理解 deployment 物件讓我們從 Deployments 開始。 首先檢視一下 Deployment 物件。 kubectl 的 explain 指令可以告訴我們有關 Deployment 物件的資訊 kubectl explain deployment 我們可以使用 --resursive 選項來檢視所有的欄位 kubectl explain deployment --recursive 在你進行本教程的過程中, 你可以使用 explain 來更了解 Deployment 物件的結構, 以及每個欄位做什麼事 kubectl explain deployment.metadata.name 建立 deployment更新 deployments/auth.yaml cs 檔案： vim deployments/auth.yaml 開始編輯模式 i 將 container 區塊內的 image 變更如下： ...containers:- name: auth image: kelseyhightower/auth:1.0.0... 儲存 auth.yaml 檔案, 按下 &lt;Esc&gt;, 然後： :wq 現在讓我們來建立一個簡單的 deployment 。 檢視 deployment 設定檔 cat deployments/auth.yaml (輸出) apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: &quot;kelseyhightower/auth:1.0.0&quot; ports: - name: http containerPort: 80 - name: health containerPort: 81... 注意到 Deployment 是如何建立一個 replica 且使用 auth container 的 version 1.0.0 當你執行 kubectl create 指令來建立 auth deployment 時, 一個符合 Deployment 設定檔的 pod 將會被建立。 這表示說, 我們可以藉由變更 replica 欄位的數量擴縮 Pods 的數量 使用 kubectl create 來建立 deployment 物件 kubectl create -f deployments/auth.yaml 一旦你已經建立 Depolyment, 你可以確認看看它是否有被建立 kubectl get deployments 一旦 deployment 被建立了, Kubernetes 會建立一個相對應的 ReplicaSet 。 我們可以確認對應該 Deployment 的 ReplicaSet 是否有被建立 kubectl get replicasets 我們應會看到一個名為 auth-xxxxxx 的 ReplicaSet 最後, 我們可以檢視 Pods, 它是 Deployment 的一部分。 當 ReplicaSet 被建立, Kubernetes 會建立一個 Pod kubectl get pods 是時候建立一個 auth deployment 的 service 。 你已經看過 service 的設定檔, 所以在這我們不會探究更多細節。 使用 kubectl create 指令來建立 auth service kubectl create -f services/auth.yaml 現在, 同樣的步驟, 讓我們建立以及暴露 hello Deployment kubectl create -f deployments/hello.yamlkubectl create -f services/hello.yaml 然後再一次, 建立以及暴露 frontend Deployment kubectl create secret generic tls-certs --from-file tls/kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.confkubectl create -f deployments/frontend.yamlkubectl create -f services/frontend.yaml 注意: 你為 frontend 建立了一個 ConfigMap 取得 frontend 的外部 IP 然後使用 curl 與它互動 kubectl get services frontendcurl -ks https://EXTERNAL-IP 然後你會得到一個 hello 的回應你也可以使用 kubectl 的輸出模板功能搭配 curl, 讓指令變成只需要一行 curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot;` 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立了 Kubernetes 叢集以及 Auth, Hello, 跟 Frontend deployments, 你將獲得一個評價分數。 擴縮 Deployment現在我們已建立一個 Deployment, 我們可以擴縮它。 可以藉由更新 spec.replicas 欄位來達成。 你可以再次使用 Kubectl explain 指令來檢視這個欄位的解釋 kubectl explain deployment.spec.replicas 更新 replicas 欄位最簡單的方法就是使用 kubectl scale 指令 kubectl scale deployment hello --replicas=5 注意: 要讓全部的 pods 都啟動且運行約需要幾分鐘Deployment 建立後, Kubernetes 會自動地更新相對應的 ReplicaSet 以及啟動新的 Pods, 讓 Pods 的總數量等於 5 確認是否有 5 個 hello Pods 運行中： kubectl get pods | grep hello- | wc -l 現在擴縮回原本的數量 kubectl scale deployment hello --replicas=3 再一次, 確認 Pods 的數量是正確的 kubectl get pods | grep hello- | wc -l 你已經學習了 Kubernetes deployments 以及如何管理 &amp; 擴縮 Pods 群組 rolling update (滾動升級)Deployments 支援透過滾動升級的機制進行鏡像升級。 當 Deployment 被更新成新的版本, 它會建立一個新的 ReplicaSet, 並且慢慢的增加新版的 replicas 的數量, 同時, 也慢慢地減少舊版的 replicas 數量 觸發滾動升級執行以下指令來更新 Deployment: kubectl edit deployment hello 將 containers 區塊內的 image 變更如下： ...containers:- name: hello image: kelseyhightower/hello:2.0.0... 儲存並離開一但你成功的儲存編輯器, 更新的 Deployment 會被儲存到你的叢集, 然後 Kubernetes 將會開始滾動升級。檢視 Kubernetes 新建立的 ReplicaSet kubectl get replicaset 同時你也可以檢視 rollout 的紀錄 kubectl rollout history deployment/hello 暫停滾動升級如果在滾動升級的過程中, 你發現一些問題, 你可以停止升級 kubectl rollout pause deployment/hello 確認目前的滾動狀態 kubectl rollout status deployment/hello 你也可以直接透過 Pods 資訊來確認 kubectl get pods -o jsonpath --template=&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&quot;\\t&quot;&#125;&#123;&quot;\\t&quot;&#125;&#123;.spec.containers[0].image&#125;&#123;&quot;\\n&quot;&#125;&#123;end&#125;&#x27; 繼續滾動升級滾動升級被中斷了, 這表示有一些 Pods 正運行著新版本而有些 Pods 運行舊版本。 我們可以使用以下的 resume 指令來繼續未完成的滾動 kubectl rollout resume deployment/hello 當滾動完成了, 你執行 status 指令時, 應會看到輸出如下： kubectl rollout status deployment/hello (輸出) deployment &quot;hello&quot; successfully rolled out 回滾假設我們在新版本發現了一個 bug 。 因為新版本有問題, 任何存取新的 Pods 資源的使用者都會遇到這個問題你會想要回滾之前的版本, 所以你可以看看出了什麼問題, 待修復後再發布一個新的版本使用 rollout 指令來回滾到之前的版本 kubectl rollout undo deployment/hello 確認回滾歷史 kubectl rollout history deployment/hello 最後, 確認所有的 Pods 都有回滾到之前的版本 kubectl get pods -o jsonpath --template=&#x27;&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;&quot;\\t&quot;&#125;&#123;&quot;\\t&quot;&#125;&#123;.spec.containers[0].image&#125;&#123;&quot;\\n&quot;&#125;&#123;end&#125;&#x27; 帥氣！ 你已經學會 Kubernetes 的滾動升級, 以及如何 0 downtime 的更新你的應用 金絲雀部署 (Canary Deployments)當你想要在正式環境只對一部分的使用者進行新版本的測試, 你可以使用金絲雀部署。 金絲雀部署讓你可以只發布變更到一小部分的使用者, 降低新發布的風險 建立一個金絲雀部署 (canary deployment)金絲雀部署包含分開的 deployment, 以及一個共同的 service, 這個 service 可以導向穩定, 一般的版本, 以及金絲雀版本 首先, 建立一個新的金絲雀 deployment cat deployments/hello-canary.yaml (輸出) apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-canaryspec: replicas: 1 template: metadata: labels: app: hello track: canary # Use ver 1.0.0 so it matches version on service selector version: 1.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81... 確認有更新到版本 1.0.0 (如果你的版本是指向其他的)現在建立一個金絲雀 deployment kubectl create -f deployments/hello-canary.yaml 金絲雀 deployment 被建立後, 你應會有兩個 deployments, hello 以及 hello-canary 。 使用以下的 kubectl 指令來確認: kubectl get deployments 在 hello service, selector 使用 app:hello selector, 這將會同時符合 prod deployment 以及 canary deployment 。 然而, 因為 canary deployment 的 pods 數量較少, 所以它對使用者的可見度來說是相對低的。 確認 canary deployment你可以發請求, 並經由以下指令來確認服務該請求的 hello 版本 curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot;`/version 執行這個指令多次, 你應會看到有一些請求是由 hello 1.0.0 所服務, 而有一小部分 (1/4 = 25%) 的請求是由 2.0.0 所服務 測試進度點擊 Check my progress 來確認目前的進度。如果你已經建立金絲雀部署, 你將獲得一個評價分數。 在正式環境中的 Canary deployments - session affinity在本教程中, 每個發往 Nginx 服務的請求都有機率由 canary deployment 所服務。 但如果是你不想要某些使用者是由 canary deployment 來服務呢？ 一個使用情境是當你 canary deployment 的 UI 有變動, 而你不想要讓使用者覺得疑惑。 在這個使用情境中, 你想要讓使用者們可以固定的被不同的 deployment 所服務, 不會一直切換來切換去的。 你可以建立一個賦有 session affinity 的 service 。 這個方法會讓使用者總是被同一個版本的 deployment 服務。 在以下的範例中, service 跟之前的沒什麼不同, 但多了一個 sessionAffinity 欄位, 並設定成 ClientIP 。 所有有著相同 IP 的客戶端將會由相同的 hello 版本的應用所服務 kind: ServiceapiVersion: v1metadata: name: &quot;hello&quot;spec: sessionAffinity: ClientIP selector: app: &quot;hello&quot; ports: - protocol: &quot;TCP&quot; port: 80 targetPort: 80 因為這個情境比較難測試, 所以我們不必在此測試, 但你可能會想要在正式環境中使用 sessionAffinity Blue-green deployment滾動升級是個理想的部署方式, 因為它讓我們可以用最小效能影響, downtime, 以及花費來部署應用。 然而在某些情況中, 待新版本部署完成後, 修改平衡負載指向新版本, 這種方式會是比較有利的。 在這樣的使用情境下, blue-green 部署會是我們需要的方式Kubernetes 藉由建立兩個分開的 deployments 來達成這個目的; 一個舊的 “blue” 版本的 deployment 以及一個新的 “green” 版本的 deployment 。 使用已存在的 hello 來作為 “blue” 版本。 這個 deployment 將會透過一個角色為路由的 Service 來被存取。 一旦新的 “green” 版本已成功啟動並且運行中, 你可以藉由更新這個 service 來切換使用新版本。 blue-green deployments 有一個主要的缺點, 那就是你必須在叢集中要有至少 2 組以上的資源來運行你的應用。 在你同時部署兩個版本的應用到叢集之前, 務必確認你有足夠的資源。 The service (服務)使用已存在的 hello service, 但是把它的 selector 更新成 app:hello, version: 1.0.0 。 這個 selector 會符合 “blue” deployment, 但不會符合 “green” deployment 因為它使用不同的版本首先更新服務： kubectl apply -f services/hello-blue.yaml 更新使用 Blue-Green deployment我們將建立一個新版本 “green” deployment 來支援 blue-green deployment 風格。 這個 green deployment 更新了版本標籤以及鏡像路徑。 apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-greenspec: replicas: 3 template: metadata: labels: app: hello track: stable version: 2.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: 10Mi livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 建立 green deployment kubectl create -f deployments/hello-green.yaml 一但你已經建立好 green deployment, 並且它已經被正確啟動且運行, 確認目前是否還是使用 1.0.0 的版本 curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot;`/version 現在更新服務來指向新的 deployment 版本 kubectl apply -f services/hello-green.yaml 當 service 被更新後, “green” deployment 會立即地被使用。 你可以確認新版本是否一直被使用著 curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot;`/version Blue-Green 回滾如果需要的話, 你也可以使用同樣的方式回滾到舊的版本。 儘管 “blue” deployment 還在運行著, 可以直接更新 service 到舊的版本 kubectl apply -f services/hello-blue.yaml 一但你更新了服務, 回滾也就完成了。 再一次, 確認看看目前使用中的是否是正確的版本 curl -ks https://`kubectl get svc frontend -o=jsonpath=&quot;&#123;.status.loadBalancer.ingress[0].ip&#125;&quot;`/version 你做到了！ 你已經學到 blue-green deployment 以及如何立即全部一次切換的部署方法 恭喜你已經完成本教程! Q&amp;A 以下的 deployment yaml 檔設定分別代表什麼意思？ deployment yaml:apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: &quot;kelseyhightower/auth:1.0.0&quot; ports: - name: http containerPort: 80 - name: health containerPort: 81 Answer:# apiVersion: 版本, 會隨著版本而變動, 可參考[文件](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#-strong-api-overview-strong-)apiVersion: extensions/v1beta1# 種類, 可參考[文件](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#-strong-api-overview-strong-)kind: Deployment# 該 Deployment 的 metadatametadata: # 該 deployment 的 name name: auth# 該 deployment 運行的規格spec: # pod 數量 replicas: 1 # pod 樣板 template: # pod 的 metadata metadata: # label, 可被 selector 挑選, 為 key/value pair labels: app: auth track: stable # pod 運行規格 spec: # 定義容器 containers: # 容器名稱 - name: auth # 鏡像名稱 image: &quot;kelseyhightower/auth:1.0.0&quot; # 定義 port ports: # port 名稱 - name: http # port 號 containerPort: 80 # port 名稱 - name: health # port 號 containerPort: 81 以下的 Kubernetes yaml 設定檔的意思是？ yaml 檔apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: &quot;kelseyhightower/auth:2.0.0&quot; ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: &quot;10Mi&quot; livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer:# api 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# Deployment 的 metadatametadata: # Deployment 的 name name: auth# 該 Deployment 運行的規格spec: # 該 Deployment 共會啟動幾個 Pod replicas: 1 # 該 Pod 的詳細資料 template: # 該 Pod 的 metadata metadata: # 該 Pod 的 label, 可透過 selector 被選取 labels: # 自定義的 key/value pair app: auth track: stable # 該 Pod 的規格 spec: # 容器規格 containers: # 容器名稱 - name: auth # 鏡像名稱 image: &quot;kelseyhightower/auth:2.0.0&quot; # 該容器的 port 定義 ports: # port 名稱 - name: http # port 號 containerPort: 80 # port 名稱 - name: health # port 號 containerPort: 81 # 容器的資源定義 resources: # 限制 limits: cpu: 0.2 memory: &quot;10Mi&quot; # 存活探針 livenessProbe: # 探測類型 httpGet: # 探測路徑 path: /healthz # 探測 port 號 port: 81 scheme: HTTP # 首次執行探針時需要延遲的時間, 以確保容器內各項工作都已準備就緒, 如果一啟動就探測的話很可能會直接失敗 initialDelaySeconds: 5 # 每隔 15 秒探測一次 periodSeconds: 15 # 探測時, 如果超過幾秒沒回覆視為失敗 timeoutSeconds: 5 # 就緒探針, 如果尚未就緒, service 不會將流量導向該容器 readinessProbe: # 探測方式為 httpGet httpGet: # 探測 url path: /readiness # 探測 port 號 port: 81 # 使用 http 還是 https scheme: HTTP # 首次啟動 readinessProbe 時, 等待五秒 initialDelaySeconds: 5 # 若超過 1 秒沒有 response, 視為失敗 timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file:apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: frontendspec: replicas: 1 template: metadata: labels: app: frontend track: stable spec: containers: - name: nginx image: &quot;nginx:1.9.14&quot; lifecycle: preStop: exec: command: [&quot;/usr/sbin/nginx&quot;,&quot;-s&quot;,&quot;quit&quot;] volumeMounts: - name: &quot;nginx-frontend-conf&quot; mountPath: &quot;/etc/nginx/conf.d&quot; - name: &quot;tls-certs&quot; mountPath: &quot;/etc/tls&quot; volumes: - name: &quot;tls-certs&quot; secret: secretName: &quot;tls-certs&quot; - name: &quot;nginx-frontend-conf&quot; configMap: name: &quot;nginx-frontend-conf&quot; items: - key: &quot;frontend.conf&quot; path: &quot;frontend.conf&quot; Answer:# API 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# 該 Deployment metadatametadata: # 該 Deployment name 為 frontend name: frontend# 該 Deployment 運行規格spec: # 啟動 1 個 pod replicas: 1 # 該 pod 模板 template: # 該 pod metadata metadata: # label, 可被 selector 選擇 labels: app: frontend track: stable # 該 pod 運行規格 spec: # 定義容器 containers: # 容器名稱 - name: nginx # 鏡像名稱 image: &quot;nginx:1.9.14&quot; # 定義生命週期 lifecycle: # preStop hook preStop: # hook handler 為 exec exec: # 執行指令, 用意為在停止前優雅退出 nginx command: [&quot;/usr/sbin/nginx&quot;,&quot;-s&quot;,&quot;quit&quot;] # 掛載 volume volumeMounts: # 使用的 volume name - name: &quot;nginx-frontend-conf&quot; # 掛載於容器內的位置 mountPath: &quot;/etc/nginx/conf.d&quot; # 使用的 volume name - name: &quot;tls-certs&quot; # 掛載於容器內的位置 mountPath: &quot;/etc/tls&quot; # 定義容器 volumes: # 定義 volume name - name: &quot;tls-certs&quot; # volume 來源為 secret secret: # 使用的 secret name secretName: &quot;tls-certs&quot; # 定義 volume name - name: &quot;nginx-frontend-conf&quot; # volume 來源為 configMap configMap: # 使用的 configMap name name: &quot;nginx-frontend-conf&quot; # 指定該 configMap 內的 key items: # 取得 nginx-frontend-conf configMap 中的 frontend.conf 的 key - key: &quot;frontend.conf&quot; # 指定掛載後的位置 path: &quot;frontend.conf&quot; 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file:apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-canaryspec: replicas: 1 template: metadata: labels: app: hello track: canary version: 2.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: 10Mi livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer:# API 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# 該 Deployment metadatametadata: # 該 Deployment name name: hello-canary# 該 Deployment 運行規格spec: # 啟動一個 pod replicas: 1 # 該 Pod 範本 template: # 該 pod 的 metadata metadata: # 定義 labels labels: app: hello track: canary version: 2.0.0 # 該 pod 運行規格 spec: # 定義容器 containers: # 容器 name - name: hello # 使用鏡像 image: kelseyhightower/hello:2.0.0 # 定義 ports ports: # port name - name: http # 容器內的 port containerPort: 80 # port name - name: health # 容器內的 port containerPort: 81 # 定義資源限制 resources: # 定義 limits 類型資源限制 limits: cpu: 0.2 memory: 10Mi # 定義存活探針 livenessProbe: # 使用 httpGet 方式探測 httpGet: # 指定探測的 path path: /healthz # 指定探測的 port port: 81 # 指定探測的 scheme scheme: HTTP # 容器啟動後延遲五秒再開始探測 initialDelaySeconds: 5 # 每十五秒探測一次 periodSeconds: 15 # 超過五秒沒回應, 視為失敗 timeoutSeconds: 5 # 定義就緒探針 readinessProbe: # 使用 httpGet 方式探測 httpGet: # 指定探測的 path path: /readiness # 指定探測的 port port: 81 # 指定探測的 scheme scheme: HTTP # 容器啟動後延遲五秒再開始探測 initialDelaySeconds: 5 # 超過五秒沒回應, 視為失敗 timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file:apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-greenspec: replicas: 3 template: metadata: labels: app: hello track: stable version: 2.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: 10Mi livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer:# API versionapiVersion: extensions/v1beta1# The kind is Deploymentkind: Deployment# The metadata of the Deploymentmetadata: # The name of the Deployment name: hello-green# The specspec: # Desired number of pod is 3 replicas: 3 # the template of the pod template: # the metadata of the pod metadata: # labels, could be selected by selector labels: app: hello track: stable version: 2.0.0 # spec of the pod spec: # define containers containers: - name: hello image: kelseyhightower/hello:2.0.0 # define ports ports: - name: http containerPort: 80 - name: health containerPort: 81 # define constraint resources resources: limits: cpu: 0.2 memory: 10Mi # define liveness probe livenessProbe: # use httpGet probe httpGet: path: /healthz port: 81 scheme: HTTP # wait for 5 seconds after the container starts before starting to probe initialDelaySeconds: 5 # probe every 15 seconds periodSeconds: 15 # consider it fails if not get responses for 5 seconds timeoutSeconds: 5 # define readiness probe readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file:apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hellospec: replicas: 3 template: metadata: labels: app: hello track: stable version: 1.0.0 spec: containers: - name: hello image: &quot;kelseyhightower/hello:1.0.0&quot; ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: &quot;10Mi&quot; livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer:# API 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# the metadata of the deploymentmetadata: # define the deployment name name: hello# define the spec of the deploymentspec: # it will start 3 pods replicas: 3 # define the template of the pod template: # define the metadata of the pod metadata: # define teh labels, which could be selected by Selector labels: app: hello track: stable version: 1.0.0 # define the spec of the pod spec: # define containers containers: # define container name - name: hello # used image image: &quot;kelseyhightower/hello:1.0.0&quot; # define ports ports: # define port name - name: http # define port inside the container containerPort: 80 # define port name - name: health # define port inside the container containerPort: 81 # define resources resources: # define limits resources limits: cpu: 0.2 memory: &quot;10Mi&quot; # define liveness probe livenessProbe: # using httpGet probe httpGet: # define probe path path: /healthz # define probe port port: 81 # define probe scheme scheme: HTTP # the liveness probe will start to probe 5 seconds after the container starts initialDelaySeconds: 5 # probe every 15 seconds periodSeconds: 15 # if the probe doesn&#x27;t receive responses for 5 seconds, it&#x27;s considered failed timeoutSeconds: 5 # define readiness probe readinessProbe: # use httpGet probe httpGet: # specify probe path path: /readiness # specify probe port port: 81 # specify probe scheme scheme: HTTP # the readiness probe will start to probe 5 seconds after the container starts initialDelaySeconds: 5 # if the probe doesn&#x27;t receive responses for 5 seconds, it&#x27;s considered failed timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file:kind: ServiceapiVersion: v1metadata: name: &quot;auth&quot;spec: selector: app: &quot;auth&quot; ports: - protocol: &quot;TCP&quot; port: 80 targetPort: 80 Answer:# 種類為 Servicekind: Service# API 版本為 v1apiVersion: v1# 此 Service 的 metadatametadata: # 此 Service 的 name name: &quot;auth&quot;# 此 Service 的運行規格spec: # 可選擇指定 label, 並將流量導向這些 pod selector: app: &quot;auth&quot; # 定義 port ports: # 使用 TCP protocol - protocol: &quot;TCP&quot; # service 的 port 為 80 port: 80 # 目標對象的 port 為 80 targetPort: 80 請解釋以下的 kubernetes yaml file 中的每一條 directive yaml file:kind: ServiceapiVersion: v1metadata: name: &quot;monolith&quot;spec: selector: app: &quot;monolith&quot; secure: &quot;enabled&quot; ports: - protocol: &quot;TCP&quot; port: 443 targetPort: 443 nodePort: 31000 type: NodePort Answer:# 種類為 Servicekind: Service# API 版本為 v1apiVersion: v1# 該 service 的 metadatametadata: # 該 service name name: &quot;monolith&quot;# 該 service 運行規格spec: # 會將流量導向符合此 label 的 pod selector: app: &quot;monolith&quot; secure: &quot;enabled&quot; # 定義 ports ports: # protocol 為 TCP - protocol: &quot;TCP&quot; # service 的 port 為 443 port: 443 # 目標對象的 port 為 443 targetPort: 443 # 定義 node 的 31000 port 將流量導向 service 的 clusterIP nodePort: 31000 # 使用 NodePort type: NodePort 請解釋以下的 Kubernetes yaml file 中的每一條 directive yaml filekind: ServiceapiVersion: v1metadata: name: &quot;frontend&quot;spec: selector: app: &quot;frontend&quot; ports: - protocol: &quot;TCP&quot; port: 443 targetPort: 443 type: LoadBalancer Answer:# kind is servicekind: Service# api version is v1apiVersion: v1# the metadata of the serivicemetadata: # the name of the service name: &quot;frontend&quot;# the spec of the servicespec: # those selected by this selector will be the endpoint to which the traffic is redirected selector: # an arbitrary key / value pair app: &quot;frontend&quot; # define ports ports: # define the protocol - protocol: &quot;TCP&quot; # define service port port: 443 # define target endpoint&#x27; ports targetPort: 443 # this option is only for cloud provider type: LoadBalancer","link":"/zh-tw/managingDeploymentsUsingKubernetesEngine/"},{"title":"<未完成> 使用 Stackdriver 在 Kubernetes Engine 上實施監控","text":"概述Stackdriver Kubernetes Monitoring 是 Stackdriver 上個一個新功能, 它更緊密地與 GKE 整合, 可以更好的顯示你運行在 GKE 上的工作、服務的重要統計資訊。新功能也包含了匯入, 可以匯入我們用 Prometheus 在 pods 取得的 metrics(指標), 就像是原生 Stackdriver metrics 一樣。 這讓我們可以使用 Prometheus 的 metrics 來觸發 Stackdriver 原生的警告功能, 不需要額外的設定以及串接。 在這個教程中, 你將會在 Kubernetes Engine 叢集設定 Monitoring 以及具現象 metrics 。 你將會使用 Terraform, 它是一個宣告式的 Infrastructure as Code 工具, 它讓我們可以使用設定檔來自動化部署, 以及更新雲端基礎設施。 我們從 Kubernetes Engine 取得的 logs(紀錄) 將會被利用來演示 Stackdriver 的監控能力。 注意: Stackdriver Monitoring workspace 不會被 script 自動化, 因為現階段 Terraform 或 gcloud command line 工具都不支援 本教程由 GKE Helmsman 工程師創建來幫助你更理解 Kubernetes Engine 上使用 Stackdriver Monitoring, 你可以從 Github repo 檢視範例程式碼。我們歡迎你們一起貢獻這個專案。 架構本教程將會建立一個 Kubernetes Engine 叢集, 這個叢集會部署一個範例應用。 這個叢集的紀錄以及指標會預設被載入到 Stackdriver Logging, 在本教程中會自動設定一個 Stackdriver Monitoring 帳號以檢視被捕捉到的指標 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 **注意：** 按下左上方位於 `Google Cloud Platform` 隔壁的 `Navigation menu`, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 故障排除: 在 production 環境, 當你在運行 Teffaform 時如果出現 Permission denied 並且安裝腳本失敗, 那很有可能是因為 Terraform 使用的憑證沒有提供在該專案建立資源需要的權限。 務必確認 gcloud config list 指令列出的帳號有建立資源需要的權限。 如果有的話, 使用 gcloud auth applications-default login 來重新產生 application default 的憑證。 設定你的 region 和 zone某些 Compute Engine 的資源位於 regions 以及 zones 。 region 是一個特定的地理位置，你只能在這個執行 region 運行你的資源, 每一個 region 有一個或多個 zone 如果你想要了解更多有關 region 以及 zone, 可以參考官方文件 執行以下指令來設定本教程中的 region 以及 zone (你可以使用對你來說最佳的 region 跟 zone) gcloud config set compute/region us-central1gcloud config set compute/zone us-central1-a 複製範例執行以下指令來複製此教程需要的範例檔案 git clone https://github.com/GoogleCloudPlatform/gke-monitoring-tutorial.git 到範例資料夾內： cd gke-monitoring-tutorial 驗證設定Terraform 設置會執行你的 GCP 環境並建立一個運行著簡單應用的 Kubernetes Engine 叢集。 這個設置會使用你的私人帳號來建立資源。 執行以下指令選擇適合的帳戶, Terraform 設置預設使用的帳戶 gcloud auth application-default login 複製輸出的 URL, 貼到新的瀏覽器視窗選擇本教程的登入憑證, 並點擊 Allow複製提供的程式碼並貼到 Cloud Shell 視窗 建立 Stackdriver workspace要使用 Stackdriver, 你的專案必須在 Stackdriver 帳號內。 以下的步驟會建立一個帳號, 這個帳號可以試用 Stackdriver 在 Google Cloud Platform 主控台, 點擊 Navigation menu &gt; Monitoring, 使用本教程提供的憑證資訊登入。 點擊 NO THANKS!, 不使用 beta 版本的 Stackdriver Monitoring 當 Stackdriver 主控台開啟, 這代表此工作區已就緒。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Stackdriver 工作區, 你將獲得一個評價分數。 部署叢集","link":"/zh-tw/monitoringWithStackdriverOnKubernetesEngine/"},{"title":"MySQL - 官方文件原子化翻譯 - 目錄","text":"# 前言雖然會使用 MySQL, 使用上也沒啥太大問題, 但好像跟這個資料庫之間總是隔著一層說不清道不明的朦朧膜, 身為一個程式開發者, 自然要秉持著科學家的精神！ 在科學精神面前, 1 就是 1, 2 就是 2, 絕對不容許似是而非, 模糊不清, 曖昧不明, 友達以上而戀人未滿的奇怪關係！ 所以我決定好好的, 一頁頁的將文件看過並記錄下來, 務求破開朦朧, 群邪僻易, 光耀大地！好了我先去吃藥了, 我們下次見 # MySQL 8.0 Reference Manual# Character Sets, Collations, Unicode# Character Sets and Collations in General# Character Sets and Collations in MySQL## Character Set Repertoire## UTF-8 for Metadata# Specifying Character Sets and Collations## Collation Naming Conventions","link":"/zh-tw/mysql-documentation-table-of-contents/"},{"title":"GCP - 多個虛擬私人網路","text":"概述在本教程中, 你將建立幾個 VPC 網路 以及 VM instances, 並且測試這些網路間的連接。 更準確的說, 你將建立兩個客製化模式的網路 (management 以及 privatenet), 以及各自的防火牆規則跟 VM instances, 如下圖所示: mynetwork 網路以及它的防火牆規則跟 VM instances (mynet-eu-vm 以及 mynet-us-vm) 在本教程的專案中已經被建立了 目標在本教程中, 你將會學習到如何完成以下任務 建立一個客製化模式的 VPC 網路以及它的防火牆規則 使用 Compute Engine 建立 VM instances 在不同的 VPC 網路間, 探索 VM instances 之間的連接 使用多重網路介面建立 VM instance 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立客製化模式的 VPC 網路以及防火牆規則建立兩個客製網路 managementnet 以及 privatenet, 以及防火牆規則允許 SSH, ICMP, 以及 RDP 流量進入 建立 managementnet 網路使用 GCP Console 建立 managementnet 網路 在 Console 內, 到 Navigation menu &gt; VPC network &gt; VPC networks 注意到 default 以及 mynetwork 網路以及它們的子網路每一個 GCP 專案都會有一個 default 網路。 另外, mynetwork 網路已經被事先建立, 如同上面的網路圖表呈現。 點擊 Create VPC Network 將 Name 設為 managementnet Subnet creation mode, 點擊 Custom 做如下設定, 其餘留為預設 點擊 Done 點擊 command line 這些指令顯示網路以及子網路是可以使用 Cloud Shell 指令來建立的。 你將使用這些指令以及類似的參數來建立與設定 privatenet 網路 點擊 Close 點擊 Create 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 managementnet 網路, 你將獲得一個評價分數。 建立 privatenet 網路使用 Cloud Shell 指令來建立 privatenet 網路: 執行以下指令來建立 privatenet 網路 gcloud compute networks create privatenet --subnet-mode=custom 執行以下指令來建立 privatesubnet-us 子網路: gcloud compute networks subnets create privatesubnet-us --network=privatenet --region=us-central1 --range=172.16.0.0/24 執行以下指令來建立 privatesubnet-eu 子網路 gcloud compute networks subnets create privatesubnet-eu --network=privatenet --region=europe-west1 --range=172.20.0.0/20 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 privatenet 網路, 你將獲得一個評價分數。 執行以下指令來列出可用的 VPC 網路:gcloud compute networks list 輸出類似如下 (不要複製; 這個只是範例輸出): NAME SUBNET_MODE BGP_ROUTING_MODE IPV4_RANGE GATEWAY_IPV4default AUTO REGIONALmanagementnet CUSTOM REGIONALmynetwork AUTO REGIONALprivatenet CUSTOM REGIONAL default 以及 mynetwork 屬於自動模式的網路, 而 managementnet 以及 privatenet 屬於客製化模式網路。 自動模式網路會自動地在某一個 region 建立子網路, 而客製化模式剛建立時是沒有子網路的, 你有著子網路建立的所有控制權 執行以下指令來列出可用的 VPC 子網路(由 VPC 網路分類)gcloud compute networks subnets list --sort-by=NETWORK 輸出類似如下 (不要複製; 這個只是範例輸出): NAME REGION NETWORK RANGEdefault asia-northeast1 default 10.146.0.0/20default us-west1 default 10.138.0.0/20default southamerica-east1 default 10.158.0.0/20default europe-west4 default 10.164.0.0/20default asia-east1 default 10.140.0.0/20default europe-north1 default 10.166.0.0/20default asia-southeast1 default 10.148.0.0/20default us-east4 default 10.150.0.0/20default europe-west1 default 10.132.0.0/20default europe-west2 default 10.154.0.0/20default europe-west3 default 10.156.0.0/20default australia-southeast1 default 10.152.0.0/20default asia-south1 default 10.160.0.0/20default us-east1 default 10.142.0.0/20default us-central1 default 10.128.0.0/20default northamerica-northeast1 default 10.162.0.0/20managementsubnet-us us-central1 managementnet 10.130.0.0/20mynetwork asia-northeast1 mynetwork 10.146.0.0/20mynetwork us-west1 mynetwork 10.138.0.0/20mynetwork southamerica-east1 mynetwork 10.158.0.0/20mynetwork europe-west4 mynetwork 10.164.0.0/20mynetwork asia-east1 mynetwork 10.140.0.0/20mynetwork europe-north1 mynetwork 10.166.0.0/20mynetwork asia-southeast1 mynetwork 10.148.0.0/20mynetwork us-east4 mynetwork 10.150.0.0/20mynetwork europe-west1 mynetwork 10.132.0.0/20mynetwork europe-west2 mynetwork 10.154.0.0/20mynetwork europe-west3 mynetwork 10.156.0.0/20mynetwork australia-southeast1 mynetwork 10.152.0.0/20mynetwork asia-south1 mynetwork 10.160.0.0/20mynetwork us-east1 mynetwork 10.142.0.0/20mynetwork us-central1 mynetwork 10.128.0.0/20mynetwork northamerica-northeast1 mynetwork 10.162.0.0/20privatesubnet-eu europe-west1 privatenet 172.20.0.0/20privatesubnet-us us-central1 privatenet 172.16.0.0/24 如預期般, default 以及 mynetwork 網路在 每一個 region 都有各自的子網路, 因為它們是屬於自動模式網路。 managementnet 以及 priavtenet 網路唯有當你有建立時, 它們才會有子網路, 因為它們是屬於客製化模式網路。 在控制台, 到 Navigation menu &gt; VPC network &gt; VPC networks 你可以看到一樣的網路以及子網路被列在控制台中 建立 managementnet 的防火牆規則建立防火牆規則來允許 SSH, ICMP, 以及 RDP 流量進入到 managementnet 網路中的 VM instances 在控制台, 到 Navigation menu &gt; VPC network &gt; Firewall rules 點擊 + Create Firewall Rule 做如下設定, 其餘留為預設 請務必確認 Source IP ranges 後面有包含 /0 已指定所有網路 點擊 command line這些指令顯示防火牆規則是可以使用 Cloud Shell 指令來建立的。 你將使用這些指令以及類似的參數來建立與設定 privatenet 的防火牆規則 點擊 Close 點擊 Create 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 managementnet 的防火牆規則, 你將獲得一個評價分數。 建立 privatenet 的防火牆規則使用 Cloud Shell 指令來建立 privatenet 網路的防火牆規則 在 Cloud Shell 中, 執行以下指令來建立 privatenet-allow-icmp-ssh-rdp 防火牆規則gcloud compute firewall-rules create privatenet-allow-icmp-ssh-rdp --direction=INGRESS --priority=1000 --network=privatenet --action=ALLOW --rules=icmp,tcp:22,tcp:3389 --source-ranges=0.0.0.0/0 輸出類似如下 (不要複製; 這個只是範例輸出): NAME NETWORK DIRECTION PRIORITY ALLOW DENYprivatenet-allow-icmp-ssh-rdp privatenet INGRESS 1000 icmp,tcp:22,tcp:3389 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 privatenet 網路的防火牆規則, 你將獲得一個評價分數。 執行以下指令來列出所有的防火牆規則 (依 VPC 網路分類)gcloud compute firewall-rules list --sort-by=NETWORK 輸出類似如下 (不要複製; 這個只是範例輸出): NAME NETWORK DIRECTION PRIORITY ALLOW DENYdefault-allow-icmp default INGRESS 65534 icmpdefault-allow-internal default INGRESS 65534 tcp:0-65535,udp:0-65535,icmpdefault-allow-rdp default INGRESS 65534 tcp:3389default-allow-ssh default INGRESS 65534 tcp:22managementnet-allow-icmp-ssh-rdp managementnet INGRESS 1000 icmp,tcp:22,tcp:3389mynetwork-allow-icmp mynetwork INGRESS 1000 icmpmynetwork-allow-rdp mynetwork INGRESS 1000 tcp:3389mynetwork-allow-ssh mynetwork INGRESS 1000 tcp:22privatenet-allow-icmp-ssh-rdp privatenet INGRESS 1000 icmp,tcp:22,tcp:3389 mynetwork 的防火牆規則已經被建立好了。 你可以在一個防火牆規則中定義多個協定以及 port (privatenet 以及 managementnet), 或是分別用多條規則來定義 (default 以及 mynetwork) 在主控台中, 到 Navigation menu &gt; VPC network &gt; Firewall rules 你可以看到同樣的防火牆規則被列在主控台 建立 VM instances建立兩個 VM instances: 在 managementsubnet-us 中, managementnet-us-vm 在 privatesubnet-us 中, privatenet-us-vm 建立 management-us-vm instance使用 GCP 主控台來建立 management-us-vm instance 在主控台中, 到 Navigation menu &gt; Compute Engine &gt; VM instances如同上面的圖表顯示的一樣, mynet-eu-vm 以及 mynet-us-vm 已經被建立好了 點擊 Create instance 做如下設定, 其餘留為預設 點擊 Management, disks, networking, SSH keys 點擊 Networking 點擊鉛筆的圖案來編輯 Network interfaces 做如下設定, 其餘留為預設 點擊 Done 點擊 command line這些指令顯示 VM instances 是可以使用 Cloud Shell 指令來建立的。 你將使用這些指令以及類似的參數來建立與設定 privatenet-us-vm 的防火牆規則 gcloud beta compute --project=qwiklabs-gcp-03-2779af1ddf93 instances create managementnet-us-vm --zone=us-central1-c --machine-type=f1-micro --subnet=managementsubnet-us --network-tier=PREMIUM --maintenance-policy=MIGRATE --service-account=357292195316-compute@developer.gserviceaccount.com --scopes=https://www.googleapis.com/auth/devstorage.read_only,https://www.googleapis.com/auth/logging.write,https://www.googleapis.com/auth/monitoring.write,https://www.googleapis.com/auth/servicecontrol,https://www.googleapis.com/auth/service.management.readonly,https://www.googleapis.com/auth/trace.append --image=debian-9-stretch-v20200210 --image-project=debian-cloud --boot-disk-size=10GB --boot-disk-type=pd-standard --boot-disk-device-name=managementnet-us-vm --reservation-affinity=any 點擊 Close 點擊 Create 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功在 managementnet 網路建立 VM instance, 你將獲得一個評價分數。 建立 privatenet-us-vm instance使用 Cloud Shell 指令來建立 privatenet-us-vm instance 在 Cloud Shell 中, 執行以下指令來建立 privatenet-us-vm instancegcloud compute instances create privatenet-us-vm --zone=us-central1-c --machine-type=n1-standard-1 --subnet=privatesubnet-us 輸出類似如下 (不要複製; 這個只是範例輸出): NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSprivatenet-us-vm us-central1-c n1-standard-1 172.16.0.2 35.184.221.40 RUNNING 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功在 privatenet 網路建立 VM instance, 你將獲得一個評價分數。 執行以下指令來列出所有的 VM instances (依 zone 分類)gcloud compute instances list --sort-by=zone 輸出類似如下 (不要複製; 這個只是範例輸出): NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSmynet-eu-vm europe-west1-c n1-standard-1 10.132.0.2 35.205.124.164 RUNNINGmanagementnet-us-vm us-central1-c n1-standard-1 10.130.0.2 35.226.20.87 RUNNINGmynet-us-vm us-central1-c n1-standard-1 10.128.0.2 35.232.252.86 RUNNINGprivatenet-us-vm us-central1-c n1-standard-1 172.16.0.2 35.184.221.40 RUNNING 在主控台, 到 Navigation menu &gt; Compute Engine &gt; VM instance 你可以看到 VM instances 被列在主控台 點擊 Columns, 然後選擇 Network可以看到在 us-central-c 有 3 台 instances, 而在 europe-west1-c 有 1 台 instance 。 然而, 這些 instances 橫跨了三個 VPC 網路 (managementnet, mynetwork 以及 privatenet), 沒有任何一台 instance 是同一個 zone 又同一個網路的。 在下一節中, 你將探索這在內部連線中的影響。 探索不同 VM instances 之間的連線探索不同 VM instances 之間的連線。 更準確的說, 確定當 VM instances 在同一個 zone 的影響, 以及當他們在同一個 VPC 網路的影響 Ping 外部 IP 位址藉由 ping VM instances 的外部 IP 位址來確定它們是否可以在公開網路被觸及到。 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 檢視 mynet-eu-vm, managementnet-us-vm, 以及 privatenet-us-vm 的外部 IP 位址 點擊 mynet-us-vm 的 SSH 來啟動一個終端機連線 執行以下指令, 將 mynet-eu-vm 替換成外部 IP, 藉此測試 mynet-eu-vm 的外部 IP 連線ping -c 3 &lt;Enter mynet-eu-vm&#x27;s external IP here&gt; 這應該要可以通過 執行以下指令, 將 managementnet-us-vm 替換成外部 IP, 藉此測試 managementnet-us-vm 的外部 IP 連線ping -c 3 &lt;Enter managementnet-us-vm&#x27;s external IP here&gt; 這應該也要可以通過 執行以下指令, 將 privatenet-us-vm 替換成外部 IP, 藉此測試 privatenet-us-vm 的外部 IP 連線ping -c 3 &lt;Enter privatenet-us-vm&#x27;s external IP here&gt; 這應該也要可以通過 你可以通過 VM instances 的外部 IP 位址來 ping 到機器, 儘管他們處於不同的 zone 或是 VPC 網路。 這確認了一件事, 那就是公開網路存取只會由早先建立的 ICMP 防火牆規則所控制 Ping 內部 IP 位址透過 ping VM instances 的內部 IP 位址來確定在同一個 VPC 網路中的 instances 是否可以互相觸及對方 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 檢視 mynet-eu-vm, managementnet-us-vm, 以及 privatenet-us-vm 的內部 IP 位址 點擊 mynet-us-vm 的 SSH 來啟動一個終端機連線 執行以下指令, 將 mynet-eu-vm 替換成內部 IP, 藉此測試 mynet-eu-vm 的內部 IP 連線 ping -c 3 &lt;Enter mynet-eu-vm&#x27;s internal IP here&gt; 你可以經由 mynet-eu-vm 的內部 IP 位址 ping 到它, 因為它與 ping 的來源機器 (mynet-us-vm) 處於同一個 VPC 網路, 儘管兩台 VM instances 在不同的 zones, regions, 以及 continents 執行以下指令, 將 managementnet-us-vm 替換成內部 IP, 藉此測試 managementnet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter managementnet-us-vm&#x27;s external IP here&gt; 這應該不能通過, 如同資料顯示, 封包 100% 遺失 執行以下指令, 將 privatenet-us-vm 替換成內部 IP, 藉此測試 privatenet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter privatenet-us-vm&#x27;s external IP here&gt; 這應該也無法通過, 如同回饋顯示, 封包 100% 丟失了！ 你無法經由 managementnet-us-vm 以及 privatenet-us-vm 的內部 IP 位址來 ping 到對方, 因為它們與來源機器 (mynet-us-vm) 的 VPC 網路不同, 儘管他們都處於同一個 zone us-central1 VPC 網路預設上是獨立的私人網路 domains 。 然而, 除非你有設定一些機制, 像是 VPC peering 或是 VPN, 否則, 網路之間是不允許內部 IP 位址來互相通信的。 建立有著多重網路介面的 VM instances每一台 VPC 網路內的 instance 都會有一個預設的網路介面。 你可以建立額外的網路介面, 然後附加到你的 VM 上。 多重網路介面可以讓你建立一個設定, 這個設定可以讓一台 instance 直接的連接到多個 VPC 網路 (最多八台 instances, 取決於 instance 的類型) 建立有著多重網路介面的 VM instances建立一台名為 vm-appliance 的 instance, 這台 instance 會在 privatesubnet-us, managementsubnet-us, 以及 mynetwork 這些網路介面中。 這些子網路的 CIDR 範圍不可互相重疊, 這是建立一台有著多重網路介面控制器 (NICs) 的 VM 的要求之一。 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instance 點擊 Create instance 做如下設定, 其餘留為預設 一台機器允許的介面數量取決於機器類型以及 VCPUs 的數量。 n1-standard-4 允許最多 4 個網路介面。 更多資訊可以參考這裏 點擊 Management, disks, networking, SSH keys 點擊 Networking 點擊鉛筆圖案編輯 Network interfaces 做如下設定, 其餘留為預設 點擊 Done 點擊 Add network interface 做如下設定, 其餘留為預設 點擊 Done 點擊 Add network interface 做如下設定, 其餘留為預設 點擊 Done 點擊 Create 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立多網路介面的 VM, 你將獲得一個評價分數。 探索多網路介面細節在主控台以及 VM’s 終端機探索 vm-appliance 的多網路介面細節 在主控台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 點擊 vm-appliance 的 Internal IP 的 nic0 來打開 Network interface details 頁面 確認 nic0 有被附加到 privatesubnet-us, 在子網路 (172.16.0.0/24) 中有被分配一組內部 IP, 以及已有生效的防火牆規則 點擊 nic0, 選擇 nic1 確認 nic1 有被附加到 managementsubnet-us, 在子網路 (10.130.0.0/20) 中有被分配一組內部 IP, 以及已有生效的防火牆規則 點擊 nic1, 選擇 nic2 確認 nic2 有被附加到 mynetwork, 在子網路 (10.128.0.0/20) 中有被分配一組內部 IP, 以及已有生效的防火牆規則每一個網路介面有它們自己的內部 IP 位址, 所以 VM instance 可以與他們溝通 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 點擊 SSH 啟動 vm-appliance 的終端連線 執行以下指令來列出 VM instance 的網路介面 sudo ifconfig 輸出類似如下 (不要複製; 這個只是範例輸出): eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 172.16.0.3 netmask 255.255.255.255 broadcast 172.16.0.3 inet6 fe80::4001:acff:fe10:3 prefixlen 64 scopeid 0x20&lt;link&gt; ether 42:01:ac:10:00:03 txqueuelen 1000 (Ethernet) RX packets 626 bytes 171556 (167.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 568 bytes 62294 (60.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 10.130.0.3 netmask 255.255.255.255 broadcast 10.130.0.3 inet6 fe80::4001:aff:fe82:3 prefixlen 64 scopeid 0x20&lt;link&gt; ether 42:01:0a:82:00:03 txqueuelen 1000 (Ethernet) RX packets 7 bytes 1222 (1.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 17 bytes 1842 (1.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth2: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 10.128.0.3 netmask 255.255.255.255 broadcast 10.128.0.3 inet6 fe80::4001:aff:fe80:3 prefixlen 64 scopeid 0x20&lt;link&gt; ether 42:01:0a:80:00:03 txqueuelen 1000 (Ethernet) RX packets 17 bytes 2014 (1.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 17 bytes 1862 (1.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 sudo ifconfig 這個指令列出了 Linux VM 的網路介面以及這些介面的內部 IP 探索網路介面的連線我們可以藉由 ping 這些子網路來演示一下 vm-appliance 是與 privatesubnet-us, managementsubnet-us 以及 mynetwork 互相連接的 在主控台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 注意一下 privatenet-us-vm, managementnet-us-vm, mynet-us-vm, 以及 my-eu-vm 的內部 IP 位址 回到 vm-appliance 的 SSH 終端機 執行以下指令, 將 privatenet-us-vm 替換成內部 IP, 藉此測試 privatenet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter privatenet-us-vm&#x27;s internal IP here&gt; 這是可以連到的！ 重複以上步驟, 執行以下指令ping -c 3 privatenet-us-vm 你可以 ping 到 privatenet-us-vm 的 name, 因為 VPC 網路有內部 DNS 服務, 這個服務讓我們可以透過 DNS name 來連接到機器, 而不用透過 IP 位址。 執行以下指令, 將 managementnet-us-vm 替換成內部 IP, 藉此測試 managementnet-us-vm 的內部 IP 連線 ping -c 3 &lt;Enter managementnet-us-vm&#x27;s internal IP here&gt; 這是可以連到的！ 執行以下指令, 將 mynet-us-vm 替換成內部 IP, 藉此測試 mynet-us-vm 的內部 IP 連線 ping -c 3 &lt;Enter mynet-us-vm&#x27;s internal IP here&gt; 這是可以連到的！ 執行以下指令, 將 mynet-eu-vm 替換成內部 IP, 藉此測試 mynet-eu-vm 的內部 IP 連線 ping -c 3 &lt;Enter mynet-eu-vm&#x27;s internal IP here&gt; 這個無法連到！ 再多網路介面 instance 中, 每一個介面都會有一個可以連到它們所在的子網路的路由。 再者, instance 只會有一個預設路由, 這個路由與主要介面 eth0 相關聯。 除非手動設置, 否則任何離開這個 instance 的流量, 不管目的地是哪, 只要不是透過直接連接的子網路, 都將經由這個預設的路由離開。 執行以下指令來列出 vm-appliance 的所有路由ip route 輸出類似如下 (不要複製; 這個只是範例輸出): default via 172.16.0.1 dev eth010.128.0.0/20 via 10.128.0.1 dev eth210.128.0.1 dev eth2 scope link10.130.0.0/20 via 10.130.0.1 dev eth110.130.0.1 dev eth1 scope link172.16.0.0/24 via 172.16.0.1 dev eth0172.16.0.1 dev eth0 scope link 主要介面 etho 有其預設路由 (預設經由 172.16.0.1 dev eth0), 以及所有三個介面 eth0, eth1, eth2 都有通往其各自子網路的路由。 因為 **mynet-eu-vm (10.132.0.0/20) 的子網路並沒有被包含在這台 instance 的路由表中, 當我們 ping 這台機器時, 請求會離開 eth0 的 vm-appliance (這是在一個不同的 VPC 網路)。 你可以設置政策路由來變更這個行為, 可參考文件 恭喜你已經完成本教程！ Questions And Answers 解釋以下 GCP command command:gcloud compute networks create privatenet --subnet-mode=custom Answer: 建立一個 GCP network 子網路的模式為, custom 解釋以下 GCP command command:gcloud compute network subnets create privatesubnet-eu --network=privatenet --region=europe-west1 --range=172.20.0.0/20 Answer: 建立一個 GCP 子網路 上層網路的名稱為 privatenet 地區為 europe-west1 確切網域範圍為 172.20.0.0/20 解釋以下 GCP command command:gcloud compute networks list Answer:列出所有網路, 不包含子網路 解釋以下 GCP command command:gcloud compute networks create privatenet --subnet-mode=custom Answer: 建立一個 GCP network 子網路的模式為, custom 以下的 GCP Command 中, –subnet-mode 預設為 auto 還是 custom? Example:gcloud compute networks create privatenet --subnet-mode=custom Answer:auto 解釋以下 GCP command Command:gcloud compute networks subnets list --sort-by=NETWORK Answer: 列出所有 subnets 以 network 排列 解釋以下 GCP command Command:gcloud compute firewall-rules create privatenet-allow-icmp-ssh-rdp --direction=INGRESS --priority=1000 --network=privatenet --action=ALLOW --rules=icmp,tcp:22,tcp:3389 --source-ranges=0.0.0.0/0 Answer: 建立一個 firewall-rules 名稱為 *privatenet-allow-icmp-ssh-rdp 方向為 INGRESS, 即外到內 –priority 為優先性, 數字介於 0 ~ 65535, 數字越小優先性越高 –action 為 ALLOW, 也可設為 DENY –rules 為規則, 可設定多種協議 –source-ranges 為此 rule 作用到的來源 IP 範圍, 預設為 0.0.0.0/0, 即全部 解釋以下 GCP command Command:gcloud compute firewall-rules list --sort-by=NETWORK Answer: 列出所有的 firewall-rules 以 NETWORK 排 解釋以下 GCP command Command:gcloud compute instances create privatenet-us-vm \\--zone=us-central1-c \\--machine-type=n1-standard-1 \\--subnet=privatesubnet-us Answer: 建立一台 vm, 名為 privatenet-us-vm 將該 vm 掛在 privatesubnet-us 這個子網路下 解釋以下 GCP command Command:gcloud compute instances list --sort-by=zone Answer: 列出所有 instances 以 zone 排列 假如我有三台 VM, 分別位於不同的子網路下, 在不考慮防火牆的因素下, 我可以經由各自的 External IP ping 到對方嗎？可以 假如我有兩台 VM, 分別位於 GCP 不同的子網路, 但相同的 network 下, region 跟 zone 都不同的情況下, 在不考慮防火牆的因素下, 我可以經由各自的 Internal IP ping 到對方嗎？可以 GCP VM Instances 當中, NIC 的上限是多少？8 個 GCP VM Instances 當中, 如果 vCPU 的數量不超過 2, 則 NIC 的數量限制為多少？2 個 GCP VM Instances 當中, 如果 vCPU 的數量超過 2, 則每多一個 CPU, 可以提高幾個 NIC 上限？1 個","link":"/zh-tw/multipleVPCNetworks/"},{"title":"Netdata 學習筆記","text":"前言這是一份未整理過的 Netdata 學習筆記內容參考出處：官方文件 Configuration (設定檔)檔案位置: /etc/netdata/netdata.conf backend[backend] enabled = yes | no type = graphite | opentsdb:telnet | opentsdb:http | opentsdb:https | prometheus_remote_write | json | kinesis | mongodb host tags = list of TAG=VALUE destination = space separated list of [PROTOCOL:]HOST[:PORT] - the first working will be used, or a region for kinesis data source = average | sum | as collected prefix = Netdata hostname = my-name update every = 10 buffer on failures = 10 timeout ms = 20000 send charts matching = * send hosts matching = localhost * send names instead of ids = yes enabled = yes | no, 開啟或關閉後端 type = graphite | opentsdb:telnet | opentsdb:http | opentsdb:https | json | kinesis | mongodb, 選擇後端類型 destination = host1 host2 host3 ..., 接受一個空白來分開多個欲連接的 hostnames, IPs (IPv4 以及 IPv6), 以及 port 號。 Netdata 會使用第一個可用目的地來傳送指標。 每個品項的格式 [PROTOCOL:]IP[:PORT] PROTOCOL 可以是 udp 或 tcp, 預設為 tcp 且只被目前的後端支援。 IP 可以是 XX.XX.XX.XX (IPv4), 或 [XX:XX…XX:XX] (IPv6). IPv6 的話你可以將 IP 包在 [] 內來與 port 分開。 PORT 可以是服務名稱的號碼。 如果沒填, 後端預設的 PORT 將會被使用 (graphite = 2003, opentsdb = 4242) IPv4 範例： destination = 10.11.14.2:4242 10.11.14.3:4242 10.11.14.4:4242 IPv4 以及 IPv6 範例： destination = [ffff:...:0001]:2003 10.11.12.1:2003 當多個 server 被定義, 第一個失敗時, Netdata 將會自動嘗試下一個。 這讓我們可以平衡負載不同的 server: 在每一個 Netdata 給予不同的後端服務順序 Netdata 也提供了 nc-backend.sh, 一個備用解決方法來將指標先存到硬碟中, 待 time-series 資料庫可用了, 再將資料傳到資料庫。 它也可用來監控 / 追蹤 / 除錯 Netadata 產生的指標。 如果是 kinesis 後端目的地, 應該要被設定成 AWS region (例如, us-east-1) MongoDB 後端在這設定中不使用 destination 選項, 它使用 mongodb.conf 設定 data source = as collected, 或 data source = average, 或 data source = sum, 選擇要被傳送到後端的資料類型 as-collected: 當指標被採集時, 傳送到後端, 以他們被採集時的單位。 所以說， counter 將會以 counter 傳送, gauge 也被以 gauge 傳送, 就像所有的資料採集器那樣。 例如說, 若要算出在這格式下的 CPU 使用率，你需要知道怎麼轉換 kernel ticks 到百分比 average: 將正規化之後的指標從 Netdata 資料庫傳送到後端。 在這個模式下，所有的指標都被以 gauges 傳送，並且使用 Netdata 使用的單位。 這抽象化了資料收集以及簡單化了視覺顯示，但你將沒有辦法從其他來源複製貼上 query 來轉換單位。 例如， CPU 使用百分比是被 Netdata 計算，所以 Netdata 將會轉換 ticks 到百分比，然後傳送平均百分比到後端 sum or volume: Netdata 圖表上的總合將會被傳送到後端。 所以，如果 Netdata 被設定為每 10 秒傳送資料一次，那 10 秒的總合將會被傳送。 Time-series 資料庫建議以原始數值的方式收集資料 (as-collected)。 如果你打算建立你自己的監控系統搭配 time-series 資料庫，且你已經（或你將會花時間學習）知道如何轉換單位以及正規化資料已符合 Grafana 或其他視覺化工具，我們建議使用 as-collected 如果，另一方面，你只是需要長期的 Netdata 資料歸檔，並且妳主要打算使用 Netdata, 我們建議使用 average。 它將視覺化以及資料收集分離，所以整體來說它會簡單很多。 再進一步來說，如果你使用 average, 在後端看到的圖表將會完全符合你在 Netdata 看到的，如果是在別種模式的話，可能不是這樣。 利用 InfluxDB 作為 Netdata backendNetdata安裝bash &lt;(curl -Ss https://my-netdata.io/kickstart.sh) --dont-wait Config 開啟設定檔 vim /etc/netdata/netdata.conf 設定 [backend] # host tags = enabled = yes data source = average type = opentsdb destination = localhost:4242 # prefix = netdata # hostname = netdata update every = 10 # buffer on failures = 10 # timeout ms = 20000 # send names instead of ids = yes # send charts matching = * # send hosts matching = localhost * 重新啟動 systemctl restart netdata InfluxDB安裝參考官方流程 開啟設定檔vim /etc/influxdb/influxdb.conf 設定[[opentsdb]] enabled = true bind-address = &quot;localhost:4242&quot; database = &quot;opentsdb&quot;","link":"/zh-tw/netdata/"},{"title":"NGINX 學習筆記","text":"前言這是我的 NGINX 學習筆記，看什麼學什麼記什麼！ 安裝sudo apt-get install nginx 建立新的設定檔vim /etc/nginx/sites-available/configName server &#123;listen 80;server_name yourServerName;access_log /locationYouPrefer;listen 443 ssl;ssl_certificate /location/fullchain.pem;ssl_certificate_key /location/privkey.pem; location /upstream &#123;proxy_set_header Host www.tu8686.com;set $upstream_url 210.209.13.49:80;proxy_pass http://$upstream_url;add_header Q-Status $upstream_cache_status;break;&#125;location / &#123;proxy_pass_header Server;proxy_redirect off;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Scheme $scheme;proxy_pass http://127.0.0.1:50005; &#125;&#125; proxy_pass_header: 若回應 request 時, header 有設定了, 那告訴 NGINX 不要更改設定的 header, 若要加 header 需使用 via, 例如 範例圖片 server_name: request 的 header 中的 server 需符合 access_log: log 的位置 location: 符合 server 後, 改搜尋相對應的 location proxy_redirect: 重新導向 proxy_set_header: 設定 header 值 proxy_pass: 將 request 導向指定的位置 proxy_set_header: set host set $upstream_url: set $upstream_url add_header: add header break: 終止目前的 rewrite 規則。 如果有規則是被指定在目前的 location 內的，繼續將此 location 的 request 處理完畢。 啟用設定檔複製到 enabled 資料夾ln -s /etc/nginx/sites-available/yourConfig /etc/nginx/sites-enabled 啟用systemctl restart nginx.service location參考官方文件 語法Syntax: location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;location @name &#123; ... &#125;Default: —Context: server, location 規則搜尋分為以下兩種方式 正則搜尋 (regular expression) ~*: 不區分大小寫 ~: 區分大小寫 前綴字串 (prefix string) 規則搜尋順序：使用前綴字串搜尋 &rarr; 搜尋到符合最長的 url, 並且記下結果 &rarr; 依照設定檔中的順序， 使用正則規則搜尋 &rarr; 如果正則規則有搜尋到符合的，會立即停止搜尋，因此正則順序至關重要 &rarr; 如果正則沒有搜尋到符合的，會採用使用前綴字串搜尋到的 在一些不區分大小寫的系統中，像是 macOS 或是 Cygwin, 前綴字串規則會無視大小寫 正則規則可以捕捉一些變數，在其他的規則中使用 如果最長的前綴字串規則有 ^~, 那就不會再使用正則規則搜尋 前綴規則有 =, 代表字串須完全符合，如果有找到，搜尋終止。 例如，如果 “/“ 請求很頻繁，那麼可以定義 “location = /“, 這樣可以加速請求處理 在版本 0.7.1 到 0.8.41 中，如果請求符合前綴規則，就算沒有加上 =, 或者 ^~, 搜尋也會立即停止 範例location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; 請求 / 將會符合 A 請求 /index.html 將會符合 B 請求 /documents/document.html 將會符合 C 請求 /images/1.gif 將會符合 D 請求 /documents/1.jpg 將會符合 E 請求 @name: 只用於內部重新導向，不用於正常使用, 例如：location /img/ &#123; not_found 404 @not_found; &#125; location @not_found &#123; # 规则 &#125; alias 與 rootalias參考文件定義特定 location 的替換。 舉例來說, 看看下面的設定 location /i/ &#123; alias /data/w3/images/;&#125; 如果請求是 /i/top.git 的話, 檔案 /data/w3/images/top.git 將會被送出 路徑可以包含變數, 除了 $document_root 以及 $realpath_root 之外 如果 alias 被使用在正則定義的 location 之內, 那 alias 必須要參考正則捕捉到的條件, 範例如下： location ~ ^/users/(.+\\.(?:gif|jpe?g|png))$ &#123; alias /data/w3/images/$1;&#125; 當 location 的值跟 alias 的最後一個資料夾的值相同, 像下面這樣： location /images/ &#123; alias /data/w3/images/;&#125; 那會建議使用 root location /images/ &#123; root /data/w3;&#125; root參考文件設定 root 的資料夾位置為請求路徑, 例如以下範例： location /i/ &#123; root /data/w3;&#125; /data/w3/i/top.git 檔案將會被送出, 以回應 /i/top.git 請求 路徑可以包含變數, 除了 $document_root 以及 $realpath_root 之外 總結 alias 會取代 location 成為新的請求資源路徑 root + location 的值 = 請求資源路徑 部署 vue 專案Buildnpm run build, 看 script 怎麼寫, 這邊只管部署 configserver &#123; # Listen port 號 listen 8080; # Server name server_name localhost; # Log 位置 access_log logs/host.access.log; # root 位置, 可以參考上面的 root 詳解 root /Users/rainy/Desktop/MyWork/Work/website/dist; # 預設檔案 index index.html index.htm; location / &#123; # try to find $uri, and then $uri/, and if they both are not found, go for @router try_files $uri $uri/ @router; # If the path is found, go for index file below index index.html index.htm; &#125; location @router &#123; # rewite whatever to /index.html # 不管 request 是什麼, 都 rewrite 到 /index.html, 並且執行 last, last 代表說, 結束這一次的 rewrite 規則, 並且使用 rewrite 後的結果重新對 server 發一次請求 rewrite ^.*$ /index.html last; &#125;&#125; upstream語法Syntax: upstream name &#123; ... &#125;Default: —Context: http 範例upstream backend &#123; server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; server backup1.example.com backup;&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; 詳解定義多個 server, server 可以 listen 不同的 port 號, TCP 以及 UNIX-domain socket 可以混用預設的話, 會採用權重輪詢分配請求到不同的 server, 以上面的範例來看, 每 7 個 request 中, 5 個會被分配到 backend1.example.com (weight=5), 2 個分別到 127.0.0.1:8080 以及 unix:/tmp/backend3如果在溝通途中有錯誤, 請求會被分派到下一個 server, 直到出現成功回應的 server 。 如果裡面都沒有可以成功回應的, 那客戶端會收到最後一個 server 的回應 (backup) PHP-FPMfast 請求網址為 http://lemp.test/test.php/foo/bar.php?v=1 各項資訊如下:array ( &#x27;USER&#x27; =&gt; &#x27;www-data&#x27;, &#x27;HOME&#x27; =&gt; &#x27;/var/www&#x27;, &#x27;FCGI_ROLE&#x27; =&gt; &#x27;RESPONDER&#x27;, &#x27;QUERY_STRING&#x27; =&gt; &#x27;v=1&#x27;, &#x27;REQUEST_METHOD&#x27; =&gt; &#x27;GET&#x27;, &#x27;CONTENT_TYPE&#x27; =&gt; &#x27;&#x27;, &#x27;CONTENT_LENGTH&#x27; =&gt; &#x27;&#x27;, &#x27;SCRIPT_FILENAME&#x27; =&gt; &#x27;/var/www/test.php&#x27;, &#x27;SCRIPT_NAME&#x27; =&gt; &#x27;/test.php&#x27;, &#x27;PATH_INFO&#x27; =&gt; &#x27;/foo/bar.php&#x27;, &#x27;REQUEST_URI&#x27; =&gt; &#x27;/test.php/foo/bar.php?v=1&#x27;, &#x27;DOCUMENT_URI&#x27; =&gt; &#x27;/test.php/foo/bar.php&#x27;, &#x27;DOCUMENT_ROOT&#x27; =&gt; &#x27;/var/www&#x27;, &#x27;SERVER_PROTOCOL&#x27; =&gt; &#x27;HTTP/1.1&#x27;, &#x27;GATEWAY_INTERFACE&#x27; =&gt; &#x27;CGI/1.1&#x27;, &#x27;SERVER_SOFTWARE&#x27; =&gt; &#x27;nginx/1.4.0&#x27;, &#x27;REMOTE_ADDR&#x27; =&gt; &#x27;192.168.56.1&#x27;, &#x27;REMOTE_PORT&#x27; =&gt; &#x27;44644&#x27;, &#x27;SERVER_ADDR&#x27; =&gt; &#x27;192.168.56.3&#x27;, &#x27;SERVER_PORT&#x27; =&gt; &#x27;80&#x27;, &#x27;SERVER_NAME&#x27; =&gt; &#x27;&#x27;, &#x27;HTTPS&#x27; =&gt; &#x27;&#x27;, &#x27;REDIRECT_STATUS&#x27; =&gt; &#x27;200&#x27;, &#x27;HTTP_HOST&#x27; =&gt; &#x27;lemp.test&#x27;, &#x27;HTTP_USER_AGENT&#x27; =&gt; &#x27;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:20.0) Gecko/20100101 Firefox/20.0&#x27;, &#x27;HTTP_ACCEPT&#x27; =&gt; &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;, &#x27;HTTP_ACCEPT_LANGUAGE&#x27; =&gt; &#x27;en-US,en;q=0.5&#x27;, &#x27;HTTP_ACCEPT_ENCODING&#x27; =&gt; &#x27;gzip, deflate&#x27;, &#x27;HTTP_CONNECTION&#x27; =&gt; &#x27;keep-alive&#x27;, &#x27;PHP_SELF&#x27; =&gt; &#x27;/test.php/foo/bar.php&#x27;, &#x27;REQUEST_TIME&#x27; =&gt; 1367829847,) Questions and Answers以下的 Nginx configuration example 的意思是？ Example:proxy_http_version 1.1; Answer:將 http version 設定為 1.1, 預設為 1.01.0 是不會開啟 keep-alive feature 在 proxy server 跟 backend 的 Nginx 中, 何時可能會用到 proxy_set_header?當我想要使用預設的 variable 來設定 header 時, 例如取得 $remote_addr 以下的 Nginx 設定的意思是？ Example: server &#123; listen 80; underscores_in_headers on; location / &#123; if ($http_custom_header = ray) &#123; proxy_pass http://127.0.0.1:3000; &#125; &#125;&#125; Answer:使用 custom variable, 會自動 assign request header name custom_headertitle column collection 的 value 到 $http_custom_header 這個變數中, 所以如果我在 request header 使用 custom_header: ray 的話, 就會 pass 到 http://127.0.0.1:3000;參考 Nginx document 以下的設定中, location ~ \\.php$ 中, 最終帶過去的 fastcgi_param 是什麼？ $query_string, 原本的 $request_method 跟 $document_root, $fastcgi_script_name 會處於未設定 # server contextroot /var/www/html;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;fastcgi_index index.php;location /scripts &#123; fastcgi_pass unix:/var/run/php5-fpm.sock;&#125;location ~ \\.php$ &#123; fastcgi_param QUERY_STRING $query_string; fastcgi_pass 127.0.0.1:9000;&#125; 在以下的設定中, 如果使用 PHP-FPM 的話, 最終傳出的 fastcgi_param TEST 跟 DOCUMENT_ROOT 是？ three, override # server contextlocation ~ \\.php$ &#123; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param SCRIPT_FILENAME $request_uri; fastcgi_param DOCUMENT_ROOT initial; fastcgi_param DOCUMENT_ROOT override; fastcgi_param TEST one; fastcgi_param TEST two; fastcgi_param TEST three; fastcgi_pass 127.0.0.1:9000;&#125; 不同的 FastCGI 處理器的作用方式依樣嗎？ 不同哦 因為不同的 FastCGI 處理器行為不同, 所以宣告 fastcgi_param 時, 建議宣告幾次？ 1次 當我們使用 PHP-FPM, 要 pass fastcgi_params 時, 怎樣可以在不同的 location 中在保留共同變數的同時, 又可以客制新的變數？ 使用 include 共同檔案, 如下： root /var/www/html;location /scripts &#123; include fastcgi_common; fastcgi_index index.php; fastcgi_pass unix:/var/run/php5-fpm.sock;&#125;location ~ \\.php$ &#123; include fastcgi_common; fastcgi_param QUERY_STRING $query_string; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000;&#125; CGI 全寫？ Common Gateway Interface Fast CGI 全寫？ Fast Common Gateway Interface CGI 用途？ 一份協議, 規定要傳哪些數據, 以什麼樣的格式給後端 Fast CGI 用途？ 依據 CGI 協議, 將請求以及數據傳給後端這個動作, 每一次都會產生一個程序, Fast CGI 會啟動一個主程序, 並將工作分配給子進程處理, 避免重複的勞動, 提高效率 PHP-FPM 全寫? PHP-Fast CGI Process Manager PHP-FPM 用途? PHP 針對 FastCGI 的實現 如何使用 systemctl 啟動 Nginx sudo systemctl start nginx 如何使用 systemctl, 預設開機啟動 NGINX? sudo systemctl enable nginx 如何使用 systemctl, 停止 nginx? sudo systemctl stop nginx 如何使用 systemctl, 重啟 nginx? sudo systemctl restart nginx 如何使用 systemctl, 重新載入 nginx 配置文件？ sudo systemctl reload nginx 如何測試 nginx 配置？ sudo nginx -t 如何使用 systemctl, 顯示 nginx 狀態？ sudo systemctl status nginx 如何檢查 nginx 版本？ sudo nginx -v 在 NGINX 中如果我想要從本地帶客製的 header 到 server, 該 header 的 key 有 underscore, 該怎麼解決？ 在 NGINX server block 中加入以下設定underscores_in_headers on; NGINX 中, location 的規則搜尋, 又區分為哪兩種？ 1. 正則搜尋2. 前贅字串 NGINX 中, location 的正則搜尋中, ~* 代表的意思是？ 不區分大小寫 NGINX 中, location 的正則搜尋中, ~ 代表的意思是？ 區分大小寫 NGINX 中, location 的規則搜尋的順序？ 1. 使用前綴字串搜尋2. 搜尋到符合最長的 uri, 記錄下來3. 依照設定檔中的順序, 使用正則搜尋4. 若正則有找到, 停止搜尋, 以正則的為主5. 若正則沒找到, 以前最字串為主 NGINX 中, location 的規則搜尋的順序, 會先使用哪種規則搜尋? 前贅字串 NGINX 中, location 的規則搜尋的順序, 前綴字串搜尋結束後, 會使用什麼規則搜尋? 正則 NGINX 中, location 的規則搜尋的順序, 若再找到符合的前綴字串後, 還是使用正則搜尋一次嗎？? 會 NGINX 中, location 的規則搜尋的順序, 若正則規則找到符合的, 還會繼續搜尋嗎？ 不會 NGINX 中, location 的規則搜尋的順序, 若前綴跟正則都有符合的, 以哪種為優先？ 正則 NGINX 中, location 的規則搜尋中, macOS 會區分大小寫嗎？ 不會 NGINX 中, location 的規則搜尋中, 如何捕捉變數？ 使用正則 NGINX 中, location 的規則搜尋中, ^~ 代表什麼意思？ 當使用 ^~ 的前綴有找到符合的, 不會再使用正則搜尋 NGINX 中, location 的規則搜尋中, ^~ 是用於前綴還是正則？ 前綴 NGINX 中, location 的規則搜尋中, = 是用於前綴還是正則？ 前綴 NGINX 中, location 的規則搜尋中, = 代表什麼意思？ 前綴須完全符合, 若有找到, 搜尋停止 NGINX 中, location 的規則搜尋中, 如果 / 的搜尋非常頻繁, 可以使用什麼樣的規則來加快速度？ = / NGINX 中, location 的規則搜尋中, 下圖中, 請求 / 會符合哪一個？ A location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 /index.html 會符合哪一個？ B location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 documents/document.htm 會符合哪一個？ C location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 images/1.gif 會符合哪一個？ D location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 @name 可否用於正常使用？ 不可 location /img/ &#123; not_found 404 @not_found; &#125; location @not_found &#123; # 规则 &#125; NGINX 中, alias 與 root 的規則中, 下圖中, 如果請求 /i/top.gif 那哪一個檔案會被送出？ /data/w3/images/top.gif location /i/ &#123; alias /data/w3/images/;&#125; NGINX 中, alias 與 root 的規則中, 下圖中, 如果像下圖般有使用到變數, 該從哪裡取變數？ location location ~ xxx &#123; alias /data/w3/images/$1;&#125; NGINX 中, alias 與 root 的規則中, 如下圖般, 當 location 以及 alias 的最後一個資料夾的值相同時, 建議如何？ location /images/ &#123; root /data/w3;&#125; location /images/ &#123; alias /data/w3/images/;&#125; NGINX 中, alias 與 root 的規則中, 如下圖般, 如果請求是 /i/top.gif, 哪個檔案會被送出？ /data/w3/i/top.gif location /i/ &#123; root /data/w3;&#125; NGINX 全域變數中, $document_root 是什麼？ 當前請求的文檔根目錄或別名 NGINX 全域變數中, 下面的 request url 中, $document_uri 是哪一段？ /test1/test2 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, 下面的 request url 中, $host 是哪一段？ 34.83.35.165 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, $hostname 是什麼？ 主機名稱, 可在 Linux 中設定 NGINX 全域變數中, $is_args 是什麼？ 如果請求中有參數，值為“?”，否則為空字符串。 NGINX 全域變數中, $limit_rate 是什麼？ 用於設置響應的速度限制，詳見limit_rate。 NGINX 全域變數中, $msec 是什麼？ 當前的Unix時間戳(1.3.9, 1.2.6) NGINX 全域變數中, $pipe 是什麼？ 如果請求來自管道通信，值為“p”，否則為“.” NGINX 全域變數中, 下面的 request url 中, $query_string 是哪一段？ test1=123&amp;test2=456 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, $realpath_root 是什麼？ 當前請求的文檔根目錄或別名的真實路徑，會將所有符號連接轉換為真實路徑, 位置同 document_root NGINX 全域變數中, $remote_addr 是什麼？ 客戶端地址 NGINX 全域變數中, $remote_port 是什麼？ 客戶端端口 NGINX 全域變數中, $request 是什麼？ 代表客戶端的請求地址, 像這樣: POST /test1/test2?test1=123&amp;test2=456 HTTP/1.1 NGINX 全域變數中, $request_body 是什麼？ 客戶端的請求主體, 此變量可在location中使用，將請求主體通過proxy_pass, fastcgi_pass, uwsgi_pass,和scgi_pass傳遞給下一級的代理服務器。 NGINX 全域變數中, $request_filename 是什麼？ 當前連接請求的文件路徑，由root或alias指令與URI請求生成。 /usr/share/nginx/html/test1/test2 NGINX 全域變數中, $request_length 是什麼？ 請求的長度(包括請求的地址, http請求頭和請求主體) (1.3.12, 1.2.7) NGINX 全域變數中, $request_method 是什麼？ HTTP請求方法，通常為“GET”或“POST” NGINX 全域變數中, $request_time 是什麼？ 處理客戶端請求使用的時間(1.3.9, 1.2.6); 從讀取客戶端的第一個字節開始計時。 NGINX 全域變數中, 下面的 request url 中, $request_uri 是哪一段？ /test1/test2?test1=123&amp;test2=456這個變量等於包含一些客戶端請求參數的原始URI，它無法修改，請查看$uri更改或重寫URI，不包含主機名，例如：”/cnphp/test.php?arg=freemouse”。 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, $scheme 是什麼？ 請求使用的Web協議, “http” 或“https” NGINX 全域變數中, $sent_http_name是什麼？ 可以設置任意http響應頭字段； 變量名中的後半部分“name”可以替換成任意響應頭字段，如需要設置響應頭Content-length，那麼將“－”替換為下劃線，大寫字母替換為小寫，形如：$sent_http_content_length 4096即可。 NGINX 全域變數中, $server_addr 是什麼？ 服務器端地址，非外部 IP, 機器在該網域的地址 NGINX 全域變數中, $server_port 是什麼？ 服務器端口 NGINX 全域變數中, $server_protocol 是什麼？ 服務器的HTTP版本, 通常為“HTTP/1.0” 或“HTTP/1.1” NGINX 全域變數中, $status 是什麼？ HTTP status code NGINX 全域變數中, $time_iso8601 是什麼？ 服務器時間的ISO 8610格式, 如 2019-11-27T14:11:04+00:00 NGINX 全域變數中, $time_local 是什麼？ 服務器時間（LOG Format 格式) 27/Nov/2019:14:11:38 +0000 NGINX 全域變數中, $uri 是什麼？ 請求中的當前URI(不帶請求參數，參數位於$args)，可以不同於瀏覽器傳遞的$request_uri的值，它可以通過內部重定向，或者使用index指令進行修改，$uri不包含主機名，如”/foo/bar.html”。 NGINX 全域變數中, 下面的 request url 中, $uri 是哪一段？ /test1/test2 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 參考以下的 NGINX 設定, 並思考接下來一連串的問題 upstream backend &#123; server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; server backup1.example.com backup;&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; 以上的 nginx 設定中, 到 / 的請求會被送到哪裡？upstream backend 以上的 nginx 設定中, 每七個請求中, 會有幾個到 backend1.example.com? 為什麼？5 個因為 weight=5 以上的 nginx 設定中, 每七個請求中, 會有幾個到 127.0.0.1:8080? 為什麼？1 個因為沒有特別分配權重, 預設平均分配 以上的 nginx 設定中, 每七個請求中, 會有幾個到 unix:/tmp/backend3 為什麼？1 個因為沒有特別分配權重, 預設平均分配 以上的 nginx 設定中, 如果送給 server 127.0.0.1:8080 出錯了, 會怎麼樣？送往下一個, 即 unix:/tmp/backend3 以上的 nginx 設定中, 如果 upstream 中的 server 都無法服務, 會怎麼樣？送給 backup server, 即 backup1.example.com, 客戶會收到這一個 server 的回應 NGINX Cookbook NGINX 中, root 語法的意思是什麼？將會在 root 所定義的位置中尋找請求中帶過來的 URL 部分","link":"/zh-tw/nginx/"},{"title":"Operating System Concept","text":"前言OS 號稱資工系三大主修之一, Ray 雖然不是個血統純正的資工人, 可也要來走上一遭！ 看誰敢嘴？ 上面純粹是壓力大胡說八道一通, 在各位大神之前豈敢妄下狂言… Questions and Answers作業系統中, 什麼是 multi-core processor?processor 上有多個 core 作業系統中, 什麼是 multi-processor?主機板上有多個 processors 插槽 作業系統中, processor affinity 中的 soft affinity 跟 hard affinity, 差別在於？soft 容許必要時移到另外一個 processor, hard 不容許 作業系統中, 如果該主機是屬於 symmetric multi-processing, 那當 OS 從眾多的 queue 當中挑選出要被執行的 process 時, 眾多 CPU 競爭一個 process, 會產生 synchronization 的問題, 解法中的 processor affinity 的意思是？process 跟執行它的 processor 是綁定 作業系統中, 如果該主機是屬於 symmetric multi-processing, 那當 OS 從眾多的 queue 當中挑選出要被執行的 process 時, CPU 的運作模式是？眾多 CPU 競爭該 process 作業系統中, 如果該主機是屬於 asymmetric multi-processing, 那當 OS 從眾多的 queue 當中挑選出要被執行的 process 時, CPU 的運作模式是？master 會分配給 slave CPU 去執行該 process 作業系統中, Multilevel Feedback Queue 中, Feedback 的意思是？job 會根據每一次 runtime 的回饋, 被調整到不同的 queue 作業系統中, Multilevel Feedback Queue 中, 通常, 越吃 CPU 的 process 會被排在上面或是下面的 queue? 為什麼？越下面, 因為理論上, SJF 演算法是比較理想的 作業系統中, Multilevel Feedback Queue 中, 不同類型的 job 可否在不同的 queue 之間移動, for example, system 類型的 job 並不會單單只被排在特定的 queue 中?可以哦 作業系統中, Multilevel Feedback Queue, 會在何時決定 job 該進哪一個 queue?runtime 的時候 作業系統中, Multilevel Feedback Queue, 比較重要的 queue 裡頭的 job 還未全部執行完之前, 會否執行其他 queue 中的 job?不會 作業系統中, multilevel queue 中, 不同的 queue 之間的優先是用什麼方式實作？以機率選擇, 比較重要的 queue 的權重較重 作業系統中, multilevel queue 中, 可否讓不同的 queue 擁有不同的 algorithm?可以 作業系統中, Scheduling method 中的 Round-Robin 的參數 time quantum 指的是？每個 process 可以使用 CPU 多久 作業系統中, Scheduling method 中的 Round-Robin 的意思是？每個 process 輪流執行 作業系統中, Scheduling 中的 SJF 全寫是？Shortest-Job-First 作業系統中, 如果目標是要將 average wait time 降到最低的話, 哪一種 scheduling 會是比較理想的？Shortest-Job-First Scheduling 作業系統中, Priority Scheduling 中, starvation 的 solution aging 是什麼意思?當一個 process 隨著時間都沒有被執行的話, 就增加其 priority 作業系統中, Priority Scheduling 中, starvation 是什麼情況?一個 process 的 priority 太小, 所以一直都沒有被執行 作業系統中, 何謂 Priority Scheduling?以 priority number 來決定執行順序 作業系統中, scheduling criteria 中, 何謂 response time?提交一個 process 後, 到該 process 開始第一個 CPU burst 所需的時間 作業系統中, scheduling criteria 中, 何謂 waiting time?一個 process 在 ready queue 中所等待的時間 作業系統中, scheduling criteria 中, 何謂 turnaround time?提交一個 process 到該 process 完成耗費的時間 作業系統中, scheduling criteria 中, 何謂 throughput?每個時間單位內完成的 process 數量 作業系統中, scheduler 跟 dispatcher 的職責分別是？ scheduler: 選擇下一個 process dispatcher: 切換 process 作業系統中, preemptive scheduler, 執行 kernel 程式時, Unix OS 是如何避免 Synchronization issue?disable timer 作業系統中, preemptive scheduler 在 Unix OS 中, 當執行 kernel 程式時, timer 會打斷 kernel process 嗎？不會 作業系統中, non-preemptive scheduler 唯有在哪兩種狀況下會 scheduling？ from running to waiting state terminate 作業系統中, scheduling 共有哪四種行為？ from running to waiting state from running to ready state from waiting to ready terminate 作業系統中, 何謂 Non-preemptive scheduler？process 執行到一半不允許被打斷 作業系統中, 何謂 Preemptive scheduler？process 執行到一半可以被打斷 作業系統中, 大部分的 CPU burst 都是短的還是長的？短的 作業系統中, 一個程式實際上就是在哪兩著 burst 之間做交換？CPU, I/O 作業系統中, 何謂 I/O burst?一連串的 instruction 都在做 I/O 作業系統中, 何謂 CPU burst?一連串的 instruction 都在使用 CPU 作業系統中, process 運行過程中, 大致上就只有哪運作兩種行為？I/O, 計算 作業系統中, 當 fork() 被呼叫, 會單單複製呼叫的 thread, 或是複製所有的 thread？兩種都有可能 作業系統中, 當一個 thread 被 cancel, main thread 需要 free 該 thread 的 memory, Asynchronous cancellation 跟 Deferred cancellation 的差異在於？ Asynchronous 會立即的 terminate, 但是是非同步的 Deferred cancellation, thread 會週期性(在特定的點)的 check 是否需要被 terminate 作業系統中, 當一個 thread 被 cancel, main thread free 該 thread 的 memory 主要有哪兩種方式？ Asynchronous cancellation Deferred cancellation 作業系統中, Linux 中的 system call fork 以及 clone, 差異在於？兩者都是建立 process, 但 clone 提供一些 flag 來決定哪些參數要 share 作業系統中, Linux OS 支援 thread 嗎？不支援 作業系統中, 為什麼 Java threads 的 portability 高？因為 Java 本身就做了一層 layer, 像是相容於各個 OS 的 virtual machine 作業系統中, Java Threads 有什麼特性?portability 高 作業系統中, thread_detach 的具體行為是?結束該 thread, 且不 join 回 main thread 作業系統中, thread_join 的具體行為是?將 thread_create 的執行結果回傳到指定的 thread 作業系統中, thread_create 的具體行為是?執行一個 function 作業系統中, 何謂 Pthread?基於 POSIX 的 thread library 作業系統中, thread programming 是屬於 shared memory programming, 還是 message passing programming?shared memory programming 作業系統中, 在 shared memory 的資料傳輸方式中, 有哪兩個角色？ producer consumer 作業系統中, 大部分的作業系統都是使用 Multi-thread 的哪一種 relation? many-to-one or one-to-one or many-to-many?one-to-one 作業系統中, Multithreading Models , many to many relation 當中, 假設我有 3 個 user thread 對上 4 個 kernel thread, 當其中一個 user thread 以及 kernel thread 被 block, 剩下的 2 個 user thread 會 share 幾個 kernel thread?3 個 作業系統中, Multithreading Models , one to one relation 當中, 當 user thread 開太多個, 可能會造成什麼樣的問題？ 為什麼？系統卡住, 因為 kernel thread 通常有其上限 作業系統中, Multithreading Models relation 中, 又分為哪三種？ many to one one to one many to many 作業系統中, Multithreading Models 中, many to one 的話, 如果一個 user process 有 4 個 thread 的話, 這 4 個 thread 可以平行同時執行嗎？ 為什麼？不行, 因為這個 process 只對到一個 kernel thread 作業系統中, Multithreading Models 中, many to one 的話, 一個 kernel thread 會對到 user thread 的什麼單位？一個 process 作業系統中, 如果一個 user thread 被 block, 那其他的 user thread 會受到影響嗎？不一定 作業系統中, 如果一個 kernel thread 被 block, 那其他的 kernel thread 會受到影響嗎？不會 作業系統中, 如果我有 multiple user thread, 但是只有 single kernel thread, 那速度會比較快嗎？ 為什麼？不會, 因為就算 user thread 已經 ready, 還是要等待 kernel thread 作業系統中, thread 又分為哪兩大類？ user thread kernel thread 作業系統中, API 算是 user level 還是 kernel level?user level 作業系統中, 同個 process 下得不同 thread, 溝通需要透過 OS 嗎？不需要 作業系統中, process 跟 process 之間, 溝通需要透過 OS 嗎？需要 作業系統中, process 的 message passing 跟 thread 的 memory sharing 哪一個傳輸的資料比較多？thread 作業系統中, thread creation 跟 process creation, 哪一個比較快？thread 作業系統中, thread 與 thread 之間, 會否 share stack不會 作業系統中, thread 與 thread 之間, 會否 share data section?會的 作業系統中, thread 與 thread 之間, 會否 share heap?會的 作業系統中, 紀錄 thread 資訊的記憶體又叫作？thread control block 作業系統中, message passing 的 RPC 方式, 位於 server 端的角色叫做？skeleton 作業系統中, message passing 的 RPC 方式, 位於 client 端的角色叫做？stub 作業系統中, message passing 的 socket 方式, 當 server 端與 client 端成功建立連線後, server 端會建立一個 thread 來跟 client 端溝通, 這時 server 端的這個 thread 使用的 port 號跟原本的 process listen 的 port 一樣嗎？不一樣 作業系統中, message passing 的 socket 方式, 當 server 端與 client 端成功建立連線後, server 端會建立什麼來跟 client 端溝通？thread 作業系統中, message passing 的 synchronization, buffer implementation 當中的 unbounded, 具體的行為是？永遠不會 block sender 作業系統中, message passing 的 synchronization, buffer implementation 當中的 Bounded, 具體的行為是？如果 capacity 滿了, block sender 作業系統中, message passing 的 synchronization, buffer implementation 當中的 Zero, 具體的行為是？如果是 0, 則 block send/receive 作業系統中, message passing 的 synchronization, 如果是使用 non-blocking 方式的話, 這代表 sender 與 receiver 之間還有一個什麼角色？buffer 作業系統中, message passing 的 indirect communication, 當出現多個 receiver 時, 大略上有哪三種方法來決定 receiver? 只允許 communication 有兩個 process (最爛, 相當於 direct communication) 只允許一次一個 process 可以執行 receive operation 讓 OS 來決定誰是 receiver, 並通知 sender 作業系統中, message passing 的 indirect communication 的 mailbox 是由誰來管理？OS 作業系統中, message passing 的 indirect communication, 是 one to one, 還是 many to many?many to many 作業系統中, message passing 的 indirect communication, 是經由什麼服務來傳遞訊息的？mailbox 作業系統中, message passing 的 direct communication 中, communication link 與 process 之間的關係, 是 one to one, 還是 one to many?one to one 作業系統中, message passing 的 direct communication 的意思是？雙方都知道對方是誰 作業系統中, message passing 的 IPC 提供了兩種 operation, 分別是？ Send Receive 作業系統中, shared memory 可以做到 synchronization 嗎？不行 作業系統中, OS 會提供一塊什麼樣的 buffer 供 shared memory 的 process 使用？circular buffer 作業系統中, 利用 shared memory 來溝通的 process 需要呼叫哪個 system call 來告知 OS 正在使用這塊空間？attach 作業系統中, 當 shared memory 被建立出來後, OS 會否參與其內容？不會, 交由需要溝通的 process 去處理 作業系統中, 若要建立 shared memory 空間, 需要誰去呼叫 system call？需要用到這塊空間的 process 作業系統中, RPC 的簡單解釋？server 端以提供 API 的方式給 client 端, 以作溝通 作業系統中, Sockets 的 port 主要代表什麼？process 作業系統中, message passing 的 method Socket, 主要是靠什麼連線?network by IP &amp; port 作業系統中, message passing 又分為哪兩種 method? Sockets Remote Procedure Calls 作業系統中, communication methods 中, 如果要跨電腦溝通, 只可使用哪一種 method?message passing 作業系統中, memory 的溝通如果不要求太複雜的操作時, shared memory 跟 message passing 哪種是比較適合的？shared memory 作業系統中, IPC 的簡單解釋？在不同 process 之間溝通 作業系統中, IPC 的全寫是？Interprocess Communication 作業系統中, 當我 kill 一個 process, 其 child 還會存在嗎？不會 作業系統中, UNIX/Linux 中, 如果 parent 要 kill child, 使用哪個 system call?abort 作業系統中, UNIX/Linux 中, 使用哪個 system call 來 terminate process?exit() 作業系統中, UNIX/Linux 中, 當 fork 時, memory space copy method 中, copy on write 的意思是？當 parent 與 child 的 memory content 不同時才複製, 若相同則 share 作業系統中, UNIX/Linux 中, 現階段當 fork 時, 針對 memory space 是使用哪一種 copy 方式？copy on write 作業系統中, UNIX/Linux 中, 預設的執行順序是 concurrent, 如果要讓 parent 等待, 可以呼叫哪一個 system call?wait system call 作業系統中, UNIX/Linux 中, 當 child 被建立後, 會呼叫 execlp system call, 目的為何？重設 child process memory space 的內容, 覆蓋舊的 作業系統中, UNIX/Linux 中, child 被建立後, 會 return 一個 value, 是？0 作業系統中, UNIX/Linux 中, parent 在建立 child 後, 會 return 一個 value, 是？child 的 PID 作業系統中, UNIX/Linux 中, parent 與 child 的執行優先順序是？OS 決定 作業系統中, UNIX/Linux 中, child 被建立時, memory space 的建立原則是複製還是載入？複製 作業系統中, UNIX/Linux 中, 使用哪個 system call 來建立 child?fork 作業系統中, process child 建立時, memory space 的定義又分為哪兩種？ 完全從 parent 複製 從 parent 載入特定部分 作業系統中, process 的 parent 跟 child 之間, execution 的優先順序又分為哪兩種？ 交給 OS scheduler 決定 parent 等待直到 child terminate 作業系統中, process 的 parent 跟 child 之間, resource sharing 又分為哪三大類？ child share all resources of parent’s child share partial resources of parent’s child share no resources of parent 作業系統中, process 一定是哪一種 data structure?tree 作業系統中, process identifier 指的是？PID 作業系統中, Medium-Term Scheduler 為什麼要將 process 在 memory, disk 之間移動？減少 degree of multiprogramming 作業系統中, Medium-Term Scheduler 的 swap in 主要做什麼事？將 process 從 disk 移到 memory 作業系統中, Medium-Term Scheduler 的 swap out 主要做什麼事？將 process 從 memory 移到 disk 作業系統中, Medium-Term Scheduler 主要是將 process 在哪兩個儲存裝置之間切換？disk, memory 作業系統中, Long-Term Scheduler select a good mix of CPU-bound &amp; I/O-bound, 這句話是什麼意思？把會需要用到 CPU 的 process 跟會用到 I/O 的 process 取得一個平衡, 提升整體效能 作業系統中, Long-Term Scheduler 主要控制 degree of multiprogramming, 這句話的意思是？控制 memory 中有幾個程序 作業系統中, Medium-term scheduler 主要將 Process 從哪一個狀態切換成哪一個狀態？Ready state =&gt; Wait state 作業系統中, 為什麼 CPU scheduler 又稱為 short-term scheduler?因為 time-sharing switch context 的速度非常頻繁 作業系統中, Job scheduler 又稱為？Long-term scheduler 作業系統中, CPU scheduler 又稱為？Short-term scheduler 作業系統中, 由 New state =&gt; Ready state, 是由 CPU scheduler 處理還是由 Job scheduler 處理？Job scheduler 作業系統中, 由 Ready state =&gt; Run state, 是由 CPU scheduler 處理還是由 Job scheduler 處理？CPU scheduler 作業系統中, Process Scheduling Queues 當中, 每一個 Device 的 Device Queue 是同一個嗎？不同, 每個 Device 都有各自的 device queue? 作業系統中, Process Scheduling Queues 當中, Device queue 是在 process 的哪一個狀態的 queue?Waiting 作業系統中, Process Scheduling Queues 當中, Ready queue 是在 process 的哪一個狀態的 queue?Ready 作業系統中, Process Scheduling Queues 當中, Job queue 是在 process 的哪一個狀態的 queue?New 作業系統中, 若要提升 context switch 的速度, 可使用 hardware support, 具體意思是?hardware 提供多組的 register, 不同 PCB 可同時 load 到不同 register 當中, 不必重 load memory 作業系統中, 若要提升 context switch 的速度, 可使用 special instructions, 具體意思是?讓 save 跟 reload 以 single instruction 完成 作業系統中, 何謂 context switch 會執行哪兩個動作?save 目前的 PCBreload 下一個 PCB 作業系統中, 何謂 context switch?將原本執行的 process 切換到另外一個 process 作業系統中, process 的 base/limit register 什麼時候會被 load 到 hardware?當該 process 位於 running state 時 作業系統中, PCB 位於 user space 還是 kernel space?kernel space 作業系統中, process 的 CPU registers 被存在什麼地方?PCB 作業系統中, process 的 Program counter 被存在什麼地方?PCB 作業系統中, 如何實現 PCB 的 queue？利用 linked list, pointer 指向下一個 PCB 作業系統中, memory 中的 PCB 全寫是？process control block 作業系統中, process state 中的 Waiting 在執行完 I/O 之後, 會回到哪個 state??Ready 作業系統中, process state 中的 Runner 通常什麼情況下會回到 Ready?被 timer 打斷 作業系統中, process state 中的 Terminated 代表的意思是？將 process 佔用的資源 release, 所以 OS 可以再度分配這些資源 作業系統中, process state 中的 Waiting 代表的意思是？當 process 在執行一些非 CPU 的工作, 像是 I/O, 這時候須等待 I/O 處理完畢才可在被 CPU 執行, 因為位於 waiting 作業系統中, process state 中的 Running 代表的意思是？正在使用 CPU 作業系統中, process state 中的 Ready 代表的意思是？load 到 memory 的 process 在等待使用 CPU 時 作業系統中, process state 中的 New 代表的意思是？將 program load 到 memory, initialize 作業系統中, 使用哪一個 section 在同一個 process 下的不同 threads 之間溝通？data section (global variable) 作業系統中, 同 process 不同 thread 之間的有哪些 section 是共用的？ code section data section resources 作業系統中, 一個 thread 可以有很多 process 嗎？不行 作業系統中, 一個 process 可以有很多 thread 嗎？可以 作業系統中, CPU 在執行中最 basic 的單位是？thread 作業系統中, Threads 又被稱為？lightweight process 作業系統中, process 在 memory space 中, 有哪兩個 section 是會動態成長的？ Stack Heap 作業系統中, process 在 memory space 中的 Heap 會存放 dynamic allocated variables or classes, 這邊指的是？就像是 new Class 分配到記憶體的 class 作業系統中, process 在 memory space 中的 Stack 會存放 local variable, 這邊的 local variable 指的是？function 中的變數, return 就釋放了 作業系統中, process 在 memory space 中, resources 紀錄的是？該 process 所使用的 resources (e.g. file) 作業系統中, process 在 memory space 中, Register content 紀錄的是？目前 register 中的 content, 這樣下次再載入的時候會直接 load 到 CPU 的 register 作業系統中, process 在 memory space 中, Program counter 紀錄的是？目前執行 program 的位置 作業系統中, process 在 memory space 中, Heap 裡頭存放的是？dynamic allocated variables or classes 作業系統中, process 在 memory space 中, Stack 裡頭存放的是？local variable 作業系統中, process 在 memory space 中, Data section 裡頭存放的是？global variable 作業系統中, process 在 memory space 中, Code Segment 裡頭存放的是？process compiled instruction 作業系統中, program 跟 process 差別在哪？ Program 是位於 disk 的 binary code Process 是位於 memory 的執行中的 program 作業系統中, JVM virtual machine 會否將翻譯過的 instruction 記住?會哦 作業系統中, JVM virtual machine 有無自己的 biyecodes?有 作業系統中, Full Virtualization 跟 Para Virtualization 哪一個效能快？ 若說 Para Virtualization 比較快, 為什麼？ 不一定 有 Master OS 居中優化 作業系統中, Full Virtualization 跟 Para Virtualization 哪一個效能快？ 若說 Full Virtualization 比較快, 為什麼？ 不一定 有 hardware support, 不用多一層 Master OS 作業系統中, Para Virtualization 的開源軟體叫做？Zen 作業系統中, Full Virtualization 的開源軟體叫做？KVM 作業系統中, virtual machine 中, 所謂的 master os, 存在於 Full Virtualization 或是 Para Virtualization?Para Virtualization 作業系統中, Para Virtualization 中, 安裝在 user space 的 OS 程式碼需要特別修改嗎 (比如說官方 Windows 10 正版光碟是否可以不修改程式碼直接安裝)？需要特別修改 作業系統中, Virrualization 又分哪兩大類？ Full Virtualization Para Virtualization 作業系統中, Full Virtualization 中, 安裝在 user space 的 OS 程式碼需要特別修改嗎 (比如說官方 Windows 10 正版光碟是否可以不修改程式碼直接安裝)？不需要 作業系統中, critical instruction 在 user space 的執行結果跟在 kernel space 的執行結果, 一樣嗎?不一樣 作業系統中, 何謂 critical instruction?一種 instruction, 在 user space 以及 kernel space 執行的結果不同 作業系統中, 有些 CPU 會標明支援 virtual machine, 是什麼意思？代表此 CPU 除了 user mode, kernel mode 之外, 還會有一個 virtual machine mode, 當偵測到 virtual machine mode 時, 會知道這是 virtual machine 的 kernel, 可以直接執行 privileged instruction, 不需再透過真正的 kernel 作業系統中, 早期 virtual machine 在執行 privileged instruction 時, 因為 virtual machine 的 kernel 位於 user space, 所以被 CPU 拒絕了, 後來如何解決？當 hardware 拒絕時, 會拋出 exception, 這時真正的 kernel 收到, 進而幫 virtual machine 的 kernel 再執行一次 作業系統中, 早期 virtual machine 在執行 privileged instruction 時, 被 CPU 拒絕了, 為什麼？?因為 virtual machine 位於 user space 作業系統中, virtual machine 的 kernel 實際上是在 kernel space 還是 user space?user space 作業系統中, virtual machine 在 40~50 年前剛被提出時, 為什麼不被泛用？因為當時的硬體效能不夠 作業系統中, virtual machine 的歷史已有多少年？40~50 年 作業系統 Kernel Module 的概念中, 與 layer 的概念差別在哪？在 layer 概念中, 下層是無法呼叫上層, 但在 Kernel Module 的概念中, 是可以互相呼叫的, 所以更靈活 作業系統 Kernel Module 的概念中, 不同 module 之間的溝通需要用到 message passing 嗎?不需要, 因為全部都使用 Kernel memory 作業系統中 Microkernel 的概念跟 Kernel Module 的概念, 差別在哪?Kernel Module 的 module 都位於 kernel space, 而 Microkernel 的 module 則是位於 user-space 作業系統中 Microkernel 的概念中, 速度慢的原因是？process 跟 process 之間的溝通都要用到 system call 作業系統中 Microkernel 的概念中, 為何使用 message passing 作為 process 跟 process 之間的溝通方式？?因為要避免 synchronisation 作業系統中 Microkernel 的概念中, 兩大優點是？? 易於擴展 可攜性高 作業系統中 Microkernel 的概念中, 不同 process 溝通的方式是？?message passing 作業系統中 Microkernel 的概念中, module 都被至於哪一個區塊？?user space 作業系統中 Microkernel 的概念中, kernel 實際上負責的工作有哪兩大類？? 在不同的 module 之間溝通 定義不同 module 的 interface 作業系統中 layer 的概念中, 速度會比較快還是比較慢?比較慢, 因為一個 function call 就要一直往下呼叫 作業系統中 layer 的概念中, 比較容易 debug 的原因是?可以經由哪一層出問題來判斷 作業系統中 layer 的概念中, 如果上層 okay, 其下層可能會是 okay 的還是不 okay?okay 作業系統中 layer 的概念, 高層的 layer 可以呼叫低層的 layer 嗎？？不可以 MS-DOS 作業系統中, 有 layer 的概念嗎？沒有 作業系統中, 為何要使用 API, 有哪三大原因？ simplicity portability efficiency 作業系統中, POSIX API 的用途是？在不同的 OS 中, 儘管彼此的 system call 不同, 但只要 API interface 相同, 便能確保不同的 user program 在不同的 OS 是不需要改動程式碼的 作業系統中, system call 的特色是？ 功能單一 速度快 作業系統中, 一個 API 可能會呼叫幾個 system call0 個或多個 作業系統中, API 一定會呼叫 system call 嗎？不一定 作業系統中, 當 OS 的 API 採用 C Library, 若我要寫一個 program 跟 OS 溝通, 需要使用哪種語言?C 作業系統中, 通常 API 的形式像是？?Library, 像 C Library, Java Library 作業系統中, 像 C Library 是屬於 system call 還是 API?API 作業系統中, 通常使用者會直接呼叫 system call 嗎？？不會, 會透過 API 作業系統中, API 的目的是？為了 programming 的方便 作業系統中, system call 是哪一種 interrupt?software 作業系統中, OS 提供的 function call, 又稱為？system calls 作業系統中, system calls 是用什麼語言寫的？assembly language 作業系統中, system call 跟 API 相同嗎？不同 作業系統中, shared memory 需要透過何者方可建立？kernel 作業系統中, message passing 跟 shared memory, 為何 message passing 速度較慢？因為還要 copy 一份 memory 作業系統中, message passing 跟 shared memory 何者速度較慢？message passing 作業系統中, shared memory 的溝通方式如何運作？建立一個 shared memory, 此區間可同時被兩個 process access, 以此交換 message 作業系統中, message passing 的溝通方式如何運作？先將要 passing 的 message 從該 process 上 copy 到 kernel 的 memory, 在 pass 到另一個 process 作業系統中, process 跟 process 有哪兩種溝通方式？ message passing shared memory 作業系統 CPU protection 中, Load-timer instruction 的目的是？重設 timer 上的 value 作業系統 CPU protection 中, 透過哪個 privileged instruction 來重設 timer value?Load-timer 作業系統 CPU protection 中, 當 timer 歸 0 時, CPU 會呼叫 OS 的 scheduler, OS scheduler 會做什麼事？決定接下來要執行什麼程式, 包括 OS 自己的程式 作業系統 CPU protection 中, 當 timer 歸 0 時, timer 會丟一個 interrupt 給 CPU, 這個 interrupt 會叫 CPU 去做什麼事？執行 OS scheduler 作業系統 CPU protection 中, 當 timer 歸 0 時, timer 會做什麼事？會丟一個 interrupt, 打斷 CPU 作業系統 CPU protection 中, timer 位於？motherboard 作業系統中, 主要靠什麼來做 CPU protection?timer 作業系統 memory protection 中, 當 CPU 要執行一個程式時, 如果發現 address 不在指定的界限範圍內, 會怎麼做？丟失 error 作業系統 memory protection 中, 當 CPU 要執行一個程式時, 會先檢查哪個東西有沒有在界限內？address 作業系統 memory protection 中, limit register 的意思是？memory 界限的長度 作業系統 memory protection 中, base register 的意思是？memory 界限的起點 作業系統 memory protection 中, 每支程式都有其可 access memory 的區間, 這個區間由哪兩個東西界定？ base register limit register 作業系統 I/O protection 中, 跟 I/O 有關的 instructions 都是屬於哪個種類的 instruction?privileged instructions 作業系統 I/O protection 中, 哪些 I/O 要保護全部的 I/O device 作業系統 Dual-Mode 中, privileged instructions 的目的是？保護電腦, 強迫使用者一定要透過 OS 才可執行的 instruction 作業系統 Dual-Mode 中, 使用者可以自己執行 privileged instruction 嗎？不行 作業系統 Dual-Mode 中, 何謂 privileged instruction? 只可在 monitor mode 執行 由 system call 呼叫 作業系統 Dual-Mode 中, mode bit 何時會變成 1?當 system call 執行完畢, 要 return 回 user program 時 作業系統 Dual-Mode 中, mode bit 位於?hardware 作業系統 Dual-Mode 中, mode bit 何時會變成 0?當 interrupt/trap 被呼叫或有 error 產生時 作業系統中, system call 一定要透過什麼來執行？interrupt 作業系統 Dual-Mode 中, mode bit 分別是？ user (1) kernel (0) 作業系統 Dual-Mode 中, 如何區別 mode?利用 mode bit 作業系統中, 要請 OS 做任何事情, 一定要呼叫？system call 作業系統中, Dual-Mode Operation 中, Monitor mode 的意思是?代表 OS 執行 作業系統中, Dual-Mode Operation 中, Monitor mode 又稱為?kernel mode or system mode 作業系統中, Dual-Mode Operation 中, 至少會有哪兩種 mode? User mode Monitor mode 作業系統中, 像 Google 是如何解決分散式系統中的 coherency and consistency 的問題？不解決 作業系統中, 當我使用 multi-tasking system 時, 多個 core 有多個 cache, 假設在兩個 cache 上同時有同樣的資料, 但新舊不同, 應該要使用哪一個？較新的 作業系統中, 為什麼在 multi-tasking system 中會比較有 coherency and consistency 的問題？因為多個 core 有各自的 cache, share 同一個 memory 作業系統中, cache 需要在多層 cache 之間處理什麼問題？coherency and consistency 作業系統中, cache 的定義？從較慢的儲存空間複製一份到較快的儲存空間 作業系統中, 當讀取連續資料時, hard drive 會跟 SSD 差很多嗎？不會 作業系統中, disk 中的 rotational latency 的意思是？磁盤轉動的速度 作業系統中, disk 中的 seek time 的意思是？在該磁盤中找到該資料的時間 (這取決於資料的分散度) 作業系統中, disk 中的 positioning time 哪兩個要素相加？seek time + rotational latency 作業系統中, disk 中的 transfer time 跟什麼有關？data size 作業系統中, hard real-time system 會使用 secondary storage 嗎？不會 作業系統中, 儲存裝置的階層主要與哪三大要素有關？ speed cost volatility 作業系統中, 唯有哪一個儲存裝置可以被 CPU 存取？main memory 作業系統中, 除了 main memory 之外的其他儲存裝置又稱為？secondary storage 作業系統中, 現在 tape 儲存裝置還有被使用嗎？有的 作業系統中, 照階層順序由上到下排列以下裝置？Example: cache registers main memory Answer:registers, cache, main memory 作業系統中, 最耐用的儲存裝置是？tapes 作業系統中, 比較注重效能的 OS, 像是 Linux, 當收到 interrupt 時, 如果又收到一個新的 interrupt, 會怎麼處理？disable 作業系統中, 當我收到 software interrupt 時, 如下圖, 為什麼是 case, 而不是 interrupt vector? 因為 software interrupt 的 function pointer 是不固定的, 反之, interrupt vector 是固定的 作業系統中, 在執行完 interrupt vector 的 size 是固定的還是不固定？固定 作業系統中, 在執行完 interrupt vector 裡頭的 service routine 之後, CPU 會回到？原本執行的程式 作業系統中, interrupt vector 中的 function pointer 又稱為？interrupt service routine 作業系統中, 當我安裝 device driver 時, 會安裝在哪個地方？interrupt vector 作業系統中, signal number 跟 usb hub 的關係是？該 usb hub 會有自己的 signal number, 這個 signal number 會對應到 interrupt vector 作業系統中, 當 OS 偵測到 hardware interrupt 之後, 會到什麼地方尋找該 hardware 編號?interrupt vector 作業系統中, interrupt vector 是什麼？array of function pointer 作業系統中, software interrupt 又稱為？trap 作業系統中, 由使用者發起的 system call 會觸發 interrupt 嗎？不會 作業系統中, software 可能因為哪兩種狀況觸發 interrupt? error operation system call 作業系統中, hardware 產生的 interrupt 又稱為？signal 作業系統中, interrupt 可能由哪兩種來源發出？ hardware software 作業系統中, 假如資料正在從 device 傳送到 buffer, 並從 buffer 在寫入 memory, 在這一個流程中, interrupt 會在什麼時候打斷 CPU?當 buffer 滿的時候 作業系統中, 在 interrupt 概念出現之前, 當 device 要寫入資料到 memory 時, CPU 的運作模式是？一方面搬運資料, 一方面監控 buffer 狀態, 總處於忙碌中, 但對使用者沒意義 作業系統中, 當我要從 device 搬資料到 memory, 會先經過哪個裝置？Device Controller 中的 buffer *作業系統中, 在 CPU, Memory 與 Devices之間, 還有一個什麼元件？*Device Controller 作業系統中, OS 的別名為？Kernel 作業系統中, System Library 扮演著承上啟下的作用, 這邊的下指的是？Device driver 作業系統中, System Library 扮演著承上啟下的作用, 這邊的上指的是？Linker, 與 compile 後的 User program 相接 作業系統中, User program 經過 compiler 轉換成機械語言之後, 要透過哪一個步驟與 System Library 做連結?Linker 作業系統中, User program 會先經過什麼處理轉換成機械語言?compiler 作業系統中, 何謂 System Library?OS 所提供的 API 作業系統中, 將 hardware resources 做分配給不同的 User Application 做使用, 算是 Control 還是 Coordinate？Coordinate 作業系統中, 將 hardware resources 抽象化給 User Application 做使用, 算是 Control 還是 Coordinate？Control 作業系統中, OS 實際上是對 hardware resource 做哪兩大操作？ Control Coordinate 作業系統中, OS 實際上是把 hardware resources 做什麼處理後給 User Application 是做使用？？提供 hardware resources 抽象化 API 作業系統中, Hardware 常常又被稱為？computing resources 作業系統四大 component 中, User 代表的是？people, machines, other computers 作業系統中, 有哪四大 component? Hardware OS Application User 作業系統中的 protection (非 security 方面), 是什麼意思？不同使用者之間不互相影響, 例如 A 使用者的程式 crash 不可影響到 B 使用者 作業系統中, hard real-time requirements 中, 資料都要跑在硬碟或 memory?memory 作業系統中, hard real-time requirements 如果沒有達到, 系統會 crash 嗎？？會 作業系統中, Soft real-time requirements 如果沒有達到, 系統會 crash 嗎？？不會 作業系統中, Real-TIme System 又分成哪兩種？ Hard real-time requirements Soft real-time requirements 作業系統中, Real-TIme 的定義是？與速度無關, 但須在 deadline 之前做完 作業系統中, Cluster System 的定義是？使用 LAN 相連, 速度較快 作業系統中, Client-Server Distributed System 的缺點是？Server 掛就全掛了, 效能瓶頸在 Server 端 作業系統中, Client-Server Distributed System 的優點是？易於管理 作業系統中, Distributed System 又分為哪兩大類？ Client-Server Distributed System Peer-to-Peer Distributed System 作業系統中, Distributed System 主要目的是？Reliability 作業系統中, Distributed System 會共享 memory 嗎？不會 作業系統中, 何謂 loosely coupled system?元件並非全都在一台機器中, 而是通過網路線連結 作業系統中, Distributed System 又稱為？loosely coupled system 作業系統中, NUMA 架構中, 存取 memory 的速度相同嗎？不同 作業系統中, NUMA 中要存取不同區塊的 memory 時, 可以直接存取, 或是需要該區塊同意？需要該區塊同意 作業系統中, 以下的圖片是 UMA 還是 NUMA? Answer:UMA 作業系統中, 以下的圖片是 UMA 還是 NUMA? Answer:NUMA 作業系統, Memory Access Architecture UMA 中, 每個 CPU 的 Memory Access Time 都一樣還是會有所不同？都一樣 作業系統中, NUMA 的全寫是？Non-Uniform Memory Access 作業系統中, UMA 的全寫是？Uniform Memory Access 作業系統中, 像現今, 一個 GPU 上有很多 core, 這又稱為？Many-Core Processor 作業系統中, 一個 CPU 不同的 core 之間的 communication 較快, 還是不同 CPU 之間的 communication 比較快？一個 CPU 不同的 core 之間 作業系統中, 一個 Multi-Core Processor 比較耗電, 還是多個 Single-Core Processor 比較耗電？多個 Single-Core Processor 作業系統中, 何謂 Multi-Core Processor？一個 CPU 有多個 core 作業系統中, Asymmetric multiprocessor system 適用於大型或小型系統？大型 作業系統中, 一般家用主機是 symmetric multiprocessor system 還是 asymmetric multiprocessor system?symmetric multiprocessor system 作業系統中, Symmetric multiprocessor system 跟 Asymmetric multiprocessor system 的 CPU 差異是？Asymmetric multiprocessor system 有 master CPU 跟很多 slave CPU, symmetric multiprocessor system 都是一樣的 作業系統中, Parallel Systems 又分為哪兩種？ Symmetric multiprocessor system (SMP) Asymmetric multiprocessor system 作業系統中, Parallel System 的目的？ 更快 經濟 可靠性 作業系統中, Parallel Systems, 或者 Multiprocessor, 抑或 tightly coupled system, 是將超過一個以上的 CPU 串在一起, 將這些 CPU 串在一起的東西稱為？System Bus 作業系統中, 何謂 Parallel Systems, 或者 Multiprocessor, 抑或 tightly coupled system?超過一個以上的 CPU 串在一起, 共用 memory 作業系統, 是靠什麼概念才能真正達到多程式同時執行？time-sharing 作業系統, 是靠什麼概念才能真正達到多使用者同時使用一台電腦？time-sharing 作業系統 multi-programing system 中, 一次能處理幾個 program？一個 作業系統 multi-programing system 中, 支援多使用者同時操作嗎？不支援 作業系統 multi-programing system 中, 分配 memory 中特定的 job 給 CPU 運算的這個動作又稱為？CPU Scheduling 作業系統 multi-programing system 中, 分配硬碟中特定的 job 到 memory 的這個動作又稱為？job Scheduling 作業系統中, multi-programing system 中的 spooling 概念是？當 I/O 輸入完畢時, 通知 CPU, 於此同時, CPU 可以處理另外一段已經輸入完畢的 I/O 作業系統中, spool 是什麼的縮寫？Simultaneous Peripheral Operation On-Line 早期的電腦又稱為？Mainframe 早期的 Batch mainframe CPU 總處於？idle 狀態 早期的 Batch mainframe I/O 快還慢？超慢 早期的 Batch mainframe 一次能處理幾件事？1 件事 早期的 Batch mainframe memory 的 layout 分為哪兩大部分？ Operating system User program data 早期的 Batch mainframe, user 跟 mainframe 可以互動嗎？不行 參考資料 Operating System Concept 10th Edition 清華大學 - 周志遠教授視頻","link":"/zh-tw/operating-system-concept/"},{"title":"使用 Kubernetes 來編排你的雲端","text":"概述在這個教程中, 你將會學習到如何： 使用 Kubernetes Engine 來提供一個完整的 Kubernetes 叢集 使用 kubectl 部署以及管理 Docker 容器 使用 Kubernetes 的 Deployments 以及 Services 將應用拆分為微服務 Kubernetes 重點就是應用。 在本教程中的這個部分, 你將使用範例應用名為 “app” 來完成這個教程 App 由 GitHub 管理, 且提供一個 12-Factor 範例應用。 在本教程中你將會使用以下的 Docker images kelseyhightower/monolith - Monolith 包含 auth 以及 hello 服務 kelseyhightower/auth - Auth 微服務。 為通過驗證的使用者產生 JWT tokens kelseyhightower/hello - Hello 微服務。 向通過驗證的使用者打招呼 ngnix - 將流量導向 auth 以及 hello 服務 Kubernetes 是一個開源的專案 (可從 kubernetes.io 獲得), 可以運行在很多不同的環境上, 從筆電到高可用的多主機叢集; 從公開的雲端到人為部署; 從虛擬機到裸機 在本教程中, 使用一個受管理的環境, 像是 Kubernetes Engine (一個由 Google 維護的 Kubernetes 版本, 運行在 Compute Engine 上), 將會讓你可以更專注在體驗 Kubernetes, 而不是設定底層的環境。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 **注意：** 按下左上方位於 `Google Cloud Platform` 隔壁的 `Navigation menu`, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Google Kubernetes Engine在 cloud shell 環境, 輸入以下指令來設定 zone gcloud config set compute/zone us-central1-b 設定完 zone 之後, 開始一個本教程需要用到的叢集 gcloud container clusters create io 注意： 創建叢集會耗費幾分鐘 - Kubernetes Engine 會提供數個虛擬機讓我們使用 取得範例代碼在 Cloud Shell 執行以下代碼來複製 GitHub 倉庫 git clone https://github.com/googlecodelabs/orchestrate-with-kubernetes.git cd orchestrate-with-kubernetes/kubernetes 列出我們會使用的檔案 ls 範例結構如下： deployments/ /* Deployment manifests */ ...nginx/ /* nginx config files */ ...pods/ /* Pod manifests */ ...services/ /* Services manifests */ ...tls/ /* TLS certificates */ ...cleanup.sh /* Cleanup script */ 該有的都有了, 讓我們來試試看 Kubernetes 吧！ Kubernetes 快速示範開始 Kubernetes 最簡單的方法, 就是使用 kubectl create 指令。 使用它來啟動一個 nignx 容器的單一虛擬機 kubectl create deployment nginx --image=nginx:1.10.0 Kubernetes 已經建立了一個 deployment – 關於 deployment 等等會再多加解釋, 但現在你唯一需要知道的是, deployments 維持 pods 啟動以及運行, 就算當他們運行的 nodes 有錯誤 在 Kubernetes 中, 所有的容器都運行在 pod 當中。 使用 kubectl get pods 指令來檢視運行中的 nginx 容器: kubectl get pods 一旦 nginx 容器已經在運行中, 你可以使用 kubectl expose 指令來暴露它 kubectl expose deployment nginx --port 80 --type LoadBalancer 所以剛剛發生什麼事了呢？ 在我們看不見的地方, Kubernetes 建立了一個外部的平衡負載附有一個公開的 IP。 任何向這個 IP 發請求的客戶端都會被導向服務後方的 pods, 在這個例子中, 是 nginx pod 現在使用 kubectl get 指令來列出服務 kubectl get services 注意： ExternalIP 欄位可能會需要幾秒鐘的時間載入我們的服務。 這是正常的 – 可以幾秒鐘執行一次 kubectl get services 直到該欄位載入 執行以下指令來存取 Nginx container curl http://&lt;External IP&gt;:80 是不是有了！ Kubernetes 提供立即可用的簡單方法, 使用 kubectl 運行以及暴露的指令 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 現在你已經完成一個 Kubernetes 簡短的旅程, 是時候更深入每一個元件以及抽象層 PodsKubernetes 的核心就是 Pod Pods 代表, 並持有一個或多個容器。 一般來說, 如果你有多個容器, 並且容器之間有很強的依賴, 那你會將這些容器打包進一個 pod 這裡的範例是一個 pod 內裝有 monolith 以及 nginx 的容器 Pods 也有 Volumes。 Volumes 是與 pods 共存亡的資料硬碟, 且可被 pod 內的容器使用。 Pods 為其內容提供一個共享的命名空間, 這表示範例 pod 內的兩個容器可以互相溝通, 並且分享附加的 volumes Pods 同時也分享一個網路命名空間。 這表示每個 pod 有著一個 IP 位址 現在讓我們更深入 pods 的世界 建立 pods可以使用 pod 設定檔來建立 pod 。 讓我們來探索一下 monolith pod 設定檔, 執行以下指令: cat pods/monolith.yaml 輸出如下： apiVersion: v1kind: Podmetadata: name: monolith labels: app: monolithspec: containers: - name: monolith image: kelseyhightower/monolith:1.0.0 args: - &quot;-http=0.0.0.0:80&quot; - &quot;-health=0.0.0.0:81&quot; - &quot;-secret=secret&quot; ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: &quot;10Mi&quot; 有幾件需要注意到的事, 你將看到： 你的 pod 由一個容器組成 (monolith) 當容器啟動時, 你帶入一些參數 你打開 port 80 供 http 流量使用 使用 kubect1 建立 monolith pod kubectl create -f pods/monolith.yaml 檢視你的 pods 。 使用 kubectl get pods 指令來列出所有運行在預設命名空間的 pods kubectl get pods 注意: monolith pod 啟動與運行可能會需要幾秒鐘。 monolith 容器的 image 需要先從 Docker Hub 下載下來, 然後才能啟動。 一旦 pod 開始運行, 使用 kubectl describe 指令來獲得 monolith pod 更多的資訊 kubectl describe pods monolith 你將會看到很多很多關於 monolith 的資訊, 包含 Pod IP 位址以及事件紀錄。 當除錯時, 這些資訊隨手可得。 Kubernetes 讓建立 pods 如此的簡單, 只需要再設定檔中敘述, 並且當在運行中時, 檢視資訊也是如此的簡單。 現在你已經有能力建立所有你部署需要的 pods 與 pods 的互動照預設, pods 會被分配一個非公開的 IP 位址, 且無法被從叢集外存取。 使用 kubectl port-forward 指令來將本地的 port 以及 monolith pod 裡頭的 port 做連結 從現在開始, 本教程會要求在多個 cloud shell 視窗之間操作以設定 pods 之間的溝通。 任何在第二個或第三個 shell 中執行的指令都表示該 shell 的命令 開啟兩個 Cloud Shell terminals 。 一個執行 kubectl port-forward 指令, 另一個執行 curl 指令。 在 第二個 terminal, 執行以下指令來設定 port-forwarding kubectl port-forward monolith 10080:80 現在在第一個 terminal, 開始使用 curl 與你的 pod 對話 curl http://127.0.0.1:10080 Yes! 你從你的容器收到一個友善的 “hello” 現在使用 curl 指令來看看當你存取一個安全端點時, 發生什麼事： curl http://127.0.0.1:10080/secure Oh!試著登入, 從 monolith 取得 auth token curl -u user http://127.0.0.1:10080/login 在登入彈窗, 使用超級安全的密碼 “password” 來登入 登入會返回一個 JWT 。 因為 cloud shell 無法很好的處理長字串的複製, 建立一個環境變數來裝這個 token TOKEN=$(curl http://127.0.0.1:10080/login -u user|jq -r &#x27;.token&#x27;) 再次輸入超級安全密碼 “password” 當彈窗要求 host 密碼 使用上面的指令來複製, 然後用 curl 來提供 token 存取安全端點 curl -H &quot;Authorization: Bearer $TOKEN&quot; http://127.0.0.1:10080/secure 現在你應該可以從應用得到回應, 告訴我們世界又恢復了正常 使用 kubectl logs 指令來檢視 monolith pod 的紀錄 kubectl logs monolith 開啟第三個 terminal 並且使用 -f 旗標來取得即時的紀錄 kubectl logs -f monolith 現在在第一個 terminal 使用 curl 來語 monolith 互動, 你可以看到記錄在更新著 (在第三個 terminal) curl http://127.0.0.1:10080 使用 kubectl exec 指令, 在 monolith pod 內運行一個互動的 shell 。 當在除錯時, 這會十分方便。 kubectl exec monolith --stdin --tty -c monolith /bin/sh 例如說, 一旦我們在 monolith 容器有一個 shell, 我們可以使用 ping 測試外部的連結 ping -c 3 google.com 確認登出互動 shell exit 你可以看到, 使用 kubectl 指令與 pod 互動是如此的容易。 Kubernetes 提供了所有的一切, 如果你需要遠端存取一個容器, 或是取得一個登入的 shell 服務Pods 並不會永遠存在。 有很多種原因, 他們會被停止以及開啟 - 像是沒通過存活以及就緒的檢查 - 而這衍生一個問題 當一組 Pods 重啟了, 他們的 IP 變了, 這時候你要怎麼去跟他們溝通？ 這就是 Services 的功用。 Services 為 Pods 提供了穩定的端點 Services 使用標籤 (labels) 來確定要作用在哪一些 Pods 上。 如果 Pods 有正確的標籤, 他們會自動地被 service 選擇且暴露 Service 提供給一系列的 Pods 的存取等級取決於 Service 的類型。 目前有三種類型： ClusterIP (internal) – 預設類型, 表示這個 Service 只能在叢集內部被看見 NodePort – 給予叢集內的節點一個外部可存取的 IP LoadBalancer – 從雲端提供者那增加一個平衡負載, 將外部流量經由 Service 導向節點 現在, 你將學習如何： 建立一個 Service 使用標籤選擇器來暴露某幾個 Pods, 使他們可被外部看見 建立一個 Service在我們建立我們的 Service 之前 – 讓我們先建立一個安全 pod, 它可以處理 HTTPS 的流量 如果你已經變更資料夾了, 確保你已經回到 ~/orchestrate-with-kubernetes/kubernetes 資料夾 cd ~/orchestrate-with-kubernetes/kubernetes 檢視 monolith service 設定檔 cat pods/secure-monolith.yaml 建立一個 secure-monolith pods 以及他們的設定資料： kubectl create secret generic tls-certs --from-file tls/kubectl create configmap nginx-proxy-conf --from-file nginx/proxy.confkubectl create -f pods/secure-monolith.yaml 現在你有一個 secure pod, 是時候暴露 secure-monolith Pod 到外部。 建立一個 Kubernetes service 檢視 monolith service 設定檔 cat services/monolith.yaml 輸出： kind: ServiceapiVersion: v1metadata: name: &quot;monolith&quot;spec: selector: app: &quot;monolith&quot; secure: &quot;enabled&quot; ports: - protocol: &quot;TCP&quot; port: 443 targetPort: 443 nodePort: 31000 type: NodePort 要注意的事情： 選擇器 (selector) 被使用來自動選擇以及暴露任何有標籤 “app=monolith” 以及 “secure=enabled” 的 pods 現在你必須暴露 nodePort, 因為這樣你才可以轉送外部流量從 31000 到 nginx (port 443) 使用 kubectl create 指令, 從 monolith service 設定檔來建立 monolith service kubectl create -f services/monolith.yaml 輸出： service &quot;monolith&quot; created 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功地建立了 Monolith pods 以及 service，你將獲得一個評價分數。 使用 port 來暴露 service。 這表示如果有其他的 app 嘗試連結你其中一個 service 的 port 31000, 那可能會有衝突。 正常來說, Kubernetes 會處理 port 的分配, 在這個教程中, 你自己選擇 port, 所以等等我們在設定健康檢查的時候會比較容易。 使用 gcloud compute firewall-rules 指令來允許流量經由 nodePort 31000 來存取 monolith service gcloud compute firewall-rules create allow-monolith-nodeport \\ --allow=tcp:31000 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立防火牆規則來允許 TCP 流量進出 port 31000，你將獲得一個評價分數。 現在, 所有東西都設定好了, 你應該可以從叢集外部直接存取 secure-monolith service, 且不需要特別轉發 port 首先, 取得其中一個節點的外部 IP gcloud compute instances list 現在試著使用 curl 向 secure-monolith service 發請求: curl -k https://&lt;EXTERNAL_IP&gt;:31000 Oh, 連線逾時了, 怎麼會這樣？ 是時候快速利用以下幾個問題釐清一下概念, 利用下面的指令來取得問題的答案：kubectl get services monolithkubectl describe services monolith 問題： 為什麼你無法從 monolith service 取得回應？ monolith service 有幾個端點？ Pod 需要有哪些標籤, 才會被 monolith service 取用？ 提示： 跟標籤有關。 你將會在下一個章節解決這個問題。 增加標籤到 Pods目前 monolith service 沒有任何端點。 有一個排除像這樣的錯誤的好方法, 那就是使用 kubectl get pods 指令的標籤查詢 我們可以看到, 有一些 pods 被貼上了 monolith 標籤 kubectl get pods -l &quot;app=monolith&quot; 但是標籤不是 “app=monolith” 和 “secure=enabled” 嗎？ kubectl get pods -l &quot;app=monolith,secure=enabled&quot; 注意到這個標籤查詢並沒有印出任何的結果。 看起來是我們需要把 “secure=enabled” 標籤加到這些 pods 上 使用 kubectl label 指令來加漏掉的 secure=enabled 標籤加到 secure-monolith Pod。 之後呢, 你可以確認標籤是否有更新 kubectl label pods secure-monolith &#x27;secure=enabled&#x27;kubectl get pods secure-monolith --show-labels 現在我們的 pods 已經被上標籤了, 讓我們檢視一下 monolith service 端點的清單 kebectl describe services monolith | grep Endpoints 有一個! 讓我們向其中一個節點發請求, 測試看看！ gcloud compute instances listcurl -k https://&lt;EXTERNAL_IP&gt;:31000 連接上了！ 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功地將標籤加到 monolith pods，你將獲得一個評價分數。 部署應用到 Kubernetes本教程的目標是讓你準備好在正式產品線上操作擴充以及管理容器。 這也是 Deployment 的作用。 Deployments 是一種宣告的方法, 確保運行的 Pods 數量跟使用者指定的數量是一致的。 Deployments 的主要優點, 是將管理 Pods 的低階細節抽象化。 如果 Pods 需要擴充或更新, Deployment 會處理這一段。 Deployment 也處理重啟 Pods 這一塊, 如果 Pods 因為某些原因關閉的話。 讓我們來快速看一個範例： Pods 的生命週期與他們被建立且身處的 Node 一樣長。 在上面的範例中, Node3 關閉了 (帶著 Pod 一起)。 Deployment 建立一個新的 Pod, 然後在 Node2 上運行, 而不需要手動建立一個新的 Pod 然後再找一個 Node 來運行它。 真是太酷了！ 是時候結合你學到的東西, Pods, Services, 使用 Deployment 將 monolith 應用拆分成更小的 Services 建立 Deployments我們將會把 monolith app 拆成三個小的部分： auth - 為通過驗證的使用者產生 JWT tokens hello - 向通過驗證的使用者打招呼 frontend - 將流量導向 auth 以及 hello 服務 我們已經準備好要為每一個 service 建立 deployments了。 在那之後, 我們將為 auth 以及 hello deployments 定義內部 service, 以及為 frontend deployment 定義外部 service 。 一旦完成, 你將可以跟每個微服務互動, 就跟現在一樣, 不同的是, 每一個部分將可以獨立地被部署, 擴充。 先從檢視 deployment 設定檔開始吧 cat deployments/auth.yaml 輸出： apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: &quot;kelseyhightower/auth:2.0.0&quot; ports: - name: http containerPort: 80 - name: health containerPort: 81... deployment 建立 1 個 replica, 且使用版本 ２.0.0 的 auth 容器 當你執行 kubectl create 指令建立 auth deployment, 它會建立一個 pod, 這個 pod 會符合 Deployment 的清單資料。 這表示你可以藉由改變 Replicas 欄位的數字來擴充 Pods 的數量 不管怎樣, 建立 deployment 物件吧 kubectl create -f deployments/auth.yaml 是時候為 auth deployment 建立 service 了。 使用 kubectl create 指令來建立 auth service: kubectl create -f services/auth.yaml 現在重複一樣的步驟來建立並暴露 hello deployment kubectl create -f deployments/hello.yamlkubectl create -f services/hello.yaml 再一次, 建立及暴露 frontend deployment kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.confkubectl create -f deployments/frontend.yamlkubectl create -f services/frontend.yaml 建立 frontend 還有最後一步, 因為你需要使用容器儲存一些設定資料 取得 frontend 的外部 IP, 並且使用 curl 來跟它互動吧! kubectl get services frontendcurl -k https://&lt;EXTERNAL-IP&gt; 然後你得到一個 hello 回應！ 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 auth, hello, 以及 frontend deployment, 你將獲得一個評價分數。 總結恭喜！ 你已經使用 Kubernetes 部署了一個多服務的應用。 你在這學到的技術將可以讓你使用一系列的 deployments 以及 services 在 Kubernetes 部署複雜的應用。","link":"/zh-tw/orchestratingTheCloudWithKubernetes/"},{"title":"Bubble Sort (氣泡排序法) In PHP","text":"# 前言出來混總是要還的! 身為一個非本科的工程師, 就是自己找時間把自己缺的的都補上！實作沒什麼好交代的, 直接看範例看註解吧！ # 概念解說Bubble sort 可以說是最普遍被使用的的一種演算法。 它是一種基於比較性質的演算法, 也總是被歸類在最沒效率的排序演算法之一。 不過, 凡事都會有改進的空間。在 bubble sort 中, 列表中的每一個品項都會跟其他的所有品項做比較, 視比較結果進行位置對調, 直到每個品項都跟其他的品項比較完畢。可參考示意圖如下： 示意圖解析：上圖為跑一輪的示意圖, 在每一輪中, 都會像示意圖中, 依序兩兩比較, 並視比較結果決定是否對調, 所以第一輪的目標便是將 list 中最大的數移到最右邊若 list 中的 item 數量為 n, 那則需要跑 n 輪方能將整個 list 排序完畢 # 實作範例# 理論版 Example code:function bubbleSort(array $arr): array &#123; $len = count($arr); // 每次兩兩比較, 共需比較 n-1 輪, 跑完即排序完畢 for ($i = 0; $i &lt; $len - 1; $i++) &#123; // $j 從 0 開始, 即一開始 index 0 跟 index 1 比較 // 接下來 index 1 跟 index 2 比較 // 視結果決定是否對調位置 for ($j = 0; $j &lt; $len - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr; &#125; # 改進一版接下來我們來嘗試改進上面的版本。可以從 bubble sort 的一個特點來著手, bubble sort 的每一輪外圈 iteration, 預設至少都會做一次調換動作, 換言之, 若沒有調換動作, 則後面剩下還沒跑的輪數都不用跑了不囉唆, 直接看以下改進版範例： Example code:function bubbleSort(array $arr): array &#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; // 如上所敘, 這邊預設此輪不會有新的調換動作 $swapped = FALSE; for ($j = 0; $j &lt; $len - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; // 如果有進到條件判斷, 代表有進行調換動作, 因此將 $swapped 改為 true $swapped = TRUE; &#125; &#125; // 如果一輪跑完 $swapped 還是 false, 則代表列表都已經排序完畢, 後面的就不用再跑了 if(! $swapped) break; &#125; return $arr; &#125; # 改進二版然而, 從以上的 example code 中觀察, 我們可以發現, bubble sort 的外圈每一輪都至少會將當輪最大的數移到最右邊, 換言之, 也可以說最右邊的數我們可以不必去判斷了更精確地來說, 假設 $i = 1, 那代表 $i 從 0 - 1, 已經跑了一輪, 所以我們在內圈的比較上, 就可以少比較一輪詳見以下 example code Example code:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; $swapped = FALSE; // 這裡新增了 $len - $i 的邏輯, 當外圈每跑一輪, 內圈就可以少比較一輪 for ($j = 0; $j &lt; $len - $i - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; $swapped = TRUE; &#125; &#125; if(! $swapped) break; &#125; return $arr; &#125; # 最終改進版 示意圖: 讓我們先來看看上面的示意圖。假如今天外圈跑了兩輪, 我們完成了 97, 93 的排序, 雖然還沒跑第三輪, 但 92 明顯已位於正確的位置, 那依照我們上面的版本, 在下一輪還是會去比較 92, 是否可以省略這不必要的判斷？或許, 我們可以記錄下, 當輪最後有進行對調動作的 index 位置, 假如第三輪最後只對調了 index 4, 5, 那代表 index 4 之後的數都已經是排序完成的, 換言之, 這個 index 之後的品項我們在後續的迴圈中都不需要去比較了請看以下的最終改進版 Example code&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); $count = 0; $bound = $len-1; for ($i = 0; $i &lt; $len - 1; $i++) &#123; $swapped = FALSE; $newBound = 0; // 如上所述, 這裡新增了 $j &lt; $bound 邏輯 // $bound 預設為 $len - 1, 但會隨著最後一次做對調的 index 位置而變化 // 換言之, 假如上一輪最終對調 index 位置為 5, 那我下一輪開始時 // 5 之後(含 5) 的 index 我都不需要去比較了 for ($j = 0; $j &lt; $bound; $j++) &#123; $count++; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; $swapped = TRUE; // 這裏更新 $newBound, $newBound 會儲存最後一次有調整的 index $newBound = $j; &#125; &#125; // $bound 會在每一輪的外圈結尾時更新, 代表著上一輪外圈中, index 對調的最後位置 // 換言之, 該位置往右的皆是已經排序完成的 $bound = $newBound; if(! $swapped) break; &#125; echo $count.&quot;\\n&quot;; return $arr;&#125; # 改進結果比較改設 list 為 20, 45, 93, 67, 10, 97, 52, 88, 33, 92以下為個版本的比較次數： 解法 比較次數 一般 bubble sort 90 改進一版 63 改進二版 42 最終改進版 38 # 複雜度 最佳複雜度 $$\\Omega(n)$$ 最差複雜度 $$O(n^2)$$ 平均複雜度 $$\\Theta(n^2)$$ 空間複雜度 $$O(1)$$ # 參考資料PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/php-bubble-sort-implementation/"},{"title":"PHP-FPM reload 真的有優雅嗎？","text":"# 前言其實這篇文章跟 OPcache 沒什麼太大的關係, 但卻是做這個實驗的根本原因！ # OPcacheOPcache 可以對於 PHP 效能優化有著非常顯著的效果, 而有 cache 就有 clear 的問題。 在每一次更新程式碼後, 都必須 clear 舊的 cache。然而 clear cache 有以下幾種方法: 特別製作一支 API, 在裡面執行 opcache_reset() 使用套件, 這樣可以透過 CLI 清除 cache, 不過套件具體原理也是跟第一個一樣, 只不過有實作了 CLI 出來 reload PHP-FPM # PHP-FPMPHP-FPM 為 FastCGI Process Manager, 簡單來說, 這個 Manager 也是一個 Process, 而它會 fork 複數的 child FastCGI process 當收到 request 時, 便分派任務給底下的 child process 處理。故事的起源, 都來自於 這篇 Stack Overflow 文中提到, 如果使用 reload 參數, 便可以 gracefully restart PHP-FPM。 那這又跟今天的故事有什麼關係呢？上面提到三個方法, 毫無疑問 reload PHP-FPM 是最簡單的, 但同時它也有著一個致命的缺點, 那就是當 reload 時, 所有 processed 中的 request 無可避免的都會中斷。 但根據這篇文章描述, 如果可以不中斷的 restart PHP-FPM 的話似乎是個 zero downtime 的最佳解啊！ 高能大大先別噴, 我知道還有 rolling update 這東西, 不過這不在今天的討論範圍內, 乾蝦！ 然而未經過自己實驗的解法, 真要拿到 production 上面用, 我心裡會毛毛的。 於是我 Google 了一下, 果然發現一些不一樣的聲音： 這裏 還有這裡 於是就開始了今天的實驗… # Docker 環境測試首先我使用了 Docker container 做測試, 我當然不是個空口說白話的人, 附上測試 docker-compose.yaml 檔 version: &quot;3&quot;services: nginx: restart: unless-stopped image: nginx:latest container_name: nginx networks: - app-network ports: - 8888:80 - 9999:443 php74: image: php:7.4.3-fpm container_name: php74 restart: unless-stopped networks: - app-networknetworks: app-network: driver: bridge 由於測試過程比較簡單, 我就沒 mount volume 出來了 首先先進到 php-fpm container docker exec -it phpFpmContainerId /bin/bash 緊接著修改 php-fpm 的 configvim /usr/local/etc/php-fpm.conf.default 哦哦, 對了如果你跟著照做發現 vim command not found 的話, 記得自己安裝啊哈哈 然後 reload PHP-FPMkill -usr2 1 因為 kill -usr2 是源碼中, 當使用 reload 時所使用的 command, 可以參考 源碼當然, 也因為在 container 中無法直接使用 systemctl reload serviceName 接著將 process_control_timeout 改成 30s, 會修改這行是因為預設是 0s, 我修改是為了確認到底有沒有作用 然後進到 nginx 的 container, 同上, 換個 container ID 而已, 我就不多加贅述 然後改一下 default 的 config, 這不是個好的做法, 我一般習慣在 sites-available 寫好 config, 然後在 soft link 到 site-enabled, 不過只是為了測試就將就啦~ vim /etc/nginx/conf.d/default.conf 然後使用以下設定 server &#123; listen 80; index index.php index.html; error_log /var/log/nginx/error.log; access_log /var/log/nginx/access.log; root /var/www/; location ~ \\.php$ &#123; try_files $uri =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass php74:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; &#125; location / &#123; try_files $uri $uri/ /index.php?$query_string; gzip_static on; &#125;&#125; 再來重啟 nginx nginx -s reload 最後, 把以下的 index.php file 複製到上面兩個 container 的 /var/www 目錄下 &lt;?phpsleep(60);echo &#x27;Hello World&#x27;; 測試的時候到了！ 靠, 我都已經測過了, 還興奮個屁啊! curl localhost:8888 恩恩, 有進入 sleep 的階段 接著 reload PHP-FPMdocker exec -it containerId kill -USR2 1 結果你會發現, connection 斷開了！斷開了！斷開了！ 因為很震驚, 所以打了三次! # GCP VM 測試不信邪的我, 立馬在 GCP 上面開了一台小 VM 做測試, 方式跟 Docker 大同小異我就不多加贅述了, 結果是還是斷開了!還是斷開了!還是斷開了! 因為很失望所以要說三次… # 暴風雨後的曙光？原本傷心欲絕, 悲憤交加的我, 在前往自我了斷的路上… 想說發個文在 FB 警醒一下世人好了, 以防有跟我一樣想不開的人… 唉, 沒有希望就不會失望啊! 誰知有個大大給個提醒, 會不會是 PHP 的 sleep() function 的問題？ 或許可以試試 select sleep(30) ? 此話當如久旱後的甘霖, 讓我放下了手中的菜刀… 想說不然試一試好了, 反正要了斷也不差這些時間, 然後冒險繼續 ing 更新 index.php 內容 &lt;?php$hostname=&quot;localhost&quot;;$username=&quot;test&quot;;$password=&quot;test&quot;;$dbname=&quot;test&quot;;$connection = mysqli_connect($hostname,$username, $password) or die (&quot;html&gt;script language=&#x27;JavaScript&#x27;&gt;alert(&#x27;無法連線至資料庫！請稍後再重試一次。&#x27;),history.go(-1)/script&gt;/html&gt;&quot;);$query = &quot;SELECT sleep(10)&quot;;$result = mysqli_query($connection, $query);?&gt; 接著在 reload PHP-FPM, 然後抱著破罐子破摔的心情, 再給他發了一次 request It worked!! It worked!! 我一邊擦著我喜極而泣的淚水, 嗯…, 還有鼻水, 一邊接著測試, 因為我想要知道 reload 到底有多優雅？ # 窺探 reload 的優雅程度 首先, 在發 request 之前, 我先觀察 process 狀態ps -ax | grep php-fpm 然後在 request 處理完畢後, 我再觀察一次 反覆觀察幾次之後, 終於探得 reload 的優雅程度 蛤？ 你還在這啊？ 那直接看結論吧！ # 結論 文中提到的 timeout 如果比 request 的時間還短, 那 timeout 時間到了, FPM 會強制的殺掉所有 process, 立馬跳 502 給你看 在下達 reload 之後, PHP-FPM 會逐步的殺掉 process, 如果還沒完成的, PHP-FPM 會等待他們完成, 當然, 最多等待 timeout 的時間 在所有 reload 之前的 request 都處理完之前, PHP-FPM 不會開啟新的 child process, 那你問我與此同時新的 request 怎麼辦？ 好問題！ PHP-FPM 會 queue 他們, 但不處理 直到所有的 request 都處理完了, 才會啟動新的 reload 過的 process 開始處理之前 queue 裡的 request 這種行為算是有某種程度上的優雅, 但也不算很優雅。 雖然可以避免 request 被強制斷開, 但在新的 process 啟動之前, 所有的 request 都是被 queue 住的, 這同時也衍伸一些問題… Server 能支援 queue 的 request 最大數量？ queue 住 request, 這表示在使用者端, 畫面是整個卡住的, 雖不強制關閉, 但算是採用延遲處理 至此, 本次實驗也告一段落, 也算是得知 PHP-FPM reload 採用得像是 k8s 中的 recreate policy, 而不是 rolling update, 實在不能說沒有 downtime (卡住算不算 downtime?)好啦, 希望本篇文章對你有幫助！ 我們下次見！","link":"/zh-tw/php-fpm-reload-graceful-or-not/"},{"title":"Insertion Sort (插入排序法) In PHP","text":"# 前言出來混總是要還的! 身為一個非本科的工程師, 就是自己找時間把自己缺的的都補上！實作沒什麼好交代的, 直接看範例看註解吧！ # 概念解說Insertion sort 某程度上會比 bubble sort 以及 selection sort 更有效率。當 n 比較小時, insertion sort 效率較佳, 反之效率較差。如同它的名字, insertion sort 的原則就是將數字插入到左側的正確位置。 它從 array 的第二個 index 開始, 檢查位於當前 index 左側的數字是否小於當前 index, 如果是, 就調換數字位置, 將較小的數字放到正確的位置。然後再從下一個 index 開始, 重複直到所有 array 都完成排序。 引述大話資料結構 就像玩撲克牌一樣, 我們每抽到一張牌都會照大小順序排列, 例如我們已經有 A, 3, 4 三張牌, 這時抽到 2, 就會把它排在 A 跟 3 中間, 以此類推, 會將抽到的牌放到對的位置 示意圖如下： 示意圖解析: 從第二個 index 開始, 即 45, 檢查第二個 index 左側是否有比 45 大的數字, 只有 20 這一個數字, 所以此輪沒必要插入 接著從第三個 index 開始, 即 93, 比較 45 是否比 93 大, 結果不是, 到此結束第二輪, 因為在第一輪我們已經比較過 45 跟 20。 到目前, 我們已有 (20, 45, 93) 三個排好的數字 接著從第四個 index 開始, 即 67, 比較 93 是否比 67 大, 結果是的, 所以我們將 93 放到 67 目前的位置, 然後繼續往左檢查, 比較 45 是否比 67 大, 結果不是。 至此停下。 然後將 67 插入到 93 原本的位置 重複以上動作, 直到所有數字都完成排序 # 實作範例直接看範例 &lt;?php// 使用 PHP Reference, 因此會直接更動外面的 $arr 內容function insertionSort(array &amp;$arr) &#123; $len = count($arr); // 外層迴圈決定了 &quot;待比較&quot; index, 1-9 都會依次被比較 for ($i = 1; $i &lt; $len; $i++) &#123; // $key 即是每輪的主要 &quot;待比較&quot; 數 $key = $arr[$i]; $j = $i - 1; // 內層 while 迴圈決定了 &quot;待比較數&quot; 的確切位置 // 會將 $key 與往前的 index 依序比較, 若 $key 較小, 則會將該 index 往後挪 // 依序往前比較, 直到 $key 不小於該 index, 這時 $key 會取代該 index 的後一個 index // 因為後一個 index 在上一輪已經被往後挪了 while($j &gt;= 0 &amp;&amp; $arr[$j] &gt; $key) &#123; $arr[$j+1] = $arr[$j]; $j--; &#125; $arr[$j+1] = $key; &#125; &#125;$arr = [20, 45, 93, 67, 10, 97, 52, 88, 33, 92];insertionSort($arr);echo implode(&quot;,&quot;, $arr); # 複雜度 最佳複雜度 $$\\Omega(n)$$ 最差複雜度 $$O(n^2)$$ 平均複雜度 $$\\theta(n^2)$$ 空間複雜度 $$O(1)$$ # 參考資料大話資料結構PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/php-insertion-sort-implementation/"},{"title":"Selection Sort (選擇排序法) In PHP","text":"# 前言出來混總是要還的! 身為一個非本科的工程師, 就是自己找時間把自己缺的的都補上！實作沒什麼好交代的, 直接看範例看註解吧！ # 概念解說先來說說 selection sort 的概念, 聽我說完沒學過的很可能會一臉矇逼, 沒矇逼就代表我概念說的還行, 矇逼也是正常的, 要配合服用 example code, 才會藥到病除概念是這樣:selection sort 是一種比較式的演算法, 看起來跟 bubble sort 有點像, 而最大的不同之處在於它的交換動作比 bubble sort 要來得少我們一開始找到最大/最小的值, 並將他們放在第一個位置, 最大/最小取決於正序/倒序排列。在第二輪呢, 我們取最大/最小值, 並將它至於第二個位置, 反覆直到每個數字都被排到正確的位置下面是示意圖： 示意圖解析：第一輪一開始第一個數字是 20, 然後我們找到最小值, 即10, 至此, 我們都還沒有進行交換動作, 只是將第一個以及最小值的位置記下, 在第一輪最後, 我們在進行交換動作第二輪我們從 45 開始, 並開始往後尋找下一個最小值, 找到了 20, 如同上一輪的動作, 我們將 45 與 20 的位置進行了交換重複此動作, 直到完成 sorting # 實作範例直接看範例 Answer:&lt;?phpfunction selectionSort(array $arr): array &#123; $len = count($arr); // 外層迴圈主要定位了 &quot;當次迴圈中要變更的 index 位置&quot; for ($i = 0; $i &lt; $len; $i++) &#123; // 由於每一輪的開始, 都會假設 $i 是目前最小的值 $min = $i; for ($j = $i+1; $j &lt; $len; $j++) &#123; // 目的要找出最小值的 index 位置 if ($arr[$j] &lt; $arr[$min]) &#123; // $min 代表最小值的 index 位置, 會動態更換 $min = $j; &#125; &#125; // 如果找到的最小值 index 跟當前的 $i index 不相符, 則對調他們 if ($min != $i) &#123; $tmp = $arr[$i]; $arr[$i] = $arr[$min]; $arr[$min] = $tmp; &#125; &#125; return $arr;&#125; # 複雜度 最佳複雜度 $$\\Omega(n^2)$$ 最差複雜度 $$O(n^2)$$ 平均複雜度 $$\\Theta(n^2)$$ 空間複雜度 $$O(1)$$ # 參考資料PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP","link":"/zh-tw/php-selection-sort-implementation/"},{"title":"PHP 學習筆記","text":"# 前言這是我的 PHP 學習筆記, 學什麼記什麼！ # 安裝 extension自從 2018 年的 4 月, Homebrew 已經不再是 PHP 在 macOS 上的套件管理器, 所以所有的 PHP Extension 之後都應該使用 pecl 來安裝 # 第一步 - 刪除可能衝突的套件brew rm php php@5.6 php@7.0 php@7.1brew rm imagemagick # 第二步 - 更新 Xcode command line 工具, 以及取得 build 套件 確定已經安裝 Xcode command line 工具 xcode-select --install 到 AppStore 去更新 Xcode 以及套件 安裝 homebrew building 工具 brew install pkg-config # 第三步 - 安裝 ImageMagickbrew install imagemagick 為什麼上面說了 brew 已不支援安裝 extension, 而這邊又使用 brew 來安裝呢？ ImageMagick 是一個開源套件, 用 C 寫的, 跟 PHP 沒關係。而下面安裝的 Imagick 才是 PHP 的 extension, 算是 PHP 跟 ImageMagick 之間的 binding # 第四步 - 使用 Homebrew 安裝 PHPbrew install php --build-from-source --build-from-source 會安裝 PHP-FPM # 判別 Apache based PHP 或 Homebrew based PHPtype php /usr/local/...anything.../php 表示你執行的為 homebrew based 的 PHP /usr/bin/php 表示你執行的為 Apache based PHP # 第五步 - 安裝 Imagickpecl install imagick # 記得重啟你的 Web server 使用 Apache 記得重啟 Apache 使用 Nginx 記得重啟 Nginx 若是使用 valet, macOS 開發, 記得重啟 valet # 疑難雜症篇# 環境為 macOS, 使用 pecl 安裝 extension 時遇到以下的錯誤Warning: mkdir(): File exists in System.php on line 294PHP Warning: mkdir(): File exists in /usr/local/Cellar/php/7.3.3/share/php/pear/System.php on line 294Warning: mkdir(): File exists in /usr/local/Cellar/php/7.3.3/share/php/pear/System.php on line 294ERROR: failed to mkdir /usr/local/Cellar/php/7.3.3/pecl/20180731 看起來該是無法在該位置建立資料夾, 那就手動建立一個吧 首先, 取得 pecl 的 extension 資料夾位址, 並複製 pecl config-get ext_dir|pbcopy 建立該資料夾 mkdir -p copiedValueFromLastCommand 這樣一來, 應該就解決了 # PHP 無法找到模組, 我的心慌慌 先找出 pecl 將模組放在哪 pecl config-get ext_dir|pbcopy 打開目前被使用的 php.ini vim &quot;$(php-config --ini-path)/php.ini&quot; 打開設定檔 ; Directory in which the loadable extensions (modules) reside.; http://php.net/extension-dir 加入上面得到的模組位置 extension_dir = &quot;/usr/local/lib/php/pecl/XXXXXX&quot; 上面的做法適用於 homebrew 安裝的 PHP # 優化# opcache; 是否啟用 opcache, 設為 0 時為不啟用opcache.enable = 1; PHP 7.4, 預設為 128 MB, 可視你的需求調整大小。 ; 可使用 `opcachegetstatus()` function 取得實際上; 使用了多少 opcache memory, 如果已經很接近上限了, 就可以調整上限opcache.memory_consumption = 256; PHP 使用一種名為 &quot;字串駐留&quot; (string interning) 的技術以增進效能; 比方說, 你在單次的 request 中使用了字串 &quot;foo&quot; 500 次 ; PHP 會在第一次使用時將這個字串存為一個不變的變數, 而之後的 499 次使用 ; 只會使用一個 pointer 來指向這個變數。 原本這個變數只可被單個 php-fpm process 使用; 但 opcache 允許將這個變數放到一個共享的區域, 可被所有的 php-fpm 存取; 而這個選項可以設定這個共享區域的允許大小; PHP 7.4 預設為 8 MBopcache.interned_strings_buffer = 16; 這個選項限制 opcache 可以緩存多少個 PHP 文件; 這個選項必須設定大於你的 project 中的 PHP 文件總數; 可只用 command &quot;find yourProjectDirectory -type f -print | grep php | wc -l&quot; ; 來計算你的 project 中 PHP 文件的數量; 可參考官方文件 &quot;https://www.php.net/manual/en/opcache.configuration.php#ini.opcache.max-accelerated-files&quot;opcache.max_accelerated_files = 7963; 如果啟用, opcache 會根據下面的另外一個選項 opcache.revalidate_freg 設置的秒數去檢查; 文件的 timestamp, 目的為確認文件是否有更新, 若有更新, 則清除舊的並且重新緩存; 在正式環境建議設為 0, 開發 / 測試環境設為 1 opcache.validate_timestamps = 1; 這個選項為, opcache 該多久檢查你的程式碼是否有改變, 如果有改變, PHP 會重新編譯, 生成新的 opcode; 並且緩存。 若設為 0 時, 表示每次 request 都會檢查, 這會大量使用 stat system call, 並且; 在檢查過程中, 為了確認位於硬碟中文件的 timestamp, process 也會進到 wating state 等待 I/O ; 這些 system call 的調用, process state 的切換都會消耗一些時間以及系統的資源; 建議開發環境設為 0, 正式環境中, 因為 opcache.validate_timestamps 會設為 0, 所以這個選項就; 不會生效, 自然也就不用管它了opcache.revalidate_freg = 5; 這個選項若啟用, 會在每個 request 的最後更快速地釋放資源, 讓 response 以及 workers ; 再次調用的速度加快, 1 啟用, 0 不啟用opcache.fast_shutdown = 1; 這個選項會 cache comment, 建議開啟, 因為有些 Library 會使用到 comment; 若關閉可能可以節省一點點 RAM, 開啟利大於弊opcache.save_comments=1 # PHP.ini; 設定單個 PHP process 可以使用的系統記憶體最大值, 默認 128M, 若是單主機單 PHP process; 的話可以依據主機等級設置高一點, 因為可使用的系統記憶體越多, 代表 PHP-FPM 的 process 可以; 負擔越多的。 但若是透過容器化啟用, 像是 k8s 架構, 那可以設小一點; 可使用 top | grep php 查看 PHP 每個 process 使用的記憶體量; 也可使用 memory_get-peak_usage() function 取得使用記憶體; 假如分配了 512M, 每個 PHP-FPM 使用了 10M 記憶體, 那相當於可以負擔 51 個 PHP-FPM processmemory_limit = 512M; 允許上傳文件file_uploads = 1; 允許的文件大小上限upload_max_filesize = 10M; 允許的最大上傳文件數量max_file_uploads = 3; 以上設定, 允許上傳, 最多 1 次的 request 中上傳 3 個文件, 每個文件最大 10MB; 若要允許大的文件上傳, 在 Nginx 中的 client_max_body_size 也要修改; 單個 PHP-FPM 可允許執行的時間, 默認 30 秒, 建議改成 5 秒, 5 秒在一個 request 來說算是很久了max_execution_time = 5 # 參考文章stackoverflowMake your Laravel App Fly with PHP OPcachePHP 及 Laravel 上線優化PHP-Late Static BindingsCSDN lamp_yang_3533 的部落格程式狂想筆記 # Questions and Answers以下的 PHP example 中, person2 的 output 是？ 如何不 reference 同一個 amount object？ Example:&lt;?phpclass Person&#123; private $name; private $age; private $id; public $account; public function __construct(string $name, int $age, Account $account) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;account = $account; &#125; public function setId(int $id) &#123; $this-&gt;id = $id; &#125; public function __clone() &#123; $this-&gt;id = 0; &#125;&#125;$person = new Person(&quot;bob&quot;, 44, new Account(200));$person-&gt;setId(343);$person2 = clone $person;// give $person some money$person-&gt;account-&gt;balance += 10;// $person2 sees the credit tooprint $person2-&gt;account-&gt;balance; Answer:210function __clone() &#123; $this-&gt;id = 0; $this-&gt;account = clone $this-&gt;account; &#125; 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass Person&#123; private $writer; public function __construct(PersonWriter $writer) &#123; $this-&gt;writer = $writer; &#125; public function __call(string $method, array $args) &#123; if (method_exists($this-&gt;writer, $method)) &#123; return $this-&gt;writer-&gt;$method($this); &#125; &#125;&#125;$person = new Person(new PersonWriter());$person-&gt;writeName(); Answer:使用 __call delegation, 直接使用 PersonWriter 中的 method PHP 中, __callStatic($method, $arg_array) method 觸發的時機是？當嘗試呼叫一個 undefined static method PHP 中, __call($method, $arg_array) method 觸發的時機是？當嘗試呼叫一個 undefined non-static method PHP 中, __isset($property) method 觸發的時機是？當嘗試使用 isset() 在一個 undefined property 時 PHP 中, __unset($property) method 觸發的時機是？當嘗試使用 unset() 在一個 undefined property 時 PHP 中, __set($property, $value) method 觸發的時機是？當嘗試 assign value 到一個 undefined property 時 PHP 中, __get($property) method 觸發的時機是？當嘗試存取未定義的 property 時 以下的 PHP example 的意思是？ Example:&lt;?phpclass IllegalCheckout extends Checkout&#123; final public function totalize() &#123; // change bill calculation &#125;&#125;// PHP Fatal error: Cannot override final method popp\\ch04\\batch14\\Checkout::totalize() ... Answer:final method 無法被覆寫 以下的 PHP example 的意思是？ Example:&lt;?phpfinal class Checkout&#123; // ...&#125; Answer:final class 無法被繼承 以下的 PHP example 的意思是？ Example:class UtilityService extends Service&#123; use PriceUtilities &#123; PriceUtilities::calculateTax as private; &#125;&#125; Answer:使用 trait 時, 可使用 as operator 來改變該 method 在 UtilityService 中的 access level即一般 use 該 trait 可能為 public, 但在 UtilityService 中為 private 以下的 PHP example 的意思是？ Example:trait PriceUtilities&#123; function calculateTax(float $price): float &#123; // better design.. we know getTaxRate() is implemented return (($this-&gt;getTaxRate() / 100) * $price); &#125; abstract function getTaxRate(): float; // other utilities&#125; Answer:trait 中可使用 abstruct method 以下的 PHP example 的意思是？ Example:class UtilityService extends Service&#123; use PriceUtilities, TaxTools &#123; TaxTools::calculateTax insteadof PriceUtilities; PriceUtilities::calculateTax as basicTax; &#125;&#125;$u = new UtilityService();print $u-&gt;calculateTax(100) . &quot;\\n&quot;;print $u-&gt;basicTax(100) . &quot;\\n&quot;; Answer:當兩個 trait 有相同的 method 時, 可使用 insteadof 來指定要使用哪一個 method然後使用 as 來命名另外一個同名 method, 這樣兩個都可存取ㄕ 以下的 PHP example 的意思是？ Example:class UtilityService extends Service&#123; use PriceUtilities, TaxTools &#123; TaxTools::calculateTax insteadof PriceUtilities; &#125;&#125;// listing 04.30$u = new UtilityService();print $u-&gt;calculateTax(100) . &quot;\\n&quot;; Answer:當兩個 trait 有相同的 method 時, 可使用 insteadof 來指定要使用哪一個 method 以下的 PHP example 的結果是？ Example:$a = true ? 0 : true ? 1 : 2; Answer:// (true ? 0 : true) ? 1 : 2 = 2 以下的 PHP example 的結果是？ Example:$a = 3 * 3 % 5; Answer:4 以下的 PHP example 中, 輸出分別是？ Example:&lt;?php$a=1;$b=1$c=++$a;$d=$b++;echo $c;echo $d; Answer:$c=2, 取++後的值, $d=1, 取++前的值 PHP 中, 以下的常量分別代表的意思是？ Example:__LINE____FILE____DIR____FUNCTION____CLASS____TRAIT____METHOD____NAMESPACE__ Answer:__LINE__: 文件中的當前行號__FILE__: 文件完整路徑及文件名, 若被包含在文件中, 則返回被包含的文件名__DIR__: 文件所在的目錄。如果用在被包括文件中，則返回被包括的文件所在的目錄。它等同於 dirname(FILE)。除非是根目錄，否則目錄中名不包括末尾的斜杠。__FUNCTION__: 當前函數的名稱。匿名函數則為 {closure}__CLASS__: 當前 class 的名稱。class 名稱包括其被聲明的作用區域（例如 Foo\\Bar）。注意自 PHP 6.4 起 CLASS 對 trait 也起作用。當用在 trait 方法中時，CLASS 是調用 trait method 的 class 的名字。__TRAIT__: Trait 的名字。 Trait 名包括其被聲明的作用區域（例如 Foo\\Bar）__METHOD__: class 的 method 名稱__NAMESPACE__: 當前 namespace 的名稱 以下位於 PHP.ini 的 configuration example 的意思是？ Example:apc.ttl=0 Answer:讓 apc cache 永不過期, 預設是 3600s (1 小時) 以下的 Laravel example code 的意思是？ Example:&lt;?phpclass CallableClass&#123; public function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5);var_dump(is_callable($obj));// outputint(5)bool(true) Answer:當嘗試以 function 的方式來呼叫一個 object 時, 就會觸發 invoke() PHP 套件中, mbstring 是什麼？multi bytes string, PHP 預設是使用 ASCII 編碼, 若要支援 UNICODE, 需要安裝 mbstring 來處理 multi bytes string (多個 bytes 代表一個 character) 以下的 example command 的意思是？ Example:ps aux | grep php-fpm Answer:確認 php-fpm 是否有在運行中 以下的 PHP example code 的意思是？ Example:&lt;?phpvar_dump(25/7);var_dump((int) (25/7));var_dump(round(25/7)); Answer:&lt;?phpvar_dump(25/7); // float(3.5714285714286) var_dump((int) (25/7)); // int(3)var_dump(round(25/7)); // float(4) ?&gt; 以下的 PHP example code 的意思是？ Example:&lt;?php$a = 1234;$a = 0123;$a = 0x1A;$a = 0b11111111;$a = 1_234_567;?&gt; Answer:&lt;?php$a = 1234; // 十进制数$a = 0123; // 八进制数 (等于十进制 83)$a = 0x1A; // 十六进制数 (等于十进制 26)$a = 0b11111111; // 二进制数字 (等于十进制 255)$a = 1_234_567; // 整型数值 (PHP 7.4.0 以后)?&gt; PHP 當中, float 跟 double 一樣嗎一樣 PHP-FPM 中, 如果要從 LISTEN PORT 改成 LISTEN SOCKET, 該修改哪個檔案？pool 的 config 檔 以下的 PHP terminal command 的意思是？ Example:php -S IP:Port -t Directory Answer:使用 PHP 內建 Web server 以下的 PHP example code 的輸出為？ Example:&lt;?phpclass A &#123; public static function get_self() &#123; return new self(); &#125; public static function get_static() &#123; return new static(); &#125;&#125;class B extends A &#123;&#125;echo get_class(B::get_self()); // ?echo get_class(B::get_static()); // ?echo get_class(A::get_self()); // ?echo get_class(A::get_static()); // ? Answer:&lt;?phpecho get_class(B::get_self()); // Aecho get_class(B::get_static()); // Becho get_class(A::get_self()); // Aecho get_class(A::get_static()); // A// 總結, self 表示 method 所在的 class, static 表示呼叫的 class 本身 SplStack 是什麼?Stand PHP Library 已實作完成的 stack structure class SplLinkedList 是什麼？Stand PHP Library 已實作完成的 linked list structure class 以下的 PECL terminal command 的意思是？ Example:pecl config-get php_ini Answer:使用 pecl 取得 php.ini 位置, 當然, 你的 PHP 必須是要使用 PECL 安裝的 以下的 Brew terminal command 的意思是？ Example:brew info php Answer:可取得 php.ini 位置, 當然, PHP 需要是使用 brew 安裝 以下的 PHP terminal command 的意思是？ Example:php-config --ini-path Answer:可取得 php.ini 位置, PHP 版本為 7.4.9 以下的 PECL terminal command 的意思是？ Example:pecl config-get ext_dir Answer:取得 PECL 模組安裝的位置 以下的 PHP terminal command 的意思是？ Example:php -m Answer:查詢目前已載入哪些模組 Brew 安裝的 PHP 是如何使用 PECL 安裝的 module?當使用 brew 安裝 PHP 時, 其 php.ini 文件內 extention_dir 參數可以指定 extension 資料夾路徑, 因為是使用 PECL 安裝的, 在 Mac 上通常路徑是 /usr/local/lib/php/pecl/&lt;日期版本號&gt;也就是說, 如果你用 brew 重新安裝了 PHP, 那新安裝的 PHP 的 extension_dir 會指向新的日期版本, 所以務必要更新 extension_dir 的指向, 最好是使用 PECL uninstall packageName, 然後在重新安裝 extension pecl install packageName, 最後再將舊的 extension_dir 移除 rm -rf oldExtensionDir 什麼是 Zend Engine?為一虛擬機, PHP 的核心 什麼是 Opcode?Zend Engine 解析 PHP code 之後得到的執行碼, 可直接被 Zend 虛擬機執行 PECL 全寫是？PHP Extension Community Library PEAR 全寫是？PHO Extension and Application Repository 以下的 PHP example code 回傳的值是？ Example:&lt;?phpfunction test()&#123; static $var; $var += 1; echo $var . PHP_EOL;&#125;function testtest()&#123; static $var; $var += 1; echo $var . PHP_EOL;&#125;// 以下的輸出是？test();test();test();testtest();testtest();testtest();?&gt; Answer:&lt;?php// static variable 在不同的 function scope 內會累加test(); // 1test(); // 2test(); // 3testtest(); // 1testtest(); // 2testtest(); // 3 以下的 PHP example code 回傳的值是？ Example:&lt;?phpclass A&#123; static $var; public static function test() &#123; self::$var += 1; echo self::$var . PHP_EOL; &#125; public static function testtest() &#123; self::$var += 1; echo self::$var . PHP_EOL; &#125;&#125; A::test(); // 輸出是？ A::test(); // 輸出是？ A::test(); // 輸出是？ A::testtest(); // 輸出是？ A::testtest(); // 輸出是？ A::testtest(); // 輸出是？?&gt; Answer:&lt;?phpclass A&#123; static $var; public static function test() &#123; self::$var += 1; echo self::$var . PHP_EOL; &#125; public static function testtest() &#123; self::$var += 1; echo self::$var . PHP_EOL; &#125;&#125; A::test(); // 1 A::test(); // 2 A::test(); // 3 A::testtest(); // 4 A::testtest(); // 5 A::testtest(); // 6?&gt; 以下的 PHP example code 回傳的值是？ Example:&lt;?phpclass A &#123; protected $name = &#x27;A&#x27;; static $alias = &#x27;a&#x27;; const HASH = &#x27;md5&#x27;; public function dd() &#123; echo $this-&gt;name; echo &#x27;--&#x27;; echo static::$alias; echo &#x27;--&#x27;; echo static::HASH; echo &#x27;--&#x27;; echo self::$alias; echo &#x27;--&#x27;; echo self::HASH; echo &#x27;--&#x27;; var_dump(new self); echo &#x27;--&#x27;; var_dump($this); echo &#x27;--&#x27;; var_dump(new static); echo &#x27;&lt;br&gt;&#x27;; &#125;&#125; class B extends A &#123; protected $name = &#x27;B&#x27;; static $alias = &#x27;b&#x27;; const HASH = &#x27;sha1&#x27;;&#125; (new A)-&gt;dd(); (new B)-&gt;dd(); Answer:&lt;?php // $this-&gt;name = A, $this 代表當前 instance, 而當前 instance 為 // class A 的 instance, 故為 class A 中的 protected variable // static::$alias = a, static 為 forwarding call, static 的 forwarding call // 下面會詳述。 呼叫的 instance 的 class 為 class A, 所以取 class A 中定義的 static variable // static::HASH = md5, 原理同上 // self::$alias = a, self 表示當前 method 歸屬的 class, 此處為 class A, // 因此使用 class A 中定義的 static variable // self::HASH = md5, 原理同上 // new self = class A, 如同上面提到的, 當前 method 所在的 class 為 class A // $this = class A, 原理同上, $this 為 class A 的 instance, 所以是 class A // new static = 同上, 原始被呼叫的 class 為 class A, 所以為 class A(new A)-&gt;dd(); // 輸出為: A--a--md5--a--md5--object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // --object(A)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // --object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // $this-&gt;name = B, $this 代表當前 instance, 也就是 class B // static::$alias = b, static 為 forwarding call, static 的 forwarding call 下面會詳述。 // 呼叫的 instance 的 class 為 class B, 所以取 class B 中定義的 static variable // static::HASH = sha1, 原理同上 // self::$alias = a, self 表示當前 method 歸屬的 class, 因 class B 使用的 test() method 是 // 繼承自 class A 的, 實際上 self 為 class A, 所以使用定義在 class A 的 alias // self::HASH = md5, 原理同上 // new self = class A, 如同上面提到的, 當前 method 定義於 class A // $this = class B, 原理同上, $this 為 class B 的 instance, 所以是 class B // new static = 同上, 原始被呼叫的 class 為 class B, 所以為 class B (new B)-&gt;dd(); // 輸出為: B--b--sha1--a--md5--object(A)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;A&quot; &#125; // --object(B)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;B&quot; &#125; // --object(B)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; string(1) &quot;B&quot; &#125; 以下的 PHP example code 回傳的值是？ Example:&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; self::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test(); // 輸出是？?&gt; Answer:&lt;?php// 輸出為 A// 因為 B 本身沒有 test(), 所以調用 A 的 test(), 而 test() 中的 // self 代表 test() 歸屬的 class, 即 A, 所以會調用 A 的 who() 以下的 PHP example code 回傳的值是？ Example:&lt;?phpclass A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); &#125;&#125;class B extends A &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;B::test(); // 輸出是？?&gt; Answer:&lt;?php// 輸出為 B// static 代表著上一個調用 non-forwarding call 的 class, 即 B// 下面會針對 forwarding call 以及 non-forwarding call 詳述 以下的 PHP example code 回傳的值是？ Example:&lt;?phpclass A &#123; public static function foo() &#123; static::who(); &#125; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;class B extends A &#123; public static function test() &#123; A::foo(); parent::foo(); self::foo(); &#125; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;C::test();?&gt; Answer:&lt;?phpclass A &#123; public static function foo() &#123; // who() 為 echo called class name, 因此 static 代表什麼, 決定著輸出 static::who(); &#125; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;class B extends A &#123; public static function test() &#123; // 上面有提到 A:: 算 non-forwarding call, 所以假如後面有呼叫 static:: 的話, static 就會代表 A A::foo(); // 上面有提到, parent:: 算 forwarding call, 而上一個 non-forwarding call // 為 C::test(), 因此如果後面有使用 static::, static 表示 C parent::foo(); // 同上 self::foo(); &#125; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__.&quot;\\n&quot;; &#125;&#125;C::test();// A C C// A::foo() 輸出 A, 如上所述, A:: 為 non-forwarding call, // 因此 static::who() 這邊的 static 代表 A// parent::foo() 輸出 C, 如上所述, parent:: 為 forwarding call, // 因此 foo() 中的 static 還是代表上一個 non-forwarding call, 即 C// self::foo() 輸出為 C, 同上?&gt; PHP 中, forwarding call 與 non-forwarding call 分別是？forwarding call: parent:: self:: static:: forward_static_call() non-forwarding call:A::test() PHP 中, self 跟 static 的差異是？ self 代表當前 method 所歸屬的 class static 代表上一個 non-forwarding 調用的 class PHP 中, 在 non-static context 環境中, static 的調用順序是？它指向的 class 中找尋 private method ==&gt; public method ==&gt; 調用 static 的 method 所在的 class 中尋找 private method ==&gt; public method, 如果存在就調用, 並停止找尋。 PHP 中, 在 non-static context 環境中, $this 的調用順序是？調用 $this 的 method 所在的 class 中尋找 private method ==&gt; 它指向的 instance 的 class 中尋找 private method ==&gt; 然後是 public method ==&gt; 調用 $this 的 method 所在的 class 中尋找 public method, 只要找到就調用, 並停止找尋 以下的 PHP example code 的輸出是？ Example&lt;?phpclass A &#123; private function foo() &#123; echo __class__ . PHP_EOL; &#125; public function test() &#123; $this-&gt;foo(); static::foo(); &#125;&#125;class B extends A &#123;&#125;class C extends A &#123; private function foo() &#123; &#125;&#125;$b = new B(); // 輸出是？$b-&gt;test(); // 輸出是？$c = new C(); // 輸出是？$c-&gt;test(); // 輸出是？?&gt; Answer:&lt;?phpclass A &#123; private function foo() &#123; echo __class__ . PHP_EOL; &#125; public function test() &#123; $this-&gt;foo(); static::foo(); &#125;&#125;class B extends A &#123; // foo() 是從 A copy 過來 B 的, 因此它的 scope 依然是 A&#125;class C extends A &#123; private function foo() &#123; // 這個 foo() 覆蓋了 class A 的 foo(), 所以新的 scope 為 C &#125;&#125;$b = new B();// $this-&gt;foo() 輸出為 A, 如上所述, class B 本身沒有 test(), 所以會調用 class A 的// 而 $this 會先到 &quot;調用 $this-&gt;foo()&quot; 的 method, 即 test(), 所在的 class, 即 class A, // 中尋找 private method, 你可以試試在 class B 中新增一個一模一樣的 private method foo(),// 結果還是會先調用 class A 的 foo()// static::foo() 輸出為 A, 同上, 但 class B 並沒有 foo(), 所以調用了 class A 的 foo()// 可以試試在 class B 新增一個 private method foo(), 這樣會報錯, 因為 static 會先從實際調用// class, 即 class B, 尋找 private method, 這樣就變成從 class A 去呼叫 class B 的 private// method, private method 只可從所屬的 class 中才可調用, 當然, 如果改成 public method, // 那輸出就會變成 B$b-&gt;test();$c = new C();// $this-&gt;foo() 輸出是 A, 這點同上, 不加贅述// static::foo() 會 fail, 因為 static 會到實際調用的 class 中尋找 private method, 而// class C 中確實定義了 private method foo(), 這樣就變成了從 class A 的 scope 去調用// class C 的 private method, 所以錯了// 可以試試把 class C 中的 foo() 改成 public, 且輸入跟 class A foo() 一樣的內容// 這樣輸出就會變成 C 了$c-&gt;test(); ?&gt;","link":"/zh-tw/php/"},{"title":"PHPSTORM 學習筆記","text":"前言PHPSTORM 學習筆記, 學什麼看什麼記什麼！ Laravel debugger安裝 xdebug參考文件 使用 peck 安裝 pecl install xdebug 打開 php.ini 檔 vim $(pecl config-get php_ini) 輸入以下設定 [xdebug]zend_extension=&quot;xdebug.so&quot;xdebug.remote_enable=1xdebug.remote_port=&quot;9000&quot;xdebug.idekey=rayxdebug.default_enable=1 儲存離開後, 驗證是否有安裝成功 php -version 預計輸出： 建立含有 phpinfo() 的 PHP 檔案&lt;?phpphpinfo(); 預計輸出: 在 PhpStorm 中設定 Xdebug參考文件 設定可利用 Paw 或 Postman 測試參考文件1出處圖片備份 參考文件2出處","link":"/zh-tw/phpstorm/"},{"title":"pm2 - 用法大全","text":"# 前言# pm2 是什麼？ pm2 是一個 node 的程序管理器 # pm2 解決什麼問題？ pm2 可以讓 node 服務 crash 掉之後，自動幫我們重啟 pm2 可以在 server 重啟之後，自動幫我們重啟 pm2 可利用 CPU 多核，開啟多程序，已達到類似負載平衡的效果 Graceful reload 可達成類似 rolling upgrade 的效果，0 downtime 升級 多程序多服務，可提升處理 request 的速度 可設定 cron 排程自動重啟時間 pm2 提供多項資訊，包含已重啟次數、 CPU 用量、 memory 用量, process id, 等等… pm2 可以在指定的條件下，自動幫我們重啟，條件可以是’up time’, ‘已使用多少 memory’, 等等…, pm2 可以幫我們整理 log, 讓 log 以我們想要的週期分割檔案，並保存我們想要的數量，若有超過，自動刪除。 pm2 提供簡單的部署方式，可一次性部署到多台 server pm2 可與 CD / CD 工具做結合， CI / CD 部署也沒有問題 好 pm2, 不用嗎？ # 本篇將提到： 安裝 pm2 使用 CLI 啟動 pm2 使用 pm2 設定檔 ecosystem 啟動 pm2 使用 pm2 設定檔 ecosystem 部署 node 專案 使用 pm2 搭配 GitLab CI / CD Runner 部署 node 專案 # 安裝 全域安裝npm install pm2@latest -g # pm2 with CLI# 可以使用 pm2 CLI 來啟動 node 專案, 範例如下：pm2 start location/fileName.js --name appName \\--watch true \\--max-memory-restart 500M \\--log ~/.pm2/logs/appName/ \\--time true \\--cron &quot;0 17 * * *&quot; \\--no-daemon true \\--merge-logs 以上範例中設定代表的意思，參考如下： # 靜態檔的服務器 也可以服務靜態檔pm2 serve &lt;path&gt; &lt;port&gt; # 啟動可以附加的參數 --name指定 app 一個名字 --watch檔案有變更時，會自動重新啟動 --max-memory-restartMemory 使用超過這個門檻時，會自動重啟 --log指定 log 的位址, 若要指定新位址，需將原本的 process 刪掉，再重新啟動指定 --output指定 output log 位址 --error指定 error log 位址 --log-date-format指定 log 的格式 --merge-logs同一個 app 跑多程序時，不要依據程序 id 去分割 log, 全部合在一起 --arg1 --arg2 --arg3指派額外的參數 --restart-delay自動重啟時，要 delay 多久 --time給 log 加上前綴 --no-autorestart不要自動重啟 --cron指定 cron 規律，強制重啟 --no-daemon無 daemon 模式， listen log 模式 --spa限定 serve 使用, 會重導所有的請求到 index.html --basic-auth-username --basic-auth-password 用於靜態檔, 讓該頁面需要帳號密碼方可存取 # 叢集模式 pm2 自動偵測該機器的 CPU 數量，啟動最大能負荷的 process, 適用上面的選項, -i 後面接希望啟動 instance 的數量， 0 或 max 默認自動偵測 CPU 啟動最大值pm2 start app.js -i max # 管理程序 直接 kill 掉 process, 再重新開始程序 pm2 restart app_name 如果是在 cluster mode, reload 會依序升級重啟每一個程序，達到 zero downtime 升級 pm2 reload app_name 停止服務 pm2 stop app_name 停止並刪除服務 pm2 delete app_name 除了 app_name 之外，你也可以指定all : 啟動所有程序id : 該程序 id # 顯示管理程序狀態pm2 [list|ls|status] # Logs 輸出 log pm2 logs 顯示指定行數 log (指定倒數 200 行) pm2 logs --lines 200 指定輸出程序 log pm2 logs id 指定輸出格式 format pm2 logs --format 指定輸出格式 json pm2 logs --json 清空 log pm2 flush 取消 log可以利用指定 log 路徑為 /dev/null 來取消 log 輸出, log 參數用法請參考 ecosystem 範例 # 循環 log如果你看過 log 檔案超肥，幾年的 log 都寫在同一個檔案; 如果你打開 log 資料夾，發現裡面躺著幾百個 log 檔案; 如果你看過千奇百怪的 log 檔名; 如果你 du -h 發現 log 資料夾大的嚇死人如果你有以上的經驗，那恭喜你，你有救了 # 安裝pm2 install pm2-logrotate # config 檔位置/home/user/.pm2/module_conf.json # 參數 max_size (預設 10M):當 log 檔案達到多大時， logrotate module 會將它分割成另外一個檔案。 logrotate module 有可能在檢查檔案時，檔案已經超過指定的大小了，所以超過一些些是可能的。 單位可以自行指定, 10G, 10M, 10K retain (預設 30 個 log 檔案):預設最多保存的 log 數量，如果設定為 7 的話，將會保存目前的 log, 以及最多 7 個 log 檔案 compress (預設 false):壓縮所有循環 log 檔案 dateFormat (時間格式，預設 YYYY-MM-DD_HH-mm-ss) :檔案命名的時間格式 rotateModule (預設 true) :跟其他 apps 一樣，循環 pm2’s module workerInterval (預設 30 秒) :多久 logrotate 會檢查一次 log 檔案大小 rotateInterval (預設每天午夜循環, 範例 0 0 * * * ):除了設定檔案大小以外，我們也可以設定以時間為單位去循環，格式上採用 node-schedule TZ (預設為系統時間):檔案命名的時間會根據你所設定的時區而改變 # 圖示* * * * * *┬ ┬ ┬ ┬ ┬ ┬│ │ │ │ │ |│ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)│ │ │ │ └───── month (1 - 12)│ │ │ └────────── day of month (1 - 31)│ │ └─────────────── hour (0 - 23)│ └──────────────────── minute (0 - 59)└───────────────────────── second (0 - 59, OPTIONAL) # terminal 監控面板pm2 monit # pm2 ecosystemCLI 工具固然不錯，但只要是人難免手滑打錯或漏打參數。 pm2 ecosystem 解決了這個問題，只要好好的打上一次，以後除非設定有變更，否則啟動服務只需要短短幾個指令，而且 ecosystem 檔案還可以納入 git 控管，跟著專案跑 產生範例 ecosystem filepm2 ecosystem # CLI跟前面介紹過的管理程序一樣，差別只是將 app.js 換成 ecosystem.js多個管理程序 CLI, 這邊就只列出 start, 其餘同上 pm2 start ecosystem.config.js # 從 ecosystem 中只啟動特定 app下面的 appName 為我們寫在 ecosystem.config.js 檔案中的 appName pm2 start ecosystem.config.js --only yourApp # 帶入參數拿下面的範例來說，如果我輸入 pm2 start ecosystem --only app1 --env production , 那麼 pm2 就會使用 NODE_ENV=production 這個環境變數 # 參數範例下面的參數有點多，我們肯定不會一次使用到這麼多的參數，所以可以視專案需求留下我們需要的參數即可 module.exports = &#123; apps: [ // First application &#123; // App 名稱 name: &#x27;app1&#x27;, // 執行服務的入口檔案 script: &#x27;./server.js&#x27;, // 你的服務所在位置 cwd: &#x27;var/www/yourApp/&#x27;, // 分為 cluster 以及 fork 模式 exec_mode: &#x27;cluster&#x27;, // 只適用於 cluster 模式，程序啟動數量 instances: 0, // 適合開發時用，檔案一有變更就會自動重啟 watch: false, // 當佔用的 memory 達到 500M, 就自動重啟 max_memory_restart: &#x27;500M&#x27;, // 可以指定要啟動服務的 node 版本 interpreter: &#x27;/root/.nvm/versions/node/v8.16.0/bin/node&#x27;, // node 的額外參數 // 格式可以是 array, 像是 &quot;args&quot;: [&quot;--toto=heya coco&quot;, &quot;-d&quot;, &quot;1&quot;], 或是 string, 像是 &quot;args&quot;: &quot;--to=&#x27;heya coco&#x27; -d 1&quot; interpreter_args: &quot;port=3001 sitename=&#x27;first pm2 app&#x27;&quot;, // 同上 node_args: &quot;port=3001 sitename=&#x27;first pm2 app&#x27;&quot;, // &#x27;cron&#x27; 模式指定重啟時間，只支持 cluster 模式 cron_restart: &quot;0 17 * * *&quot;, // log 顯示時間 time: true, // 可經由 CLI 帶入的參數 args: &#x27;-a 13 -b 12&#x27;, // 想要被忽略的檔案或資料夾, 支援正則，指定的檔案或資料夾如果內容有變更，服務將不會重啟 // 格式可以是 array, 像是 &quot;args&quot;: [&quot;--toto=heya coco&quot;, &quot;-d&quot;, &quot;1&quot;], 或是 string, 像是 &quot;args&quot;: &quot;--to=&#x27;heya coco&#x27; -d 1&quot; ignore_watch: [&quot;[\\/\\\\]\\./&quot;, &quot;node_modules&quot;], // 支援 source_map, 預設 true, 細節可參考 // http://pm2.keymetrics.io/docs/usage/source-map-support/ // https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/ source_map_support: true, // instance_var, 詳見以下連結 // http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables instance_var: &#x27;NODE_APP_INSTANCE&#x27;, // log 的時間格式 log_date_format: &#x27;YYYY-MM-DD HH:mm Z&#x27;, // 錯誤 log 的指定位置 error_file: &#x27;/var/log&#x27;, // 正常輸出 log 的指定位置 out_file: &#x27;/var/log&#x27;, // 同一個 app 有多程序 id, 如果設定為 true 的話， 同 app 的 log 檔案將不會根據不同的程序 id 分割，會全部合在一起 combine_logs: true, // 同上 merge_logs: true, // pid file 指定位置, 預設 $HOME/.pm2/pid/app-pm_id.pid pid_file: &#x27;user/.pm2/pid/app-pm_id.pid&#x27;, // pm2 會根據此選項內的時間來判定程序是否有成功啟動 // 格式可使用 number 或 string, number 的話， 3000 代表 3000 ms。 string 的話, 可使用 &#x27;1h&#x27; 代表一個小時, &#x27;5m&#x27; 代表五分鐘, &#x27;10s&#x27; 代表十秒 min_uptime: &#x27;5&#x27;, // 單位為 ms, 如果在該時間內 app 沒有聽 port 的話，強制重啟 listen_timeout: 8000, // 當執行 reload 時，因為 graceful reload 會等到服務都沒有被存取了才會斷開，如果超過這個時間，強制斷開重啟 // 細節可參考官方文件 http://pm2.keymetrics.io/docs/usage/signals-clean-restart/ kill_timeout: 1600, // 一般來說，服務等待 listen 事件觸發後，執行 reload, 若此選項為 true, 則等待 &#x27;ready&#x27; message // 細節可參考官方文件 http://pm2.keymetrics.io/docs/usage/signals-clean-restart/ wait_ready: false, // pm2 具有 crash 自動重啟的功能。 但若異常狀況重啟超過此選項的指定次數，則停止自動重啟功能。 異常與否的判定，預設為 1 秒，也就是說如果服務啟動不足一秒又立即重啟，則異常重啟次數 + 1。 若 min_uptime 選項有指定，則以 min_uptime 指定的最小正常啟動時間為標準來判斷是否為異常重啟 // 細節可參考官方文件 http://pm2.keymetrics.io/docs/usage/signals-clean-restart/ max_restarts: 10, // 單位為 ms, 預設為 0, 若有指定時間，則 app 會等待指定時間過後重啟 restart_delay: 4000, // 預設為 true, 若設為 false, pm2 將會關閉自動重啟功能, 也就是說 app crash 之後將不會自動重啟 autorestart: true, // 預設為 true, 預設執行 pm2 start app 時，只要 ssh key 沒問題， pm2 會自動比較 local 跟 remote, 看是否為最新的 commit，若否，會自動下載更新。 此功能有版本問題，需新版才支援 vizion: true, // 進階功能，當使用 Keymetrics 的 dashboard 執行 pull 或 update 操作後，可以觸發執行的一系列指令 post_update: [&quot;npm install&quot;, &quot;echo launching the app&quot;], // defaults to false. if true, you can start the same script several times which is usually not allowed by PM2 // 預設為 false, 如果設定為 true, force: false, // 當不指定 env 時，會套用此 object 裡頭的環境變數, 例如 pm2 start ecosystem.js env: &#123; COMMON_VARIABLE: &#x27;true&#x27;, NODE_ENV: &#x27;&#x27;, ID: &#x27;44&#x27; &#125;, // 當有指定 env 時，會套用此 object 裡頭的環境變數, 例如 pm2 start ecosystem.js --env production env_production: &#123; NODE_ENV: &#x27;production&#x27;, ID: &#x27;55&#x27; &#125;, // 同上 env_development: &#123; NODE_ENV: &#x27;development&#x27; &#125; &#125;, // 第二個 app, 很多資訊上面有介紹過的就不再重複 &#123; // Serve 模式, 可服務靜態資料夾 script: &quot;serve&quot;, env: &#123; PM2_SERVE_PATH: &#x27;.&#x27;, PM2_SERVE_PORT: 8080 &#125;, name: &#x27;app2&#x27;, // 預設模式，可應用在其他語言, cluster 只可用在 node.js exec_mode: &#x27;fork&#x27;, interpreter: &#x27;/root/.nvm/versions/node/v8.16.0/bin/node&#x27;, time: true, &#125; ], // 這一個區塊是部署的部分 deploy: &#123; // production production: &#123; // 要登入執行 pm2 的 user user: &#x27;root&#x27;, // 支援多個 host 部署 host: [&#x27;host1&#x27;, &#x27;host2&#x27;], // remote 要檢查的 public key 的位置 key: &#x27;path/to/some.pem&#x27;, // 要部署的分支 ref: &#x27;origin/master&#x27;, // Git 倉庫位址 repo: &#x27;git@gitlab.com:user/yourProject.git&#x27;, // 要部署到 server 上的資料夾路徑 path: &#x27;/var/www/yourProjectName&#x27;, // 如果 ssh 有設定好，從 local 連到 remote 端將不會再詢問是否將 remote 端的 public key 加到 known host &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, // 在 pm2 要從 local 端連到 remote 端之前要執行的指令，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 &quot;pre-setup&quot;: &#x27;apt update -y; apt install git -y&#x27;, // 當 pm2 在 remote 機器上將專案 clone 下來之後會執行的指令，同上，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 &quot;post-setup&quot;: &quot;ls -la&quot;, // 當 pm2 在 local 要連上 remote 部署之前 ，在 local 端所要執行的指令, 同上，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 &quot;pre-deploy-local&quot; : &quot;echo &#x27;This is a local executed command&#x27;&quot;, // 部署完成後, 所要執行的指令 同上，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 &#x27;post-deploy&#x27;: &#x27;sudo /root/.nvm/versions/node/v8.16.0/bin/npm install &amp;&amp; sudo /root/.nvm/versions/node/v8.16.0/bin/npm rebuild &amp;&amp; /root/.nvm/versions/node/v8.16.0/bin/pm2 reload ecosystem.config.js&#x27;, env_production: &#123; NODE_ENV: &#x27;production&#x27; &#125; &#125;, staging: &#123; user: &#x27;root&#x27;, host: [&#x27;host3&#x27;, &#x27;host4&#x27;], ref: &#x27;origin/staging&#x27;, repo: &#x27;git@gitlab.com:user/yourProject.git&#x27;, path: &#x27;/var/www/yourProjectName&#x27;, &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, &quot;pre-setup&quot;: &#x27;apt update -y; apt install git -y&#x27;, &quot;post-setup&quot;: &quot;ls -la&quot;, &quot;pre-deploy-local&quot; : &quot;echo &#x27;This is a local executed command&#x27;&quot;, &#x27;post-deploy&#x27;: &#x27;sudo /root/.nvm/versions/node/v8.16.0/bin/npm install &amp;&amp; sudo /root/.nvm/versions/node/v8.16.0/bin/npm rebuild &amp;&amp; /root/.nvm/versions/node/v8.16.0/bin/pm2 reload ecosystem.config.js&#x27;, env_production: &#123; NODE_ENV: &#x27;staging&#x27; &#125; &#125;, &#125;,&#125;; # pm2 部署pm2 的部署功能，可以讓我們從本機直接部署到多台 server 上, 也可以結合 CI / CD 工具，在提交 commit 後自動部署 # 部署前的必要條件 首先要先確定，local 到 remote 端的 ssh key 有準備好了嗎？ local 到 remote server 的 ssh 連線是必要的哦！ 簡單來說，你需要在 local 放一把 private key, 然後在你的 remote server 放一把 public key, 這樣才能暢通無阻哦！ 這部分再麻煩 Google 一下哦！ 再來，因為 pm2 會 ssh 到 remote server 上，然後在 remote server 上從我們的專案處 GitHub 或 GitLab 將專案 clone 下來，所以務必確保 remote server 是可以從 GitHub 或 GitLab clone 我們的專案, 所以你要在 remote server 上放一把 clone 用的 private key, 然後將 public key 放在 GitLab 或 GitHub 上，這部分也是麻煩 Google 一下哦 由於首次 ssh 連線時會跳詢問是否將 public key 加入到 known host，這個 prompt 會讓 pm2 deploy 卡住，所以務必先將 remote server 設定好哦！ 可以先連線一次，也可以修改 ssh config, 取消這個 hostKey 的 確認功能。echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config 接下來，要將 ecosystem 設定檔寫好，這部分請參考上方的 deploy 範例 最後，請確認 remote server 的 ssh 通道 (預設 port 22) 不是關閉的哦！ # 初始化遠端資料夾在部署之前, 先在 remote server 上初始化專案的資料夾, 可以帶入不同的參數讓 pm2 根據設定檔做相對應得部署 pm2 deploy ecosystem.config.js production setup # 部署 部署在初始化遠端資料夾之後，我們就可以使用 pm2 的部署功能了pm2 deploy ecosystem.config.js production deploy 可使用的參數如下，也可使用 pm2 deploy help 查看pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; &lt;command&gt; Commands: setup 遠端初始化（第一次部署才會用到） update 更新到最新的 commit revert [n] 回復到上一次的 deployment curr[ent] 輸出目前上線中的 commit prev[ious] 輸出上一次部署的 commit exec|run &lt;cmd&gt; 執行指定的指令 list 列出包含目前，以及之前所部署的 commit [ref] 部署到指定的 ref # 部署相關指令pm2 startOrRestart all.json # 重啟所有 apppm2 startOrReload all.json # 觸發 reload # 強制重啟pm2 的部署，會要求 local 端先將變更推上 Git repository, 然後 pm2 會在 remote server 執行 git pull, 所以當 local 的變更尚未推上 Git 時，部署會失敗。這時候如果我們硬要部署，我們可以使用 pm2 deploy ecosystem.json production --force # CI / CD 部署 利用 GitLab 的 CI / CD Runner 配合 pm2 來跑自動部署, 以下為 gitlab.yml 檔案範例 設定好之後，只要 git push 到 master branch, 就會觸發 GitLab CI / CD Runner 自動完成 CI / CD# 使用輕量化 pm2 imageimage: keymetrics/pm2:latest-alpinestages:- deployDeploy: stage: deploy script: # 若 ssh-agent 未安裝，則安裝 - &#x27;which ssh-agent || ( apk add --update openssh )&#x27; # 安裝 bash, 以執行 pm2 CLI 工具 - apk add --update bash # 安裝 git, pm2 要連過去時會用到 - apk add --update git # 執行 ssh agent - eval $(ssh-agent -s) # 將 ssh key 加到 ssh agent, 此 ssh key 為 GitLab 的 variable 選項 - echo &quot;$SSH_PRIVATE_KEY&quot; | ssh-add - # 執行 pm2 CLI - pm2 deploy ecosystem.config.js production update only: - master # 開機自動啟動 產生開機 script pm2 startup 取消開機自動重啟 pm2 unstartup 儲存下次重啟時，預設啟動的 process pm2 save 如果有更新 node 的版本，記得更新 script pm2 unstartup &amp;&amp; pm2 startup &amp;&amp; pm2 save # 有變更時重啟監看該資料夾下的所有檔案，以及子資料夾，並且忽略 node_module 這個資料夾 cd /path/to/my/apppm2 start env.js --watch --ignore-watch=&quot;node_modules&quot; # 更新 PM2npm install pm2@latest -g &amp;&amp; pm2 update # 常用指令# Fork 模式pm2 start app.js --name my-api # 指定程序名稱# Cluster 模式pm2 start app.js -i 0 # 會根據可用的 CPU 數量來啟動最大的程序數量，達到平衡負載的效果pm2 start app.js -i max # 跟上面一樣，但是廢除了pm2 scale app +3 # 增加三個 workerpm2 scale app 2 # 將 worker 更新成兩個# 狀態顯示pm2 list # 顯示所有程序狀態pm2 jlist # 將程序狀態使用 raw JSON 印出pm2 prettylist # 將程序狀態用美化的 JSON 印出pm2 describe 0 # 顯示特定程序的所有資訊pm2 monit # 監控所有程序# Logspm2 logs [--raw] # 以串流的方式顯示所有 logpm2 flush # 移除所有 log 檔案pm2 reloadLogs # 重新載入 logs# 操作pm2 stop all # 停止所有程序pm2 restart all # 重新開啟所有程序pm2 reload all # 重新載入服務pm2 stop 0 # 停止特定 id 的程序pm2 restart 0 # 重新啟動特定 id 程序pm2 delete 0 # 從 pm2 list 移除特定 id 程序, 但這並不會停止該程序pm2 delete all # 移除所有程序, 但這並不會停止這些程序# Miscpm2 reset &lt;process&gt; # 重置 meta datapm2 updatePM2 # 更新 pm2pm2 ping # Ensure pm2 daemon has been launchedpm2 sendSignal SIGUSR2 my-app # Send system signal to scriptpm2 start app.js --no-daemon # 不要背景執行pm2 start app.js --no-vizion # 不加這一行，預設執行 pm2 start app 時，只要 ssh key 沒問題， pm2 會自動比較 local 跟 remote, 看是否為最新的 commit，若否，會自動下載更新pm2 start app.js --no-autorestart # 不自動重啟 # 自動補齊 支援 pm2 指令可以打 tab 自動補齊pm2 completion install # 疑難雜症# 遇到錯誤 Error: ENOENT: no such file or directory, uv_cwd意思是說， pm2 的工作目錄資料夾不存在，所謂的工作目錄資料夾就是我們第一次啟動 pm2 的位置。很可能是我們啟動之後，就不小心把它刪了，如果要尋找工作目錄資料夾在哪，可以使用下面的 command 找到 pm2 的 process id ps ax | grep PM2 然後查詢該 process 執行時所在的目錄（將上面得到的 process id 替換下面的 PM2_Process_ID ls -l /proc/PM2_Process_ID/cwd 公布結果 ls -l /proc/24016/cwd 結果應該會如下, 最後的 deleted 表示該目錄已經被刪除了 lrwxrwxrwx 1 root root 0 Feb 4 17:04 /proc/24016/cwd -&gt; /home/nodejs/deploy(deleted) 現在知道原因了，那解決的方法呢？ 我們要先把目前的 process 砍掉，然後到一個安全一點的地方在開啟一次，以免下次又被誤刪了！ 殺掉 pm2 process id kill -9 processID 到一個安全不會再被意外砍掉的目錄再次啟動 pm2 cd ~ &amp;&amp; pm2 -v # 參考資料pm2 官網pm2 logrotate","link":"/zh-tw/pm2/"},{"title":"PHP - Data Structure and Algorithm","text":"# 前言資料結構與演算法學習筆記 T_T, 出來混, 遲早要還的… # Questions and Answers以下的演算法邏輯是？ Example:&lt;?phpclass Solution &#123; /** * @param TreeNode $root * @param Integer $k * @return Boolean */ function findTarget($root, $k) &#123; $result = $this-&gt;find($set, $k, $root); return $result; &#125; private function find(&amp;$set, $k, $root):bool &#123; if ($root === null) &#123; return false; &#125; if (array_key_exists($k - $root-&gt;val, $set)) &#123; return true; &#125; $set[$root-&gt;val] = true; return $this-&gt;find($set, $k, $root-&gt;right) || $this-&gt;find($set, $k, $root-&gt;left); &#125;&#125; Answer:twoSumBST 以下的演算法題目, twoSum 的解法邏輯是？ Example:Input: nums = [2,7,11,15], target = 9Output: [1,2]Output: Because nums[0] + nums[1] == 9, we return [1, 2]. Answer: &lt;?phpclass Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function twoSum($nums, $target) &#123; $map = []; for($i=0;$i&lt;=count($nums);$i++) &#123; $difference = $target - $nums[$i]; if (array_key_exists($difference, $map)) &#123; return [$i, $map[$difference]]; &#125; $map[$nums[$i]] = $i; &#125; &#125;&#125; 在 loop 過程中將 $nums key value 顛倒存成 $map = [value, key], 而只要 $target - $nums[$i] 的結果存在於 $map 的 key 中, 假設為 $difference, 則第一個 index 為 $i, 第二個為 $map[$difference] 以下的演算法題目, twoSum 的解法邏輯是？ Example:Input: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1]. Answer: &lt;?phpclass Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function twoSum($nums, $target) &#123; $map = []; for($i=0;$i&lt;=count($nums);$i++) &#123; $difference = $target - $nums[$i]; if (array_key_exists($difference, $map)) &#123; return [$i, $map[$difference]]; &#125; $map[$nums[$i]] = $i; &#125; &#125;&#125; 在 loop 過程中將 $nums key value 顛倒存成 $map = [value, key], 而只要 $target - $nums[$i] 的結果存在於 $map 的 key 中, 假設為 $difference, 則第一個 index 為 $i, 第二個為 $map[$difference] 以下的 php example code 的意思是？ Example:&lt;?phpfunction mergeSort(array $arr): array&#123; $len = count($arr); $mid = (int) ($len / 2); if ($len == 1) &#123; return $arr; &#125; $left = mergeSort(array_slice($arr, 0, $mid)); $right = mergeSort(array_slice($arr, $mid)); return merge($left, $right);&#125;function merge(array $left, array $right): array&#123; $combined = []; $countLeft = count($left); $countRight = count($right); $leftIndex = $rightIndex = 0; while ($leftIndex &lt; $countLeft &amp;&amp; $rightIndex &lt; $countRight) &#123; if ($left[$leftIndex] &gt; $right[$rightIndex]) &#123; $combined[] = $right[$rightIndex]; $rightIndex++; &#125; else &#123; $combined[] = $left[$leftIndex]; $leftIndex++; &#125; &#125; while ($leftIndex &lt; $countLeft) &#123; $combined[] = $left[$leftIndex]; $leftIndex++; &#125; while ($rightIndex &lt; $countRight) &#123; $combined[] = $right[$rightIndex]; $rightIndex++; &#125; return $combined;&#125;$array = [8, 4, 1, 8, 19, 3, 5, 11, 9, 13];$result = mergeSort($array);print_r($result); Answer:merge sort, 先使用 binary 遞迴將 array 1 分為 2, 直到一個 array 中只有一個 item, 在從終點處往回推, 使每一個 array 都是排序過的, 在排序兩個已經排序過的 array, 回推到終點時, 已完成所有的排序 B tree 通常被使用在什麼地方？大型資料, 例如資料庫或檔案系統 AVL tree 算是哪一種 tree 的一種？height balancing binary search tree Binary search tree 跟 self-balanced binary search tree 的效率哪種較佳？後者 Binary search tree 跟 self-balanced binary search tree 的差異是？後者會自動調整, 讓自身的 height 盡可能的小 Binary tree 跟 Binary search tree 的差異是？binary search tree 中, node 的必須以特定的方式排列儲存 演算法中, 何謂穩定排序與不穩定排序? 排序前 key/value 相同的 index, 在排序後的順序跟排序前一樣, 那稱為穩定排序, 如 [3, 2, 2(2), 1, 4] 排序後為 [1, 2, 2(2), 3, 4] 排序前 key/value 相同的 index, 在排序後的順序跟排序前不一樣, 那稱為不穩定排序, 如 [3, 2, 2(2), 1, 4] 排序後為 [1, 2(2), 2), 3, 4] 以下的 PHP Example code 的意思是？ Example:&lt;?phpfunction insertionSort(array &amp;$arr) &#123; $len = count($arr); for ($i = 1; $i &lt; $len; $i++) &#123; $key = $arr[$i]; $j = $i - 1; while($j &gt;= 0 &amp;&amp; $arr[$j] &gt; $key) &#123; $arr[$j+1] = $arr[$j]; $j--; &#125; $arr[$j+1] = $key; &#125; &#125;$arr = [20, 45, 93, 67, 10, 97, 52, 88, 33, 92];insertionSort($arr);echo implode(&quot;,&quot;, $arr); Answer:&lt;?php// 使用 PHP Reference, 因此會直接更動外面的 $arr 內容function insertionSort(array &amp;$arr) &#123; $len = count($arr); // 外層迴圈決定了 &quot;待比較&quot; index, 1-9 都會依次被比較 for ($i = 1; $i &lt; $len; $i++) &#123; // $key 即是每輪的主要 &quot;待比較&quot; 數 $key = $arr[$i]; $j = $i - 1; // 內層 while 迴圈決定了 &quot;待比較數&quot; 的確切位置 // 會將 $key 與往前的 index 依序比較, 若 $key 較小, 則會將該 index 往後挪 // 依序往前比較, 直到 $key 不小於該 index, 這時 $key 會取代該 index 的後一個 index // 因為後一個 index 在上一輪已經被往後挪了 while($j &gt;= 0 &amp;&amp; $arr[$j] &gt; $key) &#123; $arr[$j+1] = $arr[$j]; $j--; &#125; $arr[$j+1] = $key; &#125; &#125;$arr = [20, 45, 93, 67, 10, 97, 52, 88, 33, 92];insertionSort($arr);echo implode(&quot;,&quot;, $arr); 以下的 Example code 的邏輯是？ Example:&lt;?phpfunction selectionSort(array $arr): array &#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; $min = $i; for ($j = $i+1; $j &lt; $len; $j++) &#123; if ($arr[$j] &lt; $arr[$min]) &#123; $min = $j; &#125; &#125; if ($min != $i) &#123; $tmp = $arr[$i]; $arr[$i] = $arr[$min]; $arr[$min] = $tmp; &#125; &#125; return $arr;&#125; Answer:&lt;?phpfunction selectionSort(array $arr): array &#123; $len = count($arr); // $i 從 0 開始跑, 亦即從 index 0 開始跑到最後一個 index for ($i = 0; $i &lt; $len; $i++) &#123; // 這裡定下 $min 預設的位置, 以 first loop 來說, $i 為 0, 目標為將最小值移動到 $i 即 index 0 的位置 // 以 second loop 來說, $i = 1, 目標為將最小值移動到 index 1 的位置 $min = $i; // $j = $i+1, 所以以 first loop first step 來說, 會是 index 1 跟 index 0 做比較, 而 second loop first step 就會是 // index 2 跟 index 1 做比較, 由於 index 0 已經被賦予上一輪中取得的最小值, 所以在 second loop 開始不需參與比較 for ($j = $i+1; $j &lt; $len; $j++) &#123; // 以 first loop first step 來說, 如果 index 1 &lt; index 0, 那 $min 會記下 index 1 的位置, 表示目前取得的最小值位置在 index 1 // 繼續往下跑, 會依序把每一個 index 都去跟 $min 做比較, 而每個 step 中, 如果當前 index 比 $min 還小, 會即時更新 $min 的值 // 即是即時更新最小值的 index 位置 if ($arr[$j] &lt; $arr[$min]) &#123; $min = $j; &#125; &#125; // 當上面的 loop 結束後, 如果最小值的位置, 跟 $i 不同, 那就將上面得到的此輪最小值移動到 $i 的位置 // 以 first loop 來說, 最小值會移動到 index 0 的位置, 而隨著 loop 往後跑, 每一輪的最小值都會移動到 $i 的位置 // first loop 移動到 index 0, second loop 移動到 index 1, 以此類推 if ($min != $i) &#123; $tmp = $arr[$i]; $arr[$i] = $arr[$min]; $arr[$min] = $tmp; &#125; &#125; return $arr;&#125; 以下的 Example code 的邏輯是？ Example:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); $count = 0; $bound = $len-1; for ($i = 0; $i &lt; $len; $i++) &#123; $swapped = FALSE; $newBound = 0; for ($j = 0; $j &lt; $bound; $j++) &#123; $count++; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; $swapped = TRUE; $newBound = $j; &#125; &#125; $bound = $newBound; if(! $swapped) break; &#125; echo $count.&quot;\\n&quot;; return $arr;&#125; Answer:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); $count = 0; $bound = $len-1; for ($i = 0; $i &lt; $len; $i++) &#123; $swapped = FALSE; $newBound = 0; // 依照 loop 邏輯, 每一輪 $i 都會 iterate array 的每一個 index // 並把越大的 index value 往後移動, 換言之, 如 array 有 10 個 index // 但第一輪只需將第 6 個跟第 7 個對調, 然後後面的都不需要調動 // 那跑第二輪 $i 時, 就不需要再比較 index 6 之後的 index 了 // 所以 $bound 會在每一輪 $i 結束後更新 for ($j = 0; $j &lt; $bound; $j++) &#123; $count++; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; $swapped = TRUE; // 這裏更新 $newBound, $newBound 會儲存最後一次有調整的 index $newBound = $j; &#125; &#125; // 將 $bound value 替換為 $newBound, 下一輪的 $i 就不需要去比較 $bound 之後的 index 了 $bound = $newBound; if(! $swapped) break; &#125; echo $count.&quot;\\n&quot;; return $arr;&#125; 以下的 Example code 的邏輯是？ Example:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; $swapped = FALSE; for ($j = 0; $j &lt; $len - $i - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; $swapped = TRUE; &#125; &#125; if(! $swapped) break; &#125; return $arr; Answer:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); // 這邊 i 應為 $len - 1 即可, 但並不影響到 Big O for ($i = 0; $i &lt; $len; $i++) &#123; $swapped = FALSE; // $i 每跑完一個 loop, 代表該 array 中最大的 index value 會被排到最後一個 index // 換句話說, 當第一輪跑完, 第二輪就不需要再比較倒數第二個 index 跟最後一個 index 了 // 如下示意圖 for ($j = 0; $j &lt; $len - $i - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; $swapped = TRUE; &#125; &#125; if(! $swapped) break; &#125; return $arr; 以下的 Example code 的邏輯是？ Example:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; $swapped = FALSE; for ($j = 0; $j &lt; $len - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; $swapped = TRUE; &#125; &#125; if(! $swapped) break; &#125; return $arr; &#125; Answer:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); // 這邊 i 應為 $len - 1 即可, 但並不影響到 Big O for ($i = 0; $i &lt; $len; $i++) &#123; // 定義 $swapped 為 false, 預計每個 loop 至少會調整順序一次, 如果都沒有調整到, 代表 // 此 array 已經調整完畢, 儘管 $i 還沒跑完也不需要再往下跑了 $swapped = FALSE; // $j = 0, 代表從 array index 0 開始跑 // $j &lt; $len - 1, 所以會跑到倒數第二個 index for ($j = 0; $j &lt; $len - 1; $j++) &#123; // 比較當前 index 以及下一個 index, 這也是為何上一行只需要跑到倒數第二個 index // 如果當前較 index value 下一個 index value 大, 表示順序需要調整 if ($arr[$j] &gt; $arr[$j + 1]) &#123; // 先將下一個 index value 取出並丟到 $tmp $tmp = $arr[$j + 1]; // 將下一個 index value 替換為當前 index value $arr[$j + 1] = $arr[$j]; // 將當前 index value 替換為 $tmp $arr[$j] = $tmp; // swapped 為 true, 表示此輪依然有調整順序 $swapped = TRUE; &#125; &#125; // 如果跑到這 $swapped 為 false, 代表 $j 從頭跑到尾都沒有調整過順序, 那 // 不管 $i 跑到第幾輪 loop, 後續的就不用再跑了 if(! $swapped) break; &#125; return $arr; &#125; 以下的 Example code 的邏輯是？ Example:&lt;?phpfunction bubbleSort(array $arr): array &#123; $len = count($arr); for ($i = 0; $i &lt; $len; $i++) &#123; for ($j = 0; $j &lt; $len - 1; $j++) &#123; if ($arr[$j] &gt; $arr[$j + 1]) &#123; $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr; &#125; Answer:&lt;?phpfunction bubbleSort(array $arr): array &#123; // 求得 array length $len = count($arr); // i 從 0 開始, 若 $len = 10, 那就需要跑 9 次, 由於 $1 從 0 開始, 所以 $i &lt; $len - 1 即可 for ($i = 0; $i &lt; $len - 1; $i++) &#123; // 假設 $len = 10, 那 index 會是 0 - 9, 由於下面的 code 會是 $j 比較 $j+1 // 所以 $j 取到 index 8 即可 for ($j = 0; $j &lt; $len - 1; $j++) &#123; // $j 與 $j+1 比較, 也就是當前 index 與下一個 index 相比 // 如果當前的比較大, 即符合條件 if ($arr[$j] &gt; $arr[$j + 1]) &#123; // 由於當前 index $j 較大, 所以 // 1. 先取得 index $j+1 的值, 放到 variable $tmp // 2. 將 index $j+1 的 value 替換成 value 較大的當前 $j index // 3. 最後再將當前 index $j 替換為 variable $tmp $tmp = $arr[$j + 1]; $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; &#125; &#125; &#125; return $arr; &#125; 以下的 Example code 的邏輯是？ Example:&lt;?phpfunction insert(int $data) &#123; if ($this-&gt;isEmpty()) &#123; $node = new Node($data); $this-&gt;root = $node; return $node; &#125; $node = $this-&gt;root; while ($node) &#123; if ($data &gt; $node-&gt;data) &#123; if ($node-&gt;right) &#123; $node = $node-&gt;right; &#125; else &#123; $node-&gt;right = new Node($data, $node); $node = $node-&gt;right; break; &#125; &#125; elseif ($data &lt; $node-&gt;data) &#123; if ($node-&gt;left) &#123; $node = $node-&gt;left; &#125; else &#123; $node-&gt;left = new Node($data, $node); $node = $node-&gt;left; break; &#125; &#125; else &#123; break; &#125; &#125; return $node; &#125; Answer:&lt;?phpfunction insert(int $data) &#123; if ($this-&gt;isEmpty()) &#123; $node = new Node($data); $this-&gt;root = $node; return $node; &#125; $node = $this-&gt;root; // 如果有 $node 的情況下 while ($node) &#123; // 如果帶入的 $data 比當前 node-&gt;data 還大的話 if ($data &gt; $node-&gt;data) &#123; // 如果當前 node 有 right child 的話, 就持續往下找, 並跟下一個 node 比較 if ($node-&gt;right) &#123; $node = $node-&gt;right; &#125; // 如果當前 node 已經沒有 right child, 那就使用帶入的 data 新增一個當前 node的 // right child, 已經成功找到位置並且新增了, 可以 break 離開 loop 了 else &#123; $node-&gt;right = new Node($data, $node); $node = $node-&gt;right; break; &#125; &#125; // 如果帶入的 $data 比當前 node-&gt;data 還小的話, 邏輯同上 elseif ($data &lt; $node-&gt;data) &#123; if ($node-&gt;left) &#123; $node = $node-&gt;left; &#125; else &#123; $node-&gt;left = new Node($data, $node); $node = $node-&gt;left; break; &#125; &#125; // 如果帶入的 $data 跟當前 node-&gt;data 一樣的話 else &#123; break; &#125; &#125; return $node; &#125; 以下的 Example code 的邏輯是？ Example:&lt;?phppublic function delete() &#123; $node = $this; if (!$node-&gt;left &amp;&amp; !$node-&gt;right) &#123; if ($node-&gt;parent-&gt;left === $node) &#123; $node-&gt;parent-&gt;left = NULL; &#125; else &#123; $node-&gt;parent-&gt;right = NULL; &#125; &#125; elseif ($node-&gt;left &amp;&amp; $node-&gt;right) &#123; $successor = $node-&gt;successor(); $node-&gt;data = $successor-&gt;data; $successor-&gt;delete(); &#125; elseif ($node-&gt;left) &#123; if ($node-&gt;parent-&gt;left === $node) &#123; $node-&gt;parent-&gt;left = $node-&gt;left; $node-&gt;left-&gt;parent = $node-&gt;parent-&gt;left; &#125; else &#123; $node-&gt;parent-&gt;right = $node-&gt;left; $node-&gt;left-&gt;parent = $node-&gt;parent-&gt;right; &#125; $node-&gt;left = NULL; &#125; elseif ($node-&gt;right) &#123; if ($node-&gt;parent-&gt;left === $node) &#123; $node-&gt;parent-&gt;left = $node-&gt;right; $node-&gt;right-&gt;parent = $node-&gt;parent-&gt;left; &#125; else &#123; $node-&gt;parent-&gt;right = $node-&gt;right; $node-&gt;right-&gt;parent = $node-&gt;parent-&gt;right; &#125; $node-&gt;right = NULL; &#125;&#125; Answer:&lt;?phppublic function delete() &#123; $node = $this; // 若該 node 下面沒有任何 child node if (!$node-&gt;left &amp;&amp; !$node-&gt;right) &#123; // 若該 node 是其 parent 的 left child node if ($node-&gt;parent-&gt;left === $node) &#123; // 斷掉 parent node 的 connection, 所以將不再能從 tree 存取該 node // 因為該 node 下面沒有任何 child node, 所以這是最簡單的情況 // 直接斷掉該 node 與其 parent 的 connection 即可 $node-&gt;parent-&gt;left = NULL; &#125; else &#123; // 同上 $node-&gt;parent-&gt;right = NULL; &#125; // 若該 node 下面有 left child node 也有 right child node &#125; elseif ($node-&gt;left &amp;&amp; $node-&gt;right) &#123; // $successor 為該 node 的下一個最大值, 依照 BST 的規則, 該 $successor 的位置 // 會是該 node 的 right child node 往下開始的最左最底 $successor = $node-&gt;successor(); // 將該 node 的 data 替換成 $successor-&gt;data, 剩餘的 $left 以及 $right 不需更改 // 如上所敘, $successor 為大於該 node 的下一個值, 也就是說, 若依照大小排列, 該 node 的 // 下一個就是 $successor // 也就是說, $successor 會比該 node 的 left child node 還大, 並且比 right child node 還小 $node-&gt;data = $successor-&gt;data; // 這邊是遞迴, 由於 successor 已經是某 node 的最左端, 不會再有 left child, 因此會 // 依照是否有 right child node 若兩者皆無的狀態進下一次 delete method 的判斷 $successor-&gt;delete(); // 若該 node 下面只有 left child node &#125; elseif ($node-&gt;left) &#123; // 如果該 node 是其 parent 的 left child 的話 if ($node-&gt;parent-&gt;left === $node) &#123; // 將其 parent 的 left 替換成該 node 的 left, 所以從其 parent 不再可以 connect 到該 node $node-&gt;parent-&gt;left = $node-&gt;left; // 同樣的, 將該 node 的 left chiid 的 parent property 取代為 $node-&gt;parent $node-&gt;left-&gt;parent = $node-&gt;parent; // 如果該 node 是其 parent 的 right child 的話 &#125; else &#123; // 基本上邏輯同上 $node-&gt;parent-&gt;right = $node-&gt;left; $node-&gt;left-&gt;parent = $node-&gt;parent; &#125; $node-&gt;left = NULL; // 若該 node 下面只有 right child node &#125; elseif ($node-&gt;right) &#123; // 邏輯同上 if ($node-&gt;parent-&gt;left === $node) &#123; $node-&gt;parent-&gt;left = $node-&gt;right; $node-&gt;right-&gt;parent = $node-&gt;parent; &#125; else &#123; $node-&gt;parent-&gt;right = $node-&gt;right; $node-&gt;right-&gt;parent = $node-&gt;parent; &#125; $node-&gt;right = NULL; &#125;&#125; 以下的 Example code 的邏輯是？ Example:&lt;?phpclass BST &#123; public $root = NULL; public function __construct(int $data) &#123; $this-&gt;root = new Node($data); &#125; public function isEmpty(): bool &#123; return $this-&gt;root === NULL; &#125; public function insert(int $data) &#123; if($this-&gt;isEmpty()) &#123; $node = new Node($data); $this-&gt;root = $node; return $node; &#125; $node = $this-&gt;root; while($node) &#123; if($data &gt; $node-&gt;data) &#123; if($node-&gt;right) &#123; $node = $node-&gt;right; &#125; else &#123; $node-&gt;right = new Node($data); $node = $node-&gt;right; break; &#125; &#125; elseif($data &lt; $node-&gt;data) &#123; if($node-&gt;left) &#123; $node = $node-&gt;left; &#125; else &#123; $node-&gt;left = new Node($data); $node = $node-&gt;left; break; &#125; &#125; else &#123; break; &#125; &#125; return $node; &#125; public function traverse(Node $node) &#123; if ($node) &#123; if ($node-&gt;left) $this-&gt;traverse($node-&gt;left); echo $node-&gt;data . &quot;\\n&quot;; if ($node-&gt;right) $this-&gt;traverse($node-&gt;right); &#125; &#125;&#125; Answer:&lt;?phpclass BST &#123; public $root = NULL; public function __construct(int $data) &#123; $this-&gt;root = new Node($data); &#125; public function isEmpty(): bool &#123; return $this-&gt;root === NULL; &#125; public function insert(int $data) &#123; // 若該 tree 為 empty, assign root 為該 node if($this-&gt;isEmpty()) &#123; $node = new Node($data); $this-&gt;root = $node; return $node; &#125; $node = $this-&gt;root; while($node) &#123; // 如果帶入的 data 比當前 node 大, 進入判斷 if($data &gt; $node-&gt;data) &#123; // 如果當前 node 底下有 right child node if($node-&gt;right) &#123; // 將當前 node 替換為其 child right node // 繼續 loop 看 child right node 會進哪一個判斷 $node = $node-&gt;right; // 如果當前 node 底下沒有 right child node &#125; else &#123; // 將 new node assign 給 right child node $node-&gt;right = new Node($data); $node = $node-&gt;right; // 結束 loop break; &#125; // 如果帶入的 data 比當前 node 小, 進入判斷 &#125; elseif($data &lt; $node-&gt;data) &#123; // 如果當前 node 底下有 left child node if($node-&gt;left) &#123; // 將當前 node 替換為其 child left node // 繼續 loop 看 child left node 會進哪一個判斷 $node = $node-&gt;left; // 如果當前 node 底下沒有 left child node &#125; else &#123; // 將 new node assign 給 left child node $node-&gt;left = new Node($data); $node = $node-&gt;left; // 結束 loop break; &#125; // 如果帶入的 data 不大於也不小於當前 node, 那有可能是等於當前 node, 直接結束迴圈 &#125; else &#123; break; &#125; &#125; return $node; &#125; public function traverse(Node $node) &#123; // 如果有帶入 node, 進判斷 if ($node) &#123; // 如果該 node 有 left child node if ($node-&gt;left) // 遞迴 traverse function, argument 為當前 node 的 left child node $this-&gt;traverse($node-&gt;left); // 印出當前 node 的 data echo $node-&gt;data . &quot;\\n&quot;; if ($node-&gt;right) // 遞迴 traverse function, argument 為當前 node 的 right child node $this-&gt;traverse($node-&gt;right); &#125; &#125;&#125; 以下的 Example code 的邏輯是？ Example:&lt;?phpclass Node &#123; public $data; public $left; public $right; public function __construct(int $data = NULL) &#123; $this-&gt;data = $data; $this-&gt;left = NULL; $this-&gt;right = NULL; &#125; public function min() &#123; $node = $this; while($node-&gt;left) &#123; $node = $node-&gt;left; &#125; return $node; &#125; public function max() &#123; $node = $this; while($node-&gt;right) &#123; $node = $node-&gt;right; &#125; return $node; &#125; public function successor() &#123; $node = $this; if($node-&gt;right) return $node-&gt;right-&gt;min(); else return NULL; &#125; public function predecessor() &#123; $node = $this; if($node-&gt;left) return $node-&gt;left-&gt;max(); else return NULL; &#125;&#125; Answer:&lt;?phpclass Node &#123; public $data; public $left; public $right; public function __construct(int $data = NULL) &#123; $this-&gt;data = $data; $this-&gt;left = NULL; $this-&gt;right = NULL; &#125; public function min() &#123; $node = $this; // BST 的規則中, 每個 node 的兩個 children node, 左邊的小於 parent, 右邊的大於 parent // 所以 min 的是最底層的最左 while($node-&gt;left) &#123; $node = $node-&gt;left; &#125; return $node; &#125; public function max() &#123; $node = $this; // BST 的規則中, 每個 node 的兩個 children node, 左邊的小於 parent, 右邊的大於 parent // 所以 min 的是最底層的最右 while($node-&gt;right) &#123; $node = $node-&gt;right; &#125; return $node; &#125; public function successor() &#123; $node = $this; // BST 的規則中, 每個 node 的兩個 children node, 左邊的小於 parent, 右邊的大於 parent // 所以該 node 的 successor 為右邊 child node 下的最小值, // 也就是右邊 child node 下的最左最底那個 node if($node-&gt;right) return $node-&gt;right-&gt;min(); else return NULL; &#125; public function predecessor() &#123; $node = $this; // BST 的規則中, 每個 node 的兩個 children node, 左邊的小於 parent, 右邊的大於 parent // 所以該 node 的 presuccessor 為左邊 child node 下的最大值, // 也就是左邊 child node 下的最右最底那個 node if($node-&gt;left) return $node-&gt;left-&gt;max(); else return NULL; &#125;&#125; 以下的 Example code 的邏輯是？ Example:&lt;?phpclass BST &#123; public $root = NULL; public function __construct(int $data) &#123; $this-&gt;root = new Node($data); &#125; public function isEmpty(): bool &#123; return $this-&gt;root === NULL; &#125; public function insert(int $data) &#123; if($this-&gt;isEmpty()) &#123; $node = new Node($data); $this-&gt;root = $node; return $node; &#125; $node = $this-&gt;root; while($node) &#123; if($data &gt; $node-&gt;data) &#123; if($node-&gt;right) &#123; $node = $node-&gt;right; &#125; else &#123; $node-&gt;right = new Node($data); $node = $node-&gt;right; break; &#125; &#125; elseif($data &lt; $node-&gt;data) &#123; if($node-&gt;left) &#123; $node = $node-&gt;left; &#125; else &#123; $node-&gt;left = new Node($data); $node = $node-&gt;left; break; &#125; &#125; else &#123; break; &#125; &#125; return $node; &#125; Answer:PHP code implement BST structure 以下的 Example code 的邏輯是？ Example:&lt;?phpclass BinaryTree &#123; public $nodes = []; public function __construct(Array $nodes) &#123; $this-&gt;nodes = $nodes; &#125; public function traverse(int $num = 0, int $level = 0) &#123; if (isset($this-&gt;nodes[$num])) &#123; echo str_repeat(&quot;-&quot;, $level); echo $this-&gt;nodes[$num] . &quot;\\n&quot;; $this-&gt;traverse(2 * $num + 1, $level+1); $this-&gt;traverse(2 * ($num + 1), $level+1); &#125; &#125; &#125; Answer:利用 PHP array implement Binary Tree 以下的 Example code 的邏輯是？ Example:&lt;?phpclass BinaryNode &#123; public $data; public $left; public $right; public function __construct(string $data = NULL) &#123; $this-&gt;data = $data; $this-&gt;left = NULL; $this-&gt;right = NULL; &#125; public function addChildren(BinaryNode $left, BinaryNode $right) &#123; $this-&gt;left = $left; $this-&gt;right = $right; &#125;&#125;class BinaryTree &#123; public $root = NULL; public function __construct(BinaryNode $node) &#123; $this-&gt;root = $node; &#125; public function traverse(BinaryNode $node, int $level = 0) &#123; if ($node) &#123; echo str_repeat(&quot;-&quot;, $level); echo $node-&gt;data . &quot;\\n&quot;; if ($node-&gt;left) $this-&gt;traverse($node-&gt;left, $level + 1); if ($node-&gt;right) $this-&gt;traverse($node-&gt;right, $level + 1); &#125; &#125; &#125; Answer:implement tree data structure Data Structure 中, N-ary Tree 的 node 可以有幾個 children?N 個 Data Structure 中, B-tree 跟一般的 BST 有什麼差異？B-tree 的 child node 沒有限制, BST 只可有兩個 以下的 AVL tree 圖片中, 規則是？ Example: Answer:每一個 node 的 subtree 的 height 最大容許值 = 1拿 J 來說, 其 subtree P 線的 height 為 4, 而另一個 subtree F 的 height 為 3, 所以 3 - 2 = 1拿 F 來說, 其 subtree D 線的 height 為 2, 而 G 線則為 1, 所以 0 - 1 = -1 以下的圖片中, 哪一個是 height-balanced tree? Example: Answer:右邊 以下的圖片中, H 的 depth 是多少？ Example: Answer:2, 與 root node 之間的 edges 數量 以下的圖片中, height of tree 是多少？ Example: Answer:root node 的高度, 此例中, 為 3 以下的圖片中, B 的 level 為多少？ Example: Answer:B 的 level 為 1A = 0B, C, D 為 1依此往下類推 以下的圖片中, B 的 height of node 為多少？ Example: Answer:2B 與其最底層 Descendent 之間相隔的 edges 數量 以下的圖片中, A 的 degree 為多少？ Example: Answer:3child node 的數量 以下的圖片中, M 的 Ancestors 是哪些 node？ Example: Answer:H, G, F, C, A 以下的圖片中, C 的 Descendents 有哪些 node？ Example: Answer:F, G, H, M 以下程式碼的邏輯是？ Example:&lt;?phpclass listnode&#123; public $data = null; public $next = null; public $prev = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function delete(string $query = null) &#123; if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; if ($currentNode-&gt;data === $query) &#123; if ($currentNode-&gt;next === null) &#123; $previous-&gt;next = null; &#125; else &#123; $previous-&gt;next = $currentNode-&gt;next; $currentNode-&gt;next-&gt;prev = $previous; &#125; $this-&gt;_totalNode--; break; &#125; $previous = $currentNode; $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; Answer:&lt;?phpclass doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function delete(string $query = null) &#123; // 如果非為空 if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; // 如果找到了 if ($currentNode-&gt;data === $query) &#123; // 如果該 node 是最後一個 if ($currentNode-&gt;next === null) &#123; $previous-&gt;next = null; &#125; else &#123; // 這樣等於不指向 currentNode 了 $previous-&gt;next = $currentNode-&gt;next; // 同上 $currentNode-&gt;next-&gt;prev = $previous; &#125; $this-&gt;_totalNode--; break; &#125; $previous = $currentNode; $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass listnode&#123; public $data = null; public $next = null; public $prev = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function deleteLast() &#123; if ($this-&gt;_lastNode !== null) &#123; $currentNode = $this-&gt;_lastNode; if ($currentNode-&gt;prev === null) &#123; $this-&gt;_firstNode = null; $this-&gt;_lastNode = null; &#125; else &#123; $previousNode = $currentNode-&gt;prev; $this-&gt;_lastNode = $previousNode; $previousNode-&gt;next = null; $this-&gt;_totalNode--; return true; &#125; &#125; return false; &#125;&#125; Answer:&lt;?phpclass doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function deleteLast() &#123; // 如果不是空的 list if ($this-&gt;_lastNode !== null) &#123; $currentNode = $this-&gt;_lastNode; // 如果只有一個 node if ($currentNode-&gt;prev === null) &#123; // 將 firstNode 以及 lastNode 都去掉 $this-&gt;_firstNode = null; $this-&gt;_lastNode = null; // 如果不是只有一個 node &#125; else &#123; // 取得 previousNode $previousNode = $currentNode-&gt;prev; // 更新 lastNode $this-&gt;_lastNode = $previousNode; // 更新 lastNode property $previousNode-&gt;next = null; $this-&gt;_totalNode--; return true; &#125; &#125; return false; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass listnode&#123; public $data = null; public $next = null; public $prev = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function deleteFirst() &#123; if ($this-&gt;_firstNode !== null) &#123; if ($this-&gt;_firstNode-&gt;next !== null) &#123; $this-&gt;_firstNode = $this-&gt;_firstNode-&gt;next; $this-&gt;_firstNode-&gt;prev = null; &#125; else &#123; $this-&gt;_firstNode = null; &#125; $this-&gt;_totalNode--; return true; &#125; return false; &#125;&#125; Answer:&lt;?phpclass doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function deleteFirst() &#123; // 如果 list 非為空 if ($this-&gt;_firstNode !== null) &#123; // 如果這不是唯一一個 node if ($this-&gt;_firstNode-&gt;next !== null) &#123; // firstNode 等於下一個, 所以原本的 firstnode delete 掉了 $this-&gt;_firstNode = $this-&gt;_firstNode-&gt;next; // 新的 firstNode 的 prev 為 null $this-&gt;_firstNode-&gt;prev = null; &#125; else &#123; // 如果是唯一 node, 直接去掉即可 $this-&gt;_firstNode = null; &#125; $this-&gt;_totalNode--; return true; &#125; return false; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass listnode&#123; public $data = null; public $next = null; public $prev = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function insertBefore( string $data = null, string $query = null ) &#123; $newNode = new ListNode($data); if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; if ($currentNode-&gt;data === $query) &#123; $newNode-&gt;next = $currentNode; $currentNode-&gt;prev = $newNode; $previous-&gt;next = $newNode; $newNode-&gt;prev = $previous; $this-&gt;_totalNode++; break; &#125; $previous = $currentNode; $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; Answer:&lt;?phpclass doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function insertBefore( string $data = null, string $query = null ) &#123; $newNode = new ListNode($data); // 如果非為空 if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; // 如果該 node 非為該 list 中的最後一個 node, 持續 loop while ($currentNode !== null) &#123; // 找到 specific node if ($currentNode-&gt;data === $query) &#123; // newNode 的 next 為當前的 currentNode $newNode-&gt;next = $currentNode; // 當前 currentNode 的 prev 為帶入的 newNode $currentNode-&gt;prev = $newNode; // 若找到的 node 為第一個, previous 為 null $previous-&gt;next = $newNode; // $previous 為 insert 進去的 node 的 prev 指向, 呈上, 若 found node 為第一個, 則 prev 為 newNode 自己 $newNode-&gt;prev = $previous; $this-&gt;_totalNode++; break; &#125; // 若沒找到, 則 previous 為上一個 node $previous = $currentNode; // 繼續找下一個 $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass listnode&#123; public $data = null; public $next = null; public $prev = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function insertAtLast(string $data = null) &#123; $newNode = new ListNode($data); if ($this-&gt;_firstNode === null) &#123; $this-&gt;_firstNode = &amp;$newNode; $this-&gt;_lastNode = $newNode; &#125; else &#123; $currentNode = $this-&gt;_lastNode; $currentNode-&gt;next = $newNode; $newNode-&gt;prev = $currentNode; $this-&gt;_lastNode = $newNode; &#125; $this-&gt;_totalNode++; return true; &#125;&#125; Answer:&lt;?phpclass doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function insertAtLast(string $data = null) &#123; $newNode = new ListNode($data); // 如果為空, 則將 newNode 設為 firstNode 以及 lastNode if ($this-&gt;_firstNode === null) &#123; $this-&gt;_firstNode = &amp;$newNode; $this-&gt;_lastNode = $newNode; // 如果不為空 &#125; else &#123; // 先取得目前的 lastnode $currentNode = $this-&gt;_lastNode; // 將目前的 lastnode 的 next 指向 newnode $currentNode-&gt;next = $newNode; // 將 newnode 的 prev 指向目前的 lastnode $newNode-&gt;prev = $currentNode; // 將新的 lastnode 指向 newnode $this-&gt;_lastNode = $newNode; &#125; $this-&gt;_totalNode++; return true; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass listnode&#123; public $data = null; public $next = null; public $prev = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function insertatfirst(string $data = null) &#123; $newnode = new listnode($data); if ($this-&gt;_firstnode === null) &#123; $this-&gt;_firstnode = &amp;$newnode; $this-&gt;_lastnode = $newnode; &#125; else &#123; $currentfirstnode = $this-&gt;_firstnode; $this-&gt;_firstnode = &amp;$newnode; $newnode-&gt;next = $currentfirstnode; $currentfirstnode-&gt;prev = $newnode; &#125; $this-&gt;_totalnode++; return true; &#125;&#125; Answer:&lt;?phpclass doublylinkedlist&#123; private $_firstnode = null; private $_lastnode = null; private $_totalnode = 0; public function insertatfirst(string $data = null) &#123; $newnode = new listnode($data); // 如果為空 if ($this-&gt;_firstnode === null) &#123; $this-&gt;_firstnode = &amp;$newnode; $this-&gt;_lastnode = $newnode; // 如果非為空 &#125; else &#123; // 先取出 firstNode 並設為 $currentFirstNode $currentfirstnode = $this-&gt;_firstnode; // 將 new node 設為 firstNode $this-&gt;_firstnode = &amp;$newnode; // new node 的 next 為原本的 first node, 因為 newNode 與 firstNode 已綁定, 這邊也會同時修改到 firstNode $newnode-&gt;next = $currentfirstnode; // 將原本的 firstNode 的 prev 設為 newNode $currentfirstnode-&gt;prev = $newnode; &#125; $this-&gt;_totalnode++; return true; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class CircularLinkedList&#123; private $_firstNode = null; private $_totalNode = 0; public function insertAtEnd(string $data = null) &#123; $newNode = new ListNode($data); if ($this-&gt;_firstNode === null) &#123; $this-&gt;_firstNode = &amp;$newNode; &#125; else &#123; $currentNode = $this-&gt;_firstNode; while ($currentNode-&gt;next !== $this-&gt;_firstNode) &#123; $currentNode = $currentNode-&gt;next; &#125; $currentNode-&gt;next = $newNode; &#125; $newNode-&gt;next = $this-&gt;_firstNode; $this-&gt;_totalNode++; return true; &#125;&#125; Answer:&lt;?phpclass CircularLinkedList&#123; private $_firstNode = null; private $_totalNode = 0; public function insertAtEnd(string $data = null) &#123; $newNode = new ListNode($data); // 如果 list 為空 if ($this-&gt;_firstNode === null) &#123; $this-&gt;_firstNode = &amp;$newNode; // 如果 list 不為空 &#125; else &#123; $currentNode = $this-&gt;_firstNode; // 一直往下找, 只要 $currentNode-&gt;next 不等於 $currentNode 自己, // 如果 $currentNode-&gt;next 等於 $currentNode 自己, 那表示找到最後一個了 while ($currentNode-&gt;next !== $this-&gt;_firstNode) &#123; $currentNode = $currentNode-&gt;next; &#125; // 將最後一個 node-&gt;next 等於 $newNode, 相當於原本的 next 是自己, 現在變成 $newNode $currentNode-&gt;next = $newNode; &#125; // 如果 $newNode 為第一個 node, $newNode-&gt;next 會等於 $newNode 自己, // 所以會是一個 object 的 next property 是 object 自己, 可參照下圖 // 如果 $newNode 不是此 list 的第一個 node, 那 $newNode 相當於最後一個 node, // 將其 next 指向第一個 node, 完成 circular $newNode-&gt;next = $this-&gt;_firstNode; $this-&gt;_totalNode++; return true; &#125;&#125; 圖片 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function getNthNode(int $n = 0) &#123; $count = 1; if ($this-&gt;_firstNode !== null) &#123; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; if ($count === $n) &#123; return $currentNode; &#125; $count++; $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function getNthNode(int $n = 0) &#123; $count = 1; // 若非為空 if ($this-&gt;_firstNode !== null) &#123; // 取得 $currentNode $currentNode = $this-&gt;_firstNode; // loop 到後最一個 node while ($currentNode !== null) &#123; // 如果找到了 if ($count === $n) &#123; return $currentNode; &#125; $count++; // 繼續往下找 $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function reverse() &#123; if ($this-&gt;_firstNode !== null) &#123; if ($this-&gt;_firstNode-&gt;next !== null) &#123; $reversedList = null; $next = null; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; $next = $currentNode-&gt;next; $currentNode-&gt;next = $reversedList; $reversedList = $currentNode; $currentNode = $next; &#125; $this-&gt;_firstNode = $reversedList; &#125; &#125; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function reverse() &#123; // 如果非為空 if ($this-&gt;_firstNode !== null) &#123; // 如果此 list 非只有一個 node if ($this-&gt;_firstNode-&gt;next !== null) &#123; $reversedList = null; $next = null; $currentNode = $this-&gt;_firstNode; // loop 所有 node while ($currentNode !== null) &#123; // 這邊先取得 $next, loop 最後會用到 $next = $currentNode-&gt;next; // 將 $currentNode 的 next property 設為 $reversedList $currentNode-&gt;next = $reversedList; // 此時因為上面的 $currentNode 已經跟 $this-&gt;_firstNode 不同了, // 此時將 $reversedList 指向 $currentNode, 在第一輪, // $reversedList 的預設值為 null, 因此 $currentNode-&gt;next // 會是 null, 在第二輪, $reversedList 已經變成上一輪的 // $currentNode, 其 next 為 null, 所以上一行會變成是 // $currentNode-&gt;next = 上一輪的 $currentNode, // 而這一行會取得這這一個 linkedList, 讓 $revsersedList 指向它, // 所以在每一輪, reversedList 會變成一個 object, 不斷地指向上一個 node $reversedList = $currentNode; $currentNode = $next; &#125; // 最後, 將 $this-&gt;_firstNode 指向 $reversedList $this-&gt;_firstNode = $reversedList; &#125; &#125; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function delete(string $query = null) &#123; if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; if ($currentNode-&gt;data === $query) &#123; if ($currentNode-&gt;next === null) &#123; $previous-&gt;next = null; &#125; else &#123; $previous-&gt;next = $currentNode-&gt;next; &#125; $this-&gt;_totalNode--; break; &#125; $previous = $currentNode; $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function delete(string $query = null) &#123; // 如果非為空 if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; // 會 loop 到最後一個 while ($currentNode !== null) &#123; // 如果找到搜尋的 node if ($currentNode-&gt;data === $query) &#123; // 如果此 node 已是最後一個 if ($currentNode-&gt;next === null) &#123; // 變更 reference 的 property, 他會變更 $this-&gt;_firstNode 中的搜尋到的那一個 node 的 property, 所以會影響到 $this-&gt;_firstNode 的值 $previous-&gt;next = null; // 若不是最後一個 &#125; else &#123; // 這邊等於是把 currentNode 拿掉, 邏輯上是去變更 $previous (也就是 $currentNode 的上一個) 的 next property, 因此此 object 會變更, 連帶 $this-&gt;_firstNode 中也有此 object, 因此也會變更 $previous-&gt;next = $currentNode-&gt;next; &#125; $this-&gt;_totalNode--; break; &#125; // 即將新的 loop, 下一個 loop 中的 $previous 為當前 loop 中的 $currentNode $previous = $currentNode; // 取得下一輪 loop 中的 $currentNode $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function deleteLast() &#123; if ($this-&gt;_firstNode !== null) &#123; $currentNode = $this-&gt;_firstNode; if ($currentNode-&gt;next === null) &#123; $this-&gt;_firstNode = null; &#125; else &#123; $previousNode = null; while ($currentNode-&gt;next !== null) &#123; $previousNode = $currentNode; $currentNode = $currentNode-&gt;next; &#125; $previousNode-&gt;next = null; $this-&gt;_totalNode--; return true; &#125; &#125; return false; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function deleteLast() &#123; // 如果不是空的 if ($this-&gt;_firstNode !== null) &#123; $currentNode = $this-&gt;_firstNode; // 如果當前的是最後一個, 那就把當前的設為 null if ($currentNode-&gt;next === null) &#123; $this-&gt;_firstNode = null; // 如果不是最後一個 &#125; else &#123; $previousNode = null; // 找到最後一個為止 while ($currentNode-&gt;next !== null) &#123; $previousNode = $currentNode; // 找下一個 $currentNode = $currentNode-&gt;next; &#125; // 找到最後, 將 $previousNode-&gt;next 變成 null, 為什麼這邊不用 $currentNode = null 呢？ 因為 $currentNode 是一塊記憶體位址, 指向最後一個 node, 也就是最後一個 object, 如果我們讓 $currentNode = null, 實際上只是將 $currentNode 這塊記憶體位置變成 null, 其指向的 object 的值並不會改變。 但若是 $previousNode-&gt;next = null, 實際上是對 $previousNode 指向的 object 裡頭的 next property 做變更, 因此會更動到被指向的 object 的 property, 而這個 object 也是 $this-&gt;_firstNode 指向的 object, 因此也更新了 $this-&gt;_firstNode 的值 $previousNode-&gt;next = null; $this-&gt;_totalNode--; return true; &#125; &#125; return false; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function deleteFirst() &#123; if ($this-&gt;_firstNode !== null) &#123; if ($this-&gt;_firstNode-&gt;next !== null) &#123; $this-&gt;_firstNode = $this-&gt;_firstNode-&gt;next; &#125; else &#123; $this-&gt;_firstNode = null; &#125; $this-&gt;_totalNode--; return true; &#125; return false; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function deleteFirst() &#123; // 如果不是空的 list if ($this-&gt;_firstNode !== null) &#123; // 如果不是最後一個, 就把當前的等於下一個, 也就是當前的就不見啦 // 如果已經是最後一個, 就直接把當前的設為 null if ($this-&gt;_firstNode-&gt;next !== null) &#123; $this-&gt;_firstNode = $this-&gt;_firstNode-&gt;next; &#125; else &#123; $this-&gt;_firstNode = null; &#125; $this-&gt;_totalNode--; return true; &#125; return false; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function insertAfter( string $data = null, string $query = null ) &#123; $newNode = new ListNode($data); if ($this-&gt;_firstNode) &#123; $nextNode = null; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; if ($currentNode-&gt;data === $query) &#123; if ($nextNode !== null) &#123; $newNode-&gt;next = $nextNode; &#125; $currentNode-&gt;next = $newNode; $this-&gt;_totalNode++; break; &#125; $currentNode = $currentNode-&gt;next; $nextNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function insertAfter( string $data = null, string $query = null ) &#123; $newNode = new ListNode($data); // 如果不是空的 if ($this-&gt;_firstNode) &#123; $nextNode = null; $currentNode = $this-&gt;_firstNode; // 找到最後一個為止 while ($currentNode !== null) &#123; // 如果找到了 if ($currentNode-&gt;data === $query) &#123; // 如果當前 node 不是最後一個 if ($nextNode !== null) &#123; // 把下一個 node 接在 $newNode 之後 $newNode-&gt;next = $nextNode; &#125; // 把 $newNode 接在當前 node 之後 $currentNode-&gt;next = $newNode; $this-&gt;_totalNode++; // 結束 while loop break; &#125; // 如果沒找到, 並且還有沒跑過的 node, 才會執行到這一行 // 繼續往下找 $currentNode = $currentNode-&gt;next; $nextNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function insertBefore(string $data = null, string $query = null) &#123; $newNode = new ListNode($data); if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; if ($currentNode-&gt;data === $query) &#123; $newNode-&gt;next = $currentNode; $previous-&gt;next = $newNode; $this-&gt;_totalNode++; break; &#125; $previous = $currentNode; $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function insertBefore(string $data = null, string $query = null) &#123; // init an ListNode object $newNode = new ListNode($data); // 如果該 list 不是空的 if ($this-&gt;_firstNode) &#123; $previous = null; $currentNode = $this-&gt;_firstNode; // 往下找直到最後一個 while ($currentNode !== null) &#123; // 如果當前 node 值等於帶入的 query if ($currentNode-&gt;data === $query) &#123; // 將當前 node 接在 $newNode 之後 $newNode-&gt;next = $currentNode; // 如果是第一個, 自然為 null, 如果不是第一次, 會把 $newNode 接在上一個 node 之後 $previous-&gt;next = $newNode; $this-&gt;_totalNode++; break; &#125; // 如果 query 不等於當前 node 才會執行這一段 $previous = $currentNode; // 繼續往下找 $currentNode = $currentNode-&gt;next; &#125; &#125; &#125;&#125; 以下程式碼的邏輯是？ Example:class ListNode&#123; public $data = null; public $next = null; public function __construct(string $data = null) &#123; $this-&gt;data = $data; &#125;&#125;class LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function search(string $data = null) &#123; if ($this-&gt;_totalNode) &#123; $currentNode = $this-&gt;_firstNode; while ($currentNode !== null) &#123; if ($currentNode-&gt;data === $data) &#123; return $currentNode; &#125; $currentNode = $currentNode-&gt;next; &#125; &#125; return false; &#125;&#125; Answer:&lt;?phpclass LinkedList&#123; private $_firstNode = null; private $_totalNodes = 0; public function search(string $data = null) &#123; // 如果 totalNode !== null if ($this-&gt;_totalNode) &#123; $currentNode = $this-&gt;_firstNode; // 如果 $currentNode 不為 null, 表示還沒 search 完 while ($currentNode !== null) &#123; // 如果找到了就 return if ($currentNode-&gt;data === $data) &#123; return $currentNode; &#125; // 如果沒找到, 找下一個 $currentNode = $currentNode-&gt;next; &#125; &#125; // 沒找到就 return false return false; &#125;&#125; 以下程式碼的邏輯是？ Example:&lt;?phpclass ListNode &#123; public $data = NULL; public $next = NULL; public function __construct(string $data = NULL) &#123; $this-&gt;data = $data; &#125; class LinkedList &#123; private $_firstNode = NULL; private $_totalNodes = 0; public function insertAtFirst(string $data = NULL) &#123; $newNode = new ListNode($data); if ($this-&gt;_firstNode === NULL) &#123; $this-&gt;_firstNode = &amp;$newNode; &#125; else &#123; $currentFirstNode = $this-&gt;_firstNode; $this-&gt;_firstNode = &amp;$newNode; $newNode-&gt;next = $currentFirstNode; &#125; $this-&gt;_totalNode++; return TRUE; &#125; &#125; Answer: 建立一個新的 node 把這個新的 node 放在第一個 將之前的第一個 node 接在新的 node 後面 下圖是哪種資料結構？ 圖片 Answermulti-linked lists 下圖是哪種資料結構？ 圖片 AnswerCircular linked list PHP 當中如何實作 linked list, 概念即可&lt;?phpclass LinkedList &#123; private $_firstNode = NULL; private $_totalNodes = 0; public function insert(string $data = NULL) &#123; $newNode = new ListNode($data); if ($this-&gt;_firstNode === NULL) &#123; $this-&gt;_firstNode = &amp;$newNode; &#125; else &#123; $currentNode = $this-&gt;_firstNode; while ($currentNode-&gt;next !== NULL) &#123; $currentNode = $currentNode-&gt;next; &#125; $currentNode-&gt;next = $newNode; &#125; $this-&gt;_totalNode++; return TRUE; &#125; public function display() &#123; echo &quot;Total book titles: &quot;.$this-&gt;_totalNode.&quot;\\n&quot;; $currentNode = $this-&gt;_firstNode; while ($currentNode !== NULL) &#123; echo $currentNode-&gt;data . &quot;\\n&quot;; $currentNode = $currentNode-&gt;next; &#125; &#125; &#125; $BookTitles = new LinkedList(); $BookTitles-&gt;insert(&quot;Introduction to Algorithm&quot;); $BookTitles-&gt;insert(&quot;Introduction to PHP and Data structures&quot;); $BookTitles-&gt;insert(&quot;Programming Intelligence&quot;); $BookTitles-&gt;display(); PHP array 中, 取得 index 或 key 的 time complexity 是？O(1) 以下的 PHP code example, 可以怎麼優化, 概念即可 Example&lt;?php$odd = []; $odd[] = 1; $odd[] = 3; $odd[] = 5; $odd[] = 7; $odd[] = 9; $prime = []; $prime[] = 2; $prime[] = 3; $prime[] = 5; if (in_array(2, $prime)) &#123; echo &quot;2 is a prime&quot;; &#125; $union = array_merge($prime, $odd); $intersection = array_intersect($prime, $odd); $compliment = array_diff($prime, $odd); Answer:&lt;?php$odd = []; $odd[1] = true; $odd[3] = true; $odd[5] = true; $odd[7] = true; $odd[9] = true; $prime = []; $prime[2] = true; $prime[3] = true; $prime[5] = true; if (isset($prime[2])) &#123; echo &quot;2 is a prime&quot;; &#125; $union = $prime + $odd; $intersection = array_intersect_key($prime, $odd); $compliment = array_diff_key($prime, $odd); 以下的 PHP code example 當中, $compliment 屬於資料結構中 set 的哪一種 operation？ Example:&lt;?php$odd = []; $odd[] = 1; $odd[] = 3; $odd[] = 5; $odd[] = 7; $odd[] = 9; $prime = []; $prime[] = 2; $prime[] = 3; $prime[] = 5; if (in_array(2, $prime)) &#123; echo &quot;2 is a prime&quot;; &#125; $union = array_merge($prime, $odd); $intersection = array_intersect($prime, $odd); $compliment = array_diff($prime, $odd); Answer:complement operation 以下的 PHP code example 當中, $intersection 屬於資料結構中 set 的哪一種 operation？ Example:&lt;?php$odd = []; $odd[] = 1; $odd[] = 3; $odd[] = 5; $odd[] = 7; $odd[] = 9; $prime = []; $prime[] = 2; $prime[] = 3; $prime[] = 5; if (in_array(2, $prime)) &#123; echo &quot;2 is a prime&quot;; &#125; $union = array_merge($prime, $odd); $intersection = array_intersect($prime, $odd); $compliment = array_diff($prime, $odd); Answer:intersection operation 以下的 PHP code example 當中, $union 屬於資料結構中 set 的哪一種 operation？ Example:&lt;?php$odd = []; $odd[] = 1; $odd[] = 3; $odd[] = 5; $odd[] = 7; $odd[] = 9; $prime = []; $prime[] = 2; $prime[] = 3; $prime[] = 5; if (in_array(2, $prime)) &#123; echo &quot;2 is a prime&quot;; &#125; $union = array_merge($prime, $odd); $intersection = array_intersect($prime, $odd); $compliment = array_diff($prime, $odd); Answer:union operation 以下的 PHP code example 當中, $odd 跟 $prime 是資料結構中的哪一種？ Example:&lt;?php$odd = []; $odd[] = 1; $odd[] = 3; $odd[] = 5; $odd[] = 7; $odd[] = 9; $prime = []; $prime[] = 2; $prime[] = 3; $prime[] = 5; if (in_array(2, $prime)) &#123; echo &quot;2 is a prime&quot;; &#125; $union = array_merge($prime, $odd); $intersection = array_intersect($prime, $odd); $compliment = array_diff($prime, $odd); Answer:Sets 資料結構 sets 中, complement operation 的意思是？對兩個集合實施 intersection union operation 後, 輸出為兩個集合中不同的值 資料結構 sets 中, union operation 的意思是？對兩個集合實施 intersection union operation 後, 兩個集合有的其輸出都會有 資料結構 sets 中, intersection operation 的意思是？對兩個集合實施 intersection operation 後, 其值為兩個集合中的交集 以下的 PHP example 當中, ronaldo 算是什麼資料結構？ Example:&lt;?phpClass Player &#123; public $name; public $country; public $age; public $currentTeam; &#125; $ronaldo = new Player; $ronaldo-&gt;name = &quot;Ronaldo&quot;; $ronaldo-&gt;country = &quot;Portugal&quot;; $ronaldo-&gt;age = 31; $ronaldo-&gt;currentTeam = &quot;Real Madrid&quot;; Answer:struct 以下的 PHP example 當中, player1 跟 player2 算是什麼資料結構？ Example:&lt;?php$ronaldo = [ &quot;name&quot; =&gt; &quot;Ronaldo&quot;, &quot;country&quot; =&gt; &quot;Portugal&quot;, &quot;age&quot; =&gt; 31, &quot;currentTeam&quot; =&gt; &quot;Real Madrid&quot; ]; $messi = [ &quot;name&quot; =&gt; &quot;Messi&quot;, &quot;country&quot; =&gt; &quot;Argentina&quot;, &quot;age&quot; =&gt; 27, &quot;currentTeam&quot; =&gt; &quot;Barcelona&quot; ]; $team = [ &quot;player1&quot; =&gt; $ronaldo, &quot;player2&quot; =&gt; $messi ]; Answer:struct PHP 的 associative array 事實上是透過哪個資料結構達成的？hash table 以下 PHP code example 的意思是？ Example:&lt;?php$array = new SplFixedArray(100);for ($i = 0; $i &lt; 100; $i++) $array[$i] = new SplFixedArray(100); Answer:&lt;?php$array = new SplFixedArray(100);for ($i = 0; $i &lt; 100; $i++) // 使用 SplFixedArray 建立 multidimensional array$array[$i] = new SplFixedArray(100); 以下 PHP code example 的意思是？ Example:&lt;?php$items = 5; $array = new SplFixedArray($items); for ($i = 0; $i &lt; $items; $i++) &#123; $array[$i] = $i * 10; &#125; $array-&gt;setSize(10); $array[7] = 100; Answer:&lt;?php$items = 5; // 給予 SplFixedArray size$array = new SplFixedArray($items); for ($i = 0; $i &lt; $items; $i++) &#123; $array[$i] = $i * 10; &#125; // 重新指定 size$array-&gt;setSize(10); $array[7] = 100; 以下 PHP code example 的意思是？ Example:&lt;?php$items = 5; $array = new SplFixedArray($items); for ($i = 0; $i &lt; $items; $i++) &#123; $array[$i] = $i * 10; &#125; $newArray = $array-&gt;toArray(); print_r($newArray); Answer:&lt;?php$items = 5; $array = new SplFixedArray($items); for ($i = 0; $i &lt; $items; $i++) &#123; $array[$i] = $i * 10; &#125; // 將 SplFixedArray 轉化成 PHP Array$newArray = $array-&gt;toArray(); print_r($newArray); 以下 PHP code example 的意思是？ Example:&lt;?php$array =[1 =&gt; 10, 2 =&gt; 100, 3 =&gt; 1000, 4 =&gt; 10000]; $splArray = SplFixedArray::fromArray($array); print_r($splArray); Answer:&lt;?php$array =[1 =&gt; 10, 2 =&gt; 100, 3 =&gt; 1000, 4 =&gt; 10000]; // 將原生 array 轉換成 SplFixedArray$splArray = SplFixedArray::fromArray($array); print_r($splArray); PHP 中, SplFixedArray 跟 PHP Array 最大的優勢是？SplFixedArray 使用的記憶體較少 以下 PHP code example 的意思是？ example&lt;?php$items = 100000; $startMemory = memory_get_usage(); $array = new SplFixedArray($items); for ($i = 0; $i &lt; $items; $i++) &#123; $array[$i] = $i; &#125; $endMemory = memory_get_usage(); $memoryConsumed = ($endMemory - $startMemory) / (1024*1024); $memoryConsumed = ceil($memoryConsumed); echo &quot;memory = &#123;$memoryConsumed&#125; MB\\n&quot;; Answer&lt;?php$items = 100000; // 取得記憶體使用量$startMemory = memory_get_usage(); // 使用 SplFixedArray 建立 size 為 100000 的 array$array = new SplFixedArray($items); // 賦值for ($i = 0; $i &lt; $items; $i++) &#123; $array[$i] = $i; &#125; // 取得記憶體使用量$endMemory = memory_get_usage(); $memoryConsumed = ($endMemory - $startMemory) / (1024*1024); $memoryConsumed = ceil($memoryConsumed); echo &quot;memory = &#123;$memoryConsumed&#125; MB\\n&quot;; 如何使用 PHP array 來表示以下 graph data structure? 概念即可 Example: Answer:&lt;?php$graph = [];$nodes = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;];foreach ($nodes as $xNode) &#123; foreach ($nodes as $yNode) &#123; $graph[$xNode][$yNode] = 0; &#125;&#125;$graph[&quot;A&quot;][&quot;B&quot;] = 1;$graph[&quot;B&quot;][&quot;A&quot;] = 1;$graph[&quot;A&quot;][&quot;C&quot;] = 1;$graph[&quot;C&quot;][&quot;A&quot;] = 1;$graph[&quot;A&quot;][&quot;E&quot;] = 1;$graph[&quot;E&quot;][&quot;A&quot;] = 1;$graph[&quot;B&quot;][&quot;E&quot;] = 1;$graph[&quot;E&quot;][&quot;B&quot;] = 1;$graph[&quot;B&quot;][&quot;D&quot;] = 1;$graph[&quot;D&quot;][&quot;B&quot;] = 1; 以下的 PHP example 的 size 是多少？ Example:&lt;?php$array = []; $array[10] = 100; $array[21] = 200; $array[29] = 300; $array[500] = 1000; $array[1001] = 10000; $array[71] = 1971; Answer:7 以下的 PHP example 的輸出是？ Example:&lt;?php$array = []; $array[10] = 100; $array[21] = 200; $array[29] = 300; $array[500] = 1000; $array[1001] = 10000; $array[71] = 1971; foreach($array as $index =&gt; $value) &#123; echo &quot;Position &quot;.$index.&quot; holds the value &quot;.$value.&quot;\\n&quot;; &#125; Answer:&lt;?phpPosition 10 holds the value 100 Position 21 holds the value 200 Position 29 holds the value 300 Position 500 holds the value 1000 Position 1001 holds the value 10000 Position 71 holds the value 1971 演算法中, O(n) 的意思是？執行一段程式的最大執行次數 演算法中, implementation 後做的 analysis 又稱為？empirical analysis 演算法中, implementation 前做的 analysis 又稱為？theoretical analysis 演算法中, Storage Complexity 的定義是？需要多少儲存空間可以輸出？ 演算法中, Time Complexity 的定義是？需要幾步可以輸出？ 資料結構中, Heap 是基於哪一個資料結構上？？Tree 以下圖片代表哪種資料結構？ 圖片: Answer:Heap 以下圖片代表哪種資料結構？ 圖片: Answer:Graph 資料結構中, Graph 相當於一對集合, 分別是哪兩個集合？？ vertices edges 資料結構 Graph 中, 代表點的叫做？？vertices or nodes 資料結構 Graph 中, 代表方向的叫做？？edge or arc 資料結構中, Graph 又分為哪兩大類？ directed undirected 資料結構中, Tree 的最頂端稱為？root 資料結構中, Tree 是屬於 liner 還是 nonliner?nonliner 以下圖片代表哪種資料結構？ 圖片: Answer:Tree 資料結構中, Map 相當於 PHP 中的什麼型態的 array？？associative array 資料結構中, 從 queue 移除 item 的方法稱為？？dequeue 資料結構中, 增加新的 item 到 queue 的方法稱為？？enqueue 資料結構中, Queue 的特性是？FIFO 以下圖片代表哪種資料結構？ 圖片: Answer:Queue 從 stack 資料結構移除資料的方法叫做？pop 從 stack 資料結構加資料進去的方法叫做？push 資料結構主要又分成哪兩大群組？ liner data structures nonliner data structures 以下圖片代表哪種資料結構？ 圖片: Answer:linked list 以下圖片代表哪種資料結構？ 圖片: Answer:doubly linked list 以下圖片代表哪種資料結構？ 圖片: Answer:stack Stack 資料結構有什麼特性？LIFO # 參考資料[PHP 7 Data Structures and Algorithms: Implement linked lists, stacks, and queues using PHP`, no English version](https://www.amazon.com/PHP-Data-Structures-Algorithms-Implement-ebook/dp/B01IF7NLDW)","link":"/zh-tw/php-data-structure-and-algorithm/"},{"title":"Recursion - 建立一個 N-level category tree","text":"# 前言本篇將會使用 recursion 來呈現 N-level category tree # 步驟 將 category tree 的階層關係定義在資料庫 從資料庫取出所有的 category 資料 使用 recursion 來呈現不同的 category 之間的 level 關係 # 定義階層關係到資料庫# 建立資料表CREATE TABLE `categories` ( `id` int(11) NOT NULL, `categoryName` varchar(100) NOT NULL, `parentCategory` int(11) DEFAULT 0, ) ENGINE=InnoDB DEFAULT CHARSET=utf8; # INSERT 階層關係INSERT INTO categories VALUES (0,&#x27;First&#x27;, 0), (0,&#x27;Second&#x27;, 1), (0,&#x27;Third&#x27;, 1), (0,&#x27;Fourth&#x27;, 3), (0,&#x27;Fifth&#x27;, 4), (0,&#x27;Sixth&#x27;, 5), (0,&#x27;Seventh&#x27;, 6), (0,&#x27;Eighth&#x27;, 7), (0,&#x27;Ninth&#x27;, 1), (0,&#x27;Tenth&#x27;, 2); 此時階層關係像是: # 取出資料使用 PHP 來取出資料 &lt;?php$dsn = &quot;mysql:host=127.0.0.1;port=3306;dbname=test;&quot;;$username = &quot;root&quot;;$password = &quot;&quot;;$dbh = new PDO($dsn, $username, $password);$result = $dbh-&gt;query(&quot;Select * from categories order by parentCategory asc&quot;, PDO::FETCH_OBJ);$categories = [];foreach($result as $row) &#123; $categories[$row-&gt;parentCategory][] = $row;&#125; # 使用 recursion 呈現階層關係使用 recursion, 我們只需帶入 root category, 便會把下面的所有 category 都顯示出來loop 會 echo 每一個 parentCategory 底下的 category, 而隨後的 recursion 會檢查這些 category 是否底下還有 child categoriesif(isset($categories[$n])) 是此 recursion 的終點判斷, 我們通過上面取得的 $categories 為 array with parentCategoryId as index, 所以要是 isset($categories[$n]) 為 false, 表示該 category 底下沒有 child category此 recursion 屬於之前介紹過的 tail recursion &lt;?phpfunction showCategoryTree(Array $categories, int $n) &#123; if(isset($categories[$n])) &#123; foreach($categories[$n] as $category) &#123; echo str_repeat(&quot;-&quot;, $n).&quot;&quot;.$category-&gt;categoryName.&quot;\\n&quot;; showCategoryTree($categories, $category-&gt;id); &#125; &#125; return;&#125;showCategoryTree($categories, 0); 輸出： First-Second--Tenth-Third---Fourth----Fifth-----Sixth------Seventh-------Eighth-Ninth - 的數量表示其 parent category, 例如 ---Fourth 位於 Third category 之下 # 結語本篇到此結束啦, 我們下次見！","link":"/zh-tw/recursion-build-a-n-level-category-tree/"},{"title":"Sequelize 學習筆記","text":"參考連結官方網站 安裝npm install --save sequelize or yarn add sequelize --save 以下手動安裝： npm install --save pg pg-hstorenpm install --save mysql2npm install --save mariadbnpm install --save sqlite3npm install --save tedious # Microsoft SQL Server or yarn add pg pg-hstore --saveyarn add mysql2 --saveyarn add mariadb --saveyarn add sqlite3 --saveyarn add tedious # Microsoft SQL Server --save Migration參考官方網站 安裝 Migration CLInpm install --save sequelize-cli or yarn add sequelize-cli --save 快速開始參考官方網站 npx sequelize-cli init 會自動建立以下資料夾: config: 連接資料庫的設定 models: 這個專案 Models 的存放位置 migrations: Migration 放置處 seeders: seeds 檔案 請把以下的 operationAliases 刪掉 config.json &quot;development&quot;:&#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: null, &quot;database&quot;: &quot;database_development&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;operatorsAliases&quot;: false&#125; 建立 migration參考官方網站 npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string name: Model 名稱 attributes: 欄位屬性 會做以下的事: 建立一個 user model 在 migration 資料夾，建立一個 migration 檔案，名稱像是 XXXXXXXXXXXXXX-create-user.js 執行 migration參考官方網站 npx sequelize-cli db:migrate 取消 migration參考官方網站 取消最新一個 migration npx sequelize-cli db:migrate:undo 取消全部的 migration, 然後重新 migrate 到指定的檔案 npx sequelize-cli db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js 變更設定檔位置，名稱如果: 你想要重新定義 migration, models, seeders, 或 config 的資料夾位置 你想要重新命名 config.json, 比如說, database.json 那： 建立 .sequelizerc 檔案 touch .sequelizerc 範例格式 const path = require(&#x27;path&#x27;);module.exports = &#123; &#x27;config&#x27;: path.resolve(&#x27;config&#x27;, &#x27;database.json&#x27;), &#x27;models-path&#x27;: path.resolve(&#x27;db&#x27;, &#x27;models&#x27;), &#x27;seeders-path&#x27;: path.resolve(&#x27;db&#x27;, &#x27;seeders&#x27;), &#x27;migrations-path&#x27;: path.resolve(&#x27;db&#x27;, &#x27;migrations&#x27;)&#125; 以上的設定會告訴 CLI 使用 config/database.json 為設定檔 使用 `db/models/ 為 models 的資料夾 使用 db/seeders 為 seeders 資料夾 使用 db/migrations 為 migration 資料夾 有時我們會需要更改 config 檔案副檔名, 因為我們需要一些 json 無法提供的功能, 例如： const fs = require(&#x27;fs&#x27;); production: &#123; username: process.env.DB_USERNAME, password: process.env.DB_PASSWORD, database: process.env.DB_NAME, host: process.env.DB_HOSTNAME, dialect: &#x27;mysql&#x27;, dialectOptions: &#123; ssl: &#123; ca: fs.readFileSync(__dirname + &#x27;/mysql-ca-master.crt&#x27;) &#125; &#125;&#125;; 這時我們可以在 .sequelizerc 檔案中修改 const path = require(&#x27;path&#x27;);module.exports = &#123; &#x27;config&#x27;: path.resolve(&#x27;config&#x27;, &#x27;config.js&#x27;)&#125; 最後別忘了修改 /models/index 中, config 的路徑 在 model 中增加 method&#x27;use strict&#x27;;module.exports = (sequelize, DataTypes) =&gt; &#123; const User = sequelize.define(&#x27;User&#x27;, &#123; firstName: DataTypes.STRING, lastName: DataTypes.STRING, email: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here &#125;; User.prototype.useInstance = function () &#123; console.log(&#x27;This is for new instance way&#x27;); &#125;; User.useStatic = function () &#123; console.log(&#x27;This is for static way&#x27;); &#125;; return User;&#125;; 使用 async/await直接 await method 就可 (async () =&gt; &#123; let result = await Data.findAll(&#123; attributes: [ &#x27;host&#x27;, &#x27;upstream_cache_status&#x27;, [Sequelize.fn(&#x27;COUNT&#x27;, Sequelize.col(&#x27;request&#x27;)), &#x27;requests&#x27;], ], group: [&#x27;host&#x27;, &#x27;upstream_cache_status&#x27;] &#125;); console.log(result)&#125;)();","link":"/zh-tw/sequelize/"},{"title":"MySQL 學習筆記","text":"# 前言如果可以過目不忘, 那可能就不用寫 Blog 了… # 未開始先談移除 打開 terminal 使用 mysqldump 備份你的資料庫 mysqldump -u你的使用者名 -p --all-databases &gt; /tmp/backup.sql 尋找是否還有 MySQL process, 若有的話, 使用 kill -9 processId 砍掉 ps -ax | grep mysql 若使用 brew, 使用 brew 刪除 brew remove mysqlbrew cleanup 移除以下檔案 sudo rm /usr/local/mysqlsudo rm -rf /usr/local/var/mysqlsudo rm -rf /usr/local/mysql*sudo rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plistsudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My* 卸載之前的 MySQL 自動登入 launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 移除之前的 MySQL 設定 vim /etc/hostconfig# Remove the line MYSQLCOM=-YES- 移除以下檔案 rm -rf ~/Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /private/var/db/receipts/*mysql* 重啟電腦, 確保沒有任何程序在跑 執行 mysql, 應該不能執行 # 使用者帳號及權限建立使用者CREATE USER &#x27;userName&#x27;@&#x27;userHost&#x27;IDENTIFIED BY &#x27;userPassword&#x27;; 更改使用者名稱RENAME USER &#x27;userName&#x27;@&#x27;hostName&#x27; TO &#x27;newUserName&#x27;@&#x27;newHostName&#x27; 更改使用者密碼SET PASSWORD FOR &#x27;userName&#x27;@&#x27;hostName&#x27; = &#x27;newPassword&#x27; 顯示特定使用者權限SHOW GRANTS FOR &#x27;userName&#x27; 賦予已建立的使用者權限 SQL 敘述:GRANT ALL ON &#x27;databaseName&#x27;.&#x27;tableName&#x27; TO &#x27;userName&#x27;@&#x27;hostName&#x27;GRANT SELECT (columnName1, columnName2, ...) ON &#x27;databaseName&#x27;.&#x27;tableName&#x27; TO &#x27;userName&#x27;@&#x27;hostName&#x27; 備註:需注意, 在 MySQL 8, username 加上 hostName 視為一個完整的 GRANT 對象, 如果 hostName 不同, 即使 userName 相同, 對 GRANT 來說也是不同對象 顯示所有 user 以及 hostSELECT User, HostFROM mysql.userWHERE User LIKE &#x27;userName&#x27;; 刪除使用者 SQL 敘述:DROP USER &#x27;userName&#x27;@&#x27;hostName&#x27;; 備註:需注意, userName 加上 hostName 視為一個完整 user 對象, 若有多個 host, 需下多次指令刪除 賦予權限GRANT SELECT, INSERT, UPDATE, DELETE ON databaseName.tableNameTO &#x27;userName&#x27;@&#x27;hostName&#x27;; 權限表 權限 說明 ALL [PRIVILEGES] 一次賦予所有基本權限。不需附加 GRANT 的各種選項。 ALTER (變換) 允許使用 ALTER TABLE 敘述, 但授權時亦須同時賦予 CREATE 和 INSERT 等權限。 如需替資料表更名時, 還要搭配 DROP 權限。 此權限有一定的風險: 某人可能透過更名資料表來倒取使用權 ALTER ROUTINE 允許使用者帳號變換或棄置 (DROP) 預儲常式 (STORED ROUTINES)。 這其中包括了 ALTER FUNCTION 和 ALTER PROCEDURES 兩道敘述。 CREATE 允許執行 CREATE TABLE 敘述。 注意還需要有 INDEX 權限才能定義索引。 CREATE TEMPORARY TABLES 允許使用 CREATE TEMPORARY TABLES 敘述 CREATE USER 允許使用者帳號執行數種與管理使用帳號相關之敘述： 如 CREATE USER 、 RENAME USER 、 REVOKE ALL PRIVILEGES 、 以及 DROP USER 等敘述。 CREATE VIEW 允許執行 CREATE VIEW 敘述 DELETE 允許執行 DELETE 敘述 DROP 允許使用者執行 DROP TABLE 和 TRUNCATE 兩道敘述 EVENT 允許使用者帳號為事件排程工具定義事件。 包括 CREATE EVENT, ALTER EVENT 和 DROP EVENT 等敘述 EXECUTE 允許以 EXECUTE 敘述執行預報程序 (STORED PROCEDURES) FILE 允許使用 SELECT … INTO FILE 和 LOAD DATA INFILE 等敘述以便將資料會出成檔案, 或是從檔案匯入。 此權限也暗藏安全風險。 應該限定僅可在 SECURE_FILE_PRIV 變數中指定的特定目錄下執行 INDEX 授權使用 CREATE INDEX 和 DROP INDEX 等敘述 INSERT 允許執行 INSERT 敘述。 要先擁有此一權限才能執行 ANALYZE TABLE, OPTIMIZE TABLE 和 REPAIR TABLE 等敘述 LOCK TABLES 允許使用者對已有 SELECT 權限的資料表執行 LOCK TABLES 權限 PROCESS 允許使用 SHOW PROCESSLIST 和 SHOW ENGINE 等敘述 RELOAD 允許下達 FLUSH 敘述 REPLICATION CLIENT 允許使用者查詢主副伺服器 (MASTER AND SLAVE) 的狀態資訊, 如 SHOW MASTER STATUS 和 SHOW SLAVE STATUS 以及 SHOW BINARY LOGS 等敘述 REPLICATION SLAVE 這是複寫副伺服器 (REPLICATION SLAVE SERVER) 所必需的權限, 目的是要從主伺服器讀取二進位事件紀錄 (BINARY LOG EVENTS) SELECT 允許執行 SELECT 敘述 SHOW DATABASES 允許對所有資料庫使用 SHOW DATABASES 敘述, 而且不限於使用者有權使用的資料庫 SHOW VIEW 允許使用 SHOW CREATE VIEW 敘述 SHUTDOWN 允許 MYSQLADMIN 工具程式搭配 SHUTDOWN 選項執行 SUPER 授權執行 CHANGE MASTER TO, KILL, PURGE BINARY LOGS 及 SET GLOBAL 等敘述, 並且允許 MYSQLADMIN 工具程式搭配 DEBUG 選項執行 TRIGGER 此權限授權使用者帳號得以建立或棄置觸發器 (TRIGGERS), 亦即可以使用 CREATE TRIGGER 和 DROP TRIGGER 等敘述 UPDATE 允許執行 UPDATE 敘述 USAGE 新建使用者時引用此關鍵字, 可達到完全不賦予權限, 或是在修訂現有使用者資料時不會動到既有權限的效果 建立賦予權限的帳號GRANT specifiedPrivileges ON databaseName.tableNameTO &#x27;userName&#x27;@&#x27;hostName&#x27;IDENTIFIED BY &#x27;userPassword&#x27;WITH GRANT OPTION; 收回已賦予的權限REVOKE specifiedPrivilegesON databaseName.tableNameFROM &#x27;userName&#x27;@&#x27;hostName&#x27; 建立 RoleCREATE ROLE &#x27;roleName&#x27;; 然後可以賦予 role 權限 賦予使用者 Role 權限GRANT &#x27;roleName&#x27; TO &#x27;userName&#x27;@&#x27;hostName&#x27;; 切換 Role## 切換SET ROLE &#x27;roleName&#x27;;## 執行該 role 才擁有的權限LOAD DATA INFILE...## 執行完畢後, 登出 RoleSET ROLE NONE; # 資料備份備份所有資料庫mysqldump --user=specifiedUserAndHostName \\ --password --lock-all-tables --all-databases &gt; /preferredLocationAndFileName.sql 備份指定資料庫mysqldump --user=specifiedUserAndHostName --password --lock-tables \\--verbose --databases specifiedDatabaseName1 specifiedDatabaseName2 specifiedDatabaseNameN &gt; specifiedBackupFileName.sql 備份參數參考使用以下選項, 可以縮小 dump 檔–skip-add-drop-table: 忽略 會清除舊資料表的 DROP TABLE 敘述–skip-add-locks: 開始備份時不先鎖定資料表–skip-comments: 檔案裡不加註解–skip-disable-keys: 略過 會處理資料表索引的指令–skip-set-charset: 略過 指定使用字元集的 SET NAMES 敘述–compact: 使用上述所有選項 –user: 要求 mysqlsump 使用 admin_backup 這個帳號與 MySQL Server 互動–password: 指定使用帳號的密碼–lock-all-tables: 在開始備份前, 把所有資料庫中的所有資料表鎖定–lock-tables: 在開始備份前, 先把該資料庫中所有資料表鎖定–all-databases: 指定匯出所有資料庫–extended-insert: 會把每個資料表所需的多筆 INSERT 敘述濃縮成一句, 可縮小備份檔以及增進回原效率–skip-extended-insert: 若 server 預設有 --extended-insert 效果, 但想看到一筆筆的 INSERT 敘述, 可以使用此選項–ignore-table: 略過指定 table, 通常會略過 mysql.user table, 該 table 會用特殊帳號備份–no-create-info: 不包含 create 敘述–no-data: 只備份架構, 不備份資料–verbose: 在備份過程中, 把重大步驟產生的訊息顯示出來–replace: 使用 replace 代替 insert # 資料還原# dump file 還原從 dump file 還原mysql --user=performingOperationUser --password &lt; dumpFileName.sql 復原部分資料 修改 dump file, 只留下開頭, 結尾變數, 以及需要的 table 段落 修改 dump file 中的 create database, use database, 改成一個臨時的 database name, 匯出後在從該臨時 database 中取出資料, 完成後再刪掉該 temporary database 或是賦予一個臨時使用者該 table 的權限, 讓這個使用者去執行 restore # 從 Binary Log 還原如果很不幸的, 你想要還原備份後才新增的資料 確認 Binary Log 是否有啟用SHOW BINARY LOGS# 如果未啟用, 錯誤如下：# ERROR 1381 (HY000): You are not using binary logging 啟用 binary log在 mysql.ini / mysql.cnf 檔案中: # log-bin 表示啟動 binary loglog-bin# 表示不 log mysql 這個 table, 以提高安全性binlog-ignore-db=mysql 顯示當前 log 點SHOW MASTER STATUS; Binlog_Do_DB: 指定哪些資料庫才要記錄到 binary logBinlog_Ignore_DB: 指定哪些資料庫不要記錄到 binary logExecuted_Gtid_Set: 已經執行的 transaction 編號 取得 DATA 存在位置SHOW VARIABLES WHERE Variable_Name LIKE &#x27;datadir&#x27;; 確定 log 檔案確實在該目錄底下後, 輸出文字檔mysqlbinlog --database=databaseName \\ /binaryLogAbsoluteLocation &gt; whateverNameYouLike.txt 找出問題點手動找出問題點, 如下 example # at 1258707#140916 13:10:24 server id 1 end_log_pos 1258778 Query thread_id=382 exec_time=0 error_code=0SET TIMESTAMP=1410887424/*!*/;SET @@session.sql_mode=0/*!*/;BEGIN/*!*/;# at 1258778#140916 13:10:24 server id 1 end_log_pos 1258900 Query thread_id=382 exec_time=0 error_code=0use `rookery`/*!*/;SET TIMESTAMP=1410887424/*!*/;DELETE FROM birds_simple WHERE common_name LIKE &#x27;%Blue%&#x27;/*!*/;# at 1258900#140916 13:10:24 server id 1 end_log_pos 1258927 Xid = 45248COMMIT/*!*/;...# at 1284668#140916 13:10:28 server id 1 end_log_pos 1284739 Query thread_id=382 exec_time=0 error_code=0SET TIMESTAMP=1410887428/*!*/;SET @@session.sql_mode=0/*!*/;BEGIN/*!*/;# at 1284739#140916 13:10:28 server id 1 end_log_pos 1284862 Query thread_id=382 exec_time=0 error_code=0SET TIMESTAMP=1410887428/*!*/;DELETE FROM birds_simple WHERE common_name LIKE &#x27;%Green%&#x27;/*!*/;# at 1284862#140916 13:10:28 server id 1 end_log_pos 1284889 Xid = 45553COMMIT/*!*/; 復原備份到問題點前可看到從 position point 1258707 開始了含有 DELETE 的 transaction, 現在我們要將資料復原, 並拿掉這個含有 DELETE 的 transaction先復原到 position 1258707: mysqlbinlog --database=databaseName--stop-position=&quot;1258707&quot; \\ binaryLogAbsoluteLocation | mysql --user=userName --password 從問題點後開始復原到最新的 log point可看到有問題的 transaction 的結尾落在 1284862, 並且有指出下一個起始點為 1284889, 因此可從 position 1284889 開始往後復原 mysqlbinlog --database=rookery --start-position=&quot;1284889&quot; --to-last-log \\ binaryLogAbsoluteLocation | mysql --user=userName --password 至此就大功告成啦！ # 中文亂碼問題# 先確認 locale 狀態： 確認 charset 狀態, 在 mysql 當中: ```bashshow variables like ‘char%’; 2. 確認 `database` locale 狀態：```bashSELECT default_character_set_name FROM information_schema.SCHEMATA WHERE schema_name = &quot;databaseName&quot;; 確認 table locale 狀態： SELECT CCSA.character_set_name FROM information_schema.`TABLES` T, information_schema.`COLLATION_CHARACTER_SET_APPLICABILITY` CCSAWHERE CCSA.collation_name = T.table_collation AND T.table_schema = &quot;databaseName&quot; AND T.table_name = &quot;tableName&quot;; 確認 column locale 狀態： show full columns from tableName; 確認 collation show variables like &#x27;collation%&#x27;; # locale 修改# 確認 mysql 設定檔位置並修改 取得 ‘my.cnf’ 位置, 通常，檔案會在 /etc/mysql/my.cnf mysql --help -verbose | grep &#x27;my.cnf&#x27; 編輯檔案 vim /etc/mysql/my.cnf 貼上以下設定 [client]default-character-set=utf8mb4[mysql]default-character-set=utf8mb4[mysqld]collation-server = utf8_unicode_ciinit-connect=&#x27;SET NAMES utf8&#x27;character-set-server = utf8mb4 # 修改 database localeALTER DATABASE database_name CHARACTER SET utf8 COLLATE utf8_general_ci; # 修改 table localeALTER TABLE table_name CONVERT TO CHARACTER SET utf8; # 完成修改後, 重啟 mysqlservice mysql restart # 別忘了 PHP locale如果有用使用 PHP 的話，記得也將 PHP 那邊的 locale 設為 uft8, 可參考文章 mysqli_set_charset($dbc,&quot;utf8&quot;); # 還是亂碼？理論上，上面的都做完了，應該就不會有亂碼了，如果問題尚未解決，可以試試下面的方法 查看資料庫 locale 設定 show create database databaseName 查看 table locale 設定 show create table tableName 其餘設定 set names uft8; # 匯入大量資料# 修改 my.cnf 或 my.ini 檔 (永久性的放寬)[mysqld]max_allowed_packet=100M # 暫時性的放寬set global net_buffer_length=1000000; set global max_allowed_packet=1000000000; # 匯入# 從 sql 檔匯入mysql --max_allowed_packet=100M -u root -p database &lt; dump.sql 如果已有設定, --max_allowed_packet 可不加 # 從 csv 匯入# 一般 csv 格式LOAD DATA INFILE &#x27;/tmp/Clements-Checklist-6.9-final.csv&#x27;INTO TABLE rookery.clements_list_importFIELDS TERMINATED BY &#x27;,&#x27; OPTIONALLY ENCLOSED BY &#x27;&quot;&#x27;IGNORE 1 LINES;(id, change_type, @niente, @niente,scientific_name, english_name,@niente, bird_order, @family, @niente,@niente, @niente, @niente, @niente,@niente, @niente, @niente, @niente);SET family = SUBSTRING(@family, 1, LOCATE(&#x27; (&#x27;, @family) ); 從 csv 檔讀取資料並匯入 database.tableFIELD TERMINATED BY: field 跟 field 之間由 , 區隔開來OPTIONALLY: 有則處理, 沒有則不執行ENCLOSED BY: 使用 ENCLOSED BY &#39;&quot;&#39;, 當 &quot; (doube quote) 有出現時, 會將兩個 &quot; (double quote) 之間的內容視為一個 column 的內容, 若沒出現則不使用, 為了應付某些 filed 的內容其實是 text, 會用 &quot; (double quote) 包住, 但內容有許多 ,(comma)IGNORE 1 LINES: 表示忽略第一行, 因為第一行是 field name, 我們並不會用到@niente: 因為 csv 檔中某些欄位的資料我們並不需要, 因此在建立 table 時只需要建立我們需要的 column, 在匯入時, 將沒用到的 fieldd 按照 csv 上的順序標示為 @niente (只要是變數就行, 名稱不重要), 這樣就不會將資料匯入啦@family, SET family: 可以在 LOAD DATA 的過程中, 針對 csv 上特定的 column 做處理, 匯入完成後就已經會是處理好的 # 較特別的 csv 格式格式範例: [&quot;prospect name&quot;|&quot;prospect email&quot;|&quot;prospect country&quot;][&quot;Mr. Bogdan Kecman&quot;|&quot;bodgan\\@kecman-birds.com&quot;|&quot;Serbia&quot;][&quot;Ms. Sveta Smirnova&quot;|&quot;bettasveta\\@gmail.com&quot;|&quot;Russia&quot;][&quot;Mr. Collin Charles&quot;|&quot;callincollin\\@gmail.com&quot;|&quot;Malaysia&quot;][&quot;Ms. Sveta A. Smirnova&quot;|&quot;bettasveta\\@gmail.com&quot;|&quot;Russia&quot;] sql example: LOAD DATA INFILE &#x27;/tmp/birdwatcher-prospects.csv&#x27;INTO TABLE birdwatchers.birdwatcher_prospects_importFIELDS TERMINATED BY &#x27;|&#x27; ENCLOSED BY &#x27;&quot;&#x27; ESCAPED BY &#x27;\\\\&#x27;LINES STARTING BY &#x27;[&#x27; TERMINATED BY &#x27;]\\r\\n&#x27;IGNORE 1 LINES(prospect_name, prospect_email, prospect_country); 以下為 FIELDS 子句意思：TERMINATED BY: 表示 | 為 field 跟 field 之間的間隔ENCLOSED BY: 表示每一個 field 的內容都會由 &quot; 包住ESCAPE BY: 標示跳脫用字元, 不過預設就是 \\, 因此這個可省略 LINES 子句：STRINGS BY: 表示 [ 開頭算一行的開始TERMINATED BY: 表示 ]\\r\\n 為一行的結束, 正常 Linux 只需 \\n 即可, 但考量到 Windows 環境, 因此多加了 \\r 使用 mysqlimportmysqlimport –user=&#x27;marie_dyer&#x27; --password=&#x27;sevenangels&#x27; \\ --replace --low-priority --ignore-lines=&#x27;1&#x27; \\ --fields-enclosed-by=&#x27;&quot;&#x27; --fields-terminated-by=&#x27;|&#x27; --fields-escaped-by=&#x27;\\\\&#x27; \\ --lines-terminated-by=&#x27;]\\r\\n&#x27; \\ --columns=&#x27;prospect_name, prospect_email, prospect_country&#x27; \\ birdwatchers &#x27;/tmp/birdwatcher_prospects_import.csv&#x27; 基本上語法跟 LOAD DATA 是一樣的, 差別在於檔名若有 - 要改成 _, 以免 MySQL 判定為刪減符號 以下為 FIELDS 子句意思：TERMINATED BY: 表示 | 為 field 跟 field 之間的間隔ENCLOSED BY: 表示每一個 field 的內容都會由 &quot; 包住ESCAPE BY: 標示跳脫用字元, 不過預設就是 \\, 因此這個可省略 LINES 子句：STRINGS BY: 表示 [ 開頭算一行的開始TERMINATED BY: 表示 ]\\r\\n 為一行的結束, 正常 Linux 只需 \\n 即可, 但考量到 Windows 環境, 因此多加了 \\r # 大量匯出( SELECT &#x27;scientific name&#x27;,&#x27;common name&#x27;,&#x27;family name&#x27; )UNION( SELECT birds.scientific_name, IFNULL(common_name, &#x27;&#x27;), bird_families.scientific_name FROM rookery.birds JOIN rookery.bird_families USING(family_id) JOIN rookery.bird_orders USING(order_id) WHERE bird_orders.scientific_name = &#x27;Charadriiformes&#x27; ORDER BY common_name INTO OUTFILE &#x27;/tmp/birds-list.csv&#x27; FIELDS ENCLOSED BY &#x27;&quot;&#x27; TERMINATED BY &#x27;|&#x27; ESCAPED BY &#x27;\\\\&#x27; LINES TERMINATED BY &#x27;\\n&#x27;); 使用 SELECT INTO OUTFILE 將資料匯出, 子句部分語法跟 LOAD DATA 完全一樣需使用 IFNULL 將 null 轉為空字串, 因為 INTO OUTFILE 預設會將 null 轉為 n 以下為 FIELDS 子句意思：TERMINATED BY: 表示 | 為 field 跟 field 之間的間隔ENCLOSED BY: 表示每一個 field 的內容都會由 &quot; 包住ESCAPE BY: 標示跳脫用字元, 不過預設就是 \\, 因此這個可省略 LINES 子句：STRINGS BY: 表示 [ 開頭算一行的開始TERMINATED BY: 表示 ]\\r\\n 為一行的結束, 正常 Linux 只需 \\n 即可, 但考量到 Windows 環境, 因此多加了 \\r 匯出範例： &quot;scientific name&quot;|&quot;common name&quot;|&quot;family name&quot;&quot;Charadrius vociferus&quot;|&quot;Killdeer&quot;|&quot;Charadriidae&quot;&quot;Charadrius montanus&quot;|&quot;Mountain Plover&quot;|&quot;Charadriidae&quot;&quot;Charadrius alexandrinus&quot;|&quot;Snowy Plover&quot;|&quot;Charadriidae&quot;&quot;Pluvialis squatarola&quot;|&quot;Black-bellied Plover&quot;|&quot;Charadriidae&quot;&quot;Pluvialis fulva&quot;|&quot;Pacific Golden Plover&quot;|&quot;Charadriidae&quot;&quot;Burhinus vermiculatus&quot;|&quot;Water Thick-knee&quot;|&quot;Burhinidae&quot;&quot;Burhinus oedicnemus&quot;|&quot;Eurasian Thick-knee&quot;|&quot;Burhinidae&quot;... # 查單一資料庫 sizeSELECT table_schema &quot;databaseName&quot;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 1) &quot;DB Size in MB&quot; FROM information_schema.tables where table_schema=&quot;databaseName&quot; GROUP BY table_schema; # where 子句操作符 # EXTRACT 支援的時間格式 # DATE_FORMAT, TIME_FORMAT 時間格式碼 # Index# 加入 Foreign KeyALTER TABLE tableNameADD FOREIGN KEY (columnName) REFERENCES referencingTableName (columnName) # 移除 Foreign Key# 取得 constraintSELECT * FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTSWHERE TABLE_NAME=&#x27;tableName&#x27;; # 移除 constraintALTER TABLE table_name DROP CONSTRAINT constraint_name # 移除 indexALTER TABLE table_name DROP INDEX index_name # 取得 metadata取得 table rows 大約估計值SELECT table_rows FROM information_schema.tables WHERE table_name = &#x27;tableName&#x27; # Questions and Answers以下的 MySQL example code, t2 上最後一筆資料的 id 是多少？ Example:insert into t values(null, 1,1);insert into t values(null, 2,2);insert into t values(null, 3,3);insert into t values(null, 4,4);create table t2 like t;insert into t2(c,d) select c,d from t;insert into t2 values(null, 5,5); Answer:8, 因為 id 的申請是倍數增加的第一次, 申請到 1 個 id第二次, 申請到 2 個 id第三次, 申請到 4 個 id, 至此, 已有 7 個 id, 但只需 insert 4 筆資料, 所以 5~7 沒用到MySQL 不會去回滾已取得的 increment id, 所以最後一筆申請到的 id 會是 8 MySQL 中, 對於批量插入數據的語句, 像是 insert ... select, 申請 increment id 的規則是？首次, 1 個 id第二次, 2 個 id第三次, 4 個 id第四次, 8 個 id以此類推, 因為在不知道有幾筆的情況下, 一筆筆申請的效率太低了, 如果需要 insert 一百萬筆的話 MySQL 中, 為了避免 insert...select 這樣的語句造成主從的 increment id 不一致, 以及不影響高併發的效能, 建議 innodb_autoinc_lock_mode 以及 binlog 的格式做怎樣的設置？innodb_autoinc_lock_mode 設為 2, 即立即釋放, 不影響高併發效能binlog 設為 row, 解決主從不一致的問題 以下的 MySQL example image 中, 若 session B 的 insert...select 沒有 lock, 那可以取得連續 id 嗎？ Example: Answer:不可 MySQL 中, 參數 ‘innodb_autoinc_lock_mode’ 為什麼在 5.7 的版本中, 預設值是 1, insert ... select 這種不確定要申請多少 id 的語句會在語句執行完畢後才釋放 increment id lock?若是不上鎖, 在 binlog 格式為 row 時不會有問題, 因為 row binlog 是實際去記錄每一個 row 的實際紀錄使用 statement binlog 時, 如果不上鎖的話, 在併發時並無法保證 insert ... select 語句在 insert 時可以取得連續的 id, 但 statement binlog 執行時是沒有併發的問題, 因此可以取得連續 id, 這就造成主從不一致 MySQL 中, 參數 ‘innodb_autoinc_lock_mode’ 在 MySQL 8 的預設值是多少？2 MySQL 中, 參數 ‘innodb_autoinc_lock_mode’ 根據設置的值不同, 會有哪三種行為？(0) 所有的語句在申請 increment id 時都上鎖, 語句執行完畢才釋放(1) 一般語句取得 id 後立即釋放, insert ... select 這種不確定要申請幾個 id 的語句, 要等到語句全部執行完畢才釋放(2) 所有語句都在申請取得後立即釋放 MySQL 中, 為什麼不支援自增 id 回退？會影響效能假設 transaction a 取得 id 2, transaction b 取得 id 3, a 提供失敗, b 提交成功, 如果支援回退的話, 這時 InnoDB 的當前自增 id 會修正為 2, 結果出現資料庫內有 id = 3 的資料, 而當前自增 id = 2, 之後的 transaction 如果申請到 id = 3, 就會發生衝突為解決這個問題, 方法有 2(1) id 沒出現在資料庫才給申請, 這相當於每一次都要表搜索, 效能不佳(2) 自增鎖粒度加大, 一個事物完成並提交才給申請下一個 id, 這會影響併發能力 以下的 MySQL example code 中, 最後插入的 id 是多少？ Example:insert into t values(null,1,1);begin;insert into t values(null,2,2);rollback;insert into t values(null,2,2); Answer:3 以下的 MySQL example code 中, 為什麼 id 是 3, 不是 2？ Example: Answer:InnoDB 發現用戶沒有指定自增 id 的值, 獲取當前的值並導入 insert query將當前的值改成 3 以下的 MySQL example code 的意思是？ Example:create temporary table temp_t(id int primary key, a int, b int, index (b))engine=memory;insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;select * from t1 join temp_t on (t1.b=temp_t.b); Answer:使用 temp table 優化 join 時, 用 memory engine table 來代替 InnoDB engine table, 速度會更快 以下的 MySQL example code, 使用 memory engien 改寫是否會更好？ Example:create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;select * from t1 join temp_t on (t1.b=temp_t.b); Answer:會, 因為 memory engine table 使用 hash index, 等值查詢更快2000 筆紀錄不大, 可全部放在內存memory engine table 不需寫 disk, 速度更快 MySQL 中, 對比 memory table 以及 InnoDB table, 為什麼說 InnoDB 更適合被使用？ 若資料量大, InnoDB 併發效果較好 若資料量小, InnoDB 的資料也是會緩存在 buffer pool 中的 MySQL 中, 為什麼說正式環境不適合使用 memory engine table? memory engine table 不支援行鎖, 併發效果不好 因為斷開或重啟後會清空資料, 會造成主從同步停止, 甚至清空主庫 memory table MySQL 的 memory table 支援行鎖嗎？不支援, 只支援表鎖 以下的 MySQL example code 的意思是？ Example: Answer:加入 btree 到 memory, 不同 index 造成排列順序的不同 MySQL 中, 如何使 memory table 支援範圍搜尋嗎？加上 btree index 以下的 MySQL example code 的意思是？ Example:alter table t1 add index a_btree_index using btree (id); Answer:在 memory table 加入 btree index, 使其支援範圍查找 以下的 MySQL example code 中, output 是？ 為什麼？ Example:CREATE TABLE t1 ( id int PRIMARY KEY, c int) engine = Memory;INSERT INTO t1 values(2, 2), (4, 4), (3, 3), (1, 1), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (0, 0);SELECT *FROM t1;delete from t1 where id=5;insert into t1 values(10,10);select * from t1; Answer:id=10 會替換原先 id=5 的位置 MySQL 中, Memory table 中, 每行數據的長度相同嗎？是的 MySQL 中, Memory table 支援 text or blob column 嗎？不支援 MySQL 中, 當數據位置方生變化時, Memory table 需要修改所有索引, 為什麼？因為 Memory table 屬於 Heap Organised Table, 每種索引的地位都相等, 皆紀錄資料存放的位置, 所以資料的 hash 變了, 所有的索引也需跟著改變 MySQL 中, 當數據位置方生變化時, InnoDB table 只需要修改主鍵索引, 為什麼？因為 InnoDB 屬於 Index Organised Table, 主鍵與資料存在一起, 而其他二級索引只存主鍵 id MySQL 中, Memory 表在插入新數據的時候, 只要有找到空洞就可以插入, 為什麼？因為 Memory table 是 Heap Organised Table, 是無序性的 MySQL 中, InnoDB 表在插入新數據的時候, 只能在特定的位置插入, 為什麼？因為 InnoDB 是 Index Organised Table, 需要有序性的插入 MySQL 中, 何謂堆組織表 (Heap Organised Table)？索引上保存數據位置 MySQL 中, 何謂索引組織表 (Index Organised Table)？數據存在主鍵索引上, 其他索引存主鍵 id 以下的 MySQL example code 中, output 的排序是？ 為什麼？ Example:CREATE TABLE t2 ( id int PRIMARY KEY, c int) engine = innodb;INSERT INTO t2 values(3, 3), (2, 2), (1, 1), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (0, 0);SELECT *FROM t2; Answer:按照 id (primary key) 順序排列, MySQL innoDB engine 所有數據都在 primary key 索引上, 而 primary key 是有序儲存的 以下的 MySQL example code 中, output 的排序是？ 為什麼？ Example:CREATE TABLE t1 ( id int PRIMARY KEY, c int) engine = Memory;INSERT INTO t1 values(2, 2), (4, 4), (3, 3), (1, 1), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (0, 0);SELECT *FROM t1; Answer:按照 insert 順序排序, 因為 memory table 是按照輸入的順序排列的 以下的 MySQL example image, 為什麼沒使用 using temporary？ Example: Answer:因為使用 SQL_BIG_RESULT, 優化器不會使用臨時表, 會使用排序演算法在 disk 文件中針對 id%100 的結果做排序, 像是 0000111122223333 MySQL 中, 為什麼不能用 rename 修改臨時表的名稱？執行 rename 時, 會依照 庫名/表名.frm 的規則去 disk 找文件, 但臨時表在 disk 上的 frm 文件是放在 tmpdir 目錄下的, 且文件名的規則是 #sqlProcessId_treadId_序號.frm , 因此會出現找不到文件名的錯誤 MySQL 什麼時候會使用內部臨時表？(1) 如果語句執行過程可以一邊讀數據, 一邊直接得到結果, 那是不需要額外內存的, 反之, 就會需要額外的內存來保存中間結果(2) join_buffer 是無序數組, sort_buffer 是有序數組, 臨時表是二維表結構(3) 如果執行邏輯需要用到二維表結構, 就會優先考慮使用臨時表, 像是 union 需要用到 unique index constraint, group by 需要用到另一個 column 來 count 以下的 MySQL example code, 確切流程是？ Example:select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m; Answer:(1) 初始化 sort_buffer, 確定放入一個 int, 記為 m(2) 掃描 t1 的 index a, 依序取出裡面的 id 值, 將 id%100 的值存入 sort_buffer 中, 使用 index a 而不是 index id 的原因是因為, id 屬於 clustered index, 而 a 屬於 secondary index, a index 就只有 a,id, 所以找 a index 的 cost 較小(3) 掃描完成後, 對 sort_buffer 的 column m 排序, 如下圖(4) 如果 sort_buffer 內存不夠用, 會使用 disk 臨時文件輔助排序(5) 排序完成後, 得到一個有序數組, 自然可以經由排序知道不同的 m 值的分別數量總共有多少, 如上圖, 掃描到 1 時, 就知道總共有 x 個 0, 掃描到 2 時, 就知道總共有 y 個 1(6) 整體流程如下(7) explain 的結果如下 以下的 MySQL example code 的意思是？ Example:select SQL_BIG_RESULT id%100 as m, count(*) as c from t1 group by m; Answer:當已知該 query 會使用到內存臨時表, 且結果可能非常大, 內存臨時表的 size 不足以容納時, 可直接使用 SQL_BIG_RESULT 來指定使用 disk 臨時表若不指定, 則 MySQL 會先使用內存臨時表, 當判斷 size 不足以容納時, 才轉成 disk 臨時表, 這樣 cost 反而較高 以下的 MySQL example image 中, 若要優化拿掉 using temporary 以及 using filesort, 可以怎麼做？ Image: Answer:using temporary, 因為 id%10 本身並沒有排序, 可針對這個條件建立一個 virtual column 並加上 index, 這樣就不需要使用 temporaryusing filesort, mysql 8 之後的版本預設不會自動排序, 之前的版本若要取消排序可使用 order by null 以下的 MySQL example code 中, 該如何優化 group by? Example:create table t1(id int primary key, a int, b int, index(a));delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=1000)do insert into t1 values(i, i, i); set i=i+1; end while;end;;delimiter ;call idata();select id%10 as m, count(*) as c from t1 group by m order by null; Answer:針對 group by 的 column 加入加入欄位以及索引, 若該欄位無特殊邏輯, 可單純針對欄位本身增加 index 即可alter table t1 add column z int generated always as(id % 100), add index(z);select z, count(*) as c from t1 group by z; MySQL 當使用 group by 時, 8 以前的版本會自動根據 group by 的欄位排序, 若不需要排序可以怎麼做？加上 order by null 以下的 MySQL example image 的意思是？ Image: Example: select id%10 as m, count(*) as c from t1 group by m; Answer:(1) 創建臨時表, 有兩個 column, m &amp; c, m 為 primary key(2) 掃描 t1 的 index a, 一次取得 id 並計算 id%10 的結果, 記為 x(3) 若臨時表沒有 m = x 的 row, 則插入 new row(4) 若臨時表已有 m = x 的 row, 則 c++(5) 遍歷完成, 根據 column m 排序, 返回結果實測 MySQL 8 不會自動 order by m 以下的 MySQL example image 的意思是？ Example: Answer:(1) 子查詢取得 1000, 並插入臨時表(2) 子查詢取得 1000, 插入臨時表失敗, 因為已經存在(3) 子查詢取得 999, 插入臨時表成功返回結果 以下的 MySQL example code 中, 該選擇哪一個表為驅動表？ Exampleselect * from t1 join t2 on(t1.a=t2.a) join t3 on (t2.b=t3.b) where t1.c&gt;=X and t2.c&gt;=Y and t3.c&gt;=Z; Answer先經由 where t1.c&gt;=X and t2.c&gt;=Y and t3.c&gt;=Z 過濾條件選出資料最少的當作驅動表若為 t1, 則 t1-&gt;t2-&gt;t3, 並在 join key 上加 index若為 t3, 則 t3-&gt;t2-&gt;t1, 並在 join key 上加 index若為 t2, 則需評估 t2 join t1 或 t2 join t3, 哪個資料少最後給 c 加上 index 以下的 MySQL example image 中, S 為 M 的備庫, 為什麼在 S 上, 同個線程可以建立同名的臨時表？ Example: Answer:MySQL 在紀錄 binlog 時, 會把主庫執行這個語句的 thread_id 寫到 binlog 中, 這樣, 在備庫的 thread 就能夠知道每個語句的主庫 thead_id, 且利用這個 thread_id 來構造臨時表的 table_def_key (1) session A 的臨時表 t1，在備庫的 table_def_key 就是：庫名 + t1 + “M 的 serverid” + “session A 的 thread_id”(2) session B 的臨時表 t1，在備庫的 table_def_key 就是：庫名 + t1 + “M 的 serverid” + “session B 的 thread_id” MySQL 在紀錄 binlog 時, 不論是 create table 或是 alter table 語句, 都是原樣紀錄, 甚至連空格都不變, 但如果執行 drop table 時, 系統紀錄 binlog 會變成如下 example, 為什麼？ Example: DROP TABLE `t_normal` /* generated by server */ Answer:因為如果在主庫上有建立臨時表, 而 binlog 格式為 row 的話, 會略過臨時表語句, 如果不這麼做, 那在備庫上因為並不存在該臨時表, 就會出錯造成同步停止 MySQL 中, 當 binlog 格式為 row 時, 既然 binlog 不紀錄臨時表語句, 那備庫如何刪除？主庫會將 drop table temp_table 的語句給備庫執行 MySQL 中, 當 binlog 格式為 row 時, 既然 binlog 不紀錄臨時表語句, 那備庫如何建立臨時表？主庫會將創建臨時表的語句給備庫執行 MySQL 中, 當 binlog 格式為 mixed/statement 時, 會將臨時表語句記錄下來嗎？會 MySQL 中, 當 binlog 格式為 row 時, 會將臨時表語句記錄下來嗎？不會 MySQL 中, 同個 session 可以建立重複名稱的 temp table 嗎？不可 以下的 MySQL example image 的意思是？ Example: Answer:在不同 session 可建立同名的臨時表而不會衝突, 不同的 session 維護自己的臨時表空間 MySQL 中, 臨時表文件的前綴是？#sql&#123;process_id&#125;_&#123;thread_id&#125;_序列號 MySQL 中, 臨時表文件的後綴是？frm 以下的 MySQL example code 的意思是？ Example:select @@tmpdir Answer:顯示當前 session 的臨時文件目錄 以下的 MySQL example image 的意思是？ Example: Answer:(1) 建立 temp table(2) 從分表取得資料(3) 將資料 insert 到 temp table(4) 從 temp table 做最後操作 以下的 MySQL example image 的意思是？ Example: Answer:將資料分成 1024 個分表 MySQL 中, 當我使用臨時表, 若連線異常斷開, 或資料庫重啟, 臨時表內的資料會自動釋放嗎？會 MySQL 中, 臨時表會在一個 session 結束時自動回收嗎？會 MySQL 中, 臨時表可以與普通表重名嗎？可以 MySQL 中, 當 temp table 與一般 table 的命名相同, crud 時會取得哪一個？temp table MySQL 中, session A 建立的 temp table 可以跟 session B 建立的 temp table 重複命名嗎？可以 MySQL 中, session A 建立的 temp table 可以被 session B 存取嗎？不可 MySQL 中, hash join 的概念是?當 MySQL 採用 BNJ 算法時, 被驅動表中的每一行都會去跟 block 中的每一行做判斷, 假設驅動表為 1000 行, 被驅動表有 1000000 行, 那總判斷次數就是十億次hash join 的概念, 就是將 join_buffer 中維護的無序數組轉為 hash table, 所以被驅動表就不需要跟 block 中的每一行做比較, 總判斷次數降為 100 萬次 MySQL 8 支援 hash join 嗎？支援 以下的 MySQL example image 的意思是？ Example: Answer:前兩張圖是 BNJ 算法, 須判斷 10 億次, 耗時 1 分多鐘第三張圖, 利用建立臨時表的方式, 觸發 BKA 算法, 1 秒內完成 以下的 MySQL example code 的意思是？ Example:create temporary table temp_t(id int primary key, a int, b int, index(b))engine=innodb;insert into temp_t select * from t2 where b&gt;=1 and b&lt;=2000;select * from t1 join temp_t on (t1.b=temp_t.b); Answer:利用建立臨時表來觸發 BKA 算法 MySQL 中, BNJ 算法對系統影響主要有哪三個方面？(1) 可能多次掃瞄被驅動表, 佔用 disk I/O 資源(2) 判斷 join 條件需要執行 N*M 次判斷, 如果是大表就會佔用非常大量的 CPU 資源(3) 可能導致 Buffer Pool 熱數據被淘汰, 影響內存命中率 MySQL 中, 如果一個使用 BNJ 算法的 join query, 多次掃描一個冷表, 且這個 query 的執行時間大於 1 秒, 且冷表的數據大於整個 buffer pool 的 3/8, 那會發生什麼事？會不停的洗掉 old 區, 造成正常訪問的熱表一進到 old 區就被洗掉而沒有機會進入 young 區, 降低原本該有的 buffer pool hit rate MySQL 中, 如果一個使用 BNJ 算法的 join query, 多次掃描一個冷表, 且這個 query 的執行時間大於 1 秒, 且冷表的數據小於整個 buffer pool 的 3/8, 那會發生什麼事？會將冷表的數據移動到 young 區, 降低原本該有的 buffer pool hit rate 以下的 MySQL example code 的意思是？ Example:set optimizer_switch=&#x27;mrr=on,mrr_cost_based=off,batched_key_access=on&#x27;; Answer:開啟 MRR, 開啟 BKA, 穩定使用 BKA 以下的 MySQL example image 中, 如果 join_buffer 滿了會怎麼樣？ Example: Answer:滿了會繼續步驟 2-3, 完成後清空 buffer 並繼續 1-3 基本步驟(1) 先將 t1 需要查詢的 row 放到 join_buffer(2) 取出索引 a 到 t2 取得對應的 row(3) 組成 row 並回傳結果 以下的 MySQL example image 的意思是？ Example: Answer:(1) 先將 t1 需要查詢的 row 放到 join_buffer(2) 取出索引 a 到 t2 取得對應的 row(3) 組成 row 並回傳結果 MySQL 中, BKA 算法的全寫是？Batched Key Access 以下的 MySQL example image 中, MRR 的意思是？ Example: Answer:先將 id 排序過, 再用排序過的 id 到 id index 去取出資料 以下的 MySQL example code 的意思是？ Example:set optimizer_switch=&quot;mrr_cost_based=off&quot; Answer:優化器會判斷消耗以決定是否使用 MRR, 若設定成 off, 則會穩定使用 MRR 優化 以下的 MySQL example image 中, 萬一 read_rnd_buffer 滿了, 會怎麼樣？ Example: Answer:若滿了, 會跳到 2-3, 2-3 執行完畢後, 清空 buffer, 重複 2-3 基本步驟(1) 從索引 a 取得 id, 並存入 read_rnd_buffer(2) read_rnd_buffer 排序 id(3) 依照排序後的 id 順序, 到索引 id 取出資料 以下的 MySQL example image 的意思是？ Example: Answer:(1) 從索引 a 取得 id, 並存入 read_rnd_buffer(2) read_rnd_buffer 排序 id(3) 依照排序後的 id 順序, 到索引 id 取出資料 AWS RDS 預設參數無法更改, 要如何更改？因為預設的參數不給改, 所以要建立一個 parameter group 來自定義參數, 並套用到指定的 instance 上連結 MySQL 中, MRR 的簡單概念是？因為大部分的資料都是 auto id 順序寫入的, 所以將索引找到的 id 排序, 以達到順序讀取資料的優化 以下的 MySQL example image 的意思是？ Example: Answer:根據索引 a 查找 id, 因為 id 順序沒有排過, 會變成隨機讀, 效能較差 MySQl 中, net_buffer 是每個 thread 一個, 還是共享？每個 thread 一個 MySQL 中, 為什麼當大量出現 thread state 為 sending to client 時, 加大 net_buffer_length 是一個解決方法？ socket_send_buffer 比 net_buffer_length 還小, 不是嗎？因為只要 MySQL 將資料存到 net_buffer_length 之後, 儘管 socket_send_buffer 慢慢發, 但對於 MySQL 來說就是已經發出去了, 這樣就不會影響到語句的執行 MySQL 中, 如果一個 transaction 被 kill 之後持續處於 rollback 狀態, 應該讓他執行完畢, 或是重啟 mysql process?應讓它自行執行完畢, 因為 rollback 的邏輯是不可少的可以切到備庫, 減少原主庫的壓力, 讓其自動完成 以下的 MySQL example image 的意思是 Example: Answer:MySQL 優化過的 LRU 算法, 分為 young, old 兩區, 決定哪些資料該留在內存中, 哪些該淘汰young 區中的 page 被訪問時, 會移到 headold 區中的 page 被訪問時, 會根據其存在於 old 區中的時間決定再來的位置如果超過 1 秒, 則移到 young 區 head, 反之, 則停在 old 區所以當熱資料被頻繁 query 時, 都會待在 young 區, 而冷資料被 query 時, 只會待在 old 區, 不影響熱資料的 young 區, 從而保證了 buffer pool hit rate 以下的 MySQL example image 中, old 區的一個 page 被訪問, 該 page 會跑到什麼位置？ Example: Answer:如果該 page 已存在超過 1 秒, 會移到 young 區的 head如果該 page 存在不超過 1 秒, 仍待在 old 區 以下的 MySQL example image 中, young 區的一個 page 被訪問, 該 page 會跑到什麼位置？ Example: Answer:會跑到 head 的位置 以下的 MySQL example image 是 LRU 的基本模型, 可能會有什麼問題？ Example: Answer:當讀到一個歷史大表格時(不常使用), 會將當前內存中常用的資料都淘汰掉, 這樣會造成 buffer pool hit rate 急遽降低 MySQL 中, 內存管理算法 LRU, 全寫是？Least Recently Used, LRU MySQL 中, inno_buffer_pool_size 建議設為多少？物理內存的 60% ~ 80% MySQL 中, 哪個指令可以看內存命中率？show engine innodb status 以下的 MySQL example image 中, 為什麼處於 block 狀態, 卻是顯示 sending data？ Example: Answer:因為 MySQL 會在執行語句階段一開始就把狀態改成 sending data, 因此只要是還在執行階段, 都是顯示 sending data, 儘管鎖住了 MySQL state 中, sending to client 跟 sending data 的差異是？sending data 表示語句正在執行階段, 只要是在執行過程中, 儘管鎖住了也是顯示 sending datasending to client 表示正在等待 client 接收資料 MySQL 中, 如果很多 thread 常常處於 “sending to client” 這個狀態, 加大哪一個參數可能可以減少這個狀況？？net_buffer_length MySQL 中, 如果很多 thread 常常處於 “sending to client” 這個狀態, 那可能要優化哪一部分？查詢結果 MySQL 中, 一般正常的線上業務來說, 如果查詢的資料不是特別大, 通常都建議使用 mysql_use_result 還是 mysql_store_result?mysql_store_result 以下的 MySQL example image 中, 如果一直出現 sending to client, 有可能是甚麼原因？ Example: Answer:server 的網路棧滿了 MySQL 在回傳資料時, 是邊讀邊發, 那若 client 接收的慢, 可能會造成什麼情況？server 因為結果發不出去, 造成 transaction 執行時間拉很長 MySQL 在回傳資料時, 是邊讀邊發, 還是一次讀完再發？邊讀邊發 MySQL 中, 到哪去看 socket_send_buffer?/proc/sys/net/core/wmem_default MySQL 中, 一個查詢最大會佔用 MySQL 多少內存？net_buffer_length 以下的 MySQL example image 的意思是？ Example: Answer:MySQL query 的結果會逐一的放到 net_buffer, 滿了之後經由 socket_send_buffer 送到 client 端 MySQL 中, query result set 會發送到 net_buffer, net_buffer 滿了之後調用網路接口發出去, 那如果返回以下的訊息, 代表的意思是？ Example:EAGAIN 或 WSAEWOULDBLOCK Answer:代表本地網路 socket send buffer 已滿, 進入等待, 直到網路棧重新可寫, 再繼續發送 MySQL 中, query result set 會全部取得後才送到 client 端嗎？不會, 會發送到 net_buffer, net_buffer 滿了之後調用網路接口發出去 MySQL 中, 參數 net_buffer_length 的意思是？定義 net_buffer 的大小 MySQL 中, -quick flag 有什麼效果？(1) 跳過 table 自動補全功能(2) 使用 mysql_use_result(3) 不會把執行命令記錄到本地的歷史文件 MySQL 中, 當使用 mysql_use_result, 可能會造成 server 更快還更慢？更慢, 因為可能會導致服務端發送結果被阻塞 MySQL 中, client 端發送請求後, 接收服務端返回結果的方式有哪兩種？(1) mysql_store_result client 端本地緩存(2) mysql_use_result 不緩存, 讀一個處理一個 MySQL 中, 若因為 table 數量多, 想要加快連接 mysql client 介面連接速度, 可以怎麼做？-A 關掉自動補全功能 MySQL 中, 當 table 數量一多時, 使用 mysql client 連接會卡很久, 實際上是卡在哪？卡在建立 local hash table MySQL 中, 為什麼當 table 數量一多時, 使用 mysql client 連接會卡很久？因為 MySQL client 會提供一個 local DB 以及 table 的自動補全功能, 因此需要(1) 執行 show database(2) 執行 show tables(3) 將上面兩條命令的結果構建一個 local hash table MySQL 中, 按下 Ctrl+C 是不是就可以直接終止 thread 呢？不行, 只是會送一個 kill query, 但不代表可以終止掉該 thread MySQL 中, 有哪些情況可能會造成終止邏輯耗時長, kill 會卡住?(1) 超大事務執行期間被 kill, 回滾操作需要對事務執行期間生成的所有新數據版本作回操作(2) 大查詢回滾, 如果查詢過程中生成了比較大的臨時文件, 加上此時文件系統壓力大, 刪除臨時文件可能需要等待 I/O 資源(3) DDL 命令執行到最後階段被 kill, 需要刪除中間過程的臨時文件, 也可能受 I/O 資源影響耗時較久 MySQL 中, 有哪兩種情況, show processlist 的結果會是 Command=killed?(1) thread 沒有執行到判斷狀態的邏輯(2) 終止邏輯耗時較長 以下的 MySQL example image 中, 為什麼 session E 有效果？ 實際效果是？ Example:set global innodb_thread_concurrency=2; Answer:kill C 只是將 connection 斷開, 實際上, query 仍在 server 執行 以下的 MySQL example image 中, 為什麼 session D 沒有效果？ Example:set global innodb_thread_concurrency=2; Answer:因為在 innodb_thread_concurrency 滿的情況下, thread 會每十毫秒判斷是否能進到 innodb 執行, 不行就 sleep, 在這個等待的循環中, 並沒有判斷線程狀態的邏輯, 因此不會進入終止邏輯階段 MySQL 中, 一個語句執行, 如何隨時判斷狀態？ 例如收到 kill 指令語句執行中會有許多埋點, 在埋點判斷狀態, 執行該有的邏輯 MySQL 中, 當執行 kill query 時, MySQL 會做以下兩件事, 為什麼要對 thread 發送信號？ Example:(1) 將 session 的運行狀態改成 THD::KILL_QUERY (將變量 killed 給值為 THD::KILL_QUERY))(2) 給 session B 的執行線程發一個信號 Answer:因為 session B 處於 lock waiting 的狀態, 如果只是改狀態, session B 並不知道這個狀態變化, 會繼續等待, 發信號就是讓 session B 退出等待 以下的 MySQL example image 的意思是？ Example: Answer:使用 kill query 將 waiting for lock 的 query kill 掉 MySQL 中, 有哪兩種 kill 語句？kill query thread_id, 終止該 thread 執行的語句kill connection thread_id, 終止該 tread 的 connection MySQL 跟 Linux 中的 kill, 實際上都是怎麼樣的行為？ 是直接將 process 砍掉嗎？不是實際上是告訴 process, 可以開始執行停止執行的邏輯了 MySQL 中, update 跟 performance_schema 都是使用輪詢取資料的方式, 那為何說後者較準確？後者是 MySQL 內部會自動統計資料, 所以取得得是隨著時間統計的資料update 只是測試單一個時間點, 所以會有隨機性 MySQL 中, innodb_thread_concurrency 設為多少最好?核心數的兩倍 以下的 MySQL example code 的意思是？ Example:select event_name,MAX_TIMER_WAIT FROM performance_schema.file_summary_by_event_name where event_name in (&#x27;wait/io/file/innodb/innodb_log_file&#x27;,&#x27;wait/io/file/sql/binlog&#x27;) and MAX_TIMER_WAIT&gt;200*1000000000;truncate table performance_schema.file_summary_by_event_name; Answer:先利用 MAX_TIMER_WAIT 作為指標, 取出超過 200 毫秒的紀錄, 取得資料後, 清空之前的紀錄, 接下來若是再出現異常, 就可累計 以下的 MySQL example code 的意思是？ Example:update setup_instruments set ENABLED=&#x27;YES&#x27;, Timed=&#x27;YES&#x27; where name like &#x27;%wait/io/file/innodb/innodb_log_file%&#x27;; Answer:打開 redo log 的 performance_schema 以下的 MySQL example image 的意思是？ Example: Answer:performance_schema 針對 redo log 的各項統計COUNT_STAR 代表 I/O 總數接下來四項代表總和、最大、平均、最小COUNT_READ 代表 read 總數SUM_NUMBER_OF_BYTES_READ 代表 read 的總 byteCOUNT_WRITE 代表 write 總數COUNT_MISC 是針對其他類型的統計, 在 redo log 中, 可理解為 fsync 以下的 MySQL example code 的意思是？ Example:mysql&gt; CREATE TABLE `health_check` ( `id` int(11) NOT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`)) ENGINE=InnoDB;/* 检测命令 */insert into mysql.health_check(id, t_modified) values (@@server_id, now()) on duplicate key update t_modified=now(); Answer:由於檢測資料庫, 若架構為雙 M, 則兩台資料庫可能會因為更新同一行而出現行衝突, 因此將 primary key 設為 server_id, 當資料庫收到自己的 server_id 時會自動忽略, 結果就是主庫偵測主庫的, 備庫偵測備庫的 以下的 MySQL example code, 為什麼仍不足以判斷 MySQL 是否正常？ Exampleselect * from mysql.health_check; Answerselect 的確可以判斷併發查詢是否堵住了, 但無法判斷磁碟是否吃滿了 以下的 MySQL example code, 會佔用併發查詢的總數嗎？ Exampleselect sleep(100) from t Answer會哦 MySQL 中, 進入鎖等待的 thread, 會吃 CPU 嗎？不會 MySQL 中, 鎖等待的 connection, 會否佔用併發查詢的總數？不會 MySQL 中, 併發連接以及併發查詢, 哪一種是 CPU 殺手併發查詢 MySQL 中, innodb_thread_concurrency 建議設為多少？64~128, 取決於 CPU 有幾核 以下的 MySQL example code &amp; image 的意思是？ Example:set global innodb_thread_concurrency=3;CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB; insert into t values(1,1) Image: Answer:select 1; 只能檢測出 MySQL process 還在, 但如果是併發查詢被佔滿了, 就無法偵測出 MySQL join 中, 建議小表當驅動表, 如何定義小表？在 where 語句過濾過, 以及 select 欄位的多寡, 總結出行數較少且字段較少的, 稱為小表 以下的 MySQL example code 中, 假設 t1 有 100 行, t2 有 1000 行, 哪句效能較優？ Example:select t1.b,t2.* from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=100;select t1.b,t2.* from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=100; Answer:第一句where 讓兩個表都等於 100 行, 但 t1 只取 b, t2 取所有字段, 因此 t2 資料較大結論, 選佔用 join_buffer 少的 以下的 MySQL example code 中, 假設 t1 有 100 行, t2 有 1000 行, 哪一句的效能較好？ Example:select * from t1 straight_join t2 on (t1.b=t2.b) where t2.id&lt;=50;select * from t2 straight_join t1 on (t1.b=t2.b) where t2.id&lt;=50; Answer:第二句, 因為 where 條件, t2 只需 50 行, 所以 join_buffer 中只需丟入 50 行即可 以下的 MySQL example image 的意思是？ Image: Answer:(1) 根據 join_buffer 的大小, 取出對應數量 t1 放入 join_buffer(2) t2 full table scan, 每一行 t2 都要跟 t1 88 行比對(3) 符合的結果存到 result set(4) 清空 join_buffer(5) 塞入 t1 剩下的行數(6) 重複步驟 2(7) 重複步驟 3 MySQL 中, join_buffer_size 的用途是？定義 join_buffer 的大小, 會影響到 BNJ (Block Nested Join) 的速度 以下的 MySQL example image 的意思是？ Image: Answer:代表 join 無使用 index, 使用 BNJ 算法以及 join_buffer, 這種情況下不建議使用 join 以下的 MySQL example code 中, 說說 join 實際的執行順序？ Example:CREATE TABLE `t2` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`)) ENGINE=InnoDB;drop procedure idata;delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=1000)do insert into t2 values(i, i, i); set i=i+1; end while;end;;delimiter ;call idata();create table t1 like t2;insert into t1 (select * from t2 where id&lt;=100)select * from t1 straight_join t2 on (t1.b=t2.b); Answer:被驅動表上無可用的索引(1) 由於是 select * from t1, 因此將整個 t1 讀入 join_buffer(2) full scan t2, 並逐一取出, 與 join_buffer 中的每一行比對, 由於 join_buffer 中是無序數組, 因此 t2 中的每一行都要跟 join_buffer 做 100 次判斷, 總共判斷 100*1000 = 100000 次(3) 取出表 t2 中滿足條件的行, 跟 t1 該行組成一行, 作為結果集的一部分 MySQL 中, 使用 join 時, 該選擇 record 多或少的當驅動表？少的, 因為複雜度是 N + N*2*logMN 是驅動表行數, M 是被驅動表行數 以下的 MySQL example code 中, 假設 t1 共有 N 行, t2 共有 M 行, a 有索引, 那總時間複雜度為多少？ Example:select * from t1 straight_join t2 on (t1.a=t2.a); Answer:N+N2logMt1 行數, 每次在 t2 搜索的複雜度為 2*logM, 共搜索 N 次t2 每次共會搜尋兩棵樹, a index 以及 id每次樹搜索的時間複雜度為 logM 以下的 MySQL example code 中, 假設 t2 共有 M 行, a 有索引, 那搜索 t2 單次的時間複雜度是多少？ Example:select * from t1 straight_join t2 on (t1.a=t2.a); Answer:2*logM共會搜尋兩棵樹, a index 以及 id每次樹搜索的時間複雜度為 logM 以下的 MySQL example code 中, 若不使用 join, 而使用 select * from t1 在手動拼接, 共掃幾行？ 差異是？ Example:CREATE TABLE `t2` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`)) ENGINE=InnoDB;drop procedure idata;delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=1000)do insert into t2 values(i, i, i); set i=i+1; end while;end;;delimiter ;call idata();create table t1 like t2;insert into t1 (select * from t2 where id&lt;=100)select * from t1 straight_join t2 on (t1.a=t2.a); Answer:一樣共掃 200 行, 差異在於會有 101 次 query, 使用 join 只有 1 次 以下的 MySQL example image, 分別各掃兩個 table 幾行？ Image: Answer:(1) 對驅動表 t1 全表掃, 100 行(2) 取 a 字段到 t2 找, 樹搜索共 100 行(3) 共 200 行 以下的 MySQL example image, 是算哪種算法？ Image: Answer:NLJ (Index Nested-Loop Join) 以下的 MySQL example code 中, 說說 join 實際的執行順序？ Example:CREATE TABLE `t2` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `a` (`a`)) ENGINE=InnoDB;drop procedure idata;delimiter ;;create procedure idata()begin declare i int; set i=1; while(i&lt;=1000)do insert into t2 values(i, i, i); set i=i+1; end while;end;;delimiter ;call idata();create table t1 like t2;insert into t1 (select * from t2 where id&lt;=100)select * from t1 straight_join t2 on (t1.a=t2.a); Answer:(1) 從表 t1 中讀入一行數據 R(2) 從數據 R 中, 取出 a 字段, 到表 t2 中去找(3) 取出表 t2 中滿足條件的行, 跟 R 組成一行, 作為結果集的一部分(4) 重複 1~3, 直到表 t1 循環結束 MySQL 中, 以下三種 dead lock log 代表的意思是？ Example:locks gap before reclock_mode X locks rec but not gaplock_mode X waiting Answer:(1) 第一種代表 gap lock(2) 第二種代表 row lock(3) 第三種代表 next-key lock 以下的 MySQL example image 中, 為什麼會 block? Image: Answer:原先鎖的範圍為 (5~最大值], 更新之後, 變成 (1, 最大值], 所以 5 鎖住了 以下的 MySQL example image 中, 為什麼會 block? Image: Answer:因為 id=10 被刪除後, next-key lock 變為 (5,15], 原本是 (10,15] MySQL 中, 為了避免死鎖, 在對同一個資源 query 時, 要按照怎樣的順序訪問？相同的順序 以下的 MySQL example image, 事務 2 的意思是？ Image: Answer:HOLDS THE LOCK(S) 用來顯示這個事務持有哪些鎖；index c of table test.t 表示鎖是在表t 的索引c 上；hex 0000000a 和hex 00000014 表示這個事務持有c=10 和c=20 這兩個記錄鎖；WAITING FOR THIS LOCK TO BE GRANTED，表示在等(c=5,id=5) 這個記錄鎖。lock in share mode 的這條語句，持有c=5 的記錄鎖，在等c=10 的鎖；for update 這個語句，持有c=20 和c=10 的記錄鎖，在等c=5 的記錄鎖。 以下的 MySQL example image, 事務 1 的意思是？ Image: Answer:WAITING FOR THIS LOCK TO BE GRANTED, 表示這個事務在等待的鎖的信息index c of table test.t, 說明在等的是表 t 的索引 c 上面的鎖lock mode S waiting, 表示這個語句要自己加一個讀鎖, 當前狀態等待中Record lock, 說明這是一個紀錄鎖n_fields 2, 表示這個紀錄是兩列, 也就是 column c 以及 primary key id0: len 4; hex 0000000a; asc ;;, 是第一個 column, 也就是 c, 值為十六進制 a, 即 10 是第一个字段，也就是 c。值是十六进制 a，也就是 101: len 4; hex 0000000a; asc ;;, 是第二個 column, 也就是 primary key id, 值也是 10, 這兩行裡面的 asc 表示的是, 接下來要打印出值裡面的 ‘可打印字符’, 但 10 不是可打印字符, 因此就顯示空格以上信息顯示出在等 (c=10,id=10) 這一行鎖, 但既然出現死鎖了, 表示這個事務也佔有別的鎖, 但沒有顯示出來 以下的 MySQL example image, transaction 1 中, asc ;; 代表的意思是？ Image: Answer:要打印出值的 ‘可打印字符’, 但 10 不是可打印字符, 因此顯示空格 以下的 MySQL example image, transaction 1 中, 1: len 4; hex 0000000a; asc ;; 代表的意思是？ Image: Answer:第二個字段, 也就是 primary key id, 值是 16 進制 A, 也就是 10 以下的 MySQL example image, transaction 1 中, 0: len 4; hex 0000000a; asc ;; 代表的意思是？ Image: Answer:第一個字段, 也就是 c, 值是 16 進制 A, 也就是 10 以下的 MySQL example image, transaction 1 中, n_fields 2 代表的意思是？ Image: Answer:表示這個紀錄是兩列, column c 以及 primary key id 以下的 MySQL example image, transaction 1 中, Record lock 代表的意思是？ Image: Answer:說明這是一個紀錄鎖 以下的 MySQL example image, transaction 1 中, lock mode S waiting 代表的意思是？ Image: Answer:表示這個事務想要自己加一個讀鎖, 狀態為等待中 以下的 MySQL example image, transaction 2 中, hex 0000000a 和 hex 00000014 代表的意思是？ Image: Answer:表示這個事務持有 c=10, c=20 這兩個紀錄鎖 以下的 MySQL example image, transaction 1 中, index c of table `test`.`t` 代表的意思是？ Image: Answer:表示在等的是表 t 的索引 c 上的鎖 以下的 MySQL example image, transaction 1 中, WAITING FOR THIS LOCK TO BE GRANTED 代表的意思是？ Image: Answer:表示這個事務在等待的鎖的信息 MySQL 中, 當條件為範圍查詢時, 為什麼會出現等值查詢？在第一次樹搜索定位時會使用等值查詢 以下的 MySQL example code 中, 加了哪些鎖, 順序為何？ Example:CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);begin;select * from t where id&gt;9 and id&lt;12 order by id desc for update; Answer:由於 desc, 會先 tree search 找 id=12 的值, 沒找到, 只找到 (10,15) key-lock, 這邊會先往右遍歷, 因為 15 != 12, 索引等值查詢不相等時會退化為 gap lock向左遍歷, 舊版 MySQL 會掃到第一個不符合條件的值為止, 即 id=5, 所以鎖了 (0,5], (5,10]總共鎖了 (0,5], (5,10], (10,15) 根據阿里巴巴 MySQL 規約, 撈取資料時, 可以使用 * 嗎？不可, 需指名 column 根據阿里巴巴 MySQL 規約, 不在代碼中使用 truncate 來代替 delete, 儘管 truncate 速度快, 原因為何？truncate 無事務, 且無法觸發 trigger 根據阿里巴巴 MySQL 規約, 如果有全球化需求, 且有表情符號需求, 資料庫儲存使用什麼編碼？utf8mb4 根據阿里巴巴 MySQL 規約, 如果有全球化需求, 資料庫儲存使用什麼編碼？utf8 根據阿里巴巴 MySQL 規約, 須盡量避免 in, 若非得使用, 限制多少數量 ?1000 以內 根據阿里巴巴 MySQL 規約, 是否須盡量避免 in ?是的 根據阿里巴巴 MySQL 規約, 要刪除 data 前, 要先經過哪道程序？要先 select, 確認無誤避免誤刪 根據阿里巴巴 MySQL 規約, 不可使用 process, 原因為何？難以調適、拓展, 更無移植性 根據阿里巴巴 MySQL 規約, 需使用 IFNULL() 來判斷是否 NULL, 為什麼？因為 NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。 NULL=NULL 的返回结果是 NULL，而不是 true。 NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。 MySQL 中, 如果一個大事務執行了 10 分鐘, 從庫會只堵這個事務, 還是所有的事務？看是否有並行複製, 預設是串行, 就是全堵 MySQL 中, 一般主從延遲超過多少就不好？大於 1 MySQL 當主從連接時會取得 unix_timestamp 取得時間差, 若連接完成後再去改從庫系統時間, 會否造成 seconds_behind_master 不準？會的, 主庫只在建立連接時取得時間差 根據阿里巴巴 MySQL 規約, 可以使用 foreign key 嗎？只可在應用層實施, 高併發或分布式資料庫時會造成嚴重阻塞 以下的 MySQL example code 的意思是？ Example:SELECT IF (ISNULL (SUM (g)),0,SUM (g)) FROM table; Answer:因為 sum(col) 如果 col 全為 null, 則 result 為 null, 因此為了避免 NPE (Null Pointing Exception) issue, 使用 IFNULL 判斷, 若 NULL 則給 default 0 以下的 MySQL example code 中, 如果 col 全為 null, 那結果會是？ Example:select sum(col) from table; Answer:NULL 以下的 MySQL example code, 假設 column1 全為 null, column2 全不為 null, 則結果為？ Example:select count (column1, column2) from table; Answer:0 根據阿里巴巴 MySQL 規約, 在建立索引方面有哪三種誤解？ 一個查詢就需要一個 index index 會嚴重消耗空間, 拖慢更新以及新增速度 唯一索引一律需要在應用層先查後插入解決 根據阿里巴巴 MySQL 規約, 建立 compund index 時, 通常區分度高的為左邊, 有什麼例外情況？非等值以及等值混合判斷時, 即使非等值的 index 區分度較高, 也需置於右邊 根據阿里巴巴 MySQL 規約, 建立 compund index 時, 怎樣的 index 置於右邊？區分度高的 根據阿里巴巴 MySQL 規約, SQL 性能優化又分為哪三個等級？ const: 單一匹配, 如 id 或 unique index ref: normal index range: range index serach 以下的 MySQL example code 的意思是？ Example:SELECT a.* FROM table_a as a, (select id from table_a where xxx LIMIT 100000,20) as b where a.id=b.id Answer:當資料庫資料筆數到達一定程度時, limit 會造成效能低下, 因為 MySQL 是先取得 100000 + 20 行, 在丟棄 100000 行因此可以利用 subquery 取得目標 id, 再從該 id 取得所有資料 根據阿里巴巴 MySQL 規約, 可以使用左模糊或全模糊搜尋嗎？不可, 若有必要請使用搜尋引擎 根據阿里巴巴 MySQL 規約, 在 varchar 上建立 index, 務必使用哪種類型 index?prefix 根據阿里巴巴 MySQL 規約, 超過幾個 table 不可使用 join?三個 以下的 MySQL example code 的意思是？ Example:stop slave；CHANGE MASTER TO IGNORE_SERVER_IDS=(server_id_of_B);start slave; Answer:先暫時性的 ignore 指定的 server_id, 等到循環複製的情況解除後, 再加回來 MySQL 中, 為什麼執行 set global server_id=x 後會造成循環複製？因為 server_id 變了, 收到 relay log 之後發現跟目前的 server_id 不同, 就會造成循環複製了 以下的 MySQL example image 的意思是？ Image: Answer:可用性優先策略, binlog format 為 row假設在主備切換的途中, 有兩條 insert 語句, insert c=4 以及 insert c=5 主庫 A 執行完 insert 語句, 插入 c=4 由於採用可用性優先策略, 不將主庫改為 readonly, 所以 insert 完畢, 即 (4,4) 切換為備庫 B, 此時 insert c=5, 主庫 A 改為 readonly, 備庫 B 改為可寫, 並且收到來自主庫 A 的 relay log (4,4) 備庫 B insert c=5 執行完畢, 即 (4,5), 主庫 A 收到來自於備庫 B 的 relay log (4,5) 由於 binlog format 為 row, 所以兩邊同時報錯 duplicate key error 以下的 MySQL example image 的意思是？ Image: Answer:可用性優先策略, binlog format 為 mixed假設在主備切換的途中, 有兩條 insert 語句, insert c=4 以及 insert c=5 主庫 A 執行完 insert 語句, 插入 c=4 由於採用可用性優先策略, 不將主庫改為 readonly, 所以 insert 完畢, 即 (4,4) 切換為備庫 B, 此時 insert c=5, 主庫 A 改為 readonly, 備庫 B 改為可寫, 並且收到來自主庫 A 的 relay log (4,4) 備庫 B insert c=5 執行完畢, 即 (4,5), 主庫 A 收到來自於備庫 B 的 relay log (4,5) 由於 binlog format 為 statement, 所以兩邊都寫入資料 最終導致主備資料不一致的現象 以下的 MySQL example image 的意思是？ Image: Answer:可靠性優先策略 判斷 SBM (seconds_behind_master) 是否在 5 秒內, 若大於 5 秒則重複判斷 若在 5 秒內, 將主庫 A 改為 readonly 判斷備庫 B 的 SBM, 直到等於 0 將備庫設為可讀寫 將業務請求導向備庫 B MySQL 中, 為什麼大事務會造成主備延遲？若一個主庫上的語句花費 10 分鐘執行, 那這個事務很有可能就會造成至少 10 分鐘的主備延遲 MySQL 中, 若主備延遲的原因是因為備庫又被拿來提供 read, 壓力太大, 通常解法是？採用一主多從方式, 用多個從庫去分散壓力 MySQL 中, 主備延遲有哪兩種可能？ 備庫機器規格較差 備庫又被用來提供 read, 反而造成壓力太大 大事務, 或大表 DDL 備庫的並行複製能力 MySQL 中, 以下的三個時間點中, 主備延遲的主要原因, 可能是哪兩個時間點造成的？ 時間點: 主庫 A 執行完成一個事務, 寫入 binlog, 這個時刻記為 T1 之後傳給備庫, 備庫 B 接收完這個 binlog 的時刻記為 T2 備庫 B 執行完成這個事務, 這個時刻記為 T3 Answer:T3 - T2, 即備庫消耗 relay log 的速度 MySQL 中, 以下的三個時間點中, 哪兩個時間點在網路正常的情況下是非常短的？ 時間點: 主庫 A 執行完成一個事務, 寫入 binlog, 這個時刻記為 T1 之後傳給備庫, 備庫 B 接收完這個 binlog 的時刻記為 T2 備庫 B 執行完成這個事務, 這個時刻記為 T3 Answer:T2 - T1 MySQL 中, 若主備庫的系統時區不一致, 會否影響到 seconds_behind_master 的準確度？不會, 備庫連接到主庫時, 會執行 SELECT UNIX_TIMESTAMP() 取得當前主庫的系統時間, 若發現這個時間與備庫上的系統時間不一致, 在計算 seconds_behind_master 時會扣掉這個差值 MySQL 中, seconds_behind_master 的精度到？秒 MySQL 中, seconds_behind_master 的計算方法是？ 每個事務的 binlog 裡有都有一個時間 column, 用於記錄主庫上寫入的時間 主庫取出事務的時間 column, 計算與當前系統的差值 MySQL 中, 要取得 seconds_behind_master, 可以在備庫上使用哪個指令？show slave status MySQL 中, 以下的三個時間點中, 所謂的主備延遲, 代表的是哪段時間點？ 時間點: 主庫 A 執行完成一個事務, 寫入 binlog, 這個時刻記為 T1 之後傳給備庫, 備庫 B 接收完這個 binlog 的時刻記為 T2 備庫 B 執行完成這個事務, 這個時刻記為 T3 Answer:同一個事務在備庫執行完成的時間 和 主庫執行完成的時間 的 差值T3 - T1 根據阿里巴巴 MySQL 規約, 業務上具有唯一特性的欄位, 即使是組合欄位, 也必須建立 unique index, 對嗎？對的 根據阿里巴巴 MySQL 規約, 建議 table 大小超過多少才分庫分表？2GB 根據阿里巴巴 MySQL 規約, 建議 table 超過幾行才分庫分表？500 萬行 根據阿里巴巴 MySQL 規約, 容許 column redundency 嗎？ 原則是什麼？容許適當以提高性能 不是頻繁修改 column 不是超長 column varchar, 不是 text例如商品總類目, 長度短且基本不會變更, 可冗余以減少關聯 根據阿里巴巴 MySQL 規約, 若修正了 column name 或 column type, 建議一併修改什麼？comment 根據阿里巴巴 MySQL 規約, database 命名盡量與什麼一致？Application 根據阿里巴巴 MySQL 規約, table 命名原則推薦格式為？業務名稱_表的作用, 如 tiger_task 根據阿里巴巴 MySQL 規約, table 有哪三個必備 column?id - primary key, created_at - datetime, updated_at - datetime 根據阿里巴巴 MySQL 規約, 若 column character 大於 5000, 是否需要獨立一張表格？是 根據阿里巴巴 MySQL 規約, character 大於多少使用 text? 否則就使用 varchar?5000 根據阿里巴巴 MySQL 規約, 如果欄位的 character 長度固定, 使用哪個 column type?char 根據阿里巴巴 MySQL 規約, 小數類型一律使用哪個 column type?decimal, 為保持精度 根據阿里巴巴 MySQL 規約, 一般 index 的命名開頭為？idx_xxx, 即 index 簡稱 根據阿里巴巴 MySQL 規約, unique key index 的命名開頭為？uk_xxx, 即 unique key 簡稱 根據阿里巴巴 MySQL 規約, table 命名可以保留字嗎？不行, 可 google reserved word 查詢 MySQL 保留字 根據阿里巴巴 MySQL 規約, table 命名可以使用複數嗎？不行 根據阿里巴巴 MySQL 規約, column 命名在兩個 _ 之間, 可以只出現數字嗎？不行 根據阿里巴巴 MySQL 規約, column 命名可以用數字開頭嗎？不行 根據阿里巴巴 MySQL 規約, boolean 的 column type 為？unsigned tinyint 根據阿里巴巴 MySQL 規約, boolean 的欄位命名規則為？is_xxx MySQL 中, 生產環境的 binlog 格式強烈建議為哪一種？row MySQL 中, 假設一個 table 中並沒有 primary key, 然後 insert 了一筆 record A, record A 和之前的某一筆 record B 一模一樣, 然後使用 binlog 恢復到還沒 insert 之前, 會否刪掉早前那筆一模一樣 record有可能刪到 record B, 因為當 table 沒有 primary key, binlog 中就不會紀錄 primary key MySQL 中, 假設禮拜日的 23 做了備份, 禮拜二 20 要恢復數據, 該使用哪個參數讓 binlog 停在禮拜日的 23?可使用 –stop-datetime flag MySQL 中, 若一個事務的 binlog 寫入後, 超過了 max_binlog_size, 那會怎麼樣？會 rotate, 生成一個新的 binlog file, 但會寫完在 rotate, 不會斷掉 MySQL 中, master 從本地讀取 binlog 並傳給 slave, 是讀 page cache, 還是 disk?這是 OS 做的事, 若有 page cache 則讀 page cache, 否則則是 disk MySQL 中, 一般生產環境的 非雙 1 的設置是？innodb_flush_logs_at_trx_commit=2sync_binlog=1000 MySQL 中, 在哪些情景可能會將 binlog, redo log 設為 非雙 1 ? 有預知的業務高峰期 備庫延遲, 要讓備庫趕上主庫 用備份恢復主庫的副本時 批量導入數據時 MySQL 雙 master 架構中, 如何解決循環複製？ 規定兩個資料庫 server_id 必須不同 備庫在接到 binlog 並重放後, 生成的 binlog 中, server_id 需與來源的 server_id 相同 每個資料庫在收到 master 發來的 binlog, 先判斷 server_id 是否跟自己的一樣, 若是則丟棄 MySQL 雙 master 架構中, 何謂循環複製？master A 的 binlog 在 master B 的 relay log 中執行完畢後, 在 B 又產生新的 binlog, 又傳回 A, 而 A 又執行了一次, 一直往返 MySQL 中, log_slave_updates 設為 on, 表示？表示 relay log 執行後, 也會產生 binlog 以下的 MySQL example image 的意思是？ Image: Answer:雙 master 配置, 彼此皆為對方的 slave, 也為 master, 因此在切換時就不用特別設置誰為 master 誰為 slave MySQL 中, 標準的使用 binlog 恢復數據的做法是？使用 mysqlbinlog 工具解析出來, 把解析結果整個丟給 MySQL 執行, 只複製某段 query 可能會有上下文的關係mysqlbinlog master.000001 --start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd; MySQL 中, 假如一個 query 刪除十萬筆資料, 若使用的 binlog 格式為 row, 儲存的方式是？會儲存十萬筆到 binlog, 紀錄明確 each row 的確實 deleted query MySQL 中, 假如一個 query 刪除十萬筆資料, 若使用的 binlog 格式為 statement, 儲存的方式是？單純儲存該 MySQL query, 頂多十幾個 bytes MySQL 中, binlog mixed 格式被發明的出發點是？節省 row 格式造成的空間消耗 MySQL 中, binlog mixed 格式的特色是？會自己判斷該 query 是否會造成主從不一致, 若會則使用 row 格式, 不會則使用 statement 以下的 MySQL example image 的意思是？ Image: Answer:server id 1: 表示該 transaction 是在 server_id=1 的資料庫上執行的每個 event 都有 CRC32: 因為 binlog_checksum 設為 CRC32Table_map: 代表操作的 table指令使用了 -vv, 因此解析了所有內容, 例如 @1=4, @2=4binlog_row_image 預設配置為 FULL, 因此 Delete_event 中包含了該 row 所有 column 的值, 如果設為 MINIMAL, 則只會紀錄必要訊息, 如 id最後的 Xid event, 表示該 transaction 被正確提交了 以下的 MySQL example code 的意思是？ Example:mysqlbinlog -vv data/master.000001 --start-position=8900; Answer:使用 mysqlbinlog, 從指定的 binlog file 中, 指定 position, 取出接下來的資料 以下的 MySQL example image 的意思是？ Image: Answer:binlog row 格式 以下的 MySQL example 中, 為什麼使用 statement 格式的 binlog 可能會有問題？ Example:CREATE TABLE `t` ( `id` int(11) NOT NULL, `a` int(11) DEFAULT NULL, `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`), KEY `a` (`a`), KEY `t_modified` (`t_modified`)) ENGINE = InnoDB;INSERT INTO t values(1, 1, &#x27;2018-11-13&#x27;);INSERT INTO t values(2, 2, &#x27;2018-11-12&#x27;);INSERT INTO t values(3, 3, &#x27;2018-11-11&#x27;);INSERT INTO t values(4, 4, &#x27;2018-11-10&#x27;);INSERT INTO t values(5, 5, &#x27;2018-11-09&#x27;);delete from t /*comment*/ where a&gt;=4 and t_modified&lt;=&#x27;2018-11-10&#x27; limit 1; Answer:因為在 slave 再次執行 binlog 時, 不確定會使用 a 或是 t_modified 哪一個索引, 可能會造成 master 與 slave 資料不一致 以下的 MySQL example image 的意思是？ Image: Answer:binlog statement 格式 MySQL 中, binlog 又分為哪三種格式？statement, row, mixed 以下的 MySQL example image 的意思是？ Image: Answer: 在備庫上使用 change master, 指定 master 的 ip, port, account, password, 以及要從哪個位置請求 binlog, 包含文件名以及 log 偏移量 在備庫使用 start slave, 會啟動兩個 process, io_thread 以及 sql_thread, io_thread 會與 master 建立連接 master 校驗完身份後, 開始按照 slave 指定的位置, 從本地讀取 binlog, 發給 slave slave 拿到 binlog 後, 寫到 relay log, 稱為中轉日誌 sql_thread 讀取 relay log, 解析並執行 以下的 MySQL example image 中, 將備庫設為 readonly, 那我還怎麼同步呢？ Image: Answer:同步的 session 需擁有 super 權限 以下的 MySQL example image 中, 會將備庫設為 readonly, 主要有哪三種考量？ Image: Answer: 當在備庫上使用一些 query 時, 可防止誤寫 如果切換邏輯沒寫好, 會造成雙寫 可用 readonly 來判斷 node 的角色 以下的 MySQL example image 的意思是？ Image: Answer:兩個資料庫, 互為備庫, 當為備庫時為 readonly MySQL 中, binlog_cache_size 跟 max_binlog_cache_size 的差別是？前者超出了會存到 disk 上, 後者會噴錯 MySQL 中, 為什麼說 redo log 可以共用一個 relog log buffer, 但 binlog 卻要每個線程獨立, 不可中斷？一個 binlog 都相當於一個事務, 要是中斷了或分散了, 就相當於把一個事務分開執行, 這樣就無法保證其原子性redo log 是以 page 為單位, 一個事務可能會更動多個 page, 多個事務也可能只更動一個 page, 所以較無原子性問題 MySQL 中, 如果 sync_binlog = N, binlog_group_commit_sync_no_delay_count = M, binlog_group_commit_sync_delay = 很大值, 這種情況下, 何時會 fsync?會先滿足 sync_binlog 條件, 接下來才會去判斷要使用 no_delay_count 還是 sync_delay, 如果 no_delay_count &gt; sync_binlog, 則會滿足 no_delay_count 才會 fsync MySQL 中, 事務未提交前, redo log 及 binlog 會寫到哪裡？redo log buffer 以及 binlog cache MySQL 中, 要走到 redo log prepare, 會先經過 transaction commit 嗎？會, 二階段協議(非 lock 的二階段提交) 是在 transaction commit 後才開始 MySQL 中, 事務執行期間, 如果發生 crash, 導致 redo log 丟了, 這樣會不會造成主備不一致？不會, 因為 crash 之後 redo log 和 binlog 都沒了, 從業務上來看, 這個數據也沒有提交, 因此數據一致 MySQL 中, 為什麼 binlog cache 是每個線程自己維護, 而 redo log buffer 是全局共用？因為 binlog 是不可以被打斷的, 一個事務的 binlog 必須連續寫, 整個事務完成後, 在一起寫到文件內redo log 則沒有這個要求, 中間有生成的 log 可以寫到 redo log buffer 中, redo log buffer 中的內容還能搭便車, 隨其他事務一起被寫到 disk 中 MySQL 中, 執行一個 update 語句, 在執行 hexdump 查看 ibd 文件內容, 為何沒看到數據有改變？可能因為 WAL 機制, update 語句執行完畢後, InnoDB 只保證寫完了 redo log, page cache, 還沒 sync 到 disk MySQL 中, 如果遇到性能上的瓶頸, 通常有哪三種方法可以提升性能？ 調高 binlog_group_commit_sync_no_delay_count, binlog_group_commit_sync_delay 參數, 會增加 response time, 但無數據丟失風險 將 sync_binlog 設置大於 1, 常見的為 100~1000, 主機掉電會丟 binlog 將 innodb_flush_log_at_trx_commit 設為 2, 風險是主機掉電時會丟數據 MySQL 中, ‘binlog_group_commit_sync_no_delay_count’ 以及 ‘binlog_group_commit_sync_delay’ 的關係是？or, 只要其中一個滿足就調用 fsync, 所以如果 delay 設為 0, count 也就失效了 MySQL 中, ‘binlog_group_commit_sync_no_delay_count’ 的意思是？累積多少次 write 的次數才調用 fsync MySQL 中, ‘binlog_group_commit_sync_delay’ 的意思是？延遲多少微秒才調用 fsync 以下的 MySQL example image 的意思是？ Image: Answer:將 fsync 的時間延後, 以更加優化 group 提交, 減少 IOPS 消耗 以下的 MySQL example image 中, 為什麼 trx1 會帶著 length 160 到 fsync? Image: Answer:trx1 是第一個到 redo log 的 trx, 因此被選為該 group 的 leader, 當 fsync 的時間到了, 會 fsync redo log 中的所有 trx, 又名為 group commit 何謂 MySQL 的 ‘雙 1’ 配置？sync_binlog 以及 innodb_flush_log_at_trx_commit 都設為 1, 一個事務提交前, 會有兩次的刷盤 MySQL 中, 在二階段提交時, redo log 會在 prepare 時持久化, 還是 commit 時？會在 prepare 時持久化, commit 時只寫到 disk MySQL 中, 有哪三種情況, 會讓一個沒有提交的事務的 redo log 寫入磁盤中？ Image: Answer:後台 process 固定每秒輪詢一次, 會呼叫 write 將 redo log buffer 寫到 page cache, 在調用 fsync 將 page cache 寫入 disk當 redo log buffer 即將達到 innodb_log_buffer_size 的一半, 後台 process 會主動寫盤, 但由於事務並沒有提交, 只會調用 write, 不會調用 fsync並行的事務提交時, 順帶將其他未提交的 redo log buffer 持久化, 假設事務 A 執行到一半, 已寫了一些 redo log 到 buffer 當中, 這時有另外一個事務 B 提交, 且 innodb_flush_log_at_trx_commit=1, 這時會將 redo log buffer 中的的 log 全部持久化到 disk 以下的 MySQL example image 中, 當 innodb_flush_log_at_trx_commit=2, 行為是？ Image: Answer:每次事務提交都只是把 redo log 寫到 page cache 以下的 MySQL example image 中, 當 innodb_flush_log_at_trx_commit=1, 行為是？ Image: Answer:每次事務提交都把 redo log 持久化到 disk 以下的 MySQL example image 中, 當 innodb_flush_log_at_trx_commit=0, 行為是？ Image: Answer:每次事務提交都只是把 redo log 留在 redo log buffer 中 以下的 MySQL example image 中, 每個區塊的寫入速度比較是？ Image: Answer:紅色跟黃色都屬於內存, 速度差不多, 綠色屬於 disk, 速度慢多了 以下的 MySQL example image 中, 每個區塊分別代表的意思是？ Image: Answer:紅色屬於 MySQL process 中的內存, 黃色為 page cache, 還不算持久化, 綠色才算持久化 以下的 MySQL example image 中, 如果有 I/O 瓶頸, 一般會將 sync_binlog 設為多少？ Image: Answer:100~1000 以下的 MySQL example image 中, 如果服務容錯率非常低的話, 那 sync_binlog 會設為多少？ Image: Answer:1, 每次都 fsync 以下的 MySQL example image 中, 如果我的 sync_binlog=N(N&gt;1), 那行為會是？ Image: Answer:每次都 write, 但累積 N 個 transaction 後才 fsync 以下的 MySQL example image 中, 如果我的 sync_binlog=1, 那行為會是？ Image: Answer:每次事務都 fsync 以下的 MySQL example image 中, 如果我的 sync_binlog=0, 那行為會是？ Image: Answer:每次事務都只 write, 不 fsync MySQL 中, binlog_cache_size 的用途是？控制單個線程內, binlog cache 的大小, 若超出規定值, 則暫存到 disk 上 以下的 MySQL example image 的意思是？ Image: Answer:transaction 執行過程中, 會先把 log 寫到 binlog cache, 提交時, 再把 binlog 寫到 binlog 文件中系統給 binlog cache 分配了一塊內存, 每個線程一個, binlog_cache_size 用於控制單個線程內, binlog cache 所佔的大小, 如果超過了, 將會暫存到 disktransaction 提交時, 會將 binlog cache 完整寫入到 binlog 文件, 並清空 binlog cache 以下的 MySQL 步驟的意思是？ Example:上線前, 在測試環境, 把 slow log 打開, 把 long_query_time 設為 0在測試表中插入模擬線上的資料, 逐一觀察 slow log 中每類 query 的輸出, 留意 rows_examined 是否與預期一致 Answer:在上線前檢查, 預先發現問題 MySQL 中, 哪個工具可以幫忙檢查所有 slow log 中所有 query 的返回結果？pt-query-digest 以下的 MySQL example code 的意思是？ Example: insert into query_rewrite.rewrite_rules(pattern, replacement, pattern_database) values (&quot;select * from t where id + 1 = ?&quot;, &quot;select * from t where id = ? - 1&quot;, &quot;db1&quot;);call query_rewrite.flush_rewrite_rules(); Image: Answer:當 sql 語句寫錯了, 但無法從程式端修改時, 可直接從 DB 端修改, 但須謹慎評估, 可能造成誤傷 MySQL 中, 以下的步驟的意思是？ Example在備庫上執行 set sql_log_bin=off, 執行 alter table 加上索引主從切換在主庫上執行 set sql_log_bin=off, 執行 alter table 加上索引 Answer當索引沒設計好時, 直接在備庫上執行 DDL MySQL 中, 通常造成慢查詢大體上會是哪三種原因？ 索引沒設計好 SQL 語句沒寫好 MySQL 選錯索引 以下的 MySQL example code 的意思是？ Example[mysqld]skip-grant-tablesskip-networking Answer當忘了 root 密碼, 或者暫時性地減低 connection 的 cost, 可以先把驗證部分拿掉, 並中斷 networking, 這樣外部就無法直接連接資料庫然後在 restart mysql 以下的 MySQL example image 的意思是？ Image Answer當不確定有哪些 connection 是處於 transaction 中時, 可使用 select * from information_schema.innodb_trx 以下的 MySQL example image 中, 如果非得 kill 掉一個 session, 該 kill 哪一個？ Image Answersession B, 因為不會造成什麼有損傷害若 kill session A, 那會造成 rollback MySQL 中, 為什麼說每一次連接的成本都很大？要經過 TCP 三次握手, 以及權限驗證等等的程序 MySQL 中, insert … select 會加鎖嗎？為了一致性, 會加 read lock MySQL 中, RC Isolation level 下, 若要避免 binlog 與資料庫不一致, 需怎麼做？將 binlog 設置為 row 格式 以下的 MySQL example image 中, 默認是會上鎖的, 說說不上鎖造成的結果 Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE = InnoDB;INSERT INTO t values(0, 0, 0), (5, 5, 5), (10, 10, 10), (15, 15, 15), (20, 20, 20), (25, 25, 25); Image Answersession A 已表示要鎖住所有 d=5 的 row 了, session B 還透過 update 讓 d=5 多了 1 rowsession C 則是透過 insert 直接插入新的一個 d=5 的 row MySQL 中, RR Isolation 中, 索引等值查詢, 向右遍歷且最後一個值不滿足等值條件時, 會怎麼做？next-key lock 退化為 gap lock MySQL 中, RR Isolation 中, 索引等值查詢, 當給唯一索引加鎖時, 規則是？next-key lock 退化為 row lock MySQL 中, RR Isolation 中, 基本的加鎖單位是？next-key lock, 先加 gap lock, 再加 row lock MySQL 中, 無索引的 update 會逐行加鎖, 還是全部加鎖？逐行 MySQL 中, 如果 Isolation level 為 RC, semi-consistent read 優化對 delete 有效嗎？無效, 只對 update 有效 MySQL 中, 如果 Isolation level 為 RC, 何謂 semi-consistent read 優化？如果 update 碰到一個被上鎖的行, 會讀入最新的版本, 如果滿足查詢條件則等待鎖, 不滿足則直接跳過 MySQL 中, 如果 Isolation level 為 RC, 在 transaction 中, 會待 commit 才釋放 lock, 還是語句執行完畢就釋放？語句執行完畢就釋放 MySQL 中, 如果 Isolation level 為 RC, 那 next-key lock 如何判別範圍？拿掉 gap lock, 只剩行鎖 以下的 MySQL example image 中, 說明 dead lock 是如何產生的 Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answer根據加鎖原則, session A 加入 next-key lock (5,10]因為 c 為非唯一索引, 因此繼續向後遍歷, 取得不符合的下一個值, 即 15, 根據優化原則, 索引向右遍歷取得不符合條件的值時, 退化為 gap lock, 因此最終加鎖範圍為 (5,15)這時 session B 也要加上 next-key lock, 先加 gap lock (5,10), gap lock 彼此是不衝突的, 而在要加上行鎖時鎖住了然後 session A 此時要 insert (8,8,8), 卻被 session B 的 gap lock 鎖住了, 因此判斷為 dead lock, sessoin B 斷開 MySQL 中, 在 RR 層級, 刪除時盡量使用 limit, 原因是？避免多餘的 gap lock 以及 row lock 以下的 MySQL example image 中, 說明為何 blocked, 為何 okay? Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);insert into t values(30,10,30); Image Answer根據加鎖原則, c=10, 取得 next-key lock (5,10], 因為 c 為非唯一索引, 因此繼續往後掃, 但因 limit 2, 所以只掃了兩行, 為 (c=10,id=10), 以及 (c=10,id=30)因此, 整個鎖為 (5,10], 而 10 的範圍為 (c=10,id=10), (c=10,id=30), 所以 session B okay 以下的 MySQL example image 中, 說明為何 blocked, 為何 okay? Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);insert into t values(30,10,30); Image Answerc=10, 因此會取得 (5,10] next-key lock, 因為 c 不是唯一索引, 會往後掃到第一個不符合條件的 row, 所以會掃到 c=15在等值查詢下, 當不符合條件時, 會退化為 gap lock (10,15), 因此鎖住 (5,15), 以及相對應的 id 以下的 MySQL example image 中, c 索引是如何排列的？ Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25);insert into t values(30,10,30); Answer 以下的 MySQL example image 中, 說明為何 blocked Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answersession A 是一個範圍查詢, 理論上會取得 next-key lock (10,15], 且因為 id 為唯一索引, 因此判斷到 id=15 就不會再尋找下一個了但 MySQL (新版本已經修復) 會掃到第一個不符合條件的 record, 即 id=20, 所以實際取得的鎖為 (10,15], (15,20], 因此鎖住了 session B, C這算 bug 以下的 MySQL example image 中, 說明為何 blocked Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answersession A 是一個範圍查詢, 理論上會取得 next-key lock (10,15], 且因為 id 為唯一索引, 因此判斷到 id=15 就不會再尋找下一個了但 MySQL (新版本已經修復) 會掃到第一個不符合條件的 record, 即 id=20, 所以實際取得的鎖為 (10,15], (15,20], 因此鎖住了 session B, C 以下的 MySQL example image 中, 說明為何 blocked, 為何 okay Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answer根據非唯一索引等值查詢原則, c=10, 會附加 next-key lock (5,10]範圍查詢會繼續往後查找, 找到 c=15, 所以鎖了 next-key lock (10,15], 因此 c=15 被鎖住了定位 c=10 時, 是等值查詢, 而向右掃到 c=15 時, 是範圍查詢 以下的 MySQL example image 中, 說明為何 blocked, 為何 okay Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answer根據唯一索引等值查詢的優化原則, (5,10] 的 next-key lock 退化為行鎖, 只鎖 id=10範圍查詢會繼續往後查找, 找到 id=15, 所以鎖了 next-key lock (10,15], 因此 id=15 被鎖住了定位 id=10 時, 是等值查詢, 而向右掃到 id=15 時, 是範圍查詢 以下的 MySQL example image 中, 如果我要保持 share lock, 並且讓 session B 也 blocked, 該怎麼做？ Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answer只要讓 covering index 不成立就可以了 以下的 MySQL example image 中, 如果我把 share lock 換成 exclusive lock, 結果會變成？ 為什麼？ Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answer結果會變成兩個都 blocked要是 for update, MySQL 會將 primary key 上符合條件的 row 加鎖根據加鎖原則, 單位為 next-key lock, 因此加鎖範圍為 (0,5]當索引為非唯一索引時, 會繼續向後遍歷, 直到找到第一個不符合的值, 第一個不符合的值為 c=10, 因此會掃過的地方都會加鎖, 因此加一個 next-key lock (5,10]根據優化原則, 索引上的等值查詢, 最後一個不滿足等值條件的 next-key lock 會退化為 gap lock, 因此 (5,10] 退化為 (5,10)根據加鎖原則, 只有訪問到的才會加鎖, 此 query 使用了 covering index, 因此只鎖 covering index 的部分, 沒鎖主鍵, 所以 session B okay 以下的 MySQL example image 中, 說明為什麼 session B 為何 blocked, 而 session C 為何 okay Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answer根據加鎖原則, 單位為 next-key lock, 因此加鎖範圍為 (0,5]當索引為非唯一索引時, 會繼續向後遍歷, 直到找到第一個不符合的值, 第一個不符合的值為 c=10, 因此會掃過的地方都會加鎖, 因此加一個 next-key lock (5,10]根據優化原則, 索引上的等值查詢, 最後一個不滿足等值條件的 next-key lock 會退化為 gap lock, 因此 (5,10] 退化為 (5,10)根據加鎖原則, 只有訪問到的才會加鎖, 此 query 使用了 covering index, 因此只鎖 covering index 的部分, 沒鎖主鍵, 所以 session B okay 以下的 MySQL example image 中, 說明為什麼 session B 為何 blocked, 而 session C 為何 okay Table Schema CREATE TABLE `t` ( `id` int(11) NOT NULL, `c` int(11) DEFAULT NULL, `d` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `c` (`c`)) ENGINE=InnoDB;insert into t values(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25); Image Answer根據加鎖原則, 加鎖單位為 next-key lock, session A 的加鎖範圍為 (5,10]根據優化原則, 這是一個等值查詢, 而 (id=7), 而 id=10 不滿足查詢條件, next-key lock 退化成 gap lock, 因此最終加鎖範圍為 (5,10) 以下的 MySQL example image 的意思是？ Example Answer除了鎖上紀錄之外, 還加上了 gap lock, 以防止新插入 MySQL 中, 幻讀專指 update 後的數據還是新插入的行？新插入的行 以下的 MySQL example code, 假設 b 在 table 中的值都是 ‘1234567890’, 那結果會是？ 會跑很久嗎？ 為什麼？ ExampleCREATE TABLE `table_a` ( `id` int(11) NOT NULL, `b` varchar(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `b` (`b`)) ENGINE=InnoDB;select * from table_a where b=&#x27;1234567890abcd&#x27;; Answer結果為空會engine 在執行時, 因為 varchar(10) 的關係, 會將帶入的 b 截斷為 10 character, 即 ‘1234567890’, 而在引擎中, 符合該條件的有十萬筆, 因此會有十萬次回表, 而每一次取得結果返回 server 層時, server 會再做一次判斷, 結果不吻合, 因此返回空 以下的 MySQL example images 的意思是？ Example Answersession A 的第一個 select 語句耗時較久, 因為該 row 其實已被 update 100 萬次, 代表有 100 萬個版本, 而該 session 的 transaction 版本是在 100 萬次 update 之前, 因此會經由 undo log 返回一百萬個 update 之前的結果, 因此耗時較久第二個 select 使用當前 read, 即取得最新的版本, 所以不須經過 undo log 回朔, 因此較快 以下的 MySQL example image 的意思是？ Example Answerid 4 佔了 MDL read lockid 5 flush table 需要取得 MDL write lock, 但 id 4 的 read lock 要先釋放id 6 以及後面的 process 都會被 id 5 卡住 以下的 MySQL example code 的意思是？ Exampleselect blocking_pid from sys.schema_table_lock_waits; Answer找出 blocking pid MySQL 中, performance_schema 是什麼意思？開啟後, 搭配 sys 可以快速找到 blocking_pid, 但會損失 10% 性能 以下的 MySQL example image 的意思是？ Example Answerselect * from t where id=1 被 MDL block 住了 以下的 MySQL example code 中, 如果 d.tradeid 的 character set 是 utf8, 而 l.tradeid 是 utf8mb4, 那會使用所以樹搜索嗎？ 為什麼？ 可以怎麼修改？ Exampleselect l.operator from tradelog l , trade_detail d where d.tradeid=l.tradeid and d.id=4; Answer不會因為 utf8mb4 為 utf8 的 superset, 因此會變成 CAST(d.tradeid as utf8mb4)=l.tradeid, 進而破壞索引的有序性將 where 條件對調就行了 以下的 MySQL example code, 假設 id 的 column type 為 int, 是否可以使用索引樹搜索？ Exampleselect * from tradelog where id=&quot;83126&quot;; Answer可以, 因為會變成 select * from tradelog where id = CAST(83126 as int), 不影響 id 有序性 以下的 MySQL example image 的意思是？ Example AnswerMySQL 將 string 轉為 int 以下的 MySQL example code 的意思是？ Exampleselect &quot;10&quot; &gt; 9; Answer可以得到 MySQL 對於 string 與 int 的轉換規則, 若是 1 代表將 string 轉為 int, 若是 0 代表將 int 轉為 string 以下的 MySQL example code 中, 索引沒有作用, 可能是什麼原因？ Exampleselect * from tradelog where tradeid=110717; Answer可能是 tradeid 的 column type 不是 int, 然後會將 string 轉為 int, 變成 select * from tradelog where CAST(tradid AS signed int) = 110717;, 當 tradeid 使用了 function, 便失去樹搜索的功能 以下的 MySQL example code, 會使用索引快速定位嗎？ 為什麼？ 該怎麼修改？ Exampleselect * from tradelog where id + 1 = 10000 Answer不會, 因為優化器偷懶 XDid = 10000 - 1 MySQL 中, 為什麼對索引使用 function, 會讓索引失效？因為 function 可能會破壞索引的有序性, 就算最後有使用索引, 也可能只是使用 full index scan, 而不不是使用樹搜索快速定位 以下的 MySQL image 的意思是？ Example Answer對索引使用函數可能會破壞索引的有序性, 優化器會因此放棄走樹搜索功能 以下的 MySQL example code 掃描的總行數是？ Exampleselect count(*) into @C from t;set @Y1 = floor(@C * rand());set @Y2 = floor(@C * rand());set @Y3 = floor(@C * rand());id1 = select * from t limit @Y1，1；id2= select * from t where id &gt; id1 limit @Y2-@Y1，1；select * from t where id &gt; id2 limit @Y3 - @Y2，1； AnswerC + (Y1 + 1) + (Y2 - Y1 + 1) + (Y3 - Y2 + 1) 以下的 MySQL example code 掃描的總行數是？ Exampleselect count(*) into @C from t;set @Y1 = floor(@C * rand());set @Y2 = floor(@C * rand());set @Y3 = floor(@C * rand());select * from t limit @Y1，1； //在应用代码里面取Y1、Y2、Y3值，拼出SQL后执行select * from t limit @Y2，1；select * from t limit @Y3，1； AnswerC + (Y1 + 1) + (Y2 + 1) + (Y3 + 1) 所以, 如果遇到需求是每次打開 APP 提供給使用者隨機幾個單字的話, 那較佳的實踐是？使用 redis 儲存整個單字庫, 如果數據量不大的話 以下的 MySQL example code 的意思是？ Exampleselect count(*) into @C from t;set @Y = floor(@C * rand());set @sql = concat(&quot;select * from t limit &quot;, @Y, &quot;,1&quot;);prepare stmt from @sql;execute stmt;DEALLOCATE prepare stmt; Answer取得所有 row 的數量row number * rand(), rand() 即 0~1 的小數, 配上 floor, 所以假如 row number 是 10, 可能的數就會介於 0~9即 offset 0~9 limit 1, 由於 limit 後面的函數無法直接接 variable, 所以使用 concat()DEALLOCATE prepare 為釋放當次 prepare 資源 以下的 MySQL example code 的意思是？ Exampleselect max(id),min(id) into @M,@N from t ;set @X= floor((@M-@N+1)*rand() + @N);select * from t where id &gt;= @X limit 1; Answer取得最大 id, 最小 id@M-@N+1 代表總共有幾個 row (如果中間有空洞, 這並不準確), * rand() 代表 * 0 ~ 1 的小數, 最後 + @N 使值不會小於 @N 或 @M最後, 取得 id &gt;= @X 的第一個數字缺點就是, 如果之間有空洞, 那就不滿足嚴格的隨機 以下的 MySQL example image 的意思是？ Image Answer使用 對列優先演算法 (filesort_priority_queue_optimization) 來排序, 先組成一個 stack (limit 3), 再依序跟其他的 row 比較, 最終取得 R 值最小的 3 個 row (滿足 limit 3) 以下的 MySQL example image 中, 使用的是哪一種排序演算法？ Image Answer優先隊列演算法 (filesort_priority_queue_optimization) 以下的 MySQL example code 的意思是？ Exampleshow global variables like &#x27;sort_buffer_size&#x27;; Answer取得 current sort_buffer_size 的值 MySQL InnoDB 中, internal_tmp_disk_storage_engine 的意思是？定義 disk 臨時表該使用哪個 engine MySQL InnoDB 中, disk 臨時表使用的默認 engine 是？InnoDB MySQL InnoDB 中, tmp_table_size 的意思是？當超過這個值, 內存臨時表會轉為 disk 臨時表 MySQL InnoDB 中, 如果 primary key 存在, 那 row_id 是？primary key MySQL InnoDB 中, 如果把 primary key 刪了, 那還會有 primary key 嗎？會自動生成長度為 6 bytes 的 row_id 當作 primary key 以下的 MySQL example image 中, 如果我的 sql query 是 select word from words order by rand() limit 3;, 且資料庫中有 10000 筆資料, 那照這個圖的流程, 共會讀取幾筆資料？ Image Answer20003 筆從主表讀入臨時表, 10000 筆, 從臨時表讀入 buffer sort, 10000 筆, 從 buffer sort 取得在臨時表的 3 筆資料 以下的 MySQL example image 中, 簡述一下各個流程 Image Answer(1) 在 memory 中建立一個臨時表, 表中有兩個欄位, r 為 double, w 為 varchar(2) 從 words table 按 primary key 順序取出 word, 對每一個 word 使用 rand(), 記為 r, 1 &gt; r &gt; 0(3) 初始化 sort_buffer, 欄位為 r (rand) 以及 position (row_id), 將臨時表中的資料存到 sort buffer 中(4) sort buffer 中進行排序(5) 根據排序後 sort buffer 的前三筆的位置資訊 (row_id), 從臨時表中取出相對應的三筆資料 MySQL InnoDB 中, 為了節省 disk I/O, 在排序時會選擇哪種排序法？row_id 以下的 MySQL example image 中, Extra column 中的意思是？ Image AnswerUsing temporary 代表需要使用臨時表Using filesort 代表有排序需求, 所以會在臨時表上排序 MySQL 中, 當 binlog_format=row 且 binlog_row_image=FULL, 代表什麼？代表 binlog 需要記錄所有的字段, 所以在 read 的時候會 read 全部的資料, 會影響在 transaction 中, 當前讀的行為, 原本不會去讀的會變成全讀, 所以也不就不會做不必要的 update, 也就不會產生新的可見 version 以下的 MySQL example image 中, 為什麼結果是 (1,3) Image Answer因為 update 中沒有足夠的訊息來判斷該 row 不需要再被更新了, 因此實際上 session A 還是更新了一次, 並在該 transaction 中加入了該 transaction 對該 row update 而生成的一個新的 version, 因此結果為 (1,3) 以下的 MySQL example image 中, 為什麼結果是 (1,2) Image Answer因為 update 的 where 中, 有 a = 3, 觸發當前讀, 進而發現該 row 的值已經是 3, 判斷不需要更新, 因為沒有在 transaction 中產生新的 view, 所在 session A 的 transaction 中, (1,3) 是不可見的 以下的 MySQL example image 中, using index 的意思是？ Image Answer表示有使用覆蓋索引 以下的 MySQL example image 的意思是？ Image Answer使用聯合索引, 並且符合覆蓋索引, 從 index 中取得 city 之後, 不需到原表取值, 也不需進去 sort_buffer 排序, 直接返回結果集 以下的 MySQL example image 的意思是？ Image Answer因為使用了 compound index, 原本需要排序的 name 在 index 中已經是有序的了, 因此取得 city 後, 直接返回原表取得需要的資料, 然後就不需進去 sort_buffer 排序, 而是直接返回結果集 MySQL 中, 為什麼 row_id 排序比全字段排序掃描的行數多？因為最後還要到原表去取需求的資料, 而不是排序完直接返回 以下的 MySQL example image 的意思是？ Image Answer使用 row_id 排序初始化 sort_buffer, 確定要放入字段為 id, name從 index city 取得 id, 並到 table 經由 id 取得 id, name, 再放到 sort_buffer從 index 取下一筆紀錄, 直到將所有符合條件的 id, name 都放到 sort_buffer在 sort_buffer 中排序按照順序到 table 使用 id 取得全部需求字段, return最後一個步驟不需額外耗費內存儲存結果, 而是直接返回 MySQL 中, 何謂 row_id 排序？只將必要的字段放到 sort_buffer, 即 primary key 以及要排序的 column MySQL 中, 何謂全字段排序？將要 return 的資料全部丟到 sort_buffer 中排序 MySQL 中, max_length_for_sort_data variable 的用途是？定義 sort data 的最大長度, 若是單行超過這個長度, 會採用另外一種算法 以下的 MySQL example image 中, packed_additional_fields 的意思是？ Image Answer排序過程對字符串做緊湊處理, 即使字段定義是 varchar(16), 排序過程還是按照實際長度分配空間 以下的 MySQL example image 中, examined_rows 的意思是？ Image Answer排序的行數 MySQL 中, 若使用外部文件來排序, 通常會使用哪個演算法？歸併演算法 以下的 MySQL example image 中, number of tmp files 的意思是？ Image Answer共使用了幾個外部 disk 文件來幫助排序 MySQL 中, 如果 sort_buffer_size 小於要 sort 的資料量的話, 會發生什麼事？會使用外部 disk 臨時文件來 sort MySQL 中, 什麼是 sort_buffer_size?sort_buffer 的 size 以下的 MySQL example code 的意思是？ ExampleSET optimizer_trace=&#x27;enabled=on&#x27;; select VARIABLE_VALUE into @a from performance_schema.session_status where variable_name = &#x27;Innodb_rows_read&#x27;;select city, name,age from t where city=&#x27;杭州&#x27; order by name limit 1000; SELECT * FROM `information_schema`.`OPTIMIZER_TRACE`\\Gselect VARIABLE_VALUE into @b from performance_schema.session_status where variable_name = &#x27;Innodb_rows_read&#x27;;select @b-@a; Answer暫時的打開 optimizer_trace記下初始 read row執行 query取得 optimizer_trace記下 query 後的 read row取得總共 read row MySQL 中, 會給每個 session 分配一塊內存用以排序, 稱為？sort_buffer 以下的 MySQL example image 的意思是？ Image Example select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000 ; Answer從 index 中取得符合 where condition 的 primary key回表取得 city, name, age將值到放 sort buffer 中, 排序返回結果 以下的 MySQL example code 的意思是？ Examplebegin; /*启动事务*/insert into `like`(user_id, liker_id, relation_ship) values(A, B, 1) on duplicate key update relation_ship=relation_ship | 1;select relation_ship from `like` where user_id=A and liker_id=B;/*代码中判断返回的 relation_ship， 如果是1，事务结束，执行 commit 如果是3，则执行下面这两个语句： */insert ignore into friend(friend_1_id, friend_2_id) values(A,B);commit;mysql&gt; begin;insert into `like`(user_id, liker_id, relation_ship) values(B, A, 2) on duplicate key update relation_ship=relation_ship | 2;select relation_ship from `like` where user_id=B and liker_id=A;/*代码中判断返回的 relation_ship， 如果是2，事务结束，执行 commit 如果是3，则执行下面这两个语句：*/insert ignore into friend(friend_1_id, friend_2_id) values(B,A);commit; Answer用 single row 來實現 status 1, 2, 3| 為 按位或, 會將數字轉為二進制再運算, 比如說 1|2 = 3, 因為 01 (1), 10 (2), 所以會變成 11, 即 3, 而 2|2 還是 2, 因為 10, 10, 會等於 10, 而 1|1 還是 1, 因為 01, 01, 會等於 01, 因為還是 1最後的 ignore, 當 insert 重複資料時, 會 ignore, 以免 error 讓 transaction rollback MySQL 中, 如果出現 crash 的情況, 如果恢復數據頁的內存？若判斷數據頁有丟失更新的可能, 會先將數據頁的資料讀到內存, 在使用 redo log 去更新內存到 crash 前的內容 MySQL 中, 如果是正常運行的實例, 刷髒頁時, 會使用到 redo log 嗎？不會, 會把內存刷到 disk MySQL 中, redo log 建議設置多大？如果 disk 有幾個 TB 大小, 建議 4 個文件, 每個 1 GB 以下的 MySQL image 中, 如果只使用 binlog 而不使用 redolog, 當 crash 了, 會出現什麼情形? Image Answertransaction 2 因為尚未提交, crash 後會藉由 binlog2 來復原, 但因為 MySQL 是使用 WAL 方式, 所以 transaction 1 有可能因為內存上的數據頁丟失而一起丟失, 但因為 binlog 顯示已提交, 所以並不會重新執行一次 binlog1, 因此 transaction 1 數據可能丟失 MySQL 中, redo log 和 binlog 是如何關聯的？會有共同的 XID MySQL 中, bin-checksum 的用途是？校驗 binlog 的完整性 MySQL 中, 當發生 crash, MySQL 如何判斷 binlog 是否完整？statement 格式的 binlog, 最後會有 commit;row 格式的, 最後會有一個 XID event 以下的 MySQL example 中, 比較各種 count() 的效能以及行為？ Examplecount(*)count(1)count(id)count(columnName) Answercount(*) 會 scan 整張表, 但不取值, server 層會對於每一行的回傳累加 1, 屬於 MySQL 特別優化的選項, 優先選擇count(1) 會 scan 整張表, 但不取值, server 層會對於每一行的回傳累加 1count(id) 會 scan 整張表, 取 id, server 層會對於每一行的回傳累加 1count(columnName) 會 scan 整張表, 如果是 not null, 會取出每一行, 判斷不為 null, 累加, 若為 nullable, 則取出每一行, 並且判斷不為 null 才累加, 效率最差 MySQL 中, count(*) 跟 count(columnName) 差異是？count(*) 會回傳總行數, 而 count(columnName) 會回傳該 column 不為 null 的 count MySQL 中, 如果我要統計一個表上總共有幾列, 但該表上的 row 數量很多, 有什麼好解法？可以獨立建立另外一張表, 每當該表上面有新增, 就在這張表上 + 1, 跑 transaction, 並且如果高併發的話, 可以分成多行, 在取多行的加總, 以減少 dead lock detection 的產生 MySQL 中, show table status 取得的 row 準確嗎？不準, 誤差可能高達 40~50% MySQL 中, 若要使用 count(), 使用哪個語句會有優化過？ 如何優化？count(*), 會掃描最小的索引樹 MySQL 中, 如果機器規格很高, 但 redo log 設得很小, 那會發生什麼事？因為 redo log 很快就被寫滿, 會被迫一直進入停止 update, 推進 checkpoint, 要 flush page 的狀態, 造成 disk 壓力明明不大, 但性能卻週期性的下降 MySQL 中, 重建表有哪兩種推薦的方式？alter table t engine = InnoDBgh-ost 以下的 MySQL example code 的意思是？ Exampleoptimize table t Answerrecreate table and analyze it 以下的 MySQL example code 的意思是？ Examplealter table t engine = InnoDB Answer會重建一個表, 實際上是 alter table t engine=innodb,ALGORITHM=copy; MySQL 中, inplace 跟 online 是否同意思？不同, 可以有 online 效果的肯定是 inplace algorithm, 但 inplace algorithm 不見得可以 online, 比如 full-text index, spatial index MySQL 中, 如果我有一個 1TB 的 table, disk 空間為 1.2TB, 那我能不能做一個 DDL 呢？不行, 因為 tmp_file 也會佔空間 MySQL 中, inplace 的意思是？整個 DDL 過程都是在 innoDB 內部完成的, 速度較快, 就像是原地操作 MySQL 中, 若要比較保險的重建表, 可以使用哪個工具？gh-ost 以下的 MySQL image 中, 在 alter 語句啟動後, MDL Write lock 會立即降級為 MDL Read lock, 那為什麼不乾脆解鎖呢？ Image Answer要避免在 alter 過程中, 有其他 DDL 插入 以下的 MySQL image 中, Online DDL 是如何實現的？ Image Answer在 alter 語句啟動時需先拿到 MDL Write lock, 拿到後就會立即降級為 MDL Read lock, 所以不影響 DML 的操作 以下的 MySQL image 的意思是？ Image Answer state 1 代表舊表, 佈滿空洞 state 2 會建立一個 tmp file, 當執行 alter 語句時會需要 MDL Write lock, 拿到後在複製資料之前會降級為 MDL Read lock, 以實現 online DDL, 然後開始將資料從舊表複製到 tmp file, 於此同時進來的 query, 會被記在 row log 當中 state 3 資料複製完畢後, 會將 row log 中的資料一併複製到 tmp file state 4 將 tmp file 取代舊表 MySQL 中, 如何才能釋放刪除資料後的空洞？重建表 以下的 MySQL image 的意思是？ Image Answer當數據頁原本是滿的, 從中插入, 會申請一個新的數據頁, 並分裂成兩個數據頁, 產生空洞 MySQL 中, 如果使用 delete 把所有的資料都刪了, 資料檔案的大小會縮小嗎？不會, 只會變得可復用而已 以下的 MySQL example code 的意思是？ ExampleSET @wsum := 0;SELECT t1.*FROM ( SELECT m.*, (@wsum := @wsum + m.weight) AS cumulative_weight FROM test1 m ORDER BY m.turn ASC) t1WHERE t1.cumulative_weight &lt;= 1000ORDER BY turn DESCLIMIT 1; Answer設一個變數, 讓變數在 table 中累加某個值, 進而可取得 累加到某個點 的所有 row 以下的 MySQL image 中, 如果刪掉 R4, 然後插入一個 id = 800 的 row, 可以復用原本這一行的空間嗎？ Image Answer不行 以下的 MySQL image 中, 如果刪掉 R4, 然後插入一個 id = 400 的 row, 可以復用原本這一行的空間嗎？ Image Answer可以 以下的 MySQL image 中, 如果刪掉 R4, 那硬碟文件會縮小嗎? Image Answer不會, 只會標記為可復用 MySQL 中, innodb_file_per_table 參數建議設置為？on, 這樣當 drop table 就可以刪掉空間, 反之因為是儲存在共享空間, 刪掉空間也不會回收 以下的 MySQL example code 的意思是？ Exampleinnodb_file_per_table Answer決定表數據要儲存在共享空間, 還是單獨 .idb 結尾的檔案 MySQL 中, 當 checkpoint 推進時, 如何判斷要 flush 的 page 是乾淨的還是髒的？當 flush 時, 會取得最舊的 LSN, 對比內存中的 page, 要是該 LSN 不存在於內存, 代表刷過了, 即可跳過 MySQL 中, 當 checkpoint 推進時, 如何選擇要 flush 的 page?每個 buffer pool instance 都會有一個 flush list, 每次寫 redo log 都會有一個 LSN, 會 flush LSN 最小的 page, 代表最老的 page MySQL 中, 不建議讓髒頁比例到達幾%?75 % MySQL 中, 什麼時候會推進 redo log 的 checkpoint?當 redo log 快寫滿時 MySQL 中, 當因為內存不足必須要 flush dirty page 時, 會推進 redo log 的 checkpoint 嗎？不會 MySQL 中, flush, purge, merge, 分別代表的意思是？ flush: 刷髒頁 purge: 清 undo log merge: sync change buffer MySQL 中, 什麼是 LSN?log sequence number MySQL 中, redo log 寫滿, 必須得 flush dirty page, 這種情況是正常的嗎？不正常, 應該盡量避免, 因為出現這種情況時, 整個系統都無法再接受更新 MySQL redo log 中, 當內存不夠用時, 需要淘汰資料庫的 page, 那如果 page is dirty, 是什麼原因一定要 flush redo log, 而不能直接釋放 page, 當下次讀該 page 的時候, 再從 redo log 去拿正確資料？效能考量, 每次釋放 page 時都 flush 可以確保 page 有兩種狀態 如果內存中存在該 page, 那該 page 的資料一定是最新的 如果內存中不存在該 page, 該 disk 上的資料一定是最新的 MySQL 中的 innodb_flush_neighbors 建議怎麼設？如果是傳統 disk, 設為 1, 若是 SSD, 設為 0 MySQL 中的 innodb_flush_neighbors 的意思？當 flush dirty page 時, 若相鄰的 page 也是 dirty page, 就一起 flush, 會一直連坐下去, 直到相鄰的 page 非 dirty MySQL 中的 innodb_io_capacity 建議設為？機器的 IOPS 以下的 fil command 的意思是？ Examplefio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest Answer取得機器 IOPS 數值 什麼是 IOPS?Input/Output Operations Per Second MySQL 中, 當要讀入一個 page, 但 buffer pool 已經滿了, 會怎麼做？會將最久沒有使用的 page 淘汰, 若是乾淨的則直接釋放, 若是髒的則 flush 後釋放 MySQL 中, buffer pool 中的內存頁, 通常有哪三種狀態？ 還未使用 已使用, 是乾淨的 已使用, 是髒的 MySQL 中, 通常有哪四種情況會需要 flush dirty pape? redo log 寫滿了 內存用光了 空閒時 關機時 MySQL 中, 通常什麼情況會造成 MySQL 頓一下, query 速度忽然變得極慢？flush dirty page 以下的 MySQL image 中, 為什麼會選錯索引？ Example Answer因為 session A 還沒有提交前, session B 是無法刪除資料的, 就算刪除了, undo log 也會留著, 索引會有兩份, 一份是 session B delete 語法提交前, 一份是提交後 MySQL 中, 若使用倒序或 crc hash 來儲存, 有何共通點？都不支援 range scan MySQL 中, 若使用倒序或 crc hash 來儲存, 在查詢效率差異為何？hash 雖說還是可能會重複, 但機率並不高, 反觀 prefix index 重複機率較高, 因此效率上 hash 勝出 MySQL 中, 若使用倒序或 crc hash 來儲存, 在 CPU cost 上差異為何？reverse cost 會小一些 MySQL 中, 若使用倒序或 crc hash 來儲存, 在儲存空間上差異為何？倒序不需額外儲存空間, 但考量到前綴的字數需要一定數量來區分, 所以差異並不大 以下的 MySQL example code 的意思是？ Examplealter table t add id_card_crc int unsigned, add index(id_card_crc);select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27; Answer額外建立一個 column, 在 insert 時使用 crc32 hash id_card, 並存到這個 column, 這樣在 select 時就可以利用這個 column 上的 index 來 query id_card, 但因為 crc32() 可能會有重複的 hashed string, 因此要再比對 id_card 是否一致 以下的 MySQL example code 的意思是？ Exampleselect field_list from t where id_card = reverse(&#x27;input_id_card_string&#x27;); Answer身分證很有可能前面好幾個字母都是相同的, 可以採用倒序儲存, 並配合 prefix index MySQL 中, prefix index 是否支援 covered index?不支援 以下的 MySQL example code 的用意是？ Examplemysql&gt; select count(distinct email) as L from SUser;mysql&gt; select count(distinct left(email,4)）as L4, count(distinct left(email,5)）as L5, count(distinct left(email,6)）as L6, count(distinct left(email,7)）as L7,from SUser; Answer判斷不同字數的 prefix index 與實際上的不同值數量差距多少, 以決定最佳的 prefix index 長度 MySQL 中, 有哪幾種方法可以修正 MySQL 選錯索引？ 使用 force index 語法 修改語句 使用 analyze 重新計算索引 刪除不必要索引 以下的 MySQL example code 的意思是？ Exampleanalyze table t Answer重新統計索引 以下的 MySQL example code 的意思是？ Exampleinnodb_stats_persistent Answer決定是否將索引統計存在 disk 或 memoryon 的話, N = 20, M = 10off 的話, N = 8, M = 16當變更行數超過 1/M 時, 會觸發重新索引統計 MySQL 中, 基數 (Cardinality) 如何求得？取 n 個 page, 分別計算每個 page 中的不同值數量, 再將所有 page 的不值相加, 再除以 n, 最後乘以總 page 數量 MySQL 中, 何謂基數 (Cardinality)？索引中值不同的數量, 數量越高, 基數越大, 索引的效果也越好, 若是數量很低, 代表索引中幾乎每個值都一樣, 那基數就低, 效果就不好 MySQL 中, insert 時, 可以使用 change buffer 嗎？primary key 不行, 但 secondary index 可以 MySQL 中, .idb 檔案是？對應表數據空間的對應檔案 MySQL 中, ibdata1 檔案是？系統表空間的對應檔案 MySQL 中, redo log 與 change buffer 主要節省的效益分別是？redo log: 將隨機寫 disk I/O, 節省為順序 I/Ochange buffer: 隨機讀 disk I/O 消耗 以下的 MySQL image 的意思是？ Image Answer當讀 page 1 時, 直接從內存返回當讀 page 2 時, 從 disk 將 page 2 讀入內存, 並 merge change buffer 的紀錄, 返回 以下的 MySQL image 的意思是？ Image Answerupdate 的資料處於內存中, 直接 update 內存update 的資料所在 page2 不處於內存中, 直接在內存中的 change buffer 寫下紀錄兩上面兩個 update 寫入 redo log MySQL 中, 如果有一個情境, 所有的 update 結束後都會伴隨著 select, 那建議關掉哪個設定？ 為什麼？change buffer因為 change buffer 會在每次 select 時都去 merge 原 page, 產生 I/O cost, 若能在 select 與 select 之間寫入動作越多次的話才能真正發揮 change buffer 效果, 若是每次 update 結束就 select 就相當於每次都 merge, 如此一來便失去 change buffer 的意義 MySQL 中, 什麼樣的情境對 change buffer 來說是成效最大的？寫多讀少 MySQL 中, 為什麼唯一索引在寫入時的 cost 比一般索引大？一般索引可以使用 change buffer, 唯一索引需要將 page 讀入內存, 這個動作需要訪問隨機 I/O, 因此成本很高 以下的 MySQL image 中, 如果要插入 (4,400), 如果該 page 不在內存中, 一般索引與唯一索引分別的操作是? Image Answer一般： 將更新紀錄在 change buffer, 結束唯一： 將 page 讀入內存, 找到 3-5, 判斷有無衝突, 插入, 結束 以下的 MySQL image 中, 如果要插入 (4,400), 如果該 page 已經在內存中, 一般索引與唯一索引分別的操作是? Image Answer一般： 找到 3-5 之間的位置, 插入, 結束唯一： 找到 3-5 之間的位置, 判斷有無重複, 插入, 結束 MySQL 中, 當 innodb_change_buffer_max_size 設為 50 時, 意思是？change buffer 的大小最多只能佔用 buffer pool 的 50% 以下的 MySQL example code 的意思是？ Exampleinnodb_change_buffer_max_size Answer設定 change buffer 的 size MySQL 中, 唯一索引可以使用 change buffer 嗎？ 為什麼？不行, 因為寫入前都要確定該筆資料不存在於資料庫已達到 unique, 所以每次都會將該 page 讀入內存 MySQL 中, change buffer 何時會觸發 merge?訪問該 page定時 mergedatabase shutdown MySQL 中, change buffer 與原 page sync 的過程稱為？merge MySQL 中, 當 update 時, 如果該 page 不處於內存當中, 會如何？寫入 change buffer, 並在下次查詢時, 將該筆資料所在的 page 讀入內存, 並執行 change buffer 中與該筆資料有關的相關操作 MySQL 中, 當 update 時, 如果該 page 已經處於內存當中, 會如何？直接更新 MySQL 中, change buffer 會被持久化嗎？會 MySQL 中, 如果說我的語法是 select id from T where k=5, 那一般索引與唯一索引的查詢差異在於？一般索引查到第一筆 k=5 的資料後, 會繼續往下查找, 直到查到 k != 5 才會停下唯一索引查到第一筆 k=5 的資料後就會停下 MySQL 中, 如果一個 column 已在 APP 層設置 unique 邏輯, 一般索引與唯一索引, 哪個效能較好？ 為什麼？一般索引當讀資料時, 是將整個 page 讀入內存, 而當已經找到第一筆資料時, 代表該筆資料所處的 page 已經被讀入內存了, 這時多讀一次 (一般索引) 的 cost 幾乎微乎其微當 update 時, 一般索引可以使用 change buffer, 但唯一索引不行, 所以唯一索引會多了 I/O cost, 主要效能差異在這 MySQL 中, 如果一個 column 已在 APP 層設置 unique 邏輯, 那 index 該選擇一般索引還是唯一索引？一般索引 以下的 MySQL example code 的意思是？ Exampleupdate t set num=num-200 where num &gt;= 200; Answer為避免 race condition, 加了 where num = 200, 因為 transaction 中, update 會使用當前讀 (current read), 因此會判斷 num = 200, 若不是, 代表庫存不足, 直接報錯 以下的 MySQL image 中, 若為 RC Isolation, transaction A, B 的 select 結果分別是多少, 為什麼？ Image AnswerA: 2, 因為 trx B 尚未提交, 但 trx C 已提交, 所以 C 為可見, B 為不可見B: 3, 為當前版本, 且 trx C 已提交, 可見 MySQL 中, start transaction with consistent snapshot 在 RC Isolation 中, 有意義嗎？沒意義, 等同 start transaction, 因為 RC 是每個語句都會產生新的 view MySQL 中, RR Isolation 與 RC Isolation 的主要區別是？RR: 在 transaction 中使用同一個 viewRC: 每個語句都會產生一個新的 view MySQL 中, 在 transaction 中如何使 select 使用當前讀 (current read)?加鎖, share mode 或 exclusive mode 都可 MySQL 中, 當我在 transaction 中使用 atomic update, 為什麼不是 based on view 中的版本, 而是最新版本？因為 update 使用的是當前讀 (current read) MySQL 中, 何謂當前讀 (current read)？不讀 trx view 中的資料, 而是最新版本的資料 MySQL RR 中, 若 trx A 於 trx B 創建 view 之前提交, 那可見或不可見？可見 MySQL RR 中, 若 trx A 於 trx B 創建 view 之後才提交, 那可見或不可見？不可見 MySQL RR 中, 若 trx 版本未提交, 那可見或不可見？不可見 以下的 MySQL example image 中, transaction A 的結果是？ 為什麼？ Description: 系統內只有一個活躍 trx_id 99 transaction A, B, C 的版本分別是 100, 101, 102 三個 transaction 開始前, (1,1) 這一行的 rwo trx_id 為 90 Image Answer為 1row (1,1) 的版本為 90, 小於 [99,100] 的低水位, 表示已提交, 可見row (1,2) 的版本為 102, 大於 [99,100] 的高水位, 表示 transaction A 創建之後才建立的 trx, 不可見row (1,3) 的版本為 101, 大於等於 [99,100] 的高水位, 表示 transaction A 創建之後才建立的 trx, 不可見 以下的 MySQL example picture 中, 未開始的事務如何定義？ Example Answer當前系統已產生的最大 trx_id + 1 以上的 trx_id 都視為未開始 以下的 MySQL example picture 中, 已提交的事務如何定義？ Example Answer由當前事務更新, 或許 trx_id 不存在於未提交事務集合, 並且低於高水位, 代表已提交 以下的 MySQL example picture 中, 未提交事務集合的內容是？ Example Answer所有當前活躍的 trx_id array 以下的 MySQL example picture 中, 高水位的意思是？ Example Answer系統已產生的 trx_id 中, 最大的那一個 + 1 以下的 MySQL example picture 中, 低水位的意思是？ Example Answer未提交的 trx_id array 中, trx_id 較小的那一個 以下的 MySQL example image 的意思是？ Example AnswerMySQL MVCC 的多版本新的 transaction 需要跟 MySQL 的 transaction 系統申請一個自增 id每個 row 依據被不同的 transaction update 過, 會有不同的版本, 並持有以下的值被 update 後的值update 的 transaction id版本之間的綠色箭頭稱為 undo log, 代表邏輯的回朔上個版本, 非物理性 以下的 MySQL example schema and image 中, k 在 transaction A 以及 B 分別值是多少？ Schemamysql&gt; CREATE TABLE `t` ( `id` int(11) NOT NULL, `k` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB;insert into t(id, k) values(1,1),(2,2); Image Answertransaction B 中, k = 3transaction A 中, k = 1因為 MySQL 的 RR 只對 read 有效, 對 update 無效 以下的 MySQL example code 的意思是？ Examplestart transaction with consistent snapshot Answer當執行 transaction begin 時, 並不會立即開始 transaction, 第一句操作 DB 的語法才是 transaction 的開始處, 若要指定開始處, 可使用 example code 語法 MySQL 中, RR 跟 RC Isolation 的行鎖差異是？RC 是逐行掃描逐行鎖, 若條件不對會立即釋放RR 是逐行掃描逐行鎖, 會等到最終提交 transaction 時才全部釋放 以下的 MySQL example code 中, 如果 name 沒加索引, 會鎖住哪些 row? Exampleupdate t set t.name=&#x27;abc&#x27; where t.name=&#x27;cde&#x27; limit 1 Answer會先查詢再更新, select * from t where name = &quot;abc&quot; limit 1 for update會從開始掃描那一行開始鎖, 直到找到 name=’cde’, 掃過的行都會鎖住 以下的 MySQL example code 中, 如果 name 沒加索引, 會鎖住哪些 row? Exampleupdate t set t.name=&#x27;abc&#x27; where t.name=&#x27;cde&#x27; Answer會鎖住全表 MySQL 中, 當我使用 mysqldump –single-transaction 時, 如果這時從 master 傳來一個 DDL 的 binlog, 如下 example, 假如是時刻 4 傳來的, 會發生什麼事？ ExampleQ1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;Q2:START TRANSACTION WITH CONSISTENT SNAPSHOT；/* other tables */Q3:SAVEPOINT sp;/* 时刻 1 */Q4:show create table `t1`;/* 时刻 2 */Q5:SELECT * FROM `t1`;/* 时刻 3 */Q6:ROLLBACK TO SAVEPOINT sp;/* 时刻 4 *//* other tables */ Answer此時 read MDL 已經釋放, 沒有影響, 備份為修改前的表結構 MySQL 中, 當我使用 mysqldump –single-transaction 時, 如果這時從 master 傳來一個 DDL 的 binlog, 如下 example, 假如是時刻 2 到時刻 3 之間傳來的, 會發生什麼事？ ExampleQ1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;Q2:START TRANSACTION WITH CONSISTENT SNAPSHOT；/* other tables */Q3:SAVEPOINT sp;/* 时刻 1 */Q4:show create table `t1`;/* 时刻 2 */Q5:SELECT * FROM `t1`;/* 时刻 3 */Q6:ROLLBACK TO SAVEPOINT sp;/* 时刻 4 *//* other tables */ Answer此時因為 Q5 query 已經拿到 read MDL, 所以 DDL 會被 block, 直到 Q6 釋放 read MDL 之後才會執行, 會造成主從延遲備份的會是修改前的表結構 MySQL 中, 當我使用 mysqldump –single-transaction 時, 如果這時從 master 傳來一個 DDL 的 binlog, 如下 example, 假如是時刻 2 傳來的, 會發生什麼事？ ExampleQ1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;Q2:START TRANSACTION WITH CONSISTENT SNAPSHOT；/* other tables */Q3:SAVEPOINT sp;/* 时刻 1 */Q4:show create table `t1`;/* 时刻 2 */Q5:SELECT * FROM `t1`;/* 时刻 3 */Q6:ROLLBACK TO SAVEPOINT sp;/* 时刻 4 *//* other tables */ Answer會在 Q5 取得資料時, 報錯 Table definition has changed, please retry transaction, 終止 mysqldump MySQL 中, 當我使用 mysqldump –single-transaction 時, 如果這時從 master 傳來一個 DDL 的 binlog, 如下 example, 假如是時刻 1 傳來的, 會發生什麼事？ ExampleQ1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;Q2:START TRANSACTION WITH CONSISTENT SNAPSHOT；/* other tables */Q3:SAVEPOINT sp;/* 时刻 1 */Q4:show create table `t1`;/* 时刻 2 */Q5:SELECT * FROM `t1`;/* 时刻 3 */Q6:ROLLBACK TO SAVEPOINT sp;/* 时刻 4 *//* other tables */ Answermysqldump 尚未取得表結構, 所以沒有影響, 備份後會是 DDL 修改後的表結構 MySQL 中, 將電影院的餘額分成 10 行, 10 行的加總等於電影院的餘額, 為什麼要這樣設計？適用於高併發場景, 當高併發會去更新同一行時, 會造成大量死鎖以致於吃光效能, 所以分成多行來更新, 降低死鎖發生機率 MySQL 中, 在高併發下, 若是關閉死鎖監測, 會出現什麼問題？因為關閉了 dead lock detection, 當鎖住時不會自動 rollback, 所以會出現大量的超時 MySQL 中, 偵測死鎖的代價是多少？O(n的二次方), CPU 使用率極高 MySQL 中, 為什麼不可把 innodb_lock_wait_timeout 參數設定成 1s 來避免死鎖？因為很多時候不見得是死鎖, 可能只是單純的鎖等待, 這樣會造成很多誤傷 MySQL 中, innodb_deadlock_detect 是什麼設置？當遇到 dead lock 時, transaction row 數量比較少的那一個會主動釋放 lock MySQL 中, innodb_lock_wait_timeout 是什麼設置？當遇到 lock 衝突時, 要等待多久 MySQL 中, 根據二階段鎖的行為, 以下三個動作, 哪一個該放最後, 為什麼？ Example從顧客 A 帳戶餘額扣錢在影院 B 的帳戶餘額加錢紀錄交易日誌 Answer在影院 B 的帳戶餘額加錢要放最後, 因為可能會有多個 session 來更新這筆紀錄, 因此最可能發生衝突, 放在越後面, 佔用鎖的時間越短 MySQL 中, 如果要鎖多行, 要把可能造成最大影響的鎖往後放還是往前放？往後放 以下的 MySQL image 的的意思是？ Image Answertransaction B 會被 block, 直到 transaction A 結束後釋放鎖 MySQL 行鎖中, 何謂二階段鎖協議？在 transaction 中, 有需要時加鎖, 但會等到 transaction 結束時才釋放 以下的 MySQL example code 的意思是？ ExampleALTER TABLE tbl_name NOWAIT add column ...ALTER TABLE tbl_name WAIT N add column ... Answer使用 DDL 時, 指定若是拿不到鎖就不等待, 或是等待指定的時間就放棄, 以防止鎖死 MySQL 中, 什麼是 FTWRL?flush table with read lock 以下的 MySQL image 的意思是？ Image Answersession A 為 DML, MySQL 自動施加 MDL readsession B 為 DML, MySQL 自動施加 MDL read, 讀讀共享session C 為 DDL, 嘗試取得 MDL write, 但 MDL read write 互斥, 因此 block, 需等 MDL read 釋放session D 為 DML, 需先拿到 MDL read, 因為 MDL write priority 高於 MDL read, 因此這排在 session C MDL write 之後, 需等待 MDL write 取得並釋放 至此, 之後的 session 都將被 block, 直到 session A, B MDL read 釋放, 接著是 session C 執行, 之後才會解除 block MySQL 中, read MDL 會影響 write MDL 嗎？會, 讀寫互斥 MySQL 中, write MDL 會影響 write MDL 嗎？會, 寫寫互斥 MySQL 中, read MDL 會影響 DDL 嗎？會, 當 read MDL 存在時, 無法進行 DDL MySQL 中, write MDL 會影響 DDL 嗎？會, 只有拿到 MDL 的 connection 可以操作 DDL MySQL 中, read MDL 會影響 read MDL 嗎？不會, 讀讀共享 MySQL 中, read MDL 會影響 DML 嗎？不會 MySQL 中, MDL read, write 什麼時候會被使用？ read, 任何 DML 時會被加上 write, DDL 時會被加上 MySQL 中, 假如 connection A 執行 lock tables t1 read, t2 write, 那 connection A 對 t1, t2 的權限分別為何？t1, 可讀t2, 可讀可寫 MySQL 中, 假如 connection A 執行 lock tables t1 read, t2 write, 那 connection B 對 t1, t2 的權限分別為何？t1, 可讀不可寫t2, 不可讀不可寫 MySQL 中, 什麼是 MDL？meta data lock, 元數據鎖 MySQL 中, 表級鎖又分為哪兩種？表鎖, 元數據鎖 MySQL 中, 當進行全局備份時, 為何建議使用 FTWRL 而不使用 set global readonly=true? readonly variable 的值會被用來在很多地方進行判斷, 例如判斷主從庫, 影響重大 當使用 FTWRL, 如果 client side 斷開連線時, 會自動釋放 lock, 但 readonly 不會, 會一直鎖住 既然可以使用 mysqldump –single-transaction 來備份, 那為什麼還會有 FTWRL 需求？因為當有些 table 不支援 transaction 時, 就只能使用 FTWRL 來備份了 使用 mysqldump 備份時, 更新功能會受到影響嗎？不會, 但前提是務必要加上 --single-transaction 參數 使用 mysqldump 備份時, 可加上哪個參數, 確保 view 一致？--single-transaction 以下的 MySQL example image 的意思是？ Example Answer備份時未上鎖, 先備份 user account, 完成後, user 買了一個課程, user course 資料庫更新, 然後在備份 user course, 備份的結果變成, user 錢沒扣, 但卻多了一個課程 MySQL 中, 當在從庫上 FTWRK 時, 會產生什麼狀況？從庫無法執行同步過來的 binlog, 會造成主從延遲, 在讀寫分離的場景會受影響 MySQL 中, 當在主庫上 FTWRK 時, 會產生什麼狀況？備份期間無法更新, 會造成業務停擺 以下的 MySQL example code, 通常會用在什麼情境？ ExampleFlush tables with read lock Answer做全庫邏輯備份 以下的 MySQL example code 的意思是？ ExampleFlush tables with read lock Answer讓整個資料庫處於只讀狀態 (上讀鎖) 以下的 MySQL example code 中, 哪個 index 可以省略？ Example# SchemaCREATE TABLE `geek` ( `a` int(11) NOT NULL, `b` int(11) NOT NULL, `c` int(11) NOT NULL, `d` int(11) NOT NULL, PRIMARY KEY (`a`,`b`), KEY `c` (`c`), KEY `ca` (`c`,`a`), KEY `cb` (`c`,`b`)) ENGINE=InnoDB;# 需求select * from geek where c=N order by a limit 1;select * from geek where c=N order by b limit 1; Answerca 可拿掉index c = 聯合索引 (c,a,b)index cb = 聯合索引 (c,b,a)index ca = 聯合索引 (c,a,b) 跟 index c 重複了 MySQL 中, 每一個單獨的 index, 其實都跟哪一個 key 構成聯合索引？primary key MySQL 中, 如果一支 index API, 有多個查詢條件, 並且每個查詢條件都可能不帶 (不帶即不查), 但表的資料量又非常大, 那該怎麼辦？可評估業務需求用得最多的 query 來建立 2 個聯合索引, 剩下低頻的建立單獨的索引, 前端分別呼叫這兩個索引後, 在前端取交集 MySQL 中, 如果一張 table 中有 a 與 b 兩個單獨的索引, 假設 query 為 `where a = xx and b = yy, 那優化氣會先選擇哪個索引, 還是兩個都走? 只選 a, 然後用 b 過濾 只選 b, 然後用 a 過濾 選 a 和 b, 然後兩個單獨跑出來的結果取交集 MySQL 中, 觸發覆蓋索引的條件是?當查詢的條件與返回的字段都能被一個非主鍵索引所覆蓋, 則觸發覆蓋索引 MySQL 中, 什麼是 ICP?Index Condition Pushdown 以下的 MySQL example code 的意思是？ Examplealter table T engine=InnoDB Answer觸發 MYSQL 重建該表, 進行碎片化整理 以下的 MySQL example code, 與 images 的意思是？ Exampleselect * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1; image1 image2 Answer圖 1 為無索引下推 (index condition pushdown), 圖 2 為索引下推索引下推中, 當索引中存在 query condition 的資料時, 會在索引 B+ 樹中直接比對, 若條件不符就不必再回表繼續比對了, 若條件相符, 而索引中又不存在 condition query 資料, 那才需要回表繼續比對無索引下推, 不管索引中是否存在 query condition 需要的資料, 都會回表比對 MySQL 中, 如果 a 跟 b 欄位都有各自的查詢需求, 那聯合索引該使用 (a,b), b, 還是 (b,a) a?可以從空間角度來看, 看 a 跟 b 哪個大, 如果 b 大, 則選 (b,a), a, 因為這樣 b 只需出現一次, 反之則為 (a,b), b MySQL 中, 在建立聯合索引時, 如何安排索引的順序？如果可以通過調整索引的順序而減少索引的數量, 那這個順序優先考慮 MySQL 中, 何謂最左前綴原則？當有一個聯合索引 (compound index), 假設為 (name, age), 那當 query 的 condition, name 為第一項是, 就可以使用這一個聯合索引, 因為索引中, 最左的索引是 name MySQL 中, 何謂覆蓋索引 (covered index)？當索引上已經含有 query 所要 select 的資訊, 那就不需回表, 直接 return MySQL 中, innodb_log_file_size 的意思是？redo log 的 circular file size, 若一個區塊寫滿就會 flush 到 disk 中, 所以設越大自然越久才需要寫回 disk, 若在 write loading 非常高的情境, 可設為 500M, 預設是 128M MySQL 中, 當使用 innodb_flush_log_at_timeout 來加快 write 負荷很重的 DB 時, 利與弊？代表多久將 redo log 寫到 disk 中, 設得越長, write 的速度越快, 但一旦 server 掛點, 遺失的資料也越多 MySQL 中, 當使用 innodb_flush_log_at_trx_commit 來加快 write 負荷很重的 DB 時, 利與弊？預設是 1, 若設為 2 可大幅降低 insert 的時間, 但若 server 掛點, 因為資料寫入 disk 的頻率變低了, 所以也會遺失比較多的資料 MySQL 中, 當一個 table 中有 text 欄位, 且該欄位資料龐大, 建議怎麼做？移到一個獨立的 table, 避免 full table scan 時掃到 下面的 image 中, 如果 SQL query 是 select ID from T where k between 3 and 5, 那會回表嗎？ 為什麼？ Image: Answer:不會, 因為在 k index 這個 B+ 樹上, 已含有 ID, 所以直接給就行, 不需回表, 又稱為覆蓋索引 MySQL 中, 當我在 transaction 中使用 DDL, 會發生什麼事？會自動 commit 以下的 MySQL example image 中, 如果我的語法是 select * from T where k between 3 and 5, 那共會搜尋 index 幾次, 回表幾次？ Example Answer搜尋索引三次, 回表兩次找 k=3, 取得 id=300, 回表取 R3找 k=5, 取得 id=500, 回表取 R4找 k=6, 不符合條件, 循環終止 MySQL 中, 在 page 內如何定位行？？通過有序數組, 二分法 MySQL 中, 索引樹的葉子節點, 存什麼？存著頁, 頁裏存行 MySQL 中, 最小的儲存單位是？page MySQL 中, 默認 page 大小為？16 kb MySQL 中, 默認 pointer 大小為？6 bytes MySQL 中, 若調整 page size, page 大跟小有什麼影響？page 越大, 則可容納的 key 越多, 則載入內存與搜尋 MySQL 中, 為什麼 key 的大小會影響到 N 叉樹的 N？索引 N 叉樹中, 非葉子節點的通常儲存 key 以及 pointer, pointer 固定為 6 bytes, 而 key 的大小不定, 假設為 10 bytes, 而一個 page 的默認大小為 16kb, 那該 page 就可以容納 1024 個 key, 則該 B+ 樹的 N 為 1024 MySQL 中, 若要調整 N 叉樹的 N, 有哪兩種方向？ 調整 key 的大小 調整 page_size MySQL 中, 刪除連線, 推薦使用什麼工具？Percona pt-kill MySQL 中, 建議將 innodb_undo_tablespaces 设置成 2, 或更大的值, 為什麼？如果出現長事務導致回滾過大, 方便清理 MySQL 中, 如果要避免長事務, 可以監控哪個表？information_schema.Innodb_trx MySQL 中, SET MAX_EXECUTION_TIME 的意思以及用途是？設定 SQL 語句最長的執行時間, 以確保不會有語句執行意外太長的時間 資料庫中, 有什麼場景不使用 auto increment primary key 的呢？KV 場景, 像是 redis MySQL 中, primary key 長度越小, 二級索引佔據的空間越小, 為什麼？因為二級索引儲存著 primary key MySQL 中, 使用有業務邏輯的 string 當作 primary key, 為何成本相對較高？因為不保證有序插入, 可能會造成葉節點數據分裂 MySQL 中, auto increment 對於效能上有什麼幫助？每次都固定 id + 1, 故不需要對 B+ 數進行插入動作, 只會用到追加, 不涉及挪動其他紀錄, 也不會觸發葉子節點分裂 MySQL 中, 何謂頁合併?當相鄰的兩個數據頁有資料被刪除, 造成利用率很低, 這時會合併兩個數據頁, 又稱為頁合併 MySQL 中, 何謂頁分裂?當前的數據頁已滿, 但又有塞東西進來的需求, 所以必須要將部分的數據移動到新的數據頁 下圖中, 如果我要插入 ID 400, 但位於 R5 所在的數據頁已經滿了, 那會發生什麼事？？ Example Answer申請一個新的數據頁, 挪動部分數據過去, 又稱為頁分裂 MySQL 中, 非 primary key index 又稱為？secondary index MySQL 中, primary key index 又稱為？？clustered index 以下的 MySQL example image 的意思是？ Example Answer兩顆 B+樹, primary key (ID) 這棵樹, 一個 ID 對應到整個 row, k index 這棵樹, k 值對應到相對應的 ID primary key 資料結構中, N 叉數, 假設 N 為 1200, 那樹高三層, 會有幾筆資料？N 的三次方 資料結構中, 二元樹的搜索效率最好, 但為何資料庫卻不採用二元樹這種資料結構？因為索引不只在內存, 更在硬碟中, 而每棵樹的查找都相當於訪問一個 block, 換言之, 資料越多, 樹越高, 訪問的 block 越多, 這個查詢效率並不友善 (訪問太多硬碟 block) 以下的數據結構, query 與 insert 的 complexity 是多少？ Example AnswerO(log(N)) 以下的數據結構, 適合怎樣的情境？ Example Answer有序數組較適合靜態引擎, 即不太會更動的資料庫 以下的數據結構, 劣勢在於？ Example Answer為了維持有序, 所以 insert 會增加額外的 cost 使其維持有序, insert 資料效率差 以下的數據結構, 優勢在於？ Example Answer查詢, 因為有序, 可使用二分法, 區間查詢效率也很好 以下的 MySQL example picture, 是怎樣的數據結構？ Example Answer有序數組 MySQL hash 索引只適用於什麼樣的查詢？等值查詢, 比如 Memcached 或 NoSQL, 因為其 hash value 並無順序性 以下的 hash data structure 索引在區間查詢非常慢, 原因為何？ Example Answer因為 key 的 hash 並無順序性, 所以若要查找區間, 等於全表掃描 以下的 data structure, hash 的值是有順序性的嗎？ Example Answer沒有 以下的 picture 的意思是？ Example AnswerHash 索引, 將 key 透過 hash method 得到一個 hash 值, 將 value 放到一個數組中, 而前面得到的 hash 值, 就是這個 value 在數組中的 key, 如果 hash 值重複, 則對應的 value 會構成一個 linked list, 所以精妙的 hash method 會讓重複機率降低 MySQL 中, 如果我要使用連續的 transaction, 但我想省略 begin 來節省一次的連線, 那可以怎麼做？使用 commit work and chain 語法 以下的 MySQL example code 的意思是？ Exampleselect * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))&gt;60 Answer查詢超過 60 秒的長事務 以下的 MySQL example code 的意思是？ Exampleset autocommit=0 Answer代表關閉自動 transaction 提交, 也就是說你執行一個最基本的 select, transaction 就開始了, 而且不會自動提交, 這就導致意外的長事務 MySQL 中, 長事務跟 undo log 有什麼關係？transaction 越長, 所需要保留的 undo log 越多, 佔據的空間也越大 以下的 MySQL illustration 中, undo log 什麼時候會被刪除？ Example Answer當這個 undo log 不再被需要的時候, 例如沒有比這個 undo log 更早的 transaction read view 存在 以下的 MySQL illustration 中, read view 的意思是？ Example Answer代表不同時刻啟動的 transaction, 在 repeatable isolation 中, 不同的 transaction 會有不同的 read view 以下的 MySQL illustration 的意思是？ Example Answer在每一次的 update, 同時都會紀錄下 undo log, 供不同的 read view 使用 MySQL inno DB 中, 當提交一筆 update 時, 共會紀錄哪三種 log?redo log, undo log, binlog MySQL 中, 一天備份一次跟一週備份一次, 差別在哪？恢復時間的長短差別, 使用備份來復原的速度比使用 binlog 復原的速度還快 MySQL 中, binlog 的 row 模式, 是用什麼方式紀錄 log?紀錄 row 的內容, 記兩條, 更新前和更新後 MySQL 中, binlog 的 statement 模式, 是用什麼方式紀錄 log?紀錄 sql 語句 MySQL 中, binlog 又分為哪兩種模式？statementrow MySQL 中, redo log 是物理性, binlog 是邏輯性, 何謂物理性跟邏輯性？redo log 紀錄硬碟上數據的物理變化binlog 紀錄當時所執行的 sql 語法 MySQL 中, innodb_flush_log_at_trx_commit=1 這個參數的意思是？讓每次 redo log 都會持久化到 disk MySQL 中, 又不是常常會需要復原資料, 為何一定要使用二階段提交來確保 redo log 與 binlog 資料一致？因為當需要 scale 來增加系統 read 的 capacity 時, 便會用到 binlog 來實現增加新的 read database, 若資料不一致便無法實現這樣的操作 MySQL 中, 假設不使用二階段提交, 先寫 binlog, 再寫 redo log, 假設 binlog 寫完, 但 redo log 還沒寫完時就 crash 了, 會發生什麼事？由於 redo log 還沒寫, 也就是該 transaction 無效, 但 binlog 已寫了, 造成跟原庫的資料不一致 MySQL 中, 假設不使用二階段提交, 先寫 redo log, 再寫 binlog, 假設 redo log 寫完, 但 binlog 還沒寫完時就 crash 了, 會發生什麼事？server 重啟後, 因為 redo log 的 crash save 能力, 資料並沒有丟失, 但是如果使用 binlog 復原資料時, 便會少了那筆紀錄, 造成兩邊資料不一致 MySQL 中, redo log 與 binlog 的二階段提交主要的作用是？讓兩份 log 的邏輯一致 MySQL 中, binlog 跟 redo log 分別的主要作用是？ redo log: crash save (innoDB 層面) binlog: 恢復某個時間點的數據 MySQL 中, redo log 與 binlog 的寫入流程是？ 執行器先找引擎取 ID=2 這一行。 ID 是主鍵，引擎直接用樹搜索找到這一行。如果 ID=2 這一行所在的數據頁本來就在內存中，就直接返回給執行器；否則，需要先從磁盤讀入內存，然後再返回。 執行器拿到引擎給的行數據，把這個值加上 1，比如原來是 N，現在就是 N+1，得到新的一行數據，再調用引擎接口寫入這行新數據。 引擎將這行新數據更新到內存中，同時將這個更新操作記錄到 redo log 裡面，此時 redo log 處於 prepare 狀態。然後告知執行器執行完成了，隨時可以提交事務。 執行器生成這個操作的 binlog，並把 binlog 寫入磁盤。 執行器調用引擎的提交事務接口，引擎把剛剛寫入的 redo log 改成提交（commit）狀態，更新完成。重點： binlog 與 redo log 會有共同的 XID, 當 crash 重啟後, 如果有 prepare 又有 commit 的 redo log, 就直接提交, 如果有 prepare 但沒有 commit 的 redo log, 就拿著 XID 去尋找是否有該 binlog, 有則提交, 無則 rollback MySQL 中, redo log 和 binlog, 哪個是循環寫 哪個是追加寫？redo log 是循環寫, binlog 是追加寫 MySQL 中, redo log 和 binlog, 哪個是物理性, 哪個是邏輯性？redo log 是物理性, binlog 是邏輯性 MySQL redo log 中, 先寫日誌, 具體來說是寫到哪？ 跟實際更新硬碟的差別在於？也是寫到磁盤中, 但如果跟實際更新硬碟相比, 一個是順序 I/O, 一個是隨機 I/O, 差別在於隨機 I/O 有一個尋址的過程, cost 較高 MySQL 中, 任何 Storage Engine 都可使用, 屬於 Server 層的 Log 是哪一個？binlog MySQL 中, redo log 是屬於哪種儲存引擎專屬的？InnoDB MySQL 整體上來看, 其實就分為哪兩層？server, storage 以下的 MySQL redo log picture 中, check point 代表的意思是？ Example Answer當前要擦除的位置 以下的 MySQL redo log picture 中, write pos 代表的意思是？ Example Answer目前從此處開始寫入 以下的 MySQL redo log picture 中, 綠色部分代表的意思是？ Example Answer可以寫入的空白地方 MySQL 的 redo log 主要解決了什麼問題？減少 I/O 成本如果每一次的更新操作都需要寫進磁盤，然後磁盤也要找到對應的那條記錄，然後再更新，整個過程 IO 成本、查找成本都很高 MySQL 的 redo log 可以讓 MySQL server 就算臨時異常重啟, 之前提交的記錄也不會丟失, 這種能力稱為？crash-save關鍵點就是先寫日誌，再寫磁盤，也就是先寫粉板，等不忙的時候再寫賬本。 以下的 MySQL picture 是哪一種 log? Example Answerredo log MySQL 中, redo log 的大小是固定的, 對嗎？對的 MySQL 中, WAL 的全稱是？Write-Ahead Logging, 先寫日誌, 再寫磁盤 MySQL 8.0 還能使用查詢緩存嗎？不行 MySQL 查詢緩存, 什麼是 key, 什麼是 value?查詢語句為 key, 查詢結果為 value MySQL 中, 預設的 client 端與 server 端的連線是多久？8 小時 以下的 MySQL example picture 的意思是？ Example AnswerMySQL 的架構圖 MySQL 的 timestamp column, 從資料庫看, 顯示的時間是哪一個時區？預設為機器當下的時區, 因為 MySQL timezone variable 預設去抓 system timezone MySQL 的 timestamp column 會隨著系統的時區調整而變動, 為什麼？MySQL timestamp 會在底層儲存 UTC 的時間, 而從資料庫中看到的時間是根據當下機器的時區轉化過的, 所以 timestamp 欄位會隨著機器的時區不同而顯示該時區的時間, 所以調整 MySQL 的 timezone 是不會影響到資料準確度的 以下的 MySQL example code 的意思是？ ExampleSELECT `branch_managers`.`account`, `branch_managers`.`created_at`, `shops`.`name`FROM `branch_managers` INNER JOIN `shops` ON `branch_managers`.`shop_id` = `shops`.`id`WHERE AND `branch_managers`.`id` in( SELECT `id` FROM (( SELECT `id` FROM `branch_managers` WHERE match(account) against (&#x27;4k&#x27; IN boolean mode)) UNION ( SELECT `branch_managers`.`id` FROM `branch_managers` INNER JOIN `shops` ON `branch_managers`.`shop_id` = `shops`.`id` WHERE match(name) against (&#x27;4k&#x27; IN boolean mode))) AS `matches`) Answer無法直接使用 or where match 這樣子的 full text search 在多個表格, 因此統一取得 id, 在使用 where in 取得最後需要的資料使用 union 來取得兩個 select query 取得的不重複 id使用 derived table, 避免 where in 與 union query 之間的 dependency 以下的 MySQL example image 的意思是？ Example AnswerSELECT 時加上 exclusive lock, 雖然 weight column 並沒有 index, 但 MySQL 為了做到 RR Isolation, 會把整張 table lock 住 使用 MySQL 的 range lock 時, 要特別注意什麼事？range column 一定要有 index, 否則 MySQL 為了維持 RR Isolation, 會 lock 整張 table MySQL 的 range lock 如果 range column 並沒有 index, 那會有什麼行為？MySQL 為了維持 RR Isolation, 會 lock 整張 table 以下的 MySQL example image 的意思是？ Example AnswerSELECT 時加上 exclusive lock, 所以所有 height &gt;= 170 這個 range 的 row 都被鎖住了 MySQL 的 repeatable isolation 中, 如何避免 lost update?使用 Atomic operation, 像是 credit = credit - 1, 但如果要避免負數, 還是要使用 lock MySQL 的 repeatable isolation, 實作的 snapshot 只對什麼語法有效？只對 DQL, 像是 select 有效, 對 DML, 像是 insert, update, delete 都無效 MySQL 的 repeatable isolation 是如何實作 snapshot 的？會在 transaction 一開始進行一次 select, 並記錄下時間, 之後在此 transaction 中只可看到此時間之前的 committed row, 已經 transaction 自己本身作出的改變, 但這個規則只對 DQL (Data Query Language)有效, 對 DML (Data Manipulation Language) 無效 以下的 MySQL transaction illustration image 的意思是? Example AnswerMySQL 的 repeatable read 只可避免 phantom read, 但無法避免 phantom update, insert, delete 等其他操作在 transaction 中, update 的作用範圍依然是所有已經 commit 的 row, 而在 transaction 中, 可以看到自己 update 的 row, 因此 update 造成了 write skew, 而 select 產生 phantom read 資料庫中, Serializable Isolation 中的 Serializable Snapshot Isolation, 是如何實作?不特別對 transaction 做互相 block, 而是在最後 commit 的時候再做確認, 效能最佳, 但 2008 年才提出, 因此大部分資料庫都還沒有採用 大部分的資料庫都採用哪種方式實作 Serializable Isolation?Two-phase Lock 資料庫中, Serializable Isolation 中的 Two-phase Lock, 是如何實作?使用 Shared Lock 以及 Exclusive Lock 配合, 讓每一筆資料在同一時間最多都只會有一個 Transaction 對它進行讀寫, 還要搭配 Range Lock 避免 Phantom 現象, 大部分資料庫都採用這種實作 資料庫中, Serializable Isolation 中的 Serial Order, 是如何實作?真正照順序進行資料讀寫, 避免所有同時執行更新可能造成的衝突, 犧牲 concurrency, 效能差, 適合讀寫較快速的 In-Memory 資料庫, 如 redis 資料庫中, Serializable Isolation 有哪三種實作方式?Serial OrderTwo-phase LockSerializable Snapshot Isolation 資料庫中, 何謂 Serializable Isolation?可以保證在多個 Transaction 同時對資料庫進行讀寫所得到的結果, 會跟一次只讓一個 transaction 照順序 (serially) 進行讀寫所得到的結果完全一致, 最嚴格的 Isolation level, 但效能較差 資料庫中, 何謂 Repeatable Read Isolation?只要可以避免 Dirty Read 和 Non-repeatable Read, 就可以稱為 Repeatable Read Isolation, 依照實作方法不同, 有些資料庫的 Repeatable Read 可以避免 Lost Update 以及 Phantom 資料庫中, 何謂 Read Committed Isolation?只允許讀取已經被 Commit 的資料, 可以避免 dirty read 資料庫中, 何謂 Read Uncommitted Isolation?允許讀取尚未被 commit 的資料 資料庫中, Isolation 又分為哪四種？Read Uncommitted IsolationRead Committed IsolationRepeatable Read IsolationSerializable Isolation 資料庫中, 以下的情況又稱為？ Example: Answer:Write Skew只有 Serializable Isolation 可以避免 資料庫中, 以下的情況又稱為？ Example: Answer:Phantom Read, Serializable Isolation 可以避免這個現象, Repeatable Read Isolation 視乎各個資料的實作, PostgreSQL 可以完全避免, MySQL InnoDB 只能避免 Phantom Read, 但無法避免 UPDATE, DELETE 等 DML 寫入的操作 資料庫中, 以下的情況又稱為？ Example: Answer:Lost Update, Serializable Isolation 可以避免這個情況, Repeatable Read Isolation 看每個資料庫的實作不同有不同的行為, MySQL 無法避免 Lost Update, PostgreSQL 可以 資料庫中, 以下的情況又稱為？ Example: Answer:Read Skew (Non-repeatable Read), Repeatable Read 或更高的 Isolation 可避免這個情況 資料庫中, 以下的情況又稱為？ Example: Answer:Dirty Read, Read Committed 或更高的 Isolation 可避免 dirty read 以下的 MySQL example code 中, range lock 範圍內的資料 InnoDB 可以讀嗎？可以寫嗎？ Example:SELECT * FROM student WHERE height &gt;= 170 FOR UPDATE; Answer:如果 Isolation level 是 Serializable 的話, 不可讀不可寫如果 Isolation level 是 Repeatable Read 的話, 可讀不可寫, 因為 InnoDB 的 RR Isolation 實作是採用 Snapshot Isolation, 讀取時都是讀取 Snapshot 內的資料 以下的 MySQL example code 中, 哪些資料會被鎖住？ 會加上什麼鎖? Example:SELECT * FROM student WHERE height &gt;= 170 FOR UPDATE; Answer:height &gt;= 170 的資料exclusive lock MySQL 中, 如果一筆資料只被一個 transaction 加上 shared lock, 該 transaction 可以將此 shared lock 升級成 exclusive lock 嗎？可以 MySQL 中, 當一筆資料被 1 個或 1 個以上的 transaction 加上 shared lock, 該筆資料可以被加上 exlusive lock 嗎？不行 MySQL 中, 同一筆資料可以同時被多個 transaction 加上 shared lock 嗎？可以 MySQL 中, 當一個 transaction 取得某資料的 shared lock, 在該 lock 釋放之前, 其他 transaction 可以對此資料進行寫入嗎?不行 MySQL 中, 當一個 transaction 取得某資料的 shared lock, 在該 lock 釋放之前, 其他 transaction 可以對此資料進行讀取嗎?可以 MySQL 中, 當一個 transaction 取得某資料的 exclusive lock, 在該 lock 釋放之前, 其他 transaction 可以對此資料進行讀取嗎?不行 MySQL 中, 當一個 transaction 取得某資料的 exclusive lock, 在該 lock 釋放之前, 其他 transaction 可以對此資料進行寫入嗎?不行 MySQL 中, 何謂 shared lock?當一個 transaction 取得資料的 shared lock 之後, 其他 transaction 可以 讀取 資料, 但無法 寫入 資料 MySQL 中, 何謂 Exclusive lock?當一個 transaction 取得資料的 exclusive lock 之後, 其他 transaction 無法對此資料做 讀取 以及 寫入例如： select a from b for update 以下的 MySQL example code 的意思是？ Example:mysqlimport –user=&#x27;marie_dyer&#x27; --password=&#x27;sevenangels&#x27; \\--replace --low-priority --ignore-lines=&#x27;1&#x27; \\--fields-enclosed-by=&#x27;&quot;&#x27; --fields-terminated-by=&#x27;|&#x27; --fields-escaped-by=&#x27;\\\\&#x27; \\--lines-terminated-by=&#x27;]\\r\\n&#x27; \\--columns=&#x27;prospect_name, prospect_email, prospect_country&#x27; \\birdwatchers &#x27;/tmp/birdwatcher_prospects_import.csv&#x27; Answer:基本上語法跟 LOAD DATA 是一樣的, 差別在於檔名若有 - 要改成 _, 以免 MySQL 判定為刪減符號以下為 FIELDS 子句意思： TERMINATED BY: 表示 | 為 field 跟 field 之間的間隔ENCLOSED BY: 表示每一個 field 的內容都會由 &quot; 包住ESCAPE BY: 標示跳脫用字元, 不過預設就是 \\, 因此這個可省略LINES 子句：STRINGS BY: 表示 [ 開頭算一行的開始TERMINATED BY: 表示 ]\\r\\n 為一行的結束, 正常 Linux 只需 \\n 即可, 但考量到 Windows 環境, 因此多加了 \\r 以下的 MySQL example code 的意思是？ Example:( SELECT &#x27;scientific name&#x27;,&#x27;common name&#x27;,&#x27;family name&#x27; )UNION( SELECT birds.scientific_name, IFNULL(common_name, &#x27;&#x27;), bird_families.scientific_name FROM rookery.birds JOIN rookery.bird_families USING(family_id) JOIN rookery.bird_orders USING(order_id) WHERE bird_orders.scientific_name = &#x27;Charadriiformes&#x27; ORDER BY common_name INTO OUTFILE &#x27;/tmp/birds-list.csv&#x27; FIELDS ENCLOSED BY &#x27;&quot;&#x27; TERMINATED BY &#x27;|&#x27; ESCAPED BY &#x27;\\\\&#x27; LINES TERMINATED BY &#x27;\\n&#x27;); Answer:使用 SELECT INTO OUTFILE 將資料匯出, 子句部分語法跟 LOAD DATA 完全一樣需使用 IFNULL 將 null 轉為空字串, 因為 INTO OUTFILE 預設會將 null 轉為 n以下為 FIELDS 子句意思： TERMINATED BY: 表示 | 為 field 跟 field 之間的間隔ENCLOSED BY: 表示每一個 field 的內容都會由 &quot; 包住ESCAPE BY: 標示跳脫用字元, 不過預設就是 \\, 因此這個可省略LINES 子句：STRINGS BY: 表示 [ 開頭算一行的開始TERMINATED BY: 表示 ]\\r\\n 為一行的結束, 正常 Linux 只需 \\n 即可, 但考量到 Windows 環境, 因此多加了 \\r MySQL 中, 如果目標 server 並不支援 LOAD DATA INFILE, 那有什麼解法？找一台有支援的使用 LOAD DATA 匯入後, 在匯出 mysqldump file, 再到目標 server 上復原 from mysqldump file MySQL 中, 如果遠端登入使用 LOAD DATA 匯入檔案操作, 在 server 端跟 client 端都要開啟哪一個選項？local-infile=1 以下的 MySQL example code 的意思是？## csv 格式範例：[&quot;prospect name&quot;|&quot;prospect email&quot;|&quot;prospect country&quot;][&quot;Mr. Bogdan Kecman&quot;|&quot;bodgan\\@kecman-birds.com&quot;|&quot;Serbia&quot;][&quot;Ms. Sveta Smirnova&quot;|&quot;bettasveta\\@gmail.com&quot;|&quot;Russia&quot;][&quot;Mr. Collin Charles&quot;|&quot;callincollin\\@gmail.com&quot;|&quot;Malaysia&quot;][&quot;Ms. Sveta A. Smirnova&quot;|&quot;bettasveta\\@gmail.com&quot;|&quot;Russia&quot;]## SQL 範例LOAD DATA INFILE &#x27;/tmp/birdwatcher-prospects.csv&#x27;INTO TABLE birdwatchers.birdwatcher_prospects_importFIELDS TERMINATED BY &#x27;|&#x27; ENCLOSED BY &#x27;&quot;&#x27; ESCAPED BY &#x27;\\\\&#x27;LINES STARTING BY &#x27;[&#x27; TERMINATED BY &#x27;]\\r\\n&#x27;IGNORE 1 LINES(prospect_name, prospect_email, prospect_country); Answer:從 csv 檔讀取資料並匯入 database.table FIELD TERMINATED BY: field 跟 field 之間由 , 區隔開來OPTIONALLY: 有則處理, 沒有則不執行ENCLOSED BY: 使用 ENCLOSED BY &#39;&quot;&#39;, 當 &quot; (doube quote) 有出現時, 會將兩個 &quot; (double quote) 之間的內容視為一個 column 的內容, 若沒出現則不使用, 為了應付某些 filed 的內容其實是 text, 會用 &quot; (double quote) 包住, 但內容有許多 ,(comma)IGNORE 1 LINES: 表示忽略第一行, 因為第一行是 field name, 我們並不會用到@niente: 因為 csv 檔中某些欄位的資料我們並不需要, 因此在建立 table 時只需要建立我們需要的 column, 在匯入時, 將沒用到的 fieldd 按照 csv 上的順序標示為 @niente (只要是變數就行, 名稱不重要), 這樣就不會將資料匯入啦@family, SET family: 可以在 LOAD DATA 的過程中, 針對 csv 上特定的 column 做處理, 匯入完成後就已經會是處理好的 以下的 MySQL example code 的意思是？ Example:LOAD DATA INFILE &#x27;/tmp/Clements-Checklist-6.9-final.csv&#x27;INTO TABLE rookery.clements_list_importFIELDS TERMINATED BY &#x27;,&#x27; OPTIONALLY ENCLOSED BY &#x27;&quot;&#x27;IGNORE 1 LINES;(id, change_type, @niente, @niente,scientific_name, english_name,@niente, bird_order, @family, @niente,@niente, @niente, @niente, @niente,@niente, @niente, @niente, @niente);SET family = SUBSTRING(@family, 1, LOCATE(&#x27; (&#x27;, @family) ); Answer:從 csv 檔讀取資料並匯入 database.tableFIELD TERMINATED BY: field 跟 field 之間由 , 區隔開來OPTIONALLY: 有則處理, 沒有則不執行ENCLOSED BY: 使用 ENCLOSED BY &#39;&quot;&#39;, 當 &quot; (doube quote) 有出現時, 會將兩個 &quot; (double quote) 之間的內容視為一個 column 的內容, 若沒出現則不使用, 為了應付某些 filed 的內容其實是 text, 會用 &quot; (double quote) 包住, 但內容有許多 ,(comma)IGNORE 1 LINES: 表示忽略第一行, 因為第一行是 field name, 我們並不會用到@niente: 因為 csv 檔中某些欄位的資料我們並不需要, 因此在建立 table 時只需要建立我們需要的 column, 在匯入時, 將沒用到的 fieldd 按照 csv 上的順序標示為 @niente (只要是變數就行, 名稱不重要), 這樣就不會將資料匯入啦@family, SET family: 可以在 LOAD DATA 的過程中, 針對 csv 上特定的 column 做處理, 匯入完成後就已經會是處理好的 使用 MySQL 時, 當遇到 warning 時, 如何顯示 warning?SHOW WARNINGS; 以下的 MySQL example code 的意思是？ Example:LOAD DATA INFILE &#x27;/tmp/Clements-Checklist-6.9-final.csv&#x27;INTO TABLE rookery.clements_list_importFIELDS TERMINATED BY &#x27;,&#x27;; Answer:讀取 csv 檔並 insert 到指定 database.table, 以 , 為 filed 跟 field 之間的分隔點 MySQL 中, 當我在 CREATE TABLE 時, 如果 column name 可能是 MySQL 的保留字, 那我要用什麼符號將 column name 包住？` ` (backquote) 符號 MySQL 中, 若要執行 LOCK TABLE, 需先把哪一個選項關閉, 以避免 LOCK TABLE 與 TRANSACTION 相互影響？AUTOCOMMIT MySQL 中, 目前 innoDB 是如何處理死鎖的？將持有最少行級排他鎖的 transaction rollback 以下的 MySQL example code 中, 當兩個 transaction 同時執行時, 很可能會產生哪一種問題？ Example:事務1 START TRANSACTION; UPDATE StockPrice SET close = 45.50 WHERE stock_id = 4 and date = &#x27;2002-05-01&#x27;; UPDATE StockPrice SET close = 19.80 WHERE stock_id = 3 and date = &#x27;2002-05-02&#x27;; COMMIT;事務2 START TRANSACTION; UPDATE StockPrice SET high = 20.12 WHERE stock_id = 3 and date = &#x27;2002-05-02&#x27;; UPDATE StockPrice SET high = 47.20 WHERE stock_id = 4 and date = &#x27;2002-05-01&#x27;; COMMIT; Answer:死鎖, 即事務 1, 2 同時執行了第一條 update, 這時第一句 update 作用的 row 已被鎖住, 而當事務 1, 2 嘗試執行第二句 update 時, 發現該 row 已被鎖住, 彼此都在等對方釋放鎖, 故又稱為死鎖 以下的 MySQL 形容, 屬於 ACID 中的哪一種？ Example:一旦事務提交，則其所做的修改就會永久保存到數據庫中。此時即使系統崩潰，修改的數據也不會丟失。持久性是個有點模糊的概念，因為實際上持久性也分很多不同的級別。有些持久性策略能夠提供非常強的安全保障，而有些則未必。而且不可能有能做到100％的持久性保證的策略（如果數據庫本身就能做到真正的持久性，那麼備份又怎麼能增加持久性呢？） Answer:durability (持久性) 以下的 MySQL 形容, 屬於 ACID 中的哪一種？ Example:通常來說，一個事務所做的修改在最終提交以前，對其他事務是不可見的 Answer:isolation (隔離性) 以下的 MySQL 形容, 屬於 ACID 中的哪一種？ Example:數據庫總是從一個一致性的狀態轉換到另外一個一致性的狀態。在前面的例子中，一致性確保了，即使在執行第三、四條語句之間時系統崩潰，支票賬戶中也不會損失200美元，因為事務最終沒有提交，所以事務中所做的修改也不會保存到數據庫中。 Answer:consistency (一致性) 以下的 MySQL 形容, 屬於 ACID 中的哪一種？ Example:一個事務必須被視為一個不可分割的最小工作單元，整個事務中的所有操作要麼全部提交成功，要麼全部失敗回滾，對於一個事務來說，不可能只執行其中的一部分操作 Answer:atomicity (原子性) MySQL 中的 ACID, 分別是哪四種特性？atomicity (原子性)consistency (一致性)isolation (隔離性)durability (持久性) 以下的 MySQL Image 是？？ Example: Answer:MySQL 邏輯架構圖 以下的 MySQL example code 的意思是？ Example:mysqlbinlog --database=rookery --start-position=&quot;1284889&quot; --to-last-log \\ binaryLogAbsoluteLocation | mysql --user=userName --password Answer:從 binary log 備份中, 從 position 1284889 開始復原, 直到最後一個 log, 復原範圍有包含 1284889 以下的 MySQL example code 的意思是？ Example:mysqlbinlog --database=databaseName--stop-position=&quot;1258707&quot; \\ binaryLogAbsoluteLocation | mysql --user=userName --password Answer:從 binary log 備份中, 復原到 position 1258707, 復原範圍不包含 1258707 以下的 MySQL example code 的意思是？ Example:# at 1258707#140916 13:10:24 server id 1 end_log_pos 1258778 Query thread_id=382 exec_time=0 error_code=0SET TIMESTAMP=1410887424/*!*/;SET @@session.sql_mode=0/*!*/;BEGIN/*!*/;# at 1258778#140916 13:10:24 server id 1 end_log_pos 1258900 Query thread_id=382 exec_time=0 error_code=0use `rookery`/*!*/;SET TIMESTAMP=1410887424/*!*/;DELETE FROM birds_simple WHERE common_name LIKE &#x27;%Blue%&#x27;/*!*/;# at 1258900#140916 13:10:24 server id 1 end_log_pos 1258927 Xid = 45248COMMIT/*!*/; Answer:binary log 中的一次 transaction 的紀錄, 1258707 為起點, 1258900 為終點, 1258927 為下一個起點 以下的 MySQL example code 的意思是？ Example:mysqlbinlog --database=databaseName \\ /binaryLogAbsoluteLocation &gt; whateverNameYouLike.txt Answer:將 binary log 匯出成 txt 檔, 方便手動尋找 position 以下的 MySQL example code 的意思是？ Example:SHOW VARIABLES WHERE Variable_Name LIKE &#x27;datadir&#x27;; Answer:取得實際檔案存放位置 以下的 MySQL example code 的意思是？ Example:SHOW MASTER STATUS; Answer:顯示當前的 binary log Binlog_Do_DB: 指定哪些資料庫才要記錄到 binary logBinlog_Ignore_DB: 指定哪些資料庫不要記錄到 binary logExecuted_Gtid_Set: 已經執行的 transaction 編號 MySQL 中, 何謂 DDL?Data Definition Language, 例如 CREATE, DROP, ALTER 以下的 MySQL example code 的意思是？ Example:SHOW BINARY LOGS Answer:顯示 binary log 是否有啟動若有則顯示 log若無則返回錯誤 ERROR 1381 (HY000): You are not using binary logging 以下的 MySQL example code 的意思是？ Example:log-binbinlog-ignore-db=mysql Answer:啟動 binary log 功能不 log mysql 這個 table, 安全考量 MySQL 中, 如果我想要從一個 dump file 中只復原一部分的 table, 該怎麼做？ 修改 dump file, 只留下開頭, 結尾變數, 以及需要的 table 段落 或是修改 create database, 改成一個臨時的 database name, 匯出後在從該臨時 database 中取出資料, 完成後再刪掉該 temporary database 或是賦予一個臨時使用者該 table 的權限, 讓這個使用者去執行 restore 以下的 MySQL example code 的意思是？ Example:mysqldump --user=admin_backup --password --lock-tables \\ --databases rookery --tables birds &gt; birds-humans.sqlmysqldump --user=admin_backup --password --lock-tables \\ --databases birdwatchers --tables humans &gt;&gt; birds-humans.sql Answer:備份兩個資料庫的不同資料表, 但只產生一個 dump file 以下的 shell script 的意思是? Example:#!/bin/shmy_user=&#x27;admin_back&#x27;my_pwd=&#x27;my_silly_password&#x27;db1=&#x27;rookery&#x27;db2=&#x27;birdwatchers&#x27;date_today=$(date +%Y-%m-%d)backup_dir=&#x27;/data/backup/&#x27;dump_file=$db1-$db2-$date_today&#x27;.sql&#x27;/usr/bin/mysqldump --user=$my_usr --password=$my_pwd --lock-tables \\ --databases $db1 $db2 &gt; $backup_dir$dump_fileexit Answer:備份 MySQL Database 的 script 以下的 MySQL example code 的意思是? Example:LOCK TABLES `bird_families` WRITE;/*!40000 ALTER TABLE `bird_families` DISABLE KEYS */;INSERT INTO `bird_families` VALUES.../*!40000 ALTER TABLE `bird_families` ENABLE KEYS */;UNLOCK TABLES; Answer:通常還原資料, 在執行 INSERT 敘述時, 會先 DISABLE KEYS, 等到 INSERT 都完成後, 再 ENABLE KEYS, 這樣的效率會比 INSERT 時一筆筆的 INSERT INDEX 來得好 MySQL dump 復原資料時, 預設會覆蓋掉原本存在的資料嗎？會哦, 因為會先 drop 現存的同名 table, 再 insert 以下的 MySQL example code 的意思是? Example:mysqldump --user=specifiedUserAndHostName \\ --password --lock-all-tables --all-databases &gt; /preferredLocationAndFileName.sql Answer:–user: 要求 mysqlsump 使用 admin_backup 這個帳號與 MySQL Server 互動–password: 指定使用帳號的密碼–lock-all-tables: 在開始備份前, 先把所有資料表鎖定–all-databases: 指定匯出所有資料庫 以下位於 dump 檔的 MySQL example code 的意思是? Example:/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */; Answer:*!40101: 當 MySQL 版本在 4.01.01 以上時, 該行指令才會執行設定一個變數 @OLD_CHARACTER_SET_CLIENT, 並將目前的通用變數 CHARACTER_SET_CLIENT 儲存起來 以下的 MySQL example code 的意思是? Example:GRANT &#x27;roleName&#x27; TO &#x27;userName&#x27;@&#x27;hostName&#x27;; Answer:賦予使用者 Role 權限 以下的 MySQL example code 的意思是? Example:CREATE ROLE &#x27;roleName&#x27;; Answer:建立 Role, 可賦予 Role 權限, 在賦予使用者 Role 以下的 MySQL example code 的意思是? Example:SET ROLE &#x27;admin_import_role&#x27;;LOAD DATA INFILE...SET ROLE NONE; Answer:當該使用者有被賦予該 Role 時, 可切換該 Role執行完權限後, 登出 Role 以下的 MySQL example code 的意思是? Example:RENAME USER &#x27;lena_stankoska&#x27;@&#x27;lena_stankoska_home&#x27;TO &#x27;lena&#x27;@&#x27;stankoskahouse.com&#x27;; Answer:重新命名使用者帳號 以下的 MySQL example code 的意思是? Example:SHOW PROCESSLIST; Answer:當我們刪除一個使用者後, 如果該使用者在當下仍與 Server 處於一個連線狀態中, 那該使用者依然可以對資料庫進行操作, 這時可以透過 SHOW PROCESSLIST 列出連線, 並使用 kill processId 刪除該連線 MySQL 中, 當我刪除一個使用者後, 如果該使用者在當下仍跟 Server 處於連線狀態, 該使用者還能操作資料庫嗎？ 可以 以下的 MySQL example code 的意思是? Example:REVOKE ALL PRIVILEGESON rookery.*FROM &#x27;michael_stone&#x27;@&#x27;localhost&#x27; Answer:使用 REVOKE 語法, 從 &#39;michael_stone@localhost&#39; user 身上收回 rookery 資料庫的所有的權限 以下的 MySQL example code 的意思是? Example:GRANT ALL PRIVILEGES ON rookery.*TO &#x27;admin_granter&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;avocet_123&#x27;WITH GRANT OPTION;GRANT ALL PRIVILEGES ON birdwatchers.*TO &#x27;admin_granter&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;avocet_123&#x27;WITH GRANT OPTION; Answer:透過 WITH GRANT OPTION 語法, 可以將自身擁有的權限賦予給其他帳號 以下的 MySQL example code 的意思是? Example:CREATE USER &#x27;admin_import&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;another_pwd_789&#x27;;GRANT FILE ON *.*TO &#x27;admin_import&#x27;@&#x27;localhost&#x27;; Answer:建立一個可從檔案匯入資料的帳號, 擁有權限的帳號相當於可以讀取 MySQL 在主機上有權觸及的任何檔案, 並且可以把資料匯入到任何一個資料庫, 反之, 也可從資料庫會出資料, 甚至是含有密碼的資料庫 以下的 MySQL example code 的意思是? Example:CREATE USER &#x27;admin_restore&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;different_pwd_456&#x27;;GRANT INSERT, LOCK TABLES, CREATE,CREATE TEMPORARY TABLES, INDEX, ALTERON rookery.*TO &#x27;admin_restore&#x27;@&#x27;localhost&#x27;;GRANT INSERT, LOCK TABLES, CREATE,CREATE TEMPORARY TABLES, INDEX, ALTERON birdwatchers.*TO &#x27;admin_restore&#x27;@&#x27;localhost&#x27;; Answer:建立一個專門還原備份資料的使用者要從 dump file 復原, 所以必須要具有 INSERT 權限復原時為了能鎖定資料表, 因此需要 LOCK TABLES 權限要重建資料表, 因此需要 CREATE 權限要重建 index, 因此需要 INDEX 權限dump 內的 SQL 敘述可能會修改資料表, 因此需要 ALTER 權限如果想把資料還原至臨時資料表, 那就需要 CREATE TEMPORARY TABLES 權限如果還有包含 TRIGGER 或 VIEW, 那就要加上 CREATE VIEW 和 TRIGGER 權限 以下的 MySQL example code 的意思是? Example:CREATE USER &#x27;admin_backup&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;its_password_123&#x27;;GRANT SELECT, LOCK TABLESON rookery.*TO &#x27;admin_backup&#x27;@&#x27;localhost&#x27;;GRANT SELECT, LOCK TABLESON birdwatchers.*TO &#x27;admin_backup&#x27;@&#x27;localhost&#x27;; Answer:建立一個管理備份用的帳號, 賦予 SELECT 權限, 所以可讀取資料庫, 因為在備份的過程中必須 lock table, 所以賦予 LOCK TABLES 權限, 只限定特定資料庫 以下的 Shell script example code 的意思是? Example:#!/bin/shmysql_connect=&quot;mysql --user root -pmy_pwd&quot;results=`$mysql_connect --skip-column-names \\ --execute &#x27;SHOW TABLES FROM birdwatchers;&#x27;`items=$(echo $results | tr &quot; &quot; &quot;\\n&quot;)for item in $itemsdo if [ $item = &#x27;humans&#x27; ] || [ $item = &#x27;birder_families&#x27; ] || [ $item = &#x27;birding_events_children&#x27; ] then continue fi `$mysql_connect --execute &quot;GRANT SELECT ON birdwatchers.$item \\ TO &#x27;lena_stankoska&#x27;@&#x27;lena_stankoska_home&#x27;&quot;`doneexit Answer:由於 MySQL 中, 如果要 GRANT 特定權限給特定 table 必須要一個一個指定, 所以使用 shell script 來批量 GRANT 以下的 MySQL example code 的意思是? Example:SELECT COLUMN_GET(choices, answer AS CHAR) AS &#x27;Birding Site&#x27;,COUNT(*) AS &#x27;Votes&#x27;,CONCAT( TRUNCATE( (COUNT(*) / @fav_site_total) * 100, 1), &#x27;%&#x27;) AS &#x27;Percent&#x27;FROM survey_answersJOIN survey_questions USING(question_id)WHERE survey_id = 1AND question_id = 1GROUP BY answer; Answer:TRUNCATE() 的 arg1 表示要處理的 input, arg2 表示小數位 1 位之後都要拿掉 以下的 MySQL function 的差異是? Example:ROUND()FLOOR()CEILING() Answer:四捨五入, 無條件捨去, 無條件進位 以下的 MySQL example code 的意思是? Example:SELECT COLUMN_GET(choices, answer AS CHAR) AS &#x27;Birding Site&#x27;,COUNT(*) AS &#x27;Votes&#x27;,(COUNT(*) / @fav_site_total) AS &#x27;Percent&#x27;FROM survey_answersJOIN survey_questions USING(question_id)WHERE survey_id = 1AND question_id = 1GROUP BY answer; Answer:@fav_site_total 為 variable, 需事先定義 以下的 MySQL example code 的意思是? Example:SET @fav_site_total =(SELECT COUNT(*)FROM survey_answersJOIN survey_questions USING(question_id)WHERE survey_id = 1AND question_id = 1);SELECT @fav_site_total; Answer:@fav_site_total 為變數, assign 一段 SQL query 以下的 MySQL example code 的意思是? Example:SELECT IFNULL(COLUMN_GET(choices, answer AS CHAR), &#x27;total&#x27;)AS &#x27;Birding Site&#x27;, COUNT(*) AS &#x27;Votes&#x27;FROM survey_answersJOIN survey_questions USING(question_id)WHERE survey_id = 1AND question_id = 1GROUP BY answer WITH ROLLUP; Answer:使用 COLUMN_GET(), 從 choices column 取值。 其為 MariaDB 的 blob data type, 可以存多組 key/value, 並且取值時要指定型別 以下的 MySQL example code 的意思是? Example:SELECT NOW(), event_date, start_time,CONCAT( DATEDIFF(event_date, DATE(NOW())), &#x27; Days, &#x27;, DATE_FORMAT(TIMEDIFF(start_time, TIME(NOW())), &#x27;%k hours, %i minutes&#x27;)) AS &#x27;Time to Event&#x27;FROM birding_events; Answer:使用 DATEDIFF() 取得 event_date 以及 NOW() 的差異天數使用 TIMEDIFF() 將 start_time 以及現在的時間的差異 小時, 分鐘 取出再使用 CONCAT 串起來 以下的 MySQL example code 的意思是? Example:SELECT CURDATE() AS &#x27;Today&#x27;,DATE_FORMAT(membership_expiration, &#x27;%M %e, %Y&#x27;) AS &#x27;Date Membership Expires&#x27;,DATEDIFF(membership_expiration, CURDATE()) AS &#x27;Days Until Expiration&#x27;FROM humansWHERE human_id = 4; Answer:使用 DATEDIFF() 來比較兩個日期時間的差異天數 以下的 MySQL example code 的意思是? Example:SELECT CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,COUNT(time_seen) AS &#x27;Sightings Recorded&#x27;FROM bird_sightingsJOIN humans USING(human_id)WHERE CONCAT(QUARTER(time_seen), YEAR(time_seen)) =CONCAT( QUARTER( STR_TO_DATE( PERIOD_ADD( EXTRACT(YEAR_MONTH FROM CURDATE()), -3), &#x27;%Y%m&#x27;) ), YEAR( STR_TO_DATE( PERIOD_ADD( EXTRACT(YEAR_MONTH FROM CURDATE()), -3), &#x27;%Y%m&#x27;) ) )GROUP BY human_id LIMIT 5; Answer:先用 EXTRACT() 將 YEAR_MONTH 從目前時間取出, 接著使用 PERIOD_ADD() 減掉 3 個月, 再用 STR_TO_DATE 設定成 ‘%Y%m’ 格式, 最後再用 QUARTER() 以及 YEAR 算出第幾季以及第幾年 以下的 MySQL example code 的意思是? Example:SELECT TIME(NOW()),TIME_TO_SEC(NOW()),TIME_TO_SEC(NOW()) / 60 /60 AS &#x27;Hours&#x27;; Answer:僅將 時間 部分轉換成秒數, 即今天至今已過了幾秒 以下的 MySQL example code 的意思是? Example:UPDATE bird_sightingsSET time_seen = DATE_ADD(time_seen, INTERVAL &#x27;1 2&#x27; DAY_HOUR)WHERE sighting_id = 16; Answer:使用 DATE_ADD(), 增加 1 天 2 小時 以下的 MySQL example code 的意思是? Example:UPDATE humansSET membership_expiration = DATE_ADD(membership_expiration, INTERVAL -1 YEAR)WHERE CONCAT(name_first, SPACE(1), name_last) = &#x27;Melissa Lee&#x27;; Answer:當使用負號, DATE_ADD() 也有 DATE_SUB() 的效果 以下的 MySQL example code 的意思是? Example:UPDATE humansSET membership_expiration = DATE_SUB(membership_expiration, INTERVAL 1 YEAR)WHERE CONCAT(name_first, SPACE(1), name_last) = &#x27;Melissa Lee&#x27;; Answer:更新 membership_expiration, 使用 DATE_SUB 扣掉一年 以下的 MySQL example code 的意思是? Example:UPDATE humansSET membership_expiration = DATE_ADD(membership_expiration, INTERVAL 3 MONTH)WHERE country_id = &#x27;uk&#x27;AND membership_expiration &gt; CURDATE( ); Answer:更新 membership_expiration, 使用 DATE_ADD 將日期往後增加三個月 以下的 MySQL my.cnf example code 的意思是？ Example:default-time-zone=&#x27;GMT&#x27; Answer:將 server 的預設時區改為 GMT 以下的 MySQL example code 的意思是? Example:SELECT common_name AS &#x27;Bird&#x27;,CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,DATE_FORMAT(time_seen, &#x27;%r&#x27;) AS &#x27;System Time Spotted&#x27;,DATE_FORMAT(CONVERT_TZ(time_seen, &#x27;US/Eastern&#x27;, &#x27;Europe/Rome&#x27;), &#x27;%r&#x27;) AS &#x27;Birder Time Spotted&#x27;FROM bird_sightingsJOIN humans USING(human_id)JOIN rookery.birds USING(bird_id)JOIN rookery.conservation_status USING(conservation_status_id) LIMIT 3; Answer:使用 CONVERT_TZ, arg1 為時間, arg2 為來源時區, arg3 為欲轉換成的時區, 再將結果作為 parameter 帶入 DATE_FORMAT() 以下的 MySQL example code 的意思是? Example:SHOW VARIABLES LIKE &#x27;time_zone&#x27;; Answer:取得 MySQL 系統時區 以下的 MySQL example code 的意思是? Example:SELECT DATE_FORMAT(CURDATE(), GET_FORMAT(DATE,&#x27;EUR&#x27;)) AS &#x27;Date in Europe&#x27;,DATE_FORMAT(CURDATE(), GET_FORMAT(DATE,&#x27;USA&#x27;)) AS &#x27;Date in U.S.&#x27;,REPLACE(DATE_FORMAT(CURDATE(), GET_FORMAT(DATE,&#x27;USA&#x27;)), &#x27;.&#x27;, &#x27;-&#x27;) AS &#x27;Another Date in U.S.&#x27;; Answer:使用 GET_FORMAT 取得特定地區的時間格式, 再將結果帶入 DATE_FORMAT 完成格式設定使用 REPLACE 將不喜歡的格式做客製化替換 以下的 MySQL example code 的意思是? Example:SELECT common_name AS &#x27;Endangered Bird&#x27;,CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,DATE_FORMAT(time_seen, &#x27;%W, %M %e, %Y&#x27;) AS &#x27;Date Spotted&#x27;,TIME_FORMAT(time_seen, &#x27;%l:%i %p&#x27;) AS &#x27;Time Spotted&#x27;FROM bird_sightingsJOIN humans USING(human_id)JOIN rookery.birds USING(bird_id)JOIN rookery.conservation_status USING(conservation_status_id)WHERE conservation_category = &#x27;Threatened&#x27; LIMIT 3; Answer:使用 DATE_FORMAT, TIME_FORMAT 從指定時間擷取並輸入定義的格式, 格式碼可參考 以下的 MySQL example code 的意思是? Example:SELECT time_seen,EXTRACT(YEAR_MONTH FROM time_seen) AS &#x27;Year &amp; Month&#x27;,EXTRACT(MONTH FROM time_seen) AS &#x27;Month Only&#x27;,EXTRACT(HOUR_MINUTE FROM time_seen) AS &#x27;Hour &amp; Minute&#x27;,EXTRACT(HOUR FROM time_seen) AS &#x27;Hour Only&#x27;FROM bird_sightings JOIN humans USING(human_id)LIMIT 3; Answer:使用 EXTRACT() 從指定時間中擷取特定格式, EXTRACT() 支援格式可參考 以下的 MySQL example code 的意思是? Example:SELECT time_seen,EXTRACT(YEAR_MONTH FROM time_seen) AS &#x27;Year &amp; Month&#x27;,EXTRACT(MONTH FROM time_seen) AS &#x27;Month Only&#x27;,EXTRACT(HOUR_MINUTE FROM time_seen) AS &#x27;Hour &amp; Minute&#x27;,EXTRACT(HOUR FROM time_seen) AS &#x27;Hour Only&#x27;FROM bird_sightings JOIN humans USING(human_id)LIMIT 3; Answer:使用 EXTRACT() 從指定時間中擷取特定格式, EXTRACT() 支援格式可參考 以下的 MySQL example code 的意思是? Example:SELECT common_name AS &#x27;Endangered Bird&#x27;,CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,CONCAT(DAYNAME(time_seen), &#x27;, &#x27;, MONTHNAME(time_seen), SPACE(1), DAY(time_seen), &#x27;, &#x27;, YEAR(time_seen)) AS &#x27;Date Spotted&#x27;,CONCAT(HOUR(time_seen), &#x27;:&#x27;, MINUTE(time_seen), IF(HOUR(time_seen) &lt; 12, &#x27; a.m.&#x27;, &#x27; p.m.&#x27;)) AS &#x27;Time Spotted&#x27;FROM bird_sightingsJOIN humans USING(human_id)JOIN rookery.birds USING(bird_id)JOIN rookery.conservation_status USING(conservation_status_id)WHERE conservation_category = &#x27;Threatened&#x27; LIMIT 3; Answer:使用 DAYNAME(), MONTHNAME, 分別擷取帶入時間, 並輸出成 Day 的英文單字, 月份英文單字使用 DAY(), YEAR(), HOUR(), MINUTE(), 分別擷取帶入時間的 天, 年, 時, 分最後判斷, 如果 HOUR 小於 12, 即為上午 a.m., 大於 12, 即下午 p.m. 以下的 MySQL example code 的意思是? Example:SELECT CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,time_seen, YEAR(time_seen), MONTH(time_seen), DAY(time_seen),MONTHNAME(time_seen), DAYNAME(time_seen)FROM bird_sightings JOIN humans USING(human_id)WHERE bird_id = 309 \\G Answer:使用 YEAR(), MONTH(), DAY(), 分別擷取帶入時間的 年, 月, 日使用 MONTHNAME(), DAYNAME(), 分別擷取並輸出成帶入時間的 月份英文單字, day 的英文單字 以下的 MySQL example code 的意思是? Example:SELECT CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,time_seen, HOUR(time_seen), MINUTE(time_seen), SECOND(time_seen)FROM bird_sightings JOIN humans USING(human_id)WHERE bird_id = 309 \\G Answer:使用 HOUR(), MINUTE(), SECOND(), 分別擷取帶入時間的 小時, 分, 秒 以下的 MySQL example code 的意思是? Example:SELECT CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,time_seen, DATE(time_seen), TIME(time_seen)FROM bird_sightingsJOIN humans USING(human_id)WHERE bird_id = 309; Answer:使用 DATE(), TIME() 分別擷取帶入時間的 年月日 以及 時間 部分 以下的 MySQL example code 的意思是? Example:SELECT CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,ROUND((UNIX_TIMESTAMP( ) - UNIX_TIMESTAMP(time_seen)) / 60 / 60 / 24) AS &#x27;Days Since Spotted&#x27;FROM bird_sightings JOIN humans USING(human_id)WHERE bird_id = 309; Answer:SELECT CONCAT(name_first, SPACE(1), name_last) AS &#x27;Birdwatcher&#x27;,# UNIX_TIMESTAMP() 為取得 1970 年 1 月 1 號至今所經過的秒數# 帶入特定時間點並經過計算後, 可取得特定時間點至今所經過的天數ROUND((UNIX_TIMESTAMP() - UNIX_TIMESTAMP(time_seen)) / 60 / 60 / 24) AS &#x27;Days Since Spotted&#x27;FROM bird_sightings JOIN humans USING(human_id)WHERE bird_id = 309; 以下的 MySQL example code 的意思是? Example:SELECT NOW(), CURDATE(), CURTIME(); Answer:分別是取得當前日期時間, 當前日期, 當前時間 以下的 MySQL example code 的意思是? Example:SELECT NOW(), SLEEP(4) AS &#x27;Zzz&#x27;, SYSDATE(), SLEEP(2) AS &#x27;Zzz&#x27;, SYSDATE(); Answer:NOW() 是取得 SQL Query 執行當下的時間, 而 SYSDATE() 是取得該函式執行當下的時間, 如果要在複雜的 SQL Query 當中取得某段函式的執行時間時, 便可使用 SYSDATE() MySQL 中, 以下幾個函式的功能都一樣, 為什麼需要這麼多不同名稱卻同功能的函示？ Example:NOW(), CURRENT_TIMESTAMP(), LOCALTIME(), LOCALTIMESTAMP() Answer:因為為了配合其他種類的資料庫, 像是 PostgreSQL, Oracle, Sybase 等等…這樣原本使用其他資料庫的應用程式就可以在不更動程式碼下直接更換資料庫 以下的 MySQL example code 的意思是? Example:SELECT UNCOMPRESS(birding_background) AS BackgroundFROM humansWHERE name_first = &#x27;Melissa&#x27; AND name_last = &#x27;Lee&#x27; \\G Answer:UNCOMPRESS function 可以解壓縮 COMPRESS function 壓縮過的欄位資料 以下的 MySQL example code 的意思是? Example:INSERT INTO humans(formal_title, name_first, name_last, join_date, birding_background)VALUES(&#x27;Ms&#x27;, &#x27;Melissa&#x27;, &#x27;Lee&#x27;, CURDATE(), COMPRESS(&quot;lengthy background...&quot;)); Answer:COMPRESS function 可以壓縮字串, 適用於大量的 text, 效能有待研究 以下的 MySQL example code 的意思是? Example:SELECT bird_name, gender_age, bird_imageFROM bird_imagesWHERE bird_name LIKE &#x27;%Plover%&#x27;ORDER BY CONVERT(gender_age USING utf8)LIMIT 5; Answer:將 gender_age 的 character set 暫時轉為 utf8 以下的 MySQL example code 的意思是? Example:SELECT bird_name, gender_age, bird_imageFROM bird_imagesWHERE bird_name LIKE &#x27;%Plover%&#x27;ORDER BY CONVERT(gender_age, CHAR)LIMIT 5; Answer:將 gender_age 的 column type 暫時轉換為 CHAR, 只反映在結果上, 並不會真正更動資料庫 MySQL 中, 如果 column type 是 enum, 那排序上會依照 enum 的排序還是 collation 的排序？enum 的排序 以下的 MySQL example code 的意思是? Example:SELECT sorting_id, bird_name, bird_imageFROM bird_images ORDER BY CAST(sorting_id AS INT) LIMIT 5; Answer:將 sorting_id column type 暫時轉換為 INT, 只作用到結果, 不會變動 column type 以下的 MySQL example 為什麼 sorting_id 的排列方式是如此? Example:SELECT sorting_id, bird_name, bird_imageFROM bird_imagesORDER BY sorting_idLIMIT 5; Answer:因為 sorting_id column 的 column type 被設為 char, 而非 int 以下的 MySQL example code 的意思是? Example:SELECT common_name AS Original,REPLACE(common_name, &#x27;Gt.&#x27;, &#x27;Great&#x27;) AS ReplacedFROM birdsWHERE common_name REGEXP &#x27;Gt.&#x27; LIMIT 1; Answer:REPLACE() 跟 REPLACE 不同直接尋找 ‘Gt.’ 並將之替換為 ‘Great’, 只改變顯示結果, 並不會真正的更動資料庫 以下的 MySQL example code 的意思是? Example:SELECT common_name AS Original,INSERT(common_name, LOCATE(&#x27;Gt.&#x27;, common_name), 3, &#x27;Great&#x27;) AS AdjustedFROM birdsWHERE common_name REGEXP &#x27;Gt.&#x27; LIMIT 1; Answer:INSERT() 跟 INSERT 不同, INSERT() 只會將結果替換掉指定的字串, 不會真正的更動資料庫arg1 為要作用的欄位, arg2 為替換起始位置, arg3 為總共要覆蓋原本字串多少個字, arg4 為要用來替換的字串如上 example, LOCATE 會回傳 1, 所以從 1 開始替換 ‘Gt.’ 共三個字, 所以會全部覆蓋掉若不希望覆蓋掉任何字, arg3 可指定 0 以下的 MySQL example code 的意思是? Example:SELECT CONCAT(name_first, SPACE(1), name_last) AS Name,common_name AS Bird,SUBSTRING(comments, 1, 25) AS CommentsFROM birdwatchers.bird_sightingsJOIN birdwatchers.humans USING(human_id)JOIN rookery.birds USING(bird_id)WHERE MATCH (comments) AGAINST (&#x27;beautiful&#x27;); Answer:SELECT CONCAT(name_first, SPACE(1), name_last) AS Name,common_name AS Bird,# 從第 1 個位置開始取, 取 25 個字SUBSTRING(comments, 1, 25) AS CommentsFROM birdwatchers.bird_sightingsJOIN birdwatchers.humans USING(human_id)JOIN rookery.birds USING(bird_id)# 唯有先行建立 FULLTEXT INDEX, 方可使用 MATCH ... AGAINST 函數# 從 &#x27;comments&#x27; column 尋找 &#x27;beautiful&#x27; 字串WHERE MATCH (comments) AGAINST (&#x27;beautiful&#x27;); 以下的 MySQL example code 的意思是? Example:CREATE FULLTEXT INDEX comment_indexON bird_sightings (comments); Answer:建立 FULLTEXT index 名為 comment_index, 唯有建立 FULLTEXT index 方可使用 match … against 函數 以下的 MySQL example code 的意思是? Example:INSERT IGNORE INTO possible_duplicate_email(human_id, email_address_1, email_address_2, entry_date)VALUES(LAST_INSERT_ID(), &#x27;bobyfischer@mymail.com&#x27;, &#x27;bobbyfischer@mymail.com&#x27;)WHERE ABS( STRCMP(&#x27;bobbyrobin@mymail.com&#x27;, &#x27;bobyrobin@mymail.com&#x27;) ) = 1 ; Answer:INSERT IGNORE INTO possible_duplicate_email(human_id, email_address_1, email_address_2, entry_date)VALUES(LAST_INSERT_ID(), &#x27;bobyfischer@mymail.com&#x27;, &#x27;bobbyfischer@mymail.com&#x27;)## ABS 會將 value 轉為絕對值, 即 -1 變成 1, 1 還是 1## STRCMP 會比較兩個數, 相等則為 0, 否則則為 1 或 -1WHERE ABS( STRCMP(&#x27;bobbyrobin@mymail.com&#x27;, &#x27;bobyrobin@mymail.com&#x27;) ) = 1 ; 以下的 MySQL example code 的意思是? Example:SELECT IF(CHAR_LENGTH(comments) &gt; 100), &#x27;long&#x27;, &#x27;short&#x27;)FROM bird_sightingsWHERE sighting_id = 2; Answer:select &#39;comments&#39; 欄位, 如果長度大於 100, 則回傳 &#39;long&#39;, 反之則回傳 &#39;short&#39; 以下的 MySQL example code 的意思是? Example:SELECT FIND_IN_SET(&#x27;Anahit Vanetsyan&#x27;, Names) AS Position FROM (SELECT GROUP_CONCAT(Name ORDER BY join_date) AS Names FROM ( SELECT CONCAT(name_first, SPACE(1), name_last) AS Name, join_date FROM humans WHERE country_id = &#x27;ru&#x27;) AS derived_1 ) AS derived_2; Answer:GROUP_CONCAT 會將 Name column 的所有姓名連接起來, 並 ORDER BY join_date, 然後 FIND_IN_SET() 從 Name column 中找到 ‘Anahit Vanetsyan’ 的位置 以下的 MySQL example code 的意思是? Example:SELECTSUBSTRING(common_name, 1, LOCATE(&#x27; Avocet&#x27;, common_name) ) AS &#x27;Avocet&#x27;FROM birdsJOIN bird_families USING(family_id)WHERE bird_families.scientific_name = &#x27;Recurvirostridae&#x27;AND birds.common_name LIKE &#x27;%Avocet%&#x27;; Answer:LOCATE 會取得 ‘ Avocet’ 前面那一個空格的位置, 而 SUBSTRING 從第 1 個位置開始取, 取 LOCATE 得到的結果, 正好把 ‘Avocet’ 濾掉 以下的 MySQL query 的意思是？ Example:# +--------------------------------------------------------+# | prospect_name |# +--------------------------------------------------------+# | Ms.| Caryn-Amy | Rose |# | Mr.| Colin | Charles |# | Mr.| Kenneth | Dyer |# | Ms.| Sveta | Smirnova |# +--------------------------------------------------------+SELECT SUBSTRING_INDEX(prospect_name, &#x27;|&#x27;, 1) AS title,SUBSTRING_INDEX( SUBSTRING_INDEX(prospect_name, &#x27;|&#x27;, 2), &#x27;|&#x27;, -1) AS first_name,SUBSTRING_INDEX(prospect_name, &#x27;|&#x27;, -1) AS last_nameFROM prospects WHERE prospect_id = 7; Answer:// 取到第一個 &#x27;|&#x27; 之前的所有字串SELECT SUBSTRING_INDEX(prospect_name, &#x27;|&#x27;, 1) AS title,// 內函數取得第兩個 &#x27;|&#x27; 之前的所有字串, 外函數則是從尾端往前找, 直到找到 &#x27;|&#x27;, 取這之間的字串SUBSTRING_INDEX( SUBSTRING_INDEX(prospect_name, &#x27;|&#x27;, 2), &#x27;|&#x27;, -1) AS first_name,// 從尾端往前找, 直到找到 &#x27;|&#x27;, 取這之間的字串SUBSTRING_INDEX(prospect_name, &#x27;|&#x27;, -1) AS last_nameFROM prospects WHERE prospect_id = 7; 以下的 MySQL query 的意思是？ Example:# +--------------------------------------------------------+# | prospect_name |# +--------------------------------------------------------+# | Ms. Caryn-Amy Rose |# | Mr. Colin Charles |# | Mr. Kenneth Dyer |# | Ms. Sveta Smirnova |# +--------------------------------------------------------+SELECT SUBSTRING(prospect_name, 1, 2) AS title,SUBSTRING(prospect_name FROM 5 FOR 25) AS first_name,SUBSTRING(prospect_name, -25) AS last_nameFROM prospects LIMIT 3; Answer:// 從第 1 個開始取, 取 2 個SELECT SUBSTRING(prospect_name, 1, 2) AS title,// 從第 5 個開始取, 取 25 個SUBSTRING(prospect_name FROM 5 FOR 25) AS first_name,// 取後面算來 25 個SUBSTRING(prospect_name, -25) AS last_nameFROM prospects LIMIT 3; 以下的 MySQL query 的意思是？ Example:# +--------------------------------------------------------+# | prospect_name |# +--------------------------------------------------------+# | Ms. Caryn-Amy Rose |# | Mr. Colin Charles |# | Mr. Kenneth Dyer |# | Ms. Sveta Smirnova |# +--------------------------------------------------------+SELECT LEFT(prospect_name, 2) AS title,MID(prospect_name, 5, 25) AS first_name,RIGHT(prospect_name, 25) AS last_nameFROM prospects LIMIT 4; Answer:LEFT: 從左邊開始取, 取 2 個MID: 從第 5 個開始取, 取 25 個RIGHT: 從後面往前取, 取 25 個 以下的 MySQL query 的意思是？ Example:SELECT CONCAT(RPAD(common_name, 20, &#x27;.&#x27; ),RPAD(Families.scientific_name, 15, &#x27;.&#x27;),Orders.scientific_name) AS BirdsFROM birdsJOIN bird_families AS Families USING(family_id)JOIN bird_orders AS OrdersWHERE common_name != &#x27;&#x27;AND Orders.scientific_name = &#x27;Ciconiiformes&#x27;ORDER BY common_name LIMIT 3;# +--------------------------------------------------+# | Birds |# +--------------------------------------------------+# | Abbott&#x27;s Babbler....Pellorneidae...Ciconiiformes |# | Abbott&#x27;s Booby......Sulidae........Ciconiiformes |# | Abbott&#x27;s Starling...Sturnidae......Ciconiiformes |# +--------------------------------------------------+ Answer:利用 RPAD 將空格填滿, arg1 為作用的 column, arg2 為該 column 預期的字串長度, arg3 為不足字串長度時, 要使用什麼字符將之補滿 以下的 MySQL query 的意思是？ Example:SELECT QUOTE(common_name)FROM birdsWHERE common_name LIKE &quot;%Prince%&quot;ORDER BY common_name; Answer:# 將資料夾上 quote 輸出, 並 escape 特殊符號SELECT QUOTE(common_name)FROM birdsWHERE common_name LIKE &quot;%Prince%&quot;ORDER BY common_name;# +----------------------------------+# | QUOTE(common_name) |# +----------------------------------+# | &#x27;Prince Henry\\&#x27;s Laughingthrush&#x27; |# | &#x27;Prince Ruspoli\\&#x27;s Turaco&#x27; |# | &#x27;Princess Parrot&#x27; |# +----------------------------------+ 以下的 MySQL query 的意思是？ Example:SELECT LCASE(common_name) AS Species,UCASE(bird_families.scientific_name) AS FamilyFROM birdsJOIN bird_families USING(family_id)WHERE common_name LIKE &#x27;%Wren%&#x27;ORDER BY SpeciesLIMIT 5; Answer:## 將 common_name column 的值轉為小寫SELECT LCASE(common_name) AS Species,## 將 scientific_name column 的值轉為大寫UCASE(bird_families.scientific_name) AS FamilyFROM birds## 經由 family_id JOIN 兩張表JOIN bird_families USING(family_id)WHERE common_name LIKE &#x27;%Wren%&#x27;ORDER BY SpeciesLIMIT 5;# +-------------------------+---------------+# | Species | Family |# +-------------------------+---------------+# | apolinar&#x27;s wren | TROGLODYTIDAE |# | band-backed wren | TROGLODYTIDAE |# | banded wren | TROGLODYTIDAE |# | bar-winged wood-wren | TROGLODYTIDAE |# | bar-winged wren-babbler | TIMALIIDAE |# +-------------------------+---------------+ 以下的 MySQL query 的意思是？ Example:mysql -p --skip-column-names -e \\&quot;SELECT CONCAT_WS(&#x27;|&#x27;, IFNULL(formal_title, &#x27; &#x27;), IFNULL(name_first, &#x27; &#x27;),IFNULL(name_last, &#x27; &#x27;), IFNULL(street_address, &#x27; &#x27;),IFNULL(city, &#x27; &#x27;), IFNULL(state_province, &#x27; &#x27;),IFNULL(postal_code, &#x27; &#x27;), IFNULL(country_id, &#x27; &#x27;))FROM birdwatchers.humans WHERE membership_type = &#x27;premium&#x27;AND membership_expiration &gt; CURDATE();&quot; &gt; rookery_patch_mailinglist.txt Answer:mysql -p --skip-column-names -e \\# 跳過欄位那一欄不做處理, -p 代表 password, -e 代表執行 &quot;&quot; 內的程式碼# 使用 &#x27;|&#x27; 來連接並隔開每個 column 的value# CONCAT_WS, WS 為 with seprarator 的意思&quot;SELECT CONCAT_WS(&#x27;|&#x27;, IFNULL(formal_title, &#x27; &#x27;), IFNULL(name_first, &#x27; &#x27;),# 加上 IFNULL, 若 NULL 的話也會輸出空字串, 否則 CONCAT_WS 會不處理直接跳過# 造成 select 8 個欄位, 但卻只輸出 4 個欄位的值, 也不知道哪個欄位沒值IFNULL(name_last, &#x27; &#x27;), IFNULL(street_address, &#x27; &#x27;),IFNULL(city, &#x27; &#x27;), IFNULL(state_province, &#x27; &#x27;),IFNULL(postal_code, &#x27; &#x27;), IFNULL(country_id, &#x27; &#x27;))FROM birdwatchers.humans WHERE membership_type = &#x27;premium&#x27;# 將結果輸出到 txt 檔AND membership_expiration &gt; CURDATE();&quot; &gt; rookery_patch_mailinglist.txt 以下的 MySQL query 的意思是？ Example:SELECT common_name AS &#x27;Bird&#x27;,conservation_state AS &#x27;Status&#x27;FROM birdsLEFT JOIN conservation_status USING(conservation_status_id)WHERE common_name LIKE &#x27;%Egret%&#x27;ORDER BY Status, Bird; Answer:從 birds table select common_name column (命名呈現的 column name 為 Bird), conservation_state column (命名呈現的 column name 為 Status)left join conservation_status table, 透過 conservation_status_idleft join 會先取出 birds table, 所以如果並沒有對應的 conservation_status_id 的話, 就會顯示 null像是+--------------------+-----------------+| Bird | Status |+--------------------+-----------------+| Great Egret | NULL || Cattle Egret | Least Concern || Intermediate Egret | Least Concern || Little Egret | Least Concern || Snowy Egret | Least Concern || Reddish Egret | Near Threatened || Chinese Egret | Vulnerable || Slaty Egret | Vulnerable |+--------------------+-----------------+ 以下的 MySQL query 的意思是？ Example:SELECT book_id, title, status_nameFROM booksJOIN status_names USING(status_id); Answer:JOIN books 跟 status_names 兩張 table, 因為要用來 connect 兩張 table 的 key 都一樣, 因此使用 USING 以下的 MySQL query 的意思是？ Example:SELECT book_id, title, status_nameFROM booksJOIN status_names ON(status = status_id); Answer:JOIN books 跟 status_names 兩張 table, 用 ON 連結 status 以及 status_id 欄位 以下的 MySQL query 的意思是？ Example:SELECT &#x27;Pelecanidae&#x27; AS &#x27;Family&#x27;, COUNT(*) AS &#x27;Species&#x27; FROM birds, bird_families AS families WHERE birds.family_id = families.family_id AND families.scientific_name = &#x27;Pelecanidae&#x27;UNION SELECT &#x27;Ardeidae&#x27;, COUNT(*) FROM birds, bird_families AS families WHERE birds.family_id = families.family_id AND families.scientific_name = &#x27;Ardeidae&#x27;; Answer: ## &#x27;Pelacanidae&#x27; 為不存在的欄位, 以純文字賦予欄位值, 結果如下SELECT &#x27;Pelecanidae&#x27; AS &#x27;Family&#x27;, ## Species 為另一個 column COUNT(*) AS &#x27;Species&#x27; FROM birds, bird_families AS families WHERE birds.family_id = families.family_id AND families.scientific_name = &#x27;Pelecanidae&#x27;UNION ## 因為使用 Union, 這邊不須再加 alias, 會自動歸類到 &#x27;Family&#x27; column SELECT &#x27;Ardeidae&#x27;, COUNT(*) FROM birds, bird_families AS families WHERE birds.family_id = families.family_id AND families.scientific_name = &#x27;Ardeidae&#x27;; ## +-------------+---------+## | Family | Species |## +-------------+---------+## | Pelecanidae | 10 |## | Ardeidae | 157 |## +-------------+---------+ 以下的 MySQL query 的意思是？ Example:DELETE FROM humans, prize_winnersUSING humans JOIN prize_winnersWHERE name_first = &#x27;Elena&#x27;AND name_last = &#x27;Bokova&#x27;AND email_address LIKE &#x27;%yahoo.com&#x27;AND humans.human_id = prize_winners.human_id; Answer:// 同時 delete humans 以及 prize_winners 的資料// 如果不加 prize_winners, 那該 table 上的資料就// 不會被刪除DELETE FROM humans, prize_winners// JOIN prize_winners tableUSING humans JOIN prize_winnersWHERE name_first = &#x27;Elena&#x27;AND name_last = &#x27;Bokova&#x27;AND email_address LIKE &#x27;%yahoo.com&#x27;AND humans.human_id = prize_winners.human_id; 以下的 MySQL query 的意思是？ Example:CREATE TEMPORARY TABLE possible_duplicates(name_1 varchar(25), name_2 varchar(25)); Answer:建立一個臨時的 table, 當退出 MySQL client 時, 該 table 會自動銷毀 以下的 MySQL query 的意思是？ Example:INSERT INTO humans(formal_title, name_first, name_last, email_address, better_birders_site)VALUES(&#x27;Mr&#x27;,&#x27;Barry&#x27;,&#x27;Pilson&#x27;, &#x27;barry@gomail.com&#x27;, 1), (&#x27;Ms&#x27;,&#x27;Lexi&#x27;,&#x27;Hollar&#x27;, &#x27;alexandra@mysqlresources.com&#x27;, 1), (&#x27;Mr&#x27;,&#x27;Ricky&#x27;,&#x27;Adams&#x27;, &#x27;ricky@gomail.com&#x27;, 1)ON DUPLICATE KEYUPDATE better_birders_site = 2; Answer:因為 email_address 有 unique 特性, 所以當 insert 過程中發現有 duplicate 的 row 時, 會 update 該 row 的 better_birders_site column 為 2 以下的 MySQL query 錯誤的原因是？ Example:UPDATE prize_winners, humansSET winner_date = CURDATE()WHERE winner_date IS NULLAND country_id = &#x27;uk&#x27;AND prize_winners.human_id = humans.human_idORDER BY RAND()LIMIT 2; Answer:order by 及 limit 只適用於單一 table, 當 update 複數的 table 時就會出錯 以下的 MySQL query 的意思是？ Example:UPDATE prize_winners, humansSET winner_date = NULL, prize_chosen = NULL, prize_sent = NULLWHERE country_id = &#x27;uk&#x27;AND prize_winners.human_id = humans.human_id; Answer:從 human table 中取得 ‘country_id = uk’ 的 row, 再經此找到符合 ‘prize_winners.human_id = humans.human_id’ 的 prize_winners最後 update 這些 prize_winners 的 winner_date, prize_chosen, prize_sent columns 以下的 MySQL query 的意思是？ Example:ALTER TABLE humansCHANGE COLUMN formal_title formal_title ENUM(&#x27;Mr.&#x27;,&#x27;Ms.&#x27;,&#x27;Mr&#x27;,&#x27;Ms&#x27;);UPDATE humansSET formal_title = SUBSTRING(formal_title, 1, 2);ALTER TABLE humansCHANGE COLUMN formal_title formal_title ENUM(&#x27;Mr&#x27;,&#x27;Ms&#x27;); Answer:## 修改 humans tableALTER TABLE humans## 將 column formal_title 改成 formal_title, type 為 ENUM(&#x27;Mr.&#x27;, &#x27;Ms.&#x27;, &#x27;Mr&#x27;, &#x27;Ms&#x27;);CHANGE COLUMN formal_title formal_title ENUM(&#x27;Mr.&#x27;,&#x27;Ms.&#x27;,&#x27;Mr&#x27;,&#x27;Ms&#x27;);## 更新 humans tableUPDATE humans## 更新 formal_title column, 取 formal_title 的值, 從第一個字開始取, 共取兩個字## 因此 &quot;Mr.&quot; 會變成 &quot;Mr&quot;SET formal_title = SUBSTRING(formal_title, 1, 2);## 同上, 修改 formal_title colum 的 typeALTER TABLE humansCHANGE COLUMN formal_title formal_title ENUM(&#x27;Mr&#x27;,&#x27;Ms&#x27;); 以下的 MySQL query 的意思是？ Example:select common_name as &#x27;hawks&#x27;from birdswhere common_name regexp &#x27;[[:space:]]hawk|[[.hyphen.]]hawk&#x27;and common_name not regexp &#x27;hawk-owl|hawk owl&#x27;order by family_id; Answer:## select common_name column, 並定義新欄位名稱為 Hawksselect common_name as &#x27;hawks&#x27;## 從 birds tablefrom birds## common_name 的值必須是 &quot; hawk&quot;, 或是 &quot;-hawk&quot;where common_name regexp &#x27;[[:space:]]hawk|[[.hyphen.]]hawk&#x27;## common_name 的值必須不是 &quot;hawk_owl&quot; 或 &quot;hawk owl&quot;and common_name not regexp &#x27;hawk-owl|hawk owl&#x27;## 經由 family_id column 排序order by family_id; 以下的 MySQL column information 中, latin1_bin 的 bin 是什麼意思？ Example:SHOW FULL COLUMNSFROM birds LIKE &#x27;common_name&#x27; \\G*************************** 1. row *************************** Field: common_name Type: varchar(255) Collation: latin1_bin Null: YES Key: Default: NULL Extra:Privileges: select,insert,update,references Comment: Answer:binary 的意思, 表示儲存在該欄位的資料都會以 binary 定序 以下的 MySQL example code 是什麼意思？ Example:SELECT common_name AS &#x27;Hawks&#x27;FROM birdsWHERE common_name REGEXP BINARY &#x27;Hawk&#x27;AND common_name NOT REGEXP &#x27;Hawk-Owl&#x27;ORDER BY family_id LIMIT 10; Answer:一般來說, REGEXP 不會區分大小寫, 若要區分, 可加上 BINARY, 會以二進制定序, h 跟 H 的二進制碼不同, 所以可以區分大小寫 以下的 MySQL example code 是什麼意思？ Example:SELECT common_name, scientific_name, family_idFROM birdsWHERE family_id IN(103, 160, 162, 164)AND common_name != &#x27;&#x27;ORDER BY common_nameLIMIT 3, 2; Answer:從第三筆之後開始查詢, 取得兩筆資料, 相當於 offset 3, limit 2 以下的 MySQL example code 是什麼意思？ Example:INSERT HIGH_PRIORITY INTO bird_sightings Answer:MySQL 預設 insert 的 priority 就大於 select, 但如果預設值被改掉, 就可以使用上面的語法 以下的 MySQL example code 有個與 MySQL Client 不方便的地方, 是什麼？ Example:INSERT LOW_PRIORITY INTO bird_sightings Answer:在 low priority instruction 被執行之前, client 會一直卡住 以下的 MySQL example code 是什麼意思？ Example:INSERT LOW_PRIORITY INTO bird_sightings Answer:先完成手邊的工作, 再處理 low priority 的工作 以下的 MySQL example code 是什麼意思？ Example:REPLACE INTO bird_families(scientific_name, brief_description, order_id)VALUES(&#x27;Viduidae&#x27;, &#x27;Indigobirds &amp; Whydahs&#x27;, 128),(&#x27;Estrildidae&#x27;, &#x27;Waxbills, Weaver Finches, &amp; Allies&#x27;, 128),(&#x27;Ploceidae&#x27;, &#x27;Weavers, Malimbe, &amp; Bishops&#x27;, 128); Answer:將指定的 value insert 到指定的欄位, 如果遇到重複的, 則覆寫, 相當於 Laravel 中的 insertOrUpdate 以下的 MySQL example code 是什麼意思？ Example:UPDATE bird_families, bird_ordersSET bird_families.order_id = bird_orders.order_idWHERE bird_families.order_id IS NULLAND cornell_bird_order = bird_orders.scientific_name; Answer:將 bird_families table 中的 order_id update 為 bird_orders table 中的 order_id只更新 where clause 中限制的 record 以下的 MySQL example code 是什麼意思？ Example:INSERT IGNORE INTO bird_families(scientific_name, brief_description, cornell_bird_order)SELECT bird_family, examples, bird_orderFROM cornell_birds_families_orders; Answer:從 cornell_birds_families_orders table, select bird_family, examples, bird_order 三個欄位, 並將 select 的結果 insert 到 bird_families table 的 scientific_name, brief_description, cornell_bird_order 欄位, 同時, 若過程中出現錯誤, ignore 錯誤繼續執行 以下的 MySQL example code 中, 為什麼會失敗？ Example:ALTER TABLE conservation_statusCHANGE status_id conservation_status_id INT AUTO_INCREMENT PRIMARY KEY;ERROR 1068: Multiple primary key defined Answer:status_id 欄位原本已經有 primary_key, 這是一個 index上面的語法在原本已經有一個 index 的同時, 又要增加一個 index, 所以報錯應該要先把原本的 index 拿掉 以下的 MySQL example code 中, 為什麼最後一行的 common_name 要重複兩次？ Example:ALTER TABLE birds_newADD COLUMN body_id CHAR(2) AFTER wing_id,ADD COLUMN bill_id CHAR(2) AFTER body_id,ADD COLUMN endangered BIT DEFAULT b&#x27;1&#x27; AFTER bill_id,CHANGE COLUMN common_name common_name VARCHAR(255); Answer:第一次是指要變更的 column 名稱第二次是指要變更成哪個名稱 以下的 MySQL example code 中, 在建立 bill_id column 時, 理論上 body_id column 應該還沒創建出來, 那為什麼可以指定 bill_id after body_id 呢？ Example:ALTER TABLE birds_newADD COLUMN body_id CHAR(2) AFTER wing_id,ADD COLUMN bill_id CHAR(2) AFTER body_id,ADD COLUMN endangered BIT DEFAULT b&#x27;1&#x27; AFTER bill_id,CHANGE COLUMN common_name common_name VARCHAR(255); Answer:在 MySQL ALTER 的過程中, 會先建立一張虛擬的表格, 如果語法執行上都沒有問題, 會用這張虛擬表格取代原本的如果語法有錯, 則會刪除這張虛擬表格 MySQL 的 column property character set 以及 collation, 分別代表的意思是？character set: 該欄位會儲存的語言屬於哪一種編碼collation: 該欄位該以什麼樣的語種排序 以下的 MySQL command 的意思是？ Example:SHOW CREATE TABLE birds \\G Answer:顯示建立該 table 的語法 MySQL 中, CHAR 跟 VARCHAR, 使用的大原則是？如果確切知道有幾個 character, 就使用 CHAR, 否則則使用 VARCHAR MySQL 中, CHAR 跟 VARCHAR, 哪個較不會產生 fragmentation?VARCHAR MySQL 中, CHAR 跟 VARCHAR, 哪個使用 index 的 performance 較佳？CHAR MySQL 中, 當我使用 mysql client select, 有時會因為資料太多而資料欄位沒有排列好, 像下圖一樣, 這時候可以使用哪個 command 來顯示正確的格式？ Example: Answer:可在最後用 \\G 取代 ; MySQL 中, virtualAs column type 的作用是？虛擬 column, 內容來自於其他 column 的計算結果(自定義), 比如說, 新增一個 virtualAs column 叫做 full_name, 自定義內容來自於 first_name + last_name command line 中, 如果 filesystem 的目前登入者跟 MySQL 的 user 是同一個, 那在登入時我還需要使用 mysql -u username -p password 嗎？不需要, 直接使用 mysql -p 即可 以下的 mysql command 的意思是？ Example:mysql -u root -p -e &quot;GRANT ALL ON *.* TO &#x27;russell&#x27;@&#x27;localhost&#x27;;&quot; Answer:賦予 russell, host 為 localhost, 所有資料庫以及 table 的操作權限第一個 * 的位置代表資料庫, * 表示全部資料庫第二個 * 的位置代表 table, * 表示全部 table 以下的 mysql command 的意思是？ Example:mysql -u root -p -e &quot;SHOW GRANTS FOR &#x27;russell&#x27;@&#x27;localhost&#x27; \\G&quot; Answer:顯示 russell 的所有權限 以下的 mysql command 的意思是？ Example:mysql -u root -p -e &quot;GRANT SELECT ON *.* TO &#x27;russell&#x27;@&#x27;localhost&#x27;;&quot; Answer:給予 russell user, host 為 localhost, select 所有資料庫所有 table 的權限 以下的 mysql command 的意思是？ Example:mysql -u root -p -e &quot;GRANT USAGE ON *.*TO &#x27;russell&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;Rover#My_1st_Dog&amp;Not_Yours!&#x27;;&quot; Answer:## 給予存取所有資料庫所有 table 的權限, 這裡是指可存取的 database 以及 table## 但並沒有給予任何實際上的權限, 如 select, update, insertmysql -u root -p -e &quot;GRANT USAGE ON *.*## 賦予上面的權限給 user russell, host 為 localhostTO &#x27;russell&#x27;@&#x27;localhost&#x27;## 密碼為 Rover#My_1st_Dog&amp;Not_Yours!IDENTIFIED BY &#x27;Rover#My_1st_Dog&amp;Not_Yours!&#x27;;&quot; 以下的 mysql command 的意思是？ Example:mysqladmin -u root -p flush-privileges Answer:當完成一些設定更新後, 下達上面的指令讓設定生效 以下的 mysql command 的意思是？ Example:mysql -u root -p -e &quot;SELECT User,Host FROM mysql.user;&quot; Answer:列出所有的 user 以及 host 以下的 mysql command 的意思是？ Example:mysql -u root -p -e &quot;SET PASSWORD FOR &#x27;root&#x27;@&#x27;127.0.0.1&#x27; PASSWORD(&#x27;new_pwd&#x27;);&quot;mysql -u root -p -e &quot;SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; PASSWORD(&#x27;new_pwd&#x27;);&quot;mysql -u root -p -e &quot;DROP USER &#x27;root&#x27;@&#x27;%&#x27;;&quot;mysql -u root -p -e &quot;DROP USER &#x27;&#x27;@&#x27;localhost&#x27;;&quot; Answer:1, 2 行給 root 的不同 host 設定新密碼, 儘管 127.0.0.1 等於 localhost, 但也必須分別設定密碼3, &#39;root&#39;@&#39;%&#39; 表示不管從任何 host 都可以 claim 自己是 root, 這樣的設定並不安全, 必須刪除4, &#39;&#39;@&#39;localhost&#39; 表示只要是來自 localhost, 任何 username 都被接受, 這樣的設定也不安全, 應該要刪除這樣的 anonymous user Mysql 中, 如果搜尋的字串是 % 開頭, 那可以用 index 嗎？不行 Mysql 中, set column type 的特性是？可指定一個允許輸入值列表, 所有 insert 的值都必須在這列表內才允許輸入, 與 enum 不同之處在於, enum 只允許 insert 一個值, set 允許 insert 零個或多個 如何在已知 root 現有密碼的情況下重新設定 root 密碼？mysqladmin -u root -p flush-privileges password Mysql 中, enum column type 的特性是？可指定一個允許輸入值列表, 所有 insert 的值都必須在這列表內才允許輸入, 與 enum 不同之處在於, enum 只允許 insert 一個值, set 允許 insert 零個或多個 Mysql 中, date, datetime, timestamp, 三種 data type 差異分別是？date: yyyy-mm-dddatetime: yyyy-mm-dd hh:mm:sstimestamp: yyyy-mm-dd hh:mm:ss 除此之外, timestamp 會將收到的時間轉成 UTC, 當 query 此欄位時, 會再從 UTC 轉成目前時區 Mysql 中, float, double, decimal, 由小至大的排列順序為？float, double, decimal Mysql 中, 若要精準的儲存一個數字(含小數點), 建議使用哪個 type?decimal Mysql 中, double type 有效位數約為？17 位 Mysql 中, float type 有效位數約為？7 位數 Mysqld 通常代表什麼？MySQL Daemon, 通常代表 MySQL Server 以下的 SQL 語法中的意思是？ Example:CREATE INDEX prod_name_indON PRODUCTS (prod_name); Answer: 建立一個 index, 名為 prod_name_ind, table 為 PRODUCTS, 欄位為PROD_NAME 以下的 SQL 語法中的意思是？ Example: BEGIN TRANSACTIONINSERT INTO Customers(cust_id, cust_name)VALUES(&#x27;1000000010&#x27;, &#x27;Toys Emporium&#x27;);SAVE TRANSACTION StartOrder;INSERT INTO Orders(order_num, order_date, cust_id)VALUES(20100,&#x27;2001/12/1&#x27;,&#x27;1000000010&#x27;);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20100, 1, &#x27;BR01&#x27;, 100, 5.49);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;INSERT INTO OrderItems(order_num, order_item, prod_id, quantity, item_price)VALUES(20100, 2, &#x27;BR03&#x27;, 100, 10.99);IF @@ERROR &lt;&gt; 0 ROLLBACK TRANSACTION StartOrder;COMMIT TRANSACTION Answer:在第一個 insert 建立一個 savepoint StartOrder, 如果之後的語法失敗, 回到 savepoint 以下的 SQL 語法中的意思是？ Example:CREATE VIEW ProductCustomers ASSELECT cust_name, cust_contact, prod_idFROM Customers, Orders, OrderItemsWHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num; Answer:建立一個 VIEW, 為一張虛擬的 table, 可藉此簡單化省略重複複雜 SQL 語法 以下的 SQL 語法中的意思是？ Example:SELECT *INTO CustCopyFROM Customers; Answer:從 Customers table 撈出所有 record, 再 insert 到 CustCopy table 以下的 SQL 語法中的意思是？ Example:INSERT INTO Customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM CustNew; Answer:從 CustNew table 中 select 出 record, 在 insert 進 Customers table 以下的 SQL 語法中的意思是？ Example:SELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;)UNIONSELECT cust_name, cust_contact, cust_emailFROM CustomersWHERE cust_name = &#x27;Fun4All&#x27;ORDER BY cust_name, cust_contact; Answer:只在最後一個 SELECT 使用 ORDER BY, 因為 UNION 會將它用來排序所有 SELECT 語句返回的結果 以下的 SQL 語法中的意思是？ Example:SELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_state IN (&#x27;IL&#x27;,&#x27;IN&#x27;,&#x27;MI&#x27;) UNION ALLSELECT cust_name, cust_contact, cust_email FROM Customers WHERE cust_name = &#x27;Fun4All&#x27;; Answer:使用 UNION 語法同時執行兩個 query, UNION 默認取消重複的 record, ALL 表示不默認取消 以下的 SQL 語法中的意思是？ Example:SELECT cust_name, cust_contactFROM Customers AS C, Orders AS O, OrderItems AS OIWHERE C.cust_id = O.cust_id AND OI.order_num = O.order_num AND prod_id = &#x27;RGAN01&#x27;; Answer:使用 AS 來縮短 SQL 語法 以下的 SQL 語法中的意思是？ Example:SELECT prod_name, vend_name, prod_price, quantityFROM OrderItems, Products, VendorsWHERE Products.vend_id = Vendors.vend_id AND OrderItems.prod_id = Products.prod_id AND order_num = 20007; Answer:從三個 table 中取出指定的 column, 並指定連結 以下的 SQL 語法會取出多少行的 record？ Example:SELECT vend_name, prod_name, prod_priceFROM Vendors, Products; Answer:因為沒有指定關聯, 所以共會取出 Vendors 與 Products 行數的相乘 以下的 SQL 語法中的意思是？ Example:SELECT cust_name, cust_state, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS ordersFROM Customers ORDER BY cust_name; Answer:利用子查詢取得 orders 欄位, 即在 orders table 中, cust_id 跟 Customers table 中的 cust_id 相同 以下的 SQL 語法中, 作為子查詢, 可以 select 多個 column 嗎？ Example:SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = &#x27;RGAN01&#x27;); Answer:不行 以下的 SQL 語法的意思是？ Example:SELECT cust_idFROM OrdersWHERE order_num IN (SELECT order_num FROM OrderItems WHERE prod_id = &#x27;RGAN01&#x27;); Answer:從子查詢得到的結果來 filter 下面的 select 子句的排列順序是？ ExampleSELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY Answer: SQL 語法中, WHERE 跟 HAVING 差別是？where 過濾行having 過濾分組 SQL 語法中, count(*) 會否忽略 NULL 值？不會 SQL 語法中, 當使用 + 把不同 column 的值串在一起, 卻發現有多餘的空白如下 example, 在 example 2 當中, 該怎麼去掉這些空白呢？ Example output-----------------------------------------------------------Bear Emporium (USA )Bears R Us (USA )Doll House Inc. (USA )Fun and Games (England )Furball Inc. (USA )Jouets et ours (France ) Example 2SELECT RTRIM(vend_name) + &#x27; (&#x27; + 這裡是？(vend_country) + &#x27;)&#x27;FROM VendorsORDER BY vend_name; AnswerSELECT RTRIM(vend_name) + &#x27; (&#x27; + RTRIM(vend_country) + &#x27;)&#x27;FROM VendorsORDER BY vend_name; SQL 語法中, 如果要把兩個不同 column 的 value 串在一起成一個字串輸出, 如下 example, 該使用什麼符號？？ ExampleSELECT vend_name 這裡是？ &#x27; (&#x27; 這裡是？ vend_country 這裡是？ &#x27;)&#x27;FROM VendorsORDER BY vend_name; AnswerSELECT vend_name + &#x27; (&#x27; + vend_country + &#x27;)&#x27;FROM VendorsORDER BY vend_name; SQL 語法中, wildcard 是否會耗費比較多的時間？會的 SQL 語法中, 當使用 wildcard 時, 最好將語法置於開頭處或結尾處？結尾處 SQL 語法中, 假如我要找出所有名字以 J 或 M 起頭的聯絡人, 在以下的 example 中, 該使用哪個 wildcard? ExampleSELECT cust_contactFROM CustomersWHERE cust_contact LIKE &#x27;這裡是？%&#x27;ORDER BY cust_contact; AnswerSELECT cust_contactFROM CustomersWHERE cust_contact LIKE &#x27;[JM]%&#x27;ORDER BY cust_contact; SQL 語法中, % 代表多字 wildcard, 如果我要單個字的 wildcard, 要使用哪個符號？_, 是一個 word, 不是 character SQL 語法中, 以下 example 中的語法會撈出 value 為 null 的 row 嗎？ Example:SELECT prod_nameFROM ProductsWHERE prod_name LIKE &#x27;%&#x27;; Answer:不會 以下的 SQL 語法是什麼意思？ Example:SELECT prod_nameFROM ProductsLIMIT 5 OFFSET 5; Answer:抵銷 5 行, 也就是從第 6 行開始撈撈 5 行資料 SQL 語法中, 有區分大小寫嗎？無 SQL 語法中, inner join 跟 join 差在哪？一樣 SQL 語法中, left outer join 跟 left join 差在哪？一樣 SQL 語法中, right outer join 跟 right join 差在哪？一樣 SQL 語法中, join 語法的用途是？同時撈出兩張表的資料 SQL 語法中, left join 跟 right join 語法的差別是？left join 除了 join 兩張表有相關的資料外, 還會把左邊表的所有不相關資料也撈出來, right join 則是會把右邊表的所有不相關資料取出 以下的 MySQL example command 的意思是？ Example:show variables like &#x27;validate_password%&#x27;; Answer:顯示密碼驗證相關訊息, 如下# validate_password.check_user_name ON# validate_password.dictionary_file # validate_password.length 8# validate_password.mixed_case_count 1# validate_password.number_count 1# validate_password.policy MEDIUM# validate_password.special_char_count 1 以下的 MySQL example command 的意思是？ Example:SELECT user,authentication_string,plugin,host FROM mysql.user; Answer:user: usernameauthentication_string: 就是 passwordplugin: 這邊是 authentication plugin, caching_sha2_password 可在 memory cache 之前使用過的 user, 增進效能host: 該 user 的 host, username + host 才是一個完整的 user 以下的 MySQL example command 的意思是？ Example:ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;FLUSH PRIVILEGES; Answer:更改 root 密碼 以下的 MySQL example command 的意思是？ Example:set global validate_password_length=3; Answer:修改密碼長度規則 以下的 MySQL example command 的意思是？ Example:set global validate_password_policy=0; Answer:修改密碼驗證原則 以下的 MySQL example command 的意思是？ Example:CREATE DATABASE mydatabase CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; Answer:建立資料庫 mydatabase, 設定 character set 為 utf8mb4, collate 為 utf8mb4_unicode_ci 以下的 MySQL example command 的意思是？ Example:mysql -uroot -pYourPassword -Bse &quot;use test; delete from testTable;&quot; Answer:從 shell 不進入 MySQL client 直接下達 command 以下的 MySQL example command 的意思是？ - Example: ```set global log_timestamps = ‘system’; - **Answer**:更改 log 的時區為系統時間###### **以下的 MySQL example command 的意思是？**- **Example**: DROP DATABASE databaseName; - **Answer**: 刪除資料庫 &lt;br&gt; ## # 參考書目 - [SQL 必知必會](https://www.tenlong.com.tw/products/9787115313980) - [MySQL 與 MariaDB 學習手冊 (Learning MySQL and MariaDB: Heading in the Right Direction with MySQL and MariaDB)](https://www.tenlong.com.tw/products/9789864763832)","link":"/zh-tw/mysql/"},{"title":"SQL - Statements","text":"# 前言本篇主要為細讀官方文件後, 整理為 Q&amp;A 的原子化翻譯筆記 Data Definition Statements# CREATE INDEX Statement# Column Prefix Key PartsMySQL 中, CREATE INDEX 可以建立 primary key index 嗎？不行 以下的 MySQL example code 的意思是? Example:CREATE INDEX part_of_name ON customer (name(10)); Answer:在 customer table 建立一個 INDEX 名為 part_of_name, prefix 為 10 MySQL 中, 有哪六種 column type 可以指定 index prefix length?CHAR, VARCHAR, BINARY, VARBINARY, BLOB, TEXT MySQL 中, 有哪兩種 column type 必定要使用 index prefix length 當建立 index 時?TEXT, BLOB MySQL 中, index prefix length 的計算方式隨著 column type 有所不同, 以下的 column type 會使用什麼單位計算, character or byte? Example:CHAR, VARCHAR, TEXT Answer:character, 每個 character 等於幾 byte 視乎 character 而有所不同, 通常英文字母為 1 byte 就夠, 中文字甚至要到 3-4 bytes MySQL 中, index prefix length 的計算方式隨著 column type 有所不同, 以下的 column type 會使用什麼單位計算, character or byte? Example:BINARY, VARBINARY, BLOB Answer:Byte MySQL 中, index prefix length 的長度限制因 row format 而有所不同, 以下的 row format 的 index prefix length 長度限制是多少？ Example:REDUNDANT, COMPACT Answer:767 bytes MySQL 中, index prefix length 的長度限制因 row format 而有所不同, 以下的 row format 的 index prefix length 長度限制是多少？ Example:DYNAMIC, COMPRESSED Answer:3072 bytes MySQL 中, 如果一個指定的 ununique INDEX prefix 超出了限制, 且 strict SQL mode enabled, 那會如何？噴錯 MySQL 中, 如果一個指定的 ununique INDEX prefix 超出了限制, 但 strict SQL mode unenabled, 那會如何？超出的長度會被截斷, 產生 warning MySQL 中, 如果一個指定的 unique INDEX prefix 超出了限制, 那會如何？不管 strict SQL mode 是否 enabled 都會噴錯, 因為如果只儲存部分 unique index 字串, 那就不符合 unique 規則 MySQL 中, 在什麼情況下, prefixed index 在效能上不會差正常 index 太多？當欄位內容的 prefix 長度字串都不一樣時, 比如說, prefix 為 10, 那如果每個 row 的 column value 前十個字都不同的話, 其實效能上跟一般 index 是差不多的 MySQL 中, 在什麼情況下, 適合使用 prefixed index?當這個 column value 前面 prefix 長度的字串幾乎都不同時 MySQL 中, prefix index 有什麼優點？可以節省 disk space, 以及提升 insert 效能 # Functional Key Parts以下的 MySQL example code 的意思是? Example:CREATE TABLE t1 ( col1 VARCHAR(10), col2 VARCHAR(20), INDEX (col1, col2(10))); Answer:該 INDEX 包含了 col1 value 以及 col2 prefix 10 個 character 以下的 MySQL example code 的意思是? Example:CREATE TABLE t1 (col1 INT, col2 INT, INDEX func_index ((ABS(col1))));CREATE INDEX idx1 ON t1 ((col1 + col2));CREATE INDEX idx2 ON t1 ((col1 + col2), (col1 - col2), col1);ALTER TABLE t1 ADD INDEX ((col1 * 40) DESC); Answer:## 建立 INDEX with function key parts, 只儲存 expression 不儲存 column valueCREATE TABLE t1 (col1 INT, col2 INT, INDEX func_index ((ABS(col1))));CREATE INDEX idx1 ON t1 ((col1 + col2));## multi functional key pars 也可同時包含 functional 以及 nonfunctionalCREATE INDEX idx2 ON t1 ((col1 + col2), (col1 - col2), col1);ALTER TABLE t1 ADD INDEX ((col1 * 40) DESC); 以下的 MySQL example code 是正確的嗎? 如果不是, 為什麼？ Example:INDEX (col1 + col2, col3 - col4) Answer:不正確function expression 必須要被包在 parentheses 中 以下的 MySQL example code 是正確的嗎? 如果不是, 為什麼？ Example:INDEX ((col1), (col2)) Answer:不正確function key part 必須是一個 function expression, 不能單單是一個 column name MySQL 中, INDEX with function key parts 可以用來定義 foreign key INDEX 嗎？不行 MySQL 中, Index with functional key parts 支援以下的語法嗎？ Example:subquery, parameters, variables, stored functions, user-defined functions Answer:不支援 MySQL 中, UNIQUE key INDEX 可以使用 functional key parts 嗎？ 可以 MySQL 中, PRIMARY key INDEX 可以使用 functional key parts 嗎？ 不行, 因為 function key parts 是用 virtual generated column 實作, 而 primary key 會需要 stored generated column MySQL 中, SPATIAL 和 FULLTEXT INDEX 支援 functional key parts 嗎？ 不支援 MySQL 中, 當一個 table 中沒有 primary key 時, 會使用哪個 INDEX 當 primary key? First UNIQUE INDEX NOT NULL MySQL 中, 當一個 table 中沒有 primary key 時, 會使用 First Unique Index Not Null 來當 primary key, 那如果該 INDEX 含有 functional key parts 的話, 支援嗎？ 不支援 MySQL 中, INDEX with nonfunctional key parts 當出現重複時, 會 warning, 那 INDEX with functional key parts 也有這個特性嗎?沒有 MySQL 中, 如果我要刪除一個被 INDEX with functional key parts refer 的 column, 需要先刪除 INDEX 嗎？需要 以下的 MySQL example code, 哪一個 query 會使用到 INDEX idx1?? Example:CREATE TABLE tbl ( col1 LONGTEXT, INDEX idx1 ((SUBSTRING(col1, 1, 10))));SELECT * FROM tbl WHERE SUBSTRING(col1, 1, 9) = &#x27;123456789&#x27;;SELECT * FROM tbl WHERE SUBSTRING(col1, 1, 10) = &#x27;1234567890&#x27;; Answer:第二個當 INDEX with functional key parts 使用 SUBSTRING 時, where clause 需符合 INDEX 以下的 MySQL example code 中, syntax 正確嗎？ 為什麼 Example:CREATE TABLE employees ( data JSON, INDEX ((data-&gt;&gt;&#x27;$.name&#x27;))); Answer:不正確-&gt;&gt; 代表 JSON_UNQUOTE(JSON_EXTRACT())JSON_UNQUOTE 會 return value with data type LONGTEXT, 所以 virtual generated column 也會是這個 data typeMySQL 若要 INDEX LONGTEXT, 一定要使用 prefix length MySQL 中, JSON_UNQUOTE return 的 string collation 是？utfmb4_binary (hardcoded) MySQL 中, CAST() return 的 string collation 是？utf8mb4_0900_ai_ci (server_default_collation) 以下的 MySQL example code, 會產生什麼問題? Example:CREATE TABLE employees ( data JSON, INDEX ((CAST(data-&gt;&gt;&#x27;$.name&#x27; AS CHAR(30)))));SELECT * FROM employees WHERE data-&gt;&gt;&#x27;$.name&#x27; = &#x27;James&#x27;; Answer:data-&gt;&gt;&#39;$.name&#39; 會取得 string with collation utf8mb4_binary(hardcoded)CAST([input] AS [format or collation]) 會上面的輸出轉為 collation 為 utf8mb4_0900_ai_ci 的 string, 並存在 virtual generated column VARCHAR(30)然而, where data-&gt;&gt;&#39;$.name&#39; 這邊的 collation 依然是 utf8mb4_binary, 如果 functional index 的輸出 collation 跟 where clause 的不同, 就 不會使用到 index 以下的 MySQL example code 會輸出哪些 records, 為什麼？ Example:CREATE TABLE employees ( data JSON, INDEX idx ((CAST(data-&gt;&gt;&quot;$.name&quot; AS CHAR(30)) COLLATE utf8mb4_bin)));INSERT INTO employees VALUES (&#x27;&#123; &quot;name&quot;: &quot;james&quot;, &quot;salary&quot;: 9000 &#125;&#x27;), (&#x27;&#123; &quot;name&quot;: &quot;James&quot;, &quot;salary&quot;: 10000 &#125;&#x27;), (&#x27;&#123; &quot;name&quot;: &quot;Mary&quot;, &quot;salary&quot;: 12000 &#125;&#x27;), (&#x27;&#123; &quot;name&quot;: &quot;Peter&quot;, &quot;salary&quot;: 8000 &#125;&#x27;);SELECT * FROM employees WHERE data-&gt;&gt;&#x27;$.name&#x27; = &#x27;James&#x27;; Answer:雖然特別使用 COLLATE 將 collation 轉為 utf8mb4_bin, 與 where clause 中的相同, 但因為 collation bin, 所以會是 case-sensitive 以下的 MySQL example code 會輸出哪些 records, 為什麼？ Example:CREATE TABLE employees ( data JSON, INDEX idx ((CAST(data-&gt;&gt;&quot;$.name&quot; AS CHAR(30)))));INSERT INTO employees VALUES (&#x27;&#123; &quot;name&quot;: &quot;james&quot;, &quot;salary&quot;: 9000 &#125;&#x27;), (&#x27;&#123; &quot;name&quot;: &quot;James&quot;, &quot;salary&quot;: 10000 &#125;&#x27;), (&#x27;&#123; &quot;name&quot;: &quot;Mary&quot;, &quot;salary&quot;: 12000 &#125;&#x27;), (&#x27;&#123; &quot;name&quot;: &quot;Peter&quot;, &quot;salary&quot;: 8000 &#125;&#x27;);SELECT * FROM employees WHERE CAST(data-&gt;&gt;&#x27;$.name&#x27; AS CHAR(30)) = &#x27;James&#x27;; Answer:index 跟 where clause 的 collation 都是 CAST() 輸出的 utf8mb4_0900_ai_ci, 所以結果會是 case-insensitive 以下的 MySQL example code 的意思是? Example1:CREATE TABLE employees ( data JSON, generated_col VARCHAR(30) AS (CAST(data-&gt;&gt;&#x27;$.name&#x27; AS CHAR(30))));INSERT INTO employees (data)VALUES (&#x27;&#123;&quot;name&quot;: &quot;james&quot;&#125;&#x27;), (&#x27;&#123;&quot;name&quot;: &quot;James&quot;&#125;&#x27;);SELECT * FROM employees WHERE data-&gt;&gt;&#x27;$.name&#x27; = &#x27;James&#x27;; Output of example1: Example2:ALTER TABLE employees ADD INDEX idx (generated_col);SELECT * FROM employees WHERE data-&gt;&gt;&#x27;$.name&#x27; = &#x27;James&#x27;; Output of example2: Answer:example 1 中, 就算沒有 CAST(), generated_col 也是吃 column 的 default collation, 然而, 因為沒有 INDEX, JSON_UNQUOTE 輸出的 string 的 collation 一律為 utf8mb4_bin, 所以結果會是 case-sensitiveexample 2 中, 如上面提到, generated_col 的 collation 為 column 預設的 collation, 假設為 utf8mb4_0900_ai_ci, 因為有新增了 INDEX, 所以會使用到 generated column 的 collation, 因此會變成 case-insensitive, 但這視乎 generated_col 的 collation, 如果我們在建立這個 column 時便指定 collation 為 utfmb4_bin, 那結果會是 case-sensitive # Unique IndexesMySQL 中, UNIQUE INDEX value 可以重複嗎？ 不行 MySQL 中, UNIQUE INDEX 允許 NULL value 嗎？ 如果該 column 是 nullable, 是允許的 MySQL 中, 如果 PRIMARY_KEY 存在, 但 PRIMARY_KEY INDEX 並不含有 single integer column, _rowid 可被使用嗎？ Answer:不可 Illustration: MySQL 中, 如果 PRIMARY_KEY 存在, 且 PRIMARY_KEY INDEX 含有 single integer column, _rowid 會參照這個 column 嗎？ Answer:會 Illustration: MySQL 中, 如果 FIRST NOT NULL UNIQUE INDEX 存在, 且含有 single integer column, _rowid 會參照這個 column 嗎？ 會哦 MySQL 中, 如果 FIRST NOT NULL UNIQUE INDEX 存在, 但不含有 single integer column, _rowid 可被使用嗎？ 不能 # Full-Text IndexesMySQL 中, FULLTEXT INDEX 只可使用在哪些 column type？CHAR, VARCHAR, TEXT # Multi-Valued IndexesMySQL 中, multi-valued index 跟 normal index 差異在於？ normal index: 一筆 index value 對應一筆 row data multi-valued index: 多筆 index value 對應一筆 row data MySQL 中, multi-valued index 主要是用在什麼 column type? JSON column type # Creating multi-values Indexes以下的 MySQL example code 的意思是? Example:CREATE TABLE customers ( id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, custinfo JSON, INDEX zips( (CAST(custinfo-&gt;&#x27;$.zip&#x27; AS UNSIGNED ARRAY)) ) ); Answer:建立一個 multi-valued INDEX zips 以下的 MySQL example code 的意思是? Example:CREATE TABLE customers ( id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, custinfo JSON );ALTER TABLE customers ADD INDEX zips( (CAST(custinfo-&gt;&#x27;$.zip&#x27; AS UNSIGNED ARRAY)) ); Answer:加入一個 multi-valued INDEX zips 以下的 MySQL example code 的意思是? Example:CREATE TABLE customers ( id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, custinfo JSON );CREATE INDEX zips ON customers ( (CAST(custinfo-&gt;&#x27;$.zip&#x27; AS UNSIGNED ARRAY)) ); Answer:建立一個 multi-valued INDEX zips 以下的 MySQL example code 的意思是? Example:CREATE TABLE customers ( id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, custinfo JSON );ALTER TABLE customers ADD INDEX comp(id, modified, (CAST(custinfo-&gt;&#x27;$.zipcode&#x27; AS UNSIGNED ARRAY)) ); Answer:建立一個 composite index, 裡面包含 multi-valued INDEX MySQL 中, 一個 composite index 可以含有幾個 multi-valued index? 一個 MySQL 中, multi-valued index 在 composite index 中的順序可以調換嗎？ 可以 以下的 MySQL example code 的意思是? Example:CREATE TABLE customers ( id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, custinfo JSON, INDEX zips( (CAST(custinfo-&gt;&#x27;$.zipcode&#x27; AS UNSIGNED ARRAY)) ) ); INSERT INTO customers VALUES (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jack&quot;,&quot;user_id&quot;:37,&quot;zipcode&quot;:[94582,94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jill&quot;,&quot;user_id&quot;:22,&quot;zipcode&quot;:[94568,94507,94582]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Bob&quot;,&quot;user_id&quot;:31,&quot;zipcode&quot;:[94477,94507]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Mary&quot;,&quot;user_id&quot;:72,&quot;zipcode&quot;:[94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Ted&quot;,&quot;user_id&quot;:56,&quot;zipcode&quot;:[94507,94582]&#125;&#x27;); SELECT * FROM customers WHERE 94507 MEMBER OF(custinfo-&gt;&#x27;$.zipcode&#x27;); Answer:建立 zips multi-valued INDEX, 支援 MEMBER OF function, 取得 94507 有出現在 custinfo-&gt;$.zipcode array 中的 row 以下的 MySQL example code 的意思是? Example:CREATE TABLE customers ( id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, custinfo JSON, INDEX zips( (CAST(custinfo-&gt;&#x27;$.zipcode&#x27; AS UNSIGNED ARRAY)) ) ); INSERT INTO customers VALUES (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jack&quot;,&quot;user_id&quot;:37,&quot;zipcode&quot;:[94582,94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jill&quot;,&quot;user_id&quot;:22,&quot;zipcode&quot;:[94568,94507,94582]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Bob&quot;,&quot;user_id&quot;:31,&quot;zipcode&quot;:[94477,94507]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Mary&quot;,&quot;user_id&quot;:72,&quot;zipcode&quot;:[94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Ted&quot;,&quot;user_id&quot;:56,&quot;zipcode&quot;:[94507,94582]&#125;&#x27;); SELECT * FROM customers WHERE JSON_CONTAINS(custinfo-&gt;&#x27;$.zipcode&#x27;, CAST(&#x27;[94507,94582]&#x27; AS JSON)); Answer:建立 zips multi-valued INDEX, 支援 JSON_CONTAINS function, 取得 94507 and 94582 有出現在 custinfo-&gt;$.zipcode array 中的 row 以下的 MySQL example code 的意思是? Example:CREATE TABLE customers ( id BIGINT NOT NULL AUTO_INCREMENT PRIMARY KEY, modified DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, custinfo JSON, INDEX zips( (CAST(custinfo-&gt;&#x27;$.zipcode&#x27; AS UNSIGNED ARRAY)) ) ); INSERT INTO customers VALUES (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jack&quot;,&quot;user_id&quot;:37,&quot;zipcode&quot;:[94582,94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jill&quot;,&quot;user_id&quot;:22,&quot;zipcode&quot;:[94568,94507,94582]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Bob&quot;,&quot;user_id&quot;:31,&quot;zipcode&quot;:[94477,94507]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Mary&quot;,&quot;user_id&quot;:72,&quot;zipcode&quot;:[94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Ted&quot;,&quot;user_id&quot;:56,&quot;zipcode&quot;:[94507,94582]&#125;&#x27;); SELECT * FROM customers WHERE JSON_OVERLAPS(custinfo-&gt;&#x27;$.zipcode&#x27;, CAST(&#x27;[94507,94582]&#x27; AS JSON)); Answer:建立 zips multi-valued INDEX, 支援 JSON_OVERLAPS function, 取得 94507 or 94582 有出現在 custinfo-&gt;$.zipcode array 中的 row # Characteristics of Multi-Valued IndexesMySQL 中, 什麼是 DML?Data Manipulation Language MySQL 中, 如果 multi-valued key part 是一個 empty array, 那會產生相應的 INDEX 嗎?不會 MySQL 中, 當我使用 multi-valued INDEX, JSON 可以含有 null 值嗎, 如下 example? Example:INSERT INTO customers VALUES (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jack&quot;,&quot;user_id&quot;:37,&quot;zipcode&quot;:[94582,94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Jill&quot;,&quot;user_id&quot;:22,&quot;zipcode&quot;:[94568,94507,94582]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Bob&quot;,&quot;user_id&quot;:31,&quot;zipcode&quot;:[94477,94507]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Mary&quot;,&quot;user_id&quot;:72,&quot;zipcode&quot;:[94536]&#125;&#x27;), (NULL, NOW(), &#x27;&#123;&quot;user&quot;:&quot;Ted&quot;,&quot;user_id&quot;:56,&quot;zipcode&quot;:null&#125;&#x27;); Answer:不行, 會 Errors Invalid JSON value, [94536, null] 也不行 以下的 Laravel example code 的意思是？ Example:CAST(data-&gt;&#x27;$.arr[*][*]&#x27; AS UNSIGNED ARRAY) Answer:雖說每一個 multi-valued index 只支援一個 multi-valued key part, 但可使用如上 example refer to 多個 array, 所有符合的 value 都會被儲存到 index, 以 flat array 的形式 MySQL 中, multi-valued index 支援 ordering 嗎？ 不支援 MySQL 中, multi-valued index 可被當成 primary key 使用嗎？ 不行 MySQL 中, multi-valued index 可以是一個 convering index 嗎？ 不行 MySQL 中, 一個 row 的 multi-valued index 的 value 數量最多可達多少？ 總長度為 65000 bytes MySQL 中, 一個 row 的 multi-valued index 的 key 數量最多可達多少？ 1604 個 key MySQL 中, multi-valued index 只接受什麼樣的 expression？ JSON expression MySQL 中, multi-valued index 使用的 JSON expression 需要指向一個 JSON document 實際上存在的 element 嗎？ 不需要, syntax 正確就行 MySQL 中, multi-valued index 支援 range scan 或 index-only scan 嗎？ 不支援 MySQL 中, multi-valued index 可使用 CAST 定義為 binary 嗎？ 不可 MySQL 中, multi-valued index 支援 online creation 嗎？ 不支援 MySQL 中, multi-valued index 只支援哪兩組 character set 與 collation binary character set 與 default binary collation utf8mb4 character set 與 default utf8mb4_0900_ai_ci collation # CREATE TABLE Statement# Secondary Indexes and Generated Columns","link":"/zh-tw/sql-statements/"},{"title":"SSH 學習筆記","text":"前言本篇為未整理的個人學習紀錄 正文 建立一組公私鑰? ssh-keygen -t rsa -b 4096 -C &quot;Ray@gmail.com&quot; 如何將指定的 key 加到 ssh-agent? ssh-add keyFile 當 private_key 的名稱不是預設的 id_rsa 時，何解？將指定的 key 加到 ssh-agent 如何打開 ssh-agent? eval &quot;$(ssh-agent -s)&quot; 在 macOS 上，當我們想要將目前這組 key 刪掉，但是新的 key 要沿用相同的檔案名稱，可能會遇到什麼問題？macOS 的 keychain 將舊的 key 記住了，導致怎麼樣都驗不過，驗到人都覺得厭世了 承上，何解？ ssh-add -K keyFile 承上，在 GCP 上何解？ ssh-add -D &amp;&amp; ssh-add keyFile GCP 上，如何安裝 ssh client ? apt-get update -y &amp;&amp; apt-get install openssh-client -y 如果我已經將 key 加到 ssh-agent, 那我還需要將 key 的實體檔案放在 .ssh 的資料夾內嗎？不需要的哦！ 如何查詢指定 Server 的公鑰？ ssh-keyscan to-be-conneted-instance-ip # 127.0.0.1 SSH-2.0-OpenSSH_6.6.1 127.0.0.1 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWBZ3XrIajPmnd6R+g/wcUuOPOiRBMOYjAl4Dv8SfcZtgHqKTK6Zb1EeG3u/uzRYxqXMctG/2A4iXRDG9mvg9H9bimCWbA3xtR79NImPYg4m7BNuH9C+OXRYYJwoOGpjVMs0rGLXkq3/WVkXvQreBuhVD8NI2pEPnQsT1J5abdVbCHlwFYG6wVCJQqFY6jdntJJlxQv5EJu6w4/+Fd4LvdjysH+ngqArac6HMJUxqSxLQjzMdCRWEQKp3ySwmnRp9rHYVaJnnsXeYPfnMN1iMjdIQJPzc89Mepg4ip1q2bCMbMcx2XFO3I7YjYRdcOameFNafMGY0q5RHzhvgnNnal # 127.0.0.1 SSH- 2.0-OpenSSH_6.6.1 127.0.0.1 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/C+HTCqbDgso4mCKpMo= # 127.0.0.2 SSH-2.0-OpenSSH_6.6.1127.0.0.2 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWBZ3XrIajPmnd6R+g/wcUuOPOiRBMOYjAl4Dv8SfcZtgHqKTK6Zb1EeG3u/uzRYxqXMctG/2A4iXRDG9mvg9H9bimCWbA3xtR79NImPYg4m7BNuH9C+OXRYYJwoOGpjVMs0rGLXkq3/WVkXvQreBuhVD8NI2pEPnQsT1J5abdVbCHlwFYG6wVCJQqFY6jdntJJlxQv5EJu6w4/+Fd4LvdjysH+ngqArac6HMJUxqSxLQjzMdCRWEQKp3ySwmnRp9rHYVaJnnsXeYPfnMN1iMjdIQJPzc89Mepg4ip1q2bCMbMcx2XFO3I7YjYRdcOameFNafMGY0q5RHzhvgnNnal # 127.0.0.2 SSH-2.0-OpenSSH_6.6.1 127.0.0.2 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/ C+HTCqbDgso4mCKpMo= 取最短的那組即可，例如： 127.0.0.2 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/ C+HTCqbDgso4mCKpMo= 當我們初次從 a 電腦 經由 ssh 連到 b 電腦時，當 a 電腦要將 b 電腦的公鑰加到 known_host 檔案時，會跳出詢問視窗 yes/no, 如何避免掉這個視窗？ ssh -o StrictHostKeyChecking=no 如何在 GitHub 以及 Gitlab 上使用不同的 key # GitLabHost gitlab.com Preferredauthentications publickey IdentityFile ~/.ssh/gitlab # GitHubHost github.com Preferredauthentications publickey IdentityFile ~/.ssh/github scp利用 config 檔案來驗證scp -F SSHconfig sourceFile targetUser@targetIP:targetLocation 如果是要傳資料夾過去 scp -F SSHconfig -r sourceFile targetUser@targetIP:targetLocation 利用 private key 產生 public keyssh-keygen -y -f fileName 把公鑰傳到遠端主機ssh-copy-id -i key.pub user@IP 啟動密碼登入 打開 ssh 配置檔 vim /etc/ssh/sshd.config 修改設定如下 # To disable tunneled clear text passwords, change to no here!PasswordAuthentication yes 重啟 ssh systemctl restart ssh 在 Git 指令中指定 key&quot;SSH -i /root/.ssh/id_rsa&quot; git clone git@gitlab.com:qcdn/qcdn-aircraft-carrier.git SFTP語法sftp account@ip 用法針對遠方伺服器主機 (Server) 之行為 針對本機 (Client) 之行為 (都加上 l, L 的小寫) 針對資料上傳/下載的行為 SCP語法[root@www ~]# scp [-pr] [-l 速率] file [帳號@]主機:目錄名 &lt;==上傳[root@www ~]# scp [-pr] [-l 速率] [帳號@]主機:file 目錄名 &lt;==下載選項與參數：-p ：保留原本檔案的權限資料；-r ：複製來源為目錄時，可以複製整個目錄 (含子目錄)-l ：可以限制傳輸的速度，單位為 Kbits/s ，例如 [-l 800] 代表傳輸速限 100Kbytes/s 範例將本機的 /etc/hosts* 全部複製到 127.0.0.1 上面的 student 家目錄內scp /etc/hosts* student@127.0.0.1:~ 將 127.0.0.1 這部遠端主機的 /etc/bashrc 複製到本機的 /tmp 底下scp student@127.0.0.1:/etc/bashrc /tmp sshd 設定檔[root@www ~]# vim /etc/ssh/sshd_config# 1. 關於 SSH Server 的整體設定，包含使用的 port 啦，以及使用的密碼演算方式# Port 22# SSH 預設使用 22 這個port，也可以使用多個port，即重複使用 port 這個設定項目！# 例如想要開放 sshd 在 22 與 443 ，則多加一行內容為：『 Port 443 』# 然後重新啟動 sshd 這樣就好了！不過，不建議修改 port number 啦！Protocol 2# 選擇的 SSH 協定版本，可以是 1 也可以是 2 ，CentOS 5.x 預設是僅支援 V2。# 如果想要支援舊版 V1 ，就得要使用『 Protocol 2,1 』才行。# ListenAddress 0.0.0.0# 監聽的主機介面卡！舉個例子來說，如果你有兩個 IP，分別是 192.168.1.100 及 # 192.168.100.254，假設你只想要讓 192.168.1.100 可以監聽 sshd ，那就這樣寫：# 『 ListenAddress 192.168.1.100 』預設值是監聽所有介面的 SSH 要求# PidFile /var/run/sshd.pid# 可以放置 SSHD 這個 PID 的檔案！上述為預設值# LoginGraceTime 2m# 當使用者連上 SSH server 之後，會出現輸入密碼的畫面，在該畫面中，# 在多久時間內沒有成功連上 SSH server 就強迫斷線！若無單位則預設時間為秒！# Compression delayed# 指定何時開始使用壓縮資料模式進行傳輸。有 yes, no 與登入後才將資料壓縮 (delayed)# 2. 說明主機的 Private Key 放置的檔案，預設使用下面的檔案即可！# HostKey /etc/ssh/ssh_host_key # SSH version 1 使用的私鑰# HostKey /etc/ssh/ssh_host_rsa_key # SSH version 2 使用的 RSA 私鑰# HostKey /etc/ssh/ssh_host_dsa_key # SSH version 2 使用的 DSA 私鑰# 還記得我們在主機的 SSH 連線流程裡面談到的，這裡就是 Host Key ～# 3. 關於登錄檔的訊息資料放置與 daemon 的名稱！SyslogFacility AUTHPRIV# 當有人使用 SSH 登入系統的時候，SSH 會記錄資訊，這個資訊要記錄在什麼 daemon name# 底下？預設是以 AUTH 來設定的，即是 /var/log/secure 裡面！什麼？忘記了！# 回到 Linux 基礎去翻一下。其他可用的 daemon name 為：DAEMON,USER,AUTH,# LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5,# LogLevel INFO# 登錄記錄的等級！嘿嘿！任何訊息！同樣的，忘記了就回去參考！# 4. 安全設定項目！極重要！# 4.1 登入設定部分# PermitRootLogin yes# 是否允許 root 登入！預設是允許的，但是建議設定成 no！# StrictModes yes# 是否讓 sshd 去檢查使用者家目錄或相關檔案的權限資料，# 這是為了擔心使用者將某些重要檔案的權限設錯，可能會導致一些問題所致。# 例如使用者的 ~.ssh/ 權限設錯時，某些特殊情況下會不許用戶登入# PubkeyAuthentication yes# AuthorizedKeysFile .ssh/authorized_keys# 是否允許用戶自行使用成對的金鑰系統進行登入行為，僅針對 version 2。# 至於自製的公鑰資料就放置於使用者家目錄下的 .ssh/authorized_keys 內PasswordAuthentication yes# 密碼驗證當然是需要的！所以這裡寫 yes 囉！# PermitEmptyPasswords no# 若上面那一項如果設定為 yes 的話，這一項就最好設定為 no ，# 這個項目在是否允許以空的密碼登入！當然不許！# 4.2 認證部分# RhostsAuthentication no# 本機系統不使用 .rhosts，因為僅使用 .rhosts太不安全了，所以這裡一定要設定為 no# IgnoreRhosts yes# 是否取消使用 ~/.ssh/.rhosts 來做為認證！當然是！# RhostsRSAAuthentication no ## 這個選項是專門給 version 1 用的，使用 rhosts 檔案在 /etc/hosts.equiv# 配合 RSA 演算方式來進行認證！不要使用啊！# HostbasedAuthentication no# 這個項目與上面的項目類似，不過是給 version 2 使用的！# IgnoreUserKnownHosts no# 是否忽略家目錄內的 ~/.ssh/known_hosts 這個檔案所記錄的主機內容？# 當然不要忽略，所以這裡就是 no 啦！ChallengeResponseAuthentication no# 允許任何的密碼認證！所以，任何 login.conf 規定的認證方式，均可適用！# 但目前我們比較喜歡使用 PAM 模組幫忙管理認證，因此這個選項可以設定為 no 喔！UsePAM yes# 利用 PAM 管理使用者認證有很多好處，可以記錄與管理。# 所以這裡我們建議你使用 UsePAM 且 ChallengeResponseAuthentication 設定為 no # 4.3 與 Kerberos 有關的參數設定！因為我們沒有 Kerberos 主機，所以底下不用設定！# KerberosAuthentication no# KerberosOrLocalPasswd yes# KerberosTicketCleanup yes# KerberosTgtPassing no # 4.4 底下是有關在 X-Window 底下使用的相關設定！X11Forwarding yes# X11DisplayOffset 10# X11UseLocalhost yes# 比較重要的是 X11Forwarding 項目，他可以讓視窗的資料透過 ssh 通道來傳送喔！# 在本章後面比較進階的 ssh 使用方法中會談到。# 4.5 登入後的項目：# PrintMotd yes# 登入後是否顯示出一些資訊呢？例如上次登入的時間、地點等等，預設是 yes# 亦即是列印出 /etc/motd 這個檔案的內容。但是，如果為了安全，可以考慮改為 no ！# PrintLastLog yes# 顯示上次登入的資訊！可以啊！預設也是 yes ！# TCPKeepAlive yes# 當達成連線後，伺服器會一直傳送 TCP 封包給用戶端藉以判斷對方式否一直存在連線。# 不過，如果連線時中間的路由器暫時停止服務幾秒鐘，也會讓連線中斷喔！# 在這個情況下，任何一端死掉後，SSH可以立刻知道！而不會有僵屍程序的發生！# 但如果你的網路或路由器常常不穩定，那麼可以設定為 no 的啦！UsePrivilegeSeparation yes# 是否使用權限較低的程序來提供使用者操作。我們知道 sshd 啟動在 port 22 ，# 因此啟動的程序是屬於 root 的身份。那麼當 student 登入後，這個設定值# 會讓 sshd 產生一個屬於 sutdent 的 sshd 程序來使用，對系統較安全MaxStartups 10# 同時允許幾個尚未登入的連線畫面？當我們連上 SSH ，但是尚未輸入密碼時，# 這個時候就是我們所謂的連線畫面啦！在這個連線畫面中，為了保護主機，# 所以需要設定最大值，預設最多十個連線畫面，而已經建立連線的不計算在這十個當中# 4.6 關於使用者抵擋的設定項目：DenyUsers *# 設定受抵擋的使用者名稱，如果是全部的使用者，那就是全部擋吧！# 若是部分使用者，可以將該帳號填入！例如下列！DenyUsers testDenyGroups test# 與 DenyUsers 相同！僅抵擋幾個群組而已！# 5. 關於 SFTP 服務與其他的設定項目！Subsystem sftp /usr/lib/ssh/sftp-server# UseDNS yes# 一般來說，為了要判斷用戶端來源是正常合法的，因此會使用 DNS 去反查用戶端的主機名# 不過如果是在內網互連，這項目設定為 no 會讓連線達成速度比較快。 安全設定/etc/ssh/sshd_config# 1. 先觀察一下所需要的帳號是否存在呢？[root@www ~]# for user in sshnot1 sshnot2 sshnot3 testssh student; do \\&gt; id $user | cut -d &#x27; &#x27; -f1-3 ; doneuid=507(sshnot1) gid=509(sshnot1) groups=509(sshnot1),508(nossh)uid=508(sshnot2) gid=510(sshnot2) groups=510(sshnot2),508(nossh)uid=509(sshnot3) gid=511(sshnot3) groups=511(sshnot3),508(nossh)uid=511(testssh) gid=513(testssh) groups=513(testssh)uid=505(student) gid=506(student) groups=506(student)# 若上述帳號並不存在你的系統，請自己建置出來！UID/GID 與鳥哥的不同也沒關係！# 2. 修改 sshd_config 並且重新啟動 sshd 吧！[root@www ~]# vim /etc/ssh/sshd_configPermitRootLogin no &lt;==約在第 39 行，請拿掉註解且修改成這樣DenyGroups nossh &lt;==底下這兩行可以加在檔案的最後面DenyUsers testssh[root@www ~]# /etc/init.d/sshd restart# 3. 測試與觀察相關的帳號登入情況吧！[root@www ~]# ssh root@localhost &lt;==並請輸入正確的密碼[root@www ~]# tail /var/log/secureJul 25 13:14:05 www sshd[2039]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=localhost user=root# 你會發現出現這個錯誤訊息，而不是密碼輸入錯誤而已。[root@www ~]# ssh sshnot1@localhost &lt;==並請輸入正確的密碼[root@www ~]# tail /var/log/secureJul 25 13:15:53 www sshd[2061]: User sshnot1 from localhost not allowed becausea group is listed in DenyGroups[root@www ~]# ssh testssh@localhost &lt;==並請輸入正確的密碼[root@www ~]# tail /var/log/secureJul 25 13:17:16 www sshd[2074]: User testssh from localhost not allowed because listed in DenyUsers /etc/hosts/allow, /etc/hosts.deny[root@www ~]# vim /etc/hosts.allowsshd: 127.0.0.1 192.168.1.0/255.255.255.0 192.168.100.0/255.255.255.0[root@www ~]# vim /etc/hosts.denysshd : ALL iptables 封包過濾防火牆[root@www ~]# vim /usr/local/virus/iptables/iptables.allowiptables -A INPUT -i $EXTIF -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPTiptables -A INPUT -i $EXTIF -s 192.168.100.0/24 -p tcp --dport 22 -j ACCEPT[root@www ~]# /usr/local/virus/iptables/iptables.rule 設定 ssh 在不同 port 口新增 port[root@www ~]# vim /etc/ssh/sshd_configPort 22Port 23 &lt;==注意喔！要有兩個 Port 的設定才行！[root@www ~]# /etc/init.d/sshd restart 自定義 SELinux 規則放行模組# 1. 於 /var/log/audit/audit.log 找出與 ssh 有關的 AVC 資訊，並轉為本地模組[root@www ~]# cat /var/log/audit/audit.log | grep AVC | grep ssh | \\&gt; audit2allow -m sshlocal &gt; sshlocal.te &lt;==副檔名要是 .te 才行[root@www ~]# grep sshd_t /var/log/audit/audit.log | \\&gt; audit2allow -M sshlocal &lt;==sshlocal 就是剛剛建立的 .te 檔名******************** IMPORTANT ***********************To make this policy package active, execute:semodule -i sshlocal.pp &lt;==這個指令會編譯出這個重要的 .pp 模組！# 2. 將這個模組載入系統的 SELinux 管理當中！[root@www ~]# semodule -i sshlocal.pp# 3. 再重新啟動 sshd 並且觀察埠口吧！[root@www ~]# /etc/init.d/sshd restart[root@www ~]# netstat -tlunp | grep sshtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 7322/sshdtcp 0 0 0.0.0.0:23 0.0.0.0:* LISTEN 7322/sshdtcp 0 0 :::22 :::* LISTEN 7322/sshdtcp 0 0 :::23 :::* LISTEN 7322/sshd 非正規 port 號連接方式[root@www ~]# ssh -p 23 root@localhostroot@localhost&#x27;s password:Last login: Tue Jul 26 14:07:41 2011 from 192.168.1.101[root@www ~]# netstat -tnp | grep 23tcp 0 0 ::1:23 ::1:56645 ESTABLISHED 7327/2tcp 0 0 ::1:56645 ::1:23 ESTABLISHED 7326/ssh# 因為網路是雙向的，因此自己連自己 (localhost)，就會抓到兩隻連線！ Q&amp;A SSH 的全寫是？Secure SHell protocol SSH 中, 公鑰的作用？提供給遠端主機進行資料加密, 也就是說, 每個人都可以有你的公鑰, 用來加密要傳送給你的資料 SSH 中, 私鑰的作用？公鑰用來加密要傳送給你的資料, 而私鑰用來解密這些資料 如果有兩台電腦利用 SSH 來互相傳送資料, 共有至少幾把公鑰, 幾把私鑰？兩把公鑰, 兩把私鑰 非對稱式金鑰系統是什麼意思？伺服器：『具有伺服器的私鑰與用戶端的公鑰』，而用戶端則是： 『具有伺服器的公鑰以及用戶端自己的私鑰』 SSH 連線的具體步驟？ 用戶端對伺服器端發出主動連線要求 伺服器端回傳伺服器公鑰 用戶端紀錄/比對伺服器公鑰 用戶端回傳伺服器用戶端公鑰 開始加解密 SSH 中, 當我們接收到對方電腦的公鑰時, 會儲存在哪？~/.ssh/known_hosts SSH 中, 自家預設的公鑰會放在哪？/etc/ssh/ssh_host* 如何產生新的伺服器端的 ssh 公私鑰? rm /etc/ssh/ssh_host*/etc/init.d/sshd restart 在 sftp 中, 我可以隨意更改 local 或 remote 的資料夾所在位置嗎？可以哦, 可以參考這裏 在 scp 中, 保留原本檔案的權限資料嗎？可以哦, 可以參考這裏 在 ssh 中, 可以開啟多個 port 且都使用在 ssh 上嗎？可以哦！ 請參考sshd 設定檔 在 ssh-keygen 中, 如果我沒有特別指令密碼演算法的話, 預設是哪一種？RSA .ssh 目錄的權限必須要是多少？700 ssh 中, 私鑰的權限必須得是多少？600 ssh 中, 私鑰的擁有者必須得是誰？該 user 目錄下的擁有者 ssh 中, 如果自建 key-pair 卻無法通過驗證, 很有可能是甚麼原因？sshd 檔案中的 AuthorizedKeysFile 設定沒有打開, 可參考 sshd 設定檔 ssh 中, 如果我是透過自建 key 的方式, 那我公鑰應該要放在伺服器端的哪個檔案中？預設檔名為 .ssh/authorized_keys, 可透過 sshd 設定檔 修改 ssh 中, 如果我是透過自建 key 的方式, 預設的伺服器端公鑰放置檔案 authorized_keys 的權限該設定為多少？644 ssh 中, 如果登入失敗, log 可以在哪裡看？ tail /var/log/secure ssh 中, 可以限制僅有指定的 user 或 group 才可經由 ssh 登入嗎？可, 可參考 sshd config ssh 中, 可以限制僅有指定的 IP 才可經由 ssh 登入嗎？可, 可參考 hosts.allow &amp; hosts.deny ssh 中, 可以透過 iptable 限制指定的 ip 才可經由 ssh 登入嗎？可, 可參考 iptables.allow &amp; iptables.rule ssh 中, 我可以修改預設 port 22 到別的 port 號嗎？可以, 可參考 ssh port 號變更","link":"/zh-tw/ssh/"},{"title":"在 MacOS 及 AWS 上部署 supervisor","text":"部署 supervisor前言本篇重點如下： 在 Mac OS 上安裝並部署 Supervisor 在 AWS 上安裝並部署 Supervisor Supervisor是什麼？Supervisor 是一套程序管理系統。因為 Ray 的專案有使用到 Laravel 的 queue ，而 queue 必須要常駐在背景執行，那要是不小心失敗或中斷了怎麼辦呢？ supervisor 可以確保當 queue 失敗中斷時，自動地幫我們重啟。 Mac OS安裝 安裝 Supervisorbrew install supervisor 配置 進到預設設定檔 vim /usr/local/etc/supervisord.ini 更改預設 include 目錄，到最後一行，修改如下 [include]files = /usr/local/etc/supervisor.d/*.conf 新增客製化配置目錄及檔案 mkdir /usr/local/etc/supervisor.d;vim /usr/local/etc/supervisor.d/processNameYouLike.conf; 輸入下面的設定 [program:programNameYouLike]process_name=%(program_name)s_%(process_num)02dcommand=php absoluteAddressOfYourProject/artisan queue:work sqs --sleep=3 --tries=3 --daemonautostart=trueautorestart=trueuser=raynumprocs=8redirect_stderr=truestdout_logfile=/absoluteAddressOfLocationYouWouldLikeToPutTheLog/worker.log 啟動 啟動服務 sudo supervisord -c /usr/local/etc/supervisord.ini 進到控制台 sudo supervisorctl -c /usr/local/etc/supervisord.ini 更新配置 update 查看狀態 status 看起來如下： AWSAmazon Linux 2 AMI本篇記錄使用的AWS型號如下： Amazon Linux 2 AMI (HVM), SSD Volume Type - ami-0f9ae750e8274075b t2.micro (Variable ECUs, 1 vCPUs, 2.5 GHz, Intel Xeon Family, 1 GiB memory, EBS only) 安裝 安裝 supervisorsudo yum install -y supervisor 配置 到預設設定檔 sudo vim /etc/supervisord.conf 更改最後一行 include 的目錄 [include]files = supervisord.d/*.conf 新增配置檔，如果資料夾不存在就創建 sudo mkdir /etc/supervisord.d;sudo vim /etc/supervisord.d/projectFileNameYouLike.conf 新增配置 [program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=sudo php absoluteAddressOfYourProject/artisan queue:work sqs --sleep=3 --tries=3 --daemonautostart=trueautorestart=trueuser=rootnumprocs=8redirect_stderr=truestdout_logfile=absoluteAddressOfYourProject/worker.log 啟動 啟動 supervisor sudo supervisord -c /etc/supervisord.conf 套用新的配置檔並查看狀態 sudo supervisorctl update;sudo supervisorctl status 配置自動重啟 增加重啟配置檔 sudo vim /etc/init.d/supervisord 輸入以下配置 #! /bin/sh### BEGIN INIT INFO# Provides: supervisord# Required-Start: $remote_fs# Required-Stop: $remote_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Example initscript# Description: This file should be used to construct scripts to be# placed in /etc/init.d.### END INIT INFO# Author: Dan MacKinlay &lt;danielm@phm.gov.au&gt;# Based on instructions by Bertrand Mathieu# http://zebert.blogspot.com/2009/05/installing-django-solr-varnish-and.html# Do NOT &quot;set -e&quot;# PATH should only include /usr/* if it runs after the mountnfs.sh scriptPATH=/sbin:/usr/sbin:/bin:/usr/binDESC=&quot;Description of the service&quot;NAME=supervisordDAEMON=/usr/local/bin/supervisordDAEMON_ARGS=&quot;&quot;PIDFILE=/var/run/$NAME.pidSCRIPTNAME=/etc/init.d/$NAME# Exit if the package is not installed[ -x &quot;$DAEMON&quot; ] || exit 0# Read configuration variable file if it is present[ -r /etc/default/$NAME ] &amp;&amp; . /etc/default/$NAME# Load the VERBOSE setting and other rcS variables. /lib/init/vars.sh# Define LSB log_* functions.# Depend on lsb-base (&gt;= 3.0-6) to ensure that this file is present.. /lib/lsb/init-functions## Function that starts the daemon/service#do_start()&#123; # Return # 0 if daemon has been started # 1 if daemon was already running # 2 if daemon could not be started start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --test &gt; /dev/null \\ || return 1 start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \\ $DAEMON_ARGS \\ || return 2 # Add code here, if necessary, that waits for the process to be ready # to handle requests from services started subsequently which depend # on this one. As a last resort, sleep for some time.&#125;## Function that stops the daemon/service#do_stop()&#123; # Return # 0 if daemon has been stopped # 1 if daemon was already stopped # 2 if daemon could not be stopped # other if a failure occurred start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME RETVAL=&quot;$?&quot; [ &quot;$RETVAL&quot; = 2 ] &amp;&amp; return 2 # Wait for children to finish too if this is a daemon that forks # and if the daemon is only ever run from this initscript. # If the above conditions are not satisfied then add some other code # that waits for the process to drop all resources that could be # needed by services started subsequently. A last resort is to # sleep for some time. start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $DAEMON [ &quot;$?&quot; = 2 ] &amp;&amp; return 2 # Many daemons don&#x27;t delete their pidfiles when they exit. rm -f $PIDFILE return &quot;$RETVAL&quot;&#125;## Function that sends a SIGHUP to the daemon/service#do_reload() &#123; # # If the daemon can reload its configuration without # restarting (for example, when it is sent a SIGHUP), # then implement that here. # start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME return 0&#125;case &quot;$1&quot; in start) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_daemon_msg &quot;Starting $DESC&quot; &quot;$NAME&quot; do_start case &quot;$?&quot; in 0|1) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 0 ;; 2) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 1 ;; esac ;; stop) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_daemon_msg &quot;Stopping $DESC&quot; &quot;$NAME&quot; do_stop case &quot;$?&quot; in 0|1) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 0 ;; 2) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 1 ;; esac ;; #reload|force-reload) # # If do_reload() is not implemented then leave this commented out # and leave &#x27;force-reload&#x27; as an alias for &#x27;restart&#x27;. # #log_daemon_msg &quot;Reloading $DESC&quot; &quot;$NAME&quot; #do_reload #log_end_msg $? #;; restart|force-reload) # # If the &quot;reload&quot; option is implemented then remove the # &#x27;force-reload&#x27; alias # log_daemon_msg &quot;Restarting $DESC&quot; &quot;$NAME&quot; do_stop case &quot;$?&quot; in 0|1) do_start case &quot;$?&quot; in 0) log_end_msg 0 ;; 1) log_end_msg 1 ;; # Old process is still running *) log_end_msg 1 ;; # Failed to start esac ;; *) # Failed to stop log_end_msg 1 ;; esac ;; *) #echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart|reload|force-reload&#125;&quot; &gt;&amp;2 echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart|force-reload&#125;&quot; &gt;&amp;2 exit 3 ;;esac: script來源 增加權限 sudo chmod +x /etc/init.d/supervisord 將新增的開機重啟配置檔加到系統 sudo chkconfig --add supervisord 打開自動重啟功能，並開始 sudo chkconfig supervisord on;sudo service supervisord start Amazon Linux 2 AMI型號： Amazon Linux AMI 2018.03.0 (HVM), SSD Volume Type - ami-00a5245b4816c38e6 安裝 安裝 supervisor sudo easy_install supervisor 將 /usr/local/bin 加到 sudo path sudo vim /etc/sudoers Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin 配置 建立設定檔 sudo su -sudo echo_supervisord_conf &gt; /etc/supervisord.conf;sudo vim /etc/supervisord.conf 更改最後一行 include 的目錄 [include]files = /etc/supervisord.d/*.conf 新增配置檔，如果資料夾不存在就創建 sudo mkdir /etc/supervisord.d;sudo vim /etc/supervisord.d/projectFileNameYouLike.conf 新增配置 [program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=php absoluteAddressOfYourProject/artisan queue:work sqs --sleep=3 --tries=3 --daemonautostart=trueautorestart=trueuser=apachenumprocs=8redirect_stderr=truestdout_logfile=absoluteAddressOfYourProject/worker.log 啟動 啟動 supervisor sudo supervisord -c /etc/supervisord.conf 套用新的配置檔並查看狀態 sudo supervisorctl update;sudo supervisorctl status 配置自動重啟 增加重啟配置檔 sudo vim /etc/init.d/supervisord 輸入以下配置 #!/bin/bash## supervisord Startup script for the Supervisor process control system## Author: Mike McGrath &lt;mmcgrath@redhat.com&gt; (based off yumupdatesd)# Jason Koppe &lt;jkoppe@indeed.com&gt; adjusted to read sysconfig,# use supervisord tools to start/stop, conditionally wait# for child processes to shutdown, and startup later# Erwan Queffelec &lt;erwan.queffelec@gmail.com&gt;# make script LSB-compliant## chkconfig: 345 83 04# description: Supervisor is a client/server system that allows \\# its users to monitor and control a number of processes on \\# UNIX-like operating systems.# processname: supervisord# config: /etc/supervisord.conf# config: /etc/sysconfig/supervisord# pidfile: /var/run/supervisord.pid#### BEGIN INIT INFO# Provides: supervisord# Required-Start: $all# Required-Stop: $all# Short-Description: start and stop Supervisor process control system# Description: Supervisor is a client/server system that allows# its users to monitor and control a number of processes on# UNIX-like operating systems.### END INIT INFO# Source function library. /etc/rc.d/init.d/functions# Source system settingsif [ -f /etc/sysconfig/supervisord ]; then . /etc/sysconfig/supervisordfi# Path to the supervisorctl script, server binary,# and short-form for messages.supervisorctl=/usr/local/bin/supervisorctlsupervisord=$&#123;SUPERVISORD-/usr/local/bin/supervisord&#125;prog=supervisordpidfile=$&#123;PIDFILE-/tmp/supervisord.pid&#125;lockfile=$&#123;LOCKFILE-/var/lock/subsys/supervisord&#125;STOP_TIMEOUT=$&#123;STOP_TIMEOUT-60&#125;OPTIONS=&quot;$&#123;OPTIONS--c /etc/supervisord.conf&#125;&quot;RETVAL=0start() &#123; echo -n $&quot;Starting $prog: &quot; daemon --pidfile=$&#123;pidfile&#125; $supervisord $OPTIONS RETVAL=$? echo if [ $RETVAL -eq 0 ]; then touch $&#123;lockfile&#125; $supervisorctl $OPTIONS status fi return $RETVAL&#125;stop() &#123; echo -n $&quot;Stopping $prog: &quot; killproc -p $&#123;pidfile&#125; -d $&#123;STOP_TIMEOUT&#125; $supervisord RETVAL=$? echo [ $RETVAL -eq 0 ] &amp;&amp; rm -rf $&#123;lockfile&#125; $&#123;pidfile&#125;&#125;reload() &#123; echo -n $&quot;Reloading $prog: &quot; LSB=1 killproc -p $pidfile $supervisord -HUP RETVAL=$? echo if [ $RETVAL -eq 7 ]; then failure $&quot;$prog reload&quot; else $supervisorctl $OPTIONS status fi&#125;restart() &#123; stop start&#125;case &quot;$1&quot; in start) start ;; stop) stop ;; status) status -p $&#123;pidfile&#125; $supervisord RETVAL=$? [ $RETVAL -eq 0 ] &amp;&amp; $supervisorctl $OPTIONS status ;; restart) restart ;; condrestart|try-restart) if status -p $&#123;pidfile&#125; $supervisord &gt;&amp; /dev/null; then stop start fi ;; force-reload|reload) reload ;; *) echo $&quot;Usage: $prog &#123;start|stop|restart|condrestart|try-restart|force-reload|reload&#125;&quot; RETVAL=2 esac exit $RETVAL script來源 增加權限 sudo chmod +x /etc/init.d/supervisord 將新增的開機重啟配置檔加到系統 sudo chkconfig --add supervisord 打開自動重啟功能，並開始 sudo chkconfig supervisord on;sudo service supervisord start 在設定好配置檔之前，如何關閉 supervisord ? ps -ef | grep supervisord kill -s SIGTERM 29646 結論完成設定後，每次 reboot ， AWS 就會自動地重啟 supervisor","link":"/zh-tw/supervisor/"},{"title":"在 PayPal 的 IPN 方式中，提交多個商品","text":"前言這篇文章將分享，當我們使用 PayPal 的 IPN 結帳方式時，如何提交多個商品，每個商品擁有各自的名稱，價格，以及數量。 本文章是我從官網 複製下來的, 因為我不知道未來什麼時候會用到，而且我實在懶得再去找一次。 本文開始有些網站開發人員可能希望將PayPal付款處理集成到他們自己的第三方購物車上，而不是標準的PayPal購物車上。請使用以下說明為您的買家提供PayPal付款，以便他們在您的第三方購物車上添加購置物品後結賬時使用。 將您的第三方購物車與PayPal的付款流程集成目前有兩種方法。第一種方法是傳遞購物車付款總額，而不是單個物品金額。第二種方法是將所選物品詳情傳遞給PayPal，而不是總購物車數量。提示：按下述步驟粘貼必需的變量到PayPal時，可能需要在您的網站上執行某些腳本。 方法 1. 將總購物車數量傳遞給PayPal 方法 2. 將單個物品傳遞給PayPal 方法1. 將總購物車數量傳遞給PayPal如果願意，您可以累加整個購物車，將總數量傳遞給PayPal的立即購買按鈕代碼（也就是說，您需要粘貼整個購物車的單一名稱及其物品總價款，與購買單件物品一樣）。 該方法有一個不足之處，您的買家將無法查看其購物車中的單個物品。此外，您不能修改我們的變量名稱，也不能添加您自己的變量名稱。 查閱以下信息後如有其他技術問題，請訪問我們的 開發者服務網頁。欲知有關“立即購買”按鈕代碼或以下變量的附加信息，請查看網站付款標準版集成指南。 必需的變量向PayPal提交粘貼代碼時，應包括以下 4 個隱藏變量及一張圖片： 姓名 值 business 您的PayPal賬戶上的電子郵件地址 item_name 物品名稱（或購物車名稱） currency_code 定義幣種以標示貨幣變量（金額、運送費、運送費2、手續費、稅款）。值可以為”USD”、”EUR”、”GBP”、”CAD”、”JPY”。 amount 物品的價格（購物車中所有物品的總價格） image 按鈕圖片，您的買家按此按鈕開始PayPal付款程序。您可以將src 更換為圖片URL，以使用您自己的圖片 這就是說，您粘貼到PayPal的最短必需代碼應如下： &lt;form action=&quot;https://www.paypal.com/cgi-bin/webscr&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_xclick&quot;&gt; &lt;input type=&quot; hidden&quot; name=&quot;business&quot; value=&quot;you@youremail.com&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;item_name&quot; value=&quot;Item Name&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;currency_code&quot; value= &quot;USD&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;0.00&quot;&gt; &lt;input type=&quot;image&quot; src=&quot;http://www.paypal.com/zh_XC/i/btn/x- click-but01.gif&quot; name=&quot;submit&quot; alt=&quot;Make payments with PayPal - it&#x27;s fast, free and secure!&quot;&gt; &lt;/form&gt; PayPal提供附加變量，用於自定義您的Form Post。所有可用變量如下（變量名稱必須用小寫）： 可用變量 姓名 值 business 您的PayPal賬戶上的電子郵件地址 quantity 物品數量。大於1 時，會與金額相乘 item_name 物品名稱（或購物車名稱）。必須是字母數字字符，最多為127 個字符 item_number 用於跟踪付款的可選傳遞變量。必須是字母數字字符，最多為127 個字符 amount 物品的價格（購物車中所有物品的總價格） shipping 該物品的運送成本 shipping2 每增加一件物品所需的運送成本 handling 手續費 tax 基於交易的稅額。如果使用該變量，傳遞值將覆蓋所有用戶信息稅收設置（不管買家所在位置）。 no_shipping 送貨地址。如果設為”1”，則不會要求您的客戶提供送貨地址。該變量為可選項；如果省略或設為”0”，將提示您的客戶輸入送貨地址 cn 可選標籤，會在提示欄上顯示（最多40 個字符） no_note 為付款加入提示。如果設為”1”，則不會提示您的客戶輸入提示。該變量為可選項；如果省略或設為”0”，將提示您的客戶輸入提示。 on0 第一選項欄名稱。最多64 個字符 os0 第一組選項值。最多200 個字符。”on0” 必須定義，以便識別”os0”。 on1 第二選項欄名稱。最多64 個字符 os1 第二組選項值。最多200 個字符。”on1” 必須定義，以便識別”os1”。 custom 決不會向您的客戶顯示的可選轉遞變量。可用於跟踪庫存 invoice 決不會向您的客戶顯示的可選轉遞變量。可用於跟踪賬單號 notify_url 僅與IPN 一起使用。發送IPN Form Post 的互聯網URL return 您的客戶完成付款後將返回的互聯網URL cancel_return 您的客戶取消付款後將返回的互聯網URL image_url 您要用作圖標的圖片的互聯網URL，圖片大小為150 X 50 像素 cs 設置您的付款頁面的背景色。如果設為”1”，背景色將為黑色。該變量為可選項；如果省略或設為”0”，背景色將為白色 擴展變量 PayPal允許您粘貼擴展變量，條件是將改變以下”cmd”值： &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_xclick&quot;&gt; 到： &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_ext-enter&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;redirect_cmd&quot; value=&quot;_xclick&quot;&gt; 通過上述”cmd” 值修改，您還可使用以下變量： 擴展變量 姓名 值 email 客戶的電子郵件地址 first_name 客戶的名。必須是字母數字字符，最多為32個字符 last_name 客戶的姓。必須是字母數字字符，最多為64個字符 address1 客戶地址所在國家或地區。必須是字母數字字符，最多為100個字符 address2 客戶地址第二行。必須是字母數字字符，最多為100 個字符 city 客戶地址所在城市。必須是字母數字字符，最多為100 個字符 state 客戶地址所在州。必須是正式的2 個字母縮寫 zip 客戶地址的郵政編碼 night_phone_a 客戶夜間聯繫電話號碼的區號 night_phone_b 客戶夜間聯繫電話號碼前三位 day_phone_a 客戶白天聯繫電話號碼的區號 day_phone_b 客戶白天聯繫電話號碼前三位 提示：若要更改“用戶信息”中的默認運費和手續費設置，請轉至您的用戶信息，編輯您的運費計算，然後點擊“允許採用基於交易的運費”複選框。 方法2. 將單個物品傳遞給PayPal如果您的第三方購物車可設置成向PayPal傳遞單個物品，有關物品的信息將加入買家和賣家的記錄日誌和系統通知中。要加入該物品的信息，您需要將HTML 格式元素粘貼至PayPal購物車流程的新版本。該過程與#1 節“將總購物車數量傳遞給PayPal”描述的非常相似，不同之處在於： 將”cmd”變量設置到”_cart”更換必要的HTML行 &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_xclick&quot;&gt; 與 &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_cart&quot;&gt; 添加稱為”upload”的新變量 在&lt;表格&gt;和&lt;/表格&gt;標籤之間新增以下行： &lt;input type=&quot;hidden&quot; name=&quot;upload&quot; value=&quot;1&quot;&gt; 定義物品明細對於以下各特定物品參數，定義與通過您的合作商購物車購買的各物品對應的一組新值。將”_x”附加到變量名稱，其中x是物品號碼，從1開始，每加入一物品增加一。 姓名 值 item_name_x （物品#x 需要）購物車中物品#x 的名稱。必須是字母數字字符，最多為127 個字符 item_number_x 與購物車中物品#x 關聯的可選傳遞變量。必須是字母數字字符，最多為127 個字符 amount_x （物品#x 需要）物品#x 的價格 shipping_x 運送物品#x 的第一件（數量1）的成本 shipping2_x 每增加一件運送物品#x（數量2 或更多）所需的運送成本 handling_x 物品#x 的處理成本 on0_x 物品#x 的第一選項欄名稱。最多64 個字符 os0_x 物品#x 的第一組選項值。最多200 個字符。”on0_x” 必須定義，以便識別”os0_x”。 on1_x 物品#x 的第二選項欄名稱。最多64 個字符 os1_x 物品#x 的第二組選項值。最多200 個字符。”on1_x” 必須定義，以便識別”os1_x”。 4. 為購物車中每件物品重複此設定 為您的買家購物車中的各物品加入以上表格中的一組必需的變量和任何選項變量。購物車中的第一物品必須用以”_1”結束的參數定義，如”item_name_1”、”amount_1”等。同樣，第二物品應用變量”item_name_2”、”amount_2”等命名。提示：”_x”值必須以一為單位按序遞增，以便識別。如果從item #1跳到item #3而不定義item #2，則第三個物品會被忽略。 要指定幣種：所有貨幣變量（金額、運費、運費2、手續費、稅款）將以粘貼在付款上的”currency_code”變量指定的幣種顯示。因為其不是隨物品不同的，無需向變量名稱附加”_x”。如果沒有粘貼”currency_code”變量，我們將假定所有貨幣變量值為美元。 查閱以下信息後如有其他技術問題，請訪問我們的開發者支持網頁。欲知有關購物車代碼或以下變量的其他信息，請查看網站付款標準版集成指南。","link":"/zh-tw/submitMultipleItemsInPayPalIPNmethod/"},{"title":"使用 Laravel 任務排程","text":"打開排程檔案打開 yourProjectName/app/Console/Kernel.php 輸入你的排程排程範例如下： protected function schedule(Schedule $schedule)&#123; $schedule-&gt;call(function () &#123; Token::where(&#x27;expiry_time&#x27;, &#x27;&lt;&#x27;, time())-&gt;delete(); PaymentServiceOrders::deleteExpiredOrders(); Order::where(&#x27;expiry_time&#x27;, &#x27;&lt;&#x27;, Carbon::now())-&gt;delete(); &#125;)-&gt;daily();&#125; 我設定的任務排程, 是每天固定刪除資料庫裡過期的訂單。 將 Laravel 排程加入到 Linux 的 crontab 中 sudo vim /etc/crontab * * * * * apache cd /var/www/html/yourProjectName &amp;&amp; php artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1 前面的 * * * * * 依序分別代表 分(0-59) 時(0-23) 每月的第幾天(1-31) 月份(1-12) 每週的第幾天(0-6) apache表示使用者, 這關乎權限問題, 當執行的 schedule 中出現錯誤, log 會由此使用者而建立, 若權限沒有設好, 之後的使用者都將無法讀取 log, 若我們本身有額外記 log 的話, 會因為此 log 檔無法被開啟而造成錯誤 cd ray cd /var/www/html/yourProjectName到該目錄底下 php artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1執行 Laravel 的排程指令 以上, 這樣應該就可以順利地跑起來了！","link":"/zh-tw/taskSchedulingInLaravel/"},{"title":"<未完成> 命令行的藝術","text":"前言本篇為 The Art of Command Line 的學習筆記, 內文會盡量精簡只記錄必要的, 主要會以 Questions and Answers 的方式來記錄。 基礎","link":"/zh-tw/the-art-of-command-line/"},{"title":"<未完成>利用 Stackdriver APM 來增進網站可靠性以及排除錯誤","text":"概述此教程的目標是讓你熟悉 Stackdriver 的一些特定的功能, 它讓可以監控 GKE 叢集基礎設施, Istio, 以及部署在這些基礎設施上的應用 你將會做什麼？ 建立一個 GKE 叢集 部署微服務應用到這個叢集上 為這個應用定義延遲 (latency) 以及錯誤 SLIs (Service Level Indicator), 以及 SLOs (Service Level Objective) 設置 Stackdriver 來監控你的 SLIs 部署一個致命的錯誤到你的應用, 然後使用 Stackdriver 來分析以及解決問題 驗證你的解法是否有處理掉 SLO 的違反 你將會學到？ 如何部署微服務到一個已經存在的 GKE 叢集 如何為一個應用選擇適當的 SLIs/SLOs 如何使用 Stackdriver Monitoring features 來實作 SLIs 如何使用 Stackdriver Trace, Profiler, 以及 Debugger 來發現程式的問題 先決條件 Google Cloud Platform 帳戶以及啟用 billing 帳戶的專案 Kubernetes 基礎知識 Stackdriver Monitoring 基礎知識 錯誤分析排除的基礎知識 環境設定在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 基礎設施配置在本教程中, 你將會連接到 Google Kubernetes Engine 叢集然後驗證它有被正確的建立在 gcloud 中設定 zone: gcloud config set compute/zone us-west1-b 設定 project ID: export PROJECT_ID=$(gcloud info --format=&#x27;value(config.project)&#x27;) 確認叢集 shop-cluster 已經被建立了 gcloud container clusters list 如果你的叢集狀態顯示 PROVISIONING, 稍待一些時候, 並再次執行上面的指令, 直到狀態為 RUNNING 當你等待的時候, 設定你的 Stackdriver 工作區來監控你叢集中的應用。 建立 Stackdriver 工作區在 Navigation menu, 點擊 Monitoring當你可以看到 Stackdriver 的主控台, 這代表工作區已準備就緒。回到 Cloud Shell 再次確認叢集是否已準備完成： gcloud container clusters list 一旦你看到叢集狀態顯示為 RUNNING, 取得叢集憑證 gcloud container clusters get-credentials shop-clusters --zone us-west1-b (輸出) Fetching cluster endpoint and auth data.kubeconfig entry generated for shop-cluster. 確認 nodes 已被建立 kubectl get nodes 輸出應如下： NAME STATUS ROLES AGE VERSIONgke-shop-cluster-demo-default-pool1-24748028-3nwh Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-3z1g Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-4ksd Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-f2f2 Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-gcb3 Ready &lt;none&gt; 4m v1.13.7-gke.8 部署應用在本教程中, 你將部署一個名為 Hipster Shop 的微服務到叢集中以建立一個可被監控的工作範例 執行以下指令來複製代碼: git clone -b APM-Troubleshooting-Demo-2 https://github.com/blipzimmerman/microservices-demo-1 下載並安裝 skaffold curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/v0.36.0/skaffold-linux-amd64 &amp;&amp; chmod +x skaffold &amp;&amp; sudo mv skaffold /usr/local/bin 使用 skaffold 安裝應用 cd microservices-demo-1skaffold run 確認一切都正確運行著： kubectl get pods 輸出應類似如下： NAME READY STATUS RESTARTS AGEadservice-55f94cfd9c-4lvml 1/1 Running 0 20mcartservice-6f4946f9b8-6wtff 1/1 Running 2 20mcheckoutservice-5688779d8c-l6crl 1/1 Running 0 20mcurrencyservice-665d6f4569-b4sbm 1/1 Running 0 20memailservice-684c89bcb8-h48sq 1/1 Running 0 20mfrontend-67c8475b7d-vktsn 1/1 Running 0 20mloadgenerator-6d646566db-p422w 1/1 Running 0 20mpaymentservice-858d89d64c-hmpkg 1/1 Running 0 20mproductcatalogservice-bcd85cb5-d6xp4 1/1 Running 0 20mrecommendationservice-685d7d6cd9-pxd9g 1/1 Running 0 20mredis-cart-9b864d47f-c9xc6 1/1 Running 0 20mshippingservice-5948f9fb5c-vndcp 1/1 Running 0 20m 在進到下一步之前, 重複執行指令直到所有的 pods 都顯示 RUNNING取得應用的 external IP: export EXTERNAL_IP=$(kubectl get service frontend-external | awk &#x27;BEGIN &#123; cnt=0; &#125; &#123; cnt+=1; if (cnt &gt; 1) print $4; &#125;&#x27;) 最後, 確認應用已啟動且運行: curl -o /dev/null -s -w &quot;%&#123;http_code&#125;\\n&quot; http://$EXTERNAL_IP 注意: 如果回應是 500 錯誤, 你可能需要再次執行指令確認回應應如下: 200 下載原始碼就將程式碼置於 Cloud Source Repo: ./setup_csr.sh 現在你的應用已經部署完畢, 接下來我們設定應用的監控。 資源 Microservices Demo Application注意: 本教程使用此應用的一個 fork 來幫助除錯 Skaffold 開發範例 SLOs 以及 SLIs在我們實作任何監控之前, 複習一下 SRE 一書 中, 章節名稱為 Service Level Objectives 的介紹 服務架構 在不理解應用是怎麼建立的情況下, 是不太可能開發出 SLIs 的。 細節如原本的倉庫, 但在本教程中, 理解以下幾點便已足夠： 使用者透過 Frontend 存取應用 Purchases 由 CheckoutServer 所處理 CheckoutService 依賴 CurrencyService 處理轉換 其他服務像是 RecommendationService, ProductCatalogService, 以及 Adservice 被使用來提供渲染頁面需要的內容給 frontend Service Level Indicators 以及 Objectives 設置延遲 SLI現在你有定義完成的 SLOs 以及 SLIs, 你可以在 Stackdriver 來實作監控了。 那些你有興趣的指標已經被收集了。 你將為每一個 SLOs 建立警告政策。 前端延遲 (Front End Latency)在 Stackdriver 頁面選擇 Alerting &gt; Create a Policy 點擊 Add Condition, 接下來你將指定用來觸發警告政策的指標以及條件。 當有影響使用者體驗的性能方面的問題產生時, 這些條件將讓你知道有這些事情。 如同在 Service Level Indicators and Objectives 表格內敘述的, 你將使用第 99 的百分位數前端延遲作為 SLI 在 Find resource type and metric 欄位中數入以下值, 並從下拉選單中選擇如下： custom.googleapis.com/opencensus/grpc.io/client/roundtrip_latency 在 Resource Type 選擇 global 選項 點擊 Filter 欄位並選擇 opencensus_task 項。 點擊第一個預設值, 然後點擊 Apply 接下來, 將 Aggregator 設定為 99th percentile 接下來, 在 Configuration 區塊, 設定選項如下： Any time series violates 時觸發 Condition: is above Threshold: 500 For: Most recent value 點擊 Save 在下一個頁面, 下拉到底, 並且將 policy 命名為 “Latency Policy”, 然後點擊 Save, 你已經完成在 Stackdriver 監控 frontend latency SLI 的設置 設置可用性 SLI (Availability SLI)接下來, 設置 Stackdriver, 建立另一個警告政策來監控服務可用性 前端可用性 (Front End Availability)先由監控 front end service 的 error rate 開始, 因為這是會帶給使用者體驗最直接影響的地方。 如上所述, 你將會把任何的錯誤都列入違反 SLO 。 建立一個警告政策, 當觀察到任何錯誤時, 事件就會被觸發。 觸發特定錯誤的簡單方法之一, 就是使用基於紀錄的指標 (log-based metrics) 在 Stackdriver UI 介面中, 左側面板打開 Logging 針對 filter 做如下設置: 在 Resource type (第一個下拉選單) 選擇 Kubernetes Container Log Level 選擇 ERROR 在篩選器欄位輸入 label:k8s-pod/app:&quot;currencyservice&quot; 備註: 在這個頁面, 你不會看到任何結果, 因為目前服務正常的運行中。 很快的, 你將做一些變更來改變這個結果。 點擊 Create Metric 將指標命名為 “Error_Rate_SLI”, 然後點擊 Create Metric 來儲存紀錄指標: 現在你可以看到這個指標列在記錄指標的頁面。 點擊行末三個點的小圖案, 並點擊 Create Alert from Metric 來使用該指標建立警告政策 注意到 resource type 以及 metric 已經被填好了 將 condition 命名為 “Error Rate SLI” 點擊 Show Advanced Options 連結, 然後做如下設定： Aligner: rate在 Configuration 的地方, 使用 0.5 唯一分鐘的觸發門檻 然後點擊 Save 在下一個頁面, 將新的政策命名為 “Error Rate SLI” 然後點擊 Save 如預料的, 並沒有錯誤發生。 因為你的應用目前有達到可用性 SLO 部署新的發佈現在你已經設置好 SLI 監控, 也已經準備好測量應用變更對使用者體驗造成的衝擊。 讓我們來看看當部署一個新的應用發佈時會發生什麼事。 接下來, 你將修改 Kubernetes 的設定檔使服務有新的發佈, 然後運行 skaffold 來再次部署應用。 更新 YAML 檔案 找到 microservices-demo-1 資料夾, 打開裡頭的 kubernetes-manifests 資料夾 在 kubernetes_manifests/remommendationservice.yaml 檔案, 第 28 行, 使用下面的程式碼取代 image: gcr.io./accl-19-dev/recommendationservice:rel013019imagePullPolicy: Always 舉例來說, 下面是 recommendationservice.yaml 的原始版本： 然後下面的是更新之後的： 在以下這些檔案中都做同樣的事： kubernetes_manifests/currencyservice.yaml kubernetes_manifests/frontend.yaml 儲存並關閉檔案, 現在你已經可以部署新的版本了。 部署新的版本在 Cloud Shell, 更新 deployment 來部署新的容器鏡像: skaffold run 確認新版本的服務正在運行著: kubectl get pods (輸出) NAME READY STATUS RESTARTS AGEadservice-55f94cfd9c-4lvml 1/1 Running 0 17dcartservice-6f4946f9b8-6wtff 1/1 Running 197 17dcheckoutservice-5688779d8c-l6crl 1/1 Running 0 17dcurrencyservice-665d6f4569-b4sbm 1/1 Running 0 1memailservice-684c89bcb8-h48sq 1/1 Running 0 17dfrontend-5f889fc7bb-wvfvv 1/1 Running 0 1mloadgenerator-6d646566db-p422w 1/1 Running 0 17dpaymentservice-858d89d64c-hmpkg 1/1 Running 0 17dproductcatalogservice-bcd85cb5-d6xp4 1/1 Running 0 17drecommendationservice-57cb4559f9-bdgj7 1/1 Running 0 1mredis-cart-9b864d47f-c9xc6 1/1 Running 0 17dshippingservice-5948f9fb5c-vndcp 1/1 Running 0 17d 傳送一些資料現在應用已經在運行著, 回去看看你部署了什麼。 在主控台, 到 Kubernetes Engine &gt; Services &amp; Ingress, 尋找 frontend-external 服務並點擊 Endpoint URL 到 Hipster Shop 網站, 點擊 Buy 以及/或 Add to Cart 幾次來傳送一些流量。 等待 60 秒左右來產生足夠的延遲資料 延遲 SLO 違反 - 找出問題在這個練習中, 你將使用 Stackdriver Application Performance Management (APM) 工具來找出已經解決造成應用嚴重延遲的問題 首先, 讓我們看看在我們部署新版之後, 是不是一切都 OK 在 Stackdriver 中選擇 Monitoring Overview, 在上方點擊 autorefresh arrows, 所以你將可以看到最新的資訊 一個 Latency Policy 事件不久後會出現, 如果還沒出現的話, 等它幾分鐘 在 Incident 區塊中點擊 Latency Policy 來檢視更多資訊。 你可能需要點擊 Resolved 區塊來檢視已經發生的警告 分析延遲問題的最佳解, 就是使用 Trace, 在左手邊的選單點擊 Trace 現在你的位置在主控台。 一開始的總覽的資訊挺有幫助的, 但你需要更進一步的資訊, 打開 Trace List 頁面 點擊 Auto Reload, 注意到頁面商方的散點圖, 在時間警告處有大量的異常紀錄。 等 1 或 2 分鐘讓資料搜集, 然後點擊其中一個 outlier traces 來檢視發生的細節。 注意到 Span name (代表被呼叫的 service 或 function) 為 /char/ 或 /char/checkout/ 在 Request filter 欄位輸入 “Recv./cart” 來篩選所有的 cart 運作以及類似的追蹤, 這有助於了解它是如何比較事件發生前的紀錄以及發生後的紀錄。 設定時間範圍為 1 hour, 所以顯示資料會包括事件發生前的資料 點擊事件發生前的一筆資料來看看 可以看到, 這個類似的紀錄 ListRecommendations 在此只被呼叫了一次。 然而, 在我們最新的部署之後, ListRecommendations 在每一次的請求都被呼叫了很多次, 造成了很嚴重的額外延遲 至此, 我們可以總結, 這些異常值造成的原因是因為 ListRecommendations 的多次呼叫。 部署變更來處理延遲為了解決上一次部署所產生的延遲問題, 你需要部署另外一個版本來修復損壞的程式碼。 你將會修改 Kubernetes 的設定檔, 含有損壞程式碼服務的設定檔 要部署修復, 回到 Cloud Shell 頁面, Source Code Editor 應該還是開啟的。 你將會修改以下檔案： kubernetes_manifests/recommendationservice.yaml kubernetes_manifests/frontend.yaml 將鏡像的標籤 rel013019 修改成 rel013019fix, 所以 鏡像 看起來應如下： containers:- name: server image: gcr.io/accl-19-dev/frontend:rel013019fix imagePullPolicy: Always 儲存 檔案 回到 Cloud Shell 並執行以下指令重新部署修復過的鏡像: skaffold run 核對修復現在你已經部署了修復的版本, 核對一下你的應用是否已回到健康的狀態 回到 Stackdriver* 並到 **Metrics Explorer (Resources &gt; Metrics Explorer) 在搜尋欄位, 輸入 latency 並點擊 roundtrip_latency 將圖表類型變更為 Line, 你應該看到圖表中的 latency 數值有立即明顯的下降 (如果沒有的話, 可能要等個一分鐘) 現在, 回到 Monitoring Overview 看看事件是否已經解除了。 你應可發現兩件事 - 原本的 incident 也經不存在了, 且會有 event 通知說原本的 incident 已經被解除了。同樣的, 如果你沒看到 incident 解除的訊息, 等個幾分鐘吧。 你的監控可以正確的辨識出造成使用者體驗下滑的變更 (如同我們上面的檢測, 是由延遲造成的), 你也可以辨識出真正產生問題的原因, 且你也回滾了這段損壞的變更。 在下一個章節, 看看 Stackdriver 是如何幫助我們解決可用性 (availability) 的問題。 錯誤率 SLO 違反 (Error Rate SLO Violation) - 找出問題在這個練習中, 你將使用 Stackdriver Application Performance Management 工具 (APM) 來排查一些在你的應用之中造成錯誤, 並且超出了你設定的錯誤限制的問題 先到 Stackdriver 的 Monitoring Overview 尋找 Error Rate SLI incident, 然後點擊 incident 來了解發生了什麼事。 incidents 可能會需要幾分鐘的時間來被確認, 並且列在 incident 中。 如果還沒有看到有 incident, 你可以先跳過 incident 步驟, 然後在左手邊選單處點擊 Error Reporting 你可以看到 currencyservice pod 正紀錄比之前多很多的錯誤。 點擊 Acknowledge incident, 所以針對事件的通知不會持續累積 像這種類型的警告, 也很多方式可以達成, 但最簡單的方式是使用 Stackdriver Error Reporting, 在左手邊選單點擊 Error Reporting 可注意到 Open Error Reporting 顯示有一個最新的數據急遽上升。 點擊 Error: Conversion in Zero 來檢視更多錯誤問題 在右手邊可看到 Stack Trace 樣本, 你可以從這看到哪些特定的呼叫是跟錯誤相關的 點擊 最下面的呼叫, 如 /usr/src/app/server/js:131 顯示 這會將你導向 Stackdriver Debug, 在頂部的欄位確認 currency service 有被選擇 接下來, 從 Cloud Source Repositories 選擇正在運行的程式碼 依照以下條件選擇 source Repository: apm-qwiklabs-demo Tagged version or branch: APM-Troubleshooting-Demo-2 然後點擊 Select Source 在左手邊選單選擇 /src/currencyservice/server.js 往下捲動到 155 行左右, 這邊是 exception 被拋出的地方。 你可以看到錯誤回報功能正是回報 Conversion is Zero 這一個錯誤紀錄 從上面的程式碼可以看到, 當 result.units &lt; 0 時會記錄這個 error, 而要排除這個問題, 你將使用 Snapshots 來檢查當應用運行中變數的值。 確認你已經在右上方選擇了 Snapshot 然後點擊你想要快照的地方, 行數 (155) 在此練習中, 在行數 155, 141, 以及 149 的地方快照, 你也可以在任何你覺得適當的地方加入快照。 系統將會在下一次程式碼運行時, 對變數進行快照。 當應用正在等待程式碼運行時, 你可以看到 “Waiting for snapshot to hit …” 提示。 當快照完成, 右手邊將顯示指定快照處的變數 可以看到 Variable 以及 Call Stack 資訊。 這些資訊可以讓你了解到你的程式碼執行的路線是怎麼走的, 以及在執行的路線上的程式碼結構以及變數, 我們完全不需要重啟應用或變更任何程式碼來獲得這些資訊。 點擊 result 來檢視在 155 行結束的 3 個快照。 根據上面的資訊我們知道當 result.units 不大於 0 時, 會觸發錯誤。 檢視一下變數你可以看到 result.units = NaN (代表 ‘不是一個 number’), 這就是造成錯誤的原因 現在你可以下結論, 這個錯誤是因為設定 result.units 為 0 的 convert function (或子 function) 出 bug, 你的錯誤排除程序依據快照所提供的資訊以及紀錄是一個很確實地針對問題的診斷。 所以造成問題的 bug 是什麼？ 從程式碼可以看到, result.units 由 euros 在第 114 行設定, 而 euros 在第 136 行 from.units 被設定 檢視快照中的 euros.units 也是 NaN, 然而, from.units 是個合法的數字。 因此問題是在轉換 from.unit 到 euros 時發生的。 你可以歸納, 根本原因為 from.units 在 137 行是如何被轉換成 euros.units, 8 被帶入 Data[], 這事實上是一個 key value 的指向, currency units (像是 EUR) 到 exchange rates, 正確的 137 行應該要使用 from.to_currency (即 USD), 而非 from.units (即 8) 現在你已經確定產生 bug 的原因, 並且也可以做出相對應的修正。 根據警告的時間點, 這可能是在最近的部署上產生的。 看看之前的 “Master” 分支上, 在 137 行有沒有這個錯誤 回到主控台, 使用 Cloud Source Repositories (在主控台選單的 Tools 分類下) 來檢視程式碼 打開 apm-qwiklabs-demo repository, 選擇 master 分支 從左手邊至 *src &gt; currencyservice &gt; server.js, 注意到第 137 行有使用正確的被除數 data[from.currency_code] 現在你已經可以確定這個 bug 是由最新的 push 所造成。 當務之急, 我們先要回到前一個版本去。 部署變更來解決 Error Rate要解決這個問題, 你需要部署一個修復到應用上。 為了做到這一點, 你將需要更改 Kubernetes 的設定檔中, 包含有錯誤程式碼的服務。 部署修復回到 Cloud Shell, 然後在 Source Code Editor 打開 kubernetes_manifests 資料夾中的 currencyservice.yaml 檔案 將 image tag_re1013019_ 替換成 re1013019fix, 所以 image 應看起來如下： containers:- name: server image: gcr.io/accl-19-dev/frontend:rel013019fix imagePullPolicy: Always 關閉 檔案並儲存, 回到 Cloud Shell 視窗 重新部署帶有修復代碼的鏡像： skaffold run 核對修復現在你已經回滾了錯誤的代碼, 確認一下應用是否有回到健康的狀態。 如同上面的步驟, 先核對一下 incident 是否已經解決了。 到 Stackdriver UI Monitoring Overview 確認一下 error rate incident 是否已經解決了。 現在, 應該是沒有 open incident 了。 接下來, 回到 Error Reporting, 打開之前觀察的錯誤, 然後確認錯誤已經沒有再出現了 (時間軸應會顯示從上一次部署到現在已經都沒有錯誤發生了) 恭喜！ 你的監控可以正確地發現造成使用者體驗下降的變更代碼 (經由量測應用錯誤而得來的數據), 且你可以找出根本的原因, 然後回滾錯誤的程式碼。 讓我們進到下一個章節, 學習怎麼樣使用 Stackdriver 來優化資源利用 使用 Stackdriver APM 來優化應用在這個練習中, 你將使用 Stackdriver Application Performance Management 工具 (APM) 來尋找你的應用可能的改善空間, 讓它運行的更快速, 使用更少的資源。 在這個情境中, Director of Cloud Operations 對最近的運算成本上升感到非常失望。 特別是, 根據系統的使用量來看, currencyservice 使用了超出預期的 CPU 你的團隊已經被賦予了優化的任務。 APM 工具將被使用來分析服務, 並且確保你的團隊可以將心力集中在對的地方。 從主控台左手邊選單打開 Stackdriver Profiler 變更右上方的 Timespan 到 30 分鐘。 如果還沒有資料的話, 等個 1 到 2 分鐘讓資料載入 注意: Profiler 提取隨機的呼叫樣本來建立一個總和的呼叫堆疊。 如果你沒有看到你預期中的資料, 那可能是因為本教程運行的時間還不足, 或是你的進度比預期的要快。 可以在本次練習中多多使用 screenshots 在 filter 的 service 欄位選擇 frontend, 然後在 Profile type 欄位選擇 CPU time Profiler 提取隨機的系統頗析樣本, 並且融合這些資料, 顯示出哪些功能使用了最大量的資源。 下面的火焰圖顯示了由使用的資源分組 (在這個案例中, 資源為 CPU) 過的 function 呼叫, X 軸為 CPU 的總量, Y 軸為父子關係 在這個案例中, 在左手邊的 ServeHTTP 呼叫使用了大部分的 CPU, 點擊這個呼叫, 進一步搜索原因。 展開的圖表顯示了有一半的呼叫是由 viewCartHandler 相對應的 getRecommendations 所造成。 所以可能可以下手的地方是 getRecommendations 以及其相對應的 getProduct, 回想一下之前的練習, recommendation service 以及 getProduct 在迴圈內被頻繁的呼叫, 因為在蟲試邏輯中有錯。 解決這個問題之後, 將可以減少運算成本達 20% 恭喜你已完成本教程","link":"/zh-tw/siteReliabilityTroubleshootingWithStackdriverAPM/"},{"title":"TypeScript 學習筆記","text":"前言TypeScript 學習筆記, 學什麼記什麼！","link":"/zh-tw/typescript/"},{"title":"使用MySQL- group by 來整理資料庫","text":"大家好，我是Ray! 昨天跟大家分享如何正確的導入中文的資訊到資料庫裡，今天呢，我將分享如何使用MySQL的group by 來整理資料庫！ 在上圖我們可以看到，所有資料都以不同的地區來做劃分。假設右手邊的欄位資料爲降雨量好了，如果我們今天想要取得全地區的平均降雨量，該怎麼作呢？我們可以使用MySQL的group by 來達到我們的目的。 輸入以下code: select date, avg(rainfall) rainfall from rainfall group by date; 上面的date代表我日期欄位的名稱，avg代表平均值，rainfall代表降雨量欄位的名稱，而在括號後面又出現一次rainfall代表顯示在取得的資料表上的欄位的名稱，最後一個rainfall則是我這個表格的名稱。由於我select的項目裡並沒有地區，而最後的group by 表示資料將以date下去做重新整理，如果有相同天數的欄位就會自動重整，並使用我前面下的avg平均化處理。 得出的結果如下圖：￼ 我們下次見。","link":"/zh-tw/useGroupByToOrganiseYourDatabase/"},{"title":"<未完成> 使用地區性的永久磁碟部署 Apps 到 Kubernetes Engine","text":"概述本章節中, 我們將學習如何藉由使用 regional persistent disks (地區性永久磁碟) 在 Kubernetes Engine 部署 WordPress, 配置一個高可用的應用。 Regional persistent disks 提供的兩個 zones 之間的同步, 這確保了你的應用可以正常運行, 就算其中一個區域發生了故障或停電事故。 使用 regional persistent disks 來部署 Kubernetes Engine 叢集將會讓你的應用更穩定, 安全, 可信賴。 你將實作的內容 建立一個 regional Kubernetes Engine 叢集 建立一個 Kubernetes StorageClass 資源, 這個資源是針對複製的 zone 所配置 使用 StorageClass 的 regional disk 部署 WordPress 藉由刪除 node 來模擬區域性的故障 確認 WordPress app 以及資料成功的遷徙到另一個複製的 zone 進行此章節的建議具備知識這是 進階 課程, 在開始前, 至少有熟悉 Kubernetes 以及 WordPress 的基礎。 這邊有列出一些 Qwiklabs 可以讓你跟上進度: Kubernetes Engine: Qwik Start Running WordPress on App Engine Flexible Environment Hello Node Kubernetes 準備好了的話我們就往下吧！ 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 Regional Kubernetes Engine 叢集打開新的 Cloud Shell 視窗, 先建立 regional Kubernetes Engine 叢集, 它橫跨了位於 us-west1 的 3 個 zones 。 首先, 透過以下指令, 取得 us-west1 的 server 配置, 並將結果匯出到環境變數： 取得 server 配置CLUSTER_VERSION=$(gcloud container get-server-config --region us-west1 --format=&#x27;value(validMasterVersions[0])&#x27;)export CLOUDSDK_CONTAINER_USE_V1_API_CLIENT=false 現在建立一個標轉的 Kubernetes Engine 叢集 (會花一些時間, 請忽略認為有關 node auto repairs 的警告) gcloud container clusters create repd \\ --cluster-version=$&#123;CLUSTER_VERSION&#125; \\ --machine-type=n1-standard-4 \\ --region=us-west1 \\ --num-nodes=1 \\ --node-locations=us-west1-a,us-west1-b,us-west1-c 輸出: Creating cluster repd...done.Created [https://container.googleapis.com/v1beta1/projects/qwiklabs-gcp-e8f5f22705c770ab/zones/us-west1/clusters/repd].To inspect the contents of your cluster, go to: https://console.cloud.google.com/kubernetes/workload_/gcloud/us-west1/repd?project=qwiklabs-gcp-e8f5f22705c770abkubeconfig entry generated for repd.NAME LOCATION MASTER_VERSION MASTER_IP MACHINE_TYPE NODE_VERSION NUM_NODES STATUSrepd us-west1 1.12.6-gke.7 35.247.50.133 n1-standard-4 1.12.6-gke.7 3 RUNNING 我們剛建立了一個 regional 的叢集 (位於 us-west1), 並且在每個 zone 都個開 1 個 node (us-west1-a, us-west1-b, us-west1-c)從左邊選單到 Compute Engine 來檢視你的 instances: gcloud 指令同時也自動的設置了 kubectl 指令連接到叢集 使用 Regional Disk 部署 App現在你的 Kubernetes 叢集已經在運行中了, 你將做以下三件事： 安裝 Helm (管理 Kubernetes 套件的工具) 建立 Kubernetes StorageClass, 給 regional persistent disk 用的 部署 WordPress 安裝以及初始化 Helm, 以安裝 chart packagechart package 是由 Helm 所安裝的, 它含有運行 WordPress 所需的所有東西 執行以下指令安裝 Helm 到 Cloud Shell curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get &gt; get_helm.shchmod 700 get_helm.sh./get_helm.sh 初始化 Helm: kubectl create serviceaccount tiller --namespace kube-systemkubectl create clusterrolebinding tiller-cluster-rule \\ --clusterrole=cluster-admin \\ --serviceaccount=kube-system:tillerhelm init --service-account=tilleruntil (helm version --tiller-connection-timeout=1 &gt;/dev/null 2&gt;&amp;1); do echo &quot;Waiting for tiller install...&quot;; sleep 2; done &amp;&amp; echo &quot;Helm install complete&quot; 現在 Helm 已經安裝完畢 建立 StorageClass接下來你將建立 StorageClass, 被 chart 使用來定義 regional disk 的 zones。 列在 StorageClass 中的 zones 須符合 Kubernetes Engine 叢集的 zones 執行以下指令建立 StorageClass, 為 regional disk 所用： kubectl apply -f - &lt;&lt;EOFkind: StorageClassapiVersion: storage.k8s.io/v1metadata: name: repd-west1-a-b-cprovisioner: kubernetes.io/gce-pdparameters: type: pd-standard replication-type: regional-pd zones: us-west1-a, us-west1-b, us-west1-cEOF 輸出： storageclass &quot;repd-west1-a-b-c&quot; created Questions and Answers解釋以下的 command command:helm init --service-account=tilleruntil (helm version --tiller-connection-timeout=1 &gt;/dev/null 2&gt;&amp;1); do echo &quot;Waiting for tiller install...&quot;; sleep 2; done &amp;&amp; echo &quot;Helm install complete&quot; Answer: until: 如果 until 後的判斷為 true 的話, 就停止迴圈, 否則就一直執行 do 後的指令 do echo 字串, sleep 2 秒 done 當 until 的判斷為 true 時, 停止迴圈, 並 echo 字串 解釋以下的 gcloud command Command:kubectl create clusterrolebinding tiller-cluster-rule \\ --clusterrole=cluster-admin \\ --serviceaccount=kube-system:tiller Answer: 建立 clusterrolebinding, 名為 tiller-cluster-rule 要綁定的 clusterrole 為 cluster-admin, 為叢集中最高權限 要綁定的 service account 為 kube-system namespace 下面的 tiller 以下的 gcloud command 的意思是？ Command:kubectl create serviceaccount tiller --namespace kube-system Answer:建立 service account, 名為 tiller, 建立在 kube-system 這個 namespace 以下的 gcloud command 的意思是？ Command:CLUSTER_VERSION=$(gcloud container get-server-config --region us-west1 --format=&#x27;value(validMasterVersions[0])&#x27;)export CLOUDSDK_CONTAINER_USE_V1_API_CLIENT=false Answer: 取得 Kubernetes Engine 的 server config 地區為 us-west1 從格式可知, 目標是取得 version 不使用 V1 版本的 API 解釋以下的 gcloud command Command:gcloud container clusters create repd \\ --cluster-version=$&#123;CLUSTER_VERSION&#125; \\ --machine-type=n1-standard-4 \\ --region=us-west1 \\ --num-nodes=1 \\ --node-locations=us-west1-a,us-west1-b,us-west1-c Answer: 建立一個 cluster, 名為 repd 指定 cluster-version 指定 machine-type 為 n1-standard-4 指定 region 為 us-west1 node 的數量為 1 node 的 location 為 us-west1-a, us-west1-b, us-west1-c, 所以就是每個區域都會開一台 node, 雖然上面是說 node = 1, 但是總共會開 3 台","link":"/zh-tw/using-kubernetes-engine-to-deploy-apps-with-regional-persistent-disks/"},{"title":"使用MySQL- group by 來整理資料庫 2","text":"哈囉大家好，我是Ray！ 今天想要跟大家分享group by 的更進一步的操作，如何使用group by 配合select 相對應的選項，新建一個表格，並在新表格內將資料重新整理爲我們需要的row and column。 首先，延續昨天的進度，如下圖所示，我們將降雨量根據天來做分類，那如果說今天我們需要月的降雨量，或者年雨量總和呢？￼ 請參考以下的code: &lt;?php// SELECT後面的year(date)以及month(date)表示SELECT這兩項資料，// 括號後的year以及month表示顯示出來的欄位名稱，sum表示加總括號內欄位資料的總和,// 括號內的rainfall爲欄位名稱，括號後的表示顯示出來的欄位名稱，一樣使用group by，// 使資料以月份以及年分來做顯示，order by 表示依照先後順序由先到後作排列。$selectQuery = &#x27;SELECT year(date) year, month(date) month, sum(rainfall) rainfall from rainfall_by_date group by month(date), year(date) order by year(date) asc, month(date) asc;&#x27;;// 向資料庫作select 請求$selectResult = mysqli_query($dbc, $selectQuery);// 使用迴圈來重複請求，直到拿出所有位於$selectResult物件中的所有arraywhile ($selectRow = mysqli_fetch_array($selectResult))&#123; // 將我們從rainfall_by_date取得的資料insert進新表格rainfall_by_month $insertQuery = &#x27;INSERT INTO rainfall_by_month (year, month, rainfall) VALUES(&quot;&#x27; . $selectRow[&#x27;year&#x27;] . &#x27;&quot;, &quot;&#x27; . $selectRow[&#x27;month&#x27;] . &#x27;&quot;, &quot;&#x27; . $selectRow[&#x27;rainfall&#x27;] . &#x27;&quot;)&#x27;; // 作insert請求 $insertResult = mysqli_query($dbc, $insertQuery);&#125; 執行以上的script之後，可以得到新的表格，如下：￼","link":"/zh-tw/useGroupByToOrganiseYourDatabasePart2/"},{"title":"使用 BigQuery 以及 Stackdriver 來分析 BigQuery 用量","text":"概述Stackdriver Logging 讓你可以在 Google Cloud Platform 的服務上，針對紀錄作儲存，分析，搜尋，監控，以及警告還有事件，包含 BigQuery 服務。Stackdriver 也提供匯出特定記錄到接收器的功能，例如 Cloud Pub/Sub, Cloud Storage, 或 BigQuery 在本教程中，你將在 Stackdriver 中檢視 BigQuery 的紀錄，設定接收器來匯出記錄到 BigQuery, 然後使用 SQL 來分析這些紀錄 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求 Qwiklabs setup在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Quiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Quiclabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 打開 BigQuery 打開 Big Query 主控台在 Google Cloud Console, 選擇 Navigation menu &gt; BigQuery Welcome to BigQuery in the Cloud Console 訊息視窗彈出。這個訊息視窗提供快速導覽的連結，以及一些更新訊息 點擊 Done BigQuery 主控台開啟 建立資料組 在 Resources 區塊中，點擊 qwiklabs-gcp- 開頭的資源 點擊 CREATE DATASET 設定 Dataset ID 到 bq_logs 點擊 Create dataset 執行一個查詢首先，執行一個簡單的查詢，在 Stackdriver 中產生一筆紀錄。 之後，你將使用這個紀錄來簡單設置匯出功能，從 Stackdriver 到 BigQuery 複製底下代碼，然後在 BigQuery 的查詢編輯器中貼上 SELECT current_date 點擊 Run 設定從 Stackdriver 匯出紀錄在 Stackdriver 檢視紀錄 在 Google Cloud Console 選擇 Navigation menu &gt; Logging &gt; Logs Viewer 在第一個下拉視窗的搜索框中，選擇 BigQuery 應會看到幾筆紀錄出現 尋找含有 “jobcompleted” 字串的紀錄 點擊位於左方，下圖中的三角箭頭來打開數據，然後在右手邊點擊 Expand all 這將以 JSON 格式來顯示數據，往下滑看看不一樣的欄位 回到剛剛的開頭處，點擊 ‘jobcompleted’ 然後選擇 Show Matching Entries 這將會完成正確的搜尋設定 建立匯出現在你有需要的紀錄了，很簡單的就可以設定匯出 在搜尋框上方，點擊 Create Export 在右手邊，依照下面給的資訊輸入 (1) Sink name: JobComplete (2) Sink Service: BigQuery (3) Sink Destination: bq_logs (我們之前設定的資料組) 點擊 Create Sink 點擊 CLOSE 之後任何的紀錄都會被匯出到這一個 bq_logs 資料組 執行範例查詢為了讓新的表格載入入一些紀錄，我們需要執行一些範例的查詢 移動到 Cloud Shell , 複製下面的代碼，然後貼到 Cloud Shell 上 bq query --location=us --use_legacy_sql=false --use_cache=false &#x27;SELECT fullName, AVG(CL.numberOfYears) avgyearsFROM `bigquery-samples.nested.persons_living`, UNNEST(citiesLived) as CLGROUP BY fullname&#x27; bq query --location=us --use_legacy_sql=false --use_cache=false &#x27;select month, avg(mean_temp) as avgtempfrom `bigquery-samples.weather_geo.gsod`where station_number = 947680and year = 2010group by monthorder by month&#x27; bq query --location=us --use_legacy_sql=false --use_cache=false &#x27;select CONCAT(departure_airport, &quot;-&quot;, arrival_airport) as route, count(*) as numberflightsfrom `bigquery-samples.airline_ontime_data.airline_id_codes` ac,`bigquery-samples.airline_ontime_data.flights` flwhere ac.code = fl.airline_codeand regexp_contains(ac.airline , r&quot;Alaska&quot;)group by 1order by 2 descLIMIT 10&#x27; 你將會看到每筆查詢回應的結果 在 BigQuery 中檢視紀錄 移動到 BigQuery (Navigation menu &gt; BigQuery) 展開 qwiklabs-gcp- 開頭的資源，並且檢查 bq_logs 資料組 你應該可以看到一個表格 名字可能會跟下面的不太一樣，但看起來應該差不多“cloudaudit_googleapis_com_data_access_2019-06-19” 檢查表格的結構，然後注意到它有很大數量的欄位 如果你試著預覽，並且想知道為什麼它沒有顯示出你最近查詢的紀錄，那是因為紀錄是被串流到表格，這顯示新的資料可以被查詢但不會立即顯示在預覽 為了提高表格可用性，你可以建立 VIEW, 它可以取出子欄位的資料，然後執行一些計算來獲得查詢時間的指標 在 BigQuery 的查詢編輯器，將 替換成你的 project name (在 Qwiklab 視窗左手邊可以很簡單的複製) 後，執行以下的 SQL CREATE OR REPLACE VIEW bq_logs.v_querylogs ASSELECT resource.labels.project_id, protopayload_auditlog.authenticationInfo.principalEmail, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobConfiguration.query.query, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobConfiguration.query.statementType, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatus.error.message, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.startTime, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.endTime, TIMESTAMP_DIFF(protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.endTime, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.startTime, MILLISECOND)/1000 AS run_seconds, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.totalProcessedBytes, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.totalSlotMs, ARRAY(SELECT as STRUCT datasetid, tableId FROM UNNEST(protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.referencedTables)) as tables_ref, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.totalTablesProcessed, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.queryOutputRowCount, severityFROM `&lt;YOUR-PROJECT-ID&gt;.bq_logs.cloudaudit_googleapis_com_data_access_*`ORDER BY startTime 現在可以查詢 VIEW, 執行以下指令 SELECT * FROM bq_logs.v_querylogs 檢視結果檢視你之前執行的三筆查詢，跟下圖類似 恭喜你已經完成本教程","link":"/zh-tw/usingBigQueryAndStackdriverToAnalyzeBigQuerryUsage/"},{"title":"Git log 裡面的東西是什麼？","text":"大家好，我是Ray! 今天想跟大家分享，git log 裡面的一些細節。 首先，我們先來看看下面的圖片： 我們可以看到，每一個commit後面都有一段非常長的隨機字串，那這是什麼呢？ 這是一串git 根據commit的內容，由SHA1生成的隨機驗證字串，也許你會問，什麼是SHA1? SHA1全名為security hash algorithm, 中文意思大概就是“安全加密演算法”。 諸如此類的演算法有好幾種，SHA系列的演算法是不可逆的，簡單來說，如果你拿到一串加密過的字串，就像上面那些驗證字串，你是沒有辦法透過將它逆轉回加密前的樣子。 有興趣的朋友可以google一下，這邊我們就不針對SHA多做討論！ 接下來介紹一個非常實用的指令，git log --oneline! 輸入git log --online 可以對照下圖，這是git log 與 git log --oneline的差別。 由上圖大家可以看到，git --oneline 拿掉了作者，日期相關資訊，並且只保留驗證字串的七碼！ 那我們之前提到的git checkout也可以使用這七碼來作切換嗎？ 輸入git checkout out cc92d2f (請輸入你電腦上的驗證字串，你的跟我的不一樣） 如上圖，我們已經成功的切換到前一個commit 輸入 git checkout master 輸入 git log --oneline 這樣就又切回來了！ 看完今天的文章，是不是對於git 有更深一層的理解了呢？ 我們明天見！","link":"/zh-tw/whatIsInGitLog/"},{"title":"為什麼我們要使用Git?","text":"大家好我是Ray! 今天要跟大家分享，為什麼要使用Git? 首先，你有沒有遇過，coding到一半忽然有急事要做（可能是你媽叫你，也可能是你忘記去接你女朋友） 然而很不巧的，當時你可能正在debug，又或者在開發一個新功能。 當你終於有空回去繼續coding時，靠！怎麼出錯啦～？ 滿滿的程式碼滿滿的邏輯不知道從何找起從何debug起～ 又或者，有時在開發新功能時，新功能不巧地影響到現有的功能，導致現有的功能也無法使用！ 當我們陷入一個無頭緒的狀態時，我們就想要回到還沒開始新功能的那一刻，很不巧的，我們早就已經養成定時存檔的良好習慣… 這些時候，就是Git出場的時候啦！ 當你在一些關鍵的時刻，又或者已經完成一個功能，而打算從這個功能為一個起點，開始一個新功能，這個時候你可以使用Git把它存檔起來，存檔後，你可以隨時回到你存擋的那一刻，這種回朔是跟你檔案本身存擋沒有關聯的，換句話說，就算你已經在編輯器或者是IDE上面存擋了，你也可以隨時地回到你使用Git設的存擋點！ 另外一個情況，除非你做的是一個人可以完成的小專案，否則只要是多人協作的專案都需要多人合作與配合，有沒有想過，當這麼多人來一起做一個案子甚至一個檔案，該如何有效地整合呢？畢竟coding是非常細緻的工作，就算你只錯了一個字也可以會造成整個功能無法使用啊！ 這個時候通常我們都會使用Git來整合，試想你的電腦上是一個你自己擁有的資料夾，當你在你的電腦上把你的部分完成之後，你把完成的部分上傳到一個公共的資料夾，而團隊內的其他成員也是用這種方式來上傳他們的部分，此時Git可以讓我們記錄所有人的部分並且將所有人的code合併已達到整合！ 所以對於一個coder來說，Git似乎是不可或缺的呢！","link":"/zh-tw/whyGitIsSoMuchRequired/"},{"title":"為什麼要使用 VIM?","text":"哈囉大家好，我是Ray! 今天要來跟大家分享一款非常實用且歷史悠久的編輯器，它叫做Vim! 關於歷史來源背景，我這邊就不贅述了，在麻煩有興趣的讀者自行Google! Vim除了是一款專門爲coding而設計的編輯器之外，幾乎在所有有名的IDE，或者是Editor上，都可以找到Vim的插件，比如我所使用的PHPstorm，或者Subline。 在我們深入Vim之間，我們先來說說，爲什麼我們要使用Vim? 我個人在選擇成爲一名工程師之前，就已經使用標準指法，就是利用F以及J上的凸點來做定位而達到盲打，盲打就是蒙着眼睛也可以準確的打字哦！ 在開始寫程式之後，我最大的困擾並不是程式的語法或邏輯，而是我的手必須頻繁的在滑鼠、方向鍵、以及主鍵區之間作切換。 在我還未邂逅Vim之前，我一直在尋找可以自定義按鍵的鍵盤，因為我認為最理想的打字模式，就是我的手掌並不需要離開主鍵區而可以完成所有的操作。 理論上來說，如果兩個工程師有著同樣的經驗與邏輯，以及技術，打字速度較快的那個人肯定有著較高的輸出，意味著可以更快的完成任務。 如果你問我，那我沒事做那麼快做什麼？ 各位大大，時間就是金錢啊！！ 越快完成表示省下越多的時間，代表你可以運用的時間將越多！ 對於技術狂熱者，啊不對，是對技術有較高熱情的人來說，像是我，更多的時間表示可以學習更多的技術。 時間可以用來做非常多的事，說是比比特幣還珍貴也不為過！ 你可以用來陪家人、追劇、陪女朋友，阿～前提是你要先有女朋友，像我就沒有QQ。 Vim的最基本也最實用的功能，就是可以使用h, j, k, l四個鍵來當成上下左右，換言之，他已經解決我們最大的問題-需要在方向鍵區與主鍵區頻繁的移動。 Vim的功能區分為普通模式、輸入模式，以及選取模式，簡單來說，就是移動游標時會在普通模式，而輸入代碼時會在輸入模式，最後，當我們選取一整行要做複製或貼上甚至更複雜的動作時，會在選取模式。 看完以上的剖析，有沒有被Vim吸引到的感覺呢？ 今天的分享就到這裡，我們明天見！","link":"/zh-tw/whyWouldWeUseVIM/"},{"title":"使用 Google Stackdriver 來除錯, 追蹤, 紀錄 以及部署紀錄點","text":"概述這個教程將帶你好好走一趟 Google Stackdriver, 你將學到如何在你 Google Cloud Platform 的應用作以下的操作： 為運行在 App Engine, Compute Engine, Container Engine 的應用製作 Debug Snapshot(Debug 快照) 無需部署額外的 app 即可在 **運行中的應用加入 log point (紀錄點)**。 這是一個真正獨特的功能(且希望是有幫助的)。 追蹤 API calls並且獲取回應時間統計以及代碼內的潛在的瓶頸 檢視Application Logs (應用紀錄) 你將會從 0 開始做下面這些事: 建立一個 Google Cloud Platform 專案 (特別是 App Engine) 設定 Google Cloud platform 專案源碼倉庫 利用 Github 上可獲得的標準的 Guestbook Python Application 源碼 部署代碼 看如何在運行中的應用上獲得 Debug 快照 瞧瞧 Logging (紀錄) 以及 Application Call Traces (應用呼叫追蹤) 在目前運行的應用上加入 logpoints (紀錄點) 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 Stackdriver workspace (工作區)在 Navigation menu, 點擊 Monitoring 當你看到 Stackdriver dashboard (顯示面版)，代表你的工作區已經準備好了 測試進度點擊 Check my progress 來確認目前的進度。 設定並且加載你的私人 Git 倉庫每一個 Google Cloud Platform 都有提供私人的 Git 服務器，但首先你需要先建立一個預設的倉庫 回到主控台，並且到 Navigation menu &gt; Source Repositories &gt; Add Repository: 選擇 Create new repository, 然後選擇 Continue 將新的 repository 命名為 “DEFAULT”, 然後點擊 Create 測試完成任務 點擊 Check my progress 來確認目前的進度。 在 Cloud Shell, 利用以下的指令建立一個資料夾並且進入到這個資料夾內： mkdir stackdriver-demo cd stackdriver-demo/ 現在複製 DEFAULT repository gcloud source repos clone DEFAULT 你應該會看到輸出如下： Cloning into &#x27;/home/gcp123_student/default&#x27;...warning: You appear to have cloned an empty repository.Project [qwiklabs-gcp-1234abc1234] repository [default] was cloned to [/home/gcp123_student/default]. 對的，你沒有看錯，你複製了一個空的 repository - 沒錯。 現在花點時間來研究一下這已經設定好的 git remote, 然後你將會更了解背地裡發生了什麼事。 進到 DEFAULT 資料夾: cd DEFAULT 輸入 git remote -v 指令 git remote -v 你會看到類似以下輸出： origin https://source.developers.google.com/p/qwiklabs-gcp-1234abc1234/r/default (fetch)origin https://source.developers.google.com/p/qwiklabs-gcp-1234abc1234/r/default (push) 這指向了與你的 GCP 專案相關的 Git Repository 從 Github 上 Pull Guestbook 應用Guestbook 應用是可從官方 Google Cloud Platform 的 Github repository 上獲得的標準 App Engine 應用。 這個應用也是在 App Engine 上部署 Python 應用程式的官方文件一部分。 Github 專案可從此獲得：https://github.com/GoogleCloudPlatform/appengine-guestbook-python 運行以下指令來 Pull Guestbook 代碼到你的 Cloud Shell 實例 git pull https://github.com/GoogleCloudPlatform/appengine-guestbook-python 輸出應該如下： remote: Enumerating objects: 493, done.remote: Total 493 (delta 0), reused 0 (delta 0), pack-reused 493Receiving objects: 100% (493/493), 437.58 KiB | 0 bytes/s, done.Resolving deltas: 100% (203/203), done.From https://github.com/GoogleCloudPlatform/appengine-guestbook-python * branch HEAD -&gt; FETCH_HEAD 現在你可以看到很多檔案都從 Github 專案 pull 下來了 利用 Cloud Shell 將目前的代碼 push 到 GCP 專案的 Git Repository利用 Cloud Shell 來將代碼 push 到 GCP 專案 Git repository, 所以你可以在你的代碼設定斷點。 但是我們並不一定要這麼做，因為我們還有其他的方法來連結源碼，像是直接與 Github 或從本地機器做整合 利用標準 git push 指令來 push 代碼 git push origin master 輸出應會如下： Counting objects: 485, done.Compressing objects: 100% (280/280), done.Writing objects: 100% (485/485), 436.42 KiB | 0 bytes/s, done.Total 485 (delta 195), reused 485 (delta 195)remote: Storing objects: 100% (485/485), done.remote: Processing commits: 100% (152/152), done.To https://source.developers.google.com/p/qwiklabs-gcp-1234abc1234/r/default* [new branch] master -&gt; master 現在，回到 GCP Cloud 主控台並重整頁面。 在 Source Repository, 點擊 Source Code, 你應該可以在 DEFAULT repository 中看到所有的專案檔案 部署並且使用 Guestbook 應用你已經完成部署前的工作，輸入 gcloud app deploy 指令來部署 Guestbook App Engine 應用 gcloud app deploy --version 1 當被要求選擇一個 region, 選擇 us-east1 當跳出詢問視窗，選擇 “Y” 繼續 輸出應會如下 You are about to deploy the following services:— qwiklabs-gcp-1234abc1234/default/1 (from [/home/gcp123-student/default/app.yaml])Deployed URL: [https://qwiklabs-gcp-1234abc1234.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...File upload done.Updating service [default]...done.Deployed service [default] to https://qwiklabs-gcp-1234abc1234.appspot.com] 注意到我們提供了一個版本參數給 app deploy 的指令。 我們給了數值 &quot;1&quot; 測試進度 點擊 Check my progress 來確認目前的進度。 因為 Guestbook 應用使用 Google Cloud Datastore 來儲存，所以我們必須更新 Datastore 索引。 這個索引被指定在 index.yaml 檔案中 使用 gcloud datastore indexes create 指令: gcloud datastore indexes create index.yaml 控制台輸出應如下： Configurations to update:descriptor: [index.yaml]type: [datastore indexes]target project: [qwiklabs-gcp-39b46efbe8fc73bf]Do you want to continue (Y/n)? Y 詢問視窗中，輸入 Y 繼續 Datatore 的索引會耗費一些時間更新。 若要確認狀態，可到主控台中的 Navigation menu &gt; Datastore ，然後在左側面板點擊 Indexes 。 當索引正在被建立中時，你會看到狀態顯示為 “Indexing”: 測試進度點擊 Check my progress 來確認目前的進度。 你可以確認你的 App (version 1) 是否有部署成功且可用。 到 Navigation menu &gt; App Engine &gt; Versions: 現在應該一切都看起來 okay。 到 https://PROJECT_ID.appspot.com 看一下你的專案。 將 PROJECT_ID 替換成 Qwiklab 給的 ID 注意： 如果你看到 Internal Server Error, 一分鐘後再試一次，索引可能還在被建立中。 現在從 Guestbook 視窗，使用應用來建立一些數據 棒極了！ 現在你已經完成所有進到 Stackdriver 功能之前的準備工作 測試進度 點擊 Check my progress 來確認目前的進度。 Debug Snapshot (Debug 快照)當你想要 debug 一段特定的 code 時，或者你想要檢查一些變數，但你的應用還處於服務中，這時候快照將非常的有用。現在，當有任何人對你的首頁發請求，並且取得目前在 Datastore 中的問候清單時，你將要求一個快照。這段代碼位於 questbook.py 檔案。 並且，我們將開始在服務中檢查代表，當問候清單從 Datastore 被取得時。 這段代碼在 72 行結束，所以我們在 74 行設一個斷點，這樣我們能確定 72 行將會被執行。我們可以在主控台中使用 App Engine 檢視並且點擊 Tools 下拉選單，然後點擊 Debug 或者在 Stackdriver 瀏覽視窗，在左方面板點擊 Debug在左側面板點擊 guestbook.py, 然後點擊 74 行如下所示 訊息顯示，目前正在等待一個快照被觸發 現在，回到 Guestbook 視窗然後新增一筆數據。 回到 Debug 頁面，快照已被啟動，且 Variables 以及 Call Stack 區塊都被載入了。 你可以展開變數確認各自的值。 比方說，如果你展開 greetings 變數，你將會看到有一些記錄，且這些紀錄與我們之前建立 guestbook 數據的號碼相對應著。 有一個非常方便的功能，那就是我們可以隨時重新做一個快照。點擊照相機的圖示： 快照將會等待被觸發 你也可以使用 Expressions 欄位來追蹤特定的變數。 比方說，當快照被觸發時，我們要檢查一個變數在那一刻的值，我們可以在 Expressions 欄位內輸入變數的名稱 在 Expressions 欄位新增 “greetings”, 然後回到 Guestbook 視窗增加一個新的數據。 當快照被觸發時， greeting 的值將會被載入 如果你想要快照只在滿足特定條件時才被觸發的話，可以使用 Condition 欄位。 下方有個範例，意思是說當 greeting 的數量大於 1 時，快照才會被觸發。 你可以試試看！ 備註： 完整的 Stackdriver Debugger 文件在這:https://cloud.google.com/debugger/docs/ Logpoints (紀錄點)這肯定是一個會讓你興奮到不行的功能。 身為一個開發者，通常我們會盡其所能地在我們的代碼中安置回傳訊息, 像是 php 的 echo 或是 node.js 的 console.log，並希望這些訊息能傳達給我們一切我們想知道的。 但我們都知道，當我們在 debug 的時候，這些訊息永遠都不夠，我們總是需要再安插多一點的回傳訊息。 一般做法，我們需要重新修改我們的代碼，安置額外的回傳訊息，最後重新部署以及監控。 如果說，你可以在運行中的應用增加這些回傳訊息 (稱為紀錄點 logpoints) 呢？ 你不再需要停止應用，修改代碼，重新部署這些步驟了！ 你可以使用 logpoints support，從應用外來管理一系列的紀錄點。 在 Cloud Shell 中，執行以下的指令來檢視目前已經設置好的紀錄點清單 cloudgcloud debug logpoints list 輸出應該是 0 Debug target not specified. Using default target: default-1Listed 0 items. 要增加紀錄點，你需要做以下這些事 確認你想要增加紀錄點的檔案以及確切位置的行數 確認紀錄點的訊息。 這個紀錄點訊息可以是寫死的，也可以是一個表達式。 在本教程中，增加一個紀錄點到檔案 guestbook.py 的第 74 行，使用 logpoints create 指令: gcloud beta debug logpoints create guestbook.py:74 &quot;Fetched greetings from Datastore. Count of greetings : &#123;len(greetings)&#125;&quot; 你可以看到 檔案名稱:行號, 以及紀錄點訊息。 紀錄點訊息也包含了表達式，它會印出從 Datastore 取回的 greetings 數量。 指令回傳訊息顯示紀錄點已經被加進去了： Debug target not specified. Using default target: default-1— id: 53538243519d4-f9a0-bdbcelocation: guestbook.py:74logLevel: INFOlogMessageFormat: Fetched greetings from Datastore. Count of greetings : &#123;len(greetings)&#125;condition: Nonestatus: ACTIVE 現在，如果你執行 logpoints list 指令： cloudgcloud debug logpoints list 你將會看到以下輸出： Debug target not specified. Using default target: default-1STATUS LOCATION CONDITION LOG_LEVEL LOG_MESSAGE_FORMAT IDACTIVEguestbook.py:74 INFO Fetched greetings from Datastore. Count of greetings : &#123;len(greetings)&#125; 53538243519d4-f9a0-bdbce 要看確切的運作，到首頁 https://&lt;PROJECT_ID&gt;.appspot.com 。 這將會觸發代碼，並且觸發紀錄點。 記住，紀錄點訊息會被記錄在預設的 Application Logs。 到 Stackdriver 視窗，並點擊 Logging: 點擊一個特定的請求，瞧！ 在 details 中，你將會看到紀錄點被觸發以及紀錄點訊息被顯示出來。 Traces (追蹤)總是確保你的網頁應用的表現有達到你設定的需求，這件事是很重要的。 Stackdriver Traces 是一個關鍵的工具，它可以讓你了解你應用的延遲。 Traces 在 App Engine 預設就是打開的，它提供了觸手可及的應用表現的細節，包含了所有端點以及不同請求的整體資料。 你已經試過了拜訪首頁 (“/“) 以及檢視 / 增加 guestbook 數據。 這些已經足夠 Traces 提供更多有關延遲的資訊。 在主控台頁面，到 Navigation menu &gt; Trace 來檢視最近的 Stackdriver 追蹤紀錄以及延遲。 點擊任何一筆追蹤來檢視追蹤細節: 你獲得了延遲的資訊，以及哪些要求耗費了更多的時間。 你可以從圖形化介面看到資料庫的請求正在耗費著時間。 或許其中一個可以列入考慮的選項可以是快取資料來降低瓶頸點。 這些資料都來自於你的應用，且如果要找出哪些地方可能需要一些重構的話，這些資訊應該是十分地用幫助。 備註： 完整的 Stackdriver Debugger 文件在這:https://cloud.google.com/debugger/docs/ 搜尋紀錄在你遇到服務中斷之前，花時間學習如何使用你的紀錄將會拯救你免於很多的壓力，且會幫你更快的準確找出問題。 在你自己的專案中，你應該是要固定的使用這些功能，所以當你需要它的時候，你將會知道如何使用它。 讓我們來一起走過一些 Stackdriver Logs 的進階功能。 到 Navigation menu &gt; &gt; Logging __ 。 點擊篩選框右手邊的三角形圖案，然後選取 “Convert to advanced filter” 現在你可以使用一個特別的語法 來明確你想要檢視的特定紀錄 例如說, 這個語法限制了你將只能看到 GAE 的紀錄訊息 cloudresource.type=&quot;gae_app&quot; 若要增加更多的語句到篩選器，你可以加更多行 你也可以使用運算子像是 AND, OR, NOT, &gt;, &lt;, 等等。 這是一個只顯示 ERROR 以及 CRITICAL 訊息的篩選表達語句 cloudseverity=(&quot;ERROR&quot; OR &quot;CRITICAL&quot;) Stackdriver 將 Severity 與數字香連續，所以你也可以使用數字比較，像是： cloudresource.type = gae_app ANDseverity &gt;= ERROR 使用者介面將會自動補齊，包含欄位名稱以及可能的欄位的值 已存在的紀錄篩選有一個簡單的方法可以找到一個正確的，我們想要填入進階篩選器中的數值。 試試看： 檢視你的紀錄直到你找到你想要鎖定的訊息類型。 然後點擊欄位，然後點擊 “Show Matching Entries”。 這將會自動地將正確的數值載入篩選器中。 你也可以使用 “Hide Matching Entries” 來移除會干擾你的訊息 儲存及分享一旦你已經花時間找出正確的篩選器數值，你應該會想要將它們儲存並且分享給你的隊友們。 點擊篩選器右方的三角形圖案，你將可以獲得這個你剛剛建立的篩選器的連結。 你可以跟你的隊友們分享這個連結，或是將它存在你的文件當中。 備註： 完整的 Stackdriver Debugger 文件在這:https://cloud.google.com/debugger/docs/ 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 恭喜你已經完成本教程","link":"/zh-tw/usingGoogleStackdriverDebugTracesLoggingAndLogpoints/"}],"tags":[{"name":"Laravel Transaction","slug":"Laravel-Transaction","link":"/zh-tw/tags/Laravel-Transaction/"},{"name":"Laravel Log","slug":"Laravel-Log","link":"/zh-tw/tags/Laravel-Log/"},{"name":"ngrok","slug":"ngrok","link":"/zh-tw/tags/ngrok/"},{"name":"Laravel Middleware","slug":"Laravel-Middleware","link":"/zh-tw/tags/Laravel-Middleware/"},{"name":"GCP Essentials","slug":"GCP-Essentials","link":"/zh-tw/tags/GCP-Essentials/"},{"name":"QWIKLABS","slug":"QWIKLABS","link":"/zh-tw/tags/QWIKLABS/"},{"name":"Google Load Balancers","slug":"Google-Load-Balancers","link":"/zh-tw/tags/Google-Load-Balancers/"},{"name":"GCP Compute Engine","slug":"GCP-Compute-Engine","link":"/zh-tw/tags/GCP-Compute-Engine/"},{"name":"GCP Marketplace","slug":"GCP-Marketplace","link":"/zh-tw/tags/GCP-Marketplace/"},{"name":"GCP Kubernetes Engine","slug":"GCP-Kubernetes-Engine","link":"/zh-tw/tags/GCP-Kubernetes-Engine/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/zh-tw/tags/Kubernetes/"},{"name":"Google Kubernetes Engine Best Practices","slug":"Google-Kubernetes-Engine-Best-Practices","link":"/zh-tw/tags/Google-Kubernetes-Engine-Best-Practices/"},{"name":"Google Cloud IAM","slug":"Google-Cloud-IAM","link":"/zh-tw/tags/Google-Cloud-IAM/"},{"name":"GCP-Security & Identity Fundamentals","slug":"GCP-Security-Identity-Fundamentals","link":"/zh-tw/tags/GCP-Security-Identity-Fundamentals/"},{"name":"AWS SQS","slug":"AWS-SQS","link":"/zh-tw/tags/AWS-SQS/"},{"name":"Laravel Queue","slug":"Laravel-Queue","link":"/zh-tw/tags/Laravel-Queue/"},{"name":"Laravel","slug":"Laravel","link":"/zh-tw/tags/Laravel/"},{"name":"Laravel blade","slug":"Laravel-blade","link":"/zh-tw/tags/Laravel-blade/"},{"name":"Laravel template","slug":"Laravel-template","link":"/zh-tw/tags/Laravel-template/"},{"name":"Laravel view","slug":"Laravel-view","link":"/zh-tw/tags/Laravel-view/"},{"name":"Linux","slug":"Linux","link":"/zh-tw/tags/Linux/"},{"name":"Node.js","slug":"Node-js","link":"/zh-tw/tags/Node-js/"},{"name":"MongoDB","slug":"MongoDB","link":"/zh-tw/tags/MongoDB/"},{"name":"class","slug":"class","link":"/zh-tw/tags/class/"},{"name":"object","slug":"object","link":"/zh-tw/tags/object/"},{"name":"PayPal REST API","slug":"PayPal-REST-API","link":"/zh-tw/tags/PayPal-REST-API/"},{"name":"GCP Stackdriver","slug":"GCP-Stackdriver","link":"/zh-tw/tags/GCP-Stackdriver/"},{"name":"Baseline: Infrastructure","slug":"Baseline-Infrastructure","link":"/zh-tw/tags/Baseline-Infrastructure/"},{"name":"Laravel Image","slug":"Laravel-Image","link":"/zh-tw/tags/Laravel-Image/"},{"name":"Laravel package Intervention","slug":"Laravel-package-Intervention","link":"/zh-tw/tags/Laravel-package-Intervention/"},{"name":"Facebook login","slug":"Facebook-login","link":"/zh-tw/tags/Facebook-login/"},{"name":"Google login","slug":"Google-login","link":"/zh-tw/tags/Google-login/"},{"name":"Apple login","slug":"Apple-login","link":"/zh-tw/tags/Apple-login/"},{"name":"NFS","slug":"NFS","link":"/zh-tw/tags/NFS/"},{"name":"Hexo","slug":"Hexo","link":"/zh-tw/tags/Hexo/"},{"name":"minos","slug":"minos","link":"/zh-tw/tags/minos/"},{"name":"SFTP","slug":"SFTP","link":"/zh-tw/tags/SFTP/"},{"name":"Character Sets","slug":"Character-Sets","link":"/zh-tw/tags/Character-Sets/"},{"name":"Collations","slug":"Collations","link":"/zh-tw/tags/Collations/"},{"name":"Unicode","slug":"Unicode","link":"/zh-tw/tags/Unicode/"},{"name":"MySQL","slug":"MySQL","link":"/zh-tw/tags/MySQL/"},{"name":"GCP Cloud Functions","slug":"GCP-Cloud-Functions","link":"/zh-tw/tags/GCP-Cloud-Functions/"},{"name":"GCP IAM","slug":"GCP-IAM","link":"/zh-tw/tags/GCP-IAM/"},{"name":"Google Cloud Storage","slug":"Google-Cloud-Storage","link":"/zh-tw/tags/Google-Cloud-Storage/"},{"name":"GCP-Baseline:Infrastructure","slug":"GCP-Baseline-Infrastructure","link":"/zh-tw/tags/GCP-Baseline-Infrastructure/"},{"name":"Kubernetes health check","slug":"Kubernetes-health-check","link":"/zh-tw/tags/Kubernetes-health-check/"},{"name":"GCP Storage","slug":"GCP-Storage","link":"/zh-tw/tags/GCP-Storage/"},{"name":"Cloud Architecture","slug":"Cloud-Architecture","link":"/zh-tw/tags/Cloud-Architecture/"},{"name":"GCP Spinnaker","slug":"GCP-Spinnaker","link":"/zh-tw/tags/GCP-Spinnaker/"},{"name":"Jenkins","slug":"Jenkins","link":"/zh-tw/tags/Jenkins/"},{"name":"Kubernetes in the Google Cloud","slug":"Kubernetes-in-the-Google-Cloud","link":"/zh-tw/tags/Kubernetes-in-the-Google-Cloud/"},{"name":"Stackdriver Logging","slug":"Stackdriver-Logging","link":"/zh-tw/tags/Stackdriver-Logging/"},{"name":"PHP","slug":"PHP","link":"/zh-tw/tags/PHP/"},{"name":"Tree","slug":"Tree","link":"/zh-tw/tags/Tree/"},{"name":"Binary Search Tree","slug":"Binary-Search-Tree","link":"/zh-tw/tags/Binary-Search-Tree/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/zh-tw/tags/Binary-Tree/"},{"name":"Heap","slug":"Heap","link":"/zh-tw/tags/Heap/"},{"name":"WordPress","slug":"WordPress","link":"/zh-tw/tags/WordPress/"},{"name":"Google Deployment Manager","slug":"Google-Deployment-Manager","link":"/zh-tw/tags/Google-Deployment-Manager/"},{"name":"Recursion","slug":"Recursion","link":"/zh-tw/tags/Recursion/"},{"name":"Docker Image","slug":"Docker-Image","link":"/zh-tw/tags/Docker-Image/"},{"name":"Docker Container","slug":"Docker-Container","link":"/zh-tw/tags/Docker-Container/"},{"name":"Docker Swarm","slug":"Docker-Swarm","link":"/zh-tw/tags/Docker-Swarm/"},{"name":"Docker Multi Stage","slug":"Docker-Multi-Stage","link":"/zh-tw/tags/Docker-Multi-Stage/"},{"name":"Docker Compose","slug":"Docker-Compose","link":"/zh-tw/tags/Docker-Compose/"},{"name":"Docker Service","slug":"Docker-Service","link":"/zh-tw/tags/Docker-Service/"},{"name":"Docker Rolling Update","slug":"Docker-Rolling-Update","link":"/zh-tw/tags/Docker-Rolling-Update/"},{"name":"Docker Push","slug":"Docker-Push","link":"/zh-tw/tags/Docker-Push/"},{"name":"Docker Deployment","slug":"Docker-Deployment","link":"/zh-tw/tags/Docker-Deployment/"},{"name":"git rebase -i","slug":"git-rebase-i","link":"/zh-tw/tags/git-rebase-i/"},{"name":"git rebase -i --onto","slug":"git-rebase-i-onto","link":"/zh-tw/tags/git-rebase-i-onto/"},{"name":"git reset --hard","slug":"git-reset-hard","link":"/zh-tw/tags/git-reset-hard/"},{"name":"git reset @^ --hard","slug":"git-reset-hard","link":"/zh-tw/tags/git-reset-hard/"},{"name":"git checkout -b","slug":"git-checkout-b","link":"/zh-tw/tags/git-checkout-b/"},{"name":"git flow","slug":"git-flow","link":"/zh-tw/tags/git-flow/"},{"name":"layout","slug":"layout","link":"/zh-tw/tags/layout/"},{"name":"gcloud shell","slug":"gcloud-shell","link":"/zh-tw/tags/gcloud-shell/"},{"name":"vsftpd","slug":"vsftpd","link":"/zh-tw/tags/vsftpd/"},{"name":"ftp","slug":"ftp","link":"/zh-tw/tags/ftp/"},{"name":"Facebook Graph API","slug":"Facebook-Graph-API","link":"/zh-tw/tags/Facebook-Graph-API/"},{"name":"git","slug":"git","link":"/zh-tw/tags/git/"},{"name":"git template","slug":"git-template","link":"/zh-tw/tags/git-template/"},{"name":"Git","slug":"Git","link":"/zh-tw/tags/Git/"},{"name":"git init","slug":"git-init","link":"/zh-tw/tags/git-init/"},{"name":"git tag -a","slug":"git-tag-a","link":"/zh-tw/tags/git-tag-a/"},{"name":"git checkout","slug":"git-checkout","link":"/zh-tw/tags/git-checkout/"},{"name":"git log --oneline","slug":"git-log-oneline","link":"/zh-tw/tags/git-log-oneline/"},{"name":"git revert","slug":"git-revert","link":"/zh-tw/tags/git-revert/"},{"name":"GCP virtual machine","slug":"GCP-virtual-machine","link":"/zh-tw/tags/GCP-virtual-machine/"},{"name":"Daemon","slug":"Daemon","link":"/zh-tw/tags/Daemon/"},{"name":"SSH","slug":"SSH","link":"/zh-tw/tags/SSH/"},{"name":"Gitlab pusher","slug":"Gitlab-pusher","link":"/zh-tw/tags/Gitlab-pusher/"},{"name":"GCP Pub/Sub","slug":"GCP-Pub-Sub","link":"/zh-tw/tags/GCP-Pub-Sub/"},{"name":"GCP-Baseline: Infrastructure","slug":"GCP-Baseline-Infrastructure","link":"/zh-tw/tags/GCP-Baseline-Infrastructure/"},{"name":"git config","slug":"git-config","link":"/zh-tw/tags/git-config/"},{"name":"git config --global user.name","slug":"git-config-global-user-name","link":"/zh-tw/tags/git-config-global-user-name/"},{"name":"git config --global user.email","slug":"git-config-global-user-email","link":"/zh-tw/tags/git-config-global-user-email/"},{"name":"AWS","slug":"AWS","link":"/zh-tw/tags/AWS/"},{"name":"Apache","slug":"Apache","link":"/zh-tw/tags/Apache/"},{"name":"garbles","slug":"garbles","link":"/zh-tw/tags/garbles/"},{"name":"AWS SES","slug":"AWS-SES","link":"/zh-tw/tags/AWS-SES/"},{"name":"Ngrok","slug":"Ngrok","link":"/zh-tw/tags/Ngrok/"},{"name":"Laravel Mail","slug":"Laravel-Mail","link":"/zh-tw/tags/Laravel-Mail/"},{"name":"git add","slug":"git-add","link":"/zh-tw/tags/git-add/"},{"name":"git commit","slug":"git-commit","link":"/zh-tw/tags/git-commit/"},{"name":"git commit -a","slug":"git-commit-a","link":"/zh-tw/tags/git-commit-a/"},{"name":"HTTP","slug":"HTTP","link":"/zh-tw/tags/HTTP/"},{"name":"PayPal Payment Standard","slug":"PayPal-Payment-Standard","link":"/zh-tw/tags/PayPal-Payment-Standard/"},{"name":"PayPal IPN","slug":"PayPal-IPN","link":"/zh-tw/tags/PayPal-IPN/"},{"name":"CI/CD","slug":"CI-CD","link":"/zh-tw/tags/CI-CD/"},{"name":"CSV","slug":"CSV","link":"/zh-tw/tags/CSV/"},{"name":"InfluxDB","slug":"InfluxDB","link":"/zh-tw/tags/InfluxDB/"},{"name":"Kubernetes Dashboard","slug":"Kubernetes-Dashboard","link":"/zh-tw/tags/Kubernetes-Dashboard/"},{"name":"Docker","slug":"Docker","link":"/zh-tw/tags/Docker/"},{"name":"k6","slug":"k6","link":"/zh-tw/tags/k6/"},{"name":"Kubernetes StorageClass","slug":"Kubernetes-StorageClass","link":"/zh-tw/tags/Kubernetes-StorageClass/"},{"name":"Kubernetes Volumes","slug":"Kubernetes-Volumes","link":"/zh-tw/tags/Kubernetes-Volumes/"},{"name":"Kubernetes Lifecycle Hooks","slug":"Kubernetes-Lifecycle-Hooks","link":"/zh-tw/tags/Kubernetes-Lifecycle-Hooks/"},{"name":"Kubernetes DaemonSet","slug":"Kubernetes-DaemonSet","link":"/zh-tw/tags/Kubernetes-DaemonSet/"},{"name":"Kubernetes RBAC","slug":"Kubernetes-RBAC","link":"/zh-tw/tags/Kubernetes-RBAC/"},{"name":"Kubernetes configMap","slug":"Kubernetes-configMap","link":"/zh-tw/tags/Kubernetes-configMap/"},{"name":"Kubernetes Deployments","slug":"Kubernetes-Deployments","link":"/zh-tw/tags/Kubernetes-Deployments/"},{"name":"Laravel Documentation","slug":"Laravel-Documentation","link":"/zh-tw/tags/Laravel-Documentation/"},{"name":"Laravel Session","slug":"Laravel-Session","link":"/zh-tw/tags/Laravel-Session/"},{"name":"Laravel Carbon","slug":"Laravel-Carbon","link":"/zh-tw/tags/Laravel-Carbon/"},{"name":"Laravel Database","slug":"Laravel-Database","link":"/zh-tw/tags/Laravel-Database/"},{"name":"Laravel Query Builder","slug":"Laravel-Query-Builder","link":"/zh-tw/tags/Laravel-Query-Builder/"},{"name":"Laravel Redis","slug":"Laravel-Redis","link":"/zh-tw/tags/Laravel-Redis/"},{"name":"Laravel Seeding","slug":"Laravel-Seeding","link":"/zh-tw/tags/Laravel-Seeding/"},{"name":"Nginx","slug":"Nginx","link":"/zh-tw/tags/Nginx/"},{"name":"Composer","slug":"Composer","link":"/zh-tw/tags/Composer/"},{"name":"Supervisor","slug":"Supervisor","link":"/zh-tw/tags/Supervisor/"},{"name":"SELinux","slug":"SELinux","link":"/zh-tw/tags/SELinux/"},{"name":"Redis","slug":"Redis","link":"/zh-tw/tags/Redis/"},{"name":"PHP-FPM","slug":"PHP-FPM","link":"/zh-tw/tags/PHP-FPM/"},{"name":"GIT","slug":"GIT","link":"/zh-tw/tags/GIT/"},{"name":"Laravel Artisan Console","slug":"Laravel-Artisan-Console","link":"/zh-tw/tags/Laravel-Artisan-Console/"},{"name":"Laravel Broadcasting","slug":"Laravel-Broadcasting","link":"/zh-tw/tags/Laravel-Broadcasting/"},{"name":"Laravel Cache","slug":"Laravel-Cache","link":"/zh-tw/tags/Laravel-Cache/"},{"name":"Laravel Collections","slug":"Laravel-Collections","link":"/zh-tw/tags/Laravel-Collections/"},{"name":"Laravel Events","slug":"Laravel-Events","link":"/zh-tw/tags/Laravel-Events/"},{"name":"Laravel Helpers","slug":"Laravel-Helpers","link":"/zh-tw/tags/Laravel-Helpers/"},{"name":"Laravel HTTP Client","slug":"Laravel-HTTP-Client","link":"/zh-tw/tags/Laravel-HTTP-Client/"},{"name":"Laravel File Storage","slug":"Laravel-File-Storage","link":"/zh-tw/tags/Laravel-File-Storage/"},{"name":"Laravel Localization","slug":"Laravel-Localization","link":"/zh-tw/tags/Laravel-Localization/"},{"name":"Laravel Notifications","slug":"Laravel-Notifications","link":"/zh-tw/tags/Laravel-Notifications/"},{"name":"Laravel Task Scheduling","slug":"Laravel-Task-Scheduling","link":"/zh-tw/tags/Laravel-Task-Scheduling/"},{"name":"Laravel Eloquent ORM Collections","slug":"Laravel-Eloquent-ORM-Collections","link":"/zh-tw/tags/Laravel-Eloquent-ORM-Collections/"},{"name":"Laravel Eloquent ORM","slug":"Laravel-Eloquent-ORM","link":"/zh-tw/tags/Laravel-Eloquent-ORM/"},{"name":"Laravel Mutators","slug":"Laravel-Mutators","link":"/zh-tw/tags/Laravel-Mutators/"},{"name":"Laravel Serialization","slug":"Laravel-Serialization","link":"/zh-tw/tags/Laravel-Serialization/"},{"name":"Laravel Blade Templates","slug":"Laravel-Blade-Templates","link":"/zh-tw/tags/Laravel-Blade-Templates/"},{"name":"n+1 issue","slug":"n-1-issue","link":"/zh-tw/tags/n-1-issue/"},{"name":"Laravel Octane","slug":"Laravel-Octane","link":"/zh-tw/tags/Laravel-Octane/"},{"name":"Laravel - Backpack","slug":"Laravel-Backpack","link":"/zh-tw/tags/Laravel-Backpack/"},{"name":"Laravel Fortify","slug":"Laravel-Fortify","link":"/zh-tw/tags/Laravel-Fortify/"},{"name":"Laravel Sail","slug":"Laravel-Sail","link":"/zh-tw/tags/Laravel-Sail/"},{"name":"Laravel Socialite","slug":"Laravel-Socialite","link":"/zh-tw/tags/Laravel-Socialite/"},{"name":"Laravel Telescope","slug":"Laravel-Telescope","link":"/zh-tw/tags/Laravel-Telescope/"},{"name":"Laravel - QRCODE","slug":"Laravel-QRCODE","link":"/zh-tw/tags/Laravel-QRCODE/"},{"name":"Laravel Authentication","slug":"Laravel-Authentication","link":"/zh-tw/tags/Laravel-Authentication/"},{"name":"Laravel Authorization","slug":"Laravel-Authorization","link":"/zh-tw/tags/Laravel-Authorization/"},{"name":"Laravel Email Verification","slug":"Laravel-Email-Verification","link":"/zh-tw/tags/Laravel-Email-Verification/"},{"name":"Laravel Encryption","slug":"Laravel-Encryption","link":"/zh-tw/tags/Laravel-Encryption/"},{"name":"Laravel Hashing","slug":"Laravel-Hashing","link":"/zh-tw/tags/Laravel-Hashing/"},{"name":"Laravel Password Reset","slug":"Laravel-Password-Reset","link":"/zh-tw/tags/Laravel-Password-Reset/"},{"name":"Laravel Console Tests","slug":"Laravel-Console-Tests","link":"/zh-tw/tags/Laravel-Console-Tests/"},{"name":"Laravel Testing Database","slug":"Laravel-Testing-Database","link":"/zh-tw/tags/Laravel-Testing-Database/"},{"name":"Laravel Testing","slug":"Laravel-Testing","link":"/zh-tw/tags/Laravel-Testing/"},{"name":"Laravel HTTP Tests","slug":"Laravel-HTTP-Tests","link":"/zh-tw/tags/Laravel-HTTP-Tests/"},{"name":"Laravel Controller","slug":"Laravel-Controller","link":"/zh-tw/tags/Laravel-Controller/"},{"name":"Laravel CSRF Protection","slug":"Laravel-CSRF-Protection","link":"/zh-tw/tags/Laravel-CSRF-Protection/"},{"name":"Laravel Testing Mocking","slug":"Laravel-Testing-Mocking","link":"/zh-tw/tags/Laravel-Testing-Mocking/"},{"name":"Laravel Error Handling","slug":"Laravel-Error-Handling","link":"/zh-tw/tags/Laravel-Error-Handling/"},{"name":"Laravel Requests","slug":"Laravel-Requests","link":"/zh-tw/tags/Laravel-Requests/"},{"name":"Laravel Responses","slug":"Laravel-Responses","link":"/zh-tw/tags/Laravel-Responses/"},{"name":"Laravel Logging","slug":"Laravel-Logging","link":"/zh-tw/tags/Laravel-Logging/"},{"name":"Laravel URL Generation","slug":"Laravel-URL-Generation","link":"/zh-tw/tags/Laravel-URL-Generation/"},{"name":"Laravel Views","slug":"Laravel-Views","link":"/zh-tw/tags/Laravel-Views/"},{"name":"Laravel Queues","slug":"Laravel-Queues","link":"/zh-tw/tags/Laravel-Queues/"},{"name":"Laravel API Resource","slug":"Laravel-API-Resource","link":"/zh-tw/tags/Laravel-API-Resource/"},{"name":"Laravel Configuration","slug":"Laravel-Configuration","link":"/zh-tw/tags/Laravel-Configuration/"},{"name":"Laravel Relationships","slug":"Laravel-Relationships","link":"/zh-tw/tags/Laravel-Relationships/"},{"name":"Laravel Deployment","slug":"Laravel-Deployment","link":"/zh-tw/tags/Laravel-Deployment/"},{"name":"Laravel Routing","slug":"Laravel-Routing","link":"/zh-tw/tags/Laravel-Routing/"},{"name":"Laravel Validation","slug":"Laravel-Validation","link":"/zh-tw/tags/Laravel-Validation/"},{"name":"Let's Encrypt","slug":"Let-s-Encrypt","link":"/zh-tw/tags/Let-s-Encrypt/"},{"name":"SSL","slug":"SSL","link":"/zh-tw/tags/SSL/"},{"name":"Kubernetes Resources","slug":"Kubernetes-Resources","link":"/zh-tw/tags/Kubernetes-Resources/"},{"name":"leetcode","slug":"leetcode","link":"/zh-tw/tags/leetcode/"},{"name":"Markdown","slug":"Markdown","link":"/zh-tw/tags/Markdown/"},{"name":"GCP VPC","slug":"GCP-VPC","link":"/zh-tw/tags/GCP-VPC/"},{"name":"Netdata","slug":"Netdata","link":"/zh-tw/tags/Netdata/"},{"name":"NGINX","slug":"NGINX","link":"/zh-tw/tags/NGINX/"},{"name":"OS","slug":"OS","link":"/zh-tw/tags/OS/"},{"name":"Bubble Sort","slug":"Bubble-Sort","link":"/zh-tw/tags/Bubble-Sort/"},{"name":"Insertion Sort","slug":"Insertion-Sort","link":"/zh-tw/tags/Insertion-Sort/"},{"name":"Selection Sort","slug":"Selection-Sort","link":"/zh-tw/tags/Selection-Sort/"},{"name":"PHPSTORM","slug":"PHPSTORM","link":"/zh-tw/tags/PHPSTORM/"},{"name":"pm2","slug":"pm2","link":"/zh-tw/tags/pm2/"},{"name":"GitLab CI / CD","slug":"GitLab-CI-CD","link":"/zh-tw/tags/GitLab-CI-CD/"},{"name":"Sequelize","slug":"Sequelize","link":"/zh-tw/tags/Sequelize/"},{"name":"Node,js","slug":"Node-js","link":"/zh-tw/tags/Node-js/"},{"name":"Stackdriver APM","slug":"Stackdriver-APM","link":"/zh-tw/tags/Stackdriver-APM/"},{"name":"SQL Statements","slug":"SQL-Statements","link":"/zh-tw/tags/SQL-Statements/"},{"name":"Secondary Indexes","slug":"Secondary-Indexes","link":"/zh-tw/tags/Secondary-Indexes/"},{"name":"ssh-add","slug":"ssh-add","link":"/zh-tw/tags/ssh-add/"},{"name":"ssh-agent","slug":"ssh-agent","link":"/zh-tw/tags/ssh-agent/"},{"name":"multiple items","slug":"multiple-items","link":"/zh-tw/tags/multiple-items/"},{"name":"variables","slug":"variables","link":"/zh-tw/tags/variables/"},{"name":"MacOS","slug":"MacOS","link":"/zh-tw/tags/MacOS/"},{"name":"Linux crontab","slug":"Linux-crontab","link":"/zh-tw/tags/Linux-crontab/"},{"name":"Command Line","slug":"Command-Line","link":"/zh-tw/tags/Command-Line/"},{"name":"TypeScript","slug":"TypeScript","link":"/zh-tw/tags/TypeScript/"},{"name":"Kubernetes Solutions","slug":"Kubernetes-Solutions","link":"/zh-tw/tags/Kubernetes-Solutions/"},{"name":"GCP BigQuery","slug":"GCP-BigQuery","link":"/zh-tw/tags/GCP-BigQuery/"},{"name":"git log","slug":"git-log","link":"/zh-tw/tags/git-log/"},{"name":"VIM","slug":"VIM","link":"/zh-tw/tags/VIM/"},{"name":"GCP Cloud Shell","slug":"GCP-Cloud-Shell","link":"/zh-tw/tags/GCP-Cloud-Shell/"},{"name":"GCP Cloud Storage","slug":"GCP-Cloud-Storage","link":"/zh-tw/tags/GCP-Cloud-Storage/"},{"name":"Facebook 長期權杖","slug":"Facebook-長期權杖","link":"/zh-tw/tags/Facebook-%E9%95%B7%E6%9C%9F%E6%AC%8A%E6%9D%96/"},{"name":"Facebook 永不過期權杖","slug":"Facebook-永不過期權杖","link":"/zh-tw/tags/Facebook-%E6%B0%B8%E4%B8%8D%E9%81%8E%E6%9C%9F%E6%AC%8A%E6%9D%96/"},{"name":"歐付寶","slug":"歐付寶","link":"/zh-tw/tags/%E6%AD%90%E4%BB%98%E5%AF%B6/"},{"name":"歐付寶 付款","slug":"歐付寶-付款","link":"/zh-tw/tags/%E6%AD%90%E4%BB%98%E5%AF%B6-%E4%BB%98%E6%AC%BE/"},{"name":"歐付寶 退款","slug":"歐付寶-退款","link":"/zh-tw/tags/%E6%AD%90%E4%BB%98%E5%AF%B6-%E9%80%80%E6%AC%BE/"},{"name":"gcloud CLI","slug":"gcloud-CLI","link":"/zh-tw/tags/gcloud-CLI/"},{"name":"PayPal 退款","slug":"PayPal-退款","link":"/zh-tw/tags/PayPal-%E9%80%80%E6%AC%BE/"},{"name":"PayPal 授權","slug":"PayPal-授權","link":"/zh-tw/tags/PayPal-%E6%8E%88%E6%AC%8A/"},{"name":"PayPal 請款","slug":"PayPal-請款","link":"/zh-tw/tags/PayPal-%E8%AB%8B%E6%AC%BE/"},{"name":"PayPal 取消授權","slug":"PayPal-取消授權","link":"/zh-tw/tags/PayPal-%E5%8F%96%E6%B6%88%E6%8E%88%E6%AC%8A/"},{"name":"PayPal 建立授權訂單","slug":"PayPal-建立授權訂單","link":"/zh-tw/tags/PayPal-%E5%BB%BA%E7%AB%8B%E6%8E%88%E6%AC%8A%E8%A8%82%E5%96%AE/"},{"name":"PayPal 款項凍結","slug":"PayPal-款項凍結","link":"/zh-tw/tags/PayPal-%E6%AC%BE%E9%A0%85%E5%87%8D%E7%B5%90/"},{"name":"UML","slug":"UML","link":"/zh-tw/tags/UML/"},{"name":"WebDAV","slug":"WebDAV","link":"/zh-tw/tags/WebDAV/"},{"name":"多語","slug":"多語","link":"/zh-tw/tags/%E5%A4%9A%E8%AA%9E/"},{"name":"多語系","slug":"多語系","link":"/zh-tw/tags/%E5%A4%9A%E8%AA%9E%E7%B3%BB/"},{"name":"雙語","slug":"雙語","link":"/zh-tw/tags/%E9%9B%99%E8%AA%9E/"},{"name":"部落格","slug":"部落格","link":"/zh-tw/tags/%E9%83%A8%E8%90%BD%E6%A0%BC/"},{"name":"GCP Persistent Disk","slug":"GCP-Persistent-Disk","link":"/zh-tw/tags/GCP-Persistent-Disk/"},{"name":"Laradock","slug":"Laradock","link":"/zh-tw/tags/Laradock/"},{"name":"高併發","slug":"高併發","link":"/zh-tw/tags/%E9%AB%98%E4%BD%B5%E7%99%BC/"},{"name":"ssh-keygen","slug":"ssh-keygen","link":"/zh-tw/tags/ssh-keygen/"},{"name":"ssh-copy-id","slug":"ssh-copy-id","link":"/zh-tw/tags/ssh-copy-id/"},{"name":"scp","slug":"scp","link":"/zh-tw/tags/scp/"},{"name":"config","slug":"config","link":"/zh-tw/tags/config/"}],"categories":[{"name":"GCP","slug":"GCP","link":"/zh-tw/categories/GCP/"},{"name":"Facebook","slug":"Facebook","link":"/zh-tw/categories/Facebook/"},{"name":"Ops","slug":"Ops","link":"/zh-tw/categories/Ops/"},{"name":"Dev","slug":"Dev","link":"/zh-tw/categories/Dev/"},{"name":"OOP","slug":"OOP","link":"/zh-tw/categories/OOP/"},{"name":"Hexo","slug":"Hexo","link":"/zh-tw/categories/Hexo/"},{"name":"Data Structure and Algorithm","slug":"Data-Structure-and-Algorithm","link":"/zh-tw/categories/Data-Structure-and-Algorithm/"},{"name":"Git","slug":"Git","link":"/zh-tw/categories/Git/"},{"name":"Frontend","slug":"Frontend","link":"/zh-tw/categories/Frontend/"},{"name":"TOOLs","slug":"TOOLs","link":"/zh-tw/categories/TOOLs/"},{"name":"HTTP","slug":"HTTP","link":"/zh-tw/categories/HTTP/"},{"name":"ssh","slug":"ssh","link":"/zh-tw/categories/ssh/"},{"name":"金流","slug":"金流","link":"/zh-tw/categories/%E9%87%91%E6%B5%81/"},{"name":"資料庫","slug":"資料庫","link":"/zh-tw/categories/%E8%B3%87%E6%96%99%E5%BA%AB/"}]}