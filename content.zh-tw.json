{"pages":[{"title":"關於我","text":"你好, 這是我的部落格, 我是 Ray, 一個後端開發者, 喜歡 Dev, 也熱愛 Ops。 這是 我的履歷 幾年前, 因為一場意外, 我得了一種病, 學名叫做 learnOrDie, 翻譯成中文叫做不學會死。 自此之後, 我就像孟母三遷之後的孟子那樣, 鑿壁偷光, 雪地夜讀, 懸樑刺股, 臥薪嘗膽… 不好意思, 多了。 從軍隊退伍後的幾年間, 我可以感受到, 人生軌跡這條堅韌的無形細絲線, 在我以身軀為槍, 時間為彈, 及意志力連續扣動板機之下, 雖不明顯, 但它的確是悄悄地、緩緩地動了。 首先, 我自學英文, 並取得多益金色, 之後任職國外業務, 並獲得母語客戶肯定口說水準。 若要跟專業口譯、翻譯人員相比或許還尚有段距離, 但除特殊領域需現場口譯的場合之外, 聽說讀寫皆可無礙溝通, 至此, 英文能力算是 Get 。 在這過程中, 不知不覺間, 學習似乎已成了我生活的一部分, 它就像是呼吸般那樣的自然, 必要。 能與來自世界各地的人交流, 國外業務工作雖有趣, 可隨著我不懂的產業知識越來越少, 我對知識的渴求也越來越高, 像吸血鬼之於血, 如魚之於水, 似人, 之於氧氣。 因緣際會之下, 我接觸到 coding。 就像瀕死的寄生蟲終於找到宿主, 幹這樣說可能有點噁心, 可在這一刻, 這是搜刮我的金魚腦後可找到最貼切的形容詞。 然後我就果斷地辭掉工作, 投入這個新領域！ 看似沈悶而單調的黑視窗, 對別人來說陌生可畏有如外星生物般神秘的語法, 卻讓生無美感, 不知藝術為何物的我, 以需求為畫布, 邏輯為原料, 語言為畫筆, 在 Dev 的世界潑墨大寫意肆意揮灑, 有那麼好幾個瞬間, 覺得自己就是個藝術家。 艱澀生僻的 Internet、OS 協議及運作原理, 填補了我對知識渴求的缺口, 也像一塊塊拼圖, 拼出 Ops 的輪廓。 期待, 能循著名為架構的設計圖, 如凌空俯視的建築師, 建造可承受大洪水浩劫的諾亞方舟。 好了, 我該去學習了！ 因為, 不學真的會死。","link":"/zh-tw/about/index.html"},{"title":"archives","text":"","link":"/zh-tw/archives/index.html"},{"title":"categories","text":"","link":"/zh-tw/categories/index.html"},{"title":"Schedule","text":"2020/2/27Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/26Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/25Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/24Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/23Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/22Target and result today Work: Deposit list Learning: Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Jogging Reading Book: 2020/2/21Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Controller Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/20Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/19Target and result today Work: Deposit list Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/18Target and result today Work: Login Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/17Target and result today Work: Login Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/16Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Middleware Reviewing Exercise: Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/15Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/14Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/13Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 2020/2/12Target and result today Work: Existing code understanding Con-call Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: Others: 2020/2/11Target and result today Work: Existing code understanding Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Pull-up Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: 2020/2/10Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: 2020/2/9Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Reading Book: Others: Resume improving 2020/2/8Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: Others: Resume improving 2020/2/7Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: pull-up Reading Book: Others: Resume improving 2020/2/6Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: Resume improving 2020/2/5Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation Reviewing Exercise: Jogging Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: Resume improving 2020/2/4Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Exercise: Pull-up Reading Book: Others: Resume improving 2020/2/3Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Exercise: Squat Reading Book: MIS 82 個一定要懂的伺服器建置與管理知識 Others: Resume improving 2020/2/2Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book 2020/2/1Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book History","link":"/zh-tw/schedule/index.html"},{"title":"tags","text":"","link":"/zh-tw/tags/index.html"},{"title":"Japanese","text":"2020-2-27生きる 母と電話で話しました 買う 米 日曜日は海に行きました 五月五日は祝日です 五つ 側 八日からイギリスに行きます こっち 柿の木に実がたくさんなりました ソフトクリームを二つください 彼はシートベルト締めた 水曜日はバイトがあります 泊まる 手伝う 彼は時々遅刻します 夕食には何を食べたいですか そのデモについて、政府は何もしなかった 受ける 突然、電気が消えた 結果 期待 まあ今回は許してあげよう 発生 対策 米 五つ 生活 もう それは全て事実ですか 電気がついたままですよ お金はまだ十分あります この部分は問題ないです 昨年 あの塾はパートにチラシを配ってもらいます ペットを飼いましょうよう タバコを吸ってはいけませんか いいえ、吸ってもいいです 友達は私に本を買ってくれました 水曜日はバイトがあります 手伝う 最近、雨の日が多いです。それに、台風も二個来ました なぜ大体のお店は試食を置きますか 日本語先生のくせに、日本語で自己紹介することもできません 旅行会社の人は家族に海外旅行のビザを申し込んでくれました このパソコン、使ってもいいですか はい、使ってもいいですよ いつが暇ですか 土曜日か日曜日 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげました カバンに香水があります テレビを付けました。しかし、画面がなかなか出ません 彼女は彼氏に食事代を払ってもらいます タバコを吸ってはいけませんか はい、吸ってはいけません 課長は電話しています ジーンズを買いましょうか 小西さんはあなたに映画のチケットをあげましたよね 今夜は蒸し暑いですから、明日は雨が降るでしょう 電気屋の人は私に新しいテレビを運んでくれました 彼は泳いでいます 私はご飯を食べています 彼は妻に昼ごはんの弁当を作ってもらいます 母は私に飴を買ってくれました えっと、電車が遅れましたので、遅刻しました 私は日本料理を作ることが少しできます 先月私は台湾を旅行しました 私はご飯を食べて、テレビを見て、宿題をする 机 原稿改訂する 美味しい 私は物理の基礎は知っています 葉が落ちます サツマイモ 2020-2-26今朝は早く家を出ました 質問 払う みんなにお菓子をあげましょう 安い 美しい 肩 腰 閉める 駅 食べ物 曲がる 万 治る 突然、電気が消えた 生活 彼は食品工場で働いています 今回 除く 対策 予定 コンピュター 弟は父の性格がわかります あの塾はパートにチラシを配ってもらいます 私は友達に本を買ってもらいます 私はご飯を食べています この店は高いけれども、全然美味しくありません 北川さんはたくさん食べましたが、全然太りません 私は懐石料理がかなり好きです 旅行会社の人は家族に海外旅行のビザを申し込んでくれます みてください スピーチは何時からですか 私あなたにプレゼントをあげましたよね 庭の松は高くありませんでした あれはカーテンです ニュースで道の状況がわかります 中村さんは昨日夜１０時まで仕事をしましたので、残業代がたくさんもらえるでしょう 生活 それで？ どうした 私は宿題をしています 田村さんは林さんに中国語を教えてもらいます 明日の食券をください 食べて みて あげて 寝て 始めて 集めて 忘れて 対策 課長は電話しています 運動場で走ります もう25歳なのに、両親らからお小遣いをもらいます この本、借りてもいいですか いいえ、借りてはいけません 弟は私に部屋を掃除してくれます 待ってくれますか 吸って 買って 言って 打って 待って 立って 切って 帰って 送って 売って 何曜日が暇ですか 旅行会社の人は私にホテルに予約してくれます 彼女は彼氏に食事代を払ってもらいます あの日本料理店は広くて、美味しくて、安いです 王さんは彼女にギターを弾いてあげます 彼は泳いでいます 楓 解答 スプレー 駅弁 布 走る 切る 帰る ㎝ 2020-2-25車 漢字は中国から来ました 酒 近く 病気 見つかる 彼に会えて嬉しかった ハワイは4回目です 触る 教科書を閉じとください 六日前に日本に帰ってきました 5日 その計算は間違っている その問題に関する記事を読みました 変わる 全国 関する 仕事はほぼ終わりました 予定 彼は事故で怪我をしました それは最近話題の本ですね まあ、今回は許してあげよう 変化 写真 今後の方針が決まった この服とあの服、どちらが可愛いですか 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう もう25歳なのに、両親からお小遣いをもらいます 課長は電話しています 彼女は私に新しい手帳をくれました 先生はクラスメートに綺麗な絵本を貸してあげます 私は弟に部屋を掃除してもらいます 電気屋の人は私に新しいテレビを運んでくれます 私はあなたに宿題の答えを教えてあげます あの塾はパートにチラシを配ってもらいます 法律は破ってはいけません 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません なぜ大体のお店は試食を置きますか この車はとんでもなく高いくせに、すぐ故障しました テレビを付けました。しかし、画面がなかなか出ません 役所の人は私たちに道を案内してくれました どこも行きません 参勤、雨の日が多いです。それに、台風もにこ来ました 彼女は彼氏に食事代を払ってもらいました この本、借りてもいいですか 田村さんは林さんに中国語を教えてもらいます 彼は泳いでいます 夜中にギターを弾いてはいけません 母は怒っています ないでください 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 彼の父は彼に新しい腕時計をもらいました 新しパソコンを買いましたが、キーボードがありません 私は宿題をしています 最後に、南東から台北に帰りました あの塾はパートにチラシを配ってもらいます 私は旅行会社の人にホテルを予約してもらいます あなたのカバンはこれです 母は弟にオモチャを買ってあげます 私はサラリーマンで、父親です 明日からは夏休みです。でも、宿題がいっぱいあります 台風の時に、海辺で遊んではいけません 私は本屋で本を買って、開いて、読む あのお爺さんは妹に靴を直してくれます 私は学生ではありません 日本語先生のくせに、日本語で自己紹介することもできません ゴミ箱 マイカー 猿 フライト 駅弁 アリクイが行ったり来たりしている 走る 切る 帰る フットボール そのボトルには二リットルのコーラが入っている あの塾はパートにチラシを配ってもらいます 駅弁 走る 帰る 切る 2020-2-24部屋 私はワインが好きです 今会社に戻ります 肩が凝りました こう 私は電車で通学しています 私たちは来年、家を建てます 素敵な色のセーターですね ウエイターを呼ぶましょう 夏休みももう終わりだ 上る 見つかる 渇く 後ろを向いて これはかなり金がかかった 父 予定 改革 なお 彼は行政を改革したいと思っている 方法 事実 写真はいい思い出になります 彼はその詩を用いて自分の気持ちを伝えた この単語の意味を辞書で調べましょう 与える まあ、今回は許してあげよ ジーンズを買いましょうか 飛行機が二時間遅れました。なので、到着時間に遅くなります うそ 道に迷いました。それで、交番に道を尋ねに行きました 夏なのに、陽明山で雪が降りました パソコンを買いましたが、キーボードがありません 母は弟にオモチャを買ってあげます その塾はパートにチラシを配ってもらいます 見つかる 宿題をしました。それに、明日の授業の予習もしました 予定 あの店は高いけれども、全然美味しくありません 彼は妻に昼ご飯の弁当を作ってもらいます ここの公務員は暇なくせに、文句を言います この本、借りてもいいですか して きて 私はあなたに宿題の答えを教えてあげます 二月に日本を旅行しました。それから、韓国と中国にも行きました バカ！言い訳するな 旅行会社の人は家族に海外旅行のビザを申し込んでくれました まあ、今回は許してあげよ あれは店長のカーテンです お金を振り込んだくせに、商品が全く来ません 夜中にギターを弾いてはいけません 法律を破ってはいけません 先生はクラスメートに綺麗な絵本を貸してあげます 私はご飯を食べています 私の好きなことは音楽です 役所の人は私たちに道を案内してくれます 私あ宿題をしています あの塾はパートにチラシを配ってもらいます どうして台湾の会社は大学生を雇いたくないのですか 高野さんは私に英語を教えてくれました 見つかる ご飯を食べる時に、テレビを見てはいけません なぜ大体のお店は試食を置きますか 私ゲームが好きです 書いて 描いて 続いて 泳いで 課長は電話しています このパソコン、使ってもいいですか いいえ、使ってはいけません 基隆の夜市は有名で、賑やかです 私は部長のことが嫌いです 母は怒っています 田村さんは林さんに中国語を教えてもらいます 彼女は彼氏に食事代を払ってもらいます タバコを吸ってはいけません 彼は泳いでいます 私は頑張りたくありませんでした 彼は運動場で倒れました。そして、三分後救急車が来ました 私はご飯を食べて、テレビを見て、宿題をする 彼女は私に新しい手帳をくれました 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 雨 布団 走る 切る 帰る 栓抜き サツマイモ なぜ大体のお店は試食を置きますか 彼女は彼氏に食事代を払ってもらいます 彼女は私に新しい手帳をくれました 帰る 走る 切る 2020-2-23知る 見せる 授業 見つける 約束を忘れないてください 起きる 食べ物 日 万 嬉しい 財布は机の下にあった 晴れる 一日 何か飲み物が欲しいな 飲み物 閉める 彼は泳いでいます 時計を見たら、ちょうど３時だった 男の人は私に話しかれた 対象 これら 話 影響 彼が文章がとてもうまい ここが建物の中心です 選挙 二十キロのダイエットは可能だと思いますか 彼は泳いでいます 特徴 それは全て事実ですか 完成 予定 母は怒っています 比べる ほぼ 部分 今回 方針 従来 計算 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 宿題をしました。それに、明日の授業の予習もしました 友達は私に本を買ってくれました タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 予定 田村さんは林さんに中国語を教えてもらいます 母は怒っています 法律を破ってはいけません 課長は電話しています 彼女は彼氏に食事代を払ってもらいます アフリカにキリンがいます ドアを開ける ジーンズを買いましょうか 行って 私は宿題をしています 明日からは夏休みだけれども、宿題がいっぱいあります あの喫茶店は静かなので、あそこで勉強する人が多いでしょう あの塾はパートにチラシを配ってもらいます 寮の管理員さんは郵便物をみんなんのメールボックスに入れてあげます 法律を破ってはいけません 課長は電話しています ジーンズを買いましょうか 私の得意なことはギターを弾くことです あの塾はパートにチラシを配ってもらいます 私は弟に部屋を掃除してもらいます タバコを吸ってはいけませんか はい、吸ってはいけません 高野さんは私に英語を教えてくれます お金持ちのくせに、スーパーで散々値切りをしました 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 庭の松は高いです 待って 書いて 見て 食べて して 来て 彼は泳いでいます 夏なのに、要名山で雪が降りました 私はご飯を食べています 次に、桃園で飛行機を見に行きました 彼は妻に昼ごはんの弁当を作っても洗います 私は旅行会社の人にホテルを予約してもらいます あの店の弁当は美味しいのに、４０元もかかりません 基隆の夜市は有名で、賑やかです 貯金箱に40個のコインがあります 法律を破ってはいけません 床に蟻がいます どうしてキリンの首が長いですか 母は怒っています 電気屋の人は私に新しいテレビを運んでくれました 王さんは彼女にギターを弾いてあげます 予備校生 タプレット 虎 宝石 そのボトルには二リットルのコーラが入っている 買い物カートは空です 蝉 ぴ 課長は電話しています 彼は泳いでいます 母は怒っています 課長は電話しています 2020-2-22そう 美しい たつ 親の愛は有り難い 汚い もの道をまっすぐ行くと駅です 入る お店はもう閉まっていました 渇く 万 彼女は彼氏に食事代を払ってもらいます 食べ物 答えが違います 建設 彼はその詩を用いて自分の気持ちを伝えた 政権が交代した 彼女は彼氏に食事代を払ってもらいます それは全て事実ですか それは全て事実ですか 彼女は彼氏に食事代を払ってもらいます ドル 続ける 彼がクラスの代表だ 国は国語教育を強化しています 彼は食品工場で働いています 力 昨年 全体の八十パーセントが完成しました 田村さんは林さんに中国語を教えてもらいます 万 食べ物 引っ越しを業者に頼んだ 段階 首相 中心 従来 交差点で事故が発生した 彼女は彼氏に食事代を払ってもらいます それは全て事実ですか この段階では、決断するのはまだ早い 彼女は彼氏に食事代を払ってもらいます 十分 ほとんど 発生 それは世界最大の船です 王さんは彼女にギターを弾いてあげます あの塾はパートにチラシを配ってもらいます 田村さんは林さんに中国語を教えてもらいます 先生はクラスメートに綺麗な絵本を貸してあげます あの塾はパートにチラシを配ってもらいます ジーンズを買いましょうか 田村さんは林さんに中国語を教えてもらいます あの絵は綺麗です。なのに、誰も買いません あの塾はパートにチラシを配ってもらいます タバコを吸ってはいけませんか はい、吸ってはいけませ あのお爺さんは妹に靴を直してくれます このノートは私のノートです 私はあなたにプレゼントをあげましたよね 都市は田舎より便利です 宿題の答えを教えてあげます 昨日、どこにか行きましたか はい、コンサートに行きました 私はご飯を食べています 私の部屋は小さくて、暗くて、汚いです 母は私に飴を買ってくれます 私は弟に部屋を掃除してもらいます 私は友達に本を買ってもらいます お金持ちのくせに、スーパーで散々値切りをしました 彼女を幸せにする 法律を破ってはいけません 日本、ヨーロッパ、そしてアメリカを旅行しました 私は電気屋の人に新しいテレビを運んてくれます ジーンズを買いましょうか 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 田村さんは林さんに中国語を教えてもらいます あの塾はパートにチラシを配ってもらいます 彼は妻に昼ごはんの弁当を作ってもらいます あの塾はパートにチラシを配ってもらいます 私ご飯を食べています 法律を破ってはいけません どうして台湾の会社は大学生を雇いたくないのですか 電気屋の人は私に新しいテレビを運んでくれます ジーンズを買いましょう 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます あの塾はパートにチラシを配ってもらいます 旅行会社の人は家族に海外旅行のビザを申し込んでくれます あの塾はパートにチラシを配ってもらいます 母は弟にオモチャを買ってあげます 明日からは夏休みだけれども、宿題がいっぱいあります テレビをつけましたけれども、画面がなかなか出ません あの塾はパートにチラシを配ってもらいます 台風の時に、海辺で遊んではいけません タバコを吸ってはいけませんか いいえ、吸ってもいいですよ あの塾はパートにチラシを配ってもらいました 私は旅行会社の人にホテルに予約してもらいます 食べてください 私は電気屋の人は新しいテレビを運んでくれます 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 旅行会社の人は家族に海外旅行のビザを申し込んでもらいます 先生はテストの解答がわかります 私はご飯を食べています この店は高いけれども、全然美味しくありません 夜 梅 合格点 涼しい 皿 私は宿題をしています 蟹 あの塾はパートにチラシを配ってもらいます ティーカップとソーサー あの塾はパートにチラシを配ってもらいます そのボトルには2リットルのコーラが入っている 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私は宿題をしています 私はご飯を食べています 私は宿題をしています そのボトルには二リットルのコーラが入っている 私は宿題をしています 2020-2-21息子は飛行機のオモチャが好きです 会議は四時に終わります 妹は平仮名を全部覚えました 膝に痛みを感じます 約束を忘れないてください 話す 二十日 五日 九つ 日本の食べ物は美味しいです 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます ソフトクリームを二つください 駄目 時 多分 彼は食品工場で働いています 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 今月と先月の売上を比べた その問題関する記事を読みました 備える 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 政権 進める オスモさんは、みんな力持ちだ 状態 変化 彼女は私のスケジュールを管理している 消える 今回 生活 私は友達に本を買ってもらいます どこが賑やかですか 母は弟におもちゃを買ってあげます すみません、今は何時ですか 私はあなたに宿題の答えを教えてあげます タバコを吸ってはいけません 駅の前に新しいコンビニができます。それから、駅の後ろにもコンビニできます 白い紙を黒くする この絵は綺麗なのに、誰も買いません 王さんは彼女にギターを弾いてあげます 彼は食品工場で働いています お客さんは家に来ました 母は私に飴を買ってくれました それで？ ここからどうします 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです 先生はクラスメートに綺麗な絵本を貸してあげます 寮の管理員さんは郵便物をみんなのメールボックスに入れてあげます 私は友達に本を買ってもらいます 私は友達に本を買ってもらいました この店は高いけれども、全然美味しくありません テレビをつけましたが、画面がなかなか出ません なんで台湾の会社は大学生を雇いなくなりましたか 本棚に小説と雑誌があります 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません この絵が綺麗です。なのに、誰も買いません 私は弟に部屋を掃除してもらいます あの店は高いけれども、全然美味しくありません 私は友達に本を買ってもらいます 役所の人は私たちに道を案内してくれました えっと、電車が遅れたので、遅刻しました 先生は学生の気持ちがわかります 貯金箱に40個のコインがあります 高野さんは私に英語を教えてくれました 私は旅行会社の人にホテルを予約してもらいます 明日の食券をください 電気屋の人は私に新しいテレビを運んでくれます あのおじいさんは妹に靴を直ってくれます なんで台湾の会社は大学生を雇いたくないのですか 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私は弟に部屋を掃除してもらいます あなたは彼女に期末テストの解答をもらいましたよね 彼は妻に昼ご飯の弁当を作ってもらいます 弟は学業を続けたがります 私は自分の力で仕事を探します なるほど、これは正方形ですね それは誰のパソコンですか 夜中にギターを弾いてはいけません 食べる時に、テレビを見てはいけません 書いてくれますか 私は弟に部屋を掃除してくれました あの人は木に登ることができます 弟は父の性格がわかります この本、借りてもいいですか いいえ、借りてはいけません 私は旅行会社の人にホテルを予約してもらいます 私はパソコンで字を打って、インターネットして、印刷する それは彼のジュースです テストはいつですが 明日や明後日や来週なとです 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 彼女は飛行機を運転することができます 乗客 彼は妻に昼ごはんの弁当を作ってもらいます レンタサイクル ポルトガル 妹 書店 私は旅行会社の人にホテルを予約してもらいました 生徒 愛妻弁当 ピザ かっこいい フットボール 脈を取る 茶髪 彼は彼の妻に昼ごはんの弁当を作ってもらいました 私は弟に部屋を掃除してもらいます 私は旅行会社の人にホテルを予約してもらいます 彼は妻に昼ご飯の弁当を作ってもらいました 2020-2-20九份は賑やかです 始める 膝に痛みを感じます 彼女はよく旅行に行きます 約束を忘れないてください 彼女は来月結婚します そこに大きな円を描いて 少ない 続く 私はワイン好きです 旅行会社の人は家族に海外旅行のビザを申し込んでくれます ソフトクリームを二つください 細い お願い 千円貸してください 夕食には何を食べたいですか この書類を書き直してください 強い 違う いつか 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私が手伝いましょう 会社 今回 私は政治に関心がある 国は国語教育を強化しています 今日の新聞どこに置いた 約束を忘れないでください のち 交渉 私はあなたに宿題の答えを教えてあげます あまり お金はまだ十分あります その問題に関する記事を読みました 旅行会社の人は家族に海外旅行のビザを申し込んでくれます いつか 今回 旅行会社の人は家族に海外旅行のビザを申し込んでくれます 私はあなたに宿題の答えを教えてあげます 全国 母は弟にオモチャを買ってあげます 影響 国内 なお、雨の場合は中止です 変化 私はあなたにプレゼントをあげましたよ 私は歩いて、電車に乗って、バスに乗る このパソコン、使ってもいいですか。 はい、使ってもいいですよ お金を振り込んだくせに、商品が全く来ません 私は味噌汁が全然嫌いではありません 王さんは彼女にギターを弾いてあげます 待ってくれますか タバコを吸ってはいけません 夜中にギターを弾いてはいけません ご飯を食べる時に、テレビを見てはいけません 王さんは彼女にギターを弾いてあげます 役所の人は私たちに道を案内してくれます あのおじいさんは妹に靴を直してくれます 私はサラリーマンで、父親です 冷蔵庫のケーキ、食べでもいいですか いいえ、食べてはいけません 先生はクラスメートに綺麗な絵本を貸してあげます その問題に関する記事を読みます 母は私に飴を買ってくれます 母は弟にオモチャを買ってあげます 私は風邪をひきました。だから、明日学校に行きたくありません この車はとんでもなく高いくせに、すぐ故障しました 大きて 小さて 広くて 狭くて 道を迷いました。それで、交番に道を尋ねに行きました 彼女は可愛いけれども、わがままな人です あの絵が綺麗なのに、誰も買いません 私はあなたに宿題の答えを教えてあげます 王さんは彼女にギターを弾いてあげます 本棚に小説と雑誌があります あの店は高いけれども、全然美味しくありません 私はパソコンで字を打って、インターネットして、印刷する おじいさんは昔の記憶を忘れたがります あの公園は綺麗で、静かで、有名です 法律を破ってはいけません この店は高いです。ですが、全然美味しくありません 私の趣味は作るとこです 高野さんは私に英語を教えてくれます 母は弟にオモチャを買ってあげます 先生はクラスメートに綺麗な絵本を貸してあげます 庭の松は高かったです 飛行機が二時間遅れました。だから、それで怒っている人は多いでしょう 彼女可愛いですが、わがままな人です 電車やの人は私に新しいテレビを運んでくれます 私は紙で鶴を作りました 王さんは彼女にギターを弾いてあげます この本、借りてもいいですか いいえ、借りてはいけません 私はあなたに宿題の答えを教えてあげます あの店は高いけれども、全然美味しくありません このパソコン、使ってもいいですか いいえ、使ってはいけません 中村さんは昨日夜１０時まで仕事をしましたから、今日は来ませんよね ふーん、それで 先生はクラスメートに綺麗な絵本を貸してあげます 見てくれますか 給料をたくさんもらうくせに、全然仕事をしません 台風の時に、海辺で遊んではいけません 母は弟にオモチャを買ってあげます 弁当 布 宝石 ラーメン アリクイ フットボール 電気屋の人は私に新しいテレビを運んでくれます 王さんは彼女にギターを弾いてあげます 先生はクラスメートに綺麗な絵本を貸してあげます フットボール 電気屋の人は私に新しいテレビを運んでくれます 2020-2-19私はワインが好きです 彼は数学を教えています おこる 死ぬ いつも 美しい グラスの数が足りません 見える 十日後に帰ります 六つ 高野さんは私に英語を教えてくれます 高校生 来月の二十日は弟の誕生日です 方針 今回 高野さんは私に英語を教えてくれます 彼は一人旅の計画を立てた 部長除く全員が土曜日も働いた 影響 彼は選挙に出るつもりだ 電気屋の人は私に新しいテレビを運んでくれます 塩、胡椒加えてください 高野さんは私に英語を教えてくれます 以上 彼はその死を用いて自分の気持ちを伝えた 商品 ガソリンの価格がどんどん上がっている 作業 発生 今後 交渉 音楽は彼の得意な分野です 工場 電気屋の人は私に新しいテレビを運んでくれます 昨年 今回 引っ越しを業者に頼んだ 示す 除く 彼は新製品に興味を示している このパソコン、使ってもいいですか いいえ、使ってはいけません 影響 高野さんは私に英語を教えてくれます この車はとんでもなく高いくせに、すぐ故障します 役所の人は私たちに道を案内してくれます 母は私に飴を買ってくれます ここの公務員は暇なくせに、文句を言います 電気屋の人は私に新しいテレビを運んでくれます 高野さんは私に英語を教えてくれます タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 私はあなたにプレゼントをあげましたよね 役所の人は私たちに道を案内してくれます 上野さんは彼女と映画を見ました 電気屋の人は私に新しいテレビを運んでくれます 明日の食券をください 私はノートパソコンをテレビにする 彼は私の両親に美味しい日本料理をくれました このノートは私のです まず、台北のお寺と夜市に行きました あの公園は綺麗で、静かで、有名です 動物園のパンダは小さかったです 給料をたくさんもらうくせに、全然仕事をしません 役所の人は私たちに道を案内してくれます 法律を破ってはいけません 飛行機が二時間遅れました。なので、到着時間も遅くなります あのお爺さんは妹に靴を直してくれます あのお爺さんは妹に靴を直してくれます 私はあなたにプレゼントをあげましたよね もう25歳なのに、両親からお小遣いをもらいます 役所の人は私たちに道を案内してくれます 私はあなたに誕生日プレゼントをもらいましたよね 夜中にギターを弾いてはいけません 何を食べますか 定食かうどんかラーメンですね 私の部屋は狭くて、暗くて、汚いです 話はここまでです。あ、それから このパソコンを使ってもいいですか はい、使ってもいいですよ タバコを吸ってはいけませんか はい、吸ってはいけません 法律を破ってはいけません 台風の時に、海辺で遊んではいけません 彼女は英語の先生で、動物園のボランティアです この本、借りてもいいですか あの日本料理店は広くて、美味しくて、安いです あのお爺さんは妹に靴を直してくれます ロッキングチェア 大人 あのお爺さんは妹に靴を直してくれます 龍 夜中にギターを弾いてはいけません 解答 ㎝ あのおじいさんは妹に靴を直してくれます 2020-2-18座る 郵便局で切手を買いました 私は朝シャワーを浴びます また会いましょう 会う 私は体が丈夫だ 近い 首 彼の日本語のレベルは私の同じくらいだ 私は電車で通学しています 宿題は自分でやりなさい 教科書を閉じてください 見つかる 左 渇く ある 方針 昨年 国会 発生 理由 備える もう 全国 その計算は間違っている バラには色々な種類があります ほとんど 結果 いずれ その仕事は危険を伴う 多く 待ってくれますか 明日の食券をください タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 夜中にギターを弾いてはいけません 昨日財布をなくしました。それに、傘も電車に忘れました 弟は父の性格がわかります 台風の時に、海辺で遊んではいけません そして、台中で有名な湖の隣のホテルに泊まりました 方針 昨年 スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 発生 飛んで 運で 遊んで 読んで 住んで 死んで えっと、電車が遅れたので、遅刻しました 彼女は英語の先生で、動物園のボランティアです 私は彼女のことが好きです 中村さんは昨日夜１０時まで仕事をしましたので、残業代がたくさんもらえるでしょう あの歌手は有名だけれども、歌が下手です 法律を破ってはいけません 明日の食券をください 夜中にギターを弾いてはいけません 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう タバコを吸ってはいけませんか はい、吸ってはいけません もう朝なのに、なかなか起きる事ができません 北川さんはたくさん食べましたけれども、全然太りません 食べてくれますか 今夜は蒸し暑いですから、明日は雨が降るでしょう タバコを吸ってはいけません 最近、雨の日が多いです。それに、台風も二個来ました 向日葵は草より綺麗です 母は私に飴を買ってくれます ご飯を食べる時に、テレビを見てはいけません 私は日本の神社に参拝しましたよ。あ、それからお守りも買いました 母は私に飴を買ってくれます どうして今日遅刻した 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 見てくれますか 夜中にギターを弾いてはいけません 明日の食券をください 買いてくれますか 貸して 指して 無くして 刺して 出して 戻して 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 宝石 原稿を改訂する 合格点 炒める 物理学 かっこいい男 め 母は私に飴を買ってくれます 母は私に飴を買ってくれます 母は私に飴を買ってくれます 2020-2-17軽い 払う 言う 楽しむ 工事は3月まで続きます 遅い 私は去年フランスへ行った みんなにお菓子をあげましょう 夜中にギターを弾いてはいけません もう 辺 大人 優しい 彼は行政を改革したいと思っている システムの構成を変えてみました 夜中にギターを弾いてはいけません 夜中に弾いてはいけません 全国 引っ越しを業者に頼んだ 対象 バラには色々な種類があります 彼はいいところだけを強調した 母はまだ外国に行ったことがありません それはどういう意味ですか 待ってくれますか これは重要な書類です ただ 彼は非常に高い技術を持っている 待ってくれますか 国は国語教育を強化しています あの店は高いです。ですが、全然美味しくありません この車はとんでもなく高いくせに、すぐ故障します 書いてくれますか あの服のほうか可愛いです ご飯を食べる時に、テレビを見てはいけません 庭の松は高いです 明日からは夏休みです。でも、宿題がいっぱいあります 全国 夜中にギターを弾いてはいけません 私は歩いて、電車に乗って、バスに乗る 見てくれますか 夜中に、ギターを弾いてはいけません 台風の時に、海辺で遊んではいけません 法律を破ってはいけません 私は本屋で本を買って、開くて、読む まず、台北のお寺と夜市に行きました 私はフォークでパスタを食べました 私の部屋は小さいくて、暗くて、汚いです 食べてくれますか この本、借りてもいいですか いいえ、借りてはいけません 待ってくれますか 国仲さんはあなたにギターをもらいました 私は日本料理を作ることができます 私は自分の力で仕事を探します 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです タバコを吸ってはいけませんか はい、吸ってはいけません 書いてくれますか 目覚しとけいをかけたのに、なかなか鳴りません あの店の弁当は美味しいのに、40元もかかりません 台風の時に、海辺で遊んではいけません 見てくれますか 法律を破ってはいけません 先生の隣に父と母がいます タバコを吸ってはいけません いつが暇ですか 土曜日か日曜日です 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません ニュースで道の状況がわかります 食べてくれますか 私ご飯を食べて、テレビを見て、宿題をする タバコを吸ってはいけませんか はい、吸ってはいけません このパソコン、使ってもいいですか いいえ、使ってはいけません このパソコン、使ってもいいですか はい、使ってもいいですよ 今夜は蒸し暑いから、明日は雨が降るでしょう 中村さんは昨日夜１０時まで仕事をしましたから、今日は来ませんよね 私はサラリーマンで、父親です 待ってください 書いてください 見てください 食べてください してください 来てください えっと、電車か遅れ他ので、遅刻しました 弟は父の性格がわかります タバコを吸ってはいけませんか はい、吸ってはいけません タバコを吸ってはいけませんか いいえ、吸ってもいいですよ あの歌手は有名だけれども、歌が下手です 基隆の夜市は有名で、賑やかです キャベツ 宝石 使い捨て 屋上 合格点 原稿を改訂する プルトガル タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 炒める タバコを吸ってはいけませんか はい、吸ってはいけません えっと、電車が遅れましたので、遅刻しました 弟は父の性格がわかります タバコを吸ってはいけませんか いいえ、吸ってもいいですよ 宝石 合格点 タバコを吸ってはいけませんか イエイ、吸ってもいいですよ 2020-2-16私が払いましょう 教える 短い ドアを開けてください 私はワインが好きです 建てる 気 私は二日待った 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません 茶色 渇く 四日 ソフトクリームを二つください この道をまっすぐ行くと駅です 閉める 多分 タバコを吸ってはいけません 九つ ない 財布は机の下にあった 強調 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 話 仕事を続けください みんな私たちに期待しています 内容 トラブルがやっと解決した お金はまだ十分あります タバコを吸ってはいけません いい方法思いつきました 問題 災害に備えて大量の水を買い込んだ 外国 彼はその詩を用いて自分の気持ちを伝えた この服は三百ドルしました 法律を破ってはいけません 冷蔵庫のケーキ、食べてもいいですか。 いいえ、食べてはいけません 写真はいい思い手になります 法律を破ってはいけまあせん 解決 法律を破ってはいけません 変化 タバコを吸ってはいけません 法律を破ってはいけません 階段 私は書店で本を買って、開くて、読む 冷蔵庫のケーキ、食べてもいいですか いいえ、食べてはいけません 私は日本語が全然できません 台風の時に、海辺で遊んではいけません 台風の時に、海辺で遊んではいかません タバコを吸ってはいかません 私はサラリーマンで、父親です それで、これからどうします 日本、ヨーロッパ、そしてアメリカを旅行しました 台風の時に、海辺で遊んではいけません あの公園は綺麗で、静かで、有名です 私はパソコンで字を打って、インターネットして、印刷する うそ この本、借りてもいいですか 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ そのパソコン、使ってもいいですか はい、使ってもいいですよ 台風の時に、海辺で遊んではいけません 寂しい人 この本、借りてもいいですか いいえ、借りてはいけません 法律を破ってはいけません 図書館に本とパソコンがあります あの車は この車はとんでもなく高いくせに、すぐ故障します 法律を破ってはいけません このパソコン、使ってもいいですか いいえ、使ってはいけません して きて 大きくて 小さくて 広くて 狭くて テレビをつけましたけれども、画面がなかなか出ません 基隆の夜市は有名で、賑やかです ご飯を食べる時に、テレビを見てはいけません もう25歳なのに、両親からお小遣いをもらいます 歩く あなたは彼女に期末テストの解答をもらいましよね 台風の時に、海辺で遊んではいけません ご飯を食べる時に、テレビを見てはいけません たつ 課長 羊 布 博物館 ご飯を食べる時に、テレビを見てはいけません 台風の時に、海辺で遊んではいけません この車はとんでもなく高いくせに、すぐ故障します ご飯を食べる時に、テレビを見てはいけません あの車はとんでもなく高いくせに、すぐ故障します ご飯を食べる時に、テレビを見てはいけません 2020-2-15短い 探す 今年 右 早い 出る 赤いバラを買いました 気持ち 上る はい、借りてもいいですよ 空く 細い ご主人はお元気ですか 女 開ける 休む 男の人が私たちに話しかけた 手紙が届くのに三日かかりました このパソコン、使ってもいいですか はい、使ってもいいですよ 渇く 曲がる 力 帰ったら、まず手を洗いましょう お金はまだ十分あります 対象 可能 建設 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ 外国 変化 国は国語教育を強化しています 計算 住宅 彼は事故で怪我をしました 多く 計画を一部変更しましょう この本、借りてもいいですか これら 対する 国会 彼は行政を改革したいと思っている テレビをつけました。しかし、画面がなかなか出ません はい、借りてもいいですよ このパソコン、使ってもいいですか はい、使ってもいいですよ お金はまだ十分あります 変化 私んは自分の力で仕事を探しました 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ あの絵は綺麗なのに、誰も買いません 和食と言えば、寿司や味噌汁や天ぷらなどです 私の得意なことはギターを弾くことです この本、借りてもいいですか いいえ、借りてはいけません 彼女は英語の先生で、動物園のボランティアです 私はパソコンで、字を打って、インターネットして、印刷する この本、借りてもいいですか いいえ、借りてはいけません なんでこんな時間に学校にいないのですか 私は日本料理が好きです 私の部屋は狭くて、暗くて、汚いです もう25歳なのに、両親からお小遣いをもらいます この本、借りてもいいですか 私はご飯を食べて、テレビを見て、宿題をする もう朝なのに、なかなか起きることができません 変化 このパソコン、使ってもいいですか いいえ、使ってはいけません 引き出しにハムスターが一匹います それから、台中の有名な湖の隣のホテルに泊まりました あの日本料理店は広くて、美味しくて、安いです 食べて 見て 開けて 寝て 始めて 忘れて 集めて 私はピーマンが嫌いです あの店の料理は美味しいです。それに、値段も安いです 友達は朝９時に家にきました。そhして、夜６時にみんなに帰りました この本、借りてもいいですか いいえ、カリではいけません パソコンを買いましたけれども、キーボードがありません 林さんは私にコンサートのチケットをくれました 待って 書いて 見て 食べて して 来て 小林さんは中国語を話すことができます あの公園は綺麗で、静かで、有名です このパソコン、使ってもいいですか はい、使ってもいいですよ 石原さんは彼に防虫スプレーをもらいました このパソコン、使ってもいいですか いいえ、使ってはいけません 飛行機は二時間遅れました。なので、到着時間も遅くなります 布 紙粘土 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいです ポルトガル 解答 湖 教科書 メロン この本、借りてもいいですか ええい、借りてはいけません 雨の後、虹が見られるかもhしれません 虹 栓抜き 蝉 そのパソコン、使ってもいいですか いいえ、使ってはいけません このパソコン、使ってもいいですか はい、使ってもいいですよ 布 冷蔵庫のケーキ、食べてもいいですか はい、食べてもいいですよ この本、借りてもいいですか いいえ、借りてはいけません このパソコン、使ってもいいですか いいえ、使ってはいけません 2020-2-14電車 兄は水泳が得意です 狭い 起こす 多い 送る 私はワインが好きです 四月に大学に入学しました ハワイは4回目です お母さんによろしくを伝えください 夕食には何を食べたいですか 彼女は茶色の靴履いています 道 見つかる お腹 渇く 国は国語教育を強化しています 引っ越しを業者に頼んだ 調査 株 会談 行う 競争 与える 種類 自由 待ってください 書いてください 見てください 食べてください して下さい 来て下さい 話 彼はその詩を用いて自分の気持ちを伝えた 前売券は窓口で販売しています 強化 北川さんはたくさん食べましたけれども、全然太りません あの公園は綺麗で、静かで、有名です 私はサラリーマンで、父親です お金持ちのくせに、スーパーで散々値切りをしました 彼女は英語の先生で、動物園のボランティアです 明日からは夏休みです。でも、宿題がいっぱいあります 二月に日本を旅行しました。それから、韓国と中国にも行きました もう25歳なのに、両親からお小遣いももらいます 渇く 国は国語教育を強化しています 本棚に小説と雑誌があります 私は歩いて、電車に乗って、バスに乗る 基隆の夜市は有名で、賑やかです 明日からは夏休みですが、宿題がいっぱいあります 道に迷いました。それで、交番に道を尋ねに行きました あの日本料理店は広くて、美味しくて、安いです テレビをつけましたが、画面がなかなかでません 私の部屋は狭くて、暗くて、汚いです 私は料理を作ることができます 部屋でご飯を食べる 待ってください 書いてください 見てください 食べてください してください 来てください この本、借りてもいいですか この本、借りてもいいですか 私はパソコンで字を打った、インターネットして、印刷する 大きくて 小さくて 広くて 狭くて この服とあの服、どちらが可愛いですか 書いて 描いて 続いて 泳いで もう25歳なのに、両親からお小遣いももらいます パソコンを買いましたけれども、キーボードがありません 天気を良くありません、それで、海に行くのをやめました 私は自分の力で仕事を探します 飛行機を二時間遅れました。なので、到着時間も遅くなります 買って 言って 打って 待って 立って 切って 帰って 送って 売って 彼女は可愛いだれども、わがままな人です 都市は田舎より便利です 台南に遊びに行きました。そして、美味しいものをたくさん食べました 行って ポルトガル 着物 乗客 冷蔵庫 書店 この本、借りてもいいですか 解答 大きいな竜巻 買い物カートはからです ツアーガイドはあなたの旅行を楽しくする興味深い情報知っているだろう この本、借りてもいいですか 私は自分の力で仕事を探します 飛行機が二時間遅れました。それで、到着時間も遅くなります ポルトガル この本、借りてもいいですか 解答 2020-2-13私たちのチームはその試合で負けた 高い 彼は足が長い 起こる 彼はまだ若いです 古い 美し 私はワインが好きです おかげさまで元気です 私には友達がたくさんいます 喋る あの公園は綺麗で、静かで、有名です あそこ この道を真っ直ぐ行くと駅です 触る 酸っぱい 九つ 何 金曜日の夜は友達と出かけます 銀行は３時まで開いています 建設 受付でプログラムを受け取った この曲線がこの車の特徴です 大きくて 小さくて 広くて 狭くて 彼はその詩を用いて自分の気持ちを伝えた 話 留学してから私の世界が広がった 私は一人旅の計画を立てた 引っ越しを業者に頼んだ 対立 変わる 私はサラリーマンで、父親です 私はワインが好きです 日本の神社に参拝しましたよ。あ、それから、御守りも買いました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました あの日本料理店は広くて、美味しくて、安いです 台南に遊びに行きました。そして、美味しいものをたくさん食べました あの公園は綺麗で、静かで、有名です 飛行機が二時間遅れました。なので、到着時間も遅くなります 北川さんはたくさん食べますが、全然太りません 目覚し時計をかけたのに、なかなか鳴りません 大きくて 小さくて 広くて 狭くて 日本、ヨーロッパ、そしてアメリカを旅行しました 私は魚が嫌いです 彼女は英語先生で、動物園のボランティアです 彼はその詩を用いて自分の気持ちを伝えた 彼は運動場で倒れました。そして、三分後救急車が来ました 引っ越しを業者に頼んだ ゲームをした 日本語先生のくせに、日本語で自己紹介することもできません 私はパソコンで字を打って、インターネットして、印刷する 私は本屋で本を買って、開いて、読む 何曜日が暇ですか 彼女は可愛いですが、わがままな人です あの日本料理店は広くて、美味しくて、安いです テレビをつけました。しかし、画面がなかなかでません 天気が良くありません。それで、海に行くのをやめました。 飛行機が二時間遅れました。なので、到着時間も遅くなります どうして今日は遅刻した 私の部屋は狭くて、暗くて、汚いです 私の嫌いなことは部屋を掃除することです 私はご飯を食べて、テレビを見て、宿題をする 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 私の部屋は狭くて、暗くて、汚いです あの歌手は有名です あの絵が綺麗なのに、誰も買いません あの絵が綺麗です。なのに、誰も買いません 私の部屋は狭くて、暗くて、汚いです 中村さんは昨日夜１０時まで仕事をしましたので、残業代がたくさんもらえるでしょう 私の部屋は狭くて、暗くて、汚いです 基隆の夜市は有名で、賑やかです 私パソコンで字を打って、インターネットして、印刷する 飛んで 運で 遊んで 読んで 住んで 死んで 私はありいて、電車に乗って、バスに乗る 昨日、どこに行きましたか コンサートに行きました あなたは私にデジタルカメラをくれました 庭の松は高いです ふーん、それで 明日からは夏休みだけれども、宿題がいっぱいあります 道を迷いでした。それで、交番に道を尋ねに行きました 液晶テレビ その男の人は満足している 調味料 あの公園は綺麗で、静かで、有名です あの日本料理店は広くて、美味しくて、安いです 私の部屋は狭くて、暗くて、汚いです 私の部屋は狭くて、暗くて、汚いです あの日本料理店は広くて、美味しくて、安いです あの公園は綺麗で、静かで、有名です 私の部屋は狭くて、暗くて、汚いです 2020-2-12飛行機 右のポケットにハンカチが入っています 一つ 払う 鼻が痒いです 入る 暖かい この道を真っ直ぐ行くと駅です 掛ける 私はパソコンで字を打って、インターネットして、印刷する つける 一日 彼女は眠いようです 来る 愛する 教科書を閉じてください 私はパソコンで字を打って、インターネットして、印刷する 彼に会えて、嬉しかった ソフトクリームを二つください これはかなり金がかかった 先月の七日に孫が生まれました 私はパソコンで字を打って、インターネットして、印刷する 話 決定 方針 増える 彼女は同じ間違いを繰り返した 彼は行政を改革したいと思っている 私はサラリーマンで、父です のちに彼は総理大臣になりました 二社は互いに競争しています ダムの開発に住民は反対しています 私はサラいーマンで、父親です この道を真っ直ぐ行くと駅です 私は学生ではありません 彼女は英語の先生で、動物園のボランティアです 彼は運動場で倒れました。そして、三分後救急車が来ました 彼女は英語の先生で、動物園のボランティアです この絵が綺麗です。なのに、誰も買いません 庭の松は高いです 私はパソコンで字を打って、インターネットして、印刷する ニュースで道を状況がわかります 話 それで、どうした 今夜は蒸し暑いですから、明日は雨が降るでしょう 私はパソコンで字を打って、インターネットして、印刷する 私はご飯を食べて、テレビを見て、宿題をする 私は歩いて、電車に乗って、バスを乗る 私は先月台湾を旅行しました 基隆の夜市は有名で、賑やかです 私は紙で鶴を作りました 日本語の先生のくせに、日本語で自己紹介することもできません あの絵が綺麗なのに、誰も買いません 私はサラリーマンで、父親です 私はサラリーマンで、父親です ないでください 私は本屋で本を買って、開いて、読む 彼女は英語の先生で、動物園のボランティアです 庭の松は高いです 彼女は英語の先生で、動物園のボランティアです あのバカは二本の鉛筆を箸にして、ご飯を食べる 私は日本の神社に参拝しましたよ。あ、それから、お守りも買いました して 来て 日本、ヨーロッパ、そしてアメリカを旅行しました お金を振り込んだくせに、商品が全く来ません 貸して 指して 無くして 刺して 出して 戻して 基隆の夜市は有名で、賑やかです あの絵が綺麗なのに、誰も買いません 先生は私に100点をくれました 基隆の夜市は有名で、賑やかです 喫茶店で教科書を読みます 明日からは夏休みですが、宿題がいっぱいあります それから、南投の有名な牧場に遊びに行きました 私はサラリーマンで、父親です 期末レポート 一眼レフカメラ 緑茶 大人 原稿を改訂する 彼女は英語の先生で、動物園のボランティアです 日本、ヨーロッパ、そしてアメリカを旅行しました 基隆の夜市は有名で、賑やかです 2020-2-11飲む 質問のある方はどうぞ 兄 うちに帰ろ 緑 その次の週は空いていますか 私は朝シャワーを浴びます 弱い みんなにお菓子をあげましょう ウエイターを呼びましょう 僕 渇く 悪い 平仮名 目 九つ これは医者のためのサイトです 私はご飯を食べて、テレビを見て、宿題をする 七日 閉める これは医者のためのサイトでづ 見つかる 今晩のパーテイーは何時からですか 彼女は三人の子供の母親だ 神 強調 私は歩いて、電車に乗って、バスに乗る その質問に対する答えが見つからなかった 方向 一方 彼女は自分の立場をわかっていない 内容 彼は事故で怪我をしました この携帯電話が使えるのは国内だけです まず相手の動きを見ましょう 私は本屋で本を買って、開いて、読む 一緒に対策を考えましょう して きて 私にはたくさんのお金が必要だ 前売券は窓口で販売しています 彼は選挙に出るつもりだ 交差点で事故が発生した もう 私はご飯を食べて、テレビを見て、宿題をする 最近雨の日が多いでしょう。それに、台風が二個をきました 私は頑張りたくありません 食べて 見て 開けて 寝て 始めて 集めて 忘れて お金持ちのくせに、スーパーで散々値切りをしました 私は歩いて、電車に乗って、バスに乗る 日本、ヨーロッパ、そしてアメリカを旅行しました 給料をたくさんもらうくせに、全然仕事をしません コーヒーショップで教科書を読む 私はご飯を食べて、テレビを見て、宿題をする 行って それ店は高いですが、全然美味しくありません 夏なのに、陽明山で雪が降ります うそ あの歌手は有名だけれども、歌を下手です それから、南投の有名な牧場に遊びに行きました 私は本屋で本を買って、開いて、読む 私は歩いて、電車に乗って、バスに乗る 次に、桃園で飛行機を見に行きました ここの公務員は暇なくせに、文句を言います 餌 暑い 火曜日 期末レポート デスクトップパソコン 体育館 私は本屋で本を買って、開いて、読む フクロウ 脈を取る 蟹 茶髪 私はご飯を食べて、テレビを見て、宿題をする 私は歩いて、電車に乗って、バスに乗る 私は本屋で本を買って、開いて、読む 2020-2-10切る 足 好き 軽い 美し 九つ 辛い よやくはいりません 曲がる 明日は昼頃から曇るでしょう ソフトクリームを二つください 彼女は三人の子供の母親だ 決まる 見つかる 入る 比べる 受付でプログラムを受け取った 資金 全体のは八十パーセントが完成しました 結果 経済 彼は一人旅の計画を立てた 彼は事故で怪我をしました 夏なのに、陽明山で雪が降りました お金を振り込んだくせに、商品が全く来ません 最後に、南東から台北に来ました お金持ちのくせに、スーパーで散々値切りをしました 九つ ボタンを押す 私の得意なことはギターを弾くことです 彼は小学校の先生なので、毎日四時ちょうどに帰ります 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 行って この店は高いですが、全然美味しくありません テレビをつけました。しかし、画面がなかなか出ません 期末テストは大変です どうして今日遅刻した 浅い川 小林さんの妻は小林さんに愛妻弁当をあげました 駅の前に新しいコンビニがてきました。それから、駅の後ろにもコンビニができました 彼は事故で怪我をしました 明日からは夏休みです。でも、宿題がいっぱいあります あの店の弁当は美味しいのに、４０元もかかりません 私日本語ができます 何を食べたいですか 定食かうどんかラーメンですね 都市は田舎より便利です それで、これからどうします この車はとんでもなく高いくせに、すぐ故障します 書店 原稿改訂する 広告 嫌い フロント 私は物理の基礎は知っています 行って 2020-2-9今朝は早く家を出ました 私は窓側の席に座った 払う どう 美し 置く 彼女はイタリア語ができます 妹は平仮名を全部覚えました いう 手伝う 見つかる ソフトクリームを二つください 男の人が私たちに話しかけた 渇く 私はパンよりご飯が好きだ 夕食には何を食べたいですか 夏休みももう終わりだ 新しいテーブルを買いました 評価 今後ともよろしくお願いします 彼女の大きな帽子はとても目立つ 信号が青に変わりました 作業 普及 力 建設 写真はいい思い出になります 今夜は大いに語りましょう 彼は一人旅の計画を立てた 集める 彼は行政を改革したいと思っている 災害備えて、大量の水を買い込んだ お爺さんは昔の記憶を忘れたがります 美しい 私はあの記憶を忘れたいです 明日からは夏休みだけれども、宿題がいっぱいあります 給料をたくさんもらうくせに、全然仕事をしません 私は日本の神社に参拝しました。な、それから、お守りも買いました 昨日財布を無くしました。それに、傘も電車に忘れました ソフトクリーム二つください ここの公務員は暇なくせに、文句を言います この絵は綺麗なのに、誰も買いません 北川さんはたくさん食べますが、全然太りません 道を迷いました。それで、交番に道を尋ねに行きました あの店は高いです。ですが、全然美味しくありません 彼は小学校の先生ですから、子供の両親からのプレッシャーが多いでしょう 中村さんは昨日１０時まで仕事しましたので、残業代がたくさんもらえるでしょう この店は高いけれども、全然美味しくありません テレビをつけました。しかし、画面がなかなか出ません どうして今日遅刻した 彼は一人旅の計画を立てた お客さんは家に来ました あの絵は綺麗です。なのに、誰も買いません 飛行機が二時間遅れました。なので、到着時間も遅くなります あの車はとんでもなく高いくせに、すぐ故障しました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう テレビをつけましたけれども、画面がなかなか出ません 日本、ヨーロッパ、そしてアメリカに旅行しました パソコンお買いましたが、キーボードがありません すみません、今は何時ですか 明日からは夏休みです。でも、宿題がいっぱいあります 二月に日本を旅行しました。それから、韓国と中国にも行きました 話はここまでです。な、それから もう25歳なのに、両親からお小遣いをもらいます 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 都市は田舎より便利です 机 どうして今日遅刻した 原稿を改訂する ペットボトル 書店 高校生 タプレット カニが浜辺を歩いている 雄鶏 都市は田舎より便利です 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 原稿を改訂する 書店 2020-2-8電車で子供が騒いでいた 電車で子供が騒いでいた 言う 祖父が病気になった 肩 起こる また会いましょう みんなにお菓子をあげましょう 払う 会う 色 太い 教科書を閉じてください 見つかる 答えが違います 二 あの家には時計が八つあります ハワイは4回目です ちゃんとドアを閉めてよう 彼は私の上司です 悲しい 国内 今夜は大いに語りましょう 計算 文章 これら 選挙 最近、株を始めました バラには色々な種類があります これは重要な書類です 彼がクラスの代表だ 犬に餌をやった 彼女は明日の天気がわかります あの歌手は有名けれども、歌が下手です 中村さんは昨日夜１０時まで仕事しましたので、残業代がたくさんもらえるでしょう 払う みつかる 中村さんは昨日夜１０時まで仕事しましたので、残業代がたくさんもらえるでしょう いつが暇ですか お金持ちのくせに、スーパーで散々値切りをしました 日本、ヨーロッパ、そしてアメリカを旅行しました あのノートは私のです もう二十五さなのに、両親からお小遣いをもらいます 二月に日本を旅行しました。それから、韓国と中国にも行きました ニュースで道の状況がわかります この店は高いです。ですが、全然美味しくありません 本棚に小説と雑誌があります 私は日本の神社に参拝しました。な、それから、お守りも買いました もう朝なのに、なかなか起きることができません なんで台湾の会社は大学生を雇いたくないのですか 教室が静かではありません テレビをつけましたが、画面がなかなか出ません 彼女は可愛いけれども、わがままな人です 道を迷いました。それで、交番に道を尋ねに行きました この絵が綺麗です。なのに、誰も買いません ご飯を食べた人 台 私の得意なことはギターを弾くことです 先生の隣に父と母がいます 何曜日が暇ですか 明日からは夏休みだけれども、宿題がいっぱいあります 昨日はテレビを見ました。それから、テストの勉強をしました 目覚しとけいをかけたのに、なかなか鳴りません 日本、ヨーロッパ、そしてアメリカを旅行しました 今夜は蒸し暑いですから、明日は雨が降るでしょう そば 校長 親戚 ハンバーグ 屋上 乗客 レンタサイクル 美術館 映画 栓抜き 私は日本の神社に参拝しましたよ。な、それから、お守りも買いました サイ 貸して 指して 買い物カートはからです 蝉 2020-2-7とても 次はいつ会いましょうか 彼の日本語のレベルは私と同じくらいだ 紙 高い 私の夫はサラリーマンです みんなにお菓子をあげましょう 五月五日は祝日です 円 上る 曲がる 彼は駄目な男だ 九日に荷物が届きます 渇く 宿題は自分でやりなさん 六日前に日本に帰ってきました 私はパンよりご飯が好きだ 閉める 口 今週 三 存在 彼は行政を改革したいと思っている 毎年多くの人が海外へ旅行する 企業 もう 調査 これは世界最大の船です パソコンを買いましたが、キーボードがありません 最後に、南投から台北に帰りました 和食といえば、寿司や味噌汁や天ぷらなどです 日本語先生のくせに、日本語で自己紹介することもできません 給料をたくさんもらうくせに、全然仕事をしません 私の得意なことはギターを弾くことです 私はあの人のことが嫌いです みんなにお菓子をあげましょう 彼は運動場で倒れました。そして、三分後救急車が来ました お金持ちのくせに、スーパーで散々値切りをしました 明日から夏休みです。でも、宿題がいっぱいあります 私は風邪をひきました。なので、映画館に行きませんでした あの弁当は美味しいのに、40元もかかりません 私は風邪をひきました。だから、明日学校に行きたくありません まず、次に、そして、それから、最後に 私は日本語ができます 夜市が賑やかです 台北駅はあそこです 私は学生ではありません 友達は朝９時に家にきました。そして、夜６時にみんな帰りました 彼女は可愛いですが、わがままな人です この服とあの服、どちらが可愛いですか 私は日本語料理を作るとこが少しできます リビングのソファで寝ました。それで、風邪をひきました あの絵は綺麗です。なのに、誰も買いません テレビをつけました。しかし、画面がなかなか出ません うそ 私はフォークでパスタを食べます 最近、雨の日が多いです。それに、台風も二個来ました 私は日本料理を作ること大体できます 先月私は台湾を旅行しました 私は得意なことはギターを弾くことです ニュースで道の状況がわかります 道に迷いました。それで、交番に道を尋ねに行きました 先生は親切ではありません お金を振り込んだくせに、商品が全くきません あの歌手は有名だけれども、歌が下手です テレビを見ました。それから、テストの勉強をしました あの店は高いけれども、全然美味しくありません 床に蟻がいます 私は日本語がまあまあできます 虹 サツマイモ め ニュースで道の状況が分かります 2020-2-6短い 彼は荷物を網棚に上げた 紙 親の愛は有り難い 旅行の日程を変えました 学校は８時半に始まります 授業 よう 細い 八つ 綺麗 渇く 風邪 留学生 教科書を閉じてください 男の人が私たちに話しかけた 続ける 彼は行政を改革したいと思っている のち より いい方法思いつきました 報告 その二社は対立しています 昨日、財布を無くしました。それに、傘も電車に忘れました テレビを付けました。しかし、画面がなかなか出ません 何を食べたいですか 定食かうどんかラーメンですね お金持ちのくせに、スーパーで散々値切りをしました 彼女は可愛いけれども、わがままな人です あの歌手は有名だけれども、歌が下手です あの絵が綺麗です。なのに、誰も買いません もう朝なのに、なかなか起きることができません 彼女は可愛いですが、わがままな人です 道を迷いました。それで、交番に道を尋ねに行きました 私は日本料理を作ることができます 私は彼にノートパソコンをもらいました あの絵が綺麗なのに、誰も買いません 彼は行政を改革したいと思っている 日本語が上手になる リビングのソファで寝ました。それで、風邪をひきました。 宿題をしました。それに、明日の授業の予習もしました 明日からは夏休み。でも、宿題がいっぱいあります 25歳なのに、両親からお小遣いをもらいます お金持ちのくせに、スーパーで散々値切りをしました あの歌手は有名だけれども、歌が下手です 私は歌を歌うことができます 北川さんはたくさん食べましたけれども、全然太りません あの車はとんでもなく高いくせに、すぐ故障しました あの絵が綺麗です。なのに、誰も買いません 次に、桃園で飛行機を見に行きました どこが賑やかですか うそ ここの公務員は暇なくせに、文句を言います 日本語先生のくせに、日本語で自己紹介することもできません 明日からは夏休みだけれども、宿題がいっぱいあります テレビをつけましたけれども、画面がなかなか出ません 二月に日本を旅行しました。それから、韓国と中国にも行きました 宮沢さんは課長のことをどう思いますか この店の料理は美味しいです。それに、値段もとても安いです 給料をたくさんもらうくせに、全然仕事をしません 大人 歌手 文房具 楓 お金持ちのくせに、スーパーで散々値切りをしました 定食 キャベツ 選手 葉が落ちます 脈を取る 銀のフルート うそ 給料をたくさんもらいましたくせに、仕事を全然しません 2020-2-5右 紙 会う そう 変える 私は朝シャワーを浴びます 夕食には何を食べたいですか 違う 触る 渇く 茶色 易しい 曲がる 明日からは夏休みです。でも、宿題がいっぱいあります その子は指で十数えました 今夜は月がとても綺麗です 金 教科書を閉じてください 明日からは夏休みです。でも、宿題がいっぱいあります 採用 事実 明らか 与える 私は今結婚資金を貯めています 業者 新聞 テレビをつけました。しかし、画面がなかなか出ません 生産 構造 災害に備えて、大量の水を買い込んだ 目覚まし時計をかけたのに、なかなか鳴りません テレビをつけました。しかし、画面がなかなか出ません 話はここまでです。な、それから お金を振り込んだくせに、商品が全くきません 新しいパソコンを買いましたけれども、キーボードがありません 北川さんはたくさん食べましたけれども、全然太りません そして、対中で有名な湖の隣のホテルに泊まりました さあ、私もわかりませんね この車はとんでもなく高いくせに、すぐ故障します この絵が綺麗です。なのに、誰も買いません 給料をたくさんもらうくせに、全然仕事をしません 教科書を閉じてください 天気が良くありません。それで、海に行くのやめました それで、どうした 二月に日本を旅行しました。それから、韓国と中国にも行きました もう25歳なのに、両親からお小遣いをもらいます 明日からは夏休みです。でも、宿題がいっぱいあります 私は学生ではありません 何を食べたいですか 定食かうどんかラーメンですね 今夜は蒸し暑いから、明日雨が降るでしょう あの店の弁当は美味しいのに、40元もかかりません あの店は高いです。ですが、全然美味しいくありません テレビをつけました。しかし、画面がなかなか出ません あの歌手は有名だけれども、歌が下手です 道を迷いました。それで、交番に道を尋ねに行きました 私はあなたにデジタルカメラをもらいました この絵が綺麗です。なのに、誰も買いません 明日からは夏休みだけれども、宿題がいっぱいあります 何曜日が暇ですか 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 二月に日本を旅行しました。それから、韓国と中国にも行きました 梅と桜 向日葵は草より綺麗です 明日から夏休みです。でも、宿題がいっぱいあります 何を食べたいですか 定食かうどんか、らーめんですね 夏休みなのに、陽明山で雪が降りました 宿題をしました。それに、明日の授業の予習もしました お金持ちのくせに、スーパーで散々値切りをしました ここの公務員は暇なくせに、文句を言います あの歌手は有名だけれども、歌が下手です 羊 記憶 事務室 弁当 フクロウが頭を上下に動かしている 道を迷いました。それで、交番に道を尋ねに行きました テレビをつけました。しかし、画面がなかなか出ません 蟹 明日からは夏休みだけれども、宿題がいっぱいあります あの絵が綺麗です。なのに、誰も買いません 明日からは夏休みです。でも、宿題がいっぱいあります ま テレビをつけました。しかし、画面がなかなか出ません その絵が綺麗です。なのに、誰も買いません 2020-2-4帰る 質問のある方はどうぞ 起こる 乗る 去年 広い 肉と魚とどちらが好きですか 夏休みももう終わりだ 千円 晴れる 入る 柿の木に実がたくさんなっています 私は腕時計を四つもっています 渇く 男の人が私たちに話しかけた 閉める 曲がる 近く ハワイは4回目です 研究 調査 トラブルがやっと解決した もう 建設 受付でプログラムを受け取った 生まれる その会社は来月キャンペーンを行う 計画を一部変更しましょう 災害に備えて、大量の水を買い込んだ 力 対象 写真はいい思い出になります 対する 代表 銀行は３時まで開いています 私は学生ではありません もう朝なのに、なかなか起きることができません なんでこんな時間に学校にいないのですか 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 夏は涼しかったです お金を振り込んだくせに、商品が全くきません 北川さんはたくさん食べますが、全然太りません 渇く まず、台北のお寺と夜市に行きました 曲がる 給料をたくさんもらうくせに、全然仕事をしません 夏なのに、よう名山で雪が降りました あなたの会社は私の会社に統計ソフトウエアをくれました 目覚まし時計をかけたのに、なかなか鳴りません ここの公務員は暇なくせに、文句を言います この店は高いです。ですが、全然美味しくありません 授業をする教師 災害に備えて大量の水を買い込んだ 私の好きなことは音楽を聴くこのです 日本語先生のくせに、日本語自己紹介することもできません 私は学生ではありません お金持ちのくせに、スーパーで散々値切りをしました 小林さんは中国語を話すことができます 私は世界一周をしたいです もう25歳なのに、両親からお小遣いをもらいます 何曜日が暇ですか 給料をたくさんもらうくせに、全然仕事をしません 明日から夏休みですが、宿題がいっぱいあります 道を迷いました。それで、交番に道を尋ねに行きました この車はとんでもなく高いくせに、すぐ故障します 明日から夏休みですが、宿題がいっぱいあります 私は日本語があまりできません この絵は綺麗なのに、誰も買いません この服とあの服、どちらが可愛いですか 今夜は蒸し暑いから、明日は雨が降るでしょう パソコンを買いましたけれども、キーボードがありません このノートは私のです 彼は運動場で倒れました。そして、三分後救急車が来ました テレビをつけましたけれども、画面がなかなか出ません 最近、雨の日が多いです。それに、台風もニコ来ました ジーンズを買いましょうか そっか、今度早く家をでろう もう25歳なのに、両親からお小遣いをもらいます 何曜日が暇ですか えっと、電車が遅れましたから、遅刻した 接続詞 メロン 液晶テレビ 乗客 買い物カートはからです 道に迷いました。それで、交番に道を尋ねに行きました 炒める 脈を取る 蝉 この車はとんでもなく高いくせに、すぐ故障します 明日から夏休みだけれども、宿題がいっぱいあります 今夜は蒸し暑いから、明日は雨が降るでしょう この車はとんでもなく高いくせに、すぐ故障します この車はとんでもなく高いなのに、すぐ故障しますた この車はとんでもなく高いくせに、すぐ故障します 2020-2-3いつも 消す 次 いう 働く 起こる 来年 男の人は私たちに話しかけだ 渇く 彼はシートバルトを閉めた お金持ちのくせに、スーパーで散々値切りをしました 起こる ハワイは4回目です 男の人は私たちに話しかれた 渇く お金持ちのくせに、スーパーで散々値切りをしました ある 悲しい 閉める このコートはとても暖かい お金持ちのくせに、スーパーで散々値切りをしました お金持ちのくせに、スーパーで散々値切りをしました この車はとんでもなく高いくせに、すぐ故障します 銀行 業者 生まれる あの車はとんでもなく高いくせに、すぐ故障します もう この車はとんでもなく高いくせに、すぐ故障します 調査 バラには色々な種類があります ハワイは4回目です 結果 これは重要な書類です 計算 制度 語る 動き 姿 ここの公務員は暇なくせに、文句を言います ここの公務員は暇なくせに、文句を言います 閉める お金持ちのくせに、スーパーで散々値切りをしました お金持ちのくせに、スーパーで散々値切りをしました もう この車はとんでもなく高いくせに、すぐ故障します 調査 この車はとんでもなく高いくせに、すぐ故障します お金持ちのくせに、スーパーで散々値切りをしました この公務員は暇なくせに、文句を言います その会社は来月、キャンペーンを行う 日本語先生のくせに、日本語で自己紹介することもできません この店は高いけれども、全然美味しくありません 本棚に小説と雑誌があります 私は日本語が全然できません 私は世界一周をしたくありません コンビニに電子レンジがあります お金を振り込んだくせに、商品が全くきません 給料をたくさんもらうくせに、全然仕事をしません ここの公務員は暇なくせに、文句を言います スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 静かな教室 お爺さんは昔の記憶を忘れたがります 夏なのに、幼名山で雪が降りました 国仲さんはあなたにギターをもらいました それから、南投の有名な牧場に遊びに行きました 目覚まし時計を狩れたのに、なかなか鳴りません 最近雨の日が多いです。それに、台風をにこきました もう25歳なのに、両親からお小遣いをもらいます ふーん、それで？ スピーチは何時からですか この絵が綺麗なのに、誰も買いません お金持ちのくせに、スーパーで散々値切りをしました この公務員は暇なくせに、文句を言います 彼女は可愛いけれども、わがままな人です まず、台北のお寺と夜市に行きました お金を振り込んだくせに、商品が全くきません 給料をたくさんもらうくせに、全然仕事をしません 明日からは夏休みですが、宿題がいっぱいあります 明日からは夏休みだけれども、宿題がいっぱいあります それで？これからどうします この店は高いです。ですが、全然美味しくありません この服とあの服、どちらが可愛いですか 目覚まし時計かけたのに、なかなか鳴りません 上野さんは彼女と映画を見ました 彼は運動場で倒れました。そして、三分後救急車が来ました もう25歳なのに、両親からお小遣いをもらいます 朝なのに、なかなか起きることができません 私は日本語がよくできます テレビをつけましたが、画面がなかなか出ません どうして今日遅刻した あの店は高いです。ですが、全然美味しくありません ないでください 彼女は可愛いですが、わがままな人です あの店の弁当は美味しいのに、４０元もかかりません 乗客 博物館 鶴 広告 雨の後、虹が見られるかもしれません お金が振り込んだくせに、商品が全く来ません 脈を取る この服とあの服、どちらが可愛いですか この店は高いです。ですが、全然美味しくありません 彼は運動場で倒れました。そして、三分後救急車が来ました 朝なのに、なかなか起きることができません もう25歳なのに、両親からお小遣いをもらいます あの店は高いです。ですが、全然美味しくありません 乗客 脈を取る 2020-2-2落ちる グラスの数が足りません 鳥が飛んでいます 走る 3月は仕事が忙しい 切る 一日 8 直る 店員は若い女の人でした 夕食には何を食べたいですか 腰 愛する 多分 給料をたくさんもらうくせに、全然仕事をしません お名前をカタカナで書いてください 写真はいい思い出になります 変わる それは最近話題の本ですね 給料をたくさんもらうくせに、全然仕事をしません これら 検討 残る 方向 より 意味 彼は就職試験を受けた 立場 給料をたくさんもらうくせに、全然仕事をしません ほぼ 現在 これから、より一層努力します この絵は綺麗なのに、誰も買いません あの歌手は有名だけれども、歌が下手です テレビをつけましたけれども、画面がなかなか出ません もう25歳なのに、両親からお小遣いをもらいます 友達は朝９時に家にきました。そして、夜６時にみんな帰りました 私はあなたにデジタルカメラをもらいました それから、台中で有名な湖の隣のホテルに泊まりました 給料をたくさんもらうくせに、全然仕事をしません 夏なのに、幼名山で雪が降りました 目覚まし時計をかけたのに、なかなか鳴りません お金を振り込んだくせに、商品が全くきません お金を振り込んだくせに、商品が全くきません 給料をたくさんもらうくせに、全然仕事をしません もう25歳なのに、両親からお小遣いをもらいます もう朝なのに、なかなか起きることがでいません 彼女は可愛いですが、わがままな人です 最後に、南投から台北に帰りました あの店の弁当は美味しいのに、40元もかかりません テレビをつけましたが、画面がなかなか出ません 彼女は可愛いけれども、わがままな人です 北川さんはたくさん食べましたけれども、全然太りません お金が振り込んだくせに、商品が全くきません 私は日本料理を作ることが大体できます いつが暇ですか 土曜日か日曜日です お金が振り込んだくせに、商品が全くきません 私は日本料理を作ることがまあまあできませう 北川さんはたくさん食べますが、全然太りません あの店は高いですが、全然美味しくありません お金を振り込んだくせに、商品が全くきません 日本語先生のくせに、日本語で自己紹介することもできません 日本お神社に参拝しhましたよ。な、それから、お守りも買いました 私のカバンはどれですか 私はフォークでパスタを食べます このノート私のです 和食と言えば、寿司や味噌汁や天ぷらなどです どうしてキリンは首が長いですか パソコンを買いましたが、キーボードがありません 引き出し 大人 ゲーム 陽傘 日本語先生のくせに、日本語で自己紹介することもできません カーテン 深い 香水 小テスト 茶髪 買い物カートはからです 栓抜き 蟹 ロブスターが岩の上にいる 日本語先生のくせに、日本語で自己紹介することもできません もも 7点9センチメートル お金を振り込んだくせに、商品が全くきません ぎ 日本語先生のくせに、日本語で自己紹介することもできません 日本語先生のくせに、日本語で自己紹介することもできません 2020-2-1働く 仕事 春 宿題はまだ終わっていません 私は朝シャワーを浴びます あなたの来るの、待っています 起こす 言う もう25歳なのに、両親からお小遣いをもらいます 彼に会えて嬉しかった 上る お腹が空きました 時の経つのは早い 火曜日 もう25歳なのに、両親からお小遣いをもらいます もう25歳なのに、両親からお小遣いをもらいます 彼は時々遅刻します もう25歳なのに、両親からお小遣いをもらいます 夕食には何を食べたいですか 彼は神を信じている 彼は昼過ぎにきます 建設 あの店の弁当は美味しいのに、４０元もかかりません 実現 外国 開発 写真はいい思い出になります 開く 私は四つの会社に投資しています この絵は綺麗なのに、誰も買いません 方向 その仕事は危険を伴う 資金 遅れた理由を教えてください もう 全体の80パーセントが完成しました 会社 あの店の弁当は美味しいのに、40元もかかりません 二十キロのダイエットは可能だと思いますか もう25歳なのに、両親からお小遣いをもらいます 夕食には何を食べたいですか 25歳なのに、両親からお小遣いをもらいます あの店の弁当は美味しいのに、40元もかかりません 写真はいい思い出になります 明日からは夏休みだけれども、宿題がいっぱいあります この絵は綺麗なのに、誰も買いません 彼は運動場で倒れました。そして、三分後救急車が来ました 天気が良くありません。それで、海に行くのやめました もう朝なのに、なかなか起きることができません あの歌手は有名だけれども、歌が下手です パソコンを買いましたけれども、キーボードがありません あの店は高いけれども、全然美味しくありません もう朝なのに、なかなか起きることができません 彼女は可愛いけれども、わがままな人です あの店の弁当は美味しいのに、40元もかかりません 私はおばあちゃんのことが好きです 私はピーマンが嫌いです 北川さんはたくさん食べましたけれども、全然太りません テレビをつけましたけれども、画面がなかなか出ません 彼女は可愛いですが、わがままな人です 目覚まし時計を狩れたのに めざまし時計をかけたのに、なかなか鳴りません 道を迷いました。それで、交番に道を尋ねに行きました この店の料理が美味しいです。それに、値段もとても安いです 駅の前に新しいコンビニができます。それから、駅の後ろにもコンビニができます 彼女は可愛いけれども、わがままな人です もう朝なのに、なかなか起きることができません あの絵は綺麗なのに、誰も買いません 日曜日が暇です この店は高いですが、全然美味しくありません パソコンを買いましたが、キーボードがありません 夏なのに、幼名山で雪が降るました 湖 もう朝なのに、なかなか起きることができません ビジネスマン 鶏 蟹 買い物カートはからです 蝉 目覚まし時計をかけなのに、なかなか鳴りません 目覚まし時計をかけたのに、なかなか鳴りません 目覚まし時計をかけたのに、なかなか鳴りません あの絵は綺麗なのに、誰も買いません 夏なのに、陽明山で雪が降りました 蟹 買い物カートはからです もう朝なのに、なかなか起きることができません もう目覚まし時計をかけたのに、なかなか鳴りません History","link":"/zh-tw/japanese/index.html"},{"title":"History","text":"2020January 2019DecemberNovemberOctoberSeptember","link":"/zh-tw/japanese/History/index.html"},{"title":"History","text":"2020January 2019DecemberNovemberOctoberSeptemberAugustJulyJuneMayAprilMarchFebruaryJanuary 2018DecemberNovember","link":"/zh-tw/schedule/History/index.html"},{"title":"December 2018","text":"2018/12/31The result of my target yesterday [ ] linux: 鳥哥的linux基礎篇 i read some book not related to coding yesterday. i was guilty! [ ] git: pro git i read some book not related to coding yesterday. i was guilty! [x] challenge20181217 rewriting paymentdetail function getachievedachievement function getpossessions function profile function DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting deposit achievement 2018/12/30The result of my target yesterday [ ] linux: 鳥哥的linux基礎篇 i read some book not related to coding yesterday. i was guilty! [ ] git: pro git i read some book not related to coding yesterday. i was guilty! [x] challenge20181217 rewriting shop system function rewriting DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting getachievedachievement getachievedachievement function getpossessions function profile function 2018/12/29The result of my target yesterday [x] linux: 鳥哥的linux基礎篇 head -n number filename tail -f filename cat -n filename | tail -n [x] git: pro git how to revert a merged commit and undo all the changes introduced by the branch being merged?git revert -m 1 commitid if i reverted a merged commit and chose the parent, what if i want to merge it again?revert the reverted commit when merging, how to skip mamually resolving and just choose the side we choose? git merge branchname -xours or git merge branchname -xtheirs challenge20181217 rewriting shop system function rewriting went to a movie theater. DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting shop system function rewriting 2018/12/28The result of my target yesterday [x] linux: 鳥哥的linux基礎篇 nl -ba filename nl -bt filename nl -w filename nl -nln filename nl -nrn filename nl -nrz filename [x] git: pro git git merge -xignore-all-space git merge -xignore-space-change git log --oneline --left-right --merge -p (option) challenge20181217 rewriting readability of achievement function shop system function rewriting to be completed today DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting shop system function rewriting 2018/12/27The result of my target yesterday linux: 鳥哥的linux基礎篇 cat -a cat -b cat -e cat -n cat -t cat -v [x] git: pro git git filter-branch --subdirectory-filter directoryname head git filter-branch --commit-filter &apos; if [ &quot;$git_author_email&quot; = &quot;currentemail&quot; ] ; then git_author_name=&quot;newauthornameyouwanttobe&quot;; git_author_email=&quot;newemailyouwanttobe&quot;; git commit-tree &quot;$@&quot;; else git commit-tree &quot;$@&quot;; fi&apos; head rewrite challenge20181217 achievement function achievement function was completed, but need to improvie its readability Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting readability of achievement function shop system function rewriting2018/12/26 The result of my target yesterday linux: 鳥哥的linux基礎篇 went to ktv instead git: pro git went to ktv instead rewrite challenge20181217 getachievementlist &amp; getitemlist api was completed Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git i think i need to focus on my challenge code rework until i finish it 2018/12/25The result of my target yesterday linux: 鳥哥的linux基礎篇辦事項 git: pro git git commit –amend –no-edit git commit filter-branch –tree-filter –all ‘rm -f file’ head laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (2/5) rewrite challenge20181217 redesign tables Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git i think i need to focus on my challenge code rework until i finish it 2018/12/24The result of my target yesterday linux: 鳥哥的linux基礎篇辦事項 git: pro git - git grep filename -n &amp; git grep filename -n laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (1/5) Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (2/5) 2018/12/23The result of my target yesterday figure out how to use moment of js to covert the timezone from utc to where you are - not completed yet wondering presentation - completed Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 23 rameke my git presentation from keynote to hackmd (1/5) 2018/12/22The result of my target yesterday challenge 20181221 passed figure out how to use moment of js to covert the timezone from utc to where you are - not completed yet Achieved except for set target yesterdayDescriptionToday’s target wondering presentation 2018/12/21The result of my target yesterday challenge 20181220 passed Achieved except for set target yesterdayDescriptionToday’s target don’t special game challenge 20181221 2018/12/20The result of my target yesterday challenge 20181219 passed Achieved except for set target yesterdayDescriptionToday’s target challenge 20181220 2018/12/19The result of my target yesterday challenge 20181218 passed Achieved except for set target yesterdayDescriptionToday’s target challenge 20181219 2018/12/18The result of my target yesterday challenge 20181217 passed Achieved except for set target yesterdayDescriptionToday’s target challenge 20181218 2018/12/17The result of my target yesterdaylaravel warming up laravel warm up Achieved except for set target yesterdayDescriptionToday’s target challenge 20181217 2018/12/16The result of my target yesterdaylaracast focus on laravel warming up first laravel warming up laravel_5.7_from_scratch series (9~12/36) linux: focus on laravel warming up first git git add -i revert git add -p git reset -p git stash apply –index git stash –keep-index git add -i update Achieved except for set target yesterdayDescriptionToday’s target laravel- warming up for challenge next week 2018/12/15The result of my target yesterdaylaracast recap the php practitioner series (22/25) laravel warming up laravel_5.7_from_scratch series (4~8/36) linux: what’s cp -s? waht’s cp -r? waht’s cp -u? waht’s cp –preserve=all? if there are two sources when placing cp command, what the destination should be? waht’s cp –preserve=all? git git log origin/master..head git log master..test git log ^master test git log test –not master git log test develop ^master git log test develop –not master Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 23 laravel- warming up for challenge next week 2018/12/14The result of my target yesterdaylaracast recap the php practitioner series (21/25) laravel warming up laravel_5.7_from_scratch series (1~3/36) linux: what’s cp -a? what’s cp -d? what’s cp -f? what’s cp -i? what’s cp -l? what’s cp -p? git git rebase -i ‘wondering’ presentation perfectly done Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 22 laravel- warming up for challenge next week 2018/12/13The result of my target yesterdaylaracast the php practitioner series (19~20/25) linux: what’s in /var/spool folder of linux? what’s ls -a? what’s ls -f? what’s ls -h? what’s ls -i? what’s ls -n? what’s ls -r? what’s ls -r? what’s ls -s? what’s ls -t? what’s ls –full-time? challenge 20181212 passed git git rebase -i Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 21 ‘wondering’ presentation laravel- warming up for challenge next week 2018/12/12The result of my target yesterdaylaracast no time for it. linux: what’s in /var/spool folder of linux? what’s nfs in full name? what’s lsb in full name? how to show true path rather than link path when using pwd? how to create folders through multipal layers? how to give authority when creating a folder? how to show $path? how to add a folder into $path? what’s ls -a? challenge 20181211 passed adaptor make every single book an object how to pass outside variable into closure git github notification flicked through github api and github hooks Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 18~? challenge 20181212 ‘wondering?’ rehersal 2018/12/11The result of my target yesterdaylaracast have completed recapping of 15~17 linux: what’s in /include folder of linux? what’s in /libexec folder of linux? what’s in /usr/src folder of linux? what’s in /var folder of linux? what’s in /var/cache folder of linux? what’s in /var/lib folder of linux? what’s in /var/lock folder of linux? what’s in /var/log folder of linux? what’s in /var/mail folder of linux? what’s in /usr folder of linux? what’s in /usr/bin folder of linux? challenge 20181210 passed git how to fetch all pull-requests without adding them as remotesfetch = +refs/pull//head:refs/remotes/origin/pr/ Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap 18~? challenge 20181211 2018/12/10The result of my target yesterdaylaracast the_php_practitioner series (25/25) was completed. have recapped the_php_practitioner 1~15. linux: what’s in /usr folder of linux? what’s in /usr/bin folder of linux? what’s in /usr/lib folder of linux? what’s in /usr/local folder of linux? what’s in /usr/sbin folder of linux? what’s in /usr/share folder of linux? what’s in /usr/games folder of linux? what’s in /home folder of linux? what’s in /lib qual folder of linux? what’s in /root qual folder of linux? what’s in /proc qual folder of linux? what’s in /sys folder of linux? git if you see something like pull request does not merge cleanly in github, what should you do?① add the original repository as a remote named “upstream”② fetch the newest work from that remote③ merge the main branch of that repository into your topic branch④ fix the conflict that occurred⑤ push back up to the same topic branch how could we reference issue or pull-request on github?## how to use task list on github? write the code write all the tests document the code Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner recap challenge 20181210 2018/12/9The result of my target yesterdaylaracast having completed episode 24, and will recap it again and push it to github linux: what’s in /home folder of linux? what’s in /lib qual folder of linux? what’s in /root folder of linux? what’s in /lost+found folder of linux? what’s in /proc folder of linux? what’s in /sys folder of linux? git what are the steps to create a pull-request on github?① clone our fork of the project locally② create a descriptive topic branch③ make our change to the code④ check that the change is good⑤ commit our change to the topic branch⑥ push our new topic branch back up to our github fork how to condense a whole feature branch into a single commit and push it to master branch as production branch. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner (24/25) recap and (25/25) 2018/12/8The result of my target yesterdaylaracast having completed episode 23 and pushed it to github linux: what’s in /media folder of linux? what’s in /mnt folder of linux? what’s in /opt folder of linux? what’s in /run folder of linux? what’s in /sbin folder of linux? what’s in /srv folder of linux? what’s in /tmp folder of linux? The Wondering having completed presentation for ‘wondering’ next week. git i didn’t have time for it yesterday. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git laracast: the_php_practitioner (24/25) 2018/12/7The result of my target yesterdaylaracast yesterday i didn’t watch it at all, my goodness. i must finish it today and move on! linux: what’s in /bin folder of linux? what’s in /boot folder of linux? what’s in /dev folder of linux? what’s in /etc folder of linux? what’s in /lib folder of linux? The Wondering both rehersal and presentation were perfectly done. Achieved except for set target yesterday sharing what i learnt from the deployment event at tuesday night with the whole backend team. DescriptionToday’s target presentation for The Wondering next week, or perhaps the week after that. linux: 鳥哥的linux基礎篇 git: pro git laracast: the php practitioner(23/25) recap, and push every step of it on github 2018/12/6The result of my target yesterdaylaracast finally, i finished episode (23/25) yesterday. i will try to recap it again and push each step on github linux: when installing package, why it shows 403 forbidden? the limit of length of the name of files and repositories in linux. fhs - filesystem hierarchy standard the purpose of fhs four types of repositories in linux explanation of four types of repositories - shareable, unshareable, static, variable three defaultly defined repositries by fhs The Wondering i have finished rehersal one time, and am going to do that again before presentation.Achieved except for set target yesterdayDescriptionToday’s target The Wondering rehersal before presentation linux: 鳥哥的linux基礎篇 laracast: the php practitioner(23/25) recap, and push every step of it on github 2018/12/5The result of my target yesterdaylaracast still stuck on the_php_practitioner episode 23. maybe bacause i stayed up late the night before last night with whole backend working server deployment, yesterday i was too groggy to figure it out. i have to finish it today!git: gpg security keys for git tag signituressl: having completed ssl hand-on experiment. linux: recap authority command with jett and soj. i was supposed to read linux book last night, however, i passed out as soon as i took a shower. Achieved except for set target yesterdayDescriptionToday’s target laracast: the php practitioner(23/25) The Wondering rehersal linux: 鳥哥的linux基礎篇 2018/12/4The result of my target yesterdaylaracast the php practitioner (23/25). i was scheduled to finish episode 23 yesterday. however, the whole backend team and i were working on server configuration and deployment all day long, and i will manage to finish it today. git: as above mentioned, i counldn’t manage any time for git yesterday. linux: what’s link file what’s data file what’s device file what are block and character of device file what’s socket file what’s fifo file Achieved except for set target yesterday ssl signature frontend and backend deployment on server with apache.DescriptionToday’s target laracast: the php practitioner(23/25) git: pro git linux: 鳥哥的linux基礎篇 ssl signature hand-on experiment.2018/12/3 The result of my target yesterdaylaracast the php practitioner (23/25), i’ve recapped the logic, and ready to go further. git: hand-on experiment on rerere function linux: chmod ugoa, +-=, rwx rules of authority for files and repositories regular file: ascii, data, binary how to read data file - last how to read ascii file - cat The Wondering completed Achieved except for set target yesterdayDescriptionToday’s target laracast: the php practitioner(23/25) git: pro git linux: 鳥哥的linux基礎篇2018/12/2 The result of my target yesterdaylaracast the php practitioner (23/25): i spent a lot of time recaping what i’d leart before backend challenge. i think i will need more time to retrive the logic before getting later episode. git: merging work flow large-merging workflow git config –global rerere.enabled true linux: chgrp [-r] groupname filename chown [-r] user:group filenameorrepositoryname chmod [-r] xyz filenameorrepositoryname docker: create a dockerfile build a dockerfile run a dockerfile push a dockerfile rough concept of docker Achieved except for set target yesterdayDescriptionToday’s target laracast: the php practitioner series git linux presentation of The Wondering for next week. 2018/12/1The result of my target yesterdayapache and nginx: having learnt how to use either apache or nginx as reverse proxy and proxy_pass to webserver with whatever headers that are required. git: create a branch based off another branch - git branch thebranchyouwant thebranchyouwouldliketobebasedoff will git reflog be pushed? - no can i pull from repositories that haven’t been added as remote? - yes how to pull from repositories that haven’t been saved as remote - git pull theurl, append –allow-unrelated-histories if not related. it shows only the work your current topic branch has introduced since its common ancestor with master - git diff master…meatlinux: drwxrwxrwx, what does d mean? -rwxrwxrwx, what does - mean? lrwxrwxrwx, what does l mean? brwxrwxrwx, what does b mean? crwxrwxrwx, what does c mean?DescriptionToday’s target laracast: the php practitioner series attending docker speech held on good idea studio git linux","link":"/zh-tw/schedule/2018/December/index.html"},{"title":"September 2019","text":"2019-9-30あの歌手は有名です 起こる 彼は背が低い 使う 肩が凝りました 私はワインが好きです 一番 午前 肩 会議は四時に終わります 読む 私は去年フランスへ行った 昼間は電気を消してください お店はもう閉まっていました 私は腕時計を四つ持っています 昨日から腰が痛い 七日 彼は神を信じている これはかなり金がかかった これは医者のためのサイトです 黄色い 九日 柿の木に実が沢山なっています 32ページを開いてください 力 普及 事件 昨日の会議について報告があります 明らか 理由 病院 問題 報告 構造 今回 私は彼から大きな影響受けました 資金 島の人口は年々増加しています いずれ 導入 従来 彼はその詩を用いて自分の気持ちを伝えた 今年は変化の多い年でした システムの構成を変えてみました 都市 話 住宅 変わる 強調 私は彼に使い捨ての箸をあげました 私は彼と彼女に誕生日カードをもらいました 私は日本語が大体できます あなたは私にこのDVDをくれました 母は料理の方法が分かります 彼女を幸せにする 私は親友と遊びたいです 私はあなたにデジタルカメラをもらいました あの屋敷に幽霊がいまし 部長は仕事ができます 一眼レフカメラ 布 動物園 隣人 テレビ 雄鶏 かっこいい 彼女はマーカーを買いたがります かっこいい 2019-9-29私は電車で通学しています まだ会いましょう １ 郵便局で切手を買いました 教える 見つける 肉と魚とどちらが好きですか 親の愛は有難い 週 旅行の日程を変えました 家 電車で子供が騒いでいた 午前 私の部屋は狭いです 置く 学生 飛行機 男の人が私たちに話しかけた 火曜日に会議があります 駅はどこですか 先月の七日に孫が生まれました 有る 私は夏が大好き 喉が渇きました 風邪 切る 時計を見たらちょうど三時だった 服 この曲線がこの車の特徴です 対象 会談の内容が発表されました 住宅 その計算は間違っている 方針 今後の方針が決まった 午前 方向 事務的な処理に一週間かかります 調べる 評価 商品 このソフトで日本語勉強することができます 選挙 彼は何年も地震の研究をしている ガソリンの価格がどんどん上がっている 重要 私は彼から大きな影響受けました 比べる それは最近話題の本ですね 女性 ここは一方通行です 命令 関係 建設 研究 段階 結果 制度 インターネットで新幹線の時刻表が分かります 向日葵は草より綺麗です 引き出しにはハムスターが一匹います 小林さんは中国語を話すことができます 私は日本語大体できます あの屋敷に幽霊がいますよ 全然 そこはどこですか 夏は涼しかったです 母はペットと海外旅行しました 私は彼から大きな影響受けました 簡単な質問 私は泳ぐことができます 乗客 下手 ギター ポルトガル 浅い 学長 サツマイモは焼いても揚げても美味しい ツアーガイド フロント フルート リットル クロサイが草原をありいている あの屋敷は幽霊がいますよう 2019-9-28そこに大きな円を書いて 彼は荷物を網棚に上げた 電車で子供が騒いでいた 彼の日本語のレベルは私と同じくらいだ 髪 工事は三月まで続きます 漢字は中国から来ました 彼は意外に気が小さい 戻る 顔 そう 授業 時の経つのは早い 冷たい ご飯 その子は指で十数えました 強い 私は二日待った この部屋は寒いです 時計を見たらちょうどさんじだた 左 触る 髪の毛が伸びたね 電車で子供が騒いでいた まずい お願い 五日 来る 乾く 首相 受ける 時計を見たらちょうど三時だった 彼は新製品に興味を示している 以上 関する 今後ともよろしくお願いします 自由 それはどういう意味ですか 彼は一人旅の計画を立てた 増える 工場 一部 重要 彼は選挙に出るつもりだ 試合の相手は誰ですか 方向 国は国語教育を強化しています 比べる 消える システムの構成を変えてみました 選挙 皆私たちに期待しています 銀行は三時まで開いています 可能 彼が来た目的がわかりません まあ今回は許してあげよう 輸入 傘をさす 母は料理の方法がわかります 私はサラリーマンです、彼もサラリーマンです みんなは運動会の予定がわかります 重要 あなたは小西さんに映画のチケットをもらいましたよね 運動場で走ります 方向 床に蟻がいます 比べる 部長は仕事ができます 校長 ポルトガル 生まれる 翻訳する ポスター か 熊 烏龍茶 年齢 ツアーガイド 料理を炒める 髭剃り フットボール 買い物カート ツアーガイド 2019-9-27大学に行ってもっと勉強したいです 入れる 図書館で料理の本を借りた 乗る 郵便局で切手を買いました 彼はまだ若いです 私たちのチームはその試合で負けた 帰国することに決めました 送る 誰と会ってみたいですか 探す 病気 喉が渇きました 嬉しい 今週 九日に荷物が届きます 後ろ向いて 上る 来る 口 よう 見つかる 今日はこのホテルに泊まります 柿の木に実が沢山なっています クーラーはまだ直りません 愛する 千円貸してください 付ける 三日 左 他に方法がありません 開ける まま その質問に対する答えが見つからなかった 政権が交代した 一緒に対策を考えましょう 建設 これら 段階 選挙 この段階では決断するのはまだ早いです 社会 立場 会長 残る なお 強化 生産 示す 部長を除く全員が土曜日も働いた 競争 次は全国のお天気です 実現 彼がクラスの代表だ あの服のほうが可愛いです 日本語を上手にする 九份は賑やかではありませんでした 私は日本語がわかります その子供は親友と遊びたがります 左 先生は難しいの本を読むことができます ないでください 動物園のパンダは小さいです 背が高くなる 選挙 深い湖 私は日本語ができます 動物園のパンダは小さかったです ハンバーガーとコーラ あなたの会社は私の会社に統計ソフトウエアをくれました 私は料理を作ることができます すみません、今は何時ですか 私は鉛筆で字を書く 私は日本料理を作ることが全然できません 鶏 社員 スプーン 愛妻弁当 あごひげ 栓抜きありますか スーツケースに詰める む 2019-9-26春 去年 若い 言葉 いつ 難しい 使う かく 郵便局で切手を買いました 言う 近い 狭い 質問のある方はどうぞ 私たちは先月十一日に結婚しました 千円貸してください 強い 要る 大人 悲し 泊まる 喉が渇きました 宿題は自分でやりなさい 桃を五つください 選ぶ 残る 動き お金はまだ十分あります 建設 伴う 部長除く全員が土曜日も働いた 問題が一つあります よく答えが分かりましたね 計画 決定 実現 ゴミのリサイクルが普及している 郵便局で切手を買いました 私は四つの会社に投資しています 段階 経済 電話 関する 地域 なお、雨の場合は中止です 喉が渇きました 試合の相手は誰ですか 交渉 音楽は彼の得意な分野です これから、より一層努力します 残る 調査 一緒に対策を考えましょう 事故 建設 かく 私は日本語はあまりできません お爺さんは昔の記憶を忘れたがります あの歌手は有名でがありません インターネットで新幹線の時刻表が分かります ゲームをしませんでした テストはいつですか 明日や明後日や来週などですね 私は王建民ほど有名ではありません 彼女は飛行機を運転することができます 私は実家に帰りたいです 夏は涼しくありませんでした 弟は父の性格がわかります チケットください レシートをください 父は台湾料理をできます 上野さんは彼女と映画を見ました 冬は暖かかった 私はあの記憶を忘れたいです ニュースで道の状況がわかります 彼女は明日の天気がわかります 小学生 有名 キャベツ 一眼レフカメラ あごひげ 女性がももの太さを計っている 腹部は、肋とお尻の間の部分です を あごひげ 2019-9-25遅い こう 次 安い 知る 部屋 一番 彼は意外に気が小さい 見つかる レストランは空いていました 十日後に帰ります 細い 汚い お母さんによろしくを伝えください 彼は昼過ぎに来ます 治る この道を真っ直ぐ行くと駅です 悪い 一杯 ご主人 お腹が空きますた 私の祖母は100歳です 彼はこの辺に住んでいる 五月五日は祝日です 構成 生活 交渉 彼がクラスの代表だ より 開発 可能 彼は非常に高い技術を持っている 初めて 試合 文章 私たちがその問題を調査しています 良い方法思いつきました 利用 方針 段階 トラブルがやっと解決しだ 遅れた理由を教えてください なお 対する 今日中にこの問題を検討してください 帰ったらまず手を洗いましょう 影響 決定 話 管理 引越しを業者に頼んだ 意見 母は日本料理を作ることができます 期末レポートは大変です 浅い川 日本語が上手になる 貯金箱に40個のコインがあります 傘は長いです 私は日本料理を作ることがよくできます 試合の相手は誰ですか 両親は日本に行きます、私も行きます あの人は木を登ることができます さあ、私もわかりませんね ピザを買いました、パスタも買いました 小林さんは中国を話すことができます お母さんは実家に帰ります レシートをください うそ 美味しいデザート ボタンを押す 教室が静かではありません 彼女は飛行機を運転することができます キャベツ 蚊 辞書 餌 サツマイモは、焼いても揚げても美味しい もも センチメートル 茶髪 2019-9-24取る 彼の日本語のレベルは私と同じ位だ 短い 食べる 今朝は早く家を出ました もっと近くに来てください 病気 立つ 彼は意外に気が小さいい 飛行機 私は二日待った 米 妹 十日後に帰ります 閉まる これは医者のためのサイトです 教科書閉じてください 答えが違います 閉める 店員は若い女の人でした 悲しい 後で電話します 増える 彼がクラスの代表だ 段階 彼は意外に気が小さいい 写真はいい思い出になります 問題 加える 政権が交代した 変わる 資金 集める 前売券は窓口で販売しています 可能 国会 変化 病院 土地 方針 のち 彼がクラスの代表だ 段階 これら 明らかに彼が悪い 調べる ここは静かな住宅地だ 私は世界一周をしたかったです 冬は暖かくありません 彼女はボーリングができます 彼は実家に帰りたがります 彼女を幸せにする あなたの会社は私の会社に統計ソフトウエアをくれました 私は日本語ができます 先生は私に100点くれました 石原さんは彼に防虫スプレーをもらいました 可能 先生は学生の気持ちがわかります 文房具 液晶テレビ 翻訳する たつ 一眼レフカメラ 皿 蚊 雄鶏 私は物理の基礎はしています 教授ガズを説明する フロント 2019-9-23古い 引く 肩 全部 軽い 起こす 勝つ 少し疲れました 一番 使う 持つ 始める 質問 図書館 太い 冷たい ６ 三つ 茶色 野球は九人で人チームです 開く 口 彼に会えて嬉しかった 姉は大学生です 泊まる 彼はシートベルト締めた 宿題は自分でやりなさい 導入 対策 十分 種類 内容 私たちは二階に上がった まま 会談の内容が発表されました 彼はその詩を用いて、自分の気持ちを伝えた 今日の予定教えてください 首相 あまり 完成 我が社の経営はうまくいっています 部分 行う 工場 一部 政権が交代した 経営 仕事がほぼ終わりました 対する 彼は新製品に興味を示している 関係 ここは静かな住宅地だ 今夜は大いに語りましょう 調べる 私は先生と事務室に行きます プールで泳ぎます 私は歌を歌うことができます 私は日本料理を作ることができます 石原さんは彼に防虫スプレーをもらいました 私は日本語がよくできます 元気な子供う 向日葵は草より綺麗です あなたの会社わ私の会社に統計ソフトウエアをくれました ドアを開ける 運動場で走ります 政権が交代した あの人は木に登ることができます ベッドの下にゴキブリがいます 私は日本料理を作ることが大体できます ジーンズを買いましょう 川の岸に桜の木があります 新設の先生 下手 布 期末レポート 大きな竜巻 明後日 暑い 教授が、図を説明する スーツケースに詰める 腹部は肋とお尻の間の部分です フルード 黒犀が草原を歩いている フットボール あなたの会社わ私の会社に統計ソフトウエアをくれました 2019-9-22学校 一番 私は朝シャワーを浴びます 約束を忘れないてください ウエイターを呼びましょう こう小さい字は読めない 学校は8時半に始まります 彼の日本語のレベルは私の同じくらいだ 弱い 私は二日待った 私は絵手伝いましょう お腹 泊まる 宿題が自分でやりなさい 一番 喋る 閉める 晴れる 腰 彼女は眠いようです 神 増える 方針 生まれる 代表 宿題は自分でやりなさい 生活 外国 増加 計算 解決 新聞 首相 開発 私たちは今結婚資金を貯めています 実現 試合の相手は誰ですか 実施 一般 強化 より 特徴 ほとんど 調べる 彼は食品工場で働いています 今後の方針が決まった 建設 開く 変化 私にはたくさんのお金が必要だ 販売 住宅 立場 計画 存在 今回 彼女は同じ間違いを繰り返した なお、雨の場合は中止です いずれ システムの構成を変えてみました 予定 決定 ニュースで道の状況がわかります 私は日本料理を大体できます 私は日本料理作ることがまあまあできます 長い傘 あの屋敷に幽霊がいますよ 彼は学校に来ませんでした 引き出しにハムスターが一匹います 佐々木さんはサラリーマンです 私のノートはどれですか 白い紙を黒くする 川の岸に桜の木があります ご飯を食べましょう 私は会社に行きます 台湾は暑いです 私は日本語が全然できません 私はもっと頑張りたかったです 私は日本料理を作ることがあまりできません 私は日本料理を作ることが全然できません 田舎は都市ほど便利ではありません チケットをください ハンバーガーとコーラ はい、そうです 私は実家に帰りたがります 林さんは私にコンサートのチッケトをくれました 彼は明日の天気がわかります 小林さんの妻は小林さんに愛妻弁当あげました 乗客 鶏 ゲーム機 翻訳する 社員食堂 ゴミ箱 腹部は、肋とお尻の間の部分です サツマイモは、焼いてもあげても美味しい 女性はももの太さを計っている 栓抜きありますか む 2019-9-21生活 なお、雨の場合は中止です 実現 決定 試合の相手は誰ですか 会談 試合の結果早く知りたい 政府 私は日本語がまあまあできます 私は料理を作ることができます 国仲さんは貴方にギターをもらいました それは正方形です 私は世界一周をしたいです 車の後ろに子猫と子犬がいます お元気な子供 貴方は貴方の弟にケーキをあげましたか なお、雨の場合は中止です 日本語を上手にする 私は日本料理を作ることがあまりできません 私は日本料理を作ることができます 先生は私に100点をくれました 私は日本料理を作ることが少しできます 正方形はどれですか 私は日本料理を作ることがまあまあできます 犬と猫と兎、どれが好きですか 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 試合の相手は誰ですか 床に蟻がいます 私は弟と妹と実家に帰りました 調べる ポルトガル 烏龍茶 簡単 翻訳する 隣人 年齢 海外旅行 腹部は肋とお尻の間の部分です 雄鶏 ロブスター センチメートル む う 翻訳する 腹部は、肋とお尻の間の部分です 2019-9-20九份わ賑やかです 肉と魚とどちらが好きですか 知る 国 体 この靴はとても軽い 帰国することに決めました 家に帰ろ 軽い 酒 質問の意味はわかりましたか 今日は日本語の授業があります 見つける 私は友達が沢山います 笑う 飛行機 私は平仮名を全部読めます 時 六つ 私は腕時計を四つ持っています この道を真っ直ぐ行くと駅です 柿の木に実が沢山なっています 時の経つのは早い 書ける 辛い 細い 彼はこの辺に住んでいます 冷たい 他に方法がありません 九日に荷物が届きます 飛行機 彼はこの辺に住んでいます 野球 先 一部 昨年 資金 示す その問題に関する記事を読みます ここは一方通行です 会社 従来 生産 彼は行政を改革したいと思っていあ 資金 帰ったら、まず手を洗いましょう 増える 方針 工場 やる 兄は船の設計をしています彼は就職試験を受けた 問題 株 交渉 一緒に対策を考えもしょ 政権が交代した 強調 商品 評価 変わる 開発 島の人口は年々増加しています 情報 私たちがその問題を調査しています 増える 工場 事務的な処理に1週間かかります 解決した 機能 彼は歌で自分の気持ちを表現した 20キロのダイエットは可能だと 良い方法を思いつきました 今日の予定教えてください 彼はその詩を用いて自分の気持ちを伝えた 私は日本語があまりできません 料理を美味しくする この犬 浅い川 皆に運動会の予定わかります 私は日本料理を作ることが少しできます 私は日本語が全然できません ハンバーガーとコーラ 夏はシズしかったです 先生は学生の気持ちがよくできます 私は日本語が少しできます 深い湖 運動場で走ります 鉛筆で字を書く 私は日本語がよくできます 国内旅行 キャベツ 一眼レフカメラ 皿 子猫眠った センチメートル 雄鶏 私が物理の基礎はしています 良い方法思いつきました フットボール 夜市は賑やかです サツマイモは焼いても揚げても美味しい 教授が図を説明する フロント 栓抜きありますか クロサイが草原を歩いている スーツケースに詰める ぬ い ゆ ぎ ざ ね 2019-9-19サツマイモは焼いても揚げても美味しい 歩く 首 働く 肩 質問のある方はどうぞ 払う 彼に手紙を書きました まだ わかる 直る 八 五日 大好き 今週 お先にどうぞ 私は平仮名を全部読めます 鼻がかゆいです 冷たい 答える これはかなり金がかかった これは医者のためのサイトです 彼には子供が六人います 後ろを向いて 場合 愛する 他に方法がありません 経済 導入 関係 前売券は窓口で販売しています 国は国語教育を強化しています 冷たい はげしい雨が降っています 彼は新製品に興味を示している その問題に関する記事を読みました 消える 一部 政権が交代した 動き ガソリンの価格がどんどん上がっている 変わる 計画 増える 普及 対処 今の首相はあまり力がない 力 トラブルがやっと解決した 信号が青に変わりました 一部 政権が交代した 変わる 問題 増える 政権 報告 結果 ドル 今後ともよろしくお願いします 母はペットと海外旅行しました うそ 私は使い捨ての箸をあげました ハンバーガーとコーラ 方針 私は日本語があまりできません 彼のお父さんは彼に新し腕時計をもらいました 楽し一日 彼女を幸せにする 私は学生でした いつが暇ですか 私は泳ぐことができます 隣の人は私の猫に餌をくれました コーヒーを飲みましょうか 私は貴方にデジタルカメラをくれました 大学の先輩は商売ができます 小西さんは貴方に映画のチケットをあげましたよね 私は討論を始めたいです ハンバーガーとコーラ 大きくなかった お爺さんは昔の記憶を忘れたがります 西洋料理 鶏 一眼レフィカメラ 布 金曜日 文房具 液晶テレビ 映画 タンス フクロウ フットボール フロント 栓抜きありますか 栓抜き 買い物カート 教授が、図を説明する 妹はコップを割った 蝉 十八 葉が落ちます フルート 雄鶏 虹 センチメートル 物理学 説明する 買い物カートはからです フットボール フロント 栓抜きありますか スーツケースに詰める 女性がももの太さを計っている 教授が、図を説明する 私は物理の基礎はしてリマス 鳴いている雄鶏 雄鶏 炒める アリクイ センチメートル コロサイが草原を歩いている 彼女は茶髪でえくぼがあります スーツケースに詰める 私は物理の基礎は知っています 緑色の蝉 ７.９センチメートル センチメートル コロサイが草原を歩いている 2019-9-18親の愛は有難い 出来る 美しい 肩 私は電車で通学しています 質問 彼女は秋に結婚します 入れる 質問のある方はどうぞ 広い 言う 知る 今年 喉が渇きました 四月に大学に入学しました 二つ 何か飲み物が欲しいな 私は昼のドラマを毎日見ます 彼女はとても綺麗だ クーラーはまだ直りません 要る これは医者のためのサイトです 入る お父さんは会社員です 決まる 赤い線を2本引いてください 帰ったら先ず手を洗いましょう 報告 自由 よく答えが分かりましたね 質問のある方はどうぞ 新製品に興味を示している 以上 より システム 銀行は3時まで開いています 住宅 導入 まあ今回は許してあげよう 目たつ 文章 強化 彼はその詩を用いて自分の気持ちを伝えた 企業 これからより一層努力します これは医者のためのサイトです 首相 解決 実現 関係 運動場で走ります 弟は父の性格が分かります 私は石原さんに防虫スプレーをあげました 先生はテストの解答が分かります 教室は静かではありません 遊びましょう 私は日本語が少しできます 短い鉛筆 導入 日本語が上手になる 私は王建民ほど有名ではありません 私は親友と遊びたいです ご飯を食べましょう 烏龍茶 ドラゴン 一眼レフカメラ 土曜日 車の乗客 期末レポート 下手 あっさて 明後日 日本 女性がももの太さを 女性がももの太さを測っている 関係 調味料 料理を炒める 説明する 茶髪 質問する フルート チームでフットボールをしています サツマイモは、焼いても揚げても美味しい サツマイモは、焼いても揚げても美味しい 女性がももの太さを計っている フルート 妹はコップを割った 2019-9-17運動場で走ります あの歌手は有名です 次 聞く 近い 彼は荷物を網棚に上げだ 大学に行ってもっと勉強したいです 立つ 会議は四時に終わります 肩 彼はまだ若いです 作る 私達のチームはその試合で負けた 楽しむ 私は毎朝6時に起きます 決まる 使う 立てる 父 彼女は茶色の靴を履いています 先 柿の木に実がたくさんなっています 金 駅 来る 今夜は月がとても綺麗です 悪い 土曜日 肩 有る この道を真っ直ぐ行くと駅です 知る 喉が渇きました そばにいてください 悲し お金はまだ十分あります 多く 語る 私たちは今、結婚資金を貯めています 交渉 資金 まま 私たちがその問題を調査しています 銀行は3時まで開いています それはどういう意味ですか 計画 女性 採用 このアンケート大学生が対象です 一緒に対策を考えましょう 実現 けれは新製品に興味を示している 銀行は3時まで開いています ここは父の土地です 土地 社会 私たちは二階に上がった 文章 首相 帰ったら先ず手を洗いましょう 強化 今日の新聞どこに置いた 彼はその詩を用いて自分の気持ちを伝えだ お金がほとんどありません 実現 開発 引き出しにハムスターが一匹います 歩きます 首相 私は日本語が大体できます 私は世界一周をしたかったです 彼は学校に来ませんでした 簡単な質問 佐々木さんはサラリーマンです 私は日本料理を作ることがよくできます 机の上に雑誌があります 帰ったら、先ず手を洗いましょう 強化 ご飯を食べましょう 私は頑張りたくありませんでした 石原さんは彼に防虫スプレーをもらいました 彼はその詩を用いて自分の気持ちを伝えた あの屋敷に幽霊がいましよ 浅い川 私は日本語がまあまあできます お爺さんは昔の記憶を忘れたがります 私のノートはどれですか 庭に松があります 小林さんは中国語を話すことができます 愛妻弁当 烏龍茶 乗客 ご飯を食べましょう 皿 烏龍茶 ポルトガル 布団 液晶テレビ 和食 引き出し 隣人 暇 腕時計 一眼レフカメラ 社員食堂 親戚 フライト 解答 スマホ 果物 羊 鶏 涼しい 社長 オフィス 学長 年齢 紙箱 親切 文房具 布 折りたたみ傘 トンネル 竹 カレンダー 上手 一眼レフカメラ 調味料 アリクイ 2019-9-16予約は要りません 八つ 娘は明日九つになります 今日の予定を教えてください 構成 この商品はよく売れている 彼はロボットの研究をしています 計画 命令 中心 重要 話 彼は新製品に興味を示している 一緒に対策を考えましょう 私たちがその問題を調査しています 十分 変化 対する なお 開発 動き 島の人口が年々増加しています この曲線がこの車の特徴です 交渉 その事件の犯人はまだ捕まっていない 彼は社員ですか 九份は賑やかです 私は日本語があまりできません うそ 川の岸に桜の木があります 先生は私に100点をくれました 私は妹と弟と実家に帰りました 計画 ドアをあげました 書店で小説を買う 狭い部屋 私は鉛筆で字を書く 彼は新製品に興味を示している あの服のほうが可愛いです 向日葵は草より綺麗です 台湾は日本より暑いです 一緒に対策を考えましょう ニュースて道の状況がわかります 私たちかその問題を調査しています 開発 交渉 国仲さんは彼にギターをもらいましたよう あの人は字を登ることができます 日本語を上手にする 夏は涼しくありません 猫の方が好きですジュースはコーヒーほど高くありません 深い湖 運動場で走ります 貴方は彼女に期末テストの解答をもらいましたようね インターネットで新幹線の時刻表が分かります 車の後ろに子猫と子犬がいます キマレポート 鶴 中学生 大きな竜巻 うし 乗客 布団 キャベツ 文房具 動物園 布 フライト 下手 虎 手 2019-9-15下手 液晶テレビ 今朝は早く家を出ました 起きる 切る 言う もつ この本はとても面白い 私たちは大きな声で歌いました 鳥が飛んでいます 工事は3月まで続きます 日記 まだ会いましょう 負けた いろ 入れた 送る 言う 入れる 兄 肉と魚とどちらが好きですか 漢字は中国から来ました 私は朝シャワーを浴びます 帰国することに決めました 今年はイタリヤに旅行したい 死ぬ 私が手伝いましょう 強い 万 彼はシートベルト締めた その子は指で十数えました 母 一杯 神 大人 時計を見たらちょうどさん時だった この部屋は寒いです 宿題は自分でやりなさい 彼は時々遅刻します 妻 店員は若い女の人でした この道を真っ直ぐ行くと駅です帰国することに決めました 他に方法がありません 十日後に帰ります ご主人 彼は昼過ぎに来ます 前売券は窓口で販売しています 彼は食品工場で働いています 加える トラブルがやっと解決した 対する 彼かクラスの代表だ 相手 一般 この段階では決断すろのはまだ早いです ポルトガル コンピューター 私はテレビをあまり見ません ほぼ 集める その計算は間違っている 島の人口は年々増加しています 写真はいい思い手になります 関する 引越しを業者に頼んだ 生まれる 国会が再開した 種類 動き 彼は就職試験を受けだ 消える 我が社の経営はうまく行っています これは重要な書類です 病院 彼は非常に高い技術を持っている 音楽は彼の得意な分野です 内容 ポルトガル 状態 システムの構成を変えてみました ここは静かな住宅地だ 住宅 提供 彼は選挙に出るつもりだ 島の人口は年々増加しています 株 それはどういう意味でスカ いずれ この段階です決断するのはまだ早いです 今回 彼女は幸せにするベッドの下にゴキブリがいます 静かな教室 動き 床に蟻がいます 浅い川 2019-9-14社員食堂 見せる 帰る 私の部屋は狭いです こう 見つける 負ける 今朝は早く家を出ました 待つ 疲れました 起こす 生きる 来月の一日は空いていました 社員食堂 わかった人は手を上げてください 来る 不味い 彼女は足が太い 他に方法がありません 九日に荷物が届きます 私の祖母は100歳です 悲し 五日 答が違います 教科書閉じてください 千円貸してください いる 風邪 腰 細い 彼は私の方見ました 方針 完成 この道をまっすぐ行くと駅です 他に方法がありません 国内 会長 制度 強化 この温泉はただです 今後ともよろしくお願いします 仕事がほぼ終わりました 生産 研究 受ける 部分 構成 外国 事務的な処理に1週間かかります 多く 叔母は小さな会社の社長です ガソリンの価格がどんどん上がっている 影響 消える ここは一方通行です 貴方の意見が聞きたいです 前売券は窓口で販売しています フランスの大統領は誰ですか 料理が沢山残りました 存在 評価 全体の80%が完成しました 管理 輸入 トラブルがやっと解決した 強調 彼は私にノートパソコンをくれました ビザを買いました、パスタも買いました 彼女はボーリングができます 佐々木さんはサラリーマンです 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 石原さんは彼に防虫スプレーをもらいました 前売券は窓口で販売しています 教室は静かではありません 私は日本語があまりできません 日本語が上手になる 彼は学校に来ませんでした母はペットと海外旅行しました あの屋敷幽霊がいますよ トラブルがやっと解決した 私のノートはどれですか 夏は涼しかったです 私はもっと頑張りたいです 私は世界一周をしたかったです 犬と猫と兎、どれが好きですか うそ 長い傘 引き出しにハムスターが一匹います 先生は私に１００点をくれました ストップウォッチ 期末レポート 猿 緑茶 文房具 布 キャベツ 隣人 書店 皿 乗客 そば 餌 レンタサイクル 蜘蛛 車の乗客 うそ 解答 年齢 ペットボトル 原稿を改訂する 嫌い ソファ 自転車 一眼レフカメラ 期末レポート 雑誌 文房具 布 キャベツ 大人 彼は行ったり来たりして、とても焦っています 隣人 皿 乗客 年齢 うそ 暇 下手 博物館 カレーライス 海 故郷 一眼レフカメラ マイカー 消しゴム 香水 レタス 牛 液晶テレビ 2019-9-13引き出しにハムスターが一匹います 今年は雨が少ないです 学校は8時半に始まります 彼女からプレゼントをもらいました もう寝よう 祖父が病気になった 弱い 約束を忘れないでください 数 続きます 使う あげる 仕事のあと映画を見た 彼は毎晩3キロ走っています 授業 去年 悲し お店はもう閉まっていました 10日後に帰ります 彼女は眠いようです 男の人が私達に話しかけだ 私は好み性に良く来ます 三つ 夫の服をハンガーにかれた 後ろ向いて 米 来る 私は腕時計を四つ持っています 日本人はお米が大好きです 彼に会えて嬉しかった 悲し 休む いる 3日 時の経つのは早い 酸っぱい 一方 私の両親は昭和生まれです 選挙 部長除く全員がと土曜日も働いた 会談の内容は発表されました 対立 発生 輸入 遠くに彼女の姿が見えた 事件 うんどうかいはくじに開始です 来る これからより一層努力します 建設 強化 病院はどこですか 競争 規模 いる 開発 予定 原因 工場 トラブルがやっと解決した 電話 住宅 彼女は同じ間違いを繰り返した 経済 私は討論を始めたいです 鉛筆は短くありません 強化 カレーライスとオムライス、どちらが美味しですか 石原さんは彼に防虫スプレーをもらいました 私は父と食事をしました 彼は学校に来ませんでした ドアを開ける 皆は運動会の予定が分かります 楽しい一日 彼女は幸せにする 貴方は小西さんに映画のチケットをもらいましたよね トラブルがやっと解決した 料理を美味しいくする 私は学生です その子は親友と遊びただります 私は貴方にデジタルカメラをもらいました 石原さんは彼に防虫スプレーをもらいました 私は彼に使い捨ての箸をあげました 彼は学校に来ませんでした 私は日本語があまりできません 川の岸に桜の木があります 傘を長くありません 彼女は私に新し手帳をくれました 部屋で食べます 私は王建民ほど有名ではありません 私は学業を続きたいです 先生は私に100点をくれました 弟は父の性格がわかります 私は鉛筆で字を書く 彼の父は彼に新し腕時計をもらいました 私にデジタルカメラを 私は日本語があまりできません 先生は私に１００点をくれました 私は親友と遊びたいです このリングをください お爺さんは昔の記憶を忘れただります 楓 机 ロッキングチェア 社員食堂 森 夜市 予備校生 生まれる 中学生 レストラン 着物 紅茶 部長 ペット 課長 校長 宝石 2019-9-12おじいさんは昔の記憶を忘れたがります 九份は賑やかです 約束を忘れないでください 仕事 見る 胸 肉と魚とどちらが好きですか 忘れす 冬 私はワインが好きです 誰 私は去年フランスへ行った 座る 乗る 帰る 授業 20日 鼻 時の経つのははやい 喉が渇きました 強い 今週 お願い 閉める 柿木に実が沢山なっています 先月の7日に孫が生まれました 多分 太い お先にどうぞ 約束を忘れないでください 国は国語教育を強化しています 彼は何年も地震の研究をしている 授業 国内 あの人たちは皆同じ方向見ている お金はまだ十分あります 体重がかなり減りました 経済 私たちは二階に上がった 変わる 以上 のちに 構造 建設 備える 交渉 より 今後ともよろしくお願いします 良く答えが分かりましたね 私は四つの会社に投資しています 目たつ 文章 方法 昭和 普及 それは最近話題の本ですね 問題が一つあります 怪我はもう治るましたか 住宅 用いる 販売 与える 声 皆私たちに期待しています 検討 生活 商品 ただです 庭の中に松があります 簡単な質問 ドアを開ける 佐々木さんはサラリーマンです 深い湖 川の岸に桜の木があります 私は世界一周をしたかったです 学生ではない 日本語が上手になる ニュースで道の状況がわかります 夏は涼しいです 国仲さんは貴方にギターをもらいましたよね 住宅 床に蟻がいます 私は学業続けたいです 私のノートはどれですか この服とあの服、どちらが可愛いですか 運動場で走ります 貴方にプレゼントをあげました 貴方は教師ではありません ドアを開ける 回 期末テストは大変でした 日本語を上手にすろ 私は弟と妹と実家に帰りました ペットを飼いましょうか キマワリは草より綺麗です カバンに香水があります あの屋敷に幽霊がいますよ 九份は賑やかではありません 引き出しにハムスターが一匹います 飲み物を買いません 学食の料理は不味いです、このレストランの料理も不味いでしょ 教室は静かではありません これはなんですか あの人は木を登ることがでします 大学の先輩は商売ができます 本棚に小説と雑誌があります 2019-9-11私は朝シャワーを浴びます 飛行機 春 引く 見つける 彼は数学を教えています 言葉 宿題はまだ終わっていません いつ かく 一緒に たつ 見つかる 口 私はパンよりご飯が好きだ 宿題は自分でやりなさい 私は夏が大好き 野球は九人で人チームです 喋る 先月の7日に孫が生まれました 側 強い 6日前日本に帰ってきました 階段 変化 国会 今後ともよろしくお願いします 報告 競争 生まれる 販売 関する 国内 行う 命令 ここは静かな住宅地だ 語る 一般 導入 パソコン システムの構成を変えてみました 先月の7日に孫が生まれました 強い 東京は日本一大きな都市です 今後ともよろしくお願いします 資金 ガソリンの価格がどんどん上がっている 計算 消える 理由 いるに餌をやった 土地 株 彼はパーティー会場を提供してくれました 決定 傘は長くありません 深い湖 私は頑張りたくありません あのバカは2本の鉛筆を箸にして、ご飯を食べる 母はペットと海外旅行しました お爺さんは昔の記憶を忘れたがります テレビをつけました 国仲さんは貴方にギターをもらいましたよ これは私のコンピューターです 父は台湾料理を作ることができます 私は鉛筆で字を書く 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 先生はテストの解答がわかります 刺身をください プールで泳ぎます 深い湖 私は日本語が大体できます 庭の松は高くありません 九份は賑やかでわありません 2019-9-10あの人は木の登ることができます 日本語が上手になる 教室は静かではありません 彼女を幸せにする 川の岸に桜の木があります あの屋敷に幽霊がいますよう 置く 彼は荷物を網棚に上げた 使う 私たちのチームはその試合で負けた 肉と魚とどちらが好きですか 親の愛入り難い 午前 どれ 大学に行って、もっと勉強したいです 次 彼は郵便局を探していました 取る 消す 軽い 飛ぶ 掛ける 分からない場合は私に聞いてください 私が手伝いましょう 宿題は自分でやりなさい 九日に荷物が届きます クーラーはまだ直りません あの屋敷に幽霊がいますよう 載せる 娘は明日九つになります 晴れる 曇る 悪い 終わり 九日 四月に大学に入学したした 五日 音楽は彼の得意な分野です 都市 昨年 事務的な処理に1週間かかります システムの構成を変えてみました まま 彼は選挙に出るつもりだ それはどういう意味ですか 消える 宿題は自分でやりなさい 彼は食品工場で働いています 参加 女性 部分 彼は就職試験を受けた 彼がクラスの代表だ 加える 結果 彼は行政を改革したいと思っている ガソリンの価格がどんどん上がっている 一般 内容 力 可能 対する 十分 文章 ここは一方通行です システムの構成を変えてみました 佐々木さんは大学生です、私も大学生です 彼女はボーリングができます 消える 床に蟻がいます 私は学生です 楽しい一日 私は鉛筆で字を書く（書きます） 役所の人はお婆ちゃんに綺麗なカレンダーをくれました 私のノートはどれですか ガソリンの価格がどんどん上がっている ペットを飼いましょうう 一般 佐々木さんはサラリーマンです あの服のほうが可愛です 私は世界一周をしたかったです 庭の松は高いです 先生は討論を始めたがります 床に蟻がいます 私にデジタルカメラをくれました アフリカにきりんがいます 私は鉛筆で字を書く 弟は家に帰りました お釣りをください 私は書いた原稿本にする 小林さんは中国語を話すことができます 弟は父の性格がわかります 私のノートはどれですか 母は日本料理ができます 私は彼に使い捨ての箸をあげました","link":"/zh-tw/japanese/2019/September/index.html"},{"title":"April 2019","text":"2019/4/30The result of my target yesterday node.js Implementing MVC on Express.js docker English Japanese achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/29The result of my target yesterday English docker Japanese Node.js Working on documentation of GCP Mountain hiking achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/28The result of my target yesterday English docker Japanese Node.js Working on documentation of GCP IWD worker achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/27The result of my target yesterday English docker Japanese Node.js Build an app server with express.js achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/26The result of my target yesterday English Japanese Node.js Go deeper into event loop What’s event loop Every phase in event loop timers I/O callbacks idle, prepare poll check close callbacks achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/25The result of my target yesterday English Japanese Node.js Parsing request bodies Understanding the concept of event driven Blocking and Non-Blocking Code Roughly reading through event loop achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/24The result of my target yesterday English Japanese Node.js module create a rudimentary server end a loop get information we want from request define response rudimentary request routing achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese 2019/4/23The result of my target yesterday English Japanese Get deeper into Docker Write down current progressAchieved except for set target yesterdayDescriptionToday’s target English Japanese Node.js 2019/4/22The result of my target yesterday English Japanese Get deeper into Docker Completed my first image made by Docker commitAchieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/21The result of my target yesterday English Japanese Get deeper into Docker Docker commit Achieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/20The result of my target yesterday English Japanese Get deeper into Docker docker tag, docker push, docker volume, docker save Achieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/19The result of my target yesterday English Japanese Finish Inboxer project Get deeper into Docker Create a MySQL container and connect to it while another MySQL is installed locally. That is, I could connect to two MySQLs in the server. Achieved except for set target yesterdayDescriptionToday’s target English Japanese Get deeper into Docker 2019/4/18The result of my target yesterday English Japanese Finish Inboxer project Still wait for DNS to update for SSL signature Achieved except for set target yesterdayDescriptionToday’s target English Japanese Finish Inboxer project Get deeper into Docker 2019/4/17The result of my target yesterday English Japanese Complete CentOS document with Docker Achieved except for set target yesterdayDescriptionToday’s target English Japanese Finish Inboxer project 2019/4/16The result of my target yesterday English Japanese Inboxer project Quote the translation feeAchieved except for set target yesterdayDescriptionToday’s target English Japanese Complete CentOS document with Docker 2019/4/15The result of my target yesterday English Japanese Inboxer project Initially completed deploying and send-mail function Achieved except for set target yesterdayDescriptionToday’s target English Japanese Inboxer project Quote the translation fee 2019/4/14The result of my target yesterday English Japanese GCP event Achieved except for set target yesterdayDescriptionToday’s target English Japanese Inboxer project 2019/4/13The result of my target yesterday English Japanese GCP Essentials review Working on docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Event 2019/4/12The result of my target yesterday English Japanese GCP Essentials review Working on docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Kubernetes and Load Balance 2019/4/11The result of my target yesterday English Japanese GCP Essentials review Working on docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/10The result of my target yesterday English Japanese GCP Essentials review Go deeper into docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/9The result of my target yesterday English Japanese GCP Essentials review Docker-compose Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/8The result of my target yesterday English Japanese GCP Essentials review Go deeper into Docker - Overlay Network Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/7The result of my target yesterday English Japanese GCP Essentials review Go deeper into Docker - Swarm and Service Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/6The result of my target yesterday English Japanese GCP Essentials review Docker - containerAchieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/5The result of my target yesterday English Japanese GCP Essentials review Docker - image Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/4The result of my target yesterday English Japanese GCP Essentials review Go deeper into Docker Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/3The result of my target yesterday English Japanese GCP Essentials review Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Go deeper into Docker 2019/4/2The result of my target yesterday English Japanese GCP Essentials review 1~3 Laracasts-Laravel_5.7_From_Scratch No time for it Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review 2019/4/1The result of my target yesterday English Japanese GCP Essentials - Kubernetes Quick Start Laracasts-Laravel_5.7_From_Scratch Achieved except for set target yesterdayDescriptionToday’s target English Japanese GCP Essentials review Laracasts-Laravel_5.7_From_Scratch","link":"/zh-tw/schedule/2019/April/index.html"},{"title":"November 2018","text":"2018/11/30The result of my target yesterday ‘The Wondering’ sharing was perfectily done. having learnt the purpose of $remote_addr and $proxy_add_x_forwarded_forAchieved except for set target yesterdayDescription Today’s target go deeper into apache and nginx config git linux 2018/11/29The result of my target yesterday having learnt how to use apache with php-fpmAchieved except for set target yesterday having completed backend challenge of second roundDescription Today’s target go deeper into apache and nginx config share git in ‘The Wondering’ 2018/11/28The result of my target yesterday backend challenge was completedAchieved except for set target yesterday DescriptionToday’s target go deeper into apache config 2018/11/27The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target aws ec2, eip, security group server default environment apache, nginx installation and config","link":"/zh-tw/schedule/2018/November/index.html"},{"title":"December 2019","text":"2019-12-31私は朝シャワーを浴びます 座る 同じ 速い 家に帰ろう 兄は水泳が得意です 工事は3月まで続きます 漢字 彼は意外に気が小さい 新しい年が始まりました そう 近い 細い 腰 五日 私が手伝いましょう 手紙が届くのに三日かかりました 多分 採用 政府 建設 会談 彼は選挙に出るつもりだ 治る のち それは最近話題の本ですね 国会 写真はいい思い出になります 対策 一緒に対策を考えましょう 段階 生まれる 島の人口は年は年々増加しています 塩、こしょうを加えてください この携帯電話が使えるのは国内だけです ガソリンの価格がどんどん上がっている 留学してから私の世界が広がった 目的 事実 ゴミ箱にペットボトルがあります 何で学校に行くのですか 誰もいません お釣りをください あなたは小西さんに映画のチケットをもらいましたよね どうして今日遅刻した 私は日本語はあまりできません みんなは運動会の予定がわかります のち 母は日本料理ができます 中学生 翻訳する 炊飯器 隣人 フクロウが頭を上下に動かしている 医者は、患者の脈をとっている この携帯電話が使えるのは国内だけです 留学してから私の世界が広がった 2019-12-30彼は足が長い 遅い 近い 駅の近くで食事をした 家 私は朝シャワーを浴びます 彼の腕は太い 広い でる 軽い 他に方法がありません これは医者のためのサイトです 火曜日 お腹が空きました 昨日 かける 休む お腹 工場 強調 計画を一部変更しましょう ここは静かな住宅地だ 建設 資金 彼は小さな会社に勤めています 多く 電気がついたままですよ 意見 明らか 引越しを業者に頼んだ 私達は今結婚資金を貯めています 石原さんは彼に防虫スプレーをもらいました 役所の人はおばあちゃんに綺麗なカレンダーをくれました 私は朝シャワーを浴びます 学食の料理はまずいです。このレストランの料理もまずいです あの服のほうが可愛いです コンビニに電子レンジがあります 雑誌は辞書ほど厚くありません 中村さんは昨日夜十時まで仕事しましたので、残業代が沢山もらえるでしょう 犬は大きくありませんでした 国内旅行 建設 博物館 文房具 親戚 病院に入る ナイフ 妹 サイ 2019-12-29髪 姉 全部 赤いバラを買いました 次 美しい 生きる 目 彼女は眠いよです 夜 弟 晴れる 太い 私はパンよりご飯が好きだ その仕事は危険を伴う 計算 事故 いずれ この本を内容説明してください 変化 そのデモについて政府は何のしなかった 残る 増加 初めに、会長が挨拶した 姿 示す 商品 運動会は9時開始です 社長 毎年多くの人が海外へ旅行する まず相手の動きを見ましょう 彼女はマイカーを買いたがります 私は先生と職員室に行きました ペットを飼いましょう 飲み物を買いませんでした 雑誌は辞書ほと厚くありません 鉛筆は短くありません 飛行機が二時間遅れました。なので、到着時間も遅くなります 授業をした教師 小テストと中間テストと期末テスト、どれが難しいですか あの服のほうが可愛いです 簡単の質問 日本語が上手になる 私の苦手なことは料理を作ることです あそれはカーテンです 彼女を幸せにする 小林さんは中国語を話すことができます 一眼レフカメラ ゴミ箱 餌 広告 博物館 故郷 浅い 葉が落ちます かっこいい 茶髪 私は物理の基礎はしています あの服のほうが可愛ですか 博物館 2019-12-28建てる 電車 親の愛は有り難い 教える 駅の近くで食事をした 彼は数学を教えています そう 赤いバラを買いました 起こす 五月五日は祝日です 十日後に帰ります そこには私一人しかいなかった 八日からイギリスに行きます 辺 私たちはビデオゲームをした 触る 喋る 彼はこの辺に住んでいます 冷たい飲み物ください 細い ちゃんとドアを閉めてよ 二社は互い競争している もう やる ガソリンの価格がどんどん上がっている 今後どもよろしくお願いします 現在 情報 システムの構成を変えてみました 私は世界一周をしたくありません 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう 飛行機は二時間遅れました。なので、到着時間も遅くなります 私は納豆が全然好きではありません お客さんは家に来ました テレビをつけません 私は冬が嫌いです 水が熱くなる 暖かい手 上野さんは彼女と映画を見ました 旅行はいつですか 明日か明後日です 何も食べません 鳥 皿 カレーライス 来週 フライドチキン ㎝ 調味料 腹部は、肋とお尻の間の部分です フクロウが頭を上下に動かしている 私は物理の基礎は知っています かっこいい男 私は物理の基礎は知っています 2019-12-27置く 払う 帰国することに決めました かた そう 彼に手紙を書きました 授業 彼は荷物を網棚にあげた 今年 どうして泣いているの 私はパンよりご飯が好きだ 店員は若い女の人でした 辺 喉が乾きました 時の経つのは早い これは重要な書類です うちは五人家族です 重要 参加 なお、雨の場合は中止です 交差点で事故が発生した 全体の80%が完成しました 文章 交渉 ころ 彼は新製品に興味を示している 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう そう クラスを静かにする 向日葵は草より綺麗です 日本語が上手になる 辺 あれはジュースです 昨日、どこに行きましたか。昨日、コンサートに行きました ソファで寝ます 飲み物を買う 弟は父の性格がわかります 学校の先生は数学ができます 私は味噌汁が全然嫌いではありません 水が熱くなる なんでこんな時間に学校にいないのですか 石原さんは彼に防虫スプレーをもらいました あのバカは二本の鉛筆を箸にして、ご飯を食べる 苺 ハンバーガー 楓 冷蔵庫 布団 虎 蜘蛛 梅 ず 中村さんは昨日夜十時まで仕事しましたから、残業代がたくさんもらえるでしょう 2019-12-26明日、六時に起こしてください 安い 次はいつ会いましょうか 起きる 今朝は早く家を出ました 消す 彼はかなり英語が上手です 軽い 日 二十日 彼女は三人の子供の母親だ 違う お店はもう閉まっていました お母さんによろしくを伝えください 時 お腹が空きました ちゃんとドアを閉めてよ 宿題は自分でやりなさい 予約は要りません 曇る 上る 私はパンよりご飯が好きだ 後ろを向いて 絵に触らないでください 私は昼のドラマを毎日見ます 九日に荷物が届きます 政権 その仕事が危険を伴う 調べる ガソリンの価格がどんどん上がっている 加える 企業 まず相手の動きを見ましょう それはどういう意味ですか システムの構成を変えてみました 増える 今日の新聞どこに置いた 治る この服は三百ドルしました 彼は行政を改革したいと思っている 引っ越しを業者に頼んだ 私はパンよりご飯が好きだ 示す 一部 備える 信号が青に変わるました 川の岸に桜の木があります 小林さんの妻は小林さんに愛妻弁当をあげました 先生は私に100点をくれました 私の嫌いなことはバスケットをすることです ゴミ箱にペットボトルがあります それは正方形です 宮沢さんは課長のことをどう思いますか 狭い部屋 あの喫茶店は静かなので、あそこで勉強する人が多いでしょう あの屋敷に幽霊がいますよう 私はあの記憶を忘れたいです どうして今日遅刻した 私は納豆が全然好きではありません テストはいつですか 社員食堂 魔法瓶 生徒 校長 着物 フクロウが頭を上下に動かしている 2019-12-25また会いましょう 歌う 低い 楽しむ 兄は水泳が得意です 親の愛は有り難い 起こす 今週 お腹が空きました 火曜日 三つ 六日前に日本に帰っていました 彼は時々遅刻します 腰 昨日、あなたのお姉さんに会ったよ 酸っぱい 彼はシートベルト締めた 多分 辛い 生活 導入 彼女の大きな帽子はとても目立つ 首相 まず相手の動きを見ましょう ガソリンの価格がどんどん上がっている そのデモについて政府は何もしなかった 住宅 システムの構成を変えてみました 必要 株 より 方向 生産 それは最近話題の本ですね 私たちは二階に上がった その仕事は危険を伴う 社長は部長と出かけました 私はバスで学校に行きます 石原さんは彼に防虫スプレーをもらいました どうして大体のお店は試食を置きますか お腹が空きました 私は世界一周をしてくありません ニュースで道の状況がわかります 綺麗な公園 どうして台湾の会社は大学生を雇いたくないのですか 小林さんは中国語が話すことができます どうしてキリンは首が長いですか 飛行機が二時間遅れました。なので、到着時間も遅くなりました まず相手の動きを見ましょう ガソリンの価格がどんどん上がっている ピザを買いました、パスタも買いました ベッドの下にゴキブリがいます システムの構成を変えてみました 今夜は蒸し暑いので、蚊が多くなりました 解答 乗客 翻訳する フクロウが頭を上下に動かしている その仕事は危険を伴う ぶ ぬ 2019-12-24もっと近くに来てください 起こす 彼の腕は太い 聞く 軽い 一つ 乾く 夏 息子は六つになりました 予約入りません あそこ 四月に大学に入学しました お腹 上を向いて お名前をカタカナで書いてください 書き直す 何が飲み物が欲しいな 消える 構造 もう 現在 比べる 従来 結果 そのデモについて政府は何もしなかった 治る 開発 一般の方はこちらの席へどうぞ なお、雨の場合は中止です 国は国語教育を強化しています プログラム 部長除く全員が土曜日も働いた あの屋敷に幽霊がいますよう 小林さんは中国語を話すことができます 石原さんは彼に防虫スプレーをもらいました 向日葵は草より綺麗です 私の嫌いなことはバスケットをすることです 何曜日が暇ですか 上野さんは彼女と映画を見ました 飛行機が二時間遅れました。なので、到着時間も遅くなります 氷山が小さくなる 弟は父の性格がわかります 夜市が賑やかです 今夜は蒸し暑いですから、明日は雨が降るでしょう 私は世界一周をしたくありません 私は先生と職員室に行きました 彼は中国語と英語ができます スーツケースに詰める 小林さんは中国語を話すことができます 石原さんは彼に防虫スプレーをもらいました 飛行機が二時間遅れました。なので、到着時間も遅くなりました 私は世界一周をしたくありません 2019-12-23浴びる 郵便局で切手を買いました 親の愛は有り難い 少し疲れました 遠い 起こす 四月に大学に入学しました 夏休みももう終わりだ 彼は昼過ぎにきます 天気 火曜日 柿の木に実がたくさんなっています 五月五日は祝日です 起きる 起きる 来る 腰 そばにいて下さい 奇麗 時計を見たらちょうど三時だった 起こす 治る 一緒に対策を考えましょう 毎年多くの人が海外へ旅行する その問題に関する記事を読みました 販売 自由 今夜は大いに語りましょう それは最近話題の本ですね 彼は非常に高い技術を持っている 現在 重要 全体の80%が完成しました お相撲さんはみんな力持ちだ ほとんど もう なお、雨の場合は中止です 政権が交代した 力 どうして今日遅刻した 私はおばあちゃんのことが好きです 床に蟻がいます あの人は木を登ることができます 私は風邪をひきました。だから、学校に行きたくありません 治る 弟は父の性格がわかります 私はもっと頑張りたかったです 彼は小学校の先生ですから、子供の親からのプレッシャーが多いでしょう 台北駅はどこですか 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 現在 今夜は蒸し暑いから、明日は雨が降るでしょう 私の友達は野球とサッカーができます 授業をしている教師 もう 私の得意なことはギターを弾くことです なお、雨の場合は中止です どこが賑やかですか 宮沢さんは課長のことを、どう思いますか 私は紙粘土でドラゴンを作ります 上野さんは彼女と映画を見ました ゴミ箱にペットボトルがあります 向日葵は草より綺麗です レシートください 私は苦手なことは料理を作ることです 弟は父の性格がわかります 和食と言えば寿司や味噌汁や天ぷらなどです 上野さんは彼女と映画を見ました 向日葵は草より綺麗です 期末テスト オフィス 質問する 女性がモモの太さが計っている づ 2019-12-22大学に行って、もっと勉強したいです 重い 親の愛は有り難い 知る 負ける 肩 使う 火曜日 大人 彼女は眠いようです ちゃんとドアを閉めてよ 八日後に帰ります 口 時の経つのは早い まあ今回は許してあげよう 電話 体重がかなり減りました 増える 特徴 私は四つの会社に投資しています 全体の80パーセントが完成しました 住宅 関する 彼が来た目的がわかりません 改革 そのデモについて政府は何もしなかった この段階では決断するのはまだ早い それは最近話題の本ですね ガソリンの価格がどんどん上がっている 宮沢さんは課長のことを、どう思いますか 中村さんは昨日夜十時まで仕事をしましたから、今日は来ませんよね 親の愛は有り難い 飛行機が二時間遅れました。だから、それで起こっている人が多いでしょう 火曜日 ご飯を食べましょう 授業をしている教師 私は討論を始めたいです 新しいソフトを買いました。なので、バイト代が全部なくなりました 私は納豆が全然好きではありません 何も買いません どうして今日は遅刻した ゴミ箱にペットボトルがあります 全体の80%が完成しました 庭の松が高くありません お客さんは家に来ました 私は先生と職員室に行きました てん 体育館 浅い これはなんですか ロッキングチェア 動詞 布 だれ 宮沢さんは課長のことを、どう思いますか ゴミ箱にペットボトルがあります 2019-12-21どう 兄は水泳が得意です 一緒に帰りましょう 今朝は早く家を出ました 持つ 私の夫はサラリーマンです 親 言う 男の人は私たちに話しかけた 多分 美味しい 違う 近所で盗難事件が起こりました め これは医者のためのサイトです 弟 強い 愛する 掛ける 昨日、あなたのお姉さんに会ったよう これはかなり金がかかった 時 可能 それは最近話題の本ですね 目的 実現 そのデモについて政府は何もしなかった 建設 事実 増える ガソリンの価格がどんどん上がっている 語る ドル どうして今日遅刻した 引き出しにハムスターが一匹います 私は納豆が全然好きではありません 大学の先輩は商売ができます ペットを飼いましょう 私は日本語はできます なぜ大体のお店は試食を置きますか 彼女はボーリングができます 私は先生と職員室に行きました 私は親友と遊びたいです 授業をする教師 浅い川 ゴキビリ ポスター それは最近話題の本ですね 水曜日 涼しい 田舎 そのデモについて政府は何もしなかった 卵 増える ガソリンの価格がどんどん上がっている どうして今日遅刻した 私は納豆が全然好きではありません 予備校生 雄鶏 帰る 走る 切る サイ 私は先生と職員室に行きました 増える 2019-12-20帰る この言葉の意味がわかりません 待つ 乗る どこ 日曜日は海に行きました こっち 妹 夏 九日に荷物が届きます 六日前に日本に帰ってきました 教科書を閉じてください お腹 朝九時からミーテイングが始まった 休む 道 千円貸してください 昨日、あなたのお姉さんにあったよ 会社 毎年多くの人が海外へ旅行する 決定 十分 帰ったら、まず手を洗いましょう 音楽は彼の得意な分野です これから、より一緒努力します 処理 報告 今日の新聞、どこに置いた ほぼ 特徴 テレビをつける 教室に学生と先生がいます 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう 私はあなたにデジタルカメラをもらいました なぜ大体のお店は試食を置きますか ご飯を食べる人 なんで台湾の会社は大学生を雇いたく無いのですか 夜市はスーパーよりうるさいです 私は先生と職員室に行きました 私は苦手なことはバスケットをすることです 昨日、どこかに行きましたか いいえ、どこも行きませんでした 昨日、あなたのお姉さんに会ったよ ペットを飼いましょう 自転車とバイクと車、どれが便利ですか 教室は静かではありません 夜市はどこですか 私は日本語が大体できます 陽傘 餌 栓抜き 調味料 ㎝ ロブスターが岩の上にいる なぜ大体のお店は試食を置きますか 私は先生と職員室に行きました 2019-12-19飛行機 カナダの冬はとても寒いです おかげさまで元気です わかる その次の週は空いていますか 息子 ちゃんとドアを閉めてよ 何 この紙を半分に切ってください 大丈夫ですか お腹 時 今日は妻の誕生日だ 五月五日は祝日です 無い 毎年多くの人が海外へ旅行する 今後 方法 研究 私はよく図書館を利用します のち 商品 強調 私は日本語がまあまあできます 私は部長のことが嫌いです なぜ台湾の会社は大学生を雇いたく無いのですか レシートをくださ お客さんは家に来ました 飛行機は二時間遅れました。だから、それで怒って人が多いでしょう 私は中国語と英語がわかります あの喫茶店は静かですから、あそこでテストを勉強しましょう 私の嫌いなことはバスケットすることです 今日、何か買いますか いいえ、何も買いません 私はノートパスコンをテレビにする 私の苦手なことは料理を作ることです 緑茶 圖 おばあさん 夕食 描く 嫌い ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろう 毎年多くの人が海外へ旅行する 栓抜きありますか 虹 カニが浜辺を歩いている 私の嫌いなことはバスケットをすることです 2019-12-18色 のち 彼女の髪はとても長い 負ける 笑う 私たちのチームはその試合で負けた 質問 兄は水泳が得意です 乗る 小さい花が咲いています ちゃんとドアを閉めてよ 違う お母さんによろしくを伝えください 時 動く 五日 閉まる お腹 お手洗い 多分 ただ 解決 管理 彼は就職試験を受けた 必要 計画 ほぼ 島の人口は年々増加しています 今日はこれらの問題について話し合います 中心 政権が交代した これはイタリアから輸入した服です 関係 私は風邪をひきました。なので、映画館に行きませんでした 私の趣味は映画を見ることです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 正方形はどれですか ちゃんとドアを閉めてよ あなたのカバンはこれです 私はアメリカに行きました 何で学校に行くのですか 時 えっと、電車が遅れたので、遅刻しました どうして麒麟は首が長いですか 浅い川 私の趣味は料理を作ることです どこも行きません お客さんは家に来ました お腹 年齢 デジタルカメラ 腹部 こ う お客さんは家行きました 2019-12-17兄は水泳が得意です 日記 会議は四時に終わります 去年 皆 言葉 今朝は早く家を出ました 彼女 肩 六日前に日本に帰ってきました 金 五月五日は祝日です 上 十日後に帰ります このコートはとても暖かい 直る 多分 喋る お父さん 側 土地 計算 昨日の会議について報告があります 二者は互いに競争している 兄は水泳が得意です 可能 会議で重要な決定がありました 経営 開始 今回 これは重要な書類です 採用 検討 事実 より 対する 命令 計画を一部変更しましょう 問題 工場 目的 続ける 選挙 業者 問題が一つあります 私は世界一周をしたくありませんでした 夜市はどこですか 私は苦手なことは料理を作ることです あなたのカバンはこれです 私は果然をひきました。だから、明日学校に行きたくありません 私は冬が嫌いです お元気な子供 私は日本語ができます バカ！言い訳するな ペットを飼いましょうよ 和食 広告 楓 てん 机 調味料 多分 栓抜きありますか 2019-12-16直ぐ 彼は足が長い 消す 家に帰ろ いつ 鳥が飛んでいます いつも 彼の気持ちが分からない 私たちは大きな声で歌いました 引く 出来る 毎日駅まで自転車で行きます 入れす 今朝は早く家をてました 親の愛は有り難い 書く 起きる 勝つ 重い 六日前に日本に帰ってきました 辛い 細い 曜日 掛ける 今日はいい天気ですね 来月の一日は空いていますか 違う よう どうして 九日 彼は時々遅刻します くらわ 六日前に日本に帰ってきました 鼻 その子は指で十数えました 風邪 この道をまっすぐ行くと駅です 五月五日は祝日です 嫌い 閉まる クーラーはまだ治りません お店はもう閉まっていました 彼女は眠いようです 目 手紙が届くのに三日かかりました 柿の木に身がたくさんなっています 夏休みももう終わりだ 8 どうして泣いているの 曜日を間違えました 開ける 米 予約入りません 泊まる 五月五日は祝日です これは医者のためのサイトです 合格者が発表された 犬に餌をやった 生活 一緒に対策を考えましょう 彼は行政を改革したいと思っている そのデモについて政府は何もしなかった ほとんど 国会 お金がほとんどありません 電話 交差点で事故が発生した 評価 事務的な処理に1週間かかります 彼は事故で怪我をしました 対する やる それはどういう意味ですか 来年から新しい制度が始まります 電気がついたままですよ いずれ 方針 会談 予定 写真はいい思い出になります 作業 構造 昨日 伴う 集める お金はまだ十分あります 社会 よく答えがわかりましたね 事実 今日はこれらの問題について話し合います 変化 今日の新聞どこに置いた 状態 目的 彼は選挙に出るつもりだ 事実 中心 今日中にこの問題を検討してください 彼は食品工場で働いています 島の人口は年々増加しています ロボット 明らか 影響 私は自分の力で仕事を探します 大学の先輩は商売ができます 先生はテストの答えがわかります おおき 大学の先生は数学ができます 目的 部屋を綺麗にする 私の趣味は本を読むことです バカ！言い訳するな 飲み物を買いませんでした ご飯を食べている人 なぜ台湾の会社は大学生を雇いたく何のですか 授業をする教師 目的 私の趣味は野球をすることです 佐々木さんはサラリーマンです 私は懐石料理が一番好きです 明日の食券をください ゲームをしません 本棚に小説と雑誌があります 教師の隣に父と母がいます 彼は会長でした 綺麗な公園 コンビニに電子レンジがあります 新しいゲームソフトを買いました。なので、バイト代が全部ななくなりました 私は日本語ができます 昨日、何処かに行きますか はい、コンサートに行きました えっと電車が遅れましたから遅刻しました どうして台湾の会社か大学生を雇いなくないのですか どれが綺麗ですか 彼は会長ではありませんでした テストはいつですか 明日と明後日と来週ですね 私の苦手なことは料理を作ることです あの屋敷に幽霊がいますよう ご飯を食べる人 父は台湾料理を作ることができます あの喫茶店は静かなので、あそこに勉強する人が多いでしょう 机の上に雑誌があります なんで台湾の会社は大学生を雇いたくないのですか ペットをかいましょうよ 彼は小学校の先生ですから、子供の親のプレッシャーが多いでしょう 冷蔵庫 水曜日 大きな竜巻 香水 親戚 社員食堂 私の苦手なことは料理を作ることです 17 隣人 動詞 下手 ビジネスマン 液晶テレビ 学長 キャベツ 屋上 レタス 買い物カートはからです 鳴いている雄鶏 ペットを飼いましょうよう 蝉 葉が落ちます 顎髭 サイ 男性は、顎髭がたくさん生えているが、頭の毛が少ないです スーツケース フクロウ 2019-12-13テストで良い点を取った 次はいつ会いましょうか 春 見える 彼は時々遅刻します 違う 来月の一日は空いていますか 十日後に帰ります これは医者のためのサイトです 酸っぱい 土曜日の夜はクラブに行きます 私が手伝いましょう 窓を開けてください 髪 ほぼ 相手 塩、胡椒加えてください 比べる 従来 株 試合の相手は誰ですか 宇宙人は存在すると思いますか 彼は非常に高い技術を持っている 生産 そのデモについて、政府は何もしなかった 存在 私はあの人のことが嫌いです 私は部長のことが嫌いです 私は懐石料理が非常に好きです うそ 弟は父の性格がわかります なんでこんな時間に学校にいないのですか 昨日、どこに行きましまたか コンサートに行きました どこが賑やかですか 庭に松があります 違う 鈴木さんは大学生です。私も大学生です なぜ台湾の会社は大学生を雇いたくないのですか ニュースで道の状況がわかります 楽しい一日 動物園にライオンがいます 私は弟と妹実家に帰りました 布 ストップウオッチ 金曜日 オレンジ 御犬 化粧品 梅 水曜日 調味料 雨の後、虹が見られるかもしれません 教授が図を説明する 2019-12-12兄 緑 私 旅行の日程を変えました 顔 宿題はまだ終わっていません 軽い テーブル 治る 明日昼頃から曇るでしょう これは医者のためのサイトです 近く 十日後に帰ります 手紙が届くのに三日かかりました 彼には子供が六人います 大丈夫ですか お名前をカタカナで書いてください 閉める 来年一緒に旅行しましょう 近所で盗難事件が起きました 答える 黄色い 休む 工場 会長 島の人口は年々増加しています 目立つ 分野 写真 方向 文章 のち 消える 電気がついたままですよ 新聞 そのについて政府は何もしなかった ほぼ 二社は互い競争している 代表 これは医者のためのサイトです 家から学校まで 運動場で走ります 十日後に帰ります 母はペットと海外旅行をしました 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 日本語を上手にする 授業をする教師 私は彼に使い捨ての箸をあげました そのデモについて政府は何もしなかった どうして台湾の会社は大学生を雇いたくないのですか 簡単な質問 電車は自転車より速いです 今夜は蒸し暑いですから、明日は雨が降るでしょう 大学の先輩は商売ができます 彼女はあの野良犬をペットにする 机の上に2本のペンがあります 飛行機が二時間遅れました。だたら、それで怒っている人が多いでしょう 犬は大きくありません 原稿改訂する 数字の17 昨日 鶏 水曜日 苺 雑誌 餌 乗客 中学生 クロサイが草原を歩いている ロブスターが岩の上にいる 水曜日 2019-12-11重い 車 帰る 肉と魚とどちらが好きですか する 約束を忘れないでください 立つ 肩 国 読む 覚える 彼女は眠いようです 八日からイギリスに行きます お母さんによろしくを伝えください どうして泣いているの 今日は頭が痛いです 目 教科書を閉じてください 時計を見たら、ちょうど三時だった ただ 評価 建設 今日の新聞どこに置いた 対策 選挙 前売券ハマド口で販売しています 構造 種類 これは世界最大の船です 企業 トラブルがやっど解決した 強化 部長除く全員が土曜日も働いた 問題が一つあります お相撲さんはみんな力もつだ 彼は小学校の先生ですから、子供の親のプレッシャーが多いでしょう あの屋敷に幽霊がいますよ あの喫茶店は静かなので、そこで勉強する人が多いでしょう 私はアメリカに行きました 大学の先輩が商売ができます 庭に松があります 授業をする教師 年齢 私はもっと頑張りたいです 自転車は電車ほぼ早くありません 新しいゲームソフトを買いました。なので、バイト代が全部をなくなりました なぜ大体のお店は試食を置きますか 大学の先輩は商売ができます 授業をする教師 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 引き出しにハムスターが一匹います いつが暇ですか 私はあなたにデジタルカメラをもらいました 使い捨て 記憶 楓 社員食堂 おやつ 数字の17 動詞 夜市 どれ 2019-12-10また会いましょう どつら 私もそう思います 重い 親の愛は有り難い 彼は毎晩3キロ走っています 彼は昼過ぎに来ます め 夏休みももう終わりだ 大人 腰 彼は私の方を見ました 彼女に黄色いバラを買いました この部屋は寒いです 掛ける 財布は机の下にあった 二社は互いに競争している 商品 今日の新聞どこに置いた 選ぶ 種類 特徴 報告 命令 もつ 提供 ほとんど 党 私は懐石料理がとても好きです なんで台湾の会社は学生を雇いたくないのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 病人が元気になる 彼は学校の先生ですから、子供の親のプレッシャーが多いでしょう 寝ぬ猫 夜市が賑やかです 重い なんで今日私の家に来ましたか 私のカバンはどれですか め 私は茶碗蒸しがあまり嫌いではありません 自転車とバークと車、どれが便利ですか 私は紙粘土でドラゴンを作りました 一眼レフカメラ 課長 親戚 高層ビル 雄鶏 ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろ 今日の新聞どこに置いた 彼は学校の先生ですから、子供の親のプレッシャーが多いでしょう 2019-12-9病気 親の愛は有難い おかげさまで元気です 質問のある方はどうぞ 彼はシートベルト締めた 五日 晴れる 夕食には何を食べたいですか 触る 今の首相はあまり力がない 行う ここが建物の中心です 島の人口は年々増加しています 段階 強調 のち 宇宙人は存在すると思いますか 私は四つの会社に投資しています これは重要な書類です 信号が青に変わりました 二者は互いに競争しています 隣の人は私の猫に餌をくれました まず、次に、そして、それから、最後に ハンバーガーとコーラ 宮沢さんは課長のことを、どう思いますか どうして台湾の会社は大学生を雇いたくないのですか 親の愛は有り難い あの喫茶店は静かなので、そこで勉強することが多いでしょう 掛ける 新しいゲームソフトを買いました。だから、古いソフトを売りました 引き出しにハムスターが一匹います 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう あの屋敷に幽霊がいますよう ドアを開けませんでした 私は彼女のことが好きです 期末レポート 動詞 空港 バイク 説明する アリクイ 茶髪 サイ 二社は互いに競争してういます どうして台湾の会社は大学生を雇いたくないのですか 2019-12-8授業 電車で子供が騒いでいた 生きる しる 戻る その次の週は空いていますか 止める 暑い 上る 後ろを向いて 細い 場合 どうして泣いているの 冷たい飲み物をください 近所で盗難事件が起きました つける 方向 輸入 内容 やる 立場 一緒に対策を考えましょう 強調 その計算は間違っている 原因 最近、彼の評価が上がった 最大 島の人口は年々増加しています まま 会談お内容が発表されました 私はゲームが好きです 私はもっと頑張りたかったです 彼女を幸せにする 飛行機が二時間遅れました。なので、到着時間も遅くなります なんで今日私の家に来ましたか 台北駅はあそこです あの喫茶店は静かなので、あそこで勉強する人が多いでしょう ドアを開けません そっか、今度早くいえをでろ 何で学校に行くのですか 私の好きなことは音楽です あの屋敷に幽霊いますよう 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう えっと、電車が遅れましたから遅刻しました コンビニに電子レンジがあります 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう 島の人口は年々増加しています 冷蔵庫 楓 パスタ 動詞 社員食堂 フットボール 18年前 ロブスターが岩の上にいる 調味料 あの喫茶店は静かなので、あそこで勉強する人が多いでしょう あの屋敷に幽霊がいますよ 飛行機が二時間遅れました。だから、それで起こっている人がおおいでしょう 動詞 2019-12-7彼はタオルで顔を拭きました 冬 新しい 郵便局で切手を買いました 思う 息子 探す 彼女は眠いようです お母さんによろしくを伝えください 酸っぱい どうして泣いているの 予約は要りません 夏休みももう終わりだ 一杯 晩 辛い 計画を一部変更しましょう 設計 必要 ほぼ 姿 病院 それはどういう意味ですか 処理 構造 変わる 電気がついたままですよう ほとんど 国は国語教育を強化しています 強調 実現 彼は中国語と英語ができます テーブルと椅子 弟は父の性格がわかります 今夜は蒸し暑いので、蚊が多くなりました テレビをつけませんでした 彼女はボウリングができます 私は味噌汁が全然嫌いではありません 暇は何曜日ですか あなたにデジタルカメラをもらいました 国仲さんはあなたにギターをもらいましたよ 私は懐石料理がとても好きです ゲームをしましょう どうして泣いているの 兎 部屋 社員食堂 ドア 隣人 皿 ロブスターが岩の上にいる ざ 社員食堂 ロブスターが岩の上にいる 2019-12-6弱い 鳥が飛んでいます うちに遊びに来てください 出る 変える 早く 取る この服はとても安かった かた 見つける 膝に痛みを感じます 漢字は中国から来ました 息子は六つになりました お母さんによろしくを伝えください 私は腕時計を4つ持っています 千円貸してください 近所で盗難事件が起きました 休む 夏休みももう終わりた 彼女は眠いようです 強い 彼がクラスの代表だ 彼は新製品に興味を示している 株 私にはたくさんのお金が必要だ お母さんによろしくを伝えください 昨年 お相撲さんはみんな力持ちだ 運動会は9時開始です 示す 構成 部分 自由 普及 交差点で事故が発生した 交渉 おリーグをください 私のノートはどれですか 夏休みももう終わりだ 佐々木さんはサラリーマンです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 彼女は眠いようです 自転車とバイクと車、どれが便利ですか ニュースで道の状況がわかります 明日の食券をください 私の趣味は料理を作ることです 刺身をください 今夜は蒸し暑いですから、明日は雨が降るでしょう おばあちゃんのことが好きです どうして台湾の会社は大学生を雇いたくないのですか なんぜこんな時間に学校にいないのですか 何も買いません 和食と言えば、寿司屋味噌汁や天婦羅などです 私の妹に飴をくれましたね、ありがとう バカ！ 言い訳するな 広告 楓 竹 賑やか 文房具 暖かい 海 サイ 2019-12-5頭 あげる 午前 昨日タイカレーを食べました そこに座ってください 彼は時々遅刻します 近所で盗難事件を起こりました 小さい花が咲いています どうして わからない場合は私に聞いてください 宿題は自分でやりなさい こっち 冷たい システムの構成を変えてみました 彼は就職試験を受けた ほとんど これら 中心 いずれ 変化 発生 対立 以上 対象 やる 彼女の大きな帽子はとても目立つ 全国 住宅 まず 私は懐石料理がかなり好きです 何を食べますか 定食やうどんやラーメンなどですね 私は風邪をひきました。なので、映画館に行きませんでした コンビニに電子レンジがあります 近所で盗難事件が起こりました えっと、電車が遅れましたので、遅刻しました 先生は討論を始めたがります 何で学校に行くのですか 私の好きなことは音楽を聴くことです 今日、何か買いますか いいえ、何も買いません 自転車とバイクと車、どれが便利ですか 中村さんは昨日夜十時まで仕事しましたので、残業代が沢山もらえるでしょう 新しいゲームソフトをあげました。だから、古いソフトを売りました 辞書 楓 便利 えさ かっこいい男 サイ 調味料 ほ 自転車とバイクと車、どれが便利ですか 楓 サイ 2019-12-4遊ぶ 次はいつ会いましょうか 彼はまだ若いです 肩が凝りました 学校は八時半に始まります 一つ 広い 少ない あなたのお兄さんは何歳 細い 悪い これはかなり金がかかった 閉める 喉が乾きました 五日 答えが違います 違う 教科書を閉じてください 服 彼に会えて嬉しかった お名前をカタカナで書いてください 百 外国 代表 報告 重要 お相撲さんはみんな力を持つだ 彼は非常に高い技術を持っている 競争 この この曲線がこの車の特徴です やる 比べる 計算 話 一緒に対策を考えましょう 留学してから、私の世界が広がった 帰ったら、まず手を洗いましょう 姿 消える 従来 国会 彼は就職試験を受けた 生産 構造 政権が交代した 今夜は大いに語りましょう 今後の方針が決まった 発生 ほとんど 商品 地域 完成 彼は選挙に出るつもりだ 増える 会談 そっか、今度早く家を出ろ どこが賑やかですか 私はあなたにデジタルカメラをもらいましょた やる 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 上手なコック コンビニに電子レンジがあります 先生は難しい本を読むことができます 私の嫌いなことは部屋を掃除することです あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 何で学校に行くのですか 私はあの人のことが嫌いです 氷山が小さくなる あなたは教師です なんでこんな時間に学校にいないのですか 陽傘 苺 烏龍茶 調味料 ほとんど 葉が落ちます フクロウ ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろう 蟹が浜辺を歩いている コンビニに電子レンジがあります 調味料 2019-12-3軽い 言葉 彼は足が長い 時計を見たらちょうど三時だった 口 ある 細い 汚い 彼女は3人の子供の母親だ 酸っぱい お願い ほぼ ここは一方通行です 関する お相撲さんはみんな力持ちだ 今、値段を交渉しています 計画 細い お相撲さんはみんな力持ちだ 一緒に対策を考えましょう 彼は選挙にですつもりだ 構造 その問題に関する記事を読みました 状態 仕事がほぼ終わりました 自由 建設 政権 彼は行政を改革したいと思っている このプリンターは従来のものより速い これは重要な書類です 株 なんでこんな時間に学校にいないのですか 犬と猫、どちらが好きですか 私は親友と遊びたいです どこも行きません 動物園のパンダは小さいです どれも要りません 彼は中国語と英語ができます 飛行機が二時間遅れました。なので、到着時間も遅くなります 一緒に対策を考えましょう 構造 川の岸に桜の木があります 私はあなたにデジタルカメラをもらいました 何で学校に行くのですか 宮沢さんは課長のことを、どう思いますか 私は学業を続けたいです ご飯を食べた人 私は日本語が大体できます 私の好きなことは音楽を聴くことです あなたの会社は私の会社に統計ソフトウエアをくれました 私のカバンはどれですか おやつ 原稿改訂する 冷蔵庫 親戚 栓抜き フルート め 私はあなたにデジタルカメラをもらいました 何で学校に行くのですか 私はあなたにデジタルカメラをもらいました 2019-12-2消す かた どれ 飛行機 私たちのチームはその試合で負けた 次 休む 五つ お願い 辛い 見つかる 違い 暖かい 時の経つのは早い 愛する 採用 決定 与える 電気がついたままですよう 株 まあ今回は許してあげよう なお 利用 会談 制度 部長を除く全員が土曜日の働いた 構成 受ける 事件 生まれす 文章 対する 行う 特徴 今夜は大いに語りましょう なんでこんな時間に学校にいないのですか 明日の食券がください 今日、何か買いますか はい、オレンジを買います 株 机の上に雑誌があります 今夜は蒸し暑いですから、明日は雨が降るでしょう 私の趣味は本を読むことです 期末レポートは中間レポートほど大変ではありません 台北駅はどこですか テレビをつけません 図書館はスーパーより静かです 大きくなかった 弟は父の性格がわかります 昨日、何処かに行きましたか はい、コンサートに行きました 私は彼女のことが好きです 木曜日 プール 隣人 梅 タンス なんでこんな時間に学校にいないのですか 2019-12-1理事長 餌 果物 兎 冷蔵庫 呼ぶ 直ぐ また会いましょう 彼に手紙を書きました いつも 肉と魚とどちらが好きですか たっかたです 何も食べますか 定食やうどんやラーメンなどですね 深い湖 あの子供は親友と遊びたがります 私はもっと頑張りたかったです これをください 明日の食券をください かた 部長は仕事ができます 私は刺身があまり好きではありません 宮沢さんは課長のことを、どう思いますか 今日は何曜日ですか 今夜は蒸し暑いから、明日は雨が降るでしょう どうして今日遅刻しましたか ばか！言い訳するな 私は風邪をひきました。だから、明日は学校にいきたくありません あの歌手は有名です 熱い 彼は神を信じている 来る 五日 酸っぱい 口 私は夏が大好き 休む 企業 開く どる それはどういう意味ですか 増える 処理 解決 価格 コーヒーをもう一杯ください 先ず 我が社の経営はうまくいっています 彼女は同じ間違いを繰り返した 加える 商品 ツアーガイドはあなたの旅行を楽しくする興味深い情報知っているだろう 虹 今夜は蒸し暑いですから、明日は雨が降るでしょう 明日の食券をください どうして麒麟の首は長いですか","link":"/zh-tw/japanese/2019/December/index.html"},{"title":"August 2019","text":"2019/8/31the result of my target yesterday Task: Working on logParsing and inserting project Still working on it Working on Stackdriver course 2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on Stackdriver Logging - Using BigQuery and Stackdriver to Analyze BigQuery Usage Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Linux English Japanese 2019/8/30the result of my target yesterday Task: Working on logParsing and inserting project Still working on it Working on Stackdriver course 2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing and inserting project Working on Stackdriver course 2 Linux English Japanese 2019/8/29the result of my target yesterday Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing and inserting project Working on Stackdriver course 2 Linux English Japanese 2019/8/28the result of my target yesterday Task: Finish Netdata Still working on it Finish Stackdriver course 1 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese 2019/8/27the result of my target yesterday Task: Finish Netdata Still working on it Finish Stackdriver course 1 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese 2019/8/26the result of my target yesterday Task: Start a new Quest on QwikLab Finish Cloud FUnction document Not yet, do Stackdriver first. Finish Node course episode 2 Not yet, haven’t finished Stackdriver Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish Netdata Finish Stackdriver course 1 Linux English Japanese 2019/8/25the result of my target yesterday Task: Finish QwikLab Baseline: Infrastructure Finish The Wondering presentation next week Post at least an article of QwikLab Improve my resume Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Start a new Quest on QwikLab Finish Cloud FUnction document Finish Node course episode 2 Linux English Japanese 2019/8/24the result of my target yesterday Task: Working on Netdata and MongoDB Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish QwikLab Baseline: Infrastructure Finish The Wondering presentation next week Post at least an article of QwikLab Improve my resume Linux English Japanese 2019/8/23the result of my target yesterday Task: Working on customer-dashboard Was assigned to do another work Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on Netdata and MongoDB Linux English Japanese 2019/8/22the result of my target yesterday Task: Working on customer-dashboard Still working on it Finish GCP Cloud IAM: Qwik Start Still no time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Linux English Japanese 2019/8/21the result of my target yesterday Task: Working on customer-dashboard Still working on it Finish GCP Cloud IAM: Qwik Start Still no time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/20the result of my target yesterday Task: Working on customer-dashboard Still working on it Finish GCP Cloud IAM: Qwik Start No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/19the result of my target yesterday Task: Post GCP Cloud Storage Qwiklab start: SDK/CLI Finish GCP Cloud IAM: Qwik Start Still haven’t finished yet Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on customer-dashboard Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/18the result of my target yesterday Task: Post GCP Storage Qwiklab start: Console Finish GCP Storage Qwiklab start: SDK/CLI Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Post GCP Cloud Storage Qwiklab start: SDK/CLI Finish GCP Cloud IAM: Qwik Start Linux English Japanese 2019/8/17the result of my target yesterday Task: Release checkEdgeAlive asynchronous beta version Release checkEdgeAlive process-block-proof shell script Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Post GCP Storage Qwiklab start: Console Finish GCP Storage Qwiklab start: SDK/CLI Linux English Japanese 2019/8/16the result of my target yesterday Task: Build new site with SSL certificate Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Release checkEdgeAlive asynchronous beta version Release checkEdgeAlive process-block-proof shell script Linux English Japanese 2019/8/15the result of my target yesterday Task: Optimise checkEdgeAlive to reduce the Datastore read time Add a time response on DNS Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Build new site with SSL certificate Linux English Japanese 2019/8/14the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Optimise checkEdgeAlive to reduce the Datastore read time Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise checkEdgeAlive to reduce the Datastore read time Add a time response on DNS Linux English Japanese 2019/8/13the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Still working on it Optimise checkEdgeAlive to reduce the Datastore read time Initially completed the cost part, and going to remove unnecessary code Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Optimise checkEdgeAlive to reduce the Datastore read time Linux English Japanese 2019/8/12the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Optimise checkEdgeAlive to reduce the Datastore read time Linux English Japanese 2019/8/11the result of my target yesterday Task: GCP QwikLab - Baseline: Infrastructure Not yet QQ Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Linux English Japanese 2019/8/10the result of my target yesterday Task: Refactor checkEdgeAlive Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: GCP QwikLab - Baseline: Infrastructure Linux English Japanese 2019/8/9the result of my target yesterday Task: Figure out how logParser works Suspended temporarily Completed logrotate documentation Suspended temporarily Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Refactor checkEdgeAlive Linux English Japanese 2019/8/8the result of my target yesterday Task: Figure out how deploy works Will focus on logParser first Completed logrotate documentation No time for it yet Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out how logParser works Completed logrotate documentation Linux English Japanese 2019/8/7the result of my target yesterday Task: Figure out what lerna is Completed Figure out what yarn workspace is Completed Completed logrotate documentation No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out how deploy works Completed logrotate documentation Linux English Japanese 2019/8/6the result of my target yesterday Task: Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Completed logrotate documentation Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out what lerna is Figure out what yarn workspace is Completed logrotate documentation Linux English Japanese 2019/8/5the result of my target yesterday Task: Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out what lerna is Figure out what yarn workspace is Completed logrotate documentation Linux English Japanese 2019/8/4the result of my target yesterday Task: Organise GCP Load Balancer Finally completed it Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out what lerna is Figure out what yarn workspace is Linux English Japanese 2019/8/3the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out what lerna is Figure out what yarn workspace is Linux English Japanese 2019/8/2the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Figure out how to use logRotate Completed Figure out what lerna is Still working on it Figure out what yarn workspace is Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out what lerna is Figure out what yarn workspace is Linux English Japanese 2019/8/1the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Figure out how to use logRotate Teh result is to be seen Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out how to use logRotate Figure out what lerna is Figure out what yarn workspace is Linux English Japanese","link":"/zh-tw/schedule/2019/August/index.html"},{"title":"December 2019","text":"2019/12/31Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2019/12/30Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Exercise Squat 2019/12/29Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Write down how to deploy Jenkins with Laradock Others: Implement continuous delivery in carSharing project 2019/12/28Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Deploy Jenkins with Laradock 2019/12/27Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/26Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/25Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/24Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Consume undigested articles Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/23Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Others: Optimise Laradock deployment with Let’s Encrypt 2019/12/22Target and result today Work: Learning: Kubernetes English Japanese Laravel Linux Others: Deploy all of my side projects 2019/12/21Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2019/12/20Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2019/12/19Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/18Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/17Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/16Target and result today Work: BeePay Learning: English Japanese Laravel Linux 2019/12/15Target and result today Work: Learning: English Japanese Laravel Linux Others: Hackathon 2019/12/14Target and result today Work: Learning: English Japanese Laravel Linux Others: Hackathon 2019/12/13Target and result today Work: Learning: English Japanese Laravel Linux Others: Mountain hiking 2019/12/12The target I set today Work: BeePay v1.4.0 Besides work: NGINX Linux English Japanese Laravel Kubernetes BeePay code reading The result of today’s target Work: BeePay v1.4.0 Besides work: NGINX Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/11The target I set today Work: BeePay v1.4.0 Besides work: Linux English Japanese Laravel Kubernetes BeePay code reading The result of today’s target Work: BeePay v1.4.0 Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/10The target I set today Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading The result of today’s target Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/9The target I set today Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading The result of today’s target Work: Besides work: Linux English Japanese Laravel Kubernetes BeePay coding reading 2019/12/8The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/12/7The target I set today Work: Besides work: GDG Linux English Japanese Laravel The result of today’s target Work: Besides work: GDG Linux English Japanese Laravel 2019/12/6The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/5The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/4The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/3The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/12/2The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/12/1The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel","link":"/zh-tw/schedule/2019/December/index.html"},{"title":"February 2018","text":"2019/2/28The result of my target yesterday Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Make recipient information only required when a order is paid Achieved except for set target yesterday Solve the problem that the canvas-nest special effect doesn’t work properly on Schedule page DescriptionToday’s target Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Restructure WebSocket 2019/2/27The result of my target yesterday One more section of my Git course Write down an article - how to build a multilingual blog with Hexo Optimize FB online selling project Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Make recipient information only required when a order is paid 2019/2/26The result of my target yesterday My blog - improve the layout Achieved except for set target yesterdayDescriptionToday’s target One more section of my Git course Write down an article - how to build a multilingual blog with Hexo Optimize FB online selling project 2019/2/25The result of my target yesterday Working on the blog, I would like to make a bilingual version Achieved except for set target yesterdayDescriptionToday’s target My blog - improve the layout 2019/2/24The result of my target yesterday Fix the decoded garble problem of my blog Completed a bit, but still working on it Achieved except for set target yesterdayDescriptionToday’s target Working on the blog, I would like to make a bilingual version 2019/2/23The result of my target yesterday Challenge: Facebook optimized selling system - keep optimizing Git course: The presentation Finished first course Write down how to make PayPal payment service work Working on my blog instead Achieved except for set target yesterdayDescriptionToday’s target Fix the decoded garble problem of my blog 2019/2/22The result of my target yesterday Challenge: Facebook optimized selling system Optimize and debug Demo Achieved except for set target yesterdayDescriptionToday’s target Challenge: Facebook optimized selling system - keep optimizing Git course: The presentation Write down how to make PayPal payment service work 2019/2/21The result of my target yesterday Challenge: Facebook optimized selling system - Optimize and debug Optimize images upload function with Laravel way Reorganise and write down how to make PayPal payment service works Achieved except for set target yesterday Challenge: Facebook optimized selling system Added new function that when an order is paid, the buyer will receive a notification email DescriptionToday’s target Challenge: Facebook optimized selling system optimize and debug demo 2019/2/20The result of my target yesterday challenge: facebook optimized selling system - optimize and debug added email update function in update-user-info function Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - optimize and debug optimize images upload function with laravel way reorganise and write down how to make paypal payment service works 2019/2/19The result of my target yesterday challenge: facebook optimized selling system - paypal payment service finally app site is able to use it Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - optimize and debug 2019/2/18 gcp quiklab training course stackdriver: qwik start set up network and http load balancers The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/17The result of my target yesterday gcp quiklab training course completed lessons 6 Achieved except for set target yesterdayDescriptionToday’s target gcp quiklab training course 2019/2/16The result of my target yesterday gcp quiklab training course completed lessons 1~5 Achieved except for set target yesterdayDescriptionToday’s target gcp quiklab training course 2019/2/15 challenge: facebook optimized selling system - paypal payment service completed paypal payment service function The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target gcp quiklab training course 2019/2/14 challenge: facebook optimized selling system - paypal payment service still working on it The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/13 challenge: facebook optimized selling system - paypal payment service still working on it The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/12 challenge: facebook optimized selling system paypal payment service The result of my target yesterdayAchieved except for set target yesterday api revise create new api- get user status DescriptionToday’s target challenge: facebook optimized selling system - paypal payment service 2019/2/11 challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service still working on it. The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system paypal payment service 2019/2/10 challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service still working on it The result of my target yesterdayAchieved except for set target yesterday challenge: facebook optimized selling system debug optimize DescriptionToday’s target challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service 2019/2/9 challenge: facebook optimized selling system write an article about how to handle allpay payment service paypal payment service still working on it git pro 鳥哥的linux The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system write an article about how to get user’s basic information via token got from fb paypal payment service 2019/2/8The result of my target yesterday challenge: facebook optimized selling system write down how to use task scheduling of laravel with crontab to routinely delete expired orders the presentation of hackmd for ‘the wondering’ on 14 february 2019 paypal payment service git pro git object 鳥哥的linux Achieved except for set target yesterday adopted task scheduling of laravel with crontab to routinely delete expired orders DescriptionToday’s target challenge: facebook optimized selling system write an article about how to handle allpay payment service paypal payment service git pro 鳥哥的linux 2019/2/7The result of my target yesterday challenge: facebook optimized selling system write down how to use aws ses find out why ngrok doesn’t work with aws ses it’s caused by the port. Achieved except for set target yesterday adopted task scheduling of laravel with crontab to routinely delete expired orders DescriptionToday’s target challenge: facebook optimized selling system write down how to use task scheduling of laravel with crontab to routinely delete expired orders the presentation of hackmd for ‘the wondering’ on 14 february 2019 paypal payment service git pro 鳥哥的linux 2019/2/6The result of my target yesterday challenge: facebook optimized selling system mail notification system via ses and laravel Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system write down how to use aws ses find out why ngrok doesn’t work with aws ses 2019/2/5The result of my target yesterday challenge: facebook optimized selling system optimize order system for allpay payment service Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system mail notification system via ses and laravel 2019/2/4The result of my target yesterday challenge: facebook optimized selling system third party payment service, allpay Achieved except for set target yesterday git pro: git hash-object -w stdin git cat-file -p checksum DescriptionToday’s target challenge: facebook optimized selling system optimize order system for allpay payment service 2019/2/3The result of my target yesterday challenge: facebook optimized selling system still working on third party payment service, allpay git pro no time for it = = 鳥哥的linux no time for it = = Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service, allpay 2019/2/2The result of my target yesterday challenge: facebook optimized selling system still working on it git pro no time for it 鳥哥的linux no time for it Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux 2019/2/1The result of my target yesterday [ ] challenge: facebook optimized selling system ‘the wondering presentation’ instead [x] git pro step into plumbing’s world 鳥哥的linux no time for it Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux","link":"/zh-tw/schedule/2019/February/index.html"},{"title":"January 2019","text":"2019/1/31The result of my target yesterday challenge: facebook optimized selling system revised api instead git pro prepared ‘the wondering’ rehearsal 鳥哥的linux prepared ‘the wondering’ rehearsal Achieved except for set target yesterday block chain knowledgeDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux 2019/1/30The result of my target yesterday challenge: facebook optimized selling system completed api (26/26) git course outline provided to howard Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system third party payment service git pro 鳥哥的linux2019/1/29 The result of my target yesterday challenge: facebook optimized selling system commpleted api (23/25) git pro prepared git course outline instead 鳥哥的linux prepared git course outline instead Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system git course outline 2019/1/28The result of my target yesterday challenge: facebook optimized selling system commpleted api (22/25) introduction of my blog Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system git pro 鳥哥的linux2019/1/27 The result of my target yesterday ‘the wondering’ presentation next week challenge: facebook optimized selling system completed 3 api Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system introduction of my blog 2019/1/26The result of my target yesterday challenge: facebook optimized selling system working on my blog and linkedin instead. Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system ‘the wondering’ presentation next week 2019/1/25The result of my target yesterday challenge: facebook optimized selling system working on ci with jenkins instead Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/24The result of my target yesterday challenge: facebook optimized selling system completed three apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/23The result of my target yesterday challenge: facebook optimized selling system completed three apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/22The result of my target yesterday challenge: facebook optimized selling system completed three apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/21The result of my target yesterday challenge: facebook optimized selling system completed six apis Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/20The result of my target yesterday challenge: facebook optimized selling system completed three api Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/19The result of my target yesterday challenge: facebook optimized selling system initially completed api document Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/18The result of my target yesterday challenge: facebook optimized selling system intially confirmed the specification Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system2019/1/17 The result of my target yesterday challenge: facebook optimized selling system initially discussed the feature Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/16The result of my target yesterdayAchieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/15The result of my target yesterday linux: 鳥哥的linux基礎篇 git: pro git build my own blog in github with hexo almost complete personal configuration Achieved except for set target yesterdayDescriptionToday’s target challenge: facebook optimized selling system 2019/1/14The result of my target yesterday [x] linux: 鳥哥的linux基礎篇 suid full name suid’s function and limit [x] git: pro git how to configure your git to save your credentials? what are three level of git configurations? where is the configuration file that git looks for when it comes to system level configuration? where is the configuration file that git looks for when it comes to global level configuration? how to ignore files globaly in git? [x] build my own blog in github with hexo i’m still working on it, still some issues to be solved. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git build my own blog in github with hexo 2019/1/13The result of my target yesterday iron man award ceremony Achieved except for set target yesterday completed presentation for ‘the wondering’ on 17 january 2019DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git reorganize those presentations i’ve made from keynote to hackmd the first commit 沒遇到這些事之前，我也覺得我git超屌 episode 1 沒遇到這些事之前，我也覺得我git超屌 episode 2 沒遇到這些事之前，我也覺得我git超屌 episode 3 沒遇到這些事之前，我也覺得我git超屌 episode 4 2019/1/12The result of my target yesterday challenge20181217 rewriting optimize readme the wondering organize git presentation that i’ve shared in ‘the wondering’ presentation for ‘the wondering’ next week 鳥哥的Linux基礎篇 git: pro git Achieved except for set target yesterday build opendata project on aws and so my team members could use it for their interviews in the future.DescriptionToday’s target iron man award ceremony 2018/1/11The result of my target yesterday challenge20181217 rewriting add status code to all the functions revise api document accordingly to restful api. Achieved except for set target yesterday git: if you create a new branch, add a submodule there, and then switch back to a branch without that submodule, what will happen?DescriptionToday’s target challenge20181217 rewriting optimize readme the wondering organize git presentation that i’ve shared in ‘the wondering’ presentation for ‘the wondering’ next week linux: 鳥哥的linux基礎篇 git: pro git 2019/1/10The result of my target yesterday linux: 鳥哥的linux基礎篇 working on swagger api [ ] git: pro git working on swagger api [x] challenge20181217 rewriting added customized status code on register, login, and get profile api revise api document accordingly to restful api Achieved except for set target yesterdayDescriptionToday’s target challenge20181217 rewriting add status code to all the functions revise api document accordingly to restful api.2019/1/9 The result of my target yesterday linux: 鳥哥的linux基礎篇 working on swagger api [ ] git: pro git working on swagger api [x] challenge20181217 rewriting complete register and login function api with swagger Achieved except for set target yesterdayDescriptionToday’s target challenge20181217 rewriting make api document with swagger2019/1/8 The result of my target yesterday linux: 鳥哥的linux基礎篇 working on challenge20190107 - how to upload a file to aws-s3 via a pre-signed url instead. [x] git: pro git how to stash all the work in all our submodules? how to create a new branch and switch to it in all our submodules? how to use ‘git diff’ in your main project and all your submodules? [ ] challenge20181217 rewriting working on challenge20190107 - how to upload a file to aws-s3 via a pre-signed url instead. Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting revise api document learn how to use swagger 2019/1/7The result of my target yesterday had a wonderful getaway yesterday.Achieved except for set target yesterdayDescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting revise api document 2019/1/6The result of my target yesterday [ ] linux: 鳥哥的linux基礎篇 [x] git: pro git practice submodule [x] challenge20181217 rewriting complete transferring to restful apiAchieved except for set target yesterdayDescriptionToday’s target have a getaway today. 2019/1/5The result of my target yesterday [ ] linux: 鳥哥的linux基礎篇 [x] git: pro git practice submodule [x] challenge20181217 rewriting publish api document on github page, and sign ssl certificateAchieved except for set target yesterday how to build a blog with hexo DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting optimize api to restful api 2019/1/4The result of my target yesterday [x] linux: 鳥哥的linux基礎篇 what’s chattr [+-=] [asacdistu] how to search placed command in lunux? [x] git: pro git how to check if we find a bug after a lot of commits made, and we have no idea when and where the code went wrong? how to revise submodule url? what does 160000 mode means when commit a submodule? how to make a submodule? a better diff for submodule? [x] challenge20181217 rewriting complete ‘aws deployment’ DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting publish the api document on github page 2019/1/3The result of my target yesterday [x] linux: 鳥哥的linux基礎篇 how to execute cat command with value got previously in linux? [x] git: pro git what’s the progress of cloning project with submodule in? if, in master branch, i reset with a sha1 from develop branch, what would happen? how to specify lines with git blame? how to show where it’s originally copied from with git blame? [x] challenge20181217 rewriting complete ‘optimizing payment controller’ DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting deploy on aws2019/1/2 The result of my target yesterday [ ] linux: 鳥哥的linux基礎篇 ‘wondering’ rehearsal instead [ ] git: pro git ‘wondering’ rehearsal instead [x] challenge20181217 rewriting complete ‘deposit common achievement’ DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting optimize payment controller2019/1/1 The result of my target yesterday [x] linux: 鳥哥的linux基礎篇 what’s default authority when creating a file? what’s the default umask? so what’s the final default authority? how to see default umask? how to set umask? what’s the correct way of calculating final authority after deducting umask? [ ] git: pro git challenge20181217 rewriting do a linebot challenge held by howard instead DescriptionToday’s target linux: 鳥哥的linux基礎篇 git: pro git challenge20181217 rewriting deposit achievement","link":"/zh-tw/schedule/2019/January/index.html"},{"title":"November 2018","text":"2019/3/31The result of my target yesterday Deploy jenkins for openData Laracasts-Laravel_5.7_From_Scratch Achieved except for set target yesterdayDescriptionToday’s target GCP Essentials - Kubernetes Laracasts-Laravel_5.7_From_Scratch 2019/3/30The result of my target yesterday Write down how to do jenkins deployment Deploy ‘backendOfMobileGames’ and ‘openData’ Achieved except for set target yesterdayDescriptionToday’s target Deploy jenkins for openData Laracasts-Laravel_5.7_From_Scratch 2019/3/29The result of my target yesterday AWS Deployment: jenkins deployment Achieved except for set target yesterdayDescriptionToday’s target Write down how to do jenkins deployment Deploy ‘backendOfMobileGames’ and ‘openData’ 2019/3/28The result of my target yesterday AWS Deployment Completed supervisor and queue setting Achieved except for set target yesterdayDescriptionToday’s target AWS Deployment: jenkins deployment 2019/3/27The result of my target yesterday AWS Deployment Still working on it Achieved except for set target yesterdayDescriptionToday’s target AWS Deployment 2019/3/26The result of my target yesterday Laracasts-Laravel_5.7_From_Scratch Episode 6-11 Achieved except for set target yesterdayDescriptionToday’s target AWS Deployment 2019/3/25The result of my target yesterday Laracasts-Laravel_5.7_From_Scratch Episode 1~5 Achieved except for set target yesterdayDescriptionToday’s target Laracasts-Laravel_5.7_From_Scratch 2019/3/24The result of my target yesterday Write down how to use queue with sqs Prepare interview tonight Well, the interview was rescheduled because the interviewer was indisposed. Achieved except for set target yesterdayDescriptionToday’s target Laracasts-Laravel_5.7_From_Scratch 2019/3/23The result of my target yesterday Write down how to use Supervisor to manage queue work with sqs Completed Supervisor part, and will work on sqs part today. Prepare interview tonight The interview time was changed to tonight. Achieved except for set target yesterdayDescriptionToday’s target Write down how to use queue with sqs Prepare interview tonight 2019/3/22The result of my target yesterday Figure out how to use Supervisor to manage queue work Write down how to use Supervisor to manage queue work ‘The Wondering’ presentation Achieved except for set target yesterdayDescriptionToday’s target Write down how to use Supervisor to manage queue work with sqs Prepare interview tonight 2019/3/21The result of my target yesterday Figure out how to use SQS to send email Recap GCP Essentials Achieved except for set target yesterdayDescriptionToday’s target Figure out how to use Supervisor to manage queue work Write down how to use Supervisor to manage queue work ‘The Wondering’ presentation 2019/3/20The result of my target yesterday Complete FB selling side project’s ReadMe Recap GCP Essentials Achieved except for set target yesterdayDescriptionToday’s target Figure out how to use SQS to send email Recap GCP Essentials 2019/3/19The result of my target yesterday Write down Ray’s git flow Complete FB selling side project’s ReadMe Not yet completed, but working on it. Achieved except for set target yesterdayDescriptionToday’s target Complete FB selling side project’s ReadMe Recap GCP Essentials 2019/3/18The result of my target yesterday The Wondering presentation. Optimize FB online selling project Achieved except for set target yesterdayDescriptionToday’s target Write down Ray’s git flow Complete FB selling side project’s ReadMe 2019/3/17The result of my target yesterday The Wondering presentation. Optimize FB online selling project Phone validation and address validation Mail system Achieved except for set target yesterdayDescriptionToday’s target The Wondering presentation. Optimize FB online selling project 2019/3/16The result of my target yesterday Optimize FB online selling project Still working on the mail system for refund Achieved except for set target yesterdayDescriptionToday’s target The Wondering presentation. Optimize FB online selling project Phone validation and address validation Mail system 2019/3/15The result of my target yesterday Write down how to use PayPal payment service I’ve done it! Optimize FB online selling project If possible, I will go validation today! Achieved except for set target yesterdayDescriptionToday’s target Optimize FB online selling project Phone validation and address validation 2019/3/14The result of my target yesterday Write down how to use PayPal payment service I’m working on it! Optimize FB online selling project Have added refund function on both PayPal and AllPay Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Finish it! Optimize FB online selling project If possible, I will go validation today! 2019/3/13The result of my target yesterday Write down how to use PayPal payment service Finished the refund function of PayPal. Optimize FB online selling project Finished the refund function of PayPal. Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Will start to write this article after AllPay system refund function is completed. Optimize FB online selling project Finish refund function of AllPay 2019/3/12The result of my target yesterday Write down how to use PayPal payment service Almost finished refund function Optimize FB online selling project Almost finished PayPal refund function Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/11The result of my target yesterday Write down how to use PayPal payment service Completed capture authorization function. Optimize FB online selling project Completed capture authorization function. Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/10The result of my target yesterday Write down how to use PayPal payment service Nearly finished a basic transaction with REST API of PayPal Optimize FB online selling project Nearly finished a basic transaction with REST API of PayPal Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/9The result of my target yesterday Write down how to use PayPal payment service Still working on new features Optimize FB online selling project Working on refund feature Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/8The result of my target yesterday Write down how to use PayPal payment service Still working on new features Optimize FB online selling project Working on refund feature Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project 2019/3/7The result of my target yesterday Write down how to use PayPal payment service Already figured out how to use REST API, and now working on how to integrate it into my system Optimize FB online selling project Restructure Currently working on refund function WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/6The result of my target yesterday Write down how to use PayPal payment service still working on figuring out how rest API works Optimize FB online selling project Restructure WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/5The result of my target yesterday Write down how to use PayPal payment service Completed Payment Standard and IPN Message method Optimize FB online selling project Refine payment service Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/4The result of my target yesterday Write down how to use PayPal payment service Still working on it, it’s a epic task! Optimize FB online selling project Restructure Make PayPal page show items and recipient in detail WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/3The result of my target yesterday Write down how to get long-lived and forever token from FB One more section of my Git Course Basically, it’s completed Optimize FB online selling project Restructure WebSocket Achieved except for set target yesterdayDescriptionToday’s target Write down how to use PayPal payment service Optimize FB online selling project Restructure WebSocket 2019/3/2The result of my target yesterday Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project Added long-lived token function Achieved except for set target yesterdayDescriptionToday’s target Write down how to get long-lived and forever token from FB One more section of my Git Course Optimize FB online selling project Restructure WebSocket 2019/3/1The result of my target yesterday Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project- Restructure - WebSocket Achieved except for set target yesterdayDescription Went to help 日安 carry the new counter she bought Went to KTV with Lester Today’s target Write down how to use PayPal payment service One more section of my Git Course Optimize FB online selling project- Restructure - WebSocket","link":"/zh-tw/schedule/2019/March/index.html"},{"title":"July 2019","text":"2019/7/31the result of my target yesterday Task: Organise GCP Load Balancer Completed testing, and going to write a documentation Figure out how to use logRotate No time for it Optimise CICD on api-server project Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out how to use logRotate Linux English Japanese 2019/7/30the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Initially completed Figure out how to use logRotate No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Figure out how to use logRotate Optimise CICD on api-server project Linux English Japanese 2019/7/29the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Figure out how to use logRotate No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Figure out how to use logRotate Linux English Japanese 2019/7/28the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Figure out how to use logRotate No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Figure out how to use logRotate Linux English Japanese 2019/7/27the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Figure out how to use logRotate Linux English Japanese 2019/7/26the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Linux English Japanese 2019/7/25the result of my target yesterday Task: Organise GCP Load Balancer Still working on it Work on CostDown We’ve got some progress Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Linux English Japanese 2019/7/24the result of my target yesterday Task: Build new sites Organise pm2 config Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balancer Work on CostDown Linux English Japanese 2019/7/23the result of my target yesterday Task: Trace edgeOnline API Initially found the issue, going to test it Organise pm2 config No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Build new sites Organise pm2 config Linux English Japanese 2019/7/22the result of my target yesterday Task: Organise GCP Load Balance No time for it Organise pm2 config Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Trace edgeOnline API Organise pm2 config Linux English Japanese 2019/7/21the result of my target yesterday Task: Organise GCP Load Balance No time for it Organise pm2 config Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balance Organise pm2 config Linux English Japanese 2019/7/20the result of my target yesterday Task: Observe new LB, and if every thing goes well, delete all previous VMs Build CICD for all of the projects Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Organise GCP Load Balance Organise pm2 config Linux English Japanese 2019/7/19the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Initially completed, and going to observe it further Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Observe new LB, and if every thing goes well, delete all previous VMs Build CICD for all of the projects Linux English Japanese 2019/7/18the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/17the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Shutdown qcdn-job and move the job to another VM Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/16the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Shutdown qcdn-job and move the job to another VM Linux English Japanese 2019/7/15the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Fix eon_v3 DNS issue Initially completed, but still have something to discuss with Raymond before closing this issue Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Fix eon_v3 DNS issue Linux English Japanese 2019/7/14the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Fix eon_v3 DNS issue Initially fixed it, but still have some problems to discuss Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Fix eon_v3 DNS issue Linux English Japanese 2019/7/13the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Fix eon_v3 DNS issue Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Fix eon_v3 DNS issue Linux English Japanese 2019/7/12the result of my target yesterday Task: Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Added a feature sending event notification to Slack channel Completed Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/11the result of my target yesterday Task: Trace customer-api code to find out what might cause huge Datastore read It seems that either cloud-api and cloud-customer-api is not the cause of this issue. Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/10the result of my target yesterday Task: Trace customer-api code to find out what might cause huge Datastore read Still working on it Optimise the number of VM instance from 8 VMs to 2 VMs Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Trace customer-api code to find out what might cause huge Datastore read Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/9the result of my target yesterday Task: Optimise CI with pm2 Still working on it Publish my article regarding pm2 Still working on it Trace customer-api code to find out what might cause huge Datastore read still tracing Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Trace customer-api code to find out what might cause huge Datastore read Optimise the number of VM instance from 8 VMs to 2 VMs Linux English Japanese 2019/7/8the result of my target yesterday Task: Optimise CI with pm2 Still working on it Publish my article regarding pm2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise CI with pm2 Publish my article regarding pm2 Trace customer-api code to find out what might cause huge Datastore read Linux English Japanese 2019/7/7the result of my target yesterday Task: Change CI with pm2 Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Optimise CI with pm2 Publish my article regarding pm2 Linux English Japanese 2019/7/6the result of my target yesterday Task: Change CI with pm2 Still working on it Turn off loadAccessLog, bandwidthUsage, and emptyGzLogRemover API Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Linux English Japanese 2019/7/5the result of my target yesterday Task: Change CI with pm2 Still working on it Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Turn off loadAccessLog, bandwidthUsage, and emptyGzLogRemover API Linux English Japanese 2019/7/4the result of my target yesterday Task: Change CI with pm2 Analyse the bill Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese 2019/7/3the result of my target yesterday Task: Configure ShadowSocks client setting Change CI with pm2 Make ShadowSocks automatically restart after reboot and shutdown the instance Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Change CI with pm2 Analyse the bill Keep off checkEdgeAlive API until 10 pm, and check the bill tomorrow Linux English Japanese 2019/7/2the result of my target yesterday Task: Configure ShadowSocks sever setting Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Configure ShadowSocks client setting Change CI with pm2 Make ShadowSocks automatically restart after reboot and shutdown the instance Linux English Japanese 2019/7/1the result of my target yesterday Task: Make a pm2 document Still working on it Make a Let’s Encrypt document and publish it Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese","link":"/zh-tw/schedule/2019/July/index.html"},{"title":"June 2019","text":"2019/6/30the result of my target yesterday Task: Complete FTP server document and publish it Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Make a pm2 document Make a Let’s Encrypt document and publish it Linux English Japanese JavaScript 2019/6/29the result of my target yesterday Task: Make PM2 document, and optimise every VM Still working on it Made a FTP server for internal deployment Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Complete FTP server document and publish it Linux English Japanese JavaScript 2019/6/28the result of my target yesterday Task: Auto sign three sites with Let&#39;s Encrypt Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Make PM2 document, and optimise every VM Linux English Japanese JavaScript 2019/6/27the result of my target yesterday Task: Figure out how pm2 works and optimise VMs with pm2 Partially Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Auto sign three sites with Let&#39;s Encrypt Linux English Japanese JavaScript 2019/6/26the result of my target yesterday Task: Understand how Cloud Function works Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Figure out how pm2 works and optimise VMs with pm2 Linux English Japanese JavaScript 2019/6/25the result of my target yesterday Task: Optimise VMs Re-purged failed edges Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Understand how Cloud Function works Linux English Japanese JavaScript 2019/6/24the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese JavaScript 2019/6/23the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/22the result of my target yesterday Task: Made eov_v3 work Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/21the result of my target yesterday Task: Working on EON_V3 Make domain column accepts array Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese 2019/6/20the result of my target yesterday Task: Working on EON_V3 Completed CI Completed revising, the service is working now. Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on EON_V3 Make domain column accepts array Linux English Japanese 2019/6/19the result of my target yesterday Task: The handover of the work with Eddie I was told to work on project EON_V3 first Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on EON_V3 Linux English Japanese 2019/6/18the result of my target yesterday Task: The handover of the work with Eddie Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: The handover of the work with Eddie Linux English Japanese 2019/6/17the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: TBD Linux English Japanese JavaScript 2019/6/16the result of my target yesterday Task: Linux English Japanese JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/15the result of my target yesterday Task: Edge and Site API Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Linux English Japanese JavaScript 2019/6/14the result of my target yesterday Task: Working on DNS function Completed Working on Site and Edge API Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Edge and Site API Linux English Japanese 2019/6/13the result of my target yesterday Task: Working on DNS function Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on DNS function Linux English Japanese 2019/6/12the result of my target yesterday Task: Working on DNS function Finished GCP Cloud DNS Service part Linux English Japanese JavaScript No time for it achieved except for set target yesterdaydescriptiontoday’s target Task: Working on DNS function Linux English Japanese 2019/6/11the result of my target yesterday Task: Have a meeting with ST, Raymond, and OY Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on DNS function Linux English Japanese JavaScript 2019/6/10the result of my target yesterday Task: Figured out how to add a Load-Balancing with gcloud Got stuck on SSH issue instead. However, I learnt something from it. Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Have a meeting with ST, Raymond, and OY Linux English Japanese 2019/6/9the result of my target yesterday Task: Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript Today I will go out with friends for dinner, I hope that I will still finish my schedule achieved except for set target yesterdaydescriptiontoday’s target Task: Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript 2019/6/8the result of my target yesterday Task: Transfer the drawing from HackMD to Draw.io Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript Today I will go out with friends for dinner, I hope that I will still finish my schedule 2019/6/7the result of my target yesterday Task: Discuss with Raymond to finalize initial version, and discuss with ST Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript achieved except for set target yesterdaydescriptiontoday’s target Task: Transfer the drawing from HackMD to Draw.io Figured out how to add a Load-Balancing with gcloud Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript 2019/6/6the result of my target yesterday Task: Discuss with Raymond to finalize initial version of programming process drawing and make it with draw.io Raymond pointed out some errors, to be revised and resubmitted Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Discuss with Raymond to finalize initial version, and discuss with ST Linux English Japanese JavaScript The Principles of Object-Oriented JavaScript 2019/6/5the result of my target yesterday Task: Revised the data path according to the discussion yesterday. Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Discuss with Raymond to finalize initial version of programming process drawing and make it with draw.io Linux English Japanese 2019/6/4the result of my target yesterday Task: Completed logic part and compare with ST’s data path Completed first version of scratch, and had a discussion with Raymond Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Revised the data path according to the discussion yesterday. Linux English Japanese 2019/6/3the result of my target yesterday Task: Add new Japanese vocabulary card Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Completed logic part and compare with ST’s data path Linux English Japanese 2019/6/2the result of my target yesterday task: add new japanese vocabulary card Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Add new Japanese vocabulary card Linux English Japanese 2019/6/1the result of my target yesterday Task: Working on architecture of Cloud API Initially finished Ready Pool and Bootstrap Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: add new japanese vocabulary card Linux English Japanese","link":"/zh-tw/schedule/2019/June/index.html"},{"title":"May 2019","text":"2019/5/31the result of my target yesterday Task: Working on architecture of Cloud API Started working on Discover Service Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on architecture of Cloud API Linux English Japanese 2019/5/30the result of my target yesterday Task: Working on architecture of Cloud API Initially completed Ready Pool and Bootstrap Help Raymond to check edge condition Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on architecture of Cloud API Linux English Japanese 2019/5/29the result of my target yesterday Task: A meeting in Hsinchu Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on architecture of Cloud API Linux English Japanese 2019/5/28the result of my target yesterday Task: Completed edge-ip-revising API Still working on GCP Cloud DNS documentation Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: A meeting in Hsinchu Linux English Japanese 2019/5/27the result of my target yesterday Task: Completed a course in Qwiklab Watch Game of Thrones instead, I was guilty! Fix my windows computer Containerise HX-API Watch Game of Thrones instead, I was guilty! Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Completed edge-ip-revising API Linux English Japanese 2019/5/26the result of my target yesterday Task add getting new ip feature to monitor api Organising what I have learnt those weeks English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Completed a course in Qwiklab Fix my windows computer Containerise HX-API Linux English Japanese 2019/5/25the result of my target yesterday Task review merge request of monitor api add getting new ip feature to monitor api working on onedgeipchange api English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task add getting new ip feature to monitor api Organising what I have learnt those weeks English Japanese 2019/5/24the result of my target yesterday Task figured out how edge dns works English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task review merge request of monitor api add getting new ip feature to monitor api working on onedgeipchange api English Japanese 2019/5/23The result of my target yesterday Task Comment issue 302~310 Have a meeting with Raymond English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Working on API developing and refactoring. English Japanese 2019/5/22The result of my target yesterday Task Added new feature into monitor API English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Comment issue 302~310 Have a meeting with Raymond English Japanese 2019/5/21The result of my target yesterday Task English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Added new feature into monitor API English Japanese 2019/5/20The result of my target yesterday Task English Japanese achieved except for set target yesterdaydescriptiontoday’s target Organise what I learnt those weeks English Japanese 2019/5/19The result of my target yesterday Organise what I learnt those weeks Completed gitlac CI/CD on GCP virtual machine document organisation English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Figure out checkEdgeAlive API Complete issue 302~310 English Japanese 2019/5/18The result of my target yesterday Organise what I learnt those weeks Organised Gitlab CI/CD English Japanese achieved except for set target yesterdaydescriptiontoday’s target Organise what I learnt those weeks English Japanese 2019/5/17The result of my target yesterday Task I would like to complete API support feature of the healthCheck function, however, it depends on the task English Japanese achieved except for set target yesterdaydescriptiontoday’s target Organise what I learnt those weeks English Japanese 2019/5/16The result of my target yesterday Task Understand the logic of checkEdgeAlive API - Then, we optimise the healthCheck function instead. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task I would like to complete API support feature of the healthCheck function, however, it depends on the task English Japanese 2019/5/15The result of my target yesterday Task Come out with a solution for checkEdgeAlive issue: Completed a health check program to check the health per 10 minutes for temporary solution. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Understand the logic of checkEdgeAlive API English Japanese 2019/5/15The result of my target yesterday Task Initially fixed issue from 302 to 310 English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Come out with a solution for checkEdgeAlive issue English Japanese 2019/5/14The result of my target yesterday Task Understand the logic of API implementation of QCDN. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Solve issue 302~310 English Japanese 2019/5/13The result of my target yesterday Task Understand the logic of API implementation of QCDN. Deploy Node.js project on Google App Engine English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Understand the logic of API implementation of QCDN. English Japanese 2019/5/12The result of my target yesterday Task Figured out how to use breakpoint feature in PHPStorm. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Understand the logic of API implementation of QCDN. English Japanese 2019/5/11The result of my target yesterday Task Have initially completed the database organising, however, still have to change the logic of API implementation. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Figure out how to use IDE breakpoint feature English Japanese 2019/5/10The result of my target yesterday Task Have figured out the logic, still working on it. English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task Fix siteEdge unmatched data issue English Japanese 2019/5/9The result of my target yesterday English Japanese Task Got siteEdge.host unmatched from either site.host or site.cname Learnt how to build a site achieved except for set target yesterdaydescriptiontoday’s target Task Fix siteEdge unmatched data issue English Japanese 2019/5/8The result of my target yesterday English Japanese node.js How to insert data into datastore achieved except for set target yesterdaydescriptiontoday’s target Task English Japanese 2019/5/7The result of my target yesterday English Japanese A go over with Eddie and Raymond achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/6The result of my target yesterday English Japanese Gitlab CI Load Balance achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/5The result of my target yesterday English Japanese Gitlab CI Load Balance achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/4The result of my target yesterday node.js English Japanese Gitlab CI achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/3The result of my target yesterday node.js English Japanese Gitlab CI achieved except for set target yesterdaydescriptiontoday’s target node.js English Japanese 2019/5/2The result of my target yesterday node.js add a new route in Express.js make different routes with different prefixes in Express.js send status code in Express.js docker English Japanese achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese Gitlab CI 2019/5/1The result of my target yesterday node.js Implementing mass delete and get function in GCP Datastore docker English Japanese achieved except for set target yesterdaydescriptiontoday’s target node.js docker English Japanese","link":"/zh-tw/schedule/2019/May/index.html"},{"title":"November 2019","text":"2019/11/30The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/11/29The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/11/28The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/27The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/26The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/25The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/24The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/23The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/22The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/21The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/20The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/19The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/18The target I set today Work: BeePay Besides work: Linux English Japanese Laravel The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel 2019/11/17The target I set today Work: Besides work: Linux English Japanese Laravel The result of today’s target Work: Besides work: Linux English Japanese Laravel 2019/11/16The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/15The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/14The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/13The target I set today Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/12The target I set today Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/11The target I set today Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/10The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/9The target I set today Work: Besides work: Linux English Japanese Laravel Translate a section of QwikLab article The result of today’s target Work: BeePay Besides work: Linux English Japanese Laravel Translate a section of QwikLab article 2019/11/8The target I set today Work: Besides work: Linux English Japanese Laravel BeePay The result of today’s target Work: Besides work: Linux English Japanese Laravel BeePay 2019/11/7The target I set today Work: Besides work: Linux English Japanese Laravel BeePay The result of today’s target Work: Besides work: Linux English Japanese Laravel BeePay 2019/11/6The target I set today Work: Besides work: Linux English Japanese BeePay The result of today’s target Work: Besides work: Linux English Japanese BeePay 2019/11/5The target I set today Work: Besides work: Linux English Japanese BeePay The result of today’s target Work: Besides work: Linux English Japanese BeePay 2019/11/4The target I set today Work: Besides work: Linux English Japanese BeePay The result of today’s target Work: Besides work: Linux English Japanese BeePay 2019/11/3The target I set today Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up The result of today’s target Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up 2019/11/2The target I set today Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up The result of today’s target Work: Besides work: Linux English Japanese Post an article Write down what you learnt those two days Case warm up 2019/11/1The target I set today Work: Besides work: Linux English Japanese Case warm up The result of today’s target Work: Besides work: Linux English Japanese Case warm up","link":"/zh-tw/schedule/2019/November/index.html"},{"title":"October 2019","text":"2019/10/31The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning case The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning case 2019/10/30The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning 2019/10/29The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning 2019/10/28The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning Docker learning 2019/10/27The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/26The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/25The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/24The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/23The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/22The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/21The target I set today Work: Update site list Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning The result of today’s target Work: Update site list Besides work: Linux English Japanese Working on a tech documentation translation Kubernetes learning 2019/10/20The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Jogging Kubernetes learning Organise an article Post an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Jogging Kubernetes learning Organise an article Post an article 2019/10/19The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes learning Japanese grammar Post an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes learning Japanese grammar Post an article 2019/10/18The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation pull up Kubernetes 2019/10/17The target I set today Work: Working on tw02 to tw01 switching Besides work: Linux English Japanese Working on a tech documentation translation push up The result of today’s target Work: Working on tw02 to tw01 switching Besides work: Linux English Japanese Working on a tech documentation translation push up 2019/10/16The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article Squat The result of today’s target Work: Added a new site as told Besides work: Linux English Japanese Working on a tech documentation translation Draft an article Organised an article Squat 2019/10/15The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Draft an article Organised an article 2019/10/14The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Draft an article Organised an article 2019/10/13The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer 2019/10/12The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js push up Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer 2019/10/11The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js pull ups Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js pull ups Complete at least one course of Stackdriver Logging Quest Draft an article Organised an article Working on table of GCP Load Balancer 2019/10/10The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Japanese Grammar Squat hair cut Complete at least one course of Stackdriver Logging Quest The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Japanese Grammar Squat hair cut Completed at least one course of Stackdriver Logging Quest 2019/10/9The target I set today Work: webdev with Nginx Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: webdev with Nginx Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/8The target I set today Work: Working on logParsing upload API Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing upload API Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/7The target I set today Work: Working on logParsing frontend and backend deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing frontend and backend deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/6The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article 2019/10/5The target I set today Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article Figure out Lookahead rule of Regex The result of today’s target Work: Besides work: Linux English Japanese Working on a tech documentation translation Node.js Post an tech article Figure out Lookahead rule of Regex 2019/10/4The target I set today Work: Working on Web and Backend dashboard deployment Check siteEdge KIND Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on Web and Backend dashboard deployment Check siteEdge KIND Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/3The target I set today Work: Working on Web and Backend dashboard deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on Web and Backend dashboard deployment Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/2The target I set today Work: Working on logParsing API Working on SFTP Server Working on Netdata API Working on Node Validator Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing API Working on SFTP Server Working on Netdata API Working on Node Validator Besides work: Linux English Japanese Working on a tech documentation translation Node.js 2019/10/1The target I set today Work: Working on logParsing API Besides work: Linux English Japanese Working on a tech documentation translation Node.js The result of today’s target Work: Working on logParsing API Working on Netdata API Besides work: Linux English Japanese Working on a tech documentation translation Node.js","link":"/zh-tw/schedule/2019/October/index.html"},{"title":"September 2019","text":"2019/9/30The target I set today Work: Working on logParsing API Besides work: Linux English Japanese Working on a tech documentation translation The result of today’s target Work: Working on logParsing API Besides work: Linux English Japanese Working on a tech documentation translation 2019/9/29The target I set today Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising The result of today’s target Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising 2019/9/28The target I set today Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising The result of today’s target Work: Besides work: Linux English Japanese Post a tech article Finish a tech documentation translation Node.js HackMD document organising 2019/9/27The target I set today Work: Make an auto-delete shell script to periodically clean Influxdb Besides work: Linux English Japanese The result of today’s target Work: Make an auto-delete shell script to periodically clean Influxdb Was told to do something else Besides work: Linux English Japanese 2019/9/26The target I set today Work: Make realtime traffic display API Besides work: Linux English Japanese The result of today’s target Work: Make realtime traffic display API Besides work: Linux English Japanese 2019/9/25The target I set today Work: Figure out how to get data from Influxdb with Node.js Besides work: Linux English Japanese The result of today’s target Work: Figure out how to get data from Influxdb with Node.js Besides work: Linux English Japanese 2019/9/24The target I set today Task: Working on logParsing API Complete the Tool Linux English Japanese The result of today’s target Task: Working on logParsing API Complete the Tool Linux English Japanese 2019/9/23The target I set today Task: Working on logParsing API Renew a wildcard SSL certificate Linux English Japanese The result of today’s target Task: Working on logParsing API Renew a wildcard SSL certificate Linux English Japanese 2019/9/22The target I set today Task: Post an article Completed a documentation of Stackdriver Logging Linux English Japanese The result of today’s target Task: Post an article Completed a documentation of Stackdriver Logging Linux English Japanese 2019/9/21The target I set today Task: Linux English Japanese The result of today’s target Task: Linux English Japanese 2019/9/20The target I set today Task: Working on logParsing API Deploy to production machine Linux English Japanese The result of today’s target Task: Working on logParsing API Deploy to production machine Linux English Japanese 2019/9/19The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Linux English Japanese 2019/9/18The target I set today Task: Working on logParsing API Deploy first version of Flow API Linux English Japanese The result of today’s target Task: Working on logParsing API Deploy first version of Flow API Linux English Japanese 2019/9/17The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Linux English Japanese 2019/9/16The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Linux English Japanese 2019/9/15The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Complete translated course so far Post an article Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Complete translated course so far Post an article Linux English Japanese 2019/9/14The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Post one article Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Post one article Linux English Japanese 2019/9/13The target I set today Task: Working on logParsing API Take a rest because you are having a cold. Post one article Finish one Qwiklab course Make a Qwiklab lesson documentation Linux English Japanese The result of today’s target Task: Working on logParsing API Take a rest because you are having a cold. Post one article Finish one Qwiklab course Make a Qwiklab lesson documentation Linux English Japanese 2019/9/12The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Working on SSH issue Linux English Japanese 2019/9/11The target I set today Task: Working on logParsing API Linux English Japanese The result of today’s target Task: Working on logParsing API Linux English Japanese 2019/9/11the result of my target yesterday Task: Working on logParsing API Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing API Linux English Japanese 2019/9/10the result of my target yesterday Task: Working on logParsing API Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing API Linux English Japanese 2019/9/9the result of my target yesterday Task: Finish one course of GCP Post an article Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing API Linux English Japanese 2019/9/8the result of my target yesterday Task: Finish one course of GCP Post an article Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish one course of GCP Post an article Linux English Japanese 2019/9/7the result of my target yesterday Task: Working on logParsing Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Finish one course of GCP Post an article Linux English Japanese 2019/9/6the result of my target yesterday Task: Working on logParsing Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Linux English Japanese 2019/9/5the result of my target yesterday Task: Working on logParsing Still working on it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Linux English Japanese 2019/9/4the result of my target yesterday Task: Working on logParsing Still working on it Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine No time for it Learn Node course 3 No time for it One interesting thing Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Linux English Japanese 2019/9/3the result of my target yesterday Task: Working on logParsing Still working on it Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine No time for it Learn Node course 3 No time for it One interesting thing No time for it Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Learn Node course 3 One interesting thing Linux English Japanese 2019/9/2the result of my target yesterday Task: Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Completed document Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Learn Node course 3 One interesting thing Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Working on logParsing Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Learn Node course 3 One interesting thing Linux English Japanese 2019/9/1the result of my target yesterday Task: Working on Stackdriver Logging - Using BigQuery and Stackdriver to Analyze BigQuery Usage Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Still working Linux English Japanese achieved except for set target yesterdaydescriptiontoday’s target Task: Stackdriver Logging - Logging with Stackdriver on Kubernetes Engine Documentation building - Baseline: Infrastructure - Cloud IAM: Qwik Start Learn Node course 3 One interesting thing Linux English Japanese","link":"/zh-tw/schedule/2019/September/index.html"},{"title":"January 2020","text":"2020/1/31Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/30Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book 2020/1/29Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/28Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/27Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/26Target and result today Work: Learning: Qwiklab Kubernetes - secret English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/25Target and result today Work: Learning: Qwiklab Kubernetes - secret English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/24Target and result today Work: Learning: Qwiklab Kubernetes - secret English Japanese Laravel documentation - Basic - Validation 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/23Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - dig deeper - Eloquent ORM relationships 2 BeePay API reading Reviewing Git case-insensitive note organising Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/22Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel documentation - dig deeper - Eloquent ORM relationships 2 BeePay API reading Reviewing Git case-insensitive note organising Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/21Target and result today Work: Learning: Qwiklab Kubernetes English Japanese Laravel 2 BeePay API reading Reviewing Reading Book MIS 82 個一定要懂的伺服器建置與管理知識 2020/1/20Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel 2020/1/19Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/18Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/17Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/16Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/15Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/14Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux 2020/1/13Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/12Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/11Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/10Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/9Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/8Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/7Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/6Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/5Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/4Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/3Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/2Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab 2020/1/1Target and result today Work: BeePay Learning: Kubernetes English Japanese Laravel Linux Qwiklab Exercise pull-ups","link":"/zh-tw/schedule/2020/January/index.html"},{"title":"November 2019","text":"2019-11-30赤いバラを買いました 短い 鳥が飛んでいます 落ちる 狭い ご主人 茶色 予約入りません 起きる 大学生 強い 大人 よう 休む 曜日を間違いました 野球は9人で人チームです ほぼ これは重要な書類です 彼はその事件に関係がない 経済 この三百ドルしました なお、雨の場合は中止です 私は四つの会社に投資しています 強調 料理がたくさん残りました 変化 後 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう ニュースで道の状況がわかります 森にクマがあります 休む どうして麒麟は首が長いですか あの歌手は有名でした 新しいゲームソフト買いました。なので、バイト代が全部無くなります 私はおああちゃんのことが好きです みんなは運動会の予定がわかります えっと、電車が遅れましたので、遅刻しました 今夜は蒸し暑いですから、明日は雨が降るでしょう 今日は何曜日ですか どこが賑やかですか あの喫茶店は静かですから、あそこでテストの勉強をしましょう 授業をした教師 あれはカーテンです 私の苦手なことは料理を作ることです 私は日本料理が好きです 私はマイカーを買いたいです 傘をさす なぜ大体のお店は試食を置きますか 今夜は蒸し暑いですから、明日は雨が降るでしょう どうして今日遅刻した なんで台湾の会社は大学生を雇いたくないのですか か 紙粘土 予備校生 腕時計 苺 サツマイモ 2019-11-29カナダの冬はとても寒いです 低い 私の夫はサラリーマンです 送る そこに大きな円を書いて 彼の日本語のレベルは私の同じくらいだ 決める その次の週は空いていますか 弱い 私には友達がたくさんいます 開く 財布は机の下にあった 晴れる いる 酸っぱい 八日からイギリスに行きます 教科書を閉じてください 私が手伝いましょう 違う 七日 今日はとても暑い 冷蔵庫に三つのリンゴーとオレンジがあります 宮沢さんは課長のことを、どう思いますか あの喫茶店は静かですから、あそこでテストの勉強をしましょう これは重要な書類です 私の苦手なことは料理を作ることです 弟は父の性格がわかります バカ！言い訳するな お釣りをください 苺 広告 校長 紅茶 社員 ペット 牛 フライト ポルトガル 蝉 スーツケースに詰める ツアガードはあなたの旅行を楽しくする興味深い情報を知っているだろう ツアーガイド 苺 2019-11-28買う 起こす 変える 少し疲れました 彼は荷物を網棚にあげた 始める 探す 黄色い 手紙が届くのに三日かかりました 彼はシートベルト締めた 酸っぱい 辛い 八日からイギリスに行きます 店員は若い女の人でした あの大き建物はなんですか 決まる 五日 腰 冷たい飲み物ください お手洗い 線 ほとんど 私たちは二階に上がった 国内 電気がついたままですよう 私たちは今、結婚資金を貯めています へる 建設 計画を一部変更しましょう 商品 この町は人口が増えた 合格者が発表された ほぼ 会談 上がる レシートをください 弟は学業を続けたがります 夏は涼しくありませんでした 昨日、何処かに行きましたか いいえ、どこも行きませんでした 酸っぱい 弟は父の性格がわかります バカ！言い訳するな ご飯を食べた人 なぜ台湾の会社は大学生を雇いたくないのですか 和食と言えば、寿司や味噌汁や天ぷらなどです なんで台湾の会社は大学生を雇いたくないのですか 日本語が上手になる 飛行機が二時間遅れました。なので、到着時間も遅くなります 引き出しにハムスターが一匹います 私は風邪をひきました。なので、映画館に行きませんでした 今夜は蒸し暑いので、蚊が多くなりました 私は魚が嫌いです 隣人 冷蔵庫 マイカー フクロウ ツアーガイドはあなたの旅行を楽しくする興味深い情報知っているだろう ツアーガイドはあなたの旅行を楽しくする興味深い情報を知っているだろう 2019-11-27体 帰国することに決めました 軽い 昨日、友達にあった 小さい花が咲いています 書き直す 強い 昨日 左 お名前をカタカナで書いてください いつか ほぼ 引越しを業者に頼んだ 今後ともよろしくお願いします 交渉 生産 進める 作業 ソフト 国会 特徴 商品 利用 可能 消える 銀行 処理 宮沢さんは課長のことを、どう思いますか 机の上に雑誌があります 私の得意なことはギターを弾くことです 五日 ほぼ 私は実家に帰りたいです ご飯を食べている人 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 商品 飛行機が二時間遅れました。なので、到着時間も遅くなります 傘は長いです 床にアリがいます テストはいつですか 明日や明後日再来週などですね 彼は会長でした どれが綺麗ですか なぜ台湾の会社は大学生を雇いたくないのですか ニュースで道の状況がわかります 弟は父の性格がわかります 私は風邪をひきました。だから、明日学校に行きたくありません 私は歌を歌うことができます なんで台湾の会社大学生を雇いたくないのですか 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 部長は仕事ができます レンタサイクル 隣人 大きな竜巻 冷蔵庫 美術館 乗客 葉が落ちます 調味料 弟は父の性格がわかります 隣人 冷蔵庫 2019-11-26今日は日本語の授業があります 髪 次はいつ会いましょうか 上げる 古い 上司が一杯、飲もう。と言った 使う 軽い 彼女はイタリア語ができます 体 彼はタオルで顔を拭きました 座る 九日荷物が届きます 上を向いて 辛い 時計を見たらちょうど三時だった 細い 違う 息子は六つになりました 汚い 方 いずれ 彼女の大きな帽子はとても目立つ 調べる 国会 彼は非常に高い技術を持っている 女性 開発 比べる 電車のドアが開きました 十分 残る 今月と先月の売り上げを比べた 従来 彼は行政を改革したいと思っている 変化 処理 それはどういう意味ですか 中心 一般 これは世界最大の船です 消える バカ、言い訳するな 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう ゴミ箱にペットボトルがあります 向日葵は草より綺麗です 夏は涼しかったです 誰もいません 学生だはなかった どれも要りません ニュースで道の状況がわかります 病人が元気になる 日曜日が暇です 部屋にベッドがあります 私は鉛筆で字を書く 自転車とバイク、どちらが便利ですか 処理 私はもっと頑張りたいです 宮沢さんは課長のことを、どう思いますか 猿 キリン 中学生 日本 おやつ ガスコンロ えさ 果物 その男性は使い捨て髭剃りで顎鬚を剃っている ニュースで道の状況がわかります センチメートル 綺麗 嫌い 有名 処理 宮沢さんは課長のことを、どう思いますか 2019-11-25家に帰ろう 鳥が飛んでいます 工事は3月まで続きます 若い 郵便局で切手を買いました 触る 千円貸してください 始まる 教科書を閉じてください お先にどうぞ 後ろを向いて 予約要りません 辛い 違う 私は平仮名を全部読めます 上る 方針 いずれ 日本での生活は楽しいです 残る 問題 実現 料理がたくさん残りました まず相手の動きを見ましょう 電気がついたままですよう 今回 ほとんど 私は四つの会社に投資しています 国は国語教育を強化しています もう 報告 情報 強調 代表 より 良い家を選ぶのは難しい 宇宙人は存在すると思いますか 台北駅はどこですか 誰もいません 森に熊がいます 飛行機が二時間遅れました。なので、到着時間も遅くなります 広い部屋 明日の食券をください なんで今日私の家に来ましたか 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 辛い 違う 授業をする教師 私は日本語が少しできます 彼は実家に帰りたがります えっと、電車が遅れました、だから、遅刻しました バカ、言い訳するな 私は日本語が大体できます どうして台湾の会社は大学生を雇いたくないのですか 田舎は都市ほど便利ではありません 私はおばあちゃんのことが好きです 温かい手 飲み物を買います 私の嫌いのことは部屋を掃除することです なぜ大体のお店は試食を置きますか 原稿を改訂する 友達がコーヒーショップで集まっている 茶髪 かっこいい男 フクロウ 私は物理の基礎はしています 質問する 違う ばか！言い訳するな 違う 2019-11-24言う こう おかげさまで元気です 行く 近い 腕 その次の週は空いていますか 消す 耳 軽い 教科書を閉じてください お店はもう閉まっていました 財布は机の下にあった 平仮名 三日 彼は時々遅刻します 違う こっち 曜日を間違いました 野球は9人で人チームです 昨日から腰が痛い このコートはとても暖かい 彼はその詩を用いて自分の気持ちを伝えた 部長を除く全員が土曜日も働いた 信号が青に変わりました 電気がついたままですよう 工場 この動物園は日本一の規模です 株 会談 特徴 評価 来年から新しい制度が始まります ほとんど 目立つ 交差点で事故が発生した 続ける 対立 方向 土地 建設 和食と言えば、寿司や味噌汁や天ぷらなどです 教科書を閉じてください 違う 長い傘 なんで今日私の家に来ましたか 机の上に雑誌があります 私はおばあちゃんのことが好きです なんでこんな時間に学校にいないのですか 新しいゲームソフトを買いました。だから、古いソフトを売りました 電気がついたままですよう 今日、何か買いますか はい、オレンジを買います あの喫茶店は静かなので、あそこで勉強する人が多いでしょう ほとんど 今夜は暑いです。なので、蚊が多くなりました 私はもっと頑張りたかったです 飛行機は二時間遅れました。なので、到着時間も遅くなります 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 違う 彼は学校の先生ですから、子供の親からのプレッシャーが多いでしょう 私はおばあちゃんのことが好きです 寝る猫 中村さんは昨日夜十時まで仕事をしましたから、残業代がたくさんもらえる多いでしょう ベッド 布団 屋上 子犬 脈を取る かっこいい 飛行機が二時間遅れました。なので、到着時間も遅くなります 2019-11-233月は仕事が忙しい 見せる 生きる 言葉 書く 彼は足が長い 待つ 郵便局で切手を買いました 鳥が飛んでいます 軽い 悲し 大人 掛ける 彼女は眠いようです 彼は昼過ぎに来ます 強い お願い 曜日 柿の木に身がたくさんなっています 特徴 方向 彼は就職試験を受けた 生産 導入 住宅 文章 後 開発 部分 強調 コンピューター 輸入 仕事がほぼ終わりました 多く この段階では決断するのはまだ早い 除く 新しいコンピューターを買った 彼は選挙に出るつもりだ 力 報告 私は四つの会社に投資しています 企業 一般 下手な選手 中村さんは昨日10時まで仕事しましたので、残業代がたくさんもらえるでしょう 軽い 飛行機が二時間遅れました。なので、到着時間も遅くなります 明日の食券をください 和食といえば、寿司屋、味噌汁や、天ぷらなどです 母は料理の方法がわかります 学食の料理はまずいです。このレストランの料理もまずいです 日本語を上手にする 貯金箱40個のコインがあります 私は日本語がわかります 何も食べません どうして台湾の会社は大学生を雇いたくないのですか えっと、電車が遅れましたので、遅刻しました そっか、今度早く家を出ろ 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります ボタンをおっす あのバカは2本の鉛筆を箸にして、ご飯を食べます 飛行機が二時間遅れました。なので、到着時間も遅くなります 和食と言えば、寿司屋、味噌汁や、天ぷらなどです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 机の上に雑誌があります 台風 晩御飯 一眼レフカメラ ノートパソコン うめ 広告 親戚 雨の後、虹が見られるかもしれません め 机の上に雑誌があります 2019-11-22もらう 私たちのチームはその試合で負けた 入れる また会いましょう 会議は四時に終わります 鳥が飛んています 駅まで歩きましょう 同じ 午後 直ぐ 私は毎日、日記を付けています 教える 黄色い 私は二日待った 鳥が飛んでいます これはかなり金がかかった 八つ 予約入りません 火曜日に会議があります これは医者のためのサイトです 眼鏡が見つかりません 眼鏡が見つかりません 他 方向 報告 いい方法思いつきました 特徴 種類 彼は事故で怪我をしました 関係 状態 帰ったら、まず手を洗いましょう 今夜は大いに語りましょう 彼は行政を改革したいと思っている 一般の方はこちらの席へどうぞ それはどういう意味ですか 会談 建設 計算 住宅 存在 販売 解決 生活 消える 与える 新しいゲームを買いました。なので、バイト代が全部なくなりました 何で学校に行くのですか 下手な選手 新しいゲームソフトを買いました。だから、古いゲームを売りました どうして台湾の会社は学生を雇いたくないのですか 報告 私は風邪をひきました。だから、映画館に行きませんでした 母は料理を作ることができます 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は泳ぐことができます そっか、今度早く家を出ろ 昨日、何処かに行きましたか いいえ、どこも行きませんでした 彼は会長ではありませんでした えっと、電車が遅れたので、遅刻しました シャワーを浴びる象 どうして麒麟は首が長いですか 氷山が小さくなる なぜ大体のお店は試食を置きますか 彼女は社長です 私は日本語が大体できます ジュースはコーヒーほど高くありません えっと、電車が遅れたから遅刻しました コーヒーショップ 消しゴム 陽傘 えさ おやつ 栓抜きありますか サツマイモ 調味料 フロント 2019-11-21テストでいい点を取った その次の週は空いてますか 今月 使う 彼はタオルで顔を拭きました 授業 大学に行ってもっと勉強したいです 引く 次はいつ会いましょうか 柿の木に実がたくさんなっています 曜日を間違えました 強い お名前をカタカナで書いてください 夜 予約入りません 八日からイギリスに行きます 二つ 100 夏 財布は机の下にあった 32パージを開いてください 生産 従来 建設 トラブルがやっと解決した 彼女は大きな帽子はとても目立つ 対する 比べる 政府 彼は非常に高い技術を持っている 計画 目立つ 方向 事務的な処理に1週間かかります 討論 会談 対策 決定 特徴 段階 これからより一層努力します 交差点で事故が発生した 強化 私はマイカーを買いたいです 私は好きなことは音楽です 予約は要りません 彼女を幸せにする ゴミ箱に猫がいます どうして台湾の会社は大学生を雇いたくないのですか 彼は社員です 私は日本語が大体できます どうして今日遅刻した 刺身をください 梅と桜 私の趣味はバスケットをすることです 方向 飛行機は二時間遅れました。なので、到着時間も遅くなります 会談 特徴 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 犬と猫と兎、どれが好きですか 私は寿司が好きです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 何も買いません なんでこんな時間に学校にいないのですか 何で学校に行くのですか 私は日本料理が好きです なんで台湾の会社は大学生を雇いたくないのですか どうして台湾の会社は大学生を雇いたくないのですか 昨日、どこに行きまhしたか。昨日、コンサートに行きました スーパー えさ おやつ 布 高層ビル キャベツ 芸人 ライブ ボルトがる 下手 炒める 飛行機が二時間遅れました。なので、到着時間も遅くなります かっこいい男 葉が落ちます 新しいゲームソフトを買いました。なので、バイト代が全部無くなります えさ おやつ 2019-11-20遠い 持つ 赤ん坊が笑っています 一つ 遅い きく 彼はもう帰りました 今 置く 変える 彼に手紙を書きました 強い 時計を見たら、ちょうど3時だった 彼女は三人の子供の母親だ 32ページを開いてください 小さい花が咲いています 側 水 ミーティング 私は犬が大好きです よう 今週 曜日を間違いました 財布は机の下にあった 彼は時々遅刻します 彼は行政を改革したいと思っている 強い 建設 作業 ほとんど 交差点で事故が発生した 全国 国内 生活 語る 病院 生産 計画を一部変更しましょう システム 強化 いずれ 午後四時までです なんで台湾の会社は大学生を雇いたくないのですか 私はピーマンが嫌いです 学生ではない どうして今日遅刻しましたか 曜日を間違えました どこが賑やかですか お爺さんは昔の記憶を忘れたがります 財布は机の下にあった 父は台湾料理ができます すみません、今は何時ですか どこも行きません 彼女は飛行機を運転することができます 私はもっと頑張りたかったです 建設 弟は父の性格がわかります ドアを開ける 私はノートパソコンをテレビにする 交差点で事故が発生した 生産 シャワーを浴びる象 先生の隣に父と母がいます なぜ台湾の会社は大学生を雇いたくないのですか 私の苦手なことは料理を作ることです 傘は長くありません 私の趣味は映画を見ることです 先生は難し本を読むことができます 広い部屋をください 今夜は蒸し暑いですから、明日は雨が降るでしょう なんでこんな時間に学校にいないのですか あの喫茶店が静かなので、あそこで勉強する人が多いでしょう インターネットで新幹線の時刻表が分かります 私は日本語が大体できます 夜市が賑やかです バカ！言い訳するな 私は風邪をひきました。なので、映画館に行きませんでした 何曜日が暇ですか どこが賑やかですか 夜市はどこですか 私は世界一周をしたくありませんでした キャベツ 烏龍茶 レタス ゴミ箱 鶏 着物 ロブスター 雄鶏 かっこいい男 18 ち 私は日本語が大体できます かっこいい男 2019-11-19その次の週は空いていますか 彼はタオルで顔を拭きました 建てる 立つ 私が行きましょう 切る つぎはいつ会いましょうか 載せる かれは時々遅刻します こっち 私が手伝いましょう 息子は六つになりました 宿題は自分でやりなさい クーラーはまだ治りません 腰 口 黄色い 影響 強調 社会 残る 運動会は9時開始です 集める 合格者が発表された 方針 対策 採用 コンピューター 消える 比べる その問題に関する記事を読みました 彼女は大きな帽子はとても目立つ これは世界最大の船です それはどういう意味ですか 管理 部分 ほとんど 彼は行政を改革したいと思っている 国会 予定 この服は三百ドルしました 彼は時々遅刻します なぜ台湾の会社は大学生を雇いたくないのですか 音量を大きくする 台北駅はあそこです 弟さんにゲームをあげました なんで今日私の家に来ましたか 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 明日の食券をください 本棚に小説と雑誌があります 私は風邪をひきました。だから、明日は学校に行きたくありません あの喫茶店は静かですから、あそこでテストの勉強をしましょう 今夜は蒸し暑いですから、明日は雨が降るでしょう 今日、何か買いますか いいえ、何も買いません ほとんど まず、次に、そして、それから、最後に 私はピーマンが嫌いです 私は懐石料理を一番好きです 母は日本料理を作るできます 母はペットと海外旅行をしました 中村さんは昨日10時まで仕事しましたので、残業代がたくさんもらえるでしょう 私は日本語ができます 病人が元気になる 私は懐石料理がすごく好きです 私は魚が嫌いです スーパーは夜市ほどうるさくありません なぜ大体のお店は試食を置きますか どうして麒麟は首が長いですか 私は頑張りたかったです どうして台湾の会社は大学生を雇いたくないのですか ビジネスマン 生まれる 本棚 サツマイモは、焼いてもあげても美味しい 調味料 蝉 クロサイが草原を歩いている れ 2019-11-18九份は賑やかです 彼はタオルで顔を拭きました 私の夫はサラリーマンです いつも 緑 子供 遊ぶ 今朝は早く家を出ました 首 消す 酒 その次の週は空いてますか 次はいつ会いましょうか 黄色い 多分 お願い 昼 冷たい 彼はシートベルトを締めた 彼女は茶色の靴を履いています 男の人が私たちに話しかけた 解決 彼は食品工場で働いています 会社 私は彼から大きな影響受けました 変化 彼は新製品に興味を示している 決定 遠くに彼女の姿が見えた それはどういう 彼はタオルで顔を拭きました 検討 備える 彼女は大きな帽子はとても目立つ その次の週は空いていますか 次はいつ会いましょうか 政権が交代した 部分 中心 黄色い 彼は行政を改革したいと思っている 我が社の経営はうまくいっています 消える 比べる 選挙 交渉 何で学校に行くのですか 夜市はスーパーよりうるさいです どうして麒麟は首が長いですか なんでこんな時間に学校にいないのですか 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう それはどういう意味ですか 彼はタオルで顔を拭きました 飛行機が二時間遅れました。なので、到着時間も遅くなります 彼女は大きな帽子はとても目立つ うそ 今夜は蒸し暑いので、蚊が多くなります 上手なコック 先生はテストの解答がわかります 彼は行政を改革したいと思っている なぜ大体のお店は試食を置きますか どうして台湾の会社は大学生を雇いたくないのですか 消える 比べる 彼は学校に来ませんでした 新しいゲームソフトを買いました。だから、古いソフトを売りました 明日の食券をください 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は風邪をひきました。だから、明日学校に行きたくありません なんで今日私の家に来ましたか 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 私の嫌いなことはバスケットをすることです 引き出しにハムスターが一匹います えっと、電車が遅れたので、遅刻しました あなたのカバンはこれです あの喫茶店は静かですから、あそこでテストの勉強をしましょう お爺さんは昔の記憶を忘れたがります 私は寿司が好きです 中村さんは昨日よる十時まで仕事しましたので、残業がたくさんもらえるでしょう 私は懐石料理がとても好きです あの喫茶店は静かので、あそこで勉強をする人が多いでしょう 明日の食券をください 魔法瓶 広告 大きな竜巻 宝石 味噌汁 皿 文房具 記憶 定食 愛妻弁当 フクロウ 調味料 7点9センチメートル 中村さんは昨日よる十時まで仕事しましたので、残業代がたくさんもらえるでしょう 調味料 2019-11-17見る 午前 飛行機 出来る 今、朝ご飯を作っています 朝から頭が痛い それ 赤い 行く 帰る 親の愛は有難い 笑う 約束を忘れないてください 遅い カナダの冬はとても寒いです 言葉 年 昨日タイカレーを食べました 彼は足が長い 数 会う 後ろ しめる 大人 その人には二回に会った 彼女は茶色の靴を履いています お手洗い 十日後に帰ります お名前をカタカナで書いてください 喉が渇きました 後ろ向いて 私は世界旅行をしたい 重要 システムの構成を変えてみました この本を内容を説明してうください 今夜は大いに語りましょう 彼は非常に高い技術を持っている 商品 企業 処理 みんな私たちに期待しています 災害に備えて大量の水を買い込んだ 私は四つの会社に投資しています 国は国語教育を強化しています 強調 従来 備える 写真はいい思い出になります 全国 内容 まあ今回は許してあげよう 部長を除く全員が土曜日も働いた 種類 のち なんで今日私の家に来ましたか 絵を描く 彼は小学校の先生なので、毎日四時ちょうどに家に変えます 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね どうして台湾の会社は大学生を雇いたくないのですか あの人は木を登ることができます 何で学校に行くのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 母は実家に帰りました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 夜市はどこですか あなたのカバンはこれです なぜ大体のお店は試食を置きますか バカ！言い訳するな 私は王建民ほど有名ではありません なんでこんな時間に学校にいないのですか 今夜は蒸し暑いので、蚊が多くなりました えっと、電車は遅れましたので、遅刻しました 私は風邪をひきました。なので、映画館に行きませんでした 中村さんは昨日夜十時まで仕事をしましたので、残業代がたくさんもらえるでしょう 私は料理を作ることができます 私のカバンはどれですか 彼は社長でした どうして台湾の会社は大学生を雇いたくないのですか 教室は静かではありません 私は自分の力で仕事を探します なんで台湾の会社は大学生を雇いたくないのですか 広い部屋をください そっか、今度早く家を出ろ なぜ台湾の会社は大学生を雇いたくないのですか 新しいゲームソフトを買いました。だから、古いソフトを売りました えっと、電車が遅れましたから、遅刻しました 授業をしている教師 飛行機が二時間遅れました。だから、それで怒って売る人が多いでしょう 私は世界一周をしたくありません カバンに香水があります 私は頑張りたかったです 新しいゲームソフトを買いました。なので、バイト代が全部なくないました 昨日、どこに行きましたか 昨日、コンサートに行きました 私は茶碗蒸しがあまり嫌いではありません 姉 液晶テレビ 携帯ゲーム 医者は、患者の脈を取っている アリクイ フットボール センチメートル 葉が落ちます 緑色の蝉 め 2019-11-16わかる 今年 取る 戻る 直ぐ行きます この靴はとても軽い 彼は私にノートパソコンをくれました 二つ 米 八つ 愛する 後ろ向いて 悲し お名前をカタカナで書いてください 僕は新しい靴が欲しいです 六つ 千円貸してください 大丈夫 上る 目 なんでこんな時間に学校にいなにのですか 八日からイギリスに行きます なんでこんな時間に学校にいないのですか なんでこんな時間に学校いいないのですか 終わり 経営 経済 採用 宇宙人は存在すると思いまうか 報告 彼は非常に高い技術を持っている お名前をカタカナで書いてください 何で学校に行くのですか これは世界最大の船です 従来 いずれ 結果 飛行機が二時間遅れました。なので、到着時間を遅くなります 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は風邪をひきました。なので、映画館に行きませんでした どれが綺麗ですか たいです 飲み物を買いました 今夜は蒸し暑いですから、明日は雨が降るでしょう なぜ台湾の会社は大学生を雇いたくないのですか なんでこんな時間に学校にいないのですか なぜ大体のお店は試食を置きますか 犬は大きくありません なんでこんな時間に学校にいないのですか なんで今日私の家行きましたか？ 私は日本料理を作ることが全然できません なんで台湾の会社は大学生を雇いたくないのですか 彼は非常に高い技術を持っている どうして今日遅刻した 何で学校に行くのですか 従来 眠くなる どうして麒麟は首が長いですか どうして台湾の会社は大学生を雇いたくないのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 病人が元気になる えっと、電車が遅れたから遅刻しました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 部屋が綺麗になる 何で学校に行くのですか 私はもっと頑張りたかったです 夜市は賑やかです 佐々木さんはサラリーマンではありませんでした 何で学校に行くのですか 私の苦手なことは料理を作ることです バカ、言い訳するな 昨日、何処かに行きましたか はい、コンサートに行きました 氷山が小さくなる レシートください 佐々木さんはサラリーマンでした そっか、今度早く家をてろ どれも要りません 飛行機が二時間遅れました。なので、到着時間も遅くなります 私はもっと頑張りたかったです 何で学校に行くのですか 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 書店 期末レポート 引き出し 虹 教授が図を説明する 葉が落ちます 医者は患者の脈を取っている 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 葉が落ちます 2019-11-15私は電車で通学しています 質問のある方はどうぞ 郵便局で切手を買いました 払う また会いましょう 私たちのチームはその試合で負けた 息子は六つになりました 曇る 手紙が届くのに三日かかりいました 教科書を閉じてください なぜ大体のお店は試食を置きますか 多分 六つ 四月に大学に入学しました なぜ大体のお店は試食を置きますか 付ける 時計を見たらちょうど三時だっあ 何 100 時の経つのは早い なんで今日私の家に来ましたか 触る 見つかる 他 報告 制度 語る 増える プログラム 銀行は三時まで開いています どうして台湾の会社は大学生を雇いたくないのですか なぜ大体のお店は試食を置きますか いずれ 作業 資金 行う 動き 変わる 実現 部分 なぜ大体のお店は試食を置きますか これは世界最大の船です なんで今日私の家に来ましたか 文章 姿 十分 私は風邪をひきました。だから、映画館に行きませんでした 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 授業をした教師 飛行機が二時間遅れました。なので、到着時間も遅くなります いずれ なぜ大体台湾のお店は試食を置きますか これは世界最大の船です どうして台湾の会社は大学生を雇いたくないのですか 私の得意なことはギターを弾くことです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました あの喫茶店は静かなので、あそこで勉強する人が多いでしょう いいえ、違います なので、到着時間も遅くなります いずれ どうして台湾の会社は大学生を雇いたくないのですか どこが賑やかですか 私はゲームが好きです 私は世界一周をしたくありませんでした そっか、今度早く家を出ろ お釣りをください なんで今日家に来ましたか 何曜日が暇ですか 私は日本に行きます 今日、何か買いますか いいえ、何も買いません バカ、言い訳するな 新しいゲームソフトを買いました。だから、古いソフトを売りました 授業をしている教師 どうして今日遅刻しました 飛行機は二時間遅れました。だから、それで怒っている人が多いでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります なんで台湾の会社は大学生を雇いたくないのですか どうして麒麟は首が長いですか ニュースで道の状況がわかります なんで今日私の家に来ましたか えっと、電車が遅れたので、遅刻しました バカ、言い訳するな なぜ台湾の会社は大学生を雇いたくないのですか 私は風邪をひきました。だから、明日学校に行きたくありません 日本は台湾ほど暑くありません あの喫茶店は静かですかあ、あそこでテストの勉強をしましょう 上手なコック 私は学生であはりませんでした なんで台湾の会社は大学生を雇いたくないのですか 今夜は蒸し暑いですから、明日は雨が降るでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります ペットを飼いましょうよ どうして台湾の会社は大学生を雇いたくないのですか 音量を大きくする なぜ台湾の会社は大学生を雇いたくないのですか どこも行きません 九份は賑やかです 私は部長のことが嫌いです なぜ台湾の会社は大学生を雇いたくないのですか 弟は父の性格がわかります なんで台湾の会社は大学生を雇いたくないのですか 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 役所の人はおばちゃんに綺麗なカレンダーをくれました なんで台湾の会社は大学生を雇いたくないのですか 今夜は蒸し暑いですから、明日は雨が降るでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります コンサート 親戚 トラ 梅 書店 中学生 なぜ台湾の会社は大学生を雇いたくないのですか 屋上 なんで台湾の会社は大学生を雇いたくないのですか 飛行機が二時間遅れました。なので、到着時間も遅くなります 2019-11-14みんなにお菓子をあげましょう 私の夫はサラリーマンです おかげさまで元気です 楽しむ 忘れる 美し 彼は数学を教えています 新しい仕事を見つけました 帰る 日記 彼は足が長い 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 帰国することに決めました 7つ よう お手洗い 息子は六つになりました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 欲しい 9 六つ 決まる 私は風邪をひきました。なので、映画館に行きませんでした ここの料理はまずい 下 彼女は眠いようです 楽しい 小さい花が咲いています このコートはとても暖かい そこには私一人しかいなかった 私は腕時計を4つ持っています 風邪 こっち 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 息子は六つになりました 普及 飛行機が二時間遅れました。なので、あそこで怒っている人が多いでしょう 飛行機が二時間遅れました。だから、あそこで怒っている人が多いでしょう 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は風邪をひきました。なので、映画館に行きませんでした 飛行機が二時間遅れました。だから、あそこで怒っている人が多いでしょう 政権 状態 この商品はよく売れている 次は全国のお天気です 体重がかなり減りました 彼は選挙にですつもりだ 信号が青に変わりました 合格者が発表された 今夜は大いに語りましょう この服は三百ドルしました 消える 私は風邪をひきました。なので、映画館に行きませんでした 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 飛行機が二時間遅れました。だから、あそこで怒っている人が多いでしょう 帰ったら、まず手を洗いましょう 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 部分 彼はその詩を用いて自分の気持ちを伝えた 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 国会 変わる 強調 事務的な処理に1週間かかります 用いる より 研究 彼はパーティー会場を提供してくれました 私は風邪をひきました。だから、映画館に行きませんでした 明らか 住宅 バカ！言い訳するな ご飯を食べる人 あの喫茶店が静かあので、あそこで勉強する人が多いでしょう 部分 えっと、電車が遅れたので、遅刻しました 今夜は蒸し暑いから、明日は雨が降るでしょう あの喫茶店は静かですから、あそこでテストの勉強をしましょう 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 病人が元気になる 私は風邪をひきました。なので、明日は学校に行きたくありません 私は部長のことが嫌いです 佐々木さんはサラリーマンではありませんでした 私はゲームソフトを買いました。だから、古いソフトを売りました 今日は何曜日ですか 日本は台湾より寒いです そっか、今度早く家を出ろ 私の趣味は料理を作ることです 台北駅はあそこです 私の趣味は映画を見ることです 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は世界一周をしたくありませんでした 中村さんは昨日夜十時まで仕事しましたから、今日は来ませんよね 飛行機が二時間遅れました。なので、到着時間も遅くなります どうして今日遅刻した 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 飛行機が二時間遅れました。なので、到着時間も遅くないrます 浅い川 何も買いません 飛行機が二時間遅れました。なので、到着時間も遅くなります 飛行機が二時間遅れました。なので、到着時間も遅くなります それはカーテンです 飛行機が二時間遅れました。なので、到着時間も遅くなります 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は味噌汁が全然嫌いではありません 飛行機が二時間遅れました。なので、到着時間も遅くなります 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう 彼は小学校の先生なから、子供の親からのプレッシャーが大きでしょう 飛行機が二時間遅れました。なので、到着時間も遅くなります 宮沢さんは課長のことを、どう思いますか どうして麒麟は首が長いですか えっと、電車が送れっましたから、遅刻しました 今夜は蒸し暑いので、蚊が多くなります 広告 烏龍茶 解答 プル レストラン 向日葵 学長 予備校生 どうして麒麟は首が長いですか ボールペン 18 さい どうして麒麟は首が長いですか どうして麒麟は首が長いですか 2019-11-13難しい 彼は足が長い 質問 大学 生きる 送る 知る 私の夫はサラリーマンです 私は去年、フランスへ行った バカ！言い訳するな 消す 来る 場合 何か飲み物が欲しいな バカ、言い訳するな！ 千円貸してください 私はタバコが嫌いです その店の前で会いましょう バカ、言い訳するな 時計を見たら、ちょうど3時だった 彼女は三人の子供の母親だ 多い 彼女は命令に従わなかった 改革 計画を一部変更しましょう 今夜は多い語りましょう 彼は足が長い えっと、電車が遅れたので、遅刻しました 私の夫はサラリーマンです 夢を実現するには、努力が必要です えっと、電車が遅れたので、遅刻しました 消える 私にはたくさんのお金が必要だ よく答えがわかりましたね バカ、言い訳するな バカ、言い訳するな そっか、今度早く家を出ろ 今夜は大いに語りましょう そっか、今度早く家を出ろ 消える えっと、電車が遅れたので、遅刻しました 彼は事故で怪我をしました 試合の相手は誰ですか 目立つ 国会 示す えっと、電車が遅れたので、遅刻しました 彼は就職試験を受けた 彼はロボットの研究をしています そっか、今度早く家を出ろ 対策 先生は討論を始めたがります あの喫茶店は静かですから、あそこでテストの勉強をしましょう 中村さんは昨日夜10時まで仕事をしましたので、残業代をたくさんもらいるでしょう これをください 私の嫌いなことはバスケットをすることです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります そっか、今度早く家を出ろ 私の趣味は本を読むことです どうして今日遅刻した？ えっと、電車が遅れたので、遅刻しました 私の苦手なことは料理を作ることです 私は懐石料理が非常に好きです そっか、今度早く家をでろ 中村さんは昨日夜10時まで仕事しましたから、今日来ませんよね あの喫茶店は静かなので、あそこで勉強する人が多いでしょう 今日は何か買いますか はい、オレンジを買います 今夜は蒸し暑いので、明日は雨が降るでしょう 私は冬が嫌いです 私は懐石料理がとても好きです 今夜は蒸し暑いので、蚊が多くなりました 彼は小学校の先生なので、毎日よじちょうど家に帰ります 川の岸に桜の木があります 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 私は自分の力で仕事を探します えっと、電車が遅れたから遅刻しました テストはいつですか 明日や、明後日や、来週などですね 昨日、何処かに行きましたか はい、コンサートに行きました ゴミ箱にペットボトルがあります あの喫茶店は静かなので、あそこで勉強する人が多いでしょう 病人が元気になる 私は風邪をひきました。だから、明日学校に行きたくありません 動物園のパンダは小さくありません 私は刺身があまり好きではありません 私の趣味は野球をすることです 弟は父の性格がわかります オートバイ 広告 布団 大きな竜巻 剣道 美術館 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 陽傘 フクロウ 物理学 茶髪 新ゲームソフトを買いました。だから、古いスフとを売りました 私は風邪をひきました。だから、明日学校に行きたくありません 病人が元気になる 新ゲームソフトを買いました。だから、古いソフトを売りました 私は風邪をひきました。だから、明日学校に行きたくありません 広告 私は風邪をひきました。だから、明日は学校に行きたくありません 新しいゲームソフトを買いました。だから、古いソフトを売りました 新しいゲームソフトを買いました。だから、古いソフトを売りました 広告 2019-11-12乗る 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 言葉 赤いバラを買いました 彼はまだ若いです 彼は窓側の席に座った 覚える お腹 今夜は蒸し暑いので、蚊が多くなりました 鼻がかゆいです これはかなり金がかかった 髪の毛が伸びたね 答える 時計を見たらちょうど3時だった 大人 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 今夜は蒸し暑いので、蚊が多くなりました 時計を見たら、ちょうど3時だった 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう 彼はとても優しい人です 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 腰 火曜日に会議があります 掛ける 八日からイギリスに行きます 強調 この服は三百ドルしました 合格者が発表された 中村さんは昨日夜10時まで仕事をしましたので、残業代がたくさんもらえるでしょう 宇宙人は存在するとどう思いますか 彼は小さな会社に勤めています 処理 続ける 生まれる 計算 後 今夜は蒸し暑いので、蚊が多くなりました 規模 彼がクラスの代表だ 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 私は四つの会社に投資しています 企業 種類 提供 中村さんは昨日夜10時まで仕事をしましたので、残業代がたくさんもらえるでしょう 今日の新聞どこに置いた 私は納豆が全然好きではありません 今夜は蒸し暑いので、蚊が多くなりました 氷山が小さくなる あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 何も食べません 弟は父の性格がわかります どうして今日遅刻した 中村さんは昨日夜10時まで仕事しましたので、残業代がたくさんもらえるでしょう どうして今日遅刻した？ 何処かに行きましたか いいえ、どこも行きませんでした 中村さんは昨日夜10時まで仕事しましたから、今日は来ませんよね 今夜は蒸し暑いから、明日は雨が降るでしょう 弟は父の性格がわかります どうして今日遅刻した 彼女はマイカーを買いたがります どうして今日遅刻した 誰もいません 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 私の苦手なことは料理を作ることです 夜市はスーパーよりうるさいです あの喫茶店で静かですから、あそこでテストの勉強をしましょう 引き出しにハムスターが一匹います えっと、電車が遅れたから遅刻しました お釣りをください 日曜日が暇です ゲーム機 プール その男の人はフロントで働いている 買い物カート えっと、電車が遅れたから遅刻しました どうして今日遅刻した？ あの喫茶店が静かですから、あそこでテストの勉強をしましょう えっと、電車か遅れたから遅刻しました えっと、電車が遅れたから遅刻しました 2019-11-11勉強 広い カナダの冬はとても寒いです 起きる 考える 起こる 変える 彼はまだ若いです 忘れる あの喫茶店は静かですから、あそこでテストの勉強をしましょう 私たちのチームはその試合で負けた 少し疲れました 少ない １つ 一日 八 土曜日 先月の七日に孫が生まれました あの喫茶店は静かですから、あそこでテストの勉強をしましょう 私の祖母は100歳です この部屋は寒いです 八日からイギリスに行きます 曲がる ご飯 彼が来た目的がわかりません 彼は食品工場で働いています 新聞 彼は小学校の先生ですから、子供の親のプレッシャーが大きでしょう あの喫茶店は静かですから、あそこでテストの勉強をしましょう 計画 この服は三百ドルしました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう 彼は小学校の先生ですから、子供の親からのプレッシャーが大きいでしょう あの喫茶店は静かですから、あそこでテストの勉強をしましょう 八日からイギリスに行きます 報告 減る 集める 以上 一緒に対策を考えましょう 今夜は蒸し暑いから、明日は雨が降るでしょう 宇宙人は存在すると思いますか この服は三百ドルしました 加える 姿 備える それはどういう意味ですか 合格者が発表された 彼は事故で怪我をしました 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 一部 相手 交差点で事故が発生した 今夜は蒸し暑いですから、明日は雨が降るでしょう 部長を除く全員が土曜日も働いた 商品 変化 中心 音楽は彼の得意な分野です どこが賑やかですか 私の好きなことは音楽を聴くことです 明日、何処かに行きましたか いいえ、何処も行きませんでした 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね 宇宙人は存在すると思いますか 今夜は蒸し暑いから、明日は雨が降るでしょう 合格者が発表された 日曜日が暇です 私の苦手なことは料理を作ることです 私は世界一周をしたくありませんでした 川の岸に桜の木があります 台北駅はどこですか 彼は私の両親に美味しい日本料理をくれました 私は討論を始めたいです 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね 今夜は蒸し暑いですから、明日は雨が降るでしょう 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね 私は苦手なことは料理を作ることです 今日は何曜日ですか 授業をしている教師 みんなは運動会の予定がわかります 氷山が小さくなる 私は彼女のことは好きです インターネットで新幹線の時刻表がわかります 私はあの人のことが嫌いです ご飯を食べる人 犬を飼う あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 私は世界一周をしたかったです 原稿を改訂する 日曜日 屋上 明後日 烏龍茶 蝉 腹部 あの喫茶店は静かなので、あそこで勉強する人が多いでしょう 中村さんは昨日夜10時まで仕事をしましたから、今日は来ませんよね つ 氷山が小さくなる あの喫茶店が静かなので、あそこで勉強する人が多いでしょう あの喫茶店が静かなので、あそこで勉強する人が多いでしょう 2019-11-10彼女はオーエルです 見つける 言葉 かく 病気 次 そう 消す 私はワインが好きです 近く このコートはとても暖かい 左 上を向いて 彼女は三人の子供の母親だ 明日は昼頃から曇るでしょう 彼に会えて嬉しかった ここから富士山がよく見えます よう 私が手伝いましょう 二十日 一杯 後ろ向いて 千円貸してください 小さい花が咲いています 入る 悪い この道をまっすぐ行くと駅です 上る 対象 国は国語教育を強化しています 相手 完成 今年は変化の多い年でしだ 強調 採用 写真はいい思い出になります はげしい雨が降っています 行う 社会 自由 比べる 引越しを業者に頼んだ 繰り返す 外国 先生の隣に父と母がいます レシートをください 私は世界一周をしたくありませんでした どこも行きません 彼女は明日の天気がわかります どれが綺麗ですか テレビを付けました ご飯を食べている人 紙箱に猫がいます 小西さんは映画のチケットをあげましたよね 私は日本料理を作ることがよくできます 私は学生ではありませんでした 何も食べません 今日、何か買いますか？ はい、オレンジを買い明日 私のカバンはどれですか 小林さんは中国語を話すことができます カレンダー 嫌い 自分 故郷 烏龍茶 屋上 買い物カート スーツケースに詰める 私は世界一周をしたくありませんでした 烏龍茶 屋上 2019-11-9学校は8時半に始まります 歌う 飛行機 彼は意外に気が小さい おかげさまで元気です いつ 誰もその話を知らない また会いましょう 変える 子供 言葉 勝つ 部屋 彼はシートベルト締めた 昨日、母と話をしました このコートはとても暖かい 治る 四日 答える 切る よう 彼はその辺に住んでいる 嬉 その子は指で十数えました お願い 来月の二十日は弟の誕生日です 私たちは二階に上がった 残る 写真はいい思い出になります 比べる 報告 計画を一部変更しましょう 販売 強調 企業 その計算は間違っている 言葉 このコートはとても暖かい よう ゴミのリサイクルが普及している かの 住宅 姉夫婦に男の子が生まれました 国会 対策 増える 彼は事故で怪我をしました 彼は選挙に出るつもりだ 処理 話 のじ 方向 夜市はスーパーよりうるさいです どこが賑やかですか 台北駅はどこですか 何も買いません 私の嫌いなことは部屋を掃除することです テレビをつけました どれも要りません 宮沢さんは課長のことを、どう思いますか 日本語を上手にする 私は頑張りたくありませんでした 私は学業を続けたいです 飲み物と言えば、コーラやジュースやお茶などです 期末テストは大変でした 私はあの人のことが嫌いです 私は納豆が全然好きではありません 梅 リング マンション 親切 学長 親戚 大きな竜巻 女性はモモの太さを測っている 雨の後、虹が見られるかもしれません フクロウ 彼女は茶髪で、えくぼがあります かっこいい ぽ 2019-11-8カナダの冬はとても寒いです 国 置く 次 消す 直ぐ 約束を忘れないでください 変える 私たちのチームはその試合で負けた 彼に手紙を書きました 近い いつも 彼女は眠いようです 小さい花が咲いています 教科書を閉じてください 太い 彼女は三人の子供の母親だ 他に方法がありません 金 虹 晴れる お腹が空きました 大人 治る お店はもう閉まっていました 答えが違います 私は4つの会社に投資しています 問題 処理 彼は事故で怪我をしました 対策 商品 輸入 文章 報告 昨年は地震が多い年でした 変える 遅れた理由を教えてください 強調 その事件の犯人はまだ捕まっていない 種類 解決 計画を一部変更しましょう 処理 結果 遅れた理由を教えてください 帰ったら、まず手を洗いましょう 病院 全国 のち 彼は事故で怪我をしました 対策 報告 対立 私の好きなことは音楽です 夜市はスーパーよりうるさいです 何曜日が暇ですか 料理をおいしくする 教室は静かです 動物園のパンダは小さかったです 計画を一部変更しましょう のちに 夜市はスーパーよりうるさいです 私はおばあちゃんのことが好きです ワンピースはスカートより高いです 夜市はどこですか 引き出しにハムスターが一匹います プレで泳ぎます 昨日、どこに行きましたか 昨日、コンサートに行きました スーパーは夜市ほどうるさくありません 一眼レフカメラ 机 クリップ 中学生 陽傘 宝石 緑茶 買い物カートはからです う 2019-11-7生きる 私は体が丈夫だ 消す 肉と魚とどちらが好きですか 去年 くれる 起こす 日曜日は図書館に行きます 授業 郵便局で切手を買いました 走る いう 私たちのチームはその試合で負けた 取る １つ 登る 彼女は三人の子供の母親だ 大人 駅 口 触る 甘い 小さい花は咲いています 企業 変化 なお 方針 仕事がほぼ終わりました 私は４つの会社に投資しています 状態 備える 会長 商品 設計 原因 十分 消す 住宅 政権が交代した 彼は就職試験を受けた 対する 部長除く全員が土曜日の働いた 種類 とち 強調 塩、胡椒加えてください 彼は何年も自身の研究をしている 私たちのチームはその試合で負けた 国会 彼女は三人の子供の母親だ 大人 実現 彼は非常に高い技術を持っている 会談 問題が１つあります 小さい花は咲いています 彼は食品工場で働いています その問題に関する記事を読みました 狭い部屋 ご飯を食べた人 私は４つの会社に投資しています 台北駅はどこですか 商品 私は彼女のことが好きです 夜市は賑やかです 先生は学生の気持ちがわかります 私の趣味は本を読むことです 私は嫌いなことは部屋を掃除することです 種類 どこも行きません 私の好きなことは音楽を聴くことです 強調 今日、何か買いますか いいえ、何も買いません 犬と猫と兎、どれが好きですか 夜市はスーパーよりうるさいで 寝る猫 宮沢さんは課長のことを、どう思いますか 私は日本語が少しでします 私の趣味は料理を作るとこです 私は日本料理を作ることがまあまあできます これは私の小説です 私は懐石料理が一番好きです 私の得意なことはギターを弾くことです 私のカバンはどれですか 私は日本語が大体できます 小説はどれですか 鶴 ノートパソコン 中華料理 折り畳み傘 羊 明日 大学生が教授に質問してい フクロウ 2019-11-6おかげさまで元気です 考える 覚える 色 使う カナダの冬はとても寒いです 狭い 私は朝シャワーを浴びます 教える 漢字は中国から来ました 一日 見つかる 柿の木に実が沢山なっています 腰 直る 彼女は指が細いです 後ろを向いて お願い こっち 泊まる お手洗い 喋る 手紙が届くのに三日かかりました 住宅 病院はどこですか 企業 一般の方はこちらの席へどうぞ とち 開発 段階 国は国語教育を強化しています 参加 強調 まま トラブルがやっと解決した 姿 政治 対象 今後ともよろしくお願いします 作業 評価 それはどういう意味ですか 目立つ 国会 増加 前売券は窓口で販売しています 夢を実現するには努力が必要だ 今回 宮沢さんは課長のことを、どう思いますか 企業 何も買いません 今日は何曜日ですか 昨日、どうかに行きましたか はい、コンサートに行きました ゴミ箱にペットボトルがあります 彼女は飛行機を運転することができます どこが賑やかですか 今日、何か買いますか いいえ、何も買いません 昨日、どこに行きましたか 昨日、コンサートに行きました レシートをください 引き出しにハムスターが一匹います 国会 あなたのカバンはこれです あの人は木に登ることができます 国仲さんはあなたにギターをもらいました テストはいつですか 明日や、明後日や、来週などですね 何も食べません 静かな教室 夜市はどこですか 私はノートパスコンをテレビにする どこが賑やかですか 昨日、何処かに行きましたか いいえ、どこも行きませんでした 誰もいません どれも要りません 今日、何か買いますか はい、オレンジを買います 先生の隣に父と母がいます 飲み物を買いません 私は味噌汁が全然嫌いではありません 教室に学生と先生がいます 梅 簡単 フローリング 大きな竜巻 説明する ゴリラ センチメートル フクロウ 大学生が教授に質問している あごひげ づ フクロウ 2019-11-5九份は賑やかです 親 私位は友たちがたくさんいます 緑 安い 飛行機 一番 春 作る おかげさまで元気です 彼は医者になりました 弱い 昨日タイカレーを食べました カナダの冬はとても寒いです また会いましょう 彼女はいつも元気だ 住む 電車で子供が騒いでいた もう 家 茶色 ある 千円貸してください 彼女は眠いようです 上る 母 これは医者のためのサイトです 九日に荷物が届きます 土曜日 百 優しい 愛する 私の質問に答えてください 曲がる 宿題は自分でやりなさい お願い 閉める 私が手伝いましょう 店員は若い女の人でした 要る 続ける 交渉 彼は食品工場で働いています 彼は選挙にですつもりだ 子供の頃、その公園で遊んだ 競争 工場 変化 内容 強調 おかげさまで元気です カナダの冬はとても寒いです 首相 とし 意見 今年は変化の多い年でした まあ今回は許してあげよう 目立つ 文章 住宅 部長を除く全員が土曜日も働いた 決定 調べる 運動会は9時開始です このビールはあまり美味しくありません 採用 備える お金が十分あります このソフトにはいろいろな機能があります 増加 ここは静かな住宅地だ 経済 語る もう 存在 中心 彼女は同じ間違いを繰り返した 国は国語教育を強化しています 強調 試合の相手は誰ですか 信号が青に変わりました 建設 交差点で事故が発生した 計画 お金がほとんどありません 計算 おかげさまで元気です 住宅 部屋にベッドがあります 私は茶碗蒸しがあまり嫌いではありません 夜市が賑やかです 私は日本語が全然できません 日曜日が暇です 私は自分の力で仕事を探します 引き出しにハムスターが一匹います 大学の先輩は商売ができます 何曜日が暇ですか 台北駅はあそこです ご飯を食べた人 九份は賑やかです 犬は大きかったです 私は懐石料理がとても好きです 昨日、何処かに行きましたか はい、コンサートに行きました どこも行きません ご飯を食べている人 どれも要りません 国は国語教育を強化しています 私の苦手なことは料理を作ることです 床にアリがいます どこが賑やかですか 先生の隣に父と母がいます 誰もいません 本棚に小説と雑誌があります 宮沢さんは課長のとこを、どう思いましか 上手なコック 引き出しにハムスターが一匹います どれが綺麗です 私は日本語があまりでしませ 私はおばあちゃんのことが好きです 彼女を幸せにする 授業をした教師 私はゲームが好きです いつが暇ですか 土曜日か日曜日 私が冬が嫌いです まず、次に、そして、それから、最後に あなたのカバンはこれです 日本語が上手になる 私は懐石料理が非常に好きです 私は彼にノートパソコンをもらいました 先生の隣に父と母がいます 何も食べません 本屋で小説を買います 庭の松は高いです 私は懐石料理がかなり好きです 宮沢さんは課長のことを、どう思いますか あれはカーテンです 母はペットと海外旅行しました 昨日、何処かに行きましたか いいえ、どこも行きませんでした 何も買いません 今日、何か買いますか はい、オレンジを買います 親戚 文房具 大きな竜巻 翻訳する 竹 大人 小説 梅 たつ 中学生 乗客 一眼レフカメラ 校長 香水 陽傘 鶏 ませんでした フルート 虹 せみ ツアーガイド 茶髪 大きな竜巻 梅 づ 2019-11-3うる 紙 立つ 引く 彼は荷物を網棚にあげた 春 息子は飛行機のオモチャが好きです 続く 上を向いて かける 六日前に日本に帰ってきました 冷たい ３つ 私の家は駅の近くです 彼女は眠いようです これはかなり金がかかった 彼はとても楽しい人です 上る 妹は歌が上手です 後ろをいて 備える 進める 今後の方針が決まった 夢を実現するには、努力を必要です トラプルがやっと解決した 彼は食品工場で働いています 上る 備える 今日は自由な時間が多い 彼は小さな会社に勤めています 強化 受ける 示す 増える ドル 帰ったらまず手を洗いましょう 関する 文章 生産 変化 部長を除く全員が土曜日も働いた 彼は選挙にですつもりだ 選挙 生活 彼は新製品に興味を示している 広がる 全国 写真はいい思い出になります 理由 何も食べません あなたは小西さんに映画のチケットをもらいましたよね 彼は食品工場で働いています 備える 台北駅はどこですか 私の趣味は野球をすることです 夜市はどこですか 私は日本語ができます 誰も居ません 昨日、何処かに行きましたか いいえ、どこも行きませんでした 今日、何か買いますか はい、オレンジを買います シャワーを浴びる象 私の嫌いなことはバスケットをすることです 何も買いません どこも行きません 授業をする教師 コンビニに電子レンジがあります 部長を除く全員が土曜日も働いた 私は刺身があまり好きではありません レシートをください 彼は選挙にですつもりだ 犬は大きくありません 私のカバンはどれですか 動物園のパンダは小さくありません どれが綺麗ですか どこが賑やかですか 台北駅はどこですか 冬は暖かくありませんでした 今日、何か買いますか いいえ、何も買いません あのバカは2本の鉛筆を箸にして、ご飯を食べる どれも要りません そく 今日は何曜日ですか 何曜日が暇ですか 犬は大きくありませんでした お釣りをください 日曜日が暇です テストはいつですか 明日や、明後日や、来週などですね 昨日、どこに行きましたか 昨日、コンサートに行きました 親戚 下手 中学生 布 ペットボトル 予備校生 和食 どれも要りません 親戚 2019-11-2読む 待つ 彼女は雑誌を読んでいます 郵便局で切手を買いました 胸 起こる 右 生きる 払う 軽い また会いましょう 入れる お兄さん 喉が渇きました 強い 誰もいません 時計 つける 月曜日に会いましょう 今日は風が強い 姉は大学生です 誰もいません 彼女は眠いようです お願い 教科書を閉じてください 誰もいません 彼女は眠いようです 重要 夢を実現するには努力が必要です 比べる 何も食べません 今の首相はあまり力がない 情報 私たちはその問題を調査しています システムも構成を変えてみました 変化 関係 それはどういう意味ですか 彼は就職試験を受けた なお、雨の場合は中止です 事件 交渉 誰もいません 昨日、何処かに行きましたか いいえ、どこも行きませんでした 私のカバンはどれですか どこも行きません うそ 今日は何曜日ですか ピザを買いました。パスタも買いました 今日、何か買いますか いいえ、何も買いません 私は日本料理を作ることができます 夢を実現するには努力が必要です 何も食べません 寝る猫 変化 何も買いません どれも要りません 昨日、何処かに行きましたか はい、コンサートに行きました 広い部屋 私の苦手なことは料理を作ることです どれも要りません 授業をしている教師 みんなは運動会の予定かわかります 私は部長のことが嫌いです シャワーを浴びる象 誰もいません どれも要りません 今日、何か買いますか はい、オレンジを買います 役所の人はおばあちゃんに綺麗のカレンダーをくれました 何も食べません 台北駅はどこですか 私は懐石料理がかなり好きです 今日、どこに行きましたか コンサートに行きました レシートください あなたのカバンはこれです シャワーを浴びる象 夜市は賑やかです 彼女は明日の天気がわかります 向日葵はくさより綺麗です ゴミ箱にペットボトルがあります 何も食べません レシートください 私の好きなことは音楽です どれも要りません 夜市はどこですか どこが賑やかですか タプレット プール 年齢 ビジネスマン 記憶 校長 皿 かっこいい 雄鶏 栓抜きありますか どれも要りません 2019-11-1呼ぶ 冬 いつも 前の車はとても遅い また会いましょう 送る 宿題は未だ終わっていません 会議は四時に終わります 直ぐ 昨日、何処かに行きましたか いいえ、どこも行きませんでした 腰 左 時計を見たらちょうど3時だった 彼はシートベルト締めた 時の経つのは早い 大人 千円貸してください 五日 今日は、何か買いますか はい、オレンジを買います 今日は頭が痛いです 後ろを向いて 分からない場合は私に聞いてください それはどういう意味ですか 選挙 実現 予定 これからより一層努力します また会いましょう 計算 構成 力 姿 姉夫婦に男の子が生まれました 昨日、何処かに行きましたか いいえ、どこも行きませんでした 目立つ 減る 今日は、何か買いますか いいえ、何も買いません 対する 状態 いえ ここは一方通行です 採用 解決 販売 私は紙で鶴を作りました どこも行きません 私は歌を歌うことができます 夜市はどこですか 私の趣味は映画を見ることです 今日は、何か買いますか はい、オレンジを買います それはどういう意味ですか あなたのカバンはこれです 昨日、どこに行きましたか 昨日、コンサートに行きました 何も買いません どこが賑やかですか 何曜日が暇ですか 私は世界一周をしたくありません 貯金箱にコインが40個あります テストはいつですか 明日や、明後日や、来週などですね 授業をしている教師 運動場で走ります 今日、何か買いますか いいえ、何も買いません 私の好きなことは音楽を聴くことです 昨日、どこかに行きましたか いいえ、どこも行きませんでした 私は料理を作ることができます 台北駅はあそこです どこが賑やかですか 私の苦手なことは料理を作ることです どこも行きません 私は部長のことが嫌いです 私の得意なことはギターを弾くことです 今日、何か買いますか はい、オレンジを買います ゴミ箱にペットボトルがあります どれが綺麗ですか 私は学生ではありません 何も買いません 昨日、何処かに行きましたか はい、コンサートに行きました 日曜日が暇です 昨日、何処かに行きましたか いいえ、どこも行きませんでした ゴミ箱にペットボトルがあります 今日、何か買いますか はい、オレンジを買います 犬は大きくありません インターネットで新幹線の時刻表が分かります レストランの前に看板があります 私は日本語がまあまあできます 今日、何か買いましか いいえ、何も買いません 夜市が賑やかです 私は日本料理を作ることがでします 海 中学生 夜市 どこも行きません 鶏 どこも行きません 今日、何か買いますか いいえ、何も買いません 楓 台風 馬 腹部は、肋とお尻の間の部分です 雨の後、虹が見られるかもしれません こ ぬ 何も買いません どこも行き前ん 何も買いません","link":"/zh-tw/japanese/2019/November/index.html"},{"title":"October 2019","text":"2019-10-31肩 赤いバラを買いました 郵便局で切手を買いました 彼の日本語のレベルは私と同じくらいだ あげる 工事は3月まで続きます 今日 別 千円貸してください 上を向いて 十日後に帰ります 私が手伝いましょう そば 登る 一杯 後ろを向いて 九日 お願い どうして 触る 交差点で事故が発生した この本の内容を説明してください 引っ越しを業者に頼んだ 残る それは最近話題の本ですね 夜市はどこですか 私たちは今結婚資金を貯めています 採用 夜市はどこですか 中心 ただ 計画 続ける 千円貸してください 全国 これは重要な書類です より 文章 どこが賑やかですか 何曜日が暇ですか 台北駅はあそこです 私は書いた原稿を本にする 私の趣味は野球をすることです 後ろを向いて 私は彼女のことが好きです 私の苦手がことは料理を作ることです 昨日、どこにいきましたか。 昨日、コンサトートに行きました 私の趣味は料理を作ることです 私のカバンはどれですか ゴミ箱にペットボトルがあります 石原さんは彼に防虫スプレーをもらいました 上手なコック 自転車は電車ほど早くありません 採用 夜市はどこですか うそ 昨日、何処かに行きましたか。 はい、コンサートに行きました 夜市はどこですか 台北駅はどこですか 私は父と食事をしました 私の趣味は映画を見ることです どこが賑やかです まずい料理 夜市が賑やかです 今日は何曜日ですか 日曜日が暇ですい どこが賑やかですか 私の嫌いのことはバスゲットをすることです 私の苦手なことは料理を作ることです あなたのカバンはこれです どれが綺麗ですか テストはいつですか 明日や、明後日さ、らいしゅうなどですね 昨日、どこに行きましたか。 昨日、コンサートに行きました ゴミ箱にペットボトルがあります 昨日、どこに行きましたか。 昨日、コンサートに行きました 私は日本語が少しできます 私は日本語がよくできます 私は日本料理を作ることが大体できます どこが賑やかですか あれはカーテンです ドアをあげる 昨日、何処かに行きましたか。 はい、コンサートに行きました 私は日本語が大体できます 鼠 魔法瓶 キャベツ どこが賑やかですか テストはいつですか 明日や、明後日や、来週などですね 昨日、どこに行きましたか 昨日、コンサートに行きました ノートパスコン 中学生 故郷 博物館 フルート フットボール 18年前 タンス 質問する 私は物理の基礎は知っています せみ 昨日、何処かに行きましたか はい、コンサートに行きました 中学生 何処かに行きましたか はい、コンサートに行きました 2019-10-30生きる 旅行の日程変えました あげる 私の部屋は二階にあります 始める 昨日タイカレーを食べました 郵便局で切手を買いました 彼は昼過ぎにきます 何曜日が暇ですか 上を向いて お願い 手紙が届くのに三日かかりました 百 し 開ける こっち 何曜日が暇ですか お手洗い 動き 計算 帰ったら、まず手を洗いましょう 社会 その問題に関する記事を読みました 写真はいい思い出になります あなたのカバンはこれです 続ける 方針 一般の方はこちらの席へどうぞ 中心 姿 首相 検討 台北駅はあそこです 郵便局で切手を買いました 彼は非常に高い技術を持っている 上を向いて 内容 全国 お願い 文章 あなたのカバンはこれです 事故 昨年 計画 目立つ 先生は私に百点をくれました 何曜日が暇ですか 私のカバンはどれですか 何曜日が暇ですか 私は日本語がよくできます どこが賑やかですか 私は日本料理を作ることがまあまあできます うそ 今日は何曜日ですか どれが綺麗ですか ゲームをする 台北駅はあそこです 続ける 私はノートパソコンをテレビにする 私は自分の力で仕事を探します あなたのカバンはこれです 中心 授業をした教師 台北駅はどこですか 夜市が賑やかです 台北駅はあそこです 全国 文章 私の趣味は本を読むことです 私はサラリーマンです、けれもサラリーマンです あなたのカバンはこれです 計画 日曜日が暇です 月曜日 水曜日 火曜日 木曜日 金曜日 土曜日 日曜日 あなたの会社は私の会社に統計ソフトウエアをくれました うそ 絵を描く ご飯を食べる人 私の嫌いなことは部屋を掃除することです 私はあの人のことが嫌いです わたしはおばあちゃんのことが好きです 台北駅はあそこです お釣りをください 田舎 ガスコンロ 土曜日 クロサイが草原を歩いている 夜市は賑やかです 日曜日が暇です に の 日曜日が暇です 夜市が賑やかです 日曜日が暇です 2019-10-29親の愛は有難い 彼の家に荷物を送りました 肩 緑 うちに帰ろ 売る 持つ 私のカバンはどれですか これはかなり金がかかった １つ ２つ ３つ ４つ ５つ ６つ 7つ ８つ ９つ 10つ そこには私一人しかいなかった 口 時計を見たらちょうど3時だった 予約入りません 台北駅はどこですか 細い 私のカバンはどれですか 渇く 柿の木に実が沢山なっています 私が手伝いましょう 教科書を閉じてください かれる ソフト 比べる 台北駅はどこですか 採用 目立つ 実現 この単語の意味を辞書で調べましょう 選ぶ 中心 彼がクラスの代表だ 今日は何曜日ですか 私のカバンはどれですか 加える 計算 今日は何曜日ですか この段階では決断するのはまだ早い全体 帰ったらまず手を洗いましょう どれが綺麗ですか 政権が交代した 台北駅はどとですか 私のカバンはどれですか 作業 銀行は3時まで開いています これは世界最大の船です 目立つ 台北駅はどこですか 影響 どこが賑やかですか 中心 写真はいい思い出になります 彼は就職試験を受けた 姿 計算 今日は何曜日ですか 一部 これは重要な書類です 計画 どれが綺麗ですか 今日は何曜日ですか 変わる 検討 宮沢さんは課長のことを、どう思いますか 帰ったら、まず手を洗いましょう どれが綺麗ですか 私はあの人のことが嫌いです 私は日本語が全然できません 私の嫌いなことは部屋を掃除することです どこが賑やかですか 私は得意なことはギターを弾くことです あれはカーテンです 私は日本語料理を作ることが大体できます 授業をする教師 あの屋敷に幽霊がいますよ 写真はいい思い出になります 私は魚が嫌いです ペットを飼いましょうか どこが賑やかですか ご飯を食べた人 私は日本料理が好きです 日本語を上手にする お釣りをください あの人は木を登ることができます ソファで寝る 姿 十七 翻訳する 原稿を改訂する 計画 どれが綺麗ですか 計算 カレーライス 期末レポート 陽傘 かっこいい 走る 切る 帰る どこが賑やかですか お釣りをください お釣りをください 2019-10-28大学に行って、もっと勉強したいです 彼の家に荷物を送りました 安い 約束を忘れないてください 遠い 仕事の後、映画を見た 午前 近く 難しい こう 生きる 質問のある方はどうぞ 彼の車は新しい 少し疲れました 彼は真面目な学生です 彼は走るのが早い 私が手伝いましょう 腰 私は腕時計を４つ持っています 女 大人 教科書を閉じてください プル くる 服 東京は日本一大きな都市です 採用 信号が青に変わりました 管理 この事故の原因は何ですか この曲線がこの車の特徴です テレビ 構造 国内 状態 与える 彼は就職試験を受けた 立場 輸入 解決 国会 可能 加える 種類 私が手伝いましょう 交差点で事故が発生した 計画 実現 あの屋敷に幽霊がいましすよう 私は日本語があまりできません 私は懐石料理が一番好きです 教科書を閉じてください 私は寿司が好きです 宮沢さんは課長のことを、どう思いましか 採用 犬は大きくありません ご飯を食べる人 上手なコック 私の趣味は本を読むことです 私は日本語が少しできます 私は懐石料理がすごく好きです ご飯を食べている人 私は討論を始めたいです 彼は就職試験を受けた 自転車とバイク、どちらが便利ですか 私の好きなことはお音楽を聴くことです あなたは私にあのDVDをくれましか 計画 実現 採用 教科書を閉じてください コーヒーショップで教科書を読みます 本棚に小説と雑誌があります 私の好きなことは音楽です 私は彼女のことが好きです 私はおばあちゃんのことが好きです 私は部長のことが嫌いです 佐々木さんはサラリーマンでした 嫌いな店員 私は日本語が大体できます ボタンを押す 大きくない あれはカーテンです みんなは運動会の予定がわかります 私は日本料理を作ることが全然できません 私は苦手なことは料理を作ることです 私はあなたに誕生日プレゼントをもらいましたようね プール 中学生 牛 レタス 火曜日 コンビニ 高層ビル 海外旅行 茶髪 蝉 かっこいい 栓抜き 教科書を閉じてください あれはカーテンです かっこいい 2019-10-27１つ 直ぐ 買う 軽い 私には友達が沢山います 座る いつも 生きる 足 お母さんによろしくを伝えください 木曜日は仕事が休みです クーラーはまだ直りません 店員は若い女の人でした 金曜日の夜は友達と出かけます 休む お酒は大人になってから 教科書を閉じてください 左 要る 彼女は眠いようです 解決 上がる 弟は切手を集めています 兄は船を設計をしています 方向 残る 彼は食品工場で働いています 生きる あまり 後 トラブルがやっと解決した 彼は就職試験を受けた 交差点で事故が発生した テストはいつですか 明日や、明後日や、来週などですね 図書館はスーパーより静かです 図書館に本とコンピューターがあります 大人 私は好きなことは音楽を聴くことです 解決 私は日本語が大体できます 私は彼女のことが好きです 私は冬が嫌いです ご飯を食べましょう 私は日本料理が好きです 彼は就職試験を受けた 私は茶碗蒸しが嫌いではありません 交差点で事故が発生した 私の苦手なことは料理を作ることです 簡単な質問 私は懐石料理を非常に好きです 夏は涼しいです 小林さんは中国語を話すことができます 私は日本料理を作ることが少しできます 私の趣味は野球をすることです 私は自分の力で仕事を探します 川の岸に桜の木があります 私はピーマンが嫌いです 私は部長のことが嫌いです 日本は台湾より寒いです 私の嫌いなことはバスケットをすることです 教科書を閉じてください 私は日本語が大体できます インターネットで新幹線の時刻表が分かります 私は日本料理を作ることがあまりできません 定食 水族館 液晶テレビ 文房具 布団 猿 一眼レフカメラ 教授が図を説明する 蝉 雨の後、虹が見られるかもしれません 蝉 2019-10-26会う 言う 知る 緑 質問 見つける 聞く 手紙が届くのに三日かかりました 今日はこのホテルに泊まります テープル いい 百 この子は今年7つになります 腰 こっち 今週 付ける 妹 お手洗い これはかなり金がかかった 場合 生まれる 語る 建設 一般の方はこちらの席へどうぞ 彼は行政を改革したいと思っている 我が社の経営はうまく言っています 問題 消える 比べる 変わる 集める 導入 彼がクラスの代表だ 姿 普及 作業 私は味噌汁が全然嫌いではありません テストはいつですか 明日や、明後日や、来週などですね 私はノートパソコンをテレビにする 授業をしている教師 私はおばあちゃんのことが好きです 私は嫌いなことはバスケットをすることです 私の趣味は映画を見ることです 授業をした教師 先生は学生の気持ちがわかります テストはいつですか 明日や明後日や来週などですね 私は魚が嫌いです 私は懐石料理がすごく好きです 私の趣味は野球をすることです 私は日本料理を作ることが少しできます みんなは運動会の予定がわかります 私は鉛筆で字を書く 私の苦手なことは料理を作ることです 小林さんの妻は小林さんに愛妻弁当あげました 私の趣味は料理を作ることです 私は親友と遊びたいです 私はピーマンが嫌いです ご飯を食べた人 彼は私にノートパソコンをくれました 私の好きなことは音楽です 私は日本語が少しできます 私は部長のことが嫌いです 私はあの人のことが嫌いです 私の得意なことはギターを弾くことです 私は自分の力で仕事を探します 上手なコック ご飯を食べている人 シャワーを浴びる象 私の嫌いなことは部屋を掃除することです 宮沢さんは課長のことを、どう思いましか 寝る猫 深い湖 彼女を幸せにする 楽しい一日 プール 中学生 着物 医者は、患者の脈を取っている 私は自分の力で仕事を探します 2019-10-25また会いましょう 授業 よく いつも 笑う 終わる 飛行機 緑 あなたはどう思いましか 今朝は早く家を出ました 寝ぬ 昨日タイカレーを食べました 見せる 一緒に宿題をやろう 彼はシートベルト締めた 食べ物 私は夏が大好き 閉める 手紙が届くのに三日かかりました 百 お手洗い 神 腰 そこ左に曲がってください これはかなり金がかかだ 昼 始まる お店はもう閉まっていました 甘い 掛ける 米 した 触る 運動会は9時開始です 状態 可能 伴う 力 緑 比べる 兄は船を設計をしています 段階 多く 構造 これは大きな社会問題になっている いずれ 残る 大統領 まあ今回は許してあげよう 生活 私たちは二階に上がった 十分 一緒に対策を考えましょう 手紙が届くのに三日かかりました 百 お手洗い 腰 家族 私は懐石料理がとても好きです ハンバーガーとコーラ 私の趣味は料理を作ることです 私の趣味は映画を見ることです これはかなり金がかかった 父は台湾料理を作ることできます みんなは運動会の予定がわかります 授業をする教師 背が高くなる 比べる 私はおばあちゃんのことが好きです 私は部長のことが嫌いです 上手なコック コーヒーを飲みましょうか 宮沢さんは課長のことを、どう思いましか 授業をしている教師 小テストと中間テストと期末テスト、どれが難しですか 私は刺身があまり好きではありません 私の得意なことはギターを弾くことです 私の苦手なことは料理を作ることです インターネットで新幹線の時刻表が分かります 私はあの人のことが嫌いです 私はノートパソコンをテレビにする 私は世界一周をしたくありません みんなは、運動会の予定がわかります 絵を描く シャワーを浴びる象 私は納豆が全然好きではありません 私の嫌いなことは部屋を掃除することです 午後1時から四時までです 上手なコック 私は彼女のことが好きです ご飯を食べた人 犬は大きくありません 私はゲームが好きです 私は妹と弟と実家に帰りました 私は彼と彼女に誕生日カードをもらいました まず、次に、そして、それから、最後に 私の趣味は本を読むことです 私は日本語が少しできます 無料 コーヒーショップ 私は苦手なことは料理を作ることです 予備校生 ライブ フローリング 貯金箱 プール 私はノートパスコンをテレビにする サツマイモは、焼いても揚げても美味しい 虹 スーツケースに詰める 私は日本語が少しできます プール 中学生 2019-10-24駅の近くで食事をした 赤いバラを買いました 漢字 酒 短い 感じる まだ学校へ行くには早い時間です いつも 直ぐ お米 彼は私の方を見ました 明日は晴れるといいですね 明日は昼頃から曇るでしょう こっち 私は部長のことは嫌いです 口 店 ここから富士山がよく見えます 左 見える そこには私一人しかいなかった 状態 この曲線がこの車の特徴です 事務的な処理に1週間かかります 一般の方はこちらの席へどうぞ 交渉 開く 一般 私はおばあちゃんのことが好きです これら 残る 構造 いつも 実施 この本の内容説明してください 技術 決定 十分 存在 彼は行政を改革したいと思っている このプリンターは従来のものより早い 土地 宮さわさんは課長のことを、どう思いますか？ 島の人口は年々増加しています 彼はパソコンを二台持っています 私にはたくさんのお彼が必要だ 宮沢さんは課長のことを、どう思いましか 状態 私の好きなことは音楽を聴くことです ご飯を食べる人 私は部長のことが嫌いです 宮沢さんは課長のことを、どう思いましか？ 私の嫌いなことはバスケットをすることです あの歌手は有名でした 私の嫌いなことは部屋を掃除することです 私はおばあちゃんのことが好きです 私は部長のことが嫌いです 私の好きなことは音楽です 浅い川 私は味噌汁が全然嫌いではありません 私はあの人のことが嫌いです 私は彼女のことが好きです 授業をした教師 私は寿司が好きです 寝ぬ猫 ベッドの下にゴキブリがいます 私の趣味は本を読むことです 周りが静かになる 私の苦手なことは料理を作ることです 私の得意なことはギターを弾くことです 私はおばあちゃんのことが好きです あの服のほうが可愛いです インターネットで新幹線の時刻表が分かります 宮沢さんは課長のことを、どう思いましか 私の嫌いなことは部屋を掃除することです 私は課長のことが嫌いです 私の苦手なことは料理を作ることです 私はおばあちゃんのことが好きです インターネットで新幹線の時刻表が分かります 私の趣味は野球のすることです 車の後ろに子猫と子犬がいます 私は日本料理を作ることがあまり好きではありません 宮沢さんは課長のことを、どう思いましか 社員食堂 どちら フロント 雨の後、虹が見られるかもしれません 宮沢さんは課長のことを、どう思いましか 2019-10-23教える あに 取る 見つける 難しい 同じ わかる 私の嫌いなことは部屋を掃除することです 直ぐ この本は難しいですね 次 午前 寝ぬ 口 分からない場合は私に聞いてください 私の嫌いなことは部屋を掃除することです 私の嫌いなことは部屋を掃除することです 左 こっち 自分 場合 彼に会えて嬉しかった 上手 もう 事実 私の得意なことはギターを弾くことです 重要 代表 彼は小さな会社に勤めています 機能 その問題に関する記事を読みました 私の得意なことはギターを弾くことです 一般の方は此方席へどうぞ 直ぐ 会社 存在 自由 私の得意なことはギターを弾くことです 増える 利用 よく答えが分かりましたね 彼は非常に高い技術を持っている 私の嫌いなことは部屋を掃除することです 左 こっち 私の苦手なことは料理を作ることです 私の嫌いなことは部屋を掃除することです ガソリンの価格がどんどん上がっている 開発 私の苦手なことは料理を作ることです 以上 私の日本語が少しできます 私は懐石料理をとても好きです 私は彼女のことが好きです 私の趣味は野球をすることです 私の趣味は映画を見ることです 私の得意なことはギターを弾くことです 私は彼に使い捨て箸をあげます 私は納豆が全然好きではありません 私は好きなことは音楽です 一般の方は此方の席へどうぞ 私はあの人のことが嫌いです 私の得意なとこはギターを弾くことです 私のノートはどれですか 教室は静かではありません 図書館に本とパソコンがあります 犬は大きくありません ご飯を食べる人 授業をした教師 私の苦手なことは料理を作ることです 私の苦手なことは料理を作ることです 私は彼女のことが好きです 私はあの人のことが嫌いです 新聞で道の状況がわかります 私の嫌いなことはバスケットをすることです 私の趣味は本を読むとこです ご飯を食べた人 ピザを買いました、パスタも買いました 私は泳ぐことができます 私の苦手なことは料理を作ることです 私の好きなことは音楽を聴くことです 私は茶碗蒸しが嫌いではありません 私の趣味は料理を作ることです 私は学生です 佐々木さんはサラリーマンです 授業をする教師 テストはいつですか 明日か明後日か来週ですね ご飯を食べている人 私は彼女のことが好きです 授業をしている教師 彼女は朱さんに中間テストのノートをもらいました 社員食堂 会議 陽傘 虹 センチメートル 雨の後、虹が見られるかもしれません 私はあの人のことが嫌いです 私の苦手なことは料理を作ることです 私は彼女のことが好きです 雨の後、虹が見られるかも知れません 私はあの人のことが嫌いです 2019-10-22歩く 肩が凝りました 立つ 呼ぶ 死ぬ 寝る 帰る 右のボケットにハンカチが入っています 私の趣味は本を読むことです あげる 置く それ 彼はまだ若いです 私は二日待った 悪い 渇く 私の趣味は野球をすることです 喉が渇きました 駅 宿題は自分でやりなさい 彼女は眠いようです 冷たい 近く 柿の木に実が沢山なっています 私の好きなことは音楽です これは医者のためのサイトです 触る かれる 作業するにはもっと広いスペースが必要だ 彼女は自分の立場をわかっていない 私の趣味は本を読むことです 今後ともよろしくお願いします 私の趣味は野球をすることです 話 今日はこれらの問題について話し合います 交差点で事故が発生した 商品 開発 行う命令 私の好きなことは音楽です 結果 彼は新製品に興味を示している 強化 今回 電話 機能 期待 私の好きなことは音楽を聴くことです 政権が交代した 建設 私は彼から大きな影響受けました 残る 加える 作業 私は懐石料理が一番好きです 私の嫌いなことはバスケットをすることです ご飯を食べた人 彼女を幸せにする テレビをつける ご飯を食べている人 私の趣味は映画を見ることです 私の趣味は料理を作ることです ご飯を食べる人 私の趣味は本を読むことです 寝る猫 授業をする教師 シャワーを浴びる象 引き出しにハムスターが一匹います 授業をしている教師 本棚に小説と雑誌があります ください 私の趣味は野球をすることです 私は世界一周をしたくありません 私は懐石料理がとても好きです 授業をした教師 犬は大きくありません 記憶 魔法瓶 腹部 私の好きなことは音楽を聴くことです 私の好きなことは音楽を聴くことです 私の嫌いなことはバスケットをすることです 私の趣味は本を読むことです 私の趣味はバスケットをすることです 犬は大きくありません 私の好きなことは音楽を聴くことです 茶髪 アリクイが行ったり来たりしている 私の好きなことは音楽を聴くことです 私の嫌いなことはバスケットです 私の嫌いなことはバスケットをすることです 私の好きなことは音楽を聴くことです 2019-10-21学校は8時半に始まります 遅い 若い 昨日タイカレーを食べました 授業をしている教師 郵便局で切手を買いました 広い 建てる 日本人はお米が大好きです 十日 32ページを開いてください ご飯を食べた人 かれる 触る 彼はシートベルト締めた 一杯 答えが違います 開く 授業をした教師 多分 必要 残る 信号が青に変わりました 重要 塩、胡椒、加えてください 私の趣味は映画を見ることです 評価 いい方法思いつきました 国は国語教育を強化しています 私の趣味は映画を見ることです 強化 この本の内容説明してください 私の趣味は料理を作ることです 彼は食品工場で働いている 授業をしている教師 動き より 日本語を上手にする ご飯を食べている人 授業をしている教師 ご飯を食べた人 かれる 私はゲームが好きです 触る 私は懐石料理がかなり好きです 私は懐石料理が非常に好きです 授業をしている教師 寝ぬ猫 あの服のほうが可愛いです 授業をした教師 残る 私は日本料理を作ることができます シャワーを浴びる象 私の趣味は映画を見ることです あの歌手は有名ではありません 私は頑張りたくありません ご飯を食べている人 あのバカは二本の鉛筆を箸にして、ご飯を食べる 私はあなたにデジタルカメラをもらいました 授業をする教師です 私の趣味は料理を作ることです 私の趣味は料理を作ることです 私の趣味は映画を見ることです 私は世界一周をしたくありません 私は刺身があまり好きではありません 運動場で走ります ご飯を食べている人 ご飯を食べた人 隣人 コーヒーショップ 下手 お爺さん 使い捨て ビジネスマン 授業をした教師 ライプ 台風 授業をしている教師 質問する 栓抜き 私の趣味は映画を見ることです 私の趣味は料理を作ることです 私は世界一周をしたくありません ご飯を食べた人 授業をした教師 2019-10-20飲む 赤いバラを買いました 帰国することに決めました 彼は今勉強しています 昨日タイカレーを食べました 起こす ご飯を食べる人 狭い また会いましょう 引く 使う 来月の一日は空いていましか 授業をする教師 四月に大学に入学しました 晴れる 彼はシートベルト締めた 授業をする教師 彼女は眠いようです 寝る猫 私の質問に答えてください 風邪 メガネが見つかりません 昨日タイカレーを食べました 男の人は私たちに話しかれた ご飯を食べる人 一人 愛する なお トラブルがやっと解決した 彼はシートベルト締めた シャワーを浴びる象 明らかに彼が悪い 授業をする教師 寝る猫 シャワーを浴びる象 システムの構成を変えてみました ご飯を食べている人 彼は選挙に出るつもりだ 後に 完成 選挙 検討 ご飯を食べる人 党の代表が質問に答えました 提供 女性 この本の内容説明してください 授業をする教師 仕事がほぼ終わりました 調べる あの人は木に登ることができます 上野さんは彼女と映画を見ました 何を食べますか 定食かうどんかラーメンです 寝る猫 大きくありません出した 台湾は暑いです 私は冬が嫌いです 文房具 隣人 シャワーを浴びる象 ノートパソコン 課長 布 綺麗 嫌い 有名 ご飯を食べている人 シャワーを浴びる象 ご飯を食べる人 ぬ ご飯を食べている人 この本の内容を説明してください 授業をする教師 寝る猫 シャワーを浴びる象 ご飯を食べている人 2019-10-19膝に痛みを感じます 出来る 入れる 午前 彼に手紙を書きました 私が払いましょう 彼は歯が白い 時の経つのは早い 動く 九日に荷物が届きます 辛い 口 彼女は眠いようです ハワイは4回目です 答える 口を大きく開けてください 生活 決定 今日の新聞どこに置いた 集める 生産 交差点で事故が発生した トラブルがやっと解決した 激しい 写真はいい思い出になります 対する 病院 工場 相手 対立 外国 会長 夏は涼しかったです 鉛筆は短くありません 両親は日本に行きます、私も行きます カレーライスとオムライス、どちらが美味しいですか 私は茶碗蒸しがあまり嫌いではありません 母はペットと海外旅行しました スピーチが何時まででしか 彼女は眠いようです 私は冬が嫌いです 彼女はマイカーを買いたがります お客さんは家に来ました 学長 予備校生 本棚 ベッド 可愛い女の子 生まれる 年齢 乗客 原稿を改訂する 皿 ツアーガイド フットボール 2019-10-18私には友達が沢山います 元気 勝つ 言う 弱い 乗る もう寝よう 何か飲み物が欲しいな 細い 三日 晩ご飯は食べましたか 店員は若い女の人でした 欲しい この道を真っ直ぐ行くと駅です 口 対策 彼女は同じ間違いを繰り返した 生産 まあ今回は許してあげよう 交差点で事故が発生した 階段 研究 いつれまだお会いしましょう 交差点で事故が発生した いつれまたお会いしましょう 党の代表が質問に答えました 関する ロボット 経済 彼は食品工業で働いています 業者 試合の結果を早く知りたい その計算は間違っている 受ける 投資 情報 私は懐石料理がかなり好きです 私は刺身があまり好きではありません 父は台湾料理ができます 夏は涼しかったです インターネットで新幹線の時刻表が分かります 有名な歌手 私はピーマンが嫌いです 彼女はマイカーを買いたがります 私は納豆が全然好きではありません 私は懐石料理が一番好きです 私は懐石料理がすごく好きです 床に蟻がいます 私は味噌汁が全然嫌いではありません 私は茶碗蒸しがあまり嫌いではありません 本棚に小説と雑誌があります まず、次に、そして、それから、最後に カレンダー マイカー 陽傘 中間レポート 高層ブル 小テスト 布団 雄鶏 虹 茶髪 カニが浜辺を歩いている 肉食妻帯 2019-10-17赤いバラを買いました 乗る １つ 胸に少し痛いがあります 病気 次はいつ会いましょうか 彼女は耳がよく聞こえません もう寝よう 決める どれ 十日後に帰ります 時計を見たらちょうど3時だった 愛する 二日 手紙が届くるに三日かかりました 口 ご主人 つける ため 彼にはこ子供が6人います 関係 それはどういう意味ですか 報告 彼は食品工場で働いています 始めに、会長が挨拶した 制度 その問題に関する記事を読みました 技術 彼はその詩を用いて自分の気持ちを伝えた これから、より一層努力します 計画 遠くに彼女の姿が見えた 作業 彼は非常に高い技術を持っている 文章 輸入 販売 私は味噌汁が全然好きではありません 彼は学校に来ませんでした ボタンを押す 私は日本料理が好きです 私は寿司が好きです 私は懐石料理がとても好きです 母はペットと海外旅行しました 私は魚が嫌いです 佐々木さんはサラリーマンではありません 日本語が上手になる これは小説です 私は懐石料理がすごく好きです 彼は食品工場で働いています 台北の夜市は賑やかです、九份も賑やかです 私はピーマンが嫌いです 彼女はボーリングができます 私は納豆が全然好きではありません 私は懐石料理がとても好きです 彼は彼のお父さんに新しい腕時計をあげました 体育館 ペット 違います 中間テスト 魔法瓶 看板 一眼レフカメラ センチメートル あごひげ 栓抜きありました 茶髪 医者は、患者の脈を取っている び 茶髪 2019-10-16やる 今日は日本語の授業があります 漢字は中国から来ました また会いましょう 兄は水泳が得意です 電車で子供が騒いでいた 赤いバラを買いました まつ とても 軽い 後ろ向いて 二日 休む 来る 彼 野球は9人で人チームです 彼には子供が6人います 上手 この部屋は寒いです その子は指で十数えました そば 曜日 口 彼はこの辺に住んでいます 学生たちはインターネットでいろいろな情報集めた 後に 予定 発生 帰ったらまず手を洗いましょう 政権が交代した 昭和 方針 方向 普及 調べる 犬に餌をやった トラブルがやっと解決した 仕事を続けてください 会談の内容は発表されました 変わる 私はゲームを好きです 私は懐石料理がかなり好きです 私は刺身があまり好きではありません 部屋でご飯を食べます 赤いバラを買いました 私は日本料理が好きです 私は頑張りたくありませんでした 私は懐石料理がかなり好きです 私は魚が嫌いです 私は懐石料理が一番好きです 何を食べましか？ 定食かうどんかラーメンです 口 予備校生 キャベツ 鶏 文房具 乗客 あごひげ 18年前 2019-10-15飛行機 書く 質問 会議は四時に終わります 少し疲れました 彼は意外に気が小さい また会いましょう どう 私は絵を見るのが好きです 授業 お願い 要る 治る 泊まる 鼻 このスープはとても熱い 先月の七日に孫か産まれました 息子は６つになりました 彼に会えて嬉しかった 私が手伝いましょう 夜 後で電話します また会いましょう 後で電話します これはイタリアから輸入した服です 加える 資金 強調 存在 後には 消える 内容 新聞 問題 弟は切手を集めています 方針 可能 信号が青に変わりました 対する 今夜は大いに語りましょう 運動会は9時開始です 株 比べる 試合の会えは誰ですか ほとんど 私は４つの会社に投資しています 力 作業 前売券は窓口で販売しています 私はゲームが好きです 後に お爺さんは昔の記憶を忘れたがります 私は日本語がまあまあできます 机の上にペンが二本あります 私は寿司が好きです 絵を描く インターネットで新幹線の時刻表が分かります 向日葵は草より綺麗です 私は懐石料理がかなり好きです 私は冬が嫌いです 父は台湾料理ができます 私は茶碗蒸しがあまり嫌いです 私は刺身があまり好きではありません 本棚に小説と雑誌があります 私は懐石料理が日非常に好きです 私はあの記憶を忘れたいです 私は納豆が全然好きではありません 私は両親の支えでアパートを買いました 私は味噌汁が全然嫌いです レタス 文房具 記憶 予備校生 レンタサイクル 蚊 ノートパソコン 消しゴム 校長 ポルトガル 炒める 女性がももの太さを計っている サイ 文房具 予備校生 2019-10-14約束を忘れないてください 後 言葉 出る 彼の日本語のレベルは私の同じくらいだ 工事は3月まで続きまし いつ 私たちのチームはその試合で負けた 肉と魚とどちらが好きですか 彼は荷物を網棚に上げだ 彼は歯が白い 見つかる つよい 渇く そこには私に一人しかいなかった 晴れる 有る 方 悪い 会長 まあ今回は許してあげよう 彼は小さな会社に勤めています 原因 その会社は来月、キャンペーンを行う もう 作業 彼はその事件に関係がない 種類 昨年 なお、雨の場合は中止です 決定 受ける まま 結果 検討 段階 音楽は彼の得意な分野です 重要 対立 彼がクラスの代表だ 問題が１つあります 競争 私は納豆が全然好きではありません 私は冬が嫌いです 嫌いな店員 あれはカーテンです 私は刺身があまり好きではありません 私は懐石料理が一番好きです まずい料理 私は王建民ほど有名ではありません 私は懐石料理がかなり好きです 川の岸に桜の木があります 作業 私は懐石料理がすごくできます インターネットで新幹線の 私は味噌汁が全然嫌いではありません 私は茶碗蒸しが全然嫌いではありません 私は懐石料理がかなり好きです 私は懐石料理がすごく好きです 便利な所 コーヒーを飲みましょう 日本語を上手にする 私はピーマンが嫌いです 私は日本に行きます 高層ビル 魔法瓶 焼き鳥 陽傘 台風 ビジネスマン 翻訳する 調味料 虹 アリクイ インターネットで新幹線の時刻表が分かります 2019-10-13今年 知る 郵便局で切手を買いました 持つ 親の愛は有難い 落ちる 質問のある方はどうぞ 神 私は懐石料理がかなり好きです 勝つ 夫の服をハンガーに掛けた 強い お腹 ２つ 千円貸してください 私は腕時計を４つ持っています 私は刺身があまり好きではありません 二十日 7つ 閉まる 柿の木に実が沢山なっています 明日は昼頃から曇るでしょう 五日 腰 私は茶碗蒸しがあまり嫌いではありません 喉が渇きました 彼は新製品に興味を示している まあ今回は許してあげよう 私は茶碗蒸しがあまり嫌いではありません 新しいビルの建設が始まった 銀行は30まで開いていまし ここが建物の中心です 私は懐石料理がかなり好きです 姿 交渉 トラブルがやっと解決した 増える 輸入 今日の新聞、どこに置いた 住宅 私は懐石料理がかなり好きです 実現 私はゲームが好きです 私はピーマンが嫌いです 私は冬が嫌いです 母は日本料理ができます 私は魚が嫌いです 私は刺身があまり好きではありません 私は茶碗蒸しがあまり嫌いではありません 私は懐石料理が一番好きです 私は懐石料理が非常に好きです 私は懐石料理が非常に好きです 本棚に小説と雑誌があります 机のうえにのほんのえんぴつがあります 冬は暖かいです 父は台湾料理ができます 私は納豆が全然好きではありません まあ今回は許してあげよう 私は日本料理が好きです 私は納豆が全然好きではありません 私は懐石料理がとても好きです あのバカは二本の鉛筆を箸にして、ご飯を食べる 私は茶碗蒸しがあまり嫌いでがありません 私は刺身があまり好きではありません 何を食べますか？ 定食かうどんかラーメンですね 私は寿司が好きです 鉛筆は短くありません あなたの会社は私の会社に統計ソフトウエアをくれました 私は懐石料理がとても好きです 私は茶碗蒸しあまり嫌いではありません 私は納豆が全然好きではありません 私の妹に飴をくれましたね、ありがとう あの人は木を登ることができます コーヒー 高層ブル 期末レポート ノートパソコン 私は味噌汁が全然嫌いではありません レタスの葉 とり 小学生 陽傘 形容詞 ライブ 私は味噌汁が全然嫌いではありません 布団 魔法瓶 私は物理の基礎はしていまし 虹 私は納豆が全然好きではありません スーツケースに詰める 医者は、患者の脈を取っている 私は刺身があまり好きではありません 高層ビル 私は納豆が全然好きではありません 陽傘 私は味噌汁が全然嫌いではありません 魔法瓶 私は味噌汁が全然嫌いではありません 虹 2019-10-12とる かなり 肩 国 言う 私はピーマンが嫌いです 秋 楽しむ 美しい ご主人 私はピーマンが嫌いです 私はピーマンが嫌いです 彼は私の上司です お店はもう閉まっていました ８ 彼は神を信じている 止める これはかなり金がかかった １００ 他に方法がありません 私はピーマンが嫌いです 手紙が届くのに三日かかりました その道を真っ直ぐ行くと駅です 近く そばにいてください ８つ 私の祖母は100歳です 話すのを止めてください 政権が交代した 示す 私は懐石料理が一番好きです トラブルがやっと解決した 私は懐石料理が一番好きです 私はピーマンが嫌いです 彼は就職試験を受けた ここは一方通行です 社会 提供 生まれる 交渉 私は懐石料理をすごく好きです 一緒に対策を考えましょう 対象 開発 報告 株 普及 従来 ボラブルがやっと解決した 私は懐石料理が一番好きです 私は懐石料理がすごく好きです 写真はいい思い出になります 全体の80%が完成しました 部長除く全員が土曜日も働いた 私達は二階上がった 開く 彼は非常に高い技術を持っている 必要 この段階では決断するのはまだ早い その問題に関する記事を読みました 私は懐石料理が非常に好きです 相手 信号が青に変わりました 私の両親は昭和生まれです 投資 私は寿司が好きです 九份は賑やかではありませんでした 私は弟と妹と実家に帰りました 彼は社長ではありません ボタンを押す 私は懐石料理がとても好きです 弟は学業を続けたがります 私は魚が嫌いです 母はペットと海外旅行しました 私は懐石料理が一番好きです 父は台湾料理ができます 忙しい会社員 先生は親切です うそ あの人は木に登ることができます 私は冬が嫌いです 私は日本料理が好きです 私は懐石料理が非常に好きです 私はゲームを好きです コーヒーを飲みましょうか まず 次に そして それから 最後に あなたは国仲さんにゲームソフトをもらいましたよね 本棚に小説と雑誌があります 私は懐石料理が非常に好きです ノートパソコン 液晶テレビ 私は懐石料理が非常に好きです 私は懐石料理がとても好きです 私は懐石料理が一番好きです 母は台湾料理ができます あの人は木に登ることができます 私は懐石料理がすごく好きです 本棚に小説と雑誌があります ノートパソコン もり 烏龍茶 虎 日本料理 解答 センチメートル 私は懐石料理がとても好きです 教授が図を説明する 医者は、患者の脈を取っている フクロウ かっこいい サツマイモは、焼いても揚げても美味しい 私は懐石料理がすごく好きです 私は懐石料理がとても好きです 医者は、患者の脈を取っている 2019-10-11数 これ 一つ 一番 今会社に戻ります 覚える 私は寿司が好きです 立つ 昼間は電気を消してください 手伝う 汚い 私は日本料理が好きです 冷たい 締める 私は腕ん時計を四つ持っています 乾く 時々 私はゲームが好きです 彼は選挙に出るつもりだ 影響 国内 建設 一部 私は魚が嫌いです 激しい 構成 実施 私は寿司が好きです 私は日本料理が好きです 私はゲームが好きです 私は魚が嫌いです 調べる 政権が交代した 塩、胡椒加えてください 中心 私は寿司が好きです 土地 強化 管理 お金がまだ十分あります 私は日本料理が好きです 十分 電車が自電車より早いです 長い傘 冬は暖かくありませんでした 私はゲームが好きです クラスを静かにする 浅い川 絵を描く 弟は母の性格がわかります 私は魚が嫌いです 彼女は朱さんに中間テストのノートをもらいました あの屋敷に幽霊がいます 私の友達は野球とサッカーができます ドアを開ける 私は冬が嫌いです 松 原稿改訂する 私は寿司が好きです 私は冬が嫌いです 私は日本料理が好きです 竜巻 フライドポテト フルート 私はゲームが好きです フットボール む 私は魚が嫌いです 私は冬が嫌いです 私は冬が嫌いです 2019-10-10あの歌手は有名です 家に帰ろう 日記 ひく 飛ぶ 始める 彼は足が長い 大学に行ってもうと勉強したいです 彼は数学を教えています さらにケーキを載せました クーラーはまだ直りません 動かないで 終わり 宿題は自分でやりなさい 付ける 直る 大人 これは医者のためのサイトです 窓開けてください 彼は昼過ぎに来ます 導入 彼は非常に高い技術を持っていある 部分 いずれ それはどういう意味ですか 存在 彼は大きな声で話した 引越しを業者に頼んだ 彼はパーティー会場を提供してくれました 結果 計画を一部変更しましょう 選挙 多く 首相 より 検討 変化 今回 動き 政府 信号が青に変わりました 自由 私達は今、結婚資金を貯めています 犬は大きくありません 中間レポートは中間レポートほど大変ではありません 絵を描く 日本語を上手にする 弟は家に帰りました 私は世界一周をしたかったです 飲み物を買いませんでした ピン 記憶 年齢 竹 木製の化粧ダンス 買い物カートは空です 腹部 づ 2019-10-9九份は賑やかです こう 午前 見つける 起きる 耳 はな 今週 手紙が届くのに三日かかりました 曇る 喋る 悲し 柿の木に実が沢山なっています 易しい 酸っぱい １０ 太い 暖かい そこには私一人しかいなかった ドル 変化 方向 私は彼から多いな影響受けました 以上 この建物の構造は複雑です 今後ともよろしくお願いします 規模 事務的な処理に1週間かかります 彼は小さな会社に勤めています それは全て事実ですか 治る 計画 彼は非常に高い技術を持っている 検討 今後の方針が決まった 国は国語教育を強化しています システムの構成を変えてみました 商品 進める 信号が青に変わりました 評価 母はペットと海外旅行をしました あなたは国仲さんにゲームソフトをもらいましたね 川の岸に桜の木があります ペットと言えば、犬や猫や兎や鼠などです 彼女を幸せにする 彼は中国語と英語がわかります 運動場で走ります 引き出しにハムスターが一匹います 彼は非常に高い技術を持っている 冬は暖かくありません ボタンを押す 彼は中国語と英語ができます 彼女はボーリングができます 机 コアラ 台風 アパート ビジネスマン 信号が青に変わりました 布 レタス さら 竹 嫌い 下手 一眼レフカメラ クロサイが草原を歩いている スーツケース 18年前 2019-10-8彼はまだ若いです いう 友達とお酒を飲んでいます 鳥が飛んでいます 今朝は早く家を出ました 胸に少し痛みがあります 一つ 使う 手紙が届くのに三日かかりました 道 教科書を閉じてください 左 7つ 金 空く 時の経つのは早い 細い 時計を見たらちょうど三時だった 体重がかなり減りました 運動会は九時開始す 残る 計算 企業 写真はいい思い出になります 決定 ボルドーはワインの生産で有名だ もう 比べる 国会 生活 話 よく答えが分かりましたね 与える その問題関する記事を読みます 重要 テーブルと椅子 手紙が届くのに三日かかりました いつが暇ですか ボタンを押す 私は頑張りたくありません 彼女はマイカーを買いたがります 一個、ニコ、三個、4個、ごこ、六個、7個、８個、9個、10個 私は日本語ができます まず、次に、そして、それから、最後に すみません、今は何時ですか 私は鉛筆で字を書く 周りが静かになる 学校の先生は数学をできます 彼女は私に新しい手帳くれました する くる 社長は部長と出掛けました ドアを開けませんでした 私は日本語があまりできません テレビを付けません 母はペットと海外旅行しました ボタンを押す 私は日本語ができます 部屋が綺麗になる 日本語を上手にする あれはカーテンです ライブ 一眼レフカメラ 傘 乗客 ツアーガイド フロント 質問する 母はペットと海外旅行しました 2019-10-7軽い 少ない 家に帰ろう 次 入れる 狭い 郵便局で切手を買いました 一つ いろ 答えが違います 私の妹は小学生です 米 閉める 明日は昼頃から曇るでしょう 載せる 彼に会えて嬉しかった 近く 喉が渇きました 大きい 二十日 分からない場合は私に聞いてください 悪い 激しい 示す 政権が交代した 彼は選挙に出るつもりだ 変わる 彼は小さいな会社に勤めています 工場 外国 仕事を続けてください 写真はいい思い出になります 原因 問題 決定 生産 可能 写真はいい思い出になります 激しい雨が降っています 今の首相はあまり力がない ここは静かな住宅地だ 競争 写真 庭の松は高かったです 私の友達は野球とサッカーができます バイクのほうが便利です 私はバスで学校に行きます 深い湖 スーパーは賑やかです 日本語を上手にする まず 次に そして それから 最後に 狭い部屋 教室は静かではありません あなたは私にデジタルカメラをくれました 猫のほうが好きです 学校の先生は数学ができます 私は世界一周をしたいです 緑茶 原稿改訂する 海 地震 スマホ 雄鶏 ７.９センチメートル あごひげ 腹部は、肋とお尻の間の部分です 日本語を上手にする まず、次に、そして、それから、最後に 2019-10-6それ、全部ください 腕 電車で子供が騒いでいた なる どう 飛行機 笑う 授業 膝に痛みを感じます 覚える 去年 帰国することに決めました くる 閉じる 彼女は茶色の靴を履いています 私は二日待った 一杯 そこには私一人しかいなかった 後ろ向いて 百 九日に荷物が届きます 彼がクラスの代表だ 方針 関係 段階 私にはたくさんのお金を必要だ ほとんど その問題に関する記事を読みました 行う それはどういう意味ですか 存在 彼は歌で自分の気持ちを表現した 与える 備える 塩、胡椒加えてください 計画 飛行機が一時間以上遅れた 彼は行政を改革したいと思っている 試合の相手は誰ですか 彼は小さいな会社に勤めています 私達がその問題を調査しています 彼は小さな会社に勤めています 広がる 建設 この部分は問題ないです 床に蟻がいます 先生はテストの解答がわかります 料理をおいしくする 私は日本語ができます 彼女はあの野良犬をペットにする あなたは教師ですか あのバカは二本の鉛筆を箸にしてご飯を食べる 病人が元気になる あの歌手は有名ではありませんでした うそ 石原さんは彼に防虫スプレーをもらいました 美味しいデザート 犬と猫と兎、どれが好きですか ハンバーガーとコーラ 原稿改訂する 幽霊 台風 ビジネスマン 記憶 銀のフルート 18年前 栓抜きありますか ゴリラ ぢ ドゥ ディ 2019-10-5秋 起こす 言う わかる 質問 春 彼はもう帰りました 四つ 昨日友達にあった 晴れる 彼女は眠いようです 月 曜日 駄目 彼は行政を改革したいと思っている 母はまだ外国に行ったここがありません 昨年 これは重要な書類です その事件の犯人はまだ捕まっていない なお 対する 会社 都市 我が社の経営はうまく行っています まま ただ 塩、胡椒、加えてください 世界 完成 特徴 コンピューター その問題に関する記事を読みました 彼は新製品に興味を示している この事故の原因は何ですか ここは私の家です 経済 集める ほぼ より これから、より一層努力します 株 検討 もう 文章 私は彼に使い捨ての箸をあげました 役所の人はおばあちゃんに綺麗なカレンダーをくれました くありません 私は王建民ほど有名ではありません 大学の先輩は商売ができます 彼は彼の父に新しい腕時計をあげました 眠くなる あれはカーテンです 犬は大きくありません 私は世界一周をしたくありません 机の上に二本の鉛筆があります 彼女は社長ですか 先生は難しい本を読むことができます 深い湖 その問題に関する記事を読みました 私は飛行機で日本に行きます 記憶 ビジネスマン 台風 深い 宝石 鶏 ゲームソフト レタス ライブ 香水 18年前 栓抜き かっこいい 記憶 ビジネスマン 台風 18年前 2019-10-4彼の日本語のレベルは私同じくらいだ 近い ご主人 おっと 酒 生きる 冬 学校は八時半に始まります 聞く 午後 あげる 彼は意外に気が小さい 言う 終わり 後ろ 店員は若い女の人でした この道を真っ直ぐ行くと駅です 場合 明日は昼頃から曇るでしょう その人には二回あった そこには私一人しかいなかった 多分 九つ 掛ける 十日後に帰ります 大丈夫 彼はシートベルト締めた 他 夏休みももう終わりだ だめ 冷たい 開発 ソフト 銀行 もう 早く授業進めましょう 病院 言う 部分 一般 仕事はほぼ終わりました 帰ったら、まず手を洗いましょう 運動会九時開始です 販売 加える 良い方法思いつきました 政権が交代した 全体 中心 私は政治に関心がある 彼は良いところだけを強調した 採用 彼は一人旅の計画を立てた 会談 増える 日本語が上手になる 国仲さんはあなたにギターをもらいましたね 彼は中国語と英語ができます 先生はテストの解答がわかります 森に熊がいます 大学の先輩は商売ができます 私はプレゼントをあげましたよね コーヒーを飲みましょうよ スーパーは夜市ほどうるさくありません 先生は私に100点をくれました あの屋敷に幽霊がいましよ あれはカーテンです 夜市 キャベツ 翻訳する 蚊 レタス コンビニ弁当 知り合い ライブ フットボール サツマイモ スーツケースに詰める サツマイモは、焼いても揚げても美味しい あれはカーテンです レタス ライブ 2019-10-3行く 白い 少し疲れました 彼に手紙を書きました 京都にはお寺が多い 一緒に宿題をやろう 続く 午前 そう 買う 広い 私には友達が沢山います 質問のある方がどうぞ 弱い 私たちはビデオゲームをした 百 あそこ 六日前に日本に帰ってきました 後ろ 近く 時計を見たら、ちょうど三時だた 泊まる そこには私一人しかいなかった 私が手伝いましょう 明日は昼頃から曇るでしょう タバコは体に悪い 重要 強化 最近株を始めました 方向 一緒に対策を考えましょう 私は彼から大きな影響受けました もう 外国 状態 報告 彼女は同じ間違いを繰り返した 選挙 開発 写真は良い思い出になります 実現 会談 対立 お金がほとんどありません そこには私一人しかいなかった 明日は昼頃から曇るでしょう 引っ越しを業者に頼んだ 土地 消える 存在 政権が交代した 比べる ドアを開けました 音量を大きくする 彼女はマイカーを買いたがります そこは病院ですね 彼は学校に来ませんでした 彼は中国語と英語ができます このノートは私のノートです ニュースで道の状況がわかります あの屋敷に幽霊がいますよ フライドチキン 楓 麒麟 美術館 着物 女性がももの太さを計っている 政権が交代した 2019-10-2あと たつ 持つ 低い 郵便局で切手を買いました 宿題はまだ終わっていません 戻る 学校は八時半に始まります 見せる 午前 座る 知る 軽い 約束をわしれないでください 彼はこの辺に住んでいます うえ 着る 十 日 宿題は自分でやりなさい 近く 愛する 喉が渇きました 腰 百 答える 存在 開始 対する 交渉 遠くに彼女の姿が見えた 運動会は九時開始です 全体 計画 種類 社会 予定 参加 彼は食品工場で働いています 国会 塩、胡椒加えてください トラブルがやっと解決した 内容 土地 文章 国内 多く 私たちは二階に上がった 会長 なお、雨の場合は中止です 今日の新聞、何処に置いた まず 近く 百 前売券は窓口で販売しています 存在 生活 可能 もう 私は弟と妹と実家に帰りました 川の岸に桜の木があります あの馬鹿は二本の鉛筆を箸にして、ご飯を食べる 向日葵は草より綺麗です ご飯を食べましょう ジーンズを買いましょう 犬は大きくありません もう 私は石原さんに防虫スプレーをあげました あなたの会社は私の会社に統計ソフトウエアをくれました 私のノートはどれですか 夏は涼しくありません 皆は運動会の予定をわかります 犬は大きくありません 私は討論を始めたいです 原稿改訂する 猿 期末テスト 社員食堂 レタスの葉 文房具 中学生 レタス ツアーガイド 走る する センチメートル ドゥ 2019-10-1今月 彼女はイタリア語ができます 待つ 会議は四時に終わります 勝つ 上司が、一杯、飲もうと言った 建てる もらう 引く 電車で子供が騒いでいた 帰る 七日 四月に大学に入学しました 動き 何か飲み物が欲しいな 起きる 左 段階 塩、胡椒加えてください 決定 彼は就職試験を受けた 生活 計画を一部変更しましょう 残る 目たつ 彼がクラスの代表だ 特徴 あまり 姿 十分 運動会は九時開始です 試合の相手は誰ですか 事実 相手 生まれる 提供 弟は父の性格がわかります あなたの会社は私の会社に統計ソフトウエアをくれました コーヒーを飲みましょうよ 佐々木さんはサラリーマンです 塩、胡椒加えてください 机の上に雑誌があります あのバカは二本の箸を鉛筆にして、ご飯を食べる 彼女はマイカーを買いたがります 楽しい一日 冷蔵庫に三つのリンゴとオレンジがあります 運動会は九時開始です 彼は学校に来ませんでした 氷山が小さくなる 犬は大きくありません 私は歌を歌うことができます 浅い川 皿 ゲームソフト 液晶テレビ 原稿改訂する あのバカはに二本の鉛筆を箸にして、ご飯を食べる コーラ 期末レポート かっこいい あごひげ 私は物理の基礎は知っています 教授が図を説明する ドゥ 犬は大きくありません 原稿改訂する ドゥ","link":"/zh-tw/japanese/2019/October/index.html"},{"title":"January 2020","text":"2020-1-31言う 直ぐ 彼はまだ若いです 大学に行って、もっと勉強したいです 書く 右 勝つ 妹は平仮名を全部覚えました 暑い 来月の二十日は弟の誕生日です 彼女は可愛いけれども、わがままな人です 宿題は自分でやりなさい つける 五日 建設 バラには色々な種類があります 選ぶ もう 理由 生まれる 北川さんはたくさん食べましたけれども、全然太りません 銀行は３時まで開いています いい方法思いつきました 比べる 私たちは二階に上がった 力 計画 彼は非常に高い技術を持っている 加える 彼は文章がとてもうまい テレビをつけましたけれども、画面がなかなか出ません 作業 受付でプログラムを受け取った 彼女は可愛いけれおども、わがままな人です 言う 北川さんはたくさん食べますが、全然太りません 彼女は可愛いけれども、わがままな人です パソコンを買いましたけれども、キーボードがありません 音量を大きくする 私にデジタルカメラをくれました 次に、登園で飛行機を見に行きました 昨日、財布を無くしました。それに、傘も電車に忘れました 彼女は可愛いけれども、わがままな人です 建設 もう 北川さんはたくさん食べましたけれども、全然太りません 私は先月台湾を旅行しました ふーん、それで 犬が大きくありません 北川さんはたくさん食べましたけれども、全然太りません 天気が良くありません。それで、海に行くのをやめました 明日からは夏休みですだけれども、宿題がいっぱいあります テレビをつけましたが、画面がなかなか出ません それから、南投で有名な牧場に遊びに行きました ゴミ箱にペットボトルがあります 彼女は可愛いですが、わがままな人です テレビをつけましたけれども、画面がなかなか出ません スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 最後に、南投から台北に帰りました この店は高いけれども、全然美味し行くありません 彼女は可愛いけれども、わがままな人です 明日からは夏休みだけれども、宿題がいっぱいあります 道を迷いました。それで、交番に道を尋ねに行きました 床に蟻がいます すみません、今は何時ですか 日本、ヨーロッパ、そしてアメリカを旅行しました テレビをつけましたけれども、画面がなかなか出ません あの歌手は有名だけれども、歌が下手です どこが賑やかですか 北川さんはたくさん食べましたけれども、全然太りません 夏なのに、幼名山で雪が降りました 夏なのに、陽明山で雪が降りました 回 私は頑張りたくありません それで、これからどうします 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 夏なのに、陽明山で雪が降りました 台南に遊びに行きました。そして、美味しいものをたくさん食べました 梅 液晶テレビ 夏なのに、陽明山で雪が降りました コンビニ弁当 おやつ 夜市 道を迷いました。それで、交番に道を尋ねに行きました せみ テレビをつけましたけれども、画面がなかなか出ません 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 夏なのに、幼名山で雪が降りました 夏なのに、陽明山で雪が降りました 蝉 2020-1-30学校 もらう 会う わかる 彼女はOLです 笑う カナダの冬はとても寒いです また会いましょう 質問 どれ もう 近所で盗難事件が起こりました 十日後に帰ります 先月の七日に孫か生まれました 受付でプログラムを受け取った ほどんと 比べる 今の首相はあまり力がない これは重要な書類です 結果 備える システムの構成を変えてみました 会談 与える いずれ バラには色々な種類があります あの歌手はトレも有名だけれども、歌が下手です 語る 今日の新聞、どこに置いた 販売 計算 私はフォクでパスタを食べます あの歌手は有名だけれども、歌が下手です 私は先月台湾を旅行します 昨日財布を無くしました。それに、傘も電車に忘れました 飛行機が二時間遅れました。なので、到着時間も遅くなります えっと、電車が遅れたので、遅刻しました 二月に日本を旅行しました。それから、韓国と中国にも行きました 天気が良くありません。それで、海に行くのやめました 明日からは夏休みだけれども、宿題がいっぱいあります 受付でプログラムを受け取った 本棚に小説と雑誌があります 北川さんは沢山食べますが、全然太いません 私は好きなことは音楽を聴くことです あの喫茶店は静かですから、それでテストの勉強をします バラには色々な種類があります 周りが静かになる 私は日本の神社を参拝しました。な、それから、お守りを買いました それで、これからどうします それから、南投の有名な牧場に遊びに行きました 私は先生と職員室に行きました あの歌手は有名だけれども、歌が下手です あのお店は高いけれども、全然お美味しくありません 犬は大きいです 台南に遊びに行きました。そして、お美味しいものをたくさん食べました 天気が良くありません。それで、海に行くのやめました 明日からは夏休みですが、宿題がいっぱいあります 和食と言えば、寿司や味噌汁や天ぷらなどです 明日からは夏休みだけれども、宿題がいっぱいあります 新しいパソコンを買いましたが、キーボードがありません 新しいパソコンを買いましたが、キーボードがありません このノートは私のです 明日からは夏休みだけれども、宿題がいっぱいあります 彼女は可愛いですが、わがままの人です 昨日はテレビを見ました。それから、テストの勉強をしました そのレストランは高いですが、全然美味しくありません 明日から夏休みですけれども、宿題がいっぱいあります テレビをつけましたが、画面がなかなか出ません 最近、雨の日が多いです。それに、台風が二個きました パソコンを買いましたけれども、キーボードがありません そして、台中で有名な湖の隣のホテルに泊まりました 話すはここまでです。な、それから 寂しい とり レンタサイクル 動詞 大人 栓抜き 妹はコップを割った 新しいパソコンを買いましたけれども、キーボードがありません フルート 明日からは夏休みだけれども、宿題がいっぱいあります パソコンを買いましたけれども、キーボードがありません 新しいパソコンを買いましたけれども、キーボードがありません 2020-1-29読む 短い 私は朝シャワーを浴びます もっと 駅からタクシーに乗ってください 元気 彼の日本語のレベルは私と同じくらいだ 素敵な色のセーターですね 午前 彼女は可愛いですが、わがままな人です 探す 言葉 行く わからない場合は私に聞いてください 彼女は可愛いですが、わがままな人です 金曜日の夜は友達と出かけます 弟は野球が好きです 小さい花が咲いています 彼女は可愛いですが、わがままなひとです 触る 茶色 野球は9人で人チームです お腹 泊まる 従来 会長 結果 北川さんはたくさん食べますが、全然太りません 最近、株を始めました 経営 これは重要な書類です まず 計算 その質問に対する答えが見つからなかった 北川さんはたくさん食べましすが、全然太りません 内容 テレビを付けましたが、画面がなかなか出ません 事務的な処理に1週間かかります 彼女は可愛いですが、わがままな人です 彼女は可愛いですが、わがままな人です テレビを付けましたが、画面がなかなか出ません 続ける 結果 増える 彼がクラスの代表だ この店は高いですが、全然美味しくありません 話はここまでです。な、それから パソコンを買いましたが、キーボードがありません これは重要な書類です 私の得意なことはギターを弾くことです 最後に、南投から台北に帰りました 天気が良くありません。それで、海にやめました 私はフォークでパスタを食べます 北川さんはたくさん食べますが、全然太りません 友達は朝九時に家に来ました。そして、夜6時にみんな帰りました なんで台湾の会社は大学生を雇いたくないのですか 彼は運動場で倒れました。そして、三分後救急車が来ました いつが暇ですか 土曜日か日曜日です 宿題をしました。それに、明日の授業の予習もしました 授業をした教師 次に、桃園で飛行機を見に行きました 日本、ヨーロッパ、そしてアメリカを旅行しました この店は高いけれでも、全然おいしくありません まず、台北のお寺と夜市に行きました 和食と言えば、寿司や味噌汁や天ぷらなどです テレビを付けましたが、画面がなかなか出ません 小林さんは中国語を話すことができます それで、どうした 明日からは夏休みですが、宿題がいっぱいあります 天気が良くありません。それで、海に行くのやめました 私はフォクでパスタを食べました 最近、雨の日が多いです。それに、台風もニコ来ました このノートは私のです 何も買いません 私の趣味は本を読むことです 私は彼女のことが好きです 昨日、テレビを見ました。それから、テストの勉強をしました 冷蔵庫に三個のリンゴーとオレンジがあります けえは私のパソコンです あの歌手は有名だけれども、歌が下手です 和食といえば、寿司や味噌汁や天ぷらなどです この店は高いけれども、全然美味しくありません なんでこんな時間に学校にいないのですか それで、これからどうします 私は両親の支えでマンションを買いました 本棚に小説と雑誌があります 私は世界一周をしたくありませんでした お爺さんは昔の記憶を忘れたがります このノートは私のです 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 私は頑張りたくありません メロン 液晶テレビ 水曜日 ９分 キャベツ 大人 ラーメン 北川さんはたくさん食べますが、全然太りません 調味料 サツマイモ 鶏肉 テレビをつけましたが、画面がなかなか出ません あの歌手は有名だけれども、歌がは下手です 栓抜き サイ この店が高いけれども、全然美味しくありません それで、これからどうします 本棚に小説と雑誌があります 大人 北川さんはたくさん食べますが、全然太りません テレビをつけましたが、画面がなかなか出ません 栓抜き 大人 この店が高いけれども、全然美味しくありません 2020-1-28今日は日本語の授業があります 右 郵便局で切手を買いました 持つ 考える 緑 使う 彼に手紙を書きました 出来る 冷たい 答えが違います この店は高いですが、全然美味しくありません 細い 入る 時計を見たら、ちょうど3時だった 昨日、あなたのお姉案に会ったよ 銀行は3時まで開いています 力 これら 変化 資金 彼が来た目的がわかりません 計算 販売 重要 彼は何年も地震の研究をしている この服は三百ドルしました 昨年 このお店は高いですが、全然美味しくありません 対象 方向 二月に日本を旅行しました。それから、韓国と中国にも行きました えっと、電車が遅れたので、遅刻した 彼は運動場で倒れました。そして、三分後救急車が来ました この店の料理は美味しいです。それに、値段もとても安いです リビングのソファで寝ました。それで、風邪をひきました 私は日本料理を作ることが少しできます ないでください 明日からは夏休みですが、宿題がいっぱいあります 国仲さんはあなたにギターをもらいました この店は高いですが、全然美味しくありません まず、台北のお寺と夜市に行きました 日本語を上手にする 最後に、南投から台北に帰りました それで、これからどうします 日本の神社に参拝しましたよ。な、それから、お守りも買いました 宿題をしました。それに、明日の授業の予習もしました いつが暇ですか 土曜日か日曜日です このお店は高いですが、全然美味しくありません 氷山が小さくなる ボタンを押す そして、台中の有名な湖の隣のホテルに泊まります 床に蟻がいます 道に迷いました。それで、交番に道を尋ねに来ました それから、南投の有名な牧場に遊びに行きました 最近、雨の日が多いです。それに、台風もにこ来ました 私は王建民ほど有名ではありません 明日からは夏休みですが、宿題がいっぱいあります パソコンを買いましたが、キーボードがありません。 昨日、財布を無くしました。それに、傘も電車に忘れました それで？これからどうします 隣人 羊 幽霊 液晶テレビ いつが暇ですか 土曜日か日曜日です タプレット スーツケースに詰める 明日から夏休みですが、宿題がいっぱいあります 彼女は茶髪で、えくぼがあります パソコンを買いましたが、キーボードがありません パソコンを買いましたが、キーボードがありません 液晶テレビ 明日から夏休みですが、宿題がいっぱいあります パソコンを買いましたが、キーボードがありません 2020-1-27今月 使う 今朝は早く家を出ました 浴びる いつ 誰と会ってみたいですか 右 重い 起こす 私は朝シャワーを浴びます 聞く 妻 太い お母さんによろしくを伝えください 休む こっち 一日 三日 側 宿題は自分でやりなさい 上る この段階では決断するのはまだ早い 利用 問題が一つあります 商品 資金 相手 計算 全体の80%が完成しました 処理 運動会は9時開始です 住宅 力 いい方法思いつきました 価格 これからより一層努力します 治る 駅の前に新しいコンビニをできました。それから、駅の後ろに新しいコンビニをできました 右 リビングのソファで寝ました。それで、風邪をひきました まず、台北のお寺と夜市に行きました 昨日、財布を無くしました、それに、傘も電車に忘れました 資金 私は先月台湾を旅行しました 計算 友達は朝九時に家に行きました。それから、夜6時に帰りました 友達は朝九時に家に来ました。そして、夜6時にみんな帰りました 日本の神社を参拝しました。な、それから、御守りも買いました 力 最近、雨の日が多いです。それに、台風も二個来ました 最後に、南投から台北に帰りました それから、南投の有名な牧場に遊びに行きました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう あなたは教師ではありません ふーん、それで なぜ台湾の会社は大学生を雇いたくないのですか どれで、どうした そして、台中で有名な湖の隣のホテルに泊まりました 私は納豆が全然好きではありません 私は日本料理を作ることが全然できません スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 昨日財布を無くしました。それに、傘も電車に忘れました このお店の料理は美味しいです。それに、値段もとても安いです 彼は運動場で倒れました。そして、三分後救急車が来ました 道を迷いました。それで、交番に道を尋ねに行きました 日本語を上手にする 次に、桃園で飛行機を見に行きました 床に蟻がいます 駅弁 副詞 西洋料理 中学生 親切 炒める 彼は運動場で倒れました。そして、三分後救急車が来ました 床に蟻がいます 炒める 茶髪 2020-1-26古い 私は朝シャワーを浴びます 国 閉める 昨日、友達にあった 大人 彼は留学生です 掛ける 水曜日はバイトがあります 比べる 消える 銀行は三時まで開いています 理由 遠くに彼女の姿が見えた それは世界最大の船です それから、南投の有名な牧場に遊びに行きました 方向 今後 その会社は女性を多く採用している 彼がパーティー会場を提供してくれました それから、南東の有名な牧場に遊びに行きました 建設 彼は食品工場で働いています 特徴 島の人口は年々増加しています 彼は歌で自分の気持ちを表現した 私は朝シャワーを浴びます 与える ガソリンの価格がどんどん上がっている 前売券は窓口で販売しています 最後に、南東から台北に帰りました まま 台南に遊びに行きました。そして、美味しいものをたくさん食べました ふーん、それで？ 私の嫌いなことは部屋を掃除することです 夜市はスーパーよりうるさいです 二月に日本を旅行しました。それから、韓国と中国にも行きました そして、台中で有名な湖の隣のホテルに泊まりました 次に、登園で飛行機を見に行きました 昨日財布を無くしました。それに、傘も電車に忘れました 私は先月台湾を旅行しました 日本、ヨーロッパ、そしてアメリカを旅行しました お爺さんは昔の記憶を忘れたがります 最近雨の日が多いです。それに、台風も二個きました 向日葵は草より綺麗です それから、南投の有名な牧場に遊びに行きました 最後に、南投から台北に帰りました 私の苦手なことは料理を作る 私の苦手なことは料理を作ることです 話はここまでです。な、それから 私は日本料理を作ることが少しできます まず、台北のお寺と夜市に行きました 昨日はテレビを見ました。それから、テレビの勉強をしました 日本の神社に参拝しましたよ。な、それから、お守りも買いました 道を迷いました。それで、交番に道を尋ねに行きました 車の後ろに子猫と子犬がいます 私のカバンはどれですか 母とペットと海外旅行をしました 私はピーマンが嫌いです 駅の前に新しいコンビニができました それから、南投の有名な牧場に行きました 彼は運動場で倒れました。そして、三分後救急車が来ました 私は石原さんに防虫スプレーをあげました 学長 校長 メロン カーテン 雨の後、虹が見られるかもしれません 私は物理の基礎はしています ㎝ 質問する お 最後に、南投から台北に帰りました 道に迷いました。それで、交番に道を尋ねに行きました 彼は運動場で倒れました。そして、三分後救急車が来ました それから、南投の有名な牧場に遊びに行きました 最後に、南投から台北に帰りました 2020-1-25覚える 国 兄は水泳が得意です 楽しむ 使う 彼は医者になりました 妹は平仮名を全部覚えました 少し疲れました 日本の神社に参拝しましましたよ。な、それから、御守りも買いました 軽い 午後 私が払いましょう 千円貸してください 日本の神社に参拝しましたよ。な、それから、御守りも買いました それはどういう意味ですか 目的 私は先月台湾を旅行しました 全体の八十パーセントが完成しました トラブルがやっと解決した いい方法思いつきました 首相 方向 部長を除く全員が土曜日も働いた 対する まず、台北のお寺と夜市に行きました 状態 これら 帰ったら、まず手を洗いましょう 銀行は三時まで開いています 最近株を始めました よく答えがわかりました 日本の神社に参拝しましたよ。な、それから、お守りを買いました 私は先月台湾を旅行しました 方向 銀行は三時まで開いています まず、台北のお寺と夜市に行きました 中心 よく答えがわかりました 私は神社に参拝しましたよ。な、それから、お守りを買いました 駅の前に新しいコンビニができました。それから、駅の後ろに新しいコンビニができました 昨日財布を無くしました。それに、傘も電車に忘れました 私は日本料理を作ることがあまりできません 日本、ヨーロッパ、そしてアメリカも旅行しました この犬 道に迷いました。それで、交番に道を尋ねに行きました 先月台湾を旅行しました 私はおばあちゃんのことが好きです このお店の料理は美味しいです。それに、値段もとても安いです 天気が良くありません。それで、海に行くのをやめました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 彼は運動場で倒れました。そして、三分後救急車が来ました 私は日本の神社に参拝しましたよ。な、それから、お守りを買いました 昨日、財布が無くしました。それに、傘も電車に忘れました 私は先月台湾を旅行しました なんでこんな時間に学校にいないのですか テレビを見ました。それから、テストの勉強をしました 最近、雨の日が多いです。それに、台風もにこ来ました 何か買いますか いいえ、何も買いません 二月に日本を旅行しました。それから、韓国と中国にも行きました まず、台北のお寺と夜市に行きました 話はここまでです。な、それから 私は学生です 今夜は蒸し暑いから、明日は雨が降るでしょう 友達は朝九時に家にきました。そして、夜六時にみんな帰りました 最近、雨の日が多いです。それに、台風も二個きました すみません、今は何時ですか 次、桃園で飛行機を見に行きました 次に、桃園で飛行機を見に行きました 庭の松は高いです 私は世界一周をしたくありません おじいさんは昔の記憶を忘れたがります 宿題をしました。それから、明日の授業の予習もしました まず、台北のお寺と夜市に行きました 次に、桃園で飛行機を見に行きました 次に、登園で飛行機を見に行きました お爺さんは昔の記憶を忘れたがります それで、これからどうします 台南に遊びに行きました。それから、美味しいものを沢山食べました 弟は父の性格がわかります そして、台中で有名な湖の隣のホテルに泊まりました 小林さんは中国語話すことができます 大学の先輩は商売ができます リング 答え 水族館 そして、台中で有名な湖の隣のホテルに泊まりました 苺 明後日 腿 スーツケース そして、台中で有名な湖の隣のホテルに泊まりました そして、台中で有名な湖の隣のホテルに泊まりました 2020-1-24足 いつも 親の愛は有り難い 決める また会いましょう 元気 腕 違う 七日 最近、雨の日が多いです。それに、台風も二個きました 息子は六つになりました 切る 宿題は自分でやりなさい 六日前に日本に帰ってきました 喉が乾きました 茶色 四日 細い 昨日はテレビを見ました。それから、テストの勉強しました 触る 答える 最近株を始めました 全体の80%が完成しました 昨日はテレビを見ました。それから、テストの勉強をしました 最近、雨の日が多いです。それに、台風を二個きました 姿 与える 対象 管理 のち 飛行機は一時間以上遅れた 新聞 昨日テレビを見ました。それから、テストの勉強をしました 最近、雨の日が多いです。それに、台風も二個きました いい方法を思いついました この携帯電話が使えるのは国内だけです 比べる これら 新しいビルの建設が始まった 女性 二月に日本を旅行しました。それから、韓国と中国にも行きました 最近、株を始めました 段階 やる 一緒に対策を考えましう それで？これからどうします 私の嫌いなことは部屋を掃除することです ふーん、それで？ 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 日本、ヨーロッパ、そしてアメリカを旅行しました 全体の80パーセントが完成しました 昨日はテレビを見ました。それから、テストの勉強をしました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 最近、雨の日が多いです。それに、台風も二個きました 私は日本語が大体できます 昨日財布を無くしました。それに、傘を電車に忘れました いい方法を思いつきました 最近、雨の日が多いです。それに、台風も二個きました これら 昨日テレビを見ました。それから、テストの勉強をしました 台南に遊びに来ました。そして、美味しいものをたくさん食べました 引き出しにハムスターが一匹います 床に蟻がいます その子供は親友と遊びたがります 二月に日本を旅行しました。それから、韓国と中国にも行きました 友達は九時に家に来ました。そして、夜六時にみんな帰りました 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 日本、ヨーロッパ、そしてアメリがを旅行しました なんでこんな時間に学校にいないのですか 彼は運動場で倒れまhした。そして、三分後救急車が来ました そっか、今度早く家を出ろ その店の料理が美味しいです。それに、値段を安いです 話はここまでです。な、それから 小林さんは中国語を話すことができます 宿題をしました。それに、明日の授業の予習もしました 話はここまでです。な、それから 道を迷いました。それで、交番に道を尋ねに行きました リビングのソファで寝ました。それで、風邪をひきました 病人が元気になる 私は日本料理を作ることが少しできます 二月に日本を旅行しました。それから、韓国と忠告もに行きました なんでこんな時間に学校にいないのですか 彼は運動場で倒れました。そして、三分後救急車がきました 小林さんは中国語を話すことができます 道を迷いました。それで、交番に道を尋ねに行きました 話はここまでです。な、それから 二月に日本を旅行しました。それから、韓国と中国にも行きました 私の得意なことはギターを弾くすることです 私は世界一周をしたかったです それで、どうした 国仲さんはあなたにギターをもらいました 駅の前に新しいコンビニができました。それから、駅の後ろにもコンビニができました 天気がよりありません。それで、海を行くのをやめました メロン 餌 博物館 話はここまでです。な、それから カード レンタサイクル サツマイモ 茶髪 彼は運動場で倒れました。そして、三分後救急車が来ました 二月に日本を旅行しました。それから、韓国と中国にも行きました 駅の前にコンビニができました。それから、駅の後ろにもコンビニができました 話はここまでです。な、それから 2020-1-23冬 猿も木から落ちる 入れる 生きる 早い 彼女はいい友達です 一日 大人 細い 新しいテープルを買いました 辛い 彼女は眠いようです 予約は要りません 彼は運動場で倒れました。そして、三分後救急車がきました 上る くる 切る これは医者のためのサイトです 与える 最近、雨の日が多いです。それに、台風もにこ来ました 彼は運動場で倒れました。そして、三分後救急車がきました 交差点で、事故が発生した 最近、雨の日が多いです。それに、台風も二個きました お金はまだ十分あります 彼は運動場で倒れました。そして、三分後救急車がきました 彼は運動場で倒れました。そして、三分後救急車がきました 比べる そのデモについて、政府は何もしなかった 変わる 大統領 大学で経済を勉強しました 最近、雨の日が多いです。それに、台風も二個きました 作業 もう 台南に遊びに行きました。そして、美味しいものをたくさん食べました 最近雨の日が多いです。それに、台風も二個きました 日本、ヨーロッパ、そしてアメリがを旅行しました この店の料理は美味しいです。それに、値段もとても安いです リビングのソファで寝ました。それで、風邪をひきました それで、どうした 友達は朝九時に家に来ました。そして、夜六時にみんな帰りました なぜ大体のお店は試食を置きますか 大きくなかった 宿題をしました。それに、明日の予習もしました 国仲さんはあなたにギターをもらいましたよ 最近、雨の日が多いです。それに、台風も二個来ました 彼は運動場で倒れました。そして、三分後救急車が来ました 比べる 彼は運動場で倒れました。そして、三分後救急車が来ました 昨日財布を無くしました。それに、傘も電車に忘れました 私は日本料理を作ることが少しできます 道に迷いました。それで、交番に道を尋ねに行きました 昨日財布を無くしました。それに、傘も電車に忘れました 日本、ヨーロッパ、そしてアメリカを旅行しました 最近雨の日が多いです。それに、台風も二個きました 最近、雨の日が大きです。それに、台風も二個きました この店の料理は美味しいです。それに、値段もとても安いです 国仲さんはあなたにギターをもらいましたよ 宿題をしました。それに、明日の授業の予習もしました 私は日本料理を作ることが少しできます 道に迷いました。それで、交番に道を尋ねに行きました 昨日財布を無くしました。それに、傘も電車に忘れました ふーん、それで あの店の料理が美味しいです。それに、値段もとても安いです ないでください 先生は学生の気持ちがとてもわかります 貯金箱にコインが四十個あります 彼女を幸せにする私のノートはどれですか バカ！言い訳するな！ 上野さんは彼女と映画を見ました 宿題をしました。それに、明日の授業の予習もしました それで、これからどうします スピーチは何時からですか 私はピーマンが嫌いです スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 私は寿司が好きです 天気が良くありません。それで、海に行くのをやめました あれはカーテンです 昨日財布を無くしました。それに、傘を電車に忘れました この店の料理は美味しいです。それに、値段もとても安いです キャベツ メロン 皿 竜巻 茶髪 それで？これからどうします 宿題をしました。それに、明日の授業の予習もしました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 昨日財布を無くしました。それに、傘も電車に忘れました メロン 茶髪 それで？これからどうします？ スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 2020-1-22そう 歩く 待つ 彼の日本語のレベルは私と同じくらいだ 彼の気持ちが分からない 妹は平仮名を全部覚えました 一から始めましょう 飛ぶ ふーん、それで？ 短い うち 会う 戻る 服 まずい 五月五日は祝日です ふーん、それで？ 彼に会えて嬉しかった 強い 入る 辺 米 宿題は自分でやりなさい ふーん、それで？ 赤い線を二本引いて下さい 夕食には何を食べたいですか 私は風邪をひきました 関係 彼がクラスの代表だ やる スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 社会 開始 与える スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 我が社の経営はうまくいっています その会社は来月キャンペーンを置くなう スーパーで野菜、人参、玉葱、そしてじゃがいも買いました ふーん、それで？ 国会が再開した 電気がついたままですよう ふーん、それで？ 建設 可能 日本、ヨーロッパ、そしてアメリカを旅行しました ダムの開発に住民は反対しています 国会 日本、ヨーロッパ、そしてアメリカを旅行しました トラブルがやっと解決した 彼は行政を改革したいと思っている 対策 台南に遊びに行きました。そして、美味しいものをたくさん食べました 外国 与える 川の岸に桜の木があります 道に迷いました。それで、交番に道を尋ねに行きました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました スーパーで野菜、人参、玉葱、そしてジャガイモを買いました 友達は朝九時に家に来ました。そして、夜六時にみんな帰りました それで、これからどうします ドアを開ける どこが賑やかですか どうして台湾の会社は大学生を雇いたくないのですか 日本、ヨーロッパ、そしてアメリカを旅行しました ボタンを押す 日本、ヨーロッパ、そしてアメリカを旅行しました 私はピーマンが嫌いです あの服のほうが可愛いです 台南に遊びにいきました。そして、美味しいものをたくさん食べました 天気が良くありません。それで、海に行くのをやめました あなたは教師です 寝る猫 友達は朝九時に家に来ました。そして、夜六時にみんな帰りました それで、どうした リビングのソファで寝ました。それで、風邪をひきました 道に迷いました。それで、交番に道を尋ねに行きました 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 友達は朝九時に家にきました。そして、夜六時にみんな帰りました 湖 台南に遊びに行きました。そして、美味しいものをたくさん食べました 水族館 海 ペット 羊 炒める ぬ 日本、ヨーロッパ、そしてアメリカを旅行しました 友達は朝九時に家に行きました。そして、夜六時にみんな帰りました それで、どうした 台南に遊びに行きました。そして、美味しいものをたくさん食べました 2020-1-21彼はかなり英語が上手です グラスの数が足りません その次の週は空いていますか 妹は平仮名を全部覚えました また会いましょう あなたが来るのを待っています 天気が良くありません。それで、海に行くのをやめました 祖父が病気になった 彼はまだ若いです 私は手伝いましょう 触る 閉める 道に迷いました。それで、交番に道を尋ねに行きました 風邪 八日からイギリスに行きます 茶色 先月の七日に孫が生まれました 道に迷いました。それで、交番に道を尋ねに行きました 妹は平仮名を全部覚えました 治る ある 一日 来月の二十日は弟の誕生日です 後ろを向いて 天気が良くありません。それで、海に行くのをやめました 手紙が届くのに三日かかりました 天気が良くありません。それで、海に行くのをやめました 宿題は自分でやりなさい 天気は良くありません。それで、海に行くのをやめました 示す 道を迷いました。それで、交番に道を尋ねに行きました 関係 彼は新製品に興味を示している 道に迷いました。それで、交番に道を尋ねに行きました 宿題は自分でやりなさい 天気が良くありません。それで、海に行くのをやめました 道を迷いました。それで、交番に道を尋ねに行きました ここは一方通行です 彼は選挙に出るつもりだ リビングのソファで寝ました。それで、風邪をひきました その質問に対する答えが見つからなかった 繰り返す 対象 留学してから私の世界が広がった 強調 それで、これからどうします 会談 現在 うちは五人家族です 二十キロのダイエットは可能だと思いますか それで、これからどうします それで、どうした 私は鉛筆で字を書く 私の得意なことはギータを弾くことです 飛行機が二時間遅れました。あので、到着時間も遅くなりました それで、どうした 私は紙で鶴を作りました リビングのソファで寝ました。それで、風邪をひきました 私は頑張りたくありません 昨日、何処かに行きましたか はい、コンサートに行きました 私は刺身があまり好きではありません どこが賑やかですか すみません、今は何時ですか それで、これからどうします 昼ごはん 暇 楓 て アパート それで、どうした レンタサイクル それで、これからどうします リビングのソファで寝ました。それで、風邪をひきました 栓抜きありますか 腹部は肋とお尻の間の部分です サツマイモ それで、これからどうします それで、どうした リビングのソファで寝ました。それで、風邪をひきました それで、これからどうします それで、どうした 2020-1-20右 彼女 授業 起こす 食べる 答えが違います 服 どうして泣いているの その人には2回に会った 上る この部屋は寒いです 対象 株 声 もう そっか、今度早く家をでそ これは私の小説です 私はピーマンが嫌いです 私の嫌いなことはバスケットをすることです すみません、今は何時ですか 彼は学校に来ませんでした 授業をする教師 私の得意なことはギターを弾くことです 台北駅はどこですか 今夜は蒸し暑いから、明日は雨が降るでしょう ライブ 下手 大人 ポルトガル 子猫 小学生 マイカー 雨の後、虹が見られるかもしれません サツマイモ 一日 対象 すみません、今は何時ですか 私の得意なことはギターを弾くことです サツマイモ 2020-1-19彼は歯が白い また会いましょう 引く 五月五日は祝日です 触る 側 コップを三つ買いました クーラーはまだ直りません 細い 先 今晩 上る 私は夏が大好き 閉める 茶色 内容 あなたの意見が聞きたいです 政権が交代した 宇宙人は存在すると思いますか 交渉 消える 目立つ 種類 参加 事実 まあ、今回は許してあげよう 方針 対する 増える なぜ大体のお店は試食を置きますか そっか、今度早く家を出ろ すみません、今は何時ですか 深い湖 どうして私の家に来ましたか 私はもっと頑張りたかったです 大学の先輩商売ができます レシートください 私は泳ぐことができます 犬と猫と兎、どれが好きですか 私はピーマンが嫌いです 料理をおいしくする そっか、今度早く家を出ろ すみません、今は何時ですか 私はピーマンが嫌いです 眠くなる ないでください 新しいゲームソフトを買いました。だから、古いソフトを売りました キャベツ レンタサイクル 店長 松 タプレット 高層ビル 一眼レフカメラ 雑誌 炒める 2020-1-18また会いましょう 会議は四時に終わります そこに座ってください 午前九時のニュースです 彼の日本語のレベルは私と同じくらいだ 結婚 三人 触る 口 細い 多分 時 お手洗い 夏休みももう終わりだ 入る 茶色 柿の木に実がたくさんなっています なお雨の場合は中止です かぶ 伴う よく それは最近話題の本ですね その仕事は危険を伴う お相撲さんはみんな力持ちだ 理由 土地 構造 私はフォークでパスタを食べます 冷蔵庫に三つのリンゴとオレンジがあります 私は会社に行きます 私は日本料理が好きです あの屋敷に幽霊がいますよ 動物園にライオンがいます また会いましょう 私は魚が嫌いです ないでください 石原さんは彼に防虫スプレーをもらいました 佐々木さんはサラリーマンでした 触る 細い どこが賑やかですか ボタンを押す 茶色 えっと、電車が遅れたから遅刻しました 台北の夜市は賑やかです。九分も賑やかです ご飯を食べましょう 予備校生 レンタサイクル 液晶テレビ 記憶 ラーメン 海外旅行 羊 ㎝ フクロウ ないでください 2020-1-17あげる 春 素敵な色のセーターですね 入れる 呼ぶ まだ学校へ行くには早い時間です 酒 短い 右 売る 天気 千円貸してください 違う 私はパンよりご飯が好きだ 教科書を閉じてください 私は二日待った 痛い 入る 作業 彼は非常に高い技術を持っている 提供 一部 輸入 システムの構成を変えてみました 彼は文章がとてもうまい 彼は良いだけを強調した 報告 それは世界最大の船です 短い鉛筆 向日葵は草より綺麗です ご飯を食べた人 一時から四時までです 今夜は蒸し暑いから、明日は雨が降るでしょう 私は鉛筆で字を書く 私は寿司が好きです 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう どこが賑やかですか えっと、電車が遅れたので、遅刻した 私は日本語が少しできます カーテン 社員食堂 カレンダー 大きな竜巻 入る 羊 映画 教授が図を説明する 炒める どこが賑やかです 羊 2020-1-16右 それ全部ください 同じ 彼の日本語のレベルは私と同じくらいだ 会う 私が払いましょう 兄は水泳が得意です 一つ 今朝は早く家を出ました 7つ 夕食には何を食べたいですか お腹 曜日を間違えました 上 十日後に帰ります 妻 来月の二十日は弟の誕生日です ゲーム まず相手の動きを見ましょう 彼がクラスの代表だ 二十キロのダイエットは可能だと思いますか 文章 十分 処理 一般 予定 変わる 私は彼から大きな影響受けました 病院 生活 トラブルがやっと解決した 対する 右 合格者が発表された 国は国語教育を強化しています 前売券は窓口で販売しています その問題関する記事を読みました 兄は船の設計をしています 輸入 これは世界最大の船です 計画を一部変更しましょう 飛行機が二時間遅れました。なので、到着時間も遅くなりました 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 私は懐石料理がすごくできます 私の嫌いなことは部屋を掃除することです なぜ台湾の会社は大学生を雇いたくないのですか 川の岸に桜の木があります 私は懐石料理が一番好きです ボタンを押す 机の上に雑誌があります 有名な歌手 私は頑張りたくありません 今夜は蒸し暑いから、明日は雨が降るでしょう スピーチは何時からですか キャベツ 親戚 はな 湖 炒める 調味料 雨の後、虹が見られるかもしれません 私は物理の基礎は知っています 今夜は蒸し暑いから、明日は雨が降るでしょう 炒める 2020-1-15親の愛は有り難い 難しい する 彼の日本語のレベルは私の同じ位だ 彼はまだ若いです 一日 これはかなり金がかかった 人 私の妹は小学生です 嬉しい 閉める ここは父の土地です 全国 影響 外国 ほぼ その事件の犯人はまだ捕まっていない その質問に対する答えが見つからなかった 彼女の大きな帽子はとても目立つ 子供の頃よくその公園で遊んだ その会社は来月キャンペーンを行う 今日の新聞、どこに置いた 企業 建設 一般 のち どこも行きません ボタンを押す 彼の日本語のレベルは私と同じくらいだ 私は日本料理を作ることがあまりできません ペットを飼いましょう 日曜日は暇です あの歌手は有名ではありませんでした ご飯を食べている人 翻訳する 博物館 学長 ノートパソコン フルート 雨の後、虹が見られるかもしれません フクロウが頭を上下に動かしている りや みや ボタンを押す 雨の後、虹が見られるかもしれません 2020-1-14この言葉の意味がわかりません また会いましょう 短い 私は朝シャワーを浴びます 彼に会えて嬉しかった 違う 五日 来月の二十日は弟の誕生日です 大丈夫 先月の七日に孫が生まれました 閉める お店はもう閉まっていました お母さんによろしくを伝えください 酸っぱい 今後 工場 期待 二社は互いに競争している 広がる 二十キロのダイエットは可能だと思いますか この携帯電話が使えるのは国内だけです 信号が青に変わりました ほとんど 今回 水を熱くする 宮沢さんは課長のことを、どう思いますか 私は世界一周をしたくありません 今日、何か買いますか はい、オレンジ買います 日曜日が暇です 冷蔵庫にリンゴとオレンジが三つあります 閉める 竹 鶴 大人 広告 キャベツ 黒板 おやつ 冷蔵庫 チームで、フットバールをしている 葉が落ちます 2020-1-13短い 祖父が病気になった また会いましょう 考える 次はいつ会いましょうか 約束を忘れないでください グラスの数が足りません 取る 答えが違います 四日 昨日から腰が痛い 目 見える 来月の二十日は弟の誕生日です 彼はシートベルト締めた 一杯 口 後ろ 一日 調べる 二十キロのダイエットは可能だと思いますか 問題 内容 建設 いずれ なお、雨の場合は中止です 管理 彼がクラスの代表だ 宮沢さんは課長のことを、どう思いますか 短い なんで今日私の家に来ましたか また会いましょう ペットを飼いましょうか あなたは小西さんに映画のチケットをもらいますか 上野さんは彼女と映画を見ました 何も要りません 飛行機が二時間遅れました。なので、到着時間も遅くなります 隣の人は私の猫に餌をくれました 来月の二十日は弟の誕生日です あの喫茶店は静かなので、あそこで勉強する人は多いでしょう 消しゴム 火曜日 キャベツ 動詞 ラーメン 小学生 合格点 彼女は茶髪でえくぼがあります 調味料 二十キロのダイエットは可能だと思いますか 虹 キャベツ 2020-1-12肩 そう くれる 会う 場合 夕食には何を食べたいですか 終わり 掛ける 六日前に日本に帰ってきました 日曜日 32ページを開いてください 一日 夜 彼がクラスの代表だ もう 解決 情報 ここは道の状態がとても悪いです 一日 彼がクラスの代表だ 決定 変化 その質問に対する答えが見つからなかった 彼女は命令に従わなかった その会社は来月キャンペーンを行う ガソリンの価格がどんどん上がっている ダムの開発に住民は反対しています いずれ 作業 企業 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう 今日は何曜日ですか 私は頑張りたありません 飛行機が二時間遅れました。なので、到着時間も遅くなります 私は実家に帰りたいです 私の嫌いなことは部屋を掃除することです コーヒーを飲みましょうよ 今夜は蒸し暑いので、蚊が多くなりました 私の苦手なことは料理を作ることです 私は先生と職員室に行きます コイン タプレット 梅 アパート もり 女性が桃の太さを計っている フロント 飛行機が二時間遅れました。なので、到着時間も遅くなりました 2020-1-11消す 兄は水泳が得意です 朝 飛行機 知る 彼女はいつも元気だ 病気 私が払いましょう 起こす 漢字は中国から来ました 夕食には何を食べたいですか ちゃんとドアを閉めてよ お母さん 髪の毛が伸びたね 腰 休む 曜日 五月五日は祝日です 黄色い 彼女はいい友達です その質問に対する答えが見つからなかった 建設 それは世界最大の船です その会社は来月キャンペーンを行う トラブルがやっと解決した 商品 彼は文章がとてもうまい 一緒に対策を考えましょう 対する 事故 生産 方向 年 前売券は窓口で販売しています 選挙 これは重要な書類です 私は苦手なことは部屋を掃除することです 狭い部屋 スピーチは何時からですか 夕食には何を食べたいですか えっと、電車が遅れたので、遅刻しました お客さんは家に来ました 昨日、何処かに行きましたか いいえ、どこに行きませんでした 絵を描く 私は紙で鶴を作りました あの喫茶店が静かなので、あそこで勉強する人が多いでしょう ニュースで道の状況がわかります 都市は田舎より便利です その質問に対する答えが見つからなかった どうして今日遅刻した 焼き鳥 湖 ラーメン 大人 バイク その会社は来月キャンペーンを行う 布 私は苦手なことは部屋を掃除することです 2020-1-10言葉 立つ 素敵な色のセーターですね 彼はまだ若いです お腹が空きました お名前をカタカナで書いてください 火曜日に会議があります 新学期は来月の四日からです 彼は時々遅刻します 建設 外国 導入 全体のは八十%が完成しました 毎年多くの人が海外へ旅行する 今後の方針が決まった 増える 体重がかなり減りました はげしい雨が降っています 変わる 内容 今後の方針が決まった 種類 のち その計算は間違っている 私は日本料理を作ることがよくできます カレーライスとオムライス、どちらが美味しいですか 弟は父の性格がわかります 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 自転車とバイクと車、どれが便利ですか 何も食べません あの服のほうが可愛いです ゴミ箱にペットボトルがあります 建設 何で学校に行くのですか 私は茶碗蒸しがあまり嫌いではありません えさ 牛 大人 ライ面 大人 2020-1-9見つける 生きてる 私たちのチームはその試合て負けた 祖父が病気になった 会う 郵便局で切手を買いました これは医者のためのサイトです 茶色 ミーテイング 先月の七日に孫が生まれました 五つ 二つ 火曜日 辺 答えが違います 目的 今後 治る 作業 文章 理由 内容 あなたの意見が聞きたいです 比べる 規模 留学してから私の世界が広がった 計画 評価 私は先生と職員室に行きました 病人が元気になる こ 私は頑張りたくありません ゲームをしませんでした 午後一時から四時までです 向日葵は草より綺麗です あの歌手は有名です これはなんですか 自転車とバイクと車、どれが便利ですか 中学生 さ 内容 2020-1-8祖父が病気になった 私が払いましょう 勝つ 若い グラスの数が足りません 親の愛は有り難い 今朝は早く家を出ました 会う 私は朝シャワーを浴びます 覚える 秋 答えが違います 九日 違う 多分 予約は要りません 彼女は眠いようです 彼に会えて嬉しかった 閉める 四日 百 書き直す 従来 私は四つの会社に投資しています それは世界最大の船です 対する 作業 強化 完成 現在 実現 この携帯電話が使えるのは国内だけです 交渉 構成 それはどういう意味ですか 彼は文章がとてもうまい 祖父が病気になった 対象 部長除く全員が土曜日も働いた 受ける 前売券は窓口で販売しています それは最近話題の本ですね 会う 交差点で事故が発生した 答えが違います 私の苦手なことは料理を作ることです 彼は小学校の先生ですから、子供の親からのプレッシャーが大きでしょう 作業 私は懐石料理がすごく好きです どうして なぜ なんで 上手なコック えっと、電車が遅れたので、遅刻しました 冬は暖かかった 彼は社員ではありません チケットをください 私は頑張りたくありません 布団 プール 楓 博物館 木曜日 陽傘 湖 描く 折りたたみ傘 フットボール 鶏肉にしますか、魚にしますか 私は頑張りたくありません 2020-1-7昨日、タイカレーを食べました 買う 一番 素敵な色のセーターですね 夫 すぐ行きます 私が払いましょう 週 軽い 私が払いましょう 彼はまだ若いです 午前 開く お腹 時計を見たらちょうど三時だた つける 辛い そこには私一人しかいなかった 私はパンよりご飯が好きだ した 大人 トラブルがやっと解決した 彼は就職試験を受けた そのデモについて政府は何もしなかった 私たちはその問題を調査しています 私たちがその問題を調査しています 前売券は窓口で販売しています ダムの開発に住民は反対しています 計画 内容 外国 選挙 採用 もう 以上 対する 消える システムの構成を変えてみました 開発 彼は文章がとてもうまい そのデモについて政府は何もしなかった 仕事がほぼ終わりました 車の後ろに子猫と子犬がいます えっと、電車が遅れたので、遅刻しました スピーチは何時からですか 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう シャワーを浴びる象 日曜日は暇です 私は紙で鶴を作りました 小林さんは中国語を話すことができます どうして台湾の会社は大学生を雇いたくないのですか どれが綺麗ですか 中村さんは昨日夜十時まで仕事しましたので、残業代が沢山もらえるでしょう 前売券は窓口で販売しています いいえ、違います 辞書は雑誌より厚いです 対する タプレット 餌 小説 苺 期末レポート 湖 駅 台風 ツアーガイドはあなたの旅行楽しくする興味深い情報を知っているだろう 彼は文章がとてもうまい えっと、電車が遅れたので、遅刻しました 私は物理の基礎はしています 蝉 い 湖 2020-1-6素敵な色のセーターですね 質問のある方はどうぞ 質問 グラスの数が足りません素敵な色のセーターですね 私の部屋は二階にあります お願い ある こっち 私の祖母は100歳です よう どうして泣いているの 国会が再開した なお これは世界最大の船です 夢を実現するには努力が必要です ゴミのリサイクルが普及している 競争 対立 のち 特徴 変わる 写真はいい思い出になります よく 存在 帰ったら、まず手を洗いましょう 私にはたくさんのお金が必要だ 部分 今後 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 台北駅はどこですか まずい料理 私は紙で鶴を作りました 社長は部長と出かけました スピーチは何時からですか えっと、電車が遅れだので、遅刻しました ばか！いい訳するな 原稿を改訂する 記憶 猿 ペットボトル 調味料 タンス 飛行機が二時間遅れました。だから、それで怒っている人が多いでしょう 私は紙で鶴を作りました スピーチは何時からですか えっと、電車が遅れ他ので、遅刻しました 2020-1-5彼はまだ若いです 友達とお酒を飲んでいます グラスの数が足りません そう 日記 言葉 強い 千円貸してください 十日後に帰ります 食べ物 小さい花が咲いています 四日 先月の七日に孫が生まれました 違う 昨日、あなたのお姉さんに会ったよ 近所で盗難事件が起こりました これは世界の最大の船です 自由 お金がほとんどがありません 報告 話 ドル 変化 外国 消える 変わる 今後 ソフト 事件 国内 販売 構造 私は風邪をひきました。なので、映画館に行きませんでした 遊びましょう 私の好きなことは音楽です グラスの数が足りません これは世界最大の船です 変わる 今後 石原さんは彼に防虫スプレーをもらいました 私の趣味は映画を見ることです 彼は実家に帰りたがります 私は書いた原稿本にする 引き出しにハムスターが一匹います シャワーを浴びる象 私は世界一周をしたいです 辞書は雑誌より厚いです 部屋が綺麗になる まず、次に、そして、それから、最後に 鶏 ゲーム機 姉 ツアーガイド 髭剃り フクロウが頭の上下に動かしている 2020-1-4彼はまだ若いです グラス数が足りません 若い 水 お願い 四日 悪い 時計 二つ 彼に会えて嬉しかった 先月の七日に孫が生まれました 違う お母さんによろしくを伝えください 今日はこのホテルに泊まります もう あまり 彼はまだ若いです 階段 改革 決定 ガソリンの価格がどんどん上がっている グラスの数が足りません 普及 頃 留学してから私の世界が広がった 方向 解決 四日 受ける ダムの開発に住民は反対しています 理由 この携帯電話が使えるのは国内だけです トラブルがやっと解決した 建設 外国 先月の七日に孫がを生まれました 違う 多く その仕事は危険を伴う まず相手の動きを見ましょう 彼は食品工場で働いています 彼は非常に高い技術を持っている 計算 上野さんは彼女と映画を見ました 私の友達は野球とサッカーができます 新しいゲームソフトを買いました。だから、古いゲームを売りました どうして台湾の会社は大学生を雇いたくないのですか あの服のほうが可愛いです あなたにデジタルカメラをもらいました 私は納豆が全然好きではありません 明日の食券をください 全然 犬を飼う 一眼レフカメラ 犬 化粧品 説明する 炒める リットル 雄鶏 ロブスターが岩の上にいる 外国旅行 2020-1-3やる 彼女は酒に強い 私には友達がたくさんいます 始める 狭い 彼はタオルで顔を拭きました 起こす 彼は数学を教えています 送る 私は朝シャワーを浴びます 感じる 夏休みももう終わりだ 昨日 強い 時 妹 五月五日は祝日です 上を向いて 時計 八つ 中心 なお、雨の場合は中止です 原因 ダムの開発に住民は反対しています 今日の新聞どこい置いた トラブルがやっと解決した のち もう 強調 段階 状態 スーパーは夜市ほどうるさくありません 授業をする教師 私は世界一周をしたくありません 日曜日は暇です 日本語を上手にする 私の趣味はバスケットをすることです 彼は小学校の先生なので、毎日四時ちょうどに家に帰ります 私は飛行機で日本に行きます 自動車 知り合い 図 牛 鼠 タプレット レタス 烏龍茶 ダムの開発に住民は反対しています トラブルがやっと解決した もう 2020-1-2いつも 作る 変える 数 親の愛は有り難い 重い こう その次の週は空いていますか もう寝よう 学校亜八時半に始まります 気持ちのいい朝です 彼は意外に気が小さい おかげさまで元気です 暖かい 閉じる 私はパンよりご飯が好きだ 六日前に日本に帰ってきました 左 彼に会えて嬉しかった 教科書閉じてください 財布は机の下にあった ほう 見つかる あそこ 愛する 私はテレビをあまり見ません 昭和 行う 夢を実現するには努力が必要です あなたの話は面白いね 一部 私は行政を改革したいと思っている 経済 従来 全体の80%が完成しました 理由 ほとんど 増える 彼女は同じ間違いを繰り返した 弟は切手を集めています 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 私は刺身があまり好きではありません 大学の先輩は商売ができます 私はゲームを好きです 飛行機が二時間遅れました。なので、到着時間も遅くなります 向日葵は草より綺麗です 私は懐石料理がとても好きです なんでこんな時間に学校にいなにのですか 誰もいません インターネットで新幹線の時刻表がわかります 今日、何か買いますか はい、オレンジを買います スピーチは何時からですか なぜ大体のお店は試食を置きますか 日曜日が暇です 中村さんは昨日夜十時まで仕事しましたので、残業代がたくさんもらえるでしょう ドアを開けません チケットをください 月曜日 博物館 ペンギン タプレット たつ サツマイモは、焼いても揚げても美味しい 日曜日は暇です タプレット 2020-1-1今朝は早く家を出ました 弱い 見せる 鳥が飛んています 一番 彼に会えて嬉しかった 私は腕時計を四つ持っています 辺 お腹が空きました プールは人で一杯です 国会 生活 今、値段を交渉しています 繰り返す 与える これは大きな社会問題になっている 留学してから私の世界が広がった 理由 彼に会えて嬉しかった 交渉 システムの構成を変えてみました 報告 立場 ほぼ 今年は変化の多い年でした 彼はパーティー会場を提供してくれました 都市 建設 のち この携帯電話が使えるのは国内だけです あの人 飲み物といえば、コーラーやジュースやお茶などです 宮沢さんは課長のことをどう思いますか 弟は父の性格がわかります 私は日本語が少しできます あの喫茶店は静かですから、あそこでテストの勉強をしましょう あの服のほうが可愛いです どれも要りません 私の嫌いなことはバスケットをすることです 新しいゲームソフトを買いました。なので、バイト代が全部なくなりました 忙しい会社員 テレビをつけませんでした 私は懐石料理をかなり好きです 理由 スピーチは何時からですか そっか今度早く家を出ろう 今日は何曜日ですか 動詞 水曜日 田舎 おやつ 綺麗 生まれす ましょう 私は物理の基礎は知っています フクロウ スピーチは何時からですか","link":"/zh-tw/japanese/2020/January/index.html"}],"posts":[{"title":"在 Server 上部署 Laravel 專案","text":"前言本篇紀錄如何在 AWS EC2 上部署 Laravel 專案主要有以下重點： LAMP 部署 Composer 部署 Laravel 部署 規格 Amazon Linux AMI 2018.03.0 (HVM), SSD Volume Type LAMPPHP 安裝 PHP sudo yum install php72;php -v 安裝 PHP Extension sudo yum install php72-mbstring sudo yum install php72-bcmath sudo yum install php72-pdo sudo yum install php72-mysqlnd sudo yum install php72-gd.x86_64 Apache 安裝 Apache sudo yum install httpd24 啟動 Apache sudo service httpd start 設定開機自動重啟 Apache sudo chkconfig httpd on 確認 httpd 已啟用 chkconfig --list httpd 設定 AWS security inbound 測試 Apache 運作，拜訪 IP 安裝 SSL module sudo yum install mod24_ssl MySQL 安裝 MySQL sudo yum install mysql57-server 啟動 MySQL sudo service mysqld start 設定 MySQL 於 Reboot 時自動重啟 sudo chkconfig mysqld on 執行 mysql_secure_installation sudo mysql_secure_installation 設定MySQL支援Sequel Pro 遠端連接 CREATE USER 'root'@'%' IDENTIFIED BY '';GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;FLUSH PRIVILEGES; 設定檔案許可 將您的使用者 (在此案例中為 ec2-user) 新增至 apache 群組 sudo usermod -a -G apache ec2-user 登出並重新登入，以取得新的群組並驗證您的成員資格。 登出 (使用 exit 命令或關閉終端機視窗)： exit 若要在 apache 群組中驗證您的會員資格，請重新連線至您的執行個體，然後執行下列命令： groups 將 /var/www 的群組所有權及其內容變更為 apache 群組。 sudo chown -R ec2-user:apache /var/www 若要新增群組寫入許可並在將來的子目錄上設定群組 ID，請變更 /var/www 及其子目錄的目錄許可。 sudo chmod 2775 /var/wwwfind /var/www -type d -exec sudo chmod 2775 &#123;&#125; \\; 若要新增群組寫入許可，請以遞迴方式變更 /var/www 及其子目錄的檔案許可： find /var/www -type f -exec sudo chmod 0664 &#123;&#125; \\; 測試您的 LAMP Web 伺服器 在 Apache 文件根資料夾中建立 PHP 檔案。 echo \"&lt;?php phpinfo(); ?&gt;\" &gt; /var/www/html/phpinfo.php 在 Web 瀏覽器中，輸入您剛才建立的檔案 URL。此 URL 為您執行個體的公有 DNS 地址，其後跟隨斜線和檔案名稱。例如： http://my.public.dns.amazonaws.com/phpinfo.php 刪除 phpinfo.php 檔案。雖然這可能是有用的資訊，但基於安全因素，您不應將其廣播至網際網路。rm /var/www/html/phpinfo.php Composer 安裝 Composer php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"php -r \"if (hash_file('sha384', 'composer-setup.php') === '48e3236262b34d30969dca3c37281b3b4bbe3221bda826ac6a9a62d6444cdb0dcd0615698a5cbe587c3f0fe57a54d8f5') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php'); &#125; echo PHP_EOL;\"php composer-setup.phpphp -r \"unlink('composer-setup.php');\" 讓 Composer 可被 Global 使用 sudo mv composer.phar /usr/local/bin/composer Git 安裝 Gitsudo yum install -y git 部署專案 Clone 專案 git clone repositoryAddress 部署 .env 檔 cp .env.example .env 安裝 Composer composer install 產生 key php artisan key:generate 建立資料庫 mysql -urootcreate database databaseName; 建立表格 php artisan migrate 若記憶體不足，可劃分磁碟為替代記憶體 sudo dd if=/dev/zero of=/swapfile bs=1M count=2000;sudo chmod 600 /swapfile;sudo mkswap /swapfile;sudo swapon /swapfile;swapon -s;sudo vim /etc/fstab; 加入以下 code/swapfile swap swap defaults 0 0 更改 Apache 的預設讀取資料夾位置sudo vim /etc/httpd/conf/httpd.conf &lt;Direction \"/var/www/html\"&gt; Allow Override All&lt;/Direction&gt; 以上為正規流程，以下為懶人版 懶人版sudo yum install -y php72;sudo yum install -y php72-mbstring;sudo yum install -y php72-bcmath;sudo yum install -y php72-pdo;sudo yum install -y php72-mysqlnd;sudo yum install -y httpd24;sudo yum install -y sudo yum install php72-gd.x86_64sudo service httpd start;sudo chkconfig httpd on;sudo yum install -y mod24_ssl;sudo yum install -y mysql57-server;sudo service mysqld start;sudo chkconfig mysqld on;sudo usermod -a -G apache ec2-user;sudo chown -R ec2-user:apache /var/www;sudo chmod 2775 /var/wwwfind /var/www -type d -exec sudo chmod 2775 &#123;&#125; \\;find /var/www -type f -exec sudo chmod 0664 &#123;&#125; \\;php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"php -r \"if (hash_file('sha384', 'composer-setup.php') === '48e3236262b34d30969dca3c37281b3b4bbe3221bda826ac6a9a62d6444cdb0dcd0615698a5cbe587c3f0fe57a54d8f5') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php'); &#125; echo PHP_EOL;\"php composer-setup.php;php -r \"unlink('composer-setup.php');\";sudo mv composer.phar /usr/local/bin/composer;sudo yum install -y git;sudo php -v 設定 AWS security inbound 測試 Apache 運作，拜訪 IP 執行 mysql_secure_installation sudo mysql_secure_installation 設定MySQL支援Sequel Pro 遠端連接 CREATE USER 'root'@'%' IDENTIFIED BY '';GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;FLUSH PRIVILEGES; 登出並重新登入，以取得新的群組並驗證您的成員資格。 登出 (使用 exit 命令或關閉終端機視窗)： exit 若要在 apache 群組中驗證您的會員資格，請重新連線至您的執行個體，然後執行下列命令： groups 在 Apache 文件根資料夾中建立 PHP 檔案。 echo \"&lt;?php phpinfo(); ?&gt;\" &gt; /var/www/html/phpinfo.php 在 Web 瀏覽器中，輸入您剛才建立的檔案 URL。此 URL 為您執行個體的公有 DNS 地址，其後跟隨斜線和檔案名稱。例如： http://my.public.dns.amazonaws.com/phpinfo.php 刪除 phpinfo.php 檔案。雖然這可能是有用的資訊，但基於安全因素，您不應將其廣播至網際網路。 rm /var/www/html/phpinfo.php Clone 專案 git clone repositoryAddress 部署 .env 檔 cp .env.example .env 安裝 Composer composer install 產生 key php artisan key:generate 建立資料庫 mysql -urootcreate database databaseName; 建立表格 php artisan migrate 若記憶體不足，可劃分磁碟為替代記憶體 sudo dd if=/dev/zero of=/swapfile bs=1M count=2000;sudo chmod 600 /swapfile;sudo mkswap /swapfile;sudo swapon /swapfile;swapon -s;sudo vim /etc/fstab; 加入以下 code/swapfile swap swap defaults 0 0 更改 Apache 的預設讀取資料夾位置sudo vim /etc/httpd/conf/httpd.conf &lt;Direction \"/var/www/html\"&gt; Allow Override All&lt;/Direction&gt; 重啟 Apachesudo service httpd restart 規格 GCP- CentOS 7 LAMPPHP 更新鏡像站 yum install epel-release;rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm 安裝 PHP sudo apt-get install php72;php -v 安裝 PHP Extension sudo apt-get install php7.2-mbstring sudo apt-get install php7.2-bcmath sudo apt-get install php7.2-mysqlnd sudo apt-get install php7.2-gd sudo apt-get install php-simplexml sudo apt-get install php7.2-zip sudo apt-get install php7.2-curl sudo apt install zip;sudo apt install unzip Apache 安裝 Apache sudo apt install apache2 啟動 Apache sudo service apache2 start 設定開機自動重啟 Apache sudo systemctl enable apache2 確認 Apache 已啟用 sudo systemctl is-enabled apache2 設定 AWS security inbound 測試 Apache 運作，拜訪 IP 啟動 SSL module sudo a2enmod ssl;sudo service apache2 restart MySQL 安裝 MySQL sudo apt install mysql-server 啟動 MySQL sudo systemctl start mysql 設定 MySQL 於 Reboot 時自動重啟 sudo systemctl is-enabled mysql 執行 mysql_secure_installation sudo mysql_secure_installation 設定MySQL支援Sequel Pro 遠端連接 CREATE USER 'root'@'%' IDENTIFIED BY 'yourPassword';GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;FLUSH PRIVILEGES; GCP 要特別開權限 LOCAL_IP=$(curl http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/0/ip \\ -H \"Metadata-Flavor: Google\")sudo sed -i \"s|bind-address.*|bind-address = $LOCAL_IP|\" /etc/mysql/mysql.conf.d/mysqld.cnf 更多設定可參考官方文件 設定檔案許可 將您的使用者 (在此案例中為 ec2-user) 新增至 apache 群組 sudo usermod -a -G www-data yourUserName 登出並重新登入，以取得新的群組並驗證您的成員資格。 登出 (使用 exit 命令或關閉終端機視窗)： exit 若要在 apache 群組中驗證您的會員資格，請重新連線至您的執行個體，然後執行下列命令： groups 將 /var/www 的群組所有權及其內容變更為 apache 群組。 sudo chown -R yourUserName:www-data /var/www 若要新增群組寫入許可並在將來的子目錄上設定群組 ID，請變更 /var/www 及其子目錄的目錄許可。 sudo chmod 2775 /var/wwwfind /var/www -type d -exec sudo chmod 2775 &#123;&#125; \\; 若要新增群組寫入許可，請以遞迴方式變更 /var/www 及其子目錄的檔案許可： find /var/www -type f -exec sudo chmod 0664 &#123;&#125; \\; 測試您的 LAMP Web 伺服器 在 Apache 文件根資料夾中建立 PHP 檔案。 echo \"&lt;?php phpinfo(); ?&gt;\" &gt; /var/www/html/phpinfo.php 在 Web 瀏覽器中，輸入您剛才建立的檔案 URL。此 URL 為您執行個體的公有 DNS 地址，其後跟隨斜線和檔案名稱。例如： http://my.public.dns.amazonaws.com/phpinfo.php 刪除 phpinfo.php 檔案。雖然這可能是有用的資訊，但基於安全因素，您不應將其廣播至網際網路。rm /var/www/html/phpinfo.php Composer 安裝 Composer php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"php -r \"if (hash_file('sha384', 'composer-setup.php') === '48e3236262b34d30969dca3c37281b3b4bbe3221bda826ac6a9a62d6444cdb0dcd0615698a5cbe587c3f0fe57a54d8f5') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php'); &#125; echo PHP_EOL;\"php composer-setup.phpphp -r \"unlink('composer-setup.php');\" 讓 Composer 可被 Global 使用 sudo mv composer.phar /usr/local/bin/composer Git 安裝 Gitsudo apt install -y git 部署專案 Clone 專案 git clone repositoryAddress 部署 .env 檔 cp .env.example .env 安裝 Composer composer install 產生 key php artisan key:generate 確認 MySQL root 登入方式 SELECT user, plugin, host FROM mysql.user; 更改登入 root 的方式 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'yourPassword';FLUSH PRIVILEGES 建立資料庫 mysql -urootcreate database databaseName; 建立表格 php artisan migrate 若記憶體不足，可劃分磁碟為替代記憶體 sudo dd if=/dev/zero of=/swapfile bs=1M count=2000;sudo chmod 600 /swapfile;sudo mkswap /swapfile;sudo swapon /swapfile;swapon -s;sudo vim /etc/fstab; 加入以下 code/swapfile swap swap defaults 0 0 更改 Apache 的預設讀取資料夾位置sudo vim /etc/httpd/conf/httpd.conf &lt;Direction \"/var/www/html\"&gt; Allow Override All&lt;/Direction&gt; 以上為正規流程，以下為懶人版 懶人版sudo yum install -y php72;sudo yum install -y php72-mbstring;sudo yum install -y php72-bcmath;sudo yum install -y php72-pdo;sudo yum install -y php72-mysqlnd;sudo yum install -y httpd24;sudo yum install php72-gd.x86_64sudo service httpd start;sudo chkconfig httpd on;sudo yum install -y mod24_ssl;sudo yum install -y mysql57-server;sudo service mysqld start;sudo chkconfig mysqld on;sudo usermod -a -G apache ec2-user;sudo chown -R ec2-user:apache /var/www;sudo chmod 2775 /var/wwwfind /var/www -type d -exec sudo chmod 2775 &#123;&#125; \\;find /var/www -type f -exec sudo chmod 0664 &#123;&#125; \\;php -r \"copy('https://getcomposer.org/installer', 'composer-setup.php');\"php -r \"if (hash_file('sha384', 'composer-setup.php') === '48e3236262b34d30969dca3c37281b3b4bbe3221bda826ac6a9a62d6444cdb0dcd0615698a5cbe587c3f0fe57a54d8f5') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php'); &#125; echo PHP_EOL;\"php composer-setup.php;php -r \"unlink('composer-setup.php');\";sudo mv composer.phar /usr/local/bin/composer;sudo yum install -y git;sudo php -v 設定 AWS security inbound 測試 Apache 運作，拜訪 IP 執行 mysql_secure_installation sudo mysql_secure_installation 設定MySQL支援Sequel Pro 遠端連接 CREATE USER 'root'@'%' IDENTIFIED BY '';GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION;FLUSH PRIVILEGES; 登出並重新登入，以取得新的群組並驗證您的成員資格。 登出 (使用 exit 命令或關閉終端機視窗)： exit 若要在 apache 群組中驗證您的會員資格，請重新連線至您的執行個體，然後執行下列命令： groups 在 Apache 文件根資料夾中建立 PHP 檔案。 echo \"&lt;?php phpinfo(); ?&gt;\" &gt; /var/www/html/phpinfo.php 在 Web 瀏覽器中，輸入您剛才建立的檔案 URL。此 URL 為您執行個體的公有 DNS 地址，其後跟隨斜線和檔案名稱。例如： http://my.public.dns.amazonaws.com/phpinfo.php 刪除 phpinfo.php 檔案。雖然這可能是有用的資訊，但基於安全因素，您不應將其廣播至網際網路。 rm /var/www/html/phpinfo.php Clone 專案 git clone repositoryAddress 部署 .env 檔 cp .env.example .env 安裝 Composer composer install 產生 key php artisan key:generate 建立資料庫 mysql -urootcreate database databaseName; 建立表格 php artisan migrate 若記憶體不足，可劃分磁碟為替代記憶體 sudo dd if=/dev/zero of=/swapfile bs=1M count=2000;sudo chmod 600 /swapfile;sudo mkswap /swapfile;sudo swapon /swapfile;swapon -s;sudo vim /etc/fstab; 加入以下 code/swapfile swap swap defaults 0 0 更改 Apache 的預設讀取資料夾位置sudo vim /etc/httpd/conf/httpd.conf &lt;Direction \"/var/www/html\"&gt; Allow Override All&lt;/Direction&gt; 重啟 Apachesudo service httpd restart 確認 OS 種類以及版本 使用 lsb_release ， 如果沒安裝的話，安裝它 sudo apt-get install lsb-release 查詢用法 lsb_release --help 輸出如下：-h, --help show this help message and exit-v, --version show LSB modules this system supports-i, --id show distributor ID-d, --description show description of this distribution-r, --release show release number of this distribution-c, --codename show code name of this distribution-a, --all show all of the above information-s, --short show requested information in short format 根據上面的資訊，想查詢明細的話 lsb_release -a 只想知道 Kernel 版本的話 uname -r","link":"/zh-tw/AWSLaravelDeployment/"},{"title":"Laravel串接歐付寶第三方金流支付","text":"建立Laravel專案Laravel new AllPay 一開始先Git，這幾乎是一定要的啊！git init 下載歐付寶SDK，本篇使用PHP SDKgit clone https://github.com/o-pay/Payment_PHP 將SDK移到Laravel裡頭的app底下 cp Payment_PHP/sdk/AllPay.Payment.Integration.php AllPay/app/ 建立等等測試用的Controllerphp artisan make:controller PaymentsController 從剛剛的SDK包裡面，複製example到我們的controller裡，本篇使用All的example，如下：/****/ //載入SDK(路徑可依系統規劃自行調整) include('AllPay.Payment.Integration.php'); try &#123; $obj = new AllInOne(); //服務參數 $obj-&gt;ServiceURL = \"https://payment-stage.opay.tw/Cashier/AioCheckOut/V5\"; //服務位置 $obj-&gt;HashKey = '5294y06JbISpM5x9' ; //測試用Hashkey，請自行帶入AllPay提供的HashKey $obj-&gt;HashIV = 'v77hoKGq4kWxNNIS' ; //測試用HashIV，請自行帶入AllPay提供的HashIV $obj-&gt;MerchantID = '2000132'; //測試用MerchantID，請自行帶入AllPay提供的MerchantID $obj-&gt;EncryptType = EncryptType::ENC_SHA256; //CheckMacValue加密類型，請固定填入1，使用SHA256加密 //基本參數(請依系統規劃自行調整) $MerchantTradeNo = \"Test\".time(); $obj-&gt;Send['ReturnURL'] = 'http://gw.grazia.tw/sdk/op_sdk/op_payment/example/simple_ServerReplyPaymentStatus.php' ; //付款完成通知回傳的網址 $obj-&gt;Send['MerchantTradeNo'] = $MerchantTradeNo; //訂單編號 $obj-&gt;Send['MerchantTradeDate'] = date('Y/m/d H:i:s'); //交易時間 $obj-&gt;Send['TotalAmount'] = 2000; //交易金額 $obj-&gt;Send['TradeDesc'] = \"good to drink\"; //交易描述 $obj-&gt;Send['ChoosePayment'] = PaymentMethod::ALL; //付款方式:全功能 //訂單的商品資料 array_push($obj-&gt;Send['Items'], array('Name' =&gt; \"歐付寶黑芝麻豆漿\", 'Price' =&gt; (int)\"2000\", 'Currency' =&gt; \"元\", 'Quantity' =&gt; (int) \"1\", 'URL' =&gt; \"dedwed\")); # 電子發票參數 /* $obj-&gt;Send['InvoiceMark'] = InvoiceState::Yes; $obj-&gt;SendExtend['RelateNumber'] = $MerchantTradeNo; $obj-&gt;SendExtend['CustomerEmail'] = 'test@opay.tw'; $obj-&gt;SendExtend['CustomerPhone'] = '0911222333'; $obj-&gt;SendExtend['TaxType'] = TaxType::Dutiable; $obj-&gt;SendExtend['CustomerAddr'] = '台北市南港區三重路19-2號5樓D棟'; $obj-&gt;SendExtend['InvoiceItems'] = array(); // 將商品加入電子發票商品列表陣列 foreach ($obj-&gt;Send['Items'] as $info) &#123; array_push($obj-&gt;SendExtend['InvoiceItems'],array('Name' =&gt; $info['Name'],'Count' =&gt; $info['Quantity'],'Word' =&gt; '個','Price' =&gt; $info['Price'],'TaxType' =&gt; TaxType::Dutiable)); &#125; $obj-&gt;SendExtend['InvoiceRemark'] = '測試發票備註'; $obj-&gt;SendExtend['DelayDay'] = '0'; $obj-&gt;SendExtend['InvType'] = InvType::General; */ //產生訂單(auto submit至AllPay) $obj-&gt;CheckOut(); &#125; catch (Exception $e) &#123; echo $e-&gt;getMessage(); &#125; 我們將上面一些機敏資訊，移到Laravel的.env檔裡面，如下://服務位置$obj-&gt;HashKey = env('HASHKEY'); //測試用Hashkey，請自行帶入AllPay提供的HashKey$obj-&gt;HashIV = env('HASHIV'); //測試用HashIV，請自行帶入AllPay提供的HashIV$obj-&gt;MerchantID = env('MERCHANTID'); //測試用MerchantID，請自行帶入AllPay提供的MerchantID$obj-&gt;Send['ReturnURL'] = env('ALLPAYRETURNURL');//付款完成通知回傳的網址$obj-&gt;Send['ClientBackURL'] = $request-&gt;ClintBackURL;//付款完成後，於第三方頁面顯示回到我們服務的網址 .env檔內如下：ALLPAYRETURNURL=https://163be100.ngrok.io/api/paymentsResponseHASHKEY=5294y06JbISpM5x9HASHIV=v77hoKGq4kWxNNISMERCHANTID=2000132 使用use代替include 刪除 //載入SDK(路徑可依系統規劃自行調整)include('AllPay.Payment.Integration.php'); 新增AllPay.Payment.Integration.php到composer.json file \"autoload-dev\": &#123; \"psr-4\": &#123; \"Tests\\\\\": \"tests/\" &#125;, \"files\": [ \"app/Helpers.php\", \"app/AllPay.Payment.Integration.php\" ] 在terminal下達 composer dump-autoload` 在controller檔案裡，use新的class namespace App\\Http\\Controllers;use AllInOne;use EncryptType;use Exception;use Illuminate\\Http\\Request;use PaymentMethod; 建立金流訂單 (這部分屬個人表格設計，帶入參數每個人都不同)因為會一次性的寫入兩張表格，所以這邊會使用 Laravel 的 transaction 來寫入資料//總金額$totalAmount = Order::getTotalAmountForPayments($orders);//商品訂單編號$ordersName = Order::getOrdersNameForPayments($orders);//金流訂單編號$MerchantTradeNo = time() . Helpers::createAUniqueNumber();//金流訂單建立時間$MerchantTradeDate = date(&apos;Y/m/d H:i:s&apos;);//金流訂單敘述$TradeDesc = &apos;BuyBuyGo&apos;;//數量$quantity = 1;//因為同時建立兩張表格，這邊使用Laravel的transaction功能來防止資料庫資料不一//transaction開始DB::beginTransaction();//以下動作需全部完成無錯誤，否則終止並回朔try&#123; $payment_service_order = new PaymentServiceOrders(); $payment_service_order-&gt;user_id = User::getUserID($request); //金流服務商ID $payment_service_order-&gt;payment_service_id = $thirdPartyPaymentService-&gt;id; $payment_service_order-&gt;expiry_time = (new Carbon())-&gt;now()-&gt;addDay(1)-&gt;toDateTimeString(); $payment_service_order-&gt;MerchantID = env(&apos;MERCHANTID&apos;); $payment_service_order-&gt;MerchantTradeNo = $MerchantTradeNo; $payment_service_order-&gt;MerchantTradeDate = $MerchantTradeDate; $payment_service_order-&gt;TotalAmount = $totalAmount; $payment_service_order-&gt;TradeDesc = $TradeDesc; //商品訂單的編號 $payment_service_order-&gt;ItemName = $ordersName; $payment_service_order-&gt;save(); foreach ($orders as $order) &#123; $order_relations = new OrderRelations(); $order_relations-&gt;payment_service_id = $thirdPartyPaymentService-&gt;id; $order_relations-&gt;payment_service_order_id = $payment_service_order-&gt;id; $order_relations-&gt;order_id = $order-&gt;id; $order_relations-&gt;save(); &#125; //若有錯誤，則停止並回朔，回報自訂錯誤訊息&#125; catch (Exception $e)&#123; DB::rollBack(); return Helpers::result(&apos;false&apos;, &apos;Something went wrong with DB&apos;, 400);&#125;//若無錯誤，則寫入資料庫DB::commit(); 為PaymentsController建立一支API 到routes資料夾底下的api.php 增加routeRoute::post(&apos;pay&apos;, &apos;PaymentsController@pay&apos;); 建立一頁最簡單的的html 直接更改Laravel內建welcome.blade的內容，如下：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Facebook Login JavaScript Example&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;// 這邊需輸入PaymentsController的API&lt;form action=&quot;/api/pay&quot; method=&quot;POST&quot;&gt; @csrf() &lt;input type=&quot;checkbox&quot; value=&quot;1&quot; name=&quot;order_id[]&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;2&quot; name=&quot;order_id[]&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;3&quot; name=&quot;order_id[]&quot;&gt; &lt;input type=&quot;hidden&quot; value=&quot;https://64b30ea0.ngrok.io/&quot; name=&quot;ClintBackURL&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 簡單傳送測試 到Laravel首頁，此時此頁面應已經變更為我們剛剛建立的簡單form頁面 什麼都不要勾選，點選submit 成功到了歐付寶的付款頁面 建立Log 為了要知道當我們成功付款之後，歐付寶會回傳什麼給我們，我們需要用Log來看看回傳的東西 有沒有一個地方，是所有的請求跟回饋都一定會進出通過，而且可以讓我們控制的？ 這似乎是個完美記log的地方 我們可以建立一個middleware，然後在middleware裏頭使用Laravel的Log功能，將所有進來的請求跟我們回饋的東西全都記下來 建立middleware 於terminal頁面php artisan make:middleware TestLog 註冊middleware 到/app/Http/Kernel.php檔案裡頭，加上我們剛剛建立的middleware protected $middleware = [ \\App\\Http\\Middleware\\CheckForMaintenanceMode::class, \\Illuminate\\Foundation\\Http\\Middleware\\ValidatePostSize::class, \\App\\Http\\Middleware\\TrimStrings::class, \\Illuminate\\Foundation\\Http\\Middleware\\ConvertEmptyStringsToNull::class, \\App\\Http\\Middleware\\TrustProxies::class, \\App\\Http\\Middleware\\TestLog::class,]; 建立Log 到我們剛剛建立的TestLog檔案裡頭，新增： $response = $next($request);log::info([$request-&gt;header(),$request-&gt;getMethod(),$request-&gt;getRequestUri(),$request-&gt;all(),$response-&gt;getStatusCode(),$response-&gt;getContent()]);return $response; 實際上，Log要記些什麼視乎每個人的需求 建立public url 我們要取得第三方回傳的資訊，所以我們必須要有一個public url來接收第三方的response 我們可以使用ngrok來取得public url 至ngrok官網安裝ngrok 將ngrok變更為可全域執行 mv ngrok /usr/local/bin 先取得public url，在terminal中 ngrok http 8000 在terminal中，位於AllPay專案資料夾內，開啟本機通道 php artisan serve 8000` 複製ngrok產生的public https url 建立接收的function 我們準備要來接歐付寶回傳的訊息了，我們需要建立一個function，並且接到之後，可以在裡面做我們想做的事 在PaymentsController裡頭，我們先建一個function receive，如下：public function receive()&#123; &#125; 針對此function，建立一個API Route::post(&apos;pay&apos;, &apos;PaymentsController@pay&apos;);Route::post(&apos;receive&apos;, &apos;PaymentsController@receive&apos;); 設定ReturnURL 於.env檔內，如有照之前步驟，應有以下參數，將複製的public url 貼上 ALLPAYRETURNURL=https://163be100.ngrok.io/api/recevie 你的連結跟我的不一樣哦，別貼我的 付款測試 再次連到歐付寶付款頁面 登入歐付寶提供的買家測試帳號 帳號： stageuser001 密碼： test1234 使用歐付寶提供的測試信用卡付款 卡號： 4311-9522-2222-2222 有效期限：請大於目前月/年，例：12 / 20 末三碼：222 付款後，我們到log去看一下有沒有收到歐付寶的回饋，於terminal，位於AllPay的資料夾內 cat storage/logs/laravel-2019-02-08.log` 咦，有收到歐付寶的回饋了！ &apos;MerchantID&apos; =&gt; &apos;2000132&apos;, &apos;MerchantTradeNo&apos; =&gt; &apos;Test1549597724&apos;, &apos;PayAmt&apos; =&gt; &apos;2000&apos;, &apos;PaymentDate&apos; =&gt; &apos;2019/02/08 11:49:03&apos;, &apos;PaymentType&apos; =&gt; &apos;Credit_CreditCard&apos;, &apos;PaymentTypeChargeFee&apos; =&gt; &apos;20&apos;, &apos;RedeemAmt&apos; =&gt; &apos;0&apos;, &apos;RtnCode&apos; =&gt; &apos;1&apos;, &apos;RtnMsg&apos; =&gt; &apos;交易成功&apos;, &apos;SimulatePaid&apos; =&gt; &apos;0&apos;, &apos;TradeAmt&apos; =&gt; &apos;2000&apos;, &apos;TradeDate&apos; =&gt; &apos;2019/02/08 11:48:44&apos;, &apos;TradeNo&apos; =&gt; &apos;1902081148440800&apos;, &apos;CheckMacValue&apos; =&gt; &apos;5B1EE24B0E9D600C65578DD82D3168E2ED56799453577E17E1EBEFC536BD7EAF&apos;, 驗證 試想，如果有人不小心知道了你的API，然後對方也是開發者，他如果跑到你的服務購買商品，然後呼叫你的API結帳，你如何辨別？ 所以說，第三方跟廠商會有一套只有雙方身份對了，驗證才能通過的機制 驗證機制大概就是，所以你傳出去的資料，每一項欄位，會經過一套只有雙方適用的公式下去計算，最後會得出一串CheckMacValue，眼尖的朋友應該已經看到，在我們收到的訊息最下面一個欄位帶的就是這串資料。 詳細的公式各位朋友可參照官方網站。 由於本篇使用官方的SDK，所以本篇將教大家如何使用官方SDK來驗證收到的資訊 首先，我們到官方SDK的檔案中app/AllPay.Payment.Integration.php，搜尋名為CheckMacValue的class CheckMacValue class裡頭，有一個名為generate的function，大家可以看一下它是怎麼寫的，這就是產生這串CheckMacValue的公式。 所以說，我們只要通過這套公式，驗證我們收到的訊息之中，除了CheckMacValue這個欄位的資訊，那理應得到跟回傳的CheckMacValue一模一樣的值 先取得回傳資訊中，除了CheckMacValue之外的所有資訊，我們可以使用以下的code $parameters = $paymentResponse-&gt;except(&apos;CheckMacValue&apos;); 再來，取得歐付寶回傳的CheckMacValue $receivedCheckMacValue = $paymentResponse-&gt;CheckMacValue; 接下來，使用官方的generate function，帶入我們收到的資訊，來產出正確的CheckMacValue $calculatedCheckMacValue = CheckMacValue::generate($parameters, env(&apos;HASHKEY&apos;), env(&apos;HASHIV&apos;), EncryptType::ENC_SHA256); 最後，比較兩者的值是否一樣？如果一樣，表示這則訊息的確來自歐付寶，如果不同，那此資訊沒有可信度 if($receivedCheckMacValue == $calculatedCheckMacValue) return true;return false; 驗證之後呢？ 確認資訊來源正確之後，我們就可以依據收到的資訊下去做事了！ 比方說，付款了做些什麼，付款失敗又做些什麼 本篇範例為收到付款之後，將資料庫內訂單標記付款，並發email通知買家，如下： if (PaymentServiceOrders::checkIfCheckMacValueCorrect($request) &amp;&amp; PaymentServiceOrders::checkIfPaymentPaid($request-&gt;RtnCode))&#123; $paymentServiceOrder = (new PaymentServiceOrders)-&gt;where(&apos;MerchantTradeNo&apos;, $request-&gt;MerchantTradeNo)-&gt;first(); $paymentServiceOrder-&gt;update([&apos;status&apos; =&gt; 1, &apos;expiry_time&apos; =&gt; null]); $orderRelations = $paymentServiceOrder-&gt;where(&apos;MerchantTradeNo&apos;, $request-&gt;MerchantTradeNo)-&gt;first()-&gt;orderRelations; Order::updateStatus($orderRelations); $payerEmail = $paymentServiceOrder-&gt;user-&gt;email; if ($payerEmail !== null) Mail::to($payerEmail)-&gt;send(new PaymentReceived($paymentServiceOrder, $orderRelations)); return &apos;1|OK&apos;;&#125; 最後記得別忘記return ‘1|OK’, 通知歐付寶我們已經收到付款囉！ 一些沒說到的事 歐付寶測試帳號中，除了信用卡之外，也支援多種其他方式付款哦！可於登入買家測試帳號之後使用。 超商或轉帳付款方式，需特別登入歐付寶提供的後台測試帳號，方可達到模擬付款！ 帳號： StageTest 密碼： test1234 退款 退款範例如下： public static function refund($order, $paymentServiceInstance, $orderRelation)&#123; try &#123; $obj = new AllInOne(); $obj-&gt;ServiceURL = &quot;https://payment-stage.opay.tw/Cashier/AioChargeback&quot;; // 服務位置 $obj-&gt;HashKey = env(&apos;HASHKEY&apos;); // 測試用Hashkey，請自行帶入AllPay提供的HashKey $obj-&gt;HashIV = env(&apos;HASHIV&apos;); // 測試用HashIV，請自行帶入AllPay提供的HashIV $obj-&gt;MerchantID = env(&apos;MERCHANTID&apos;); // 測試用MerchantID，請自行帶入AllPay提供的MerchantID $obj-&gt;EncryptType = EncryptType::ENC_SHA256; // CheckMacValue加密類型，請固定填入1，使用SHA256加密 $obj-&gt;ChargeBack[&apos;MerchantTradeNo&apos;] = $paymentServiceInstance-&gt;MerchantTradeNo; // 當初訂單成立時，提供的訂單號碼 $obj-&gt;ChargeBack[&apos;TradeNo&apos;] = $paymentServiceInstance-&gt;TradeNo; // AllPay提供的訂單號碼 $obj-&gt;ChargeBack[&apos;ChargeBackTotalAmount&apos;] = $order-&gt;total_amount; // 退款金額 $obj-&gt;AioChargeback(); &#125; catch (Exception $e) &#123; // 若錯誤，return return Helpers::result(true, &apos;Something wrong happened&apos;, 200); // Debug模式，印出錯誤 echo $e-&gt;getMessage(); &#125;&#125; 帶入參數可參考官方文件，選項12，會員通知退款。","link":"/zh-tw/AllPayPaymentService/"},{"title":"Cloud Shell 及 Gcloud 簡介！","text":"本篇將會做什麼？ 練習使用 gcloud 指令 連結到 Google Cloud Platform 的儲存裝置 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記原文可參閱:官方連結 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 理解 Regions 和 Zones 特定的 Compute Engine 資源位於特定的 regions 或 zones. Region 表示一個你可以運行你的資源的特定地理位置。 每個 region 都有一個或多個 zones，舉例來說，us-central1 region 位於 Central United States，並且下面有 us-central1-a, us-central1-b, us-central1-c, us-central1-f 這些 zones 位於 zone 的資源算是 zonal 資源。 Virtual machine instance 還有 persistent disk 都位於 zone, 如果要在一個 virtual machine 上加一個 persistent disk ，那兩者必須位於同一個 zone 很類似的，如果你要分配一個 static IP 位址到一個 instance ，這個 instance 必須要跟這個 static IP 同一個 region 使用終端機 點擊位於 GCP 主控台右上角的圖案來開始一個新的 Cloud Shell 視窗，如下圖： 在 Cloud Shell 成功開啟後，我們可以使用終端機來下達 Cloud SDK gcloud ，或任何其他 vurtual machine instance 有提供的指令。 我們也可以在不同的專案，或著 Cloud Shell，把檔案儲存在 persistent disk 的 HOME 資料夾。 HOME資料夾只屬於你個人，任何其他USER將無法存取。 gcloud提供使用指南，只要在指令的後面加上-h，試試下面的指令: gcloud -h 或者，你也可以打長一點 gcloud config --help gcloud help config 使用你的 Home 資料夾現在，讓我們來試試 Home 資料夾。就算你結束或者重開你的 virtual machine, Cloud Shell Home 資料夾內的內容也會繼續存在，不同的專案或者 Cloud Shell 都可以存取。 改變目前的工作資料夾 cd $HOME 使用vim打開.bashrc設定檔 vim .bashrc 使用 gcloud 指令 讓我們來檢視一下我們環境內的設定列表 gcloud config list 檢視其他的 property 是怎麼被設定的 gcloud config list --all 管理 Cloud 儲存資料 建立一個 Cloud Storage bucket, bucket 的名字必須獨一無二，所以請給一個名稱來取代下面的unique-namegsutil mb gs://unique-name 現在，我們可以建立一些資料，並上傳的我們的 bucket 建立一個 test 檔案 vim test.dat 加一些資料進去 welcome to gcloud! 存檔 :wq 現在，上傳一些檔案到我們建立的 bucket，請使用我們之前給的名字來取代下面的 unique-name gsutil cp test.dat gs://unique-name 如果想看一下我們建立的 bucket, 以及我們上傳的檔案，可以打開 Navigation menu &gt; Storage &gt; Browser, 然後點擊 bucket, 應該可以看到 test.dat 檔案，如下圖： 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： Three basic ways to interact with the GCP services and resources: Command-line interface Client libraries GLib GStreamer GCP Console","link":"/zh-tw/CloudShellAndgcloud/"},{"title":"gcloud CLI 用法","text":"前言本篇記錄 gcloud CLI 用法 computeinstance 建立一台虛擬機 gcloud compute instances create example-instance-1 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=10GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=example-instance-1,http-server,https-server \\--zone=asia-east1-c 由自己建立的 image 建一台 VM gcloud compute instances create example-instance-1 \\--image-project=yourProject \\--image=yourImage \\--boot-disk-size=10GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=example-instance-1,http-server,https-server \\--zone=asia-east1-c 停止 instance gcloud compute instances stop instanceName1 instanceName2 instanceName3 啟動 instance gcloud compute instances start instanceName1 instancesName2 instanceName3 刪除 instance gcloud compute instances delete instanceName 列出 instances 列表 gcloud compute instances list 列出特定 instance 細節資料 gcloud compute instances describe instanceName 查詢執行個體的 ssh 金鑰 gcloud compute instances describe instanceName | grep -A 5 ssh-keys 移除或新增執行個體 ssh 金鑰 gcloud compute instances add-metadata instanceName --metadata-from-file ssh-keys=fileName 指令如上，以下是 fileName 的格式[USERNAME_2]:ssh-rsa [EXISTING_KEY_VALUE_2] [USERNAME_2][USERNAME_3]:ssh-rsa [NEW_KEY_VALUE] [USERNAME_3] 為 instance 增加 tags gcloud compute instances add-tags instanceName \\--tags tag1,tag2,tag3... 封鎖全專案公開 SSH 金鑰 gcloud compute instances add-metadata [INSTANCE_NAME] --metadata block-project-ssh-keys=TRUE 允許全專案公開 SSH 金鑰 gcloud compute instances add-metadata [INSTANCE_NAME] --metadata block-project-ssh-keys=FALSE firewall-rules 增加防火牆規則gcloud compute firewall-rules create firewallRuleName --allow tcp:50005,port2,port3 --target-tags targetTags 文件連結 images 查詢可用的 images 相關資訊 gcloud compute images list 從現有的 disk 創立 image gcloud compute images create shadowsocks \\--source-disk test-shadowsock \\--source-disk-zone asia-east1-a \\--family ubuntu-1804-lts project 查詢全專案公開 ssh 金鑰並且顯示 5 行資料 gcloud compute project-info describe | grep -A 5 ssh-keys 移除或新增全專案公開 ssh 金鑰 gcloud compute project-info add-metadata --metadata-from-file ssh-keys=fileName 指令如上，以下是 fileName 的格式[USERNAME_2]:ssh-rsa [EXISTING_KEY_VALUE_2] [USERNAME_2][USERNAME_3]:ssh-rsa [NEW_KEY_VALUE] [USERNAME_3] addresses 將現有 VM 使用的 IP 轉為靜態 gcloud compute addresses create addressName \\--addresses IP \\--region regionName 列出 IP gcloud compute addresses list 刪除 IP gcloud compute addresses delete ip1 ip2 ip3 regions 取得 regions 列表gcloud compute regions list backend-service 更新 draining-time-outgcloud compute backend-services update [BACKEND_SERVICE] \\ --connection-draining-timeout [CONNECTION_TIMEOUT_SECS] DNSrecord-sets顯示區域的當前 DNS 紀錄gcloud dns record-sets list --zone=\"myzonename\" 此指令會以含有前 100 筆記錄的資源記錄集，輸出 JSON 回應。您可以指定下列額外參數： limit：要列出的記錄集數目上限。 name：只列出含有這個確切網域名稱的記錄集。 type：只列出這個類型的記錄。如果有這類記錄，則必須同時使用 –name 參數。 新增 A record 開始 transaction gcloud dns record-sets transaction start --z zoneName 增加 A 紀錄 gcloud dns record-sets transaction add 'ip' --name 'domainName' --ttl 5 --type A --zone 'zoneName' 增加 cname 紀錄 gcloud dns record-sets transaction add -z=zoneName --type=CNAME --name=\"www.ray.com\" --ttl 5 \"ray.com.\" 增加 MX 紀錄 gcloud dns record-sets transaction add --z=zoneName --name=\"ray.com\" --ttl 5 --type MX \"10 mail1.ray.com.\" \"20 mail2.ray.com.\" 執行 gcloud dns record-sets transaction execute -z 'zoneName' managed-zones列出所有 zone 列表gcloud dns managed-zones list config 切斷 project gcloud config set projectID 取得 config 的 zone 的值 gcloud config get-value compute/zone 取得 config 的 account 的值 gcloud config get-value account projects取得 project listgcloud projects list gsutilCloud Storage mb建立儲存區, 命名規格請參考gsutil mb gs://YOUR-BUCKET-NAME cp上傳檔案gsutil cp ada.jpg gs://YOUR-BUCKET-NAME 下載檔案gsutil cp -r ada.jpg gs://YOUR-BUCKET-NAME -r: recursive 複製檔案gsutil cp gs://YOUR-BUCKET-NAME/ada.jpg gs://YOUR-BUCKET-NAME/image-folder/ ls列出物件gsutil ls gs://YOUR-BUCKET-NAME 列出物件細節gsutil ls -l gs://YOUR-BUCKET-NAME/ada.jpg -l: list acl增加公開存取權限gsutil acl ch -u AllUsers:R gs://YOUR-BUCKET-NAME/fileName 移除公開存取權限gsutil acl ch -d AllUsers gs://YOUR-BUCKET-NAME/fileName rm刪除物件gsutil rm gs://YOUR-BUCKET-NAME/fileName containercluster 建立集群, 並且限定集群內 instance 可存取的 API 範圍 gcloud container clusters create jenkins-cd \\--num-nodes 3 \\--machine-type n1-standard-2 \\--scopes \"https://www.googleapis.com/auth/source.read_write,cloud-platform\" –num-nodes: 集群含有三台機器, 最少三台 –machine-type: 機器類型 –scopes: instance 可存取的 API 範圍, API 可從官方文件 獲得 Q&amp;A","link":"/zh-tw/GCP/"},{"title":"手把手教你理解並建立 GCP 平衡負載","text":"前言為什麼要使用 Load Balancer? 可以分攤流量, 利用多台機器跑多個服務 當一台機器掛了，你還有另外一台 當負載到達一定程度，可以啟動 auto scaling (本篇不會使用到) 配合適當的 CI / CD, 以及健康檢查，可達到 rolling upgrade 的效果 本篇重點 本篇分享最簡單易設的 unmanaged Load Balancer 為避免混淆，本篇對於有意義的元件術語，將維持原文，不會特別翻譯 詳解每個元件行為 簡單的概念圖如下 (圖片來源： Google )： IPv4 以及 IPv6 的使用者，對我們的服務發請求 我們設定的 IPv4 以及 IPv6 Forwading rules，會將使用者導向我們設定好的 HTTP(S) proxy 到了 HTTP(S) proxy 的 request, 會根據我們設定好的 url-map 規則，導向相對應的backend-service, 例如說， 透過 domain name 為 ‘test1’ 的 request, 導向backend-service 1, 而 ‘test2’ 的 request 導向 backend-service 2 backend-service 由 instance group 組成，舉例來說，我們可以指定， backend-service A 導向 instance group A 的 port 8000 , 而 backend-service B 導向 instance group B 的 port 6000 instance group, 顧名思義，由 instance 所組成，當我們在 instance group 中設定好特定的 port, 並且設定好 backend-service, 那麼 request 將會經由 backend-service, 再到 instance group 指定的 port, 最後到依照 instance 本身的負載狀況, 將 request 導向適合服務的 instance 每個 backend-service 都可以設定一個 health-check, health-check 會根據指定的頻率向指定的 port 探測並取得回應，如果回應的速度低於我們設立的門檻，那麼該 instance 就會被判定為不健康。 request 不會導向已被判定為不健康的 instance 如果有 SSL 需求，可建立 SSL certificate, 並且掛在 HTTPS proxy 以下我們就開始來實作吧! 安裝 Google Cloud SDK本篇所有的指令都會使用到 Google Cloud SDK 的指令, 所有在我們開始之前，先安裝它哦！根據你的作業系統的不同，安裝方法也不一樣哦，請參考官方文件 建立 instance 建立兩個 instances gcloud compute instances create test-01 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=30GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=test-01,http-server,https-server \\--zone=asia-east1-c gcloud compute instances create test-02 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=30GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=test-02,http-server,https-server \\--zone=asia-east1-c 建立二台機器, 叫做 test-01, test-02 開機碟的空間為 30GB 從 ubuntu-os-cloud, 來 pull 我們需要的 image 我們使用 ubuntu-1804-lts 的 image 版本, 這會自動使用這個版本的最新版 硬碟類型為 pd-standard, 不知道類型可以跑 gcloud compute disk-types list 來看看 機器型號為 f1-micro, 不知道類型可以跑 gcloud compute machine-types list 來看看 tags 用來當作該 instance 的一個識別，等等開防火牆的時候會用到 zone 指定該 instance 的地區, 有些資源只有相同 zone 或者 region 可以取用，要注意 可參考官方文件 instance 環境建置以下為 instance 上的環境建置範例，與本篇主題較無關係，可跳過 apt-get update -y &amp;&amp; apt-get install curl -y &amp;&amp; curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash &amp;&amp; export NVM_DIR=\"$HOME/.nvm\" &amp;&amp; [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" &amp;&amp; [ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" &amp;&amp; nvm install yourNodeVersion &amp;&amp; apt-get install npm -y &amp;&amp; npm install pm2 -g &amp;&amp; pm2 update &amp;&amp; apt-get install git -y &amp;&amp; apt-get install build-essential 開啟防火牆看服務跑在哪一個 port, 我們需要將防火牆打開，這樣 instance group 才能將 request 從 Load Balancer 經由 backend-service 導向相對應的 port, 可參考官方文件 gcloud compute firewall-rules create test-01 --allow tcp:123,tcp:456,tcp:789 --target-tags test-01 gcloud compute firewall-rules create test-02 --allow tcp:123,tcp:456,tcp:789 --target-tags test-02 外部靜態 IP這邊建立一個 IPv4 的靜態 IP , 之後會用到, 可參考官方文件 gcloud compute addresses create lb-test \\ --ip-version=IPV4 \\ --global Instance groupInstance group 可由多個 instance 所組成，為組成 backend-service 的主體, 可參考官方文件 建立 instance group, 之後 Load Balancer 可以用它來建立不同的 backend-service gcloud compute instance-groups unmanaged create test --description 'run test project' --zone asia-east1-c 設定 named port, 所以不同的 backend-service 可以指定要用哪一個 port gcloud compute instance-groups unmanaged set-named-ports test --named-ports port1:3000,port2:6000,port3:9000,port4:12000,port5:15000 --zone asia-east1-c 將現有的 instance 加到 instance group gcloud compute instance-groups unmanaged add-instances test \\ --instances test-01,test-02 \\ --zone asia-east1-c Health checkhealth-check , 可根據我們指定的頻率，探測指定的 port, 如果該 port 無回應， health-check 將判定這個 port 不健康， backend-service 不會將 request 送往不健康的 instance 可參考官方文件 gcloud compute health-checks create tcp test-tcp-3000 \\ --description='test tcp 3000'\\ --port=3000 gcloud compute health-checks create tcp test-tcp-6000 \\ --description='test tcp 6000'\\ --port=6000 gcloud compute health-checks create tcp test-tcp-9000 \\ --description='test tcp 9000'\\ --port=9000 gcloud compute health-checks create tcp test-tcp-12000 \\ --description='test tcp 12000'\\ --port=12000 gcloud compute health-checks create tcp test-tcp-15000 \\ --description='test tcp 15000'\\ --port=15000 Backend service這邊的 --port-name, 就是上面我們在 instance-group 中，建立的 port, 在此範例中，不同的 backend-service 會將 request 導向不同的 port, 這邊看起來沒有提到 instance group ? 別緊張，下一步我們就會把 instance group 加到 backend-service 當中。 同理， health-check 也是掛在 backend-service 上的, 因為 backend-service 將決定要將 request 導向哪一個 instance。可參考官方文件 建立後端服務 gcloud compute backend-services create backend-service-port1 \\ --protocol http \\ --port-name port1 \\ --health-checks test-tcp-3000 \\ --global gcloud compute backend-services create backend-service-port2 \\ --protocol http \\ --port-name port2 \\ --health-checks test-tcp-6000 \\ --global gcloud compute backend-services create backend-service-port3 \\ --protocol http \\ --port-name port3 \\ --health-checks test-tcp-9000 \\ --global gcloud compute backend-services create backend-service-port4 \\ --protocol http \\ --port-name port4 \\ --health-checks test-tcp-12000 \\ --global gcloud compute backend-services create backend-service-port5 \\ --protocol http \\ --port-name port5 \\ --health-checks test-tcp-15000 \\ --global 接下來，我們將 instance group 加到我們剛剛建立的 backend-service, 因為我們在建立 backend-service 時就已指定了 port, 所以 backend-service 會將 request 導向所屬的 instance group 中已指定的 port, 嗯, 聽起來有點饒舌, 不過的確是這樣。 除了設定導向的 port 之外，這邊也會設定 instance 的負載門檻。 設定 UTILIZATION 表示使用率，當使用到 80 % 時， backend-service 便會停止將 request 導向這個 instance capacity-scaler 表示， 1 * 0.8, 所以說，如果你有多個 backend-service 使用這個 instance-group, 那你希望多保留一些 instance-group 的可使用率，給其他 backend-service 使用，那就可以將 capacity-scaler 調低，如此一來，當這個 backend-service 已使用了 capacity-scaler * max-utilization 的 CPU 時，來自於該 backend-service 的請求就不會導向該 instance-group, 可以很大程度地保留該 instance-group 服務其他 backend-service 的可用性。 下面範例，可參考官方文件 將 instance group 加到 backend-service gcloud compute backend-services add-backend backend-service-port1 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port2 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port3 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port4 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global gcloud compute backend-services add-backend backend-service-port5 \\ --balancing-mode UTILIZATION \\ --max-utilization 0.8 \\ --capacity-scaler 1 \\ --instance-group test \\ --instance-group-zone asia-east1-c \\ --global URL map前面介紹完了 backend-service, 那這個 url-map, 就是將 request 導向 backend-service 的元件。 首先，我們要先建立一個 url-map, 並且給予一個默認的 backend-service, 意思就是說，如果沒有特別指定的話，收到的 request 要導向哪一個 backend-service 下面範例，可參考官方文件 建立 URL-map gcloud compute url-maps create web-map \\ --default-service backend-service-port1 上面建立了 url-map, 並且指定了一個默認的 backend-service, 現在我們可以定義怎麼樣的 request 該導向哪一個 backend-service。 路徑的指定，我們需要使用 path-matcher, 範例如下： path-matcher: 建立一個 path-matcher, 並給予指定的路徑規則 new-hosts: 當 request 是對 host sunday.com.tw 發請求時，會套用此規則 所以就是說, 當 request 的 host 為 sunday.com.tw 時，會導向 backend-service-port1 以下為範例，可參考官方文件 新增 path-matcher gcloud compute url-maps add-path-matcher web-map \\ --default-service backend-service-port1 \\ --path-matcher-name pathmap-port1 \\ --new-hosts=sunday.com.tw 這邊可以看到比上面多了一個新的元件，叫做 path-rules 當 request 的 host 為 monday.com.tw, 默認路徑如 / 會導向 backend-service-port2 當 request 的路徑為 happy, 如 monday.com.tw/happy, 會導向 backend-service-port1 當 request 的路徑為 unhappy, 如 monday.com.tw/unhappy, 會導向 backend-service-port2 當 request 的路徑為 sad, 如 monday.com.tw/sad, 會導向 backend-service-port3 gcloud compute url-maps add-path-matcher web-map \\ --default-service backend-service-port2 \\ --path-matcher-name pathmap-port2 \\ --path-rules=/happy=backend-service-port1,/unhappy=backend-service-port2,/sad=backend-service-port3 \\ --new-hosts=monday.com.tw 以下範例同上，當 request 為 tuesday.com.tw 時，導向 backend-service-port3 gcloud compute url-maps add-path-matcher web-map \\ --default-service backend-service-port3 \\ --path-matcher-name pathmap-port3 \\ --new-hosts=tuesday.com.tw 建立 SSL 憑證要讓我們的服務支援 HTTPS, 我們需要建立 ssl-certificates, ssl-certificates 分成 self-managed, 以及 google-managed。 self-managed 顧名思義就是你提供你自己的 ssl 簽證，以下範例採用 google-managed 可參考官方文件 gcloud beta compute ssl-certificates create www-ssl-cert \\ --domains sunday.com.tw,monday.com.tw,tuesday.com.tw HTTP proxy所有來自 HTTP 的請求，都會先到這裡，再經由我們剛剛建立的 url-map 導向指定的 backend-service 可參考官方文件 建立 HTTP proxy gcloud compute target-http-proxies create http-lb-proxy \\ --url-map web-map HTTPS proxy所有來自 HTTPS 的請求，都會先到這裡，再經由我們剛剛建立的 url-map 導向指定的 backend-service 並且，我們剛剛建立的 ssl-certificates 也要掛在這, 這樣 target-https-proxies 才能支援 HTTPS 可參考官方文件 建立 HTTPS proxy gcloud compute target-https-proxies create https-lb-proxy \\--url-map web-map \\--ssl-certificates www-ssl-cert 查看外部靜態 IP 清單列出我們一開始建立的 addresses 可參考官方文件 gcloud compute addresses list 轉發規則當 request 的 address 以及 port 符合 forwarding-rules, 導向指定的 target-http-proxy 下面範例的 [LB_IP_ADDRESS] 請替換為上面建立的靜態 IP 可參考官方文件 建立 HTTP forwarding-rules gcloud compute forwarding-rules create http-content-rule \\ --address [LB_IP_ADDRESS] \\ --global \\ --target-http-proxy http-lb-proxy \\ --ports 80 當 request 的 address 以及 port 符合 forwarding-rules, 導向指定的 target-https-proxy 下面範例的 [LB_IP_ADDRESS] 請替換為上面建立的靜態 IP 可參考官方文件 建立 HTTPS forwarding-rules gcloud compute forwarding-rules create https-content-rule \\ --address [LB_IP_ADDRESS] \\ --global \\ --target-https-proxy https-lb-proxy \\ --ports 443 總結以上便是 GCP Load Balancer 的 gcloud 各元件順序流程，順序如下：request =&gt; forwarding-rules =&gt; target-http(s)-proxy =&gt; url-map =&gt; backend-service =&gt; instance-group =&gt; instance 照著以上範例跑完之後，只要在 instance 跑服務，並且跑在範例上指定的 port 號，那 request 應會照著上面的順序到達我們的服務。 我花了不少時間來寫這篇文章，希望有幫到需要的人，如果你已經看到這裡，很感謝你把它看完了！ 最後，如果你覺得這篇文章有幫到你，或者你覺得寫得不錯，你的掌聲將是對我最大的鼓勵！ 如果有發現任何錯誤，還請不吝指教哦！","link":"/zh-tw/GCPLoadBalancer/"},{"title":"利用GCP Marketplace來提供服務","text":"概述GCP Marketplace 讓我們可以透過簡單的幾下點擊就可以在 Google Compute Engine 部署一些常見的套裝軟體。 許多網頁框架，資料庫，客戶管理系統以及客戶關係管理系統都有支援。 這是最快速的方法之一，來讓我們的服務運行在 Google Cloud Platform. 在這個手把手教程中，你將會學習如何在 Google Cloud Platform 開始並設置一個 Marketplace 服務 本篇將會做什麼？ 使用 Marketplace 來建立一套網路工具包 核對部署 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 導覽到 Marketplace 在 Google Cloud Console ，找到 Marketplace 如下： 然後應該可以看到 Marketplace 首頁 選擇 Nginx 在搜尋欄輸入 Nginx, 然後選擇 Nginx Certified by Bitnami 的版本 建立 Nginx 工具組VM instance 設定一旦專案建立了，我們將會被帶到位於 Cloud 主控台，新的 Nginx 部署頁面來設定我們的 Nginx instance 為 instance 取名，例如， nginxstack-1 選擇 zone 以下保持預設值 Machine type: micro(1-shared vCPU)0.6GB memory Boot Disk: 10 GB SSD “Allow HTTP Traffic” 以及 “Allow HTTPS Traffic” 需要被勾選 請接受 GCP Marketplace Terms of Service ，在頁面的下方 點擊 Deploy 來建立我們的Nginx 工具組 核對部署 當 Cloud 主控台回報，我們的 Nginx 套組已經部署完畢，我們可以核實一下，是否所有東西都正常運行，我們的畫面看起來應該如下圖： 核對網頁 點擊上圖的藍色按鈕 Visit the site ，我們可以存取部署好的 Nginx 套組，看起來如下圖： 核對 SSH 我們也可以點擊 SSH 連結來打開一個新的 VM instance 視窗。我們可以使用 Unix 指令，像是 ps 來看看 Nginx 是否正常的運行在我們的 instanceps aux | grep nginx 考考你！！ Does Google Cloud Platform Marketplace allow you to deply a software package now, and scale that deployment later when your application require additional capacity without updating the software that you have already deployed true false","link":"/zh-tw/GCPMarketplace/"},{"title":"GKE Migrating to Containers","text":"容器正在以很快的速度成為軟體應用部署的業界標準。 容器化所帶來的商業以及技術上的好處正在推動很多團隊將他們的應用移到容器內。 本教程會提供一個基礎的示範, 示範如何將一個無狀態的應用, 從 VM 上轉移到 Kubernetes Engine (GKE), 本範例示範了應用轉移的過程, 從典型的 VM/OS-based 部署, 到特定的容器化的 os, 再到一個你所知道的容器專用的平台 GKE 概述容器化部署應用有許多的好處, 像是： 隔離 - 應用們有各自的 libraries; 各個應用之間不會因為有不同的 libraries 而產生衝突。 限制(CPU/memory) - 應用們不會佔用其他應用的資源 可攜帶 - 容器含有任何所需的東西, 且不會被 OS 或雲端服務商綁死 輕量化 - 共享 Kernel, 比完整的 OS 鏡像還要輕量且快速 學習目標這個專案示範了轉移一個名為 Prime-flask 的簡單 Python 應用, 到： 一台 虛擬機(Debian VM), Prime-flask 是被部署在這台機器上的唯一應用, 就好像是傳統的運行在一台實體資料中心上的應用。 一個容器化版本的 Prime-flask, 被部署在 Container-Optimized OS (COS) 使用 [Kubernetes] 將 Prime-flask 部署在 Kubernetes Engine 上, 並且使負載平衡來暴露服務。 在完成部署後, 你將會針對最後版本的部署實施一個負載測試, 並且擴縮服務來適應負載 在教程途中, 如果有遇到什麼錯誤, 可以重新執行失敗的 script, 因為偶而會因為網路連線問題出錯, 重試之後就好了。 本教程由 GKE Helmsman 工程師建立, 讓你更了解如何轉移到容器。 你可以在這檢視範例, 並且, 我們歡迎任何人貢獻這個專案。 架構佈局 1: 運行 Debian 的虛擬機, 應用被直接部署到主機的 OS, 無容器 佈局 2: 虛擬機運行容器優化的 OS, 應用被部署在容器內 佈局 3: Kubernetes Engine (GKE) 平台, 很多容器運行在很多機器上 用於此範例的一個簡單的 Python Flask web 應用 (Prime-flask) 已被建立, 並且擁有兩個端點：http://&lt;ip&gt;:8080/factorial/ 以及 http://&lt;ip&gt;:8080/prime/ 使用範例如下：curl http://35.227.149.80:8080/prime/10The sum of all primes less than 10 is 17curl http://35.227.149.80:8080/factorial/10The factorial of 10 is 3628800 以及也可用來驗證是否成功部署 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 安裝 ApacheBench現在安裝 ApacheBench:sudo apt-get install apache2-utils 當被詢問是否繼續是, 輸入 “y” 驗證安裝是否成功：ab -V 輸出應如下：This is ApacheBench, Version 2.3 &lt;$Revision: 1757674 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, 建立虛擬環境執行以下指令下載並更新套件清單:sudo apt-get update Python 虛擬環境是被用來獨立系統內的套件安裝sudo apt-get install vitualenv 如果跳出 [Y/n], 選擇 Y, 然後按 Enter virtualenv -p python3 venv 啟動虛擬環境source venv/bin/activate 複製倉庫git clone https://github.com/GoogleCloudPlatform/gke-migration-to-containers.git 到範例資料夾內：cd gke-migration-to-containers 設定你的 region 以及 zone特定的 Compute Engine 資源位於 regions 以及 zones, 一個 region 為一個運行你的資源的特定地理位置, 然一個 region 有一或多個 zones 更多有關 regions 以及 zones 的資訊可以參考 Regions &amp; Zones documentation 運行以下的指令來設定本教程中的 region 以及 zone (你也可以使用對你來說最佳的 region/zone)gcloud config set compute/region us-central1gcloud config set compute/zone us-central1-a 部署這個專案需要的基礎設施可執行以下指令部署make create 這個範例的設定大概需要最多 15 分鐘。 如果沒有跳錯的話, 建議持續等待。 不要中斷 make create 的執行。 資源建立的過程中, 你可以從主控台的 Compute Engine &gt; VM instances 確認目前進度。 等待過程中, 可以看一下 create.sh script 的內容, 了解它幫你建立了什麼。 你可以使用編輯器來檢視 gke-migration-to-containers/scripts/create.sh make create 指令執行了 create.sh script, 做了以下幾件事： 打包 Prime-flask 應用, 使它可以被複製到 Google Cloud Storage 透過 Google Cloud Build 建立容器鏡像, 並推送到這個專案的 private Container Registry (GCR) 產生 Terraform 適當的設置 執行 Terraform, 建立上述的情境 範例輸出如下：Terraform 建立一個 VM, COS VM, 以及 GKE 叢集： Terraform 輸出顯示在 Debain VM 以及 COS 系統的 (factorial endpoints) 階乘端點： Kubernetes 叢集以及 Prime-flask 服務也被啟動： 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立基礎設施, 你將獲得一個評價分數。 探索 Prime-Flask 環境三個不一樣的環境已經完成設置, Prime-flask app 可以橫跨這些環境, 成為一個在單一虛擬機上運行的容器化應用, 到一個 pod, 運行在一個編排容器的平台, 像是 Kubernetes 一旦你的資源已經準備就緒, 這對你探索系統來說有很大的幫助。 執行以下指令到 vm-webserver 機器, 在這台機器上, 應用正運行在主機的作業系統gcloud compute ssh vm-webserver --zone us-central1-a 如果有詢問是否繼續, 輸入 “Y”, 按下 Enter 兩次來確認不使用密碼 這個環境中沒有隔離效果, 攜帶性也不好。 在某種意義上, 這個應用具有整個系統的存取權, 且在一些其他因素下, 可能無法在失敗後自動回復。 若要擴充這個應用可能需要更多台的虛擬機, 而這很可能無法有效地利用資源。 列出所有程序：ps aux (輸出)root 882 0.0 1.1 92824 6716 ? Ss 18:41 0:00 sshd: user [priv]user 888 0.0 0.6 92824 4052 ? S 18:41 0:00 sshd: user@pts/0user 889 0.0 0.6 19916 3880 pts/0 Ss 18:41 0:00 -bashuser 895 0.0 0.5 38304 3176 pts/0 R+ 18:41 0:00 ps auxapprunn+ 7938 0.0 3.3 48840 20328 ? Ss Mar19 1:06 /usr/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-serverapprunn+ 21662 0.0 3.9 69868 24032 ? S Mar20 0:05 /usr/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 離開：exit 執行以下指令到 cos-vm 機器, 在這台機器上你運行著 docker 容器gcloud compute ssh cos-vm --zone us-central1-a 如果有詢問是否繼續, 輸入 “Y”, 按下 Enter 兩次來確認不使用密碼 COS 是一個優化過的作業系統, 作業系統佔用了很小的空間, 這也是它比較適合運行容器化工作的原因之一。 它是先安裝了 cloud-init 以及 Docker runtime, 而如果有些容器並不需要跑在一些高可靠性的平台的話, 也是很適合跑在這樣的系統。 你可以在宿主機上運行 ps aux 來檢視運行中的 prime-flaskps aux 注意到 docker 以及容器的參考資訊：root 626 0.0 5.7 496812 34824 ? Ssl Mar19 0:14 /usr/bin/docker run --rm --name=flaskservice -p 8080:8080 gcr.io/migration-to-containers/prime-flask:1.0.2root 719 0.0 0.5 305016 3276 ? Sl Mar19 0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 8080 -container-ip 172.17.0.2 -container-port 8080root 724 0.0 0.8 614804 5104 ? Sl Mar19 0:09 docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/mochronos 741 0.0 0.0 204 4 ? Ss Mar19 0:00 /usr/bin/dumb-init /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-serverchronos 774 0.0 3.2 21324 19480 ? Ss Mar19 1:25 /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-serverchronos 14376 0.0 4.0 29700 24452 ? S Mar20 0:05 /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 並且, 如果你試著列出 python path, 會顯示不存在ls /usr/local/bin/python (輸出)ls: cannot access &apos;/usr/local/bin/python&apos;: No such file or directory Docker 列出容器sudo docker ps (輸出)CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd147963ec3ca gcr.io/migration-to-containers/prime-flask:1.0.2 &quot;/usr/bin/dumb-init …&quot; 39 hours ago Up 39 hours 0.0.0.0:8080-&gt;8080/tcp flaskservice 現在你可以執行以下指令來檢視運行在容器內的程序:sudo docker exec -it $(sudo docker ps |awk '/prime-flask/ &#123;print $1&#125;') ps aux (輸出)PID USER TIME COMMAND 1 apprunne 0:00 /usr/bin/dumb-init /usr/local/bin/gunicorn --bind 0.0.0.0: 6 apprunne 1:25 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn - 17 apprunne 0:05 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn - 29 apprunne 0:00 ps aux 退出：exit 接下來, 讓我們到 Kubernetes 環境。 在 Kubernetes 我們可以運行千百個 pods, pods 代表容器的群組。 Kubernetes 是現今部署容器的標準。 它提供了高生產力, 可靠性, 以及擴充性。 Kubernetes 讓你的容器有個家, 且當你的容器失敗了, 它會再次重啟它。 你可以使用很多機器來組成一個叢集, 所以你可以讓它橫跨了不同的區域, 確保了可用性, 以及一些對潛在問題的高適應性。 取得叢集配置：gcloud container clusters get-credentials prime-server-cluster 取得運行在預設命名空間下的 podskubectl get pods (輸出)NAME READY STATUS RESTARTS AGEprime-server-6b94cdfc8b-dfckf 1/1 Running 0 2d5h 檢視 pod 內運行著什麼：kubectl exec $(kubectl get pods -lapp=prime-server -ojsonpath='&#123;.items[].metadata.name&#125;') -- ps aux (輸出)PID USER TIME COMMAND 1 apprunne 0:00 /usr/bin/dumb-init /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 6 apprunne 1:16 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 8 apprunne 2:52 &#123;gunicorn&#125; /usr/local/bin/python /usr/local/bin/gunicorn --bind 0.0.0.0:8080 prime-flask-server 19 apprunne 0:00 ps aux 如你所見, python 應用目前正運行在容器內。 這個應用無法存取任何主機上的東西, 因為這個容器是被隔離的。 它運行在一個 Linux 命名空間, 且(預設)無法存取檔案, 網路, 或在 VM 上的, 在容器裡的, 或任何地方的其他資源。 驗證現在此應用已被部署, 執行以下指令來驗證三種部署:make validate API 可能會花一些時間完成。 立即執行 make validate 可能會出現錯誤, 但那是因為 instances 還沒有完成初始化。 等個 1 或 2 分鐘然後重試一次應可以解決任何問題。 一個成功的輸出將如下：Validating Debian VM Webapp...Testing endpoint http://35.227.149.80:8080Endpoint http://35.227.149.80:8080 is responding.**** http://35.227.149.80:8080/prime/10The sum of all primes less than 10 is 17The factorial of 10 is 3628800Validating Container OS Webapp...Testing endpoint http://35.230.123.231:8080Endpoint http://35.230.123.231:8080 is responding.**** http://35.230.123.231:8080/prime/10The sum of all primes less than 10 is 17The factorial of 10 is 3628800Validating Kubernetes Webapp...Testing endpoint http://35.190.89.136Endpoint http://35.190.89.136 is responding.**** http://35.190.89.136/prime/10The sum of all primes less than 10 is 17The factorial of 10 is 3628800 當然, IP 位址會與你的不同。 負載測試在 Cloud Shell 點擊 + 打開新的 Cloud Shell 視窗。 執行以下指令, 記得將 [IP_ADDRESS] 替換成從驗證輸出得到的 IP 位址以及 port, 注意 Kubernetes 部署運行在 port 80, 而其他兩個部署運行在 port 8080ab -c 120 -t 60 http://&lt;IP_ADDRESS&gt;/prime/10000 ApacheBench(ab) 將在一分鐘內每秒鐘對指定端點發送 120 個併發請求。範例應用的規模並不足以處理這個數量的請求。 結果可以經由 ab 指令的輸出來確認, 如果你看到一個 Failed requests 的值大於 0, 這表示 server 無法成功回應這個負荷 注意: 能不會三個資源都有錯誤 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功地實施負載測試, 你將獲得一個評價分數。 若要確保你的系統可以處理這樣的流量, 可以使用擴充。 在此範例中, 我們將水平的擴充服務 在 Debian 以及 COS 架構, 水平擴充包含： 建立一個平衡負載 開啟額外的機器 使用平衡負載來重新註冊機器 這是一個複雜的程序, 且不在本範例的範圍內。 在第三個部署中 (Kubernetes), 這個程序簡單多了 在你的第一個 Cloud Shell 視窗, 執行以下指令:kubectl scale --replicas 3 deployment/prime-server 測試進度點擊 Check my progress 來確認目前的進度。如果你成功地擴充了你的部署, 你將獲得一個評價分數。 等待 30 秒鐘讓 replicas 初始化, 重新執行以下負載測試：ab -c 120 -t 60 http://&lt;IP_ADDRESS&gt;/prime/10000 可以注意到, Failed requests 現在是 0, 這代表針對這所有的 10,000+ 請求, server 都有成功回應。 清理儘管 Qwiklabs 將會清理所有在本教程中提供的資源, 不過也可以學學如何清理你的環境 在第一個 Cloud Shell 執行以下指令：make teardown 這將執行 terraform destroy, 它會刪除所有本範例中建立的資源。 恭喜你已完成本教程","link":"/zh-tw/GKEMigratingToContainers/"},{"title":"設定 Network 以及 HTTP 平衡負載器","text":"概述在這個教程中，你將會學習 network load balance 與 HTTP load balance 之間的不同，以及如何正確地根據你的應用來設定，讓你的應用在 Google Compute Engine VM 上運行平衡負載的功能。 有好幾種方法可以在Google Cloud Platform 上實施平衡負載。 本教程會帶你走過以下兩種負載器的設定： L3 Network Load Balancer L7 HTTP(s) Load Balancer 學生們會建議自己輸入指令，這對學習核心概念有幫助。 很多教程中，都會有代碼區塊，可以直接複製需要的代碼，你可以很簡單的從代碼區塊複製貼上這些指令到教程中適當的位置。 你將會做什麼 設定一個網路平衡負載器 設定一個 HTTP(S) 平衡負載器 通過實作，學習兩者之間的不同之處 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 為你的資源設定預設的 region 以及 zone 在 Cloud Shell ，設定預設 zone gcloud config set compute/zone us-central1-a 在 Cloud Shell ，設定預設 region gcloud config set compute/region us-central1 建立多個 web server instance為了模擬使用一個群組的機器來服務，我們可以利用 Instance Template 以及 Managed Instance Groups 來創建一個群集的 Nginx web servers 用以服務靜態的內容。 Instance Template 定義了在這個群組中的 virtual machine 的規格（ disk, CPUs, memory, 等等）。 Managed Instance Groups 可以初始化多台使用 Instance Template 定義的 virtual machine 要建立一個 Nginx web server 服務群，建立以下事物: 一份用來設定所有 virtual machine 上的 Nginx server 的 script 一份 instance template 來使用上述的 script 一個 target pool 一個使用 instance template 的 managed instance group 在 Cloud Shell 中，建立一個使用在所有 VM 上的 startup script。 這個腳本會在一開始時設定 Nginx servercat &lt;&lt; EOF &gt; startup.sh#! /bin/bashapt-get updateapt-get install -y nginxservice nginx startsed -i -- 's/nginx/Google Cloud Platform - '\"\\$HOSTNAME\"'/' /var/www/html/index.nginx-debian.htmlEOF 建立使用 startup script 的 instance template gcloud compute instance-templates create nginx-template \\ --metadata-from-file startup-script=startup.sh (輸出)Created [...].NAME MACHINE_TYPE PREEMPTIBLE CREATION_TIMESTAMPnginx-template n1-standard-1 2015-11-09T08:44:59.007-08:00 建立 target pool 。一個 target pool 將針對所有的群組內的 instance 提供一個存取點，且在之後的平衡負載步驟，這是必須的。gcloud compute target-pools create nginx-pool (輸出)Created [...].NAME REGION SESSION_AFFINITY BACKUP HEALTH_CHECKSnginx-pool us-central1 建立一個使用 instance template 的 managed instance group gcloud compute instance-groups managed create nginx-group \\ --base-instance-name nginx \\ --size 2 \\ --template nginx-template \\ --target-pool nginx-pool (輸出)Created [...].NAME LOCATION SCOPE BASE_INSTANCE_NAME SIZE TARGET_SIZE INSTANCE_TEMPLATE AUTOSCALEDnginx-group us-central1-a zone nginx 0 2 nginx-template no 這將會建立兩個擁有相同前綴名稱 nginx-的vurtual machine ，需要幾分鐘。 檢視所有已建立的 instancesgcloud compute instances list (輸出)NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSnginx-7wvi us-central1-a n1-standard-1 10.240.X.X X.X.X.X RUNNINGnginx-9mwd us-central1-a n1-standard-1 10.240.X.X X.X.X.X RUNNING 現在設定防火牆，所以我們可以經由 port 80，EXTERNAL_IP 位址來連接我們的機器 gcloud compute firewall-rules create www-firewall --allow tcp:80 現在我們應該要可以經由上述的 external IP 位址連接到任何一台的 instance 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 建立Network Load BalancerNetwork Load Balancing 允許我們依據收到的 IP 協議資料，像是位址， port 號，還有協議類型，來平衡負載我們的系統。我們還可以取得一些 HTTP(S) load balancing 沒有提供的選項，例如說，基於 TCP/UDP 的協議, 像是 SMTP traffic ，且如果你的應用對 TCP 連結相關的特性感興趣的話， Network Load Balacing 也允許你的 app 去檢查封包，這是 HTTP(S) Load Balancing 沒有提供的。 更多資訊，可以參考Setting Up Network Load Balancing 針對我們的 instance ，建立一個 L3 network load balancer gcloud compute forwarding-rules create nginx-lb \\ --region us-central1 \\ --ports=80 \\ --target-pool nginx-pool (輸出)Created [https://www.googleapis.com/compute/v1/projects/...]. 列出所有 Google Compute Engine 轉發的規則 gcloud compute forwarding-rules list (輸出)NAME REGION IP_ADDRESS IP_PROTOCOL TARGETnginx-lb us-central1 X.X.X.X TCP us-central1/targetPools/nginx-pool 經由瀏覽器來拜訪 load balancerhttp://IP_ADDRESS/IP_ADDRESS 可從上一個指令輸出中找到 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 建立一個 HTTP(S) Load BalancerHTTP(S) Load Balancing 提供全球性的所有對我們的 instance 所做的請求。我們可以設定 URL 規則來將某些 URL 導向一些 instance ，而將另一些 URL 導向另外一些 instance 。正常下，請求將會被導向離使用者最近的 instance ，以確保該群組的 instance 有足夠的資源可以提供給使用者。如果被導向的 instance 沒有足夠的資源，那請求將會被導向離使用者最近的並且有足夠資源的 instance 更多資訊可以參考 HTTP(s) Load Balancer in the documentation 首先，建立一個 health check 。 Health check 可以核實 instance 有針對 HTTP 或 HTTPS 通道做回應 gcloud compute http-health-checks create http-basic-check (輸出)Created [https://www.googleapis.com/compute/v1/projects/...].NAME HOST PORT REQUEST_PATHhttp-basic-check 80 / 定義一個 HTTP 服務，並且給予我們 instance 使用的 port 號, 現在平衡負載服務已經將流量轉發到指定的 portgcloud compute instance-groups managed \\ set-named-ports nginx-group \\ --named-ports http:80 (輸出)Updated [https://www.googleapis.com/compute/v1/projects/...]. 建立 後端服務gcloud compute backend-services create nginx-backend \\ --protocol HTTP --http-health-checks http-basic-check --global (輸出)Created [https://www.googleapis.com/compute/v1/projects/...].NAME BACKENDS PROTOCOLnginx-backend HTTP 將我們的 instance 群組加到後端服務:gcloud compute backend-services add-backend nginx-backend \\ --instance-group nginx-group \\ --instance-group-zone us-central1-a \\ --global (輸出)Updated [https://www.googleapis.com/compute/v1/projects/...]. 建立一個預設的 URL 指定，他將會把所有收到的請求導向我們的 instancegcloud compute url-maps create web-map \\ --default-service nginx-backend (輸出)Created [https://www.googleapis.com/compute/v1/projects/...].NAME DEFAULT_SERVICEWeb-map nginx-backend 若要直接將流量基於請求的 URL 不同，導向不同的 instance, 請參考 content-based routing 建立一個 target HTTP proxy 來將請求導向我們的 URL mapgcloud compute target-http-proxies create http-lb-proxy \\ --url-map web-map (輸出)Created [https://www.googleapis.com/compute/v1/projects/...].NAME URL_MAPhttp-lb-proxy web-map 建立一個全球轉發規則來處理導向所有收到的請求。一個轉發規則將流量送到指定的 HTTP 或 HTTPS 代理根據請求的 IP 位址， IP 協議，或特定的 port 號。全球轉發規則不支援多個 port gcloud compute forwarding-rules create http-content-rule \\ --global \\ --target-http-proxy http-lb-proxy \\ --ports 80 (輸出)Created [https://www.googleapis.com/compute/v1/projects/...]. 全球轉發規則建立之後，需要幾分鐘時間生效gcloud compute forwarding-rules list (輸出)NAME REGION IP_ADDRESS IP_PROTOCOL TARGEThttp-content-rule X.X.X.X TCP http-lb-proxynginx-lb us-central1 X.X.X.X TCP us-central1/.... 我們現在應該要可以從瀏覽器經由http://IP_ADDRESS/來連接，這可能會需要幾分鐘生效。如果無法連接，多等一些時間，重新整理瀏覽器。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 答案是 true 恭喜你已經完成本教程","link":"/zh-tw/HTTPAndNetworkLoadBalancer/"},{"title":"IAM 自訂角色","text":"概述Cloud IAM 提供適當的工具, 以最少的麻煩, 高自動化來管理資源的權限。 你不直接賦予使用者權限。 你賦予他們角色, 角色與一個或多個權限綁定。 這個功能讓我們可以依照工作內容來付予適當的群組以及角色權限。 使用者只會被賦予足夠完成他們工作的權限, 而管理者可以輕鬆地賦予預設權限到整個群組的使用者。在 Cloud IAM 中, 有兩種角色: 預定義好的角色 自定義角色 預定義角色 由 Google 建立並管理。 他們的權限視必要會自動更新, 例如 GCP 新加入了功能或服務。 自定義角色 為使用者自定義, 讓我們可以視需求綁定一個或多個有支援的權限。 自定義角色不被 Google 維護, 當有新權限, 新功能, 或新服務新增到 GCP, 你的自定義角色將不會自動被更新。 自定義角色由一個或多個可用的 Cloud IAM 權限所組成。 權限讓使用者可以對 Google Cloud Platform 資源做特定的操作 你將在本教程中做什麼？ 建立, 更新, 刪除, 取消刪除自定義角色 預先具備條件 對 IAM 角色熟悉 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 理解 IAM 自定義角色Cloud IAM 也提供了自定義角色的能力。 你可以建立一個自訂義的 Cloud IAM 角色, 並加入一個或多個權限, 然後將這個角色賦予給使用者。 Cloud IAM 提供圖形化以及 API 的方式來建立以及管理自定義角色 Key Point: 自定義角色讓你可以實施最低特權的原則, 確保在你的組織中, 使用者以及服務帳號都僅有剛好足夠完成他們工作的權限。 Note: 你可以建立組織等級以及專案等級的自定義角色, 但你無法建立資料夾等級的自定義角色。 藉由整合一個或多個 Cloud IAM 權限, 建立一個自定義角色。 權限可以讓使用者在 Cloud Platform 資源做特定的操作。 在 Cloud IAM 的世界, 權限被表現為以下格式： &lt;service&gt;.&lt;resource&gt;.&lt;verb&gt; 例如, compute.instances.list 權限讓使用者可以列出他們擁有的 Google Compute Engine instance, 而 compute.instances.stop 讓使用者停止一台 VM 通常, 但不是絕對, 權限跟 REST 方法的比例為 1:1 。 這代表說, 每一個 GCP 服務中, 每一個 REST 方法都會有一個相關的權限。 要呼叫一個方法, 你需要相對應的權限。 比如說, topic.publish() 的呼叫者會需要 pubsub.topics.publish 的權限。 唯有該資源是隸屬在該專案或組織的情況之下, 你才可以在該專案或組織內賦予跟此資源有關的權限。 如果你想要自定義角色擁有不屬於這個專案或組織的資源的權限, 那是不行的。 必要的權限以及角色要建立一個自定義角色, 呼叫者必須擁有 iam.roles.create 權限 非擁有者的使用者包含 organization administrators (組織管理者), 必須要被賦予 Organization Role Administrator (組織角色管理者) (roles/iam.organizationRoleAdmin) 或是 IAM Role Administrator (IAM 角色管理者) (roles/iam.roleAdmin) 。 IAM Security Reviewer (IAM 安全審查者) (roles/iam.securityReviewer) 可以檢視自定義角色, 但無法管理他們 自定義角色使用者的介面位於 Google Cloud Platform 主控台的 IAM Roles 之下。 只有有權限的使用者可以建立或管理自定義角色。 若照預設, 只有專案擁有者可以建立新角色。 專案擁有者可以藉由給予其他使用者 IAM Role Administrator 角色來做權限操作; 若是組織的話, 只有組織管理者可以賦予 Organization Role, Administrator 角色 準備建立自定義角色在自定義角色之前, 你可能會想知道 什麼樣的權限可以應用在資源上 什麼樣的角色可以被賦予在資源上 什麼是角色的 metadata? 檢視可獲得的資源權限在你建立一個自訂義角色之前, 你可能會想要知道什麼權限可以被應用到資源上。 你可以使用 gcloud command-line 工具, 主控台, 或是 IAM API 來取得所有適用在資源上的權限, 以及階層排列的資源。 例如, 你可以取得所有你可應用在一個組織中的權限, 以及那個組織中的專案的權限。 執行以下的執行來取得專案中可獲得的權限列表：gcloud iam list-testable-permissions //cloudresourcemanager.googleapis.com/projects/$DEVSHELL_PROJECT_ID 輸出：name: appengine.applications.createstage: GA---name: appengine.applications.getstage: GA---name: appengine.applications.updatestage: GA---name: appengine.instances.delete stage: GA---name: appengine.instances.getstage: GA---name: appengine.instances.liststage: GA---customRolesSupportLevel: TESTINGname: appengine.memcache.addKeystage: BETA---customRolesSupportLevel: TESTINGname: appengine.memcache.flushstage: BETA--- 取得角色 metadata在你建立自訂義角色之前, 你可能會想要獲得事先定義以及自定義角色的 metadata。 角色 metadata 包含角色 ID 以及該角色擁有的權限。 你可以使用 Google Cloud Platform 主控台或者是 IAM API 來檢視 metadata 執行以下指令來檢視角色 metadata, 將 [ROLE_NAME] 替換成欲檢視的角色, 例如： roles/viewer 或 roles/editorgcloud iam roles describe [ROLE_NAME] 範例輸出(roles/viewer):description: Read access to all custom roles in the project.etag: AA==includedPermissions:- iam.roles.get- iam.roles.list- resourcemanager.projects.get- resourcemanager.projects.getIamPolicy......name: roles/iam.roleViewerstage: GAtitle: Role Viewer 檢視資源上可賦予的角色使用 gcloud iam list-grantable-roles 指令來獲得可賦予到指定資源上的角色列表 執行以下的 gcloud 指令來列出你的專案中可賦予的角色:gcloud iam list-grantable-roles //cloudresourcemanager.googleapis.com/projects/$DEVSHELL_PROJECT_ID 輸出應如下：---description: Full management of App Engine apps (but not storage).name: roles/appengine.appAdmintitle: App Engine Admin---description: Ability to view App Engine app status.name: roles/appengine.appViewertitle: App Engine Viewer---description: Ability to view App Engine app status and deployed source code.name: roles/appengine.codeViewertitle: App Engine Code Viewer---...... 建立自定義角色要建立自定義角色, 呼叫者必須擁有 iam.roles.create 權限。 預設來說, 專案或組織的擁有者擁有可以建立以及管理自定義角色的權限 非擁有者的使用者, 包含組織管理員, 必須被賦予 Organization Role Administrator 角色, 或是 IAM Role Administrator 角色 使用 gcloud iam roles create 指令來建立新的自訂義角色。 你有兩種方式來使用這個指令： 提供含有角色定義的 YAML 檔案 當建立自定義角色時, 使用指定角色定義的旗標, 你必須指定指令的作用範圍, 是組織等級的還是專案等級的, 使用 --organization [ORGANIZATION_ID] 或 --project [PROJECT_ID] 旗標。 下面的範例都是建立一個專案等級的自定義角色 循著以下的範例, 你將建立專案等級的自訂義角色 使用 YAML 檔案來建立自訂義角色建立一個含有自定義角色定義的 YAML 檔。 檔案的結構必須像下面這樣：title: [ROLE_TITLE]description: [ROLE_DESCRIPTION]stage: [LAUNCH_STAGE]includedPermissions:- [PERMISSION_1]- [PERMISSION_2] 填入值的敘述如下： [ROLE_TITLE] 角色職稱, 像是 Role Viewer, 可自定義 [ROLE_DESCRIPTION] 簡短的角色敘述, 像是 My custom role description [LAUNCH_STAGE] 角色在啟動的生命週期, 像是 ALPHA, BETA, 或 GA, 可參考文件 [includePermissions] 指定了一個或多個這個自定義角色將包含的權限, 像是 iam.roles.get 該是動手的時間了！ 建立你的角色定義 YAML 檔, 執行以下指令：vim role-definition.yaml 將下面的定義增加到 YAML 檔案：title: \"Role Editor\"description: \"Edit access for App Versions\"stage: \"ALPHA\"includedPermissions:- appengine.versions.create- appengine.versions.delete 然後儲存並關閉檔案 執行下面的 gcloud 指令:gcloud iam roles create editor --project $DEVSHELL_PROJECT_ID \\--file role-definition.yaml 如果角色成功被建立, 會得到以下的回應 Created role [editor].description: Edit access for App Versionsetag: BwVs4O4E3e4=includedPermissions:- appengine.versions.create- appengine.versions.deletename: projects/[PROJECT_ID]/roles/editorstage: ALPHAtitle: Role Editor 使用 flag (旗標) 來建立自定義角色現在你將使用旗標方法來建立一個新的自訂義角色。 旗標方法採用一個類似 YAML 檔案的格式, 所以你將可以辨識這個指令是如何被建立的 執行以下 gcloud 指令來使用旗標建立一個新的角色gcloud iam roles create viewer --project $DEVSHELL_PROJECT_ID \\--title \"Role Viewer\" --description \"Custom role description.\" \\--permissions compute.instances.get,compute.instances.list --stage ALPHA 範例輸出：Created role [viewer].description: Custom role description.etag: BwVs4PYHqYI=includedPermissions:- compute.instances.get- compute.instances.listname: projects/[PROJECT_ID]/roles/viewerstage: ALPHAtitle: Role Viewer 列出自定義角色執行以下指令來列出自定義角色, 指定專案等級或是組織等級gcloud iam roles list --project $DEVSHELL_PROJECT_ID 範例輸出：---description: Edit access for App Versionsetag: BwVxLgrnawQ=name: projects/[PROJECT_ID]/roles/editortitle: Role Editor---description: Custom role description.etag: BwVxLg18IQg=name: projects/[PROJECT_ID]/roles/viewertitle: Role Viewer 若要列出已刪除的角色, 你可以使用 --show-deleted 旗標執行下面的 gcloud 指令來列出預定義的角色gcloud iam roles list 編輯一個現存的自定義角色更新資源的 metadata 的一個常用模式, 例如更新一個自訂義角色, 會先讀他目前的狀態, 在本地更新資料, 然後送出更改後的資料來複寫。 如果兩個或以上的動作同時發生, 可能會造成衝突 例如, 如果兩個專案的擁有者在同一時間試圖對一個角色做修改, 某些改變可能會失敗 Cloud IAM 在自定義角色中使用 etag 屬性來解決這個問題。 這個屬性被使用來核對這個自定義角色從上次請求之後是否被更改過了。 當你使用 etag 對 Cloud IAM 送出一個請求, Cloud IAM 會比較請求中以及目前的 etag 值, 唯有 etag 值吻合了, 變更才會被寫入 使用 gcloud iam roles update 指令來更新自定義角色。 你有兩種方式來使用這個指令: 提供含有角色定義的 YAML 檔案 當更新自定義角色時, 使用指定角色定義的旗標 當更新一個自定義角色時你必須指定指令的作用範圍, 是組織等級的還是專案等級的, 使用 --organization [ORGANIZATION_ID] 或 --project [PROJECT_ID] 旗標。 下面的範例都是建立一個專案等級的自定義角色 describe 指令會返回角色的定義, 包含可獨特辨識角色目前版本的 etag 值。 當更新角色定義時, etag 值必須被提供, 以確保同時變更的請求不會互相複寫 使用 YAML 檔案來更新自定義角色執行以下的 gcloud 指令來取得目前的角色定義, 將 [ROLE_ID] 替換成 editorgcloud iam roles describe [ROLE_ID] --project $DEVSHELL_PROJECT_ID describe 指令會返回以下輸出:description: [ROLE_DESCRIPTION]etag: [ETAG_VALUE]includedPermissions:- [PERMISSION_1]- [PERMISSION_2]name: [ROLE_ID]stage: [LAUNCH_STAGE]title: [ROLE_TITLE] 你將使用輸出的值來建立一個新的 YAML 檔案。 從這個指令中複製輸出 使用你的編輯器建立一個 new-role-definition.yamlvim new-role-definition.yaml 將上面輸出的值貼上, 然後在 includedPermissions 下面增加兩個權限：- storage.buckets.get- storage.buckets.list 現在你的 YAML 檔看起來應該如下：description: Edit access for App Versionsetag: BwVxIAbRq_I=includedPermissions:- appengine.versions.create- appengine.versions.delete- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/editorstage: ALPHAtitle: Role Editor 儲存並離開檔案 現在你將使用 update 指令來更新角色。 執行以下的 gcloud 指令, 將 [ROLE_ID] 替換成 editor:gcloud iam roles update [ROLE_ID] --project $DEVSHELL_PROJECT_ID \\--file new-role-definition.yaml 如果角色成功被更新, 輸出會像以下那樣:description: Edit access for App Versionsetag: BwVxIBjfN3M=includedPermissions:- appengine.versions.create- appengine.versions.delete- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/editorstage: ALPHAtitle: Role Editor 使用旗標來更新自定義角色角色定義更新中, 每部份都有各自對應的旗標。 旗標清單可參考文件 你可以使用下面的旗標來增加以及移除權限: --add-permissions: 增加一個或多個, 以逗號分隔的權限 --remove-permissions: 移除一個或多個, 以逗號分隔的權限 你也可以指定新的權限來取代掉目前的權限, 使用 --permissions [PERMISSIONS] 旗標以及以逗號來分隔權限 執行下面的 gcloud 指令, 使用旗標來增加權限到 viewer 角色gcloud iam roles update viewer --project $DEVSHELL_PROJECT_ID \\--add-permissions storage.buckets.get,storage.buckets.list 如果角色成功地被更新, 以下的輸出將會返回description: Custom role description.etag: BwVxLi4wTvk=includedPermissions:- compute.instances.get- compute.instances.list- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/viewerstage: ALPHAtitle: Role Viewer 使自定義角色失效當角色被無效化, 與之相連的政策也會失效, 就是說權限將會停止被賦予到這個角色, 儘管你賦予了使用者這個角色 無效化一個現存自定義角色最簡單的方法就是使用 --stage 指標來把它設成 DISABLED 執行以下的 gcloud 指令來無效化 viewer 角色gcloud iam roles update viewer --project $DEVSHELL_PROJECT_ID \\--stage DISABLED 如果角色成功地被更新了, 將會返回以下輸出：description: Custom role description.etag: BwVxLkIYHrQ=includedPermissions:- compute.instances.get- compute.instances.list- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/viewerstage: DISABLEDtitle: Role Viewer 刪除自定義角色使用 gcloud iam roles delete 指令來刪除自定義角色。 一旦角色被刪了, 它就失效了, 無法再被用來與任何政策相對應 gcloud iam roles delete viewer --project $DEVSHELL_PROJECT_ID 範例輸出：description: Custom role description.etag: BwVxLkf_epw=includedPermissions:- compute.instances.get- compute.instances.list- storage.buckets.get- storage.buckets.listname: projects/[PROJECT_ID]/roles/viewerstage: DISABLEDtitle: Role Viewer 在角色被刪除之後, 現存的連結將會保留, 但是是無效的。 角色可以在 7 天內被復原, 要是過了 7 天, 這個角色會進入一個永久刪除程序, 持續 30 天, 所以過了 37 天之後, 這個角色的 ID 又可以被使用了 注意： 如果角色被棄用了, 修改 role.stage 屬性為 DEPRECATED, 然後設定 deprecation_message, 這樣可以讓使用者知道替代角色是哪一個, 或是哪裡可以得到更多資訊 復原自定義角色在 7 天內, 你可以復原一個刪除了的角色。 被刪除的角色處於 DISABLED 階段, 你可以利用旗標 --stage 來更新它, 讓他再次可用gcloud iam roles undelete viewer --project $DEVSHELL_PROJECT_ID 恭喜你已經完成本教程！","link":"/zh-tw/IAMCustomRoles/"},{"title":"使用 Laravel Queue 以及 AWS SQS","text":"前言本篇重點如下： 使用 Laravel queue 完成寄 Email 功能 使用 AWS SQS 為什麼要使用 queue 呢？當我們執行一些耗時較久的工作時，像是發送 Email ， 或是上傳圖片或是影片，讓使用者等到工作執行完畢才進行下一個動作的話，是不太現實的。所以當使用者發出一些需要較長時間執行的請求時，我們要使用 queue 來幫我們隊列，在背景慢慢執行，然後讓使用者可以立即執行下一個動作。 申請 AWS SQS 服務 首先，你要有 AWS 帳號 到 AWS 上申請 SQS 服務 這邊可以參考 AWS教學，完成設定。 記住下面的資料，後面會用到 到右上角，選擇帳戶的地方，選擇My Security Credentials 到左邊選擇 Users 建立新的 User 輸入 user 名稱，打勾 Programmatic access ，然後下一步 然後 Create group ，如下圖 再來把剛剛建立的 user 加到這個新建的 group 接下來 Add tags 是選填，不一定要填 然後就可以獲得 Access key ID 以及 Secret access key ，如果怕忘記的話，可以下載下來哦！ 這個 Secret access key 只會出現一次哦，如果不小心忘記或沒有記下來的話，就要重新產生哦！ 實作 Laravel queue配置 AWS SQS 以下操作均參考官方文件 安裝 AWS 官方 SDK ，參照官方文件 ，在專案資料夾底下： composer require aws/aws-sdk-php 在.env檔案中，做以下配置 QUEUE_CONNECTION=sqsSQS_KEY=上面拿到的 keySQS_SECRET=上面拿到的 secretSQS_QUEUE=testSQSSQS_REGION=ap-northeast-1SQS_PREFIX=依照上面的URL去掉queue名稱後填入 建立 jobsphp artisan make:job ProcessPodcast job 範本如下&lt;?phpnamespace App\\Jobs;use App\\Helpers;use Illuminate\\Bus\\Queueable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Foundation\\Bus\\Dispatchable;class SendMailWhenOrderPlaced implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $job; // 嘗試執行最高次數 public $tries = 5; /** * Create a new job instance. * * @return void */ public function __construct($order, $FB_email, $Local_email) &#123; $this-&gt;order = $order; $this-&gt;FB_email = $FB_email; $this-&gt;Local_email = $Local_email; $this-&gt;job = Helpers::mailWhenOrderPlaced($order, $FB_email, $Local_email); &#125; /** * Execute the job. * * @return void */ public function handle() &#123; return $this-&gt;job; &#125;&#125; 上面的範例，是使用 queue 來執行 Ray 專案裡頭的一個寄送 Email 的功能，叫做 mailWhenOrderPlaced。 使用 dispatch 在我們想要執行這一個job的地方，使用dispatch，就可以囉！SendMailWhenOrderPlaced::dispatch($order, $FB_email, $Local_email); 執行 queue 在專案底下，執行php artisan queue:work 測試 這個時候，當程式執行到 dispatch 那行時，就會使用 queue 來執行哦！ 總結是不是很簡單啊？另外，因為我們使用了 queue ，所以必須要確保 queue 的運作是正常的。以這個例子來說的話，如果 queue 不幸失效了，那這個發 Email 的功能就會失效哦！為了確保 queue 在失敗後重新自動執行，我們需要 Supervisor 來幫我們監控並管理程序！關於 Supervisor ，可以參考 Ray 的另外一篇文章哦！如果想知道如何用 Laravel Mail 以及 AWS SES 來發送 mail ，也可以參考 Ray 的另外一篇文章","link":"/zh-tw/LaravelQueueWithSQS/"},{"title":"取得 Facebook 長期權杖 (long lived token)，以及 永不過期權杖 (never expired token)","text":"前言本篇將分享如何利用 Facebook 的圖形 API 測試工具，以及 PHP 來取得長期權杖 (long lived token)，以及永不過期權杖 (never expired token)目前正在做一個 Facebook 的直播拍賣優化系統的後端，發現前端的短期 (short lived token) 權杖有效時間只有不到兩個小時，相較於 Android 的三個月，以及 iOS 的兩個月，實在是有夠短。雖然說 code 寫好之後其實也無所謂，但是就想來研究一下如何拿到長期的權杖 (long lived token) Facebook 的圖形 API 測試工具長期權杖 (long lived token)首先，讓我們先用 Facebook 的圖形 API 來拿長期權杖 (long lived token) 測試帳號 取得測試測試帳號權杖 圖形 API 測試工具 輸入剛剛獲得的權杖 按下’提交’ 按下權杖左邊的驚嘆號，並選擇，以存取權杖工具開啟 點擊左下方的，延伸存取權杖 得到兩個月的長期權杖 (long lived token) 永不過期的粉絲專頁權杖接下來，讓我們使用 Facebook 的圖形 API 測試工具來取得永不過期的權杖 (never expired token) 首先，讓我們登入測試帳號，並申請一個粉絲團 跟上面的流程完全一模一樣，我們就可以拿到永不過期的權杖 (never expired token) PHP長期權杖 (long lived token)現在讓我們使用 PHP 來透過呼叫 Facebook 的 API 來取得長期權杖 (long lived token) 使用 PHP 的 function file_get_contents來呼叫 Facebook 的 API public static function getLongLivedToken($token)&#123; $url = 'https://graph.facebook.com/oauth/access_token?grant_type=fb_exchange_token&amp;client_id=yourClientID&amp;client_secret=yourClientSecret&amp;fb_exchange_token=shortLivedToken; return json_decode(file_get_contents($url), true);&#125; 會得到以下資訊: &#123; \"result\": true, \"response\": &#123; \"access_token\": \"EAAEpKfFACZA8BAGyTFU29VFIlEjhDaUe66eliyWdGQDfVTBUUdFZBZAGeZBEgTEwxgthvdABuzECYi1ahqm8ZCYNRSV9YMnegq7XxCouP1sR8kXMdnNFysGb2IHZBhSB3KENeTZCBzHrFSJ9BJLt9k6xkuWkJsVHnG0KahmFmybKTG6pVaFoZATN\", \"expires_in\": 5182393 &#125;&#125; 結語至於如何利用 PHP 來取得永不過期的粉絲專頁權杖 (never expired token)，似乎需要提升 APP 的權限，這方面需要審查，所以我就暫時無法測試啦。","link":"/zh-tw/FacebookLongLivedToken/"},{"title":"你好！Kubernetes","text":"概述本教程的目標是將開發完畢的代碼轉成運行在 Kubernetes 上可複製的應用, 本教程中 Kubernetes 運行在 Kubernetes Engine。 在本教程中, 代碼會是簡單的 Hello World node.js 應用 下圖是一個圖示顯示個元件在本教程中扮演的角色, 讓我們了解個元件彼此之間是如何互相配合的。 當你在進行本教程時, 可以參考這個圖示。 當你結束本教程, 你將會了解整個脈絡 (如果現在看不懂可以先跳過) 。 Kubernetes 是一個開源的專案 (可從 kubernetes.io 獲得), 可以運行在很多不同的環境上, 從筆電到高可用的多主機叢集; 從公開的雲端到人為部署; 從虛擬機到裸機 在本教程中, 使用一個受管理的環境, 像是 Kubernetes Engine (一個由 Google 維護的 Kubernetes 版本, 運行在 Compute Engine 上), 將會讓你可以更專注在體驗 Kubernetes, 而不是設定底層的環境。 本篇將會做什麼？ 建立一個 Node.js server 建立一個 Docker container image 建立一個 container cluster 建立一個 Kubernetes Pod 擴大服務 前言本篇主要是利用Google的Qwiklab平台學習的同時,做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立你的 Node.js 應用使用 Cloud Shell, 寫一個簡單的 Node.js server, 你將會部署這個 Server 到 Kubernetes Enginevi server.js 進入編輯模式i 在檔案中增加以下內容：var http = require('http');var handleRequest = function(request, response) &#123; response.writeHead(200); response.end(\"Hello World!\");&#125;` 注意: 這邊使用 vi, 但是 nano 以及 emacs 在 Cloud Shell 當中也有。 你也可以使用 CloudShell 的瀏覽器編輯器功能, 像是 儲存 server.js 檔案, 按下 Esc, 然後：:wq Cloud Shell 已內建 node, 直接執行 node servernode server.js 使用 Cloud Shell 內建的 Web 預覽功能, 開一個新的視窗並發請求到 port 8080, 如下圖： 一個新的瀏覽器視窗將會開啟並且顯示結果： 在更進一步之前, 讓我們先到 Cloud Shell 按下 Ctrl+c 停止正在運行中的 node server, 我們將打包這個運用, 並置於 Docker container 內 建立一個 Docker container image接下來, 建立一個 Dockerfile 來敘述我們想要建立的 image, Docker container images 可以是已經存在 image 的延伸, 所以我們將從已經存在的 Node image 來延伸 vim Dockerfile 進入編輯模式i 增加以下內容FROM node:6.9.2EXPOSE 8080COPY server.js .CMD node server.js 上面 Docker image 的內容將會執行以下的事： 開始一個從 Docker hub 找到的 node image 暴露 port 8080 複製 server.js 檔案到此 docker image 開始一個 node server, 就像我們上一步手動開啟那樣 儲存 Dockerfile 檔案, 按下 Esc, 然後：:wq 輸入以下的指令來建立 image, 將下面的 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到docker build -t gcr.io/PROJECT_ID/hello-node:v1 . 接下來會花一些時間來下載以及擷取需要的東西, 但你可以從進度條看到 image 建立的進度 完成之後, 於本地端使用下面的指令測試一下這個 image, 這個指令會從剛新建立的 container image 中, 將 Docker container 以常駐的方式跑在 port 8080, 執行下面的指令, 並將的 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到 docker run -d -p 8080:8080 gcr.io/PROJECT_ID/hello-node:v1 結果大概如下325301e6b2bffd1d0049c621866831316d653c0b25a496d04ce0ec6854cb7998 可使用 Web 預覽功能 或在 Cloud Shell 中使用 curlkcurl http://localhost:8080 注意： 完整的 docker run 文件你可以在這裏找到 接下來, 停止運行中的容器 尋找 Docker container ID docker ps 結果大概如下CONTAINER ID IMAGE COMMAND2c66d0efcbd4 gcr.io/PROJECT_ID/hello-node:v1 &quot;/bin/sh -c &apos;node 執行以下指令來關閉容器, 並將 [CONTAINER ID] 替換成之前獲得的值docker stop [containerID] 結果會輸出你的 container ID ,如下：2c66d0efcbd4 現在, image 如我們預期般的運作著, 接下來我們將它推到 Google Container Registry, 一個可被 Google Cloud Projects 存取的 Docker image 私人資料夾。 執行下面的指令, 並將的 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。 gcloud auth configure-docker docker push gcr.io/PROJECT_ID/hello-node:v1 第一次的推送可能會花個幾分鐘完成。 當它在建立時, 你可以看到進度條。 The push refers to a repository [gcr.io/qwiklabs-gcp-6h281a111f098/hello-node]ba6ca48af64e: Pushed381c97ba7dc3: Pushed604c78617f34: Pushedfa18e5ffd316: Pushed0a5e2b2ddeaa: Pushed53c779688d06: Pushed60a0858edcd5: Pushedb6ca02dfe5e6: Pushedv1: digest: sha256:8a9349a355c8e06a48a1e8906652b9259bba6d594097f115060acca8e3e941a2 size: 2002 Container image 將會被列在主控台中, 選擇 Navigation menu &gt; Container Registry 現在我們擁有 project-wide 的 Docker image ,可供 Kubernetes 存取以及編排 注意： 在這次註冊中使用一個通用的 domain (gcr.io)。 在你自己的環境中, 你可以指定哪一個 zone 或是儲存區, 詳見文件 建立 cluster現在我們已經準備好可以建立 Kubernetes Engine cluster 。 一個 cluster 內, 有由 Google 管理的 Kubernetes master API server, 以及一組 worker nodes 。 worker nodes 為 Compute Engine 的虛擬機 確保我們已經使用 gcould 來設定我們的專案 (將 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。) gcloud config set project PROJECT_ID 使用兩個 n1-standard-1 nodes 來建立 cluster (將會耗費幾分鐘) gcloud container clusters create hello-world \\ --num-nodes 2 \\ --machine-type n1-standard-1 \\ --zone us-central1-a 在建立時, 若看到警告可以無視。輸出應會如下：Creating cluster hello-world...done.Created [https://container.googleapis.com/v1/projects/PROJECT_ID/zones/us-central1-a/clusters/hello-world].kubeconfig entry generated for hello-world.NAME ZONE MASTER_VERSION MASTER_IP MACHINE_TYPE STATUShello-world us-central1-a 1.5.7 146.148.46.124 n1-standard-1 RUNNING 注意： 你也可以透過主控台來建立 cluster, 打開 Navigation 選單並選擇 Kubernetes Engine &gt; Kubernetes cluster &gt; Create cluster 注意： cluster 建立的區域,建議跟 container registry 使用的儲存區的所在區域一樣 如果你選擇 Navigation menu &gt; Kubernetes Engine , 可以看到, 現在有一個由 Kubernetes Engine 驅動的, 功能完全的 Kubernetes 叢集 接下來, 是時候將我們容器化的 application 部署到 Kubernetes cluster, 從現在開始, 我們將使用 kubectl 命令行（在 Cloud Shell 環境中,這已經被設定完畢） 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 建立 PodKubernetes pod 由多個容器組成, 用於管理以及連結。 它可以容納單一或多個容器。 這邊我們將會使用儲存於私人的 container registry, 由 Node.js image 建立的容器 。 將會運行在 8080 port 使用 kubectl run 指令來建立一個 pod (將 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。)kubectl run hello-node \\ --image=gcr.io/PROJECT_ID/hello-node:v1 \\ --port=8080 輸出：deployment &quot;hello-node&quot; created 可以看到, 我們已經建立一個 deployment 物件。 Deployments 是建立跟擴大 pods 推薦的方法。 這邊, 一個新的 deployment 管理一個正運行著 hello-node:v1 image 的 pod 若要檢視 deployment, 運行：cloudkubectl get deployments 輸出：NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-node 1 1 1 1 2m 若要檢視由 deployment 建立的 pod, 運行：kubectl get pods 輸出：NAME READY STATUS RESTARTS AGEhello-node-714049816-ztzrb 1/1 Running 0 6m 現在是時候來看看一些有趣的 kubectl 指令。 他們都不會變更叢集的狀態, 完整個文件可參考這裡 cloudkubectl cluster-info cloudkubectl config view Debug 專用： cloudkubectl get events cloudkubectl logs &lt;pod-name&gt; 現在你需要讓外部可以存取你的 pod 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 允許外部連結在預設中, Pod 只可被 cluster 內部的 IP 存取。為了要讓 hello-node container 可被 Kubernetes virtual network 之外的地方存取,我們必須設定 Pod 成可被存取的 Kubernetes 的服務 在 Cloud Shell, 透過使用 kubectl expose 指令, 並結合 --type=&quot;LoadBalancer&quot; 旗標, 我們可以讓 Pod 可被公用網路存取。要建立一個外部存取 IP, 這個 flag 是必須的。kubectl expose deployment hello-node --type=\"LoadBalancer\" 輸出： service &quot;hello-node&quot; exposed 這個 flag 指定我們將使用底層基礎設施提供的平衡負載 (在此範例中,為 Compute Engine load balancer)。需注意我們是使 deployment 可視化, 並非直接暴露 Pod 。這代表, 服務將會在所有由 deployment 管理的 pods 之間平衡負載流量 (於此範例中, 為一個Pod, 但我們等等會增加) 此 Kubernetes master 建立了 load balancer, 相關的 Compute Engline 轉發規則, target pools, 以及防火牆規則, 所以服務可被 Google Cloud Platform 之外的來源所存取 若要找公開可存取IP, 可要求 kubectl 列出所有的 cluster 服務kubectl get services 結果如下：NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGEhello-node 10.3.250.149 104.154.90.147 8080/TCP 1mkubernetes 10.3.240.1 &lt;none&gt; 443/TCP 5m 上圖可以看到, hello-node service 有兩組 IP, 兩組都使用 port 8080, CLUSTER-IP 是內部 IP, 只可被內部 cloud virtual network 所見, EXTERNAL-IP 為外部 load-balanced IP 注意： EXTERNAL-IP 可能會需要幾分鐘的時間變得可用, 以及可視化。 如果 EXTERNAL-IP 不可用, 等幾分鐘, 然後再次執行指令。 現在你應該可以透過以下的連結來存取服務: http://&lt;EXTERNAL_IP&gt;:8080 使用容器化以及 Kubernetes 之後, 你已經獲得很多新的功能 - 你不需要指定哪台主機來運行你的工作, 且還有服務的監控以及重啟功能。 現在讓我們來看看我的們新 Kubernetes 還有什麼其他功能 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 擴充服務Kubernetes 提供的其中一個強大的功能, 就是非常簡單的擴充你的應用。 假如你忽然間需要很大的容量, 你可以告訴 replication controller 來為我們的 pod 設置一個新的 replicas 數量kubectl scale deployment hello-node --replicas=4 輸出：deployment &quot;hello-node&quot; scaled 你可以查看更新後的 deploymentkubectl get deployment 輸出：NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-node 4 4 4 4 16m 你也可以列出所有的 podskubectl get Pods 輸出：NAME READY STATUS RESTARTS AGEhello-node-714049816-g4azy 1/1 Running 0 1mhello-node-714049816-rk0u6 1/1 Running 0 1mhello-node-714049816-sh812 1/1 Running 0 1mhello-node-714049816-ztzrb 1/1 Running 0 16m 一個宣告式的方法在這裡被使用。 你宣告了多少個 instances 應該被使用, 而不是開啟或關閉新的 instances. Kubernetes 的調和迴圈確保實際情況符合你要求的, 並且必要時採取動作。 以下圖片總結 Kubernetes 叢集的狀態: 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 升級服務某些時候,已經被部署的應用需要 debug 或增加新的功能。 Kubernetes 幫我們部署新的版本,並且不影響使用者 首先, 修改應用, 編輯 server.jsvim server.js i 更新回覆訊息response.end(\"Hello Kubernetes World!\"); 按下 ESC, 然後輸入以下指令來儲存 server.js:wq 現在, 我們可以透過往上增加的版本號, (v2, 在本範例中) 建立以及發布一個新的 container image 到 registry。 執行以下指令(將 PROJECT_ID 替換成你的 GCP Project ID, 可以從主控台以及 Connection Details 區找到。) docker build -t gcr.io/PROJECT_ID/hello-node:v2 . gcloud docker -- push gcr.io/PROJECT_ID/hello-node:v2 注意： 建立以及推送更新的 image 應該會比較快, 因為 cache 已經被使用了 Kubernetes 將會流暢的更新你的 replication controller 到新的應用程式版本。 為了要改變運行中容器的 image 的標籤, 你需要編輯已經存在的 hello-node deployment 以及將 image 由 gcr.io/PROJECT_ID/hello-node:v1 變更為 gcr.io/PROJECT_ID/hello-node:v2 使用 kubectl edit 指令來做到這一點。 它會打開一個顯示所有 deployment yaml 設定檔的編輯器。 現在不需要理解所有的 yaml 設定, 只需要理解如果我們更新了 spec.template.spec.containers.image 欄位, 那相當於告訴 deployment 使用新的 image 更新 pods。 cloudkubectl edit deployment hello-node 尋找 Spec &gt; containers &gt; image, 然後改變版本號碼到 v2 # Please edit the object below. Lines beginning with a '#' will be ignored,# and an empty file will abort the edit. If an error occurs while saving this file will be# reopened with the relevant failures.#apiVersion: extensions/v1beta1kind: Deploymentmetadata: annotations: deployment.kubernetes.io/revision: \"1\" creationTimestamp: 2016-03-24T17:55:28Z generation: 3 labels: run: hello-node name: hello-node namespace: default resourceVersion: \"151017\" selfLink: /apis/extensions/v1beta1/namespaces/default/deployments/hello-node uid: 981fe302-f1e9-11e5-9a78-42010af00005spec: replicas: 4 selector: matchLabels: run: hello-node strategy: rollingUpdate: maxSurge: 1 maxUnavailable: 1 type: RollingUpdate template: metadata: creationTimestamp: null labels: run: hello-node spec: containers: - image: gcr.io/PROJECT_ID/hello-node:v1 ## Update this line ## imagePullPolicy: IfNotPresent name: hello-node ports: - containerPort: 8080 protocol: TCP resources: &#123;&#125; terminationMessagePath: /dev/termination-log dnsPolicy: ClusterFirst restartPolicy: Always securityContext: &#123;&#125; terminationGracePeriodSeconds: 30 更改之後, 按下 Esc, 然後輸入以下指令來儲存並且離開檔案:wq 輸出應如下：deployment &quot;hello-node&quot; edited 執行以下指令來使用新的 image 更新 deploymentcloudkubectl get deployments 更新後的 image 將會被使用來建立新的 pods, 而舊的 pods 會被刪除 輸出應如下：NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEhello-node 4 4 4 4 1h 在這一切發生的過程中, 你的服務的使用者不會看到任何的服務中斷。 過一段時間後, 他們會開始存取新版的應用。 關係滾動升級的更多細節可以參考文件 使用這些部署, 擴充, 更新的功能, 一旦我們完成 Kubernetes Engine 叢集的設定, 我們可以把我們節省花在基礎設施上的時間並專注在開發上。 Kubernetes圖形化面板 (optional)最近的 Kubernetes 版本已經推出了圖示化的網頁使用者介面 (dashboard)。 顯示面板讓我們可以更快速的使用 Kubernetes, 並且可以開啟一些 CLI 的功能, 像是是一種更容易理解, 且更容易發現問題的與系統互動的方式。 執行以下指令來取得 cluster 層級權限kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account) 使用適當的權限設定, 執行以下指令來建立一個新的顯示面板服務kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml 你應會收到類似輸出：secret &quot;kubernetes-dashboard-certs&quot; createdserviceaccount &quot;kubernetes-dashboard&quot; createdrole.rbac.authorization.k8s.io &quot;kubernetes-dashboard-minimal&quot; createdrolebinding.rbac.authorization.k8s.io &quot;kubernetes-dashboard-minimal&quot; createddeployment.apps &quot;kubernetes-dashboard&quot; createdservice &quot;kubernetes-dashboard&quot; created 執行以下指令來編輯面板服務的 yaml 表現kubectl -n kube-system edit service kubernetes-dashboard 按下 i, 進入編輯模式 將 type: ClusterIP 更改為 type: NodePort 在做完一切更改後, 按下 Esc, 然後輸入以下指令儲存離開:wq 要登入 Kubernetes 顯示面板, 你需要使用 token 驗證。 使用由 service account 分配的 token, 例如 namespace-controller 要獲得 token, 執行以下指令：cloudkubectl -n kube-system describe $(kubectl -n kube-system \\get secret -n kube-system -o name | grep namespace) | grep token: 輸出應如下：token: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlLXN5c3RlbSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJuYW1lc3BhY2UtY29udHJvbGxlci10b2tlbi1kOTZyNCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJuYW1lc3BhY2UtY29udHJvbGxlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6ImU2ZmFkNGQ5LTJjNjYtMTFlOC05NDFiLTQyMDEwYTgwMDFlYiIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlLXN5c3RlbTpuYW1lc3BhY2UtY29udHJvbGxlciJ9.AY3Fp-T_4wxTzvo4kiWi4zxojVTSr1Wy7BL_-HmIRlWTRAUmy_1RAJS19zn4BbSkxlV13Y9Bv3NoVcG01jKd4QoM172OXo2TqSU5v2B62i3-_CDZtf3CVgQIp9jiuxACcR5zg3w-4ewGfH4C3ospoKCuayyRaADLq0ThWLGaTQv9e7UjSfWAPir3XPXQut3mMRYrSiHcFNiEGeztSfF3cyhuvL2I5Lfh20yYuqW5j-w72BLnlqQGPuhJXJgH1_35XUCU8WtnkEK-qYX40ajDWJYa1s9_R-MWzF6Zwji2Gh5txOvxG3lZuIq9GSAOBp85617wB3eCGio6Nu3L9TwWXA 複製 token 然後儲存, 等等要進到顯示面板會用到。 執行以下指令來打開連線cloudkubecl proxy --port 8081 然後使用 Cloud Shell 網頁預覽功能來改變 port 到 8081: 我們將收到一串API endpoint, 要連結到面板, 將 /?authuser=0 移除,然後加上下面的 url:/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default 最終的 URL 看起來應該會像下面那樣：https://8081-dot-5177448-dot-devshell.appspot.com/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/#!/overview?namespace=default 然後你會被帶到一個網頁預覽 點選 Token radio 按鈕, 然後貼上剛剛拿到的 token, 然後點擊 Sign in 現在你可以享受 Kubernetes 圖形化顯示面板帶來的好處, 使用它來部署容器化應用, 以及監控和管理你的叢集。 你可以從主控台或是使用 Command-line 存取面板服務, Navigation menu &gt; Kubernetes Engine, 然後點擊 Connect 按鈕連接到我們想要連接的叢集 如果想要瞭解更多有關 Kubernetes 顯示面板的資訊, 參考文件 習題測驗 which of the following are features of the Kubernetes Engine? Identity and Access Management Integrated Logging and Monitoring None of these Stateful Application Support 恭喜你已經完成本教程！","link":"/zh-tw/Kubernetes/"},{"title":"使用 `Laravel` `template` 與 `blade`","text":"前言本篇為Laravel 的學習筆記，主要紀錄 Laravel blade 的用法，重點如下： 建立並重複使用 template 使用 yield 及 section 將值傳到 view {{ }} 幫我們做了什麼？ 建立 template 建立 template ，名為 layout ，如下&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; // 使用 yield 設定 title 的範圍，並將 Laracasts 設為預設值，若在頁面中沒有特別指定 title 的值時，會自訂套用預設 &lt;title&gt;@yield('title', 'Laracasts')&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Welcome&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/about\"&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/contact\"&gt;contact&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;// 使用 yield 設定區塊的範圍，範圍名稱為 content@yield('content')&lt;/body&gt;&lt;/html&gt; 使用 section 上面已經建立好了 template ，所以我們可以在新的頁面直接套用 template// 下面我們直接套用名為 layout 的 template@extends('layout')// 使用 section ， 在 template 中已經設定好的區塊，插入我們想要的元素。在 title 區塊插入新的值@section('title', 'Welcome Page')// 使用 section ， 在 content 區塊插入值@section('content') &lt;h1&gt;Welcome here&lt;/h1&gt;// 使用 endsection 來明確範圍@endsection 重複上面的操作，在多個新頁面上套用 template 將值傳到 view 要將值帶到 view 其實也很多種做法，以下列舉四種 1. Route::get(&apos;/&apos;, function () &#123; $task = [ &apos;Go to the school&apos;, &apos;Go to the market&apos;, &apos;Go to work&apos; ]; return view(&apos;welcome&apos;, compact(&apos;task&apos;) );&#125;); 2. Route::get(&apos;/&apos;, function () &#123; $task = [ &apos;Go to the school&apos;, &apos;Go to the market&apos;, &apos;Go to work&apos; ]; return view(&apos;welcome&apos;, [&apos;tasks&apos; =&gt; $task] ); Route::get(&apos;/&apos;, function () &#123; return view(&apos;welcome&apos;, [&apos;tasks&apos; =&gt; [ &apos;Go to the school&apos;, &apos;Go to the market&apos;, &apos;Go to work&apos; ]]);&#125;); Route::get(&apos;/&apos;, function () &#123; return view(&apos;welcome&apos;)-&gt;withTasks([ &apos;Go to the school&apos;, &apos;Go to the market&apos;, &apos;Go to work&apos; ]);&#125;); 以上四種做法， Ray 比較常用第一種。 在 view 接值 在 view 把剛剛傳過來的值取出，並顯示 @extends(&apos;layout&apos;)@section(&apos;title&apos;, &apos;Welcome Page&apos;)@section(&apos;content&apos;) &lt;h1&gt;Welcome here&lt;/h1&gt; &lt;ul&gt; @foreach ($tasks as $task) &lt;li&gt; &#123;&#123; $task &#125;&#125; &lt;/li&gt; @endforeach &lt;/ul&gt;@endsection 在Laravel 的 blade 檔案中，可以在 {{ }} 中使用變數 畫面如下： blade {{ }} 幫我們做了什麼？ {{ }} 除了可讓我們取得傳過來的變數之外，還自動執行了 PHP的 function htmlspecialchars ，防止有心人 XSS 攻擊。 做個實驗，使用blade:Route::get(&apos;/&apos;, function () &#123; $test = &apos;&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;&apos;; return view(&apos;welcome&apos;)-&gt;withTasks([ &apos;Go to the school&apos;, &apos;Go to the market&apos;, &apos;Go to work&apos; ])-&gt;withTest($test);&#125;); @extends(&apos;layout&apos;)@section(&apos;title&apos;, &apos;Welcome Page&apos;)@section(&apos;content&apos;) &lt;h1&gt;&#123;&#123; $test &#125;&#125;&lt;/h1&gt; &lt;ul&gt; @foreach ($tasks as $task) &lt;li&gt; &#123;&#123; $task &#125;&#125; &lt;/li&gt; @endforeach &lt;/ul&gt;@endsection 如上面的 code ，我們傳了有著 script tag 的 變數過去經由瀏覽器渲染出來後，如下： 再做個實驗，我們可以使用{!! !!} 來取消htmlspecialchars，慎用！@extends(&apos;layout&apos;)@section(&apos;title&apos;, &apos;Welcome Page&apos;)@section(&apos;content&apos;) &lt;h1&gt;&#123;!! $test !!&#125;&lt;/h1&gt; &lt;ul&gt; @foreach ($tasks as $task) &lt;li&gt; &#123;&#123; $task &#125;&#125; &lt;/li&gt; @endforeach &lt;/ul&gt;@endsection 瀏覽器渲染出來後，如下： 可以看到，該 script 真的被執行了 總結有關於blade的應用還有很多，之後會繼續更新。","link":"/zh-tw/LaravelView/"},{"title":"MongoDB 學習筆記","text":"前言一份未整理的 MongoDB 學習筆記 環境GCP Linux Ubuntu 19.04 安裝參考 官方文件 重啟sudo service mongod restart 登入無建立使用者mongo 有建立使用者mongo -u user -p password 設定檔位置ubuntuvim /etc/mongod.conf vim /lib/systemd/system/mongod.service MacOSvim /usr/local/etc/mongod.conf 說明書mongo --help 一般指令 顯示 database show databases 顯示 collections show collections 顯示使用者 use adminshow users 使用資料庫 use databaseName 刪除 user db.dropUser('User') 變更密碼 db.changeUserPassword('user', 'updatedPassword') 建立需驗證的 user參考文件 登入 mongo --host &lt;HOSTNAME&gt; --port &lt;PORT&gt; 切換到 admin 資料庫 use admin 建立 user db.createUser( &#123; user: \"superuser\", pwd: \"changeMeToAStrongPassword\", roles: [ \"root\" ] &#125;) 驗證 user 是否成功建立 show users 關閉 MongoDB server db.shutdownServer() 離開 exit 如果是用套件安裝，需要先更改設定。 編輯設定檔，並新增 uncomment security 欄位 vim /etc/mongod.conf 如下設定 security: authorization: enabled 重新啟動 MongoDB Server, dbPath 可以在設定檔裡面看到 vim /etc/mongod.conf ubuntu # Where and how to store data.storage: dbPath: /var/lib/mongodb journal: enabled: true MacOS systemLog: destination: file path: /usr/local/var/log/mongodb/mongo.log logAppend: truestorage: dbPath: /usr/local/var/mongodbnet: bindIp: 127.0.0.1security: authorization: enabled 執行下面指令重新啟動 mongod --dbpath &lt;path to data directory&gt; --auth &amp; 連接連接語法mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] mongodb://這是固定的格式，必須要指定。 username:password@可選項，如果設置，在連接數據庫服務器之後，驅動都會嘗試登陸這個數據庫 host1必須的指定至少一個host, host1是這個URI唯一要填寫的。它指定了要連接服務器的地址。如果要連接複製集，請指定多個主機地址。 portX可選的指定端口，如果不填，默認為27017 /database如果指定username:password@，連接並驗證登陸指定數據庫。若不指定，默認打開test數據庫。 ?options是連接選項。如果不使用/database，則前面需要加上/。所有連接選項都是鍵值對name=value，鍵值對之間通過&amp;或;（分號）隔開 讓外面可以連到資料庫 更改 IP 如下# network interfacesnet: port: 27017 bindIp: 0.0.0.0","link":"/zh-tw/MongoDB/"},{"title":"Linux 伺服器篇 - 學習筆記","text":"前言這是一份未整理過的 Linux Server 學習筆記內容參考出處： 鳥哥的 Linux 的私房菜 Internet 電腦網路組成 節點 (node) 是什麼？ 具有網路位址 (IP) 的設備, 如 PC、Linux Server Hub 算 node 嗎？ 不算, 因為它沒有 IP 伺服器主機 (server) 是什麼？ 就網路連線的方向來說，提供資料以『回應』給用戶的主機， 都可以被稱為是一部伺服器。 工作站 (workstation) 或用戶端 (client) 是什麼？ 任何可以在電腦網路輸入的設備都可以是工作站， 若以連線發起的方向來說，主動發起連線去『要求』資料的，就可以稱為是用戶端 (client)。 網路卡 (Network Interface Card, NIC)： 內建或者是外插在主機上面的一個設備， 主要提供網路連線的卡片 網路介面： 利用軟體設計出來的網路介面，主要在提供網路位址 (IP) 的任務。 一張網卡可以搭配幾個以上的網路介面？ 一個以上的網路介面；而每部主機內部其實也都擁有一個內部的網路介面，那就是 loopback (lo) 這個迴圈測試介面！ 網路形態或拓樸 (topology)： 各個節點在網路上面的連結方式，一般講的是物理連接方式。 舉例來說，上圖中顯示的是一種被稱為星形連線 (star) 的方式，主要是透過一個中間連接設備， 以放射狀的方式連接各個節點的一種形態，這就是一種拓樸。 網關 (route) 或通訊閘 (gateway)： 具有兩個以上的網路介面， 可以連接兩個以上不同的網段的設備，例如 IP 分享器就是一個常見的網關設備。 電腦網路區域範圍 網路的大小範圍主要區分為哪兩種？ 區域網路 (Local Area Network, LAN) 廣域網路 (Wide Area Network, WAN) OSI 七層協定 什麼是 OCI? Open System Interconnection OCI 有幾層？ 七層 實體層必須要定義什麼？ 所使用的媒體設備之電壓與訊號 實體層英文？ Physical Layer 為什麼實體曾要先定義所使用媒體設備之電壓與訊號？ 因為網路媒體只能傳送 0 與 1 這種位元串 實體層需要瞭解什麼的編碼方式？ 資料訊框轉成位元串的方式 OSI 模型中, 將上層東西打包放進下一層, 這個動作稱為？封裝 OSI 模型中, 實體層的大概職責？定義網路線材質, 連接器的類型, Pin 腳排列方式, 實體網路器材相關 OSI 模型中, 鏈結層的大概職責？定義了如何和直接連線的設備之間建立邏輯傳送路徑 (資料鏈結) 的方法, OSI 模型中, 網路層的大概職責？定義了和相同或不同的網路設備連線時, 如何選擇位址和路徑的方法 OSI 模型中, 傳送層的大概職責？定義了如何確實將資料送達接收端的方法 OSI 模型中, 會談層的大概職責？定義了如何建立與切斷傳送資料所使用的通訊路徑(連線) OSI 模型中, 表現層的大概職責？定義了如何將應用資料轉換為通訊所適用的型態 OSI 模型中, 應用層的大概職責？定義了如何根據不同的應用, 提供各種服務的方法 訊框(Frame)中的 FCS 全寫是什麼？Frame Check Sequence OSI 七層系統中, 當乙太網路收到網路層傳來的封包時, 會附加哪三樣資訊？ 前序 (Preamble) 標頭 (Header) 訊框檢查序列 (Frame Check Sequence) MAC 位址中, OUI 的全寫是什麼？Organizationally Unique Identifier MAC 位址中, 前三碼 Vendor ID 是由哪個組織頒發的？美國電子電機工程協會 (IEEE) MAC 位址中, 每幾個 bit 會隔開?8 bits MAC 位址中, 共有幾個區段？6 個 MAC 位址中, 共有幾 bit 組成?48 bits MAC 位址中, 每一個區段用多少進位的方式表示？16 進位 當 OSI 第三層 (網路層) 從第四層 (傳送層) 收到 segment 之後, 會做什麼事？附加 IP 標頭 集線器、交換器與相關機制 集線器 (hub) 以及交換器 (switch) 的差異？ 交換器內有一個特別的記憶體, 這個記憶體可以記錄每個 switch port 與連接的 PC 的 MAC 位址 如上圖, 假設每個 port 都擁有 10/100Mbps 的頻寬, 那當 A 與 D 都傳給 C 時, 會發生什麼事？ 等於 A 與 D 都需要搶 C 節點的 10/100Mbps 來用的意思。 什麼是全雙工 (full-duplex)? 如果兩端的 PC 同時支援全雙工時, 那表示 input/output 均可達到 10/100 Mbps hub 可以達到全雙工嗎？ 因為網路線腳位的關係, 無法使用共享媒體來達到全雙工的 switch 可以達到全雙工嗎？ 要有支援才行 什麼是 N-Way? auto-negotiation, 可自動的協調出最高的傳輸速度來溝通 是否需要分辨平行線與跳線？ 不需要, 因為 switch 若含有 auto MDI/MDIX 的功能, 會自動分辨網路線的腳位來調整連線的 網路線如果在門邊常常被門板壓, 導致變形, 會造成訊號衰減嗎？ 會哦 交換器會將哪兩項資訊記在 address table 裡？ 傳送端 LAN port 傳送端 MAC address 當接收端的 MAC address 還未被記錄在交換器的 MAC address table 時, 交換器會將訊框發給哪些對象？所有對象 封包的封裝IP 封裝的表頭資料： IP 封包可以達到多大？ 65535 bytes 如果 IP 封包比 MAC 還大, 那我們的作業系統會做什麼事？ 會對 IP 進行拆解的動作 上圖中的 Version (版本), 代表什麼意思？ 宣告這個 IP 封包的版本, 例如 IPv4 上圖中的 IHL, 代表什麼意思？ (Internet Header Length)(IP 表頭長度) 上圖中的 Type of Service, 代表什麼意思？ IP 封包的服務類型 IP 封包的服務類型的項目內容為？ PPPDARUU IP 封包的服務類型的項目內容 PPPDARUU, PPP 代表？ 此 IP 封包的優先度, 很少使用 IP 封包的服務類型的項目內容 PPPDARUU, D 代表？ 一般延遲(delay), 若為 1 表示為低延遲 IP 封包的服務類型的項目內容 PPPDARUU, T 代表？ 傳輸量 (throughput), 若為 1 表示為高傳輸量 IP 封包的服務類型的項目內容 PPPDARUU, R 代表？ 可靠度 (reliability), 若為 1 表示為高可靠度 IP 封包的服務類型的項目內容 PPPDARUU, UU 代表？ 保留尚未被使用 IP 封包中, Total Length(總長度) 代表什麼？ 指這個 IP 封包的總容量, 包括表頭與內容 IP 封包中, Identification (辨別碼) 代表什麼？ 識別這一個小 IP 封包是來自於哪一個大 IP 封包 IP 封包中, Flags (特殊旗標) 代表意義？ 代表封包是否分段, 是否為最後一個分段 IP 封包中, Flags (特殊旗標) 中, D 代表？ 0 可以分段, 1 不可分段 IP 封包中, Flags (特殊旗標) 中, M 代表？ 0 最後一段, 1 非最後一段 IP 封包中, Fragment offset (分段偏移) 代表意義？ 表示這個 IP 分段在原始 IP 封包中所佔的位置 透過 IP 封包中的哪些資訊, 就能夠將小 IP 分段在接收端組合起來？ Total Length, Identification, Flags, Fragment Offset IP 封包中, Time To Live (TTL, 存活時間), 是什麼？ 表示這個 IP 封包的存活時間 IP 封包中, Time To Live (TTL, 存活時間), 範圍為多少? 0-255 IP 封包中, Time To Live (TTL, 存活時間), 計算方法？ 當 IP 封包通過一個路由器, TTL 減一, 當 TTL 為 0, 封包將會被直接丟棄 IP 封包中, Protocol Number (協定代碼)是什麼？ 記載資料是屬於哪一種協定 IP 封包中, Header Checksum (表頭檢查碼) 是什麼？ 用來檢查這個 IP 表頭的錯誤檢驗之用 IP 封包中, Source Address 是什麼？ 來源的 IP 位址 IP 封包中, Destination Address 是什麼？ 目標的 IP 位址 IP 封包中, Options (其他參數）是什麼？ 這個是額外的功能，提供包括安全處理機制、路由紀錄、時間戳記、嚴格與寬鬆之來源路由等。 IP 封包中, Padding (補齊項目) 是什麼？ 每個 IP 資料都必須要是 32 bits, 若 Options 的資料不足 32 bits, 則由 padding 主動補齊 若以配送貨物來比喻 IP 封包, IP 標頭就好像什麼一樣？託運單 若以配送貨物來比喻 IP 封包, 乙太網路訊框就像是？宅配車 IP 位址的組成與分級 IP 的全寫？ Internet Protocol IP 其實是什麼？ 是一種網路封包 IP 是由幾個 bit 所組成？ 32個 IP 是由 32 個什麼單位組成？ bit 組成 IP 的 32 bit, 是幾進位？ 2 進位 我們將 IP 分成幾小段？ 4 小段 每小段的 IP 有幾 bit? 8 bits IP 最小到最大分別是多少？ 0.0.0.0 ~ 255.255.255.255 IP 又可分為哪兩個部分？ Net_ID (網域號碼) 與 Host_ID (主機號碼) 同一個網域的定義？ 在同一個物理網段內, 主機的 IP 具有相同的 Net_ID, 並且具有獨特的 Host_ID 什麼是物理網段？ 當所有的主機當是使用同一個網路媒體串在一起 同一個 Net_ID 裏頭, 可以具有相同的 Host_ID 嗎？ 不可 在同一個網段內, Net_ID 會變嗎？ 不會哦 Host_ID 在二進位的表示法中, 不可設置為哪兩種情況？ 同時為 0 或同時為 1 Host_ID 若全部為 0, 表示？ 整個網段位址 (Network IP) Host_ID 若全部為 1, 表示？ 廣播位址 (Broadcast IP) 上圖範例中, 可使用的主機 IP 範圍是？ 192.168.0.1 ~ 192.168.0.254 透過 CSMA/CD 傳遞資料的條件是？ 必須在同一個網段內 在同一個網段內, 如果要連結不同的網域, 要透過什麼？ 路由器 router InterNIC 將 IP 網段分成哪幾個等級？ A, B, C, D, E IP 等級中, 二進位的 class A 是？ 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx IP 等級中, 二進位的 class B 是？ 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx IP 等級中, 二進位的 class C 是？ 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx IP 等級中, 二進位的 class D 是？ 1110xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx IP 等級中, 二進位的 class E 是？ 1111xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx 能夠設定在一般系統上的, 只有哪三個等級的 IP? A, B, C IP 等級中, class D 的用途？ Multicast (群播), 通常用在大批電腦的網路還原 IP 等級中, class E 的用途？ 保留沒有使用 IP 的種類與取得方式 IPv4 當中, IP 有哪兩種類別？ public IP (公共 IP), private IP (私有 IP) IPv4 當中, 什麼是 public IP ? 經由 INTERNIC 所統一規劃的 IP，有這種 IP 才可以連上 Internet ； IPv4 當中, 什麼是 private IP ? 不能直接連上 Internet 的 IP ， 主要用於區域網路內的主機連線規劃。 private IP class A 範圍？ 10.0.0.0 - 10.255.255.255 private IP class B 範圍？ 172.16.0.0 - 172.31.255.255 private IP class C 範圍？ 192.168.0.0 - 192.168.255.255 私有 IP 的路由資訊可以對外散播嗎？ 不行 使用私有 IP 作為來源或目的地址的封包, 可以透過 Internet 轉送嗎？ 不行 關於私有 IP 的參考紀錄(如 DNS), 可以在 Internet 上使用嗎？ 不行 如果電腦沒有網卡, 可以測試伺服器環境運作狀況嗎？ 可以, 使用 localhost 內部迴圈的網段範圍？ class A 的 127.0.0.0/8 DHCP 全寫是什麼？ Dynamic Host Configuration Protocol DHCP 用途是什麼? 內部網路或網路服務供應商自動分配 IP 位址給用戶 IP 的三種取得方式？ 手動設定, 撥接取得, DHCP ISP 全寫是什麼？ Internet Service Provider Netmask, 子網路與 CIDR (Classless Interdomain Routing) Netmask (子網路遮罩) 的功能？ 將 Net_ID 以及 Host_ID 的界線切割出來 Host_ID 範圍內的第一個 IP 是什麼？ Network, 可以說是這個 IP 範圍的路徑 Host_ID 範圍內的最後一個 IP 是什麼？ Broadcast, 用來廣播用 要得到精確的 Host_ID, 需要哪兩項資訊？ IP 位址, Netmask 上圖的寫法又稱為？ CIDR 寫法 CIDR 全寫為？ Classless Interdomain Routing 路由概念 192.168.10.100/25 與 192.168.10.200/25 是否在同一個網域內？ 如果經過計算，會發現 192.168.10.100 的 Network 為 192.168.10.0 ，但是 192.168.10.200 的 Network 卻是 192.168.10.128，由於 Net_ID 不相同，所以當然不在同一個網段內！ 上圖中, 當 PC01 這部主機想要傳送資料到 PC11 時, 他的 IP 封包該如何傳輸？ 查詢目標 IP 封包的目標 IP 位址 查詢是否位於本機所在的網域之路由設定 查詢預設路由 送出封包至 gateway 後, 不理會封包流向 當主機想要傳送資料時, 第一個動作是？ 查詢本機路由表 (route table) 當主機想要傳送資料時, 發現目標 IP 與本機 IP 的 Net_ID 相同時(同一網域), 會怎麼做？ 直接透過區網功能, 將資料直接傳送給目的地主機 當主機想要傳送資料時, 發現目標 IP 與本機 IP 的 Net_ID 不同時, 會怎麼做？ 直接將 IP 封包送到預設路由器 (default gateway) 當主機送出封包後, 是否會追蹤封包流向？ 不會 網關 / 路由器的功能？ 負責在不同網域之間的封包傳遞 上圖中, 當 PC 01 要將封包傳送到 Server Bingo, 流程該是怎樣？ 依據自己的路由表，將該封包送到 Server A 去，Server A 再繼續送到 Server B ，然後在一個一個的接力給他送下去，最後總是可以到達 Server Bingo 的。 觀察主機路由： route 如何觀察主機自己的路由表？ route or route -n 上圖中, Destination 代表什麼？ Network 上圖中, Gateway 代表什麼？ 通往該 Destination 所需要的 Gateway, 若為 0.0.0.0 表示不需要額外的 IP 上圖中, Genmask 代表什麼？ Netmask 上圖中, Flags 代表什麼？ 多個旗標來表示網域或主機代表的意義 上圖中, Flags 為 U 代表什麼？ 代表該路由可用 上圖中, Flags 為 G 代表什麼？ 代表該網域須經由 Gateway 幫忙轉遞 上圖中, Flags 為 H 代表什麼？ 代表該路由為一部主機, 而非一整個網域 上圖中, iface 代表什麼？ Interface 上圖中, 共有幾個路由規則? 三個 上圖中, 第一欄顯示的是? 目的地網域 上圖中, 最後一欄顯示的是? 要去這個目的地要使用哪一個網路介面 上圖中, etho 是什麼? 網路卡裝置代號 上圖中, 假設我們要傳送的封包在路由規則裡面的 192.168.0.0/255.255.255.0 或者 127.0.0.0/255.0.0.0 裡面時，因為第二欄 Gateway 為*, 所以封包會怎麼樣？ 直接以後面的網路介面來傳送出去, 不透過 Gateway 上圖中, 萬一我們要傳送的封包目的地 IP 不在路由規則裡面, 會怎麼樣? 封包會被傳送到 default 的路由規則 IP 與 MAC：鏈結層的 ARP 與 RARP 協定 ARP 全寫是？ Address Resolution Protocol 網路位址解析協定 RARP 全寫是？ Reverse Address Resolution Protocol ARP 的作用？ 得到目標 IP 的實際網卡卡號 (MAC) 如何從一個區網內得知目標主機的 MAC? 主機會對整個區網發出 ARP 封包, 對方收到封包後就會回傳他們的 MAC 給我們 當使用 ARP 取得目標 IP 與它的網卡卡號之後, 主機會做什麼事？ 將該筆記錄寫進我們主機的 ARP table 當使用 ARP 取得目標 IP 與它的網卡卡號之後, 並將該紀錄寫進主機的 ARP table 之後, 資料會記錄多久？ 20 分鐘 如何取得自己的網卡卡號 in Linux？ ifconfig eth0 如何取得本機的 ARP table 資訊？ arp IP 是邏輯為止, 而 MAC 是實體位置, 是什麼將兩者聯繫起來？ARP 在封包的傳送過程中, IP 在不同網段內是否會改變？不會 在封包的傳送過程中, MAC 在不同網段內是否會改變？會 ICMP 協定 ICMP 全名是？ Internet Control Message Protocol 網際網路訊息控制協定 基本上, ICMP 的作用是？ 錯誤偵測與回報的機制 ICMP 是透過什麼來進行資料傳送的？ IP 封包 哪兩個簡單的指令是利用 ICMP 來檢驗網路的狀態？ ping, traceroute 可靠連線的 TCP 協定 TCP 全寫？ Transmission Control Protocol 網路層的 IP 封包, 跟此封包會不會被接受, 或有沒有正確的被接受, 有關係嗎？ 沒有 TCP 封包位於什麼內？ IP 封包 TCP 封包中有 Source port 跟 Destination port 嗎？ 有哦 TCP 封包中, 什麼是 Sequence Number (封包序號)? 由於 TCP 封包必須要帶入 IP 封包當中，所以如果 TCP 資料太大時(大於 IP 封包的容許程度)， 就得要進行分段。這個 Sequence Number 就是記錄每個封包的序號，可以讓收受端重新將 TCP 的資料組合起來。 TCP 封包中, 什麼是 Acknowledge Number (回應序號)? 確認 client 端有收到資料 TCP 封包中, 什麼是 Data Offset (資料補償)? 那個 Options 的欄位長度是非固定的，而為了要確認整個 TCP 封包的大小，就需要這個標誌來說明整個封包區段的起始位置。 TCP 封包中, 什麼是 Reserved (保留)? 未使用的保留欄位 TCP 封包中, 什麼是 code (Control Flag, 控制標誌碼)? 當我們在進行網路連線的時候，必須要說明這個連線的狀態，好讓接收端瞭解這個封包的主要動作 TCP 封包中, code (Control Flag, 控制標誌碼), 共有幾 bit? 6 bits TCP 封包中, code (Control Flag, 控制標誌碼), 共有幾個控制碼? 6 個 TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, 若為 1 時, 代表什麼? 啟動 TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, URG (Urgent) 代表什麼? 若為 1 則代表該封包為緊急封包， 接收端應該要緊急處理，且上圖當中的 Urgent Pointer 欄位也會被啟用。 TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, ACK (Acknowledge) 代表什麼? 若為 1 代表這個封包為回應封包， 則與上面提到的 Acknowledge Number 有關。 TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, PSH (Push function )代表什麼? 若為 1 時，代表要求對方立即傳送緩衝區內的其他對應封包，而無須等待緩衝區滿了才送。 TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, RST(Reset) 代表什麼? 如果 RST 為 1 的時候，表示連線會被馬上結束，而無需等待終止確認手續。這也就是說， 這是個強制結束的連線，且發送端已斷線。 TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, SYN(Synchronous) 代表什麼? 若為 1，表示發送端希望雙方建立同步處理， 也就是要求建立連線。通常帶有 SYN 標誌的封包表示『主動』要連接到對方的意思。 TCP 封包中, code (Control Flag, 控制標誌碼) 的控制碼, FIN(Finish) 代表什麼? 若為 1 ，表示傳送結束，所以通知對方資料傳畢， 是否同意斷線，只是發送者還在等待對方的回應而已。 TCP 封包中, Window (滑動視窗), 代表什麼？ 主要是用來控制封包的流量的，可以告知對方目前本身有的緩衝器容量 TCP 封包中, Window (滑動視窗), 當 Windows = 0 時, 代表什麼？ 代表緩衝器已經額滿，所以應該要暫停傳輸資料。 TCP 封包中, Window (滑動視窗), Window 的單位？ Byte TCP 封包中, Checksum(確認檢查碼), 檢查原理？ 當資料要由發送端送出前，會進行一個檢驗的動作，並將該動作的檢驗值標注在這個欄位上； 而接收者收到這個封包之後，會再次的對封包進行驗證，並且比對原發送的 Checksum 值是否相符，如果相符就接受，若不符就會假設該封包已經損毀，進而要求對方重新發送此封包！ TCP 封包中, Urgent Pointer(緊急資料), 是什麼？ 這個欄位是在 Code 欄位內的 URG = 1 時才會產生作用。可以告知緊急資料所在的位置。 TCP 封包中, Options(任意資料)? 目前此欄位僅應用於表示接收端可以接收的最大資料區段容量，若此欄位不使用， 表示可以使用任意資料區段的大小。這個欄位較少使用。 TCP 封包中, Padding(補足欄位)? 如同 IP 封包需要有固定的 32bits 表頭一樣， Options 由於欄位為非固定， 所以也需要 Padding 欄位來加以補齊才行。同樣也是 32 bits 的整數。 TCP 是連接導向還是非連接導向？ 連接導向 port 最大可達多少？ 65535 (2 的 16 次方) 假如 IP 是網路世界的門牌, 那麼 port 可以想像成什麼？ 該門牌號碼上建築物的樓層 小於 1024 的 port 要啟動時, 啟動者的身份必須是? root 特權埠口的範圍？ 小於 1024 的 port 哪裡可以查到每個 port 的已規範網路服務軟體 /etc/services 當 server 收到 client 端的請求後, 當 server 要回應給 client 時, 需回應給當初請求的 port 號口嗎？需要哦 TCP 的三向交握 三項交握的第一步驟 - 封包發起？ 當用戶端想要對伺服器端連線時，就必須要送出一個要求連線的封包，此時用戶端必須隨機取用一個大於 1024 以上的埠口來做為程式溝通的介面。然後在 TCP 的表頭當中，必須要帶有 SYN 的主動連線(SYN=1)，並且記下發送出連線封包給伺服器端的序號 (Sequence number = 10001) 。 三項交握的第二步驟 - 封包接收與確認封包傳送？ 當伺服器接到這個封包，並且確定要接收這個封包後，就會開始製作一個同時帶有 SYN=1, ACK=1 的封包， 其中那個 acknowledge 的號碼是要給 client 端確認用的，所以該數字會比(A 步驟)裡面的 Sequence 號碼多一號 (ack = 10001+1 = 10002)， 那我們伺服器也必須要確認用戶端確實可以接收我們的封包才行，所以也會發送出一個 Sequence (seq=20001) 給用戶端，並且開始等待用戶端給我們伺服器端的回應喔！ 三項交握的第三步驟 - 回送確認封包 當用戶端收到來自伺服器端的 ACK 數字後 (10002) 就能夠確認之前那個要求封包被正確的收受了， 接下來如果用戶端也同意與伺服器端建立連線時，就會再次的發送一個確認封包 (ACK=1) 給伺服器，亦即是 acknowledge = 20001+1 = 20002 囉。 三項交握的第一步驟 - 封包發起, 用戶端會隨機取得合乎哪個條件下的 port? 大於 1024 三項交握的第一步驟 - 封包發起, 在 TCP 表頭, 必須帶有哪些資訊？ SYN=1, Sequence number 三項交握的第二步驟 - 封包接收與確認封包傳送, 伺服器端若決定要接收封包, 會回傳哪些資訊？ SYN=1,ACK=1,sequence number,acknowledge number 三項交握的第二步驟 - 封包接收與確認封包傳送, 伺服器端若決定要接收封包, 回傳的 Acknowledge number 規則是？ 比 client 端的 sequence number 多 1 個號碼 非連接導向的 UDP 協定 UDP 的全寫是？ User Datagram Protocol 用戶資料流協定 UDP 協定中, 接收端在接收到封包之後, 會回應封包 (ACK) 給發送端嗎？ 不會 UDP 比較適合哪些使用情境？ 影像即時傳送軟體, 網路攝影機 封包上面通常都會具有哪四個基本的資訊 來源與目的 IP 以及來源與目的端的 port number 防火牆基本原理？ 進行封包表頭的分析，並且設定分析的規則，當發現某些特定的 IP 、特定的埠口或者是特定的封包資訊(SYN/ACK等等)，那麼就將該封包給他丟棄 DNS DNS 全寫 Domain Name System DNS 主機的 IP 位址設定在哪個檔案？ /etc/resolv.conf 若在本機沒有把 DNS 伺服器的位址設定好, 會變成怎樣？ 只能用 IP 上網 Hinet 最大的 DNS 伺服器？ 168.95.1.1 一組可以連上 Internet 的必要網路參數 一組合理的網路設定需要哪些資料？ IP, Network, Netmask, Broadcast, Gateway, DNS Network 以及 Broadcast 可以經由哪兩個資訊計算得來？ IP/Broadcast 如果是使用 ADSL 撥接上網的話, 可以經由哪里獲得資料？ ISP 如果是使用 ADSL 撥接上網的話, 資料會如何設定完成？ 自動設定完成 習題 在 ISP 提供的網路服務中，他們提到傳輸速度為 1.5M/382K ，請問這個數據的單位為何？ 數據單位為 bits/second, 與慣用的 bytes 差 8 倍。 連上 Internet 在 Linux 中, 預設的網卡代號為？ eth0 如何確認網路卡有被核心捕捉到？ dmesg | grep -in eth Linux 常用網路指令 上圖中, etho 代表什麼？ 就是網路卡的代號，也有 lo 這個 loopback 上圖中, HWaddr 代表什麼？ 就是網路卡的硬體位址，俗稱的 MAC 是也 上圖中, net addr 代表什麼？ IPv4 的 IP 位址 上圖中, Bcast 代表什麼？ Broadcast 上圖中, Mask 代表什麼？ Netmask 上圖中, inet6 addr 代表什麼？ 是 IPv6 的版本的 IP 上圖中, MTU 代表什麼？ Maximum Transmission Unit 上圖中, RX 代表什麼？ 那一行代表的是網路由啟動到目前為止的封包接收情況， packets 代表封包數、errors 代表封包發生錯誤的數量、 dropped 代表封包由於有問題而遭丟棄的數量等等 上圖中, TX 代表什麼？ 那一行代表的是網路由啟動到目前為止的封包傳送情況， packets 代表封包數、errors 代表封包發生錯誤的數量、 dropped 代表封包由於有問題而遭丟棄的數量等等 上圖中, collisions 代表什麼？ 代表封包碰撞的情況，如果發生太多次， 表示你的網路狀況不太好； 上圖中, txqueuelen 代表什麼？ 代表用來傳輸資料的緩衝區的儲存長度 上圖中, RX bytes, TX bytes 代表什麼？ 總接收、傳送的位元組總量 在 Linux 當中, 當我們連線到網路的速度慢時, 想要確認是我們自己網路環境有問題, 還是外部 Internet 有問題, 可以使用哪一個指令？ 可使用 traceroute 在 Linux 的 traceroute 指令, 可以更換測試的封包類型嗎？ 可以哦 在 Linux 中, 如果要下載指定 url 的檔案, 可以使用哪一個文字介面下載器呢？ wget 在 Linux 中, 若想要監聽封包可以使用哪一個指令？ tcpdump 網路安全與主機基本防護：限制埠口, 網路升級與 SELinux 網路封包進入主機的流程? Linux 中, 預設的防火牆有幾種機制？ 兩個 Linux 中, 預設的防火牆有哪兩種機制？ 1. 封包過濾式的 netfilter 防火牆2. 軟體控管的 TCP Wrapper 防火牆 Linux 中, 預設的防火牆 netfilter 是哪一個軟體提供的功能？ iptable Linux 中, 預設的防火牆 netfilter 是分析什麼來進行過濾的機制？ TCP/IP Linux 中, 預設的防火牆 netfilter 是分析 OSI 的哪幾層？ (2) 資料連結層(3) 網路層(4) 傳輸層 Linux 中, 預設的防火牆 netfilter 主要控制的是什麼？ MAC, IP, ICMP, TCP, UDP, PORT, 狀態(SYN, ACK...) 等 SELinux 的運作模式 SELinux 的順序？ 上圖中, 主體的意思是？就是程序 上圖中, 目標的意思是？檔案系統 上圖中, 政策的意思是？由於程序與檔案數量龐大，因此 SELinux 會依據某些服務來制訂基本的存取安全性政策。這些政策內還會有詳細的規則 (rule) 來指定不同的服務開放某些資源的存取與否。 Centos 提供的兩個 SELinux 的主要政策是？targeted：針對網路服務限制較多，針對本機限制較少，是預設的政策；mls：完整的 SELinux 限制，限制方面較為嚴格。 DNS FQDN 的全寫??Fully Qualified Domain Name DNS 的階層架構?? DNS 的最上層 server 為??., 又稱為 root DNS 中, 什麼是 TLD?Top Level Domains DNS 中, 什麼是 gTLD?Generic Top Level Domains DNS 中, 什麼是 ccTLD?Country Code Top Level Domains DNS 中, 最早由 root 管理的六大領域中, com 為？Company DNS 中, 最早由 root 管理的六大領域中, org 為？organisation DNS 中, 最早由 root 管理的六大領域中, edu 為？education DNS 中, 最早由 root 管理的六大領域中, gov 為？Government DNS 中, 最早由 root 管理的六大領域中, net 為？Network DNS 中, 最早由 root 管理的六大領域中, mil 為？Military DNS 中, 當我今天在瀏覽器輸入一個 domain name, 其具體步驟為何？ 如上圖, 當今天我在瀏覽器輸入一個 domain name, 第一步驟是？像 /etc/resolv.conf 檔案中的 DNS server 查詢 如上圖, 當 DNS Server 收到 Client 端的查詢請求時, 第一步驟會做什麼？查詢本身有沒有紀錄 如上圖, 當 DNS Server 收到 Client 端的查詢請求時, 如果 DNS Server 本身沒有紀錄, 會怎麼做？向 . (也就是 root) 做查詢 如上圖, 當 .(root) 收到 DNS Server 的查詢請求時, 會做什麼？告知 .tw 的位置 如上圖, 當 .tw 收到 DNS Server 的查詢請求時, 會做什麼？告知 .edu.tw 的位置 如上圖, 當 .edu.tw 收到 DNS Server 的查詢請求時, 會做什麼？告知 .ksu.edu.tw 的位置 如上圖, 當 .ksu.edu.tw 收到 DNS Server 的查詢請求時, 會做什麼？告知 www.ksu.edu.tw 的 IP 位置 如上圖, 當 DNS Server 查到該 DNS 的 IP 並回報 Client 之後, 會把紀錄存起來嗎？會哦 如何追蹤 DNS 查詢的過程？ dig +trace domain DNS 使用哪個 port?53 要讓你的主機名稱對應 IP 且讓其他電腦都可以查詢的到，有哪兩種方式？ 上層 DNS 授權領域查詢權，自己設定 DNS 伺服器 請上層 DNS 伺服器設定主機名稱對應 DNS 系統中, 從主機名稱查詢到 IP 的流程稱為?正解 dns lookup DNS 系統中, 從 IP 反解析到主機名稱的流程稱為?反解 reverse dns lookup DNS 系統中, PTR 的全寫是？PoinTeR DNS 系統中, PTR 的功用是？反解, 指向 resource DNS 系統中, 誰能夠設定反解？IP 的擁有人 DNS 系統中, 一部簡單的 DNS server 基本上要有兩個 zone, 哪兩個?hint: 紀錄 . 的 zone自己領域的正解 zone DNS 系統中, 如果有兩部以上的 DNS 伺服器, 會先搜尋到哪一台？不知道, 是隨機的 DNS server 中, Master 跟 Slave 的查詢優先權？先搶先贏 DNS server 中, Master/Slave 的同步又分成哪兩種方式? Master 主動告知 Slave 主動提出 DNS server 中, Master/Slave 的更新, 決定是否更新的要素是什麼？代表該資料庫新舊的序號 DNS server 中, Master/Slave 的更新, Master 主動告知的方式中, master 什麼時候向 slave 發請求？當 master 在修改了資料庫內容後 DNS server 中, Master/Slave 的更新, slave 主動告知的方式中, slave 什麼時候向 master 發請求？slave 會定時查看 master 資料庫的序號, 如果發現 master 的序號比較大, 就會開始更新 DNS 系統設定檔中, 有哪三個？ /etc/hosts /etc/resolv.conf /etc/nsswitch.conf DNS 系統設定檔中, /etc/hosts 的作用是？最早 hostname 對應 IP 的檔案 DNS 系統設定檔中, /etc/resolv.conf 的作用是？ISP 的 DNS server IP 紀錄處 DNS 系統設定檔中, /etc/nsswitch.conf 的作用是？決定先要使用 /etc/hosts 還是 /etc/resolv.conf 以下的 dig 指令查詢結果, QUESTION 代表什麼意思？顯示所要查詢的內容，因為我們是查詢 linux.vbird.org 的 IP，所以這裡顯示 A (Address)； 上圖中的 dig 指令查詢結果, ANSWER 代表什麼意思？QUESTION 查詢得到的結果 上圖中的 dig 指令查詢結果, AUTHORITY 代表什麼意思？哪一部 DNS server 所提供答案的 上圖中的 dig 指令查詢結果, 600 代表什麼意思？查詢者能夠保留這筆記錄多久的意思 (cache) DNS 系統中, cache-only 的伺服器中只有什麼檔案？只有 . root 的 zone file DNS 系統中, cache-only 的伺服器中有主機名稱以及 IP 正反解的檔案嗎？沒有 DNS 系統中, cache-only 的伺服器當收到查詢請求時, 會怎麼做？向 . root 查詢 DNS 系統中, cache-only 實際上只有哪兩種功能？cache搜尋 DNS 系統中, forwarding 伺服器有正反解的檔案嗎?沒有 DNS 系統中, forwarding 伺服器有 . root zone 檔案嗎?沒有 DNS 系統中, forwarding 伺服器收到請求時, 如何處理嗎?委託上一層查詢 什麼時候有架設 cache-only DNS 伺服器的需求？安全性需求 當我們使用 dig 來查詢 DNS 時, 如果主機名稱是全名, 務必在結尾加上什麼？. root 符號 以下的 SOA 輸出, ns-cloud-c1.googledomains.com.代表什麼？Master DNS 伺服器主機名稱 承上的圖片中, ns-cloud-c1.googledomains.com. 代表什麼？管理員的 email 承上, ns-cloud-c1.googledomains.com. 為什麼沒有 @ 符號？因為 @ 在資料庫檔案中是有特別意義的 承上的圖片中, 21600 代表什麼？更新頻率: 每隔多久時間, slave server sync master server 一次 承上的圖片中, 3600 代表什麼？失敗重新嘗試時間: 如果 slave sync master 失敗, 則將嘗試間隔時間縮短為 3600 秒, 直到成功之後才會變更為 21600 秒 承上的圖片中, 300 代表什麼？快取時間: 資料庫內沒有指定 TTL 的紀錄, 將使用這一項預設值 承上的圖片中, 259200 代表什麼？如果失敗了, slave server 會持續每 3600 秒嘗試一次, 持續 259200 秒, 如果過了這段時間依然沒有成功, 那 slave server 將不再繼續嘗試連線 承上的圖片中, 如果持續嚐試超過 259200 slave server 會做什麼事？刪除這份 zone file, 並停止嘗試連線 以下的圖片中, 2010080369 代表什麼意思？序號, 判別是否從 master server 上下載更新 DNS 系統中, 從網域的角度來看, 越右邊出現的名稱代表網域越大或越小？越大 DNS 系統中, 從 IP, 的角度來看, 越右邊出現的名稱代表網域越大或越小？越小 WWW Server Internet 中, WWW 是什麼的縮寫？World Wide Web 如果我要使用瀏覽器連接到 port 21 的 ftp, 我可以怎麼做？ftp://address 防火牆與 NAT 伺服器 廣義上的防火牆定義？能夠分析與過濾進出我們管理之網域的封包資料 網路技術中, NAT 的全寫是??Network Address Translation 網路技術中, NAPT 的全寫是??Network Address Port Translation 網路技術中, NAT 是以一對一還是多對一的方式轉換私人到公開的 IP??一對一 網路技術中, NAPT 是以一對一還是多對一的方式轉換私人到公開的 IP??多對一 網路技術中, 如果 NAPT 將多個私人 IP 轉換成一個公開 IP, 當 Server 回應請求時, NAPT 是如何辨別這一個公開 IP 當初是由哪一個私人 IP 所發出的？利用埠號 網路技術中, 什麼樣的技術可以將私人 IP 轉換成公開 IP?NAT, NAPT DevOps On-premise 的意思是？內部部署 DevOps 中, IaaS 的全寫是?Infrastructure as a Service DevOps 中, PaaS 的全寫是?Platform as a Service DevOps 中, Saas 的全寫是?Software as a Service 虛擬化軟體大致上又可分成哪兩種？ Bare-metal Hypervisor Hosted Hypervisor Bare-metal Hypervisor 需要先安裝作業系統嗎？不需要 Hosted Hypervisor 需要先安裝作業系統嗎？需要 伺服器的機櫃外型又分成哪三種？ 直立式 機架式 刀鋒式 什麼是 Appliance Server?專為特定的服務或功能而製造出來的伺服器 專用伺服器 (Appliance Server) 有什麼優點？ 導入門檻低 價格低廉 C/P 值高 專用伺服器 (Appliance Server) 有什麼缺點？ 無法做更細部的設定 無法升級部份硬體 NAS 的全寫是??Network Attached Storage 列印伺服器和一般網路印表機的差別是? 列印伺服器可預裝各種 OS 驅動程式, 並在有需要的時候發送驅動程式 可處理較大量需求 伺服器中, SSO 的全寫是??Single Sign On 伺服器中, SIP 的全寫是?Session initiation Protocol 伺服器中, SMTP 的全寫是?Simple Mail Transfer Protocol 傳送郵件的第一步, 會將郵件傳送到什麼地方？傳送端的 SMTP server 當傳送方的 SMTP server 收到使用者的郵件之後, 會採取什麼動作？向 DNS server 查詢, 解析 @ 後方的 domain, 獲得相對應的 IP 位址 當傳送方的 SMTP server 獲得相對應的 IP 位址後, 會採取什麼動作？傳送到接收端的 SMTP server 當接收方的 SMTP server 收到郵件之後, 會採取什麼動作?會根據 @ 郵件發往屬於該使用者位於 server 的信箱, 此處的信箱不是使用者電腦上的信箱 接收方的 SMTP server 是依據什麼將收到的郵件儲存到屬於該使用者位於 server 上的信箱？依據 @ 之前的使用者名稱 負責傳送郵件的伺服器有哪兩種？ SMTP server POP3 server SMTP 有哪兩種防護對策？ SMTP AUTH POP BEFORE SMTP POP3 server 的全寫是？Post Office Protocol Version:3 負責將郵件從位於 Server 的 user 郵箱傳送到使用者手上的 server 稱為？POP3 server 傳送郵件的伺服器中, 哪個負責推播 (push)？SMTP server 傳送郵件的伺服器中, 哪個負責拉播 (pull)？POP3 server POP3 server 的用途為？收到使用者 pull 請求後, 從使用者位於 server 的郵箱中, 取出使用者的信件, 傳送到使用者手上 APOP 的全寫是？Authenticated Post Office Protocol POP3S 的全寫是？Post Office Protocol over SSL 通常用以處理郵件收發的 server 上, 會同時安裝哪兩種郵件相關的 server? SMTP server POP3 server 何謂 symmetric-key algorithm？加解密都使用同一把金鑰 對稱加密的英文是？symmetric-key algorithm 公開金鑰加密的英文是？public-key cryptography 何謂 public-key cryptography？即非對稱加密, 利用 public 以及 private key 做加解密動作 public-key cryptography 的優點是？ 優點：傳送 key 給對方簡單 public-key cryptography 的缺點是？ 缺點：運算複雜, 效能負荷大 symmetric-key algorithm 的優點是？ 優點：加解密使用單一金鑰, 效能友善 symmetric-key algorithm 的缺點是？ 缺點：傳送 key 給對方要注意 SSL 融合了哪兩種加密方法？ Symmetric-key algorithm public-key cryptography SSL 最終使用哪一種加密方法？Symmetric-key algorithm SSL 在何處使用使用了 public-key cryptography?傳輸 symmetric key 時 SSL 中, CSR 的全寫是？Certificate Sign Request (簽證簽署請求) SSL 中, CA 的全寫是？Certificate Authority (憑證授權機構) SSL 的第一步, 當 Server 收到用戶端請求時, 會做什麼事？回傳公鑰, 以及含數位簽章的數位憑證 SSL 的第二步, 當用戶端收到 server 端的公鑰以及數位憑證之後時, 會做什麼事？會核對數位憑證, 若內容無誤, 則使用 server 公鑰加密共用金鑰的基礎資料, 並回傳 SSL 的第三步, 當 server 收到用戶端的公鑰以及共用金鑰的基礎資料後, 會做什麼事？進行解密, 並製作共用金鑰 Server 中, 何謂 CMS?Content Management System Server 中, 因應故障的技術在概念上主要分為哪兩種？ Redundancy Backup Server 中, 將多個實體網路卡整合為邏輯上單一網路卡的技術稱為？Teaming 網卡技術中的 Teaming, 在 Linux 中又稱為？Bonding 網卡中的 Teaming 技術, 較常使用的有哪兩種模式？ 平衡負載 容錯 網卡中 Teaming 技術的容錯模式優點是？故障排除較簡單 網卡中 Teaming 技術的容錯模式缺點是？還是只有一張網卡在運作, 無法提高通訊量 網卡中 Teaming 技術的平衡負載模式缺點是？因為不知道封包是從哪一張網卡出入的, 故障排除難度較高 網卡中 Teaming 技術的平衡負載模式優點是？可使用兩張網卡的通訊量, 通訊量大大提高 Server 中的 UPS 全寫為?Uninterruptible Power System Server 中的 UPS 有哪兩大功能？ 忽然停電時, UPS 可以繼續供電 當電壓忽高忽低時, UPS 可調節電壓 伺服器平衡負載技術主要分為哪三種? DNS route-robin (DNS 輪替式) Server Type Appliance Server Type 伺服器平衡負載技術中, 簡單解釋 DNS 輪替式?將一個 DNS 設定多組 IP 伺服器平衡負載技術中, 簡單解釋 Server Type?在一台 Server 上安裝平衡負載軟體, 並使用它來協調 伺服器平衡負載技術中, 簡單解釋 Appliance Server Type?使用專用型的平衡負載機器 提升安全策略中, 何謂 PDCA? Plan Do Check Action 防火牆一般來說分成哪四種？ 傳統型 UTM NGFW WAF 防火牆軟體中, UTM 的全寫是？United Threat Management (整合式威脅管理系統) 防火牆軟體中, NGFW 的全寫是？Next Generation Firewall (次世代防火牆) 防火牆軟體中, WAF 的全寫是？Web Application Firewall (網頁應用程式防火牆) 以下四種防火牆, 若要阻擋 VPN, 垃圾郵件, 過濾內容, 那哪一種較為適合？ Example: 傳統型 UTM NGFW WAF Answer: UTM 以下四種防火牆, 若要允許 Twitter, 拒絕 YouTube, 那哪一種較為適合？ Example: 傳統型 UTM NGFW WAF Answer: NGFW 以下四種防火牆, 若要簡單的依據來源以及目的 IP, port 來阻擋, 那哪一種較為適合？ Example: 傳統型 UTM NGFW WAF Answer: 傳統型 以下四種防火牆, 若要阻擋 CSRF, SQL injection, 那哪一種較為適合？ Example: 傳統型 UTM NGFW WAF Answer: WAF 網路上依據信任程度大致可分為幾大分區？ trust Zone Untrust Zone DMZ (De-Militarized Zone) WAN Zone (Wide Area Network Zone) Security zone 當中, DMZ 的全寫是？De-Militarized Zone Security zone 當中, WAN Zone 的全寫是？Wide Area Network Zone Security Zone 當中, trust zone 的簡單定義為？防火牆內, 不對外部網路公開 Security Zone 當中, untrust zone 的簡單定義為？防火牆外的區域 Security Zone 當中, DMZ 的簡單定義為？防火牆內, 但對外部網路公開的區域 Security zone 當中, WAN Zone 的簡單定義是？利用 VPN 等方式連接至其他據點的區域 防火牆系統中, IDS 的全寫是？Intrusion Detection System 防火牆系統中, IPS 的全寫是？Intrusion Prevention System 試描述防火牆系統中, IPS 以及 IDS 的簡單概念？會從通訊連線中偵測疑似不正常的行為, 並採取相對應的動作, 像是回報, 或是阻斷連線, 等等… 防火牆系統中, UTM 優點?多功能整合成一台, 維運較容易, 成本也較低 防火牆系統中, UTM 缺點? 效能負荷高 無法針對單一功能升級 防火牆中, 專用伺服器優點? 效能較穩定 可針對單一功能升級 防火牆中, 專用伺服器缺點? 成本較高, 因為每種功能都有其 Appliance Server 運維難度較高 Server 中, NTP 的全寫是？Network Time Protocol NTP Server 採用什麼協定？UDP NTP Server 中, stratum 的意思是？從標準時刻來源起算的網路距離 最上層 NTP Server 中, stratum 是多少？0 NTP Server 中, stratum 0, 1, 2 的 Server 之間的關係？？0 為 1 的上層 server, 1 為 2 的上層 server syslog server 的作用是？專門用來收集 Log syslog server 透過什麼協定來接受 log？syslog protocol Syslog server 整理列出 log 時, 主要會使用到 syslog 訊息內哪兩個欄位？ Facility Severity Syslog 訊息中, Facility 代表的意思是？該筆 log 的來源類型 Syslog 訊息中, Severity 代表的意思是？緊急程度或重要程度 Server 中, SNMP 的全寫是？Simple Network Management Protocol SNMP Server 中, MIB 的全寫是？Management Information Base SNMP Server 的主要功能是？ 監控效能 改變設定 故障偵測","link":"/zh-tw/LinuxForServer/"},{"title":"Stackdriver 快速開始","text":"概述本篇實作將告訴你如何利用Stackdriver來監看Google Compute Engine virtual machine instance，你也將安裝監看以及紀錄的服務在你的VM上，他們可以從你的instance上收集更多的資訊 前言本篇主要是利用Google的Qwiklab平台學習的同時，做的一份學習筆記, 一些專有名詞將不會被翻譯 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個Compute Engine Instance 在GCP主控台的控制面板， Navigation menu &gt; Compute Engine &gt; VM instance，然後點擊 Create￼ 照下面的資訊填入相對應的空格，無提到的空格內請保持預設值 Name: lamp-1-vm Region: us-central1 (Iowa)` Zone: us-central1-a Machine type: small (1 shared vCPU) Firewall: Select Allow HTTP traffic 點擊Create 安裝Apache2 Server 在主控台，點擊SSH來開啟一個連接此instance的terminal 在SSH視窗中，執行下面的指令來設定Apache2 sudo apt-get update sudo apt-get install apache2 php7.0 當詢問是否繼續y 如果你無法安裝php7.0，裝php5 sudo service apache2 restart 回到主控台，在VM instance的頁面，點選External IP處以連接到Apache2預設頁面 建立 Stackdriver 帳號 要使用 Stackdriver ，你的專案必須要在一個 Stackdriver 帳號內，接下的步驟將建立一個有試用期的 Stackdriver 帳號 (1) 在GCP主控台，點擊 Navigation menu &gt; Monitoring - 這將在一個新視窗開啟 Stackdriver，並顯示你的 Qwiklabs 專案。 點擊 Create workspace ![](https://i.imgur.com/0wwazU5.png) (2) 在接下來的頁面: - 加入 GCP 專案到 monitor ，你將看到你的專案顯示已勾選 ![](https://i.imgur.com/97vi3ch.png) - 點擊 Continue - 監看 AWS 帳號 - 略過設定 - 安裝 Stackdriver 監看代理 curl -sSO https://dl.google.com/cloudagents/install-monitoring-agent.sh sudo bash install-monitoring-agent.sh 安裝 Stachdriver 記錄代理curl -sSO https://dl.google.com/cloudagents/install-logging-agent.sh sudo bash install-logging-agent.sh 點擊 Continue 點擊 Launch monitoring 建立運行時間確認Uptime check 用以確認資源總是可以被存取，在此範例中，我們將建立一個 uptime check 來確認 Google 網頁正常運行中- 在 Stackdriver console 主控台，在控制面板上，點擊 Create an Uptime Check 按鈕。你也可以從左邊到 menu 中，找到 Uptime Checks &gt; Uptime Checks Overview ，然後點擊 Create an Uptime Check- 編輯 New Uptime Check ，加入以下資訊 - Title: Lamp Uptime Check - Check type: HTTP - Resource Type: Instacne - Applies to: Single, lamp-1-vm - Path: leave at default - Check every: 1 min如果 instance 沒有自動載入在我們寫則 “single” 之後，取消這次的 uptime check ，重新整理 Stackdriver 頁面，然後重新試一遍 點擊 Test 來確認我們的 uptime check 可以連結到資源 點擊 save ，當顯示所有的資源都已經可以連接 點擊 No thanks 來為這個 uptime check 建立一個警告政策 Uptime Check 的設置將會需要一些時間生效，我們繼續我們的進度，等等我們再來確認結果。讓我們先來建立一個警告政策。 建立一個警告政策利用 Stackdriver 來建立一個或多個的 alerting policies.從左邊的選單，點擊 Alerting &gt; Create a Policy ，然後設置 Conditions, Notifications, and Documentation 條件： 點擊 Add Condition 依照下面的資訊來設置空格處，如果沒有提到，請保留為默認值 Target: Resource Type: GCE VM Instance (gce_instance)Metric: Type &quot;network&quot; then select Network traffic ConfigurationCondition: is aboveThreshold: 500 bytesFor: 1 minute 點擊 Save Notifications: 選擇 Email Address ，然後輸入你的個人信箱地址 Documentation: 點擊 Add Documentation 然後新增一個訊息，這個訊息將會被包含在郵件警告中 Name this policy: Inbound Traffic Alert 點擊 save 我們已經建立一個警告了！在等待系統觸發警告的同時，建立一個控制面板和圖表，然後看一下紀錄 建立控制面板和圖表 左邊選單， Dashboards &gt; Create Dashboard 螢幕右上方，點擊 Add Chart 在 Find resource type and metric 區域，輸入 CPU ，然後選擇 CPU Load(1m). GCE VM instance 根據資源類型自動被選擇，圖表名稱自動命名，但如果你想要的話，你可以自訂命名 點擊 save 現在建立第二個圖表 在新的控制面板右上方的選單，選擇 Add Chart Find resource type and metric 欄位內輸入 Network ，選擇 Received Packets ，其餘欄位保持預設值，你可以在預覽區域看到圖表資料 點擊 save 重新命名新的控制面板，從 Untitled Dashboard 改成 Stackdriver LAMP Qwik Start Dashboard 檢視紀錄Stackdriver Monitoring 和 Stackdriver Logging 緊密地互相整合著 在Stackdriver 左手邊選單，點擊 Logging 來檢視紀錄 選擇 GCE VM instance &gt; lamp-1-vm 在第一個下拉選單 從第二個下拉選單選擇 syslog，然後點擊OK 其餘欄位保留預設 選擇 Start streaming logs 圖案 可以看到這個 VM instance 的 logs 現在來看看，當我們開始跟結束時，會發生什麼事 點擊並拖曳 Logs Viewer brower 視窗，所以 Compute Engine console 和 Stackdriver Logging console 會並排 在主控台內，VM instance 視窗，點擊 lamp-1-vm instance 在 VM instance details 視窗，於螢幕上方點擊 Stop，然後確認停止 instance ，這會需要幾分鐘，我們來看 log messages 我們可以看著 Logs View 視窗，然後看VM什麼時候被結束 在 VM instance detail 視窗，在螢幕最上方點擊 Start，然後確認。這會需要幾分鐘的時間，我們可以檢視 log 訊息 確認 uptime check 結果以及警告觸發 在 Stackdriver 左邊區域，點擊 Uptime Checks &gt; Lamp Uptime Check 。這將顯示 uptime check 的細節，包含等待時間， uptime 百分比，區域結果以及設定檢查。如果你看到的 Location result 是 “No checks have run yet” ，那請等待幾分鐘，然後重新整理頁面 左方區域點擊 Uptime Checks &gt; Uptime Checks Overview ，這將提供所有運行中的 uptime checks ，包含網站在不同區域的狀態 確認警報是否有觸發 在 StackDriver 主控台，左方頁面點擊 Alerting &gt; Incidents ，如果你沒有看到開啟的事件，請確定一下你在看的是 RESOLVED 頁面 依然在 Stackdriver 主控台，點擊 Alerting &gt; Events ，你應該會看到一個事件列表 確認一下我們的 email 帳號，應該會收到警報 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： Stackdriver supports which of the following cloud platforms / Stackdriver 支援以下哪種雲端平台? Google Cloud Platform Azure Amazon Web Services","link":"/zh-tw/Stackdriver/"},{"title":"使用 Laravel 儲存並重新縮放圖片大小","text":"前言本篇為實際上使用Laravel，以及套件Intervention來儲存及重新修改圖片尺寸的學習筆記。 安裝套件Intervention安裝流程請參照 Intervention GitHub官網composer require intervention/image 打開config/app.php, 在array $providers 裏頭加上Intervention\\Image\\ImageServiceProvider::class 在array aliases裏頭加上&apos;Image&apos; =&gt; Intervention\\Image\\Facades\\Image::class 建立上傳資料夾與storage資料夾的連結 依照官網說明建立連結 在terminal輸入 php artisan storage:link 連結之後，project/storage/app/public 會跟 project/public/storage這兩個資料夾就回相連。 如果你是要儲存檔案，請儲存到project/storage/app/public/(anySubdirectoryYouWant) 如果你是要提供外部存取的URL，請使用project/public/storage/(anySubdirectoryYouWant)/fileName，因為對外部來說，預設可存取資料夾為public，所以直接使用asset(&#39;storage/(anySubdirectoryYouWant/fileName)&#39;) 驗證圖片是否有被帶進來// 因為我們不需要太多的東西，只需要request array裡頭的東西$parameters = request()-&gt;all();if (request()-&gt;hasFile('image'))&#123; // 檔案存在，所以存到project/storage/app/public，並拿到url，此範例會拿到public/fileName $imageURL = request()-&gt;file('image')-&gt;store('public'); // 因為我們只想要將純粹的檔名存到資料庫，所以特別做處理 $parameters['image'] = substr($imageURL, 7);&#125; 重新縮放圖片大小 要縮放大小，所以會需要使用到套件intervention 在namespace下加上use Intervention\\Image\\ImageManagerStatic as Image; // 拿到剛剛存進DB的item實例$item = Item::update($parameters);// 設定driverImage::configure(array('driver' =&gt; 'gd'));// 如果我們dd (storage_phth)，我們將會得到'project/storage/'，但這不是我們要的// 所以我們在後面加上'app/public/，如上所敘，這是內部儲存的資料夾位址// 請注意，當我們重新縮放圖片大小，目標都是我們的內部資料夾// 並且，再重新縮放之後，也是要存到同樣的地方Image::make(storage_path('app/public/' . $item-&gt;image))-&gt;resize(300, 300)-&gt;save(storage_path('app/public/' . $item-&gt;image)); 刪除圖片(如果使用者要求)if ($request-&gt;imageDelete == true)&#123; Storage::delete($item-&gt;images); $item-&gt;update(['images' =&gt; null]);&#125; 產出可存取資源的URL// 當產出公開存取的URL，它必須要是外部存取位址return asset(&apos;storage/&apos; . $parameters[&apos;image&apos;]);","link":"/zh-tw/UploadAndResizeImagesWithLaravel/"},{"title":"利用 Hexo 來建立一個 多語系 部落格","text":"前言這幾天為了建立一個個人部落格，真是沒少折騰了！個人除了對程式分享有熱愛之外，對語言也很有愛，像是英日語等等，所以一直以來，就想建一個多語系的部落格，除了可以讓分享的受眾更廣之外，另一方面也可以強制練習自己的語言！在請教 Google 大神無數次之後，大概歸納出以下三種可行的方法： 利用 i18n ，再透過修改源碼的方式建兩個站點，一個中文，一個英文利用 Hexo 的 minos 主題在花了一些時間研究之後，毅然決然的選擇第三種，原因如下：原本我是使用 Hexo 的 Next 主題，可惜該主題在這方面並沒有支援，需要特別去修改源碼。這代表，維護成本會相當可觀，每修改一個地方，就需要修改兩份檔案，看你有幾種語言就得修改幾份檔案 所以，本篇會針對 Hexo 的 minos 主題來做分享 安裝 Hexo 安裝 NodeJS ，會連帶安裝 npm 套件管理器 brew install node 透過 npm 安裝 Hexo 主程式 npm install hexo-cli -g 在指定資料夾內，建立一個 Hexo 網站需要的檔案 hexo init folderName 安裝 minos 主題 進到資料夾 cd folderName 從官方 GitHub上clone https://github.com/ppoffice/hexo-theme-minos.git themes/minos 原始資料夾，預設只有 _config.yml.example ，所以 copy 或 rename 為 _config.yml ，並於檔案中，搜尋 theme ，並設為 minos 開始配置配置 Hexo 配置檔 config(配置檔)又分為 Hexo 本身的，以及主題的，以下先針對 Hexo 配置檔做說明，以下為必要設定的選項，其餘都維持預設即可: language: [&apos;en&apos;, &apos;zh-tw&apos;] //這邊的配置，表示默認以English語系為主，並以Taiwan語系為輔 url: https://tn710617.github.io/ (此為你的網站地址) permalink: :title/ deploy: type: git repo: https://github.com/tn710617/tn710617.github.io.git (此為你在GitHub上的資料夾clone地址) branch: master 主題配置檔內的設定都跟多語系無直接關係，所以這邊不特別做說明，大家依照官方文件以及個人喜好設定完成即可。 配置網頁語系檔 配置完 Hexo 的配置檔後，我們需要先新建一個自己國家的語系檔，如果主題內原本就已經有的話就不必，以本篇例子來說，我需要一個 Taiwan 語系，但是主題內的配置沒有，所以我必須要自己建一個。這個檔案的功用為，當切換到指定語系時， Hexo 會去讀指定語系的配置檔，就是這個檔案，並且依照這個語系檔裡面的內容來顯示 到 minos 的 languages 資料夾內，新建一個檔名為zh-tw.yml的檔案 內容可以比照其他國家的格式，如下：name: &apos;繁體中文&apos;common: archives: &apos;歸檔&apos; category: &apos;分類&apos; tag: &apos;標籤&apos; categories: &apos;分類&apos; tags: &apos;標籤&apos;nav: next: &apos;下一頁&apos; prev: &apos;上一頁&apos; search: &apos;搜尋&apos; toc: &apos;目錄&apos;article: read_more: &apos;點擊閱讀&apos; read: &apos;讀完&apos; about: &apos;大概&apos; words: &apos;字&apos; comments: &apos;留言&apos; contents: &apos;目錄&apos;search: hint: &apos;站內搜尋&apos;insight: hint: &apos;站內搜尋&apos; posts: &apos;文章&apos; pages: &apos;頁面&apos; categories: &apos;分類&apos; tags: &apos;標籤&apos; untitled: &apos;(無標題)&apos; 配置主題下的語系導向檔案 語系檔設定完成後，複製這個主題配置檔，並創立另外兩份配置檔。這幾個檔案的作用為，當我們切換到指定語系，網頁會依照這個檔案內配置的路徑來開啟相對應的檔案，比方說，中文開中文的檔案，英文開英文的檔案。 _config.zh-tw.yml _config.en.yml 先針對’en’配置檔做以下配置： // 這邊的配置可以依照個人需求menu: Archives: /archives Categories: /categories Tags: /tags Schedule: /schedule About: /about Friends: /friends 再來針對’zh-tw’配置檔做以下配置： menu: 歸檔: /zh-tw/archives 分類: /zh-tw/categories 標籤: /zh-tw/tags 行程: /zh-tw/schedule 關於: /zh-tw/about 好友: /zh-tw/friends 大家可能會注意到，這三個檔案內有著重複的配置。規則是這樣的，當我們切換到該語系的網頁時，默認會套用該語系的配置檔裡頭的配置，若該語系配置檔裡頭沒有這個配置，會自動套用主題原本的配置檔裡面的配置，所以這邊可以很靈活的針對不同語系的網頁來做配置調整。 view檔案的配置 現在我們開始針對view的檔案來做配置， minos 的規則是，除了源碼以及主體架構之外，所有的檔案根據語系的數量來配置，簡單來說，有幾種語系，該檔案就要有幾份。這也很合理，不然透過機器翻譯的文章你敢貼出來嗎？ 現在開始針對source底下的檔案來做配置: _posts上圖應該不會很難理解吧？ 簡單來說，_posts資料夾下面放的，是默認語系的檔案，以本篇例子來說，就是英文語系。而在_posts資料夾下面，建立一個名為zh-tw的資料夾，裡頭放著自然是中文語系的檔案 其他的：檔案配置就跟上圖一樣，是不是簡單到言語無法形容了？ 語言切換選單位置調整以我個人來說，當我進到一個網頁，如果密密麻麻的都是我看不懂的語言，我希望我第一個可以找到的就是語言切換的按鈕（如果有的話啦），以目前Ray使用的minos主題版本來說，切換語言的選單默認是在最下面的，所以我希望把它調整到一個顯眼的地方 到footer.ejs中，找到以下的代碼 &lt;%- partial('common/languages') %&gt; 把它剪下之後，貼到navbar.ejs檔案的最下方&lt;/body&gt;上面 如果現在從今整理頁面，應該已經可以看到語言切換選單已經換到上頭去了！可是呢… 怎麼是向上開啟選單的ＸＤ，根本無法選啊！所以我們還要再做一些調整。找到layout裡頭的languages.ejs檔案，並在裡頭找到下面這一行，並加入style=&quot;top:100%&quot; &lt;div class=&quot;dropdown-menu has-text-left&quot; role=&quot;menu&quot; style=&quot;top:100%&quot;&gt; 結語照著上面配置，大概就可以實現雙語系網站了，效果可以看看我的 blog 若有說的不對的地方，歡迎指教歡迎轉載，但請註明出處，謝謝！","link":"/zh-tw/buildABilingualBlog/"},{"title":"Node.js 學習筆記","text":"前言這是一份未整理的 Node.js 學習筆記 正文安裝 在 CentOS 7 上安裝 Node.js 和 NPMNodeSource 是一家致力於提供企業級Node 支持的公司，他們為Linux 發行版維護一致更新的Node.js 軟件倉庫。要從CentOS 7 系統上的NodeSource 軟件倉庫安裝Node.js 和npm ，請按照下列步驟操作： 添加NodeSource yum 軟件倉庫Node.js 的當前LTS 版本是10.x 版。如果你想安裝的版本8 只吧下面的命令中setup_10.x 更改為setup_8.x 。運行以下curl命令將NodeSource yum軟件倉庫添加到您的系統： curl -sL https://rpm.nodesource.com/setup_10.x | bash - 安裝Node.js 和npm啟用NodeSource 軟件倉庫後，通過以下命令安裝Node.js 和npm ： yum install nodejs 驗證Node.js 和npm 安裝 node -v npm -v 如何使用NVM 安裝Node.js 和npmNVM （Node 版本管理器）是一個bash 腳本，用於管理多個活動的Node.js 版本。NVM 允許我們安裝和卸載任何特定的Node.js 版本，這意味著我們可以擁有任何數量的Node.js 版本供我們使用或測試。curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash &amp;&amp; export NVM_DIR=\"$HOME/.nvm\" &amp;&amp; [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" &amp;&amp; [ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" 參考資料來源 要在CentOS 系統上使用NVM 安裝Node.js 和npm ，請按照下列步驟操作： 使用 fs module fs.writeFileSyncconst fs = require(&#39;fs);在 Node.js 裏頭，如果要引用一個 module ，要用一個變數引用，然後之後就可以使用它例如fs.writeFileSync('hello.txt', 'Hello fromNode.js'); 上面的 function ，是將 Hello fromNode.js 寫進 hello.txt 這個檔案### 建立一個最簡單的 server首先，我們先引用 `http` module，當我們要調用本地 module 時，我們可以指定路徑，像是 `./http` ，但我們要調用 global 的 module 時，我們不加任何路徑， 如下```javascriptconst http = require(&apos;http&apos;); 接下來，我們利用剛剛引用的 http module 來建立一個 server ，如下：const server = http.createServer((req, res) =&gt; &#123; console.log(req);&#125;); orconst server = http.createServer(function(req, res)&#123; console.log(req);&#125;); or function rqListener(req, res) &#123; console.log(req);&#125;const server = http.createServer(rqListener); 最後，我們雖然已經建立了 server ，但是我們還沒有指定它的位址。 我們指定 3000 port 給這個 server ，如下：server.listen(3000); 此時，我們可以從瀏覽器，輸入 localhost:3000 來拜訪這個 server 停止這個 loopconst http = require('http');const server = http.createServer((req, res) =&gt; &#123; console.log(req); process.exit();&#125;);server.listen(3000); 從 request 中取得我們想要的資訊舉例來說，我們要取得 url , method , 以及 header 三項資訊，如下：const http = require('http');const server = http.createServer((req, res) =&gt; &#123; console.log(req.url, req.method, req.header); // process.exit();&#125;);server.listen(3000); 下圖，我們可以看到我們特別指定的三項資訊: 設定 response我們可以在 server 中，指定 response ，如下：const http = require('http');const server = http.createServer((req, res) =&gt; &#123; console.log(req.url, req.method, req.header); // process.exit(); res.setHeader('Content-Type', 'text/html'); res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); res.end();&#125;);server.listen(3000); 然後打開開發者工具，我們可以看到我們剛剛設定的 header 然後 response 的地方可以看到我們剛剛設定的 response 簡易的 request routing我們可以指定觸發特定 response 的 url ，當 client 呼叫這個 url 時，就會觸發我們指定的 response ，反之，則觸發另外的 response const http = require('http');const server = http.createServer((req, res) =&gt; &#123; const url = req.url; if (url === '/') &#123; res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;form action=\"/message\" method=\"post\"&gt;&lt;input type=\"text\" name=\"message\"&gt;&lt;button type=\"submit\"&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); return res.end(); &#125; res.setHeader('Content-Type', 'text/html'); res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); res.end();&#125;);server.listen(3000); 由上面的 code 可以看到，我們指定 req.url 必須要絕對等於 / 才會觸發條件內，我們指定的 response 如下： 當我們按下 send ，會執行 post method, action /message ，如下： 因為 action 的關係，會嘗試拜訪 message url ，而因為這個 url 並不符合我們設定的條件，所以會執行預設 response 簡單的 redirect request現在，我們要簡易的 redirect 我們的 request ，如下：const http = require('http');const fs = require('fs');const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const method = req.method; if (url === '/') &#123; res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;form action=\"/message\" method=\"post\"&gt;&lt;input type=\"text\" name=\"message\"&gt;&lt;button type=\"submit\"&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); return res.end(); &#125; if (url === '/message' &amp;&amp; method === 'POST') &#123; fs.writeFileSync('message.txt', 'DUMMY'); res.statusCode = 302; res.setHeader('Location', '/'); return res.end(); &#125; res.setHeader('Content-Type', 'text/html'); res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); res.end();&#125;);server.listen(3000); 從上面的 code 可以看到，我們新增了第二個 if statement。如果 url 等於 //message 以及 method 等於 post ，雙重條件都符合之下，就會觸發我們設定的條件我們使用了之前我們曾經使用的 fs module ，如果條件觸發，我們就會將 DUMMY 寫入一個叫做 message.txt 的檔案接著回傳 status code 302最後回導到 /在 res.end() 之後，我們不可以在 define 新的 res ，否則就會出現錯誤，因為這邊我們要使用 return ，後續的代碼就不會再執行 Parsing request bodies本章節，我們將解析 request 裡頭的 body 資料並且初次接觸到了 stream 以及 buffer 的概念。首先，我們先設定一個事件。 當接收到 data 時，觸發一個 function 並且帶入 chunk ， chunk 是資料的最小單位。接著我們使用了 console.log 來把 chunk 印出來！同時，我們建立一個 body 常數 array ，並且將每一次觸發 data 事件時，我們都將 chunk 丟到這個 array 裏頭， 代碼如下：const body = [];req.on('data', (chunk) =&gt; &#123; console.log(chunk); body.push(chunk);&#125;); 接著，我們在建立一個事件，當 request 接收完成，我們在定義一個常數，叫做 parsedBody ， 至於這個常數的內容，我們使用 buffer 物件，來將 body array 裡頭的 chunk 都串起來，然後轉換成 string 。最後，我們使用 console.log 把常數 parsedBody 印出來，代碼如下：req.on('end', () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); console.log(parsedBody);&#125;); 結果如下： 接下來，我們在定義一個常數 message ，它的內容是用 ‘=’ 來將常數 parsedBody 分隔，變成一個 array ，然後我們取 [1] ，就是 array 中的第二項資料。然後，我們將這個常數 message 一方面利用 console.log 印出來，一方面利用 fs module 來寫到一個叫做 message.txt 的檔案中。代碼如下：req.on('end', () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split('=')[1]; console.log(message); fs.writeFileSync('message.txt', message);&#125;); 至此, 此 episode 告一段落，最後全部的 code 如下：const http = require('http');const fs = require('fs');const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const method = req.method; if (url === '/') &#123; res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;form action=\"/message\" method=\"post\"&gt;&lt;input type=\"text\" name=\"message\"&gt;&lt;button type=\"submit\"&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); return res.end(); &#125; if (url === '/message' &amp;&amp; method === 'POST') &#123; const body = []; req.on('data', (chunk) =&gt; &#123; console.log(chunk); body.push(chunk); &#125;); req.on('end', () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split('=')[1]; console.log(message); fs.writeFileSync('message.txt', message); &#125;); res.statusCode = 302; res.setHeader('Location', '/'); return res.end(); &#125; res.setHeader('Content-Type', 'text/html'); res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); res.end();&#125;);server.listen(3000); 了解事件驅動代碼的執行本章節介紹了事件驅動代碼的執行規則以及順序舉例來說，如果我們對目前的代碼做了一些調整，如下:req.on('end', () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split('=')[1]; fs.writeFileSync('message.txt', message); res.statusCode = 302; res.setHeader('Location', '/'); return res.end();&#125;); 首先，在一開始我們就引用了 http module 以及 fs module ，然後我們利用 http module 來建立一個 server ，並且讓這個 server 聽 3000 port 。當有任何 requets 呼叫這個 server 時，都會觸發這個 server 。我們帶入 request 以及 response ， 在 server 內可以用。首先，我們定義發請求的 url 為常數 url ， 再來，我們定義發請求的方法為常數 method如果常數 url 等於 / 時，會觸發一系列的 response ，並且 return res.end(); 做結束。如果常數 url 等於 /message 且常數 method 等於 POST 的話，定義常數 body 為 array。接下來進入事件驅動, 當開始解析 request 時，我們帶入 chunk ，印出 chunk ，並且將 chunk 放入一個叫做 body 的 array 常數另外一個事件，當 request 解析完成後， 定義一個常數叫做 parsedBody ，它是利用 buffer 物件來將在常數 body 內的所有 chunk 串連起來，然後變成 string在定義一個常數叫做 message ， 首先， 常數 parsedBody 是一個 string ，我們將這個 string 用 = 為分隔點，將這個 string 變成 array 之後，取 [1] ，就是這個 array 的第二項資料，這個就是常數 message 的值接下來，我們利用一開始引用的 fs module ， 將常數 message 的內容寫入一個叫做 message.txt 的檔案。接下來，定義 response 的 status code 為 302定義 response 跳轉的 location 為 /最後， return res.end(); 出了事件驅動之後，是定義 header ，然後定義另外一些 html 的 response ， 最後是 res.end(); Server 內的執行部分到此做一個結尾。 由於 js 的事件驅動屬性，事件 end 並不會先被執行，反之，後面的代碼會先被執行。所以這個更動會造成一個錯誤，那就是當 res.end(); 已經被執行了，才開始執行 end 事件內的 setHeader 以及 statusCode ，這樣就會造成如下的錯誤 如果，我們在 end 事件之下加了 return ，那錯誤就不會出現 ， 修改代碼如下：req.on('end', () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split('=')[1]; fs.writeFileSync('message.txt', message); res.statusCode = 302; res.setHeader('Location', '/'); return res.end();&#125;);return; 因為 end 事件之下的 res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;); 就不會被執行了。注意！ 在 return 的當下，其實 end 的監聽事件是還沒有被執行的，但是當 server 裡頭的動作執行完畢之後， request 被解析完成，觸發了 end 的監聽事件，然後才開始執行這個事件裡頭的動作。 至此，此 Episode 告一段落，截至目前的完整程式碼如下：const http = require('http');const fs = require('fs');const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const method = req.method; if (url === '/') &#123; res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;Enter Message&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;form action=\"/message\" method=\"post\"&gt;&lt;input type=\"text\" name=\"message\"&gt;&lt;button type=\"submit\"&gt;Send&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); return res.end(); &#125; if (url === '/message' &amp;&amp; method === 'POST') &#123; const body = []; req.on('data', (chunk) =&gt; &#123; console.log(chunk); body.push(chunk); &#125;); req.on('end', () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split('=')[1]; fs.writeFileSync('message.txt', message); res.statusCode = 302; res.setHeader('Location', '/'); return res.end(); &#125;); return; &#125; res.setHeader('Content-Type', 'text/html'); res.write('&lt;html&gt;'); res.write('&lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;'); res.write('&lt;body&gt;&lt;ht&gt;Hello from my NOde.js Server&lt;/ht&gt;&lt;/body&gt;'); res.write('&lt;/html&gt;'); res.end();&#125;);server.listen(3000); Blocking and Non-Blocking Code所以，fs.writeFile 跟 fs.writeFileSync 差在哪？fs.writeFileSync 會待這個檔案寫入的任務完成之後，才會繼續向後執行，而 fs.writeFIle 會異步執行，儘管檔案寫入的任務還沒完成，程式一樣會繼續向後執行，並且，我們可以在任務完成時執行一項 callback ，修改代碼如下： req.on('end', () =&gt; &#123; const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split('=')[1]; fs.writeFile('message.txt', message, (err)=&gt;&#123; res.statusCode = 302; res.setHeader('Location', '/'); return res.end(); &#125;);&#125;); 從以上的代碼來看，當程式執行到寫入檔案那一行， fs.writeFile ，程式不會停下來等待 fs.writeFile 執行完畢，反之，程式會繼續往下跑 ， 而當 fs.writeFile 執行完畢後，會觸發我們設定的 callback ，進而執行以下的代碼res.statusCode = 302;res.setHeader('Location', '/');return res.end(); 簡述事件迴圈本章節主要參閱官方文件 ， 以及這位大大的文章 。在本章節中，主要是搞懂 Node.js 中事件迴圈的概念。 Node.js 的架構圖 上圖可以看到，除了 V8 Engine ， Node.js 使用了 libuv 來處理 I/O 的部分，提供了 asynchronous 以及 Non-Blocking API 以及事件迴圈 ， 下面提到的事件迴圈，主要與 libuv 有關。 什麼是事件迴圈？事件迴圈，藉由將工作量分擔給 Kernel 來處理，使 Node.js 得以做非阻塞 I/O 的操作，儘管 JsvaScript 是單線程的。 因為目前新型的 Kernel 都是多線程的，它們可以在背景運行多個程序。當其中一個程序完成了， Kernel 會通知 Node.js ，所以 Node.js 會調整將適合的 callback 加到 poll 階段的 queue 當中 ，這些 callback 最終將會被執行。 深談事件迴圈以下是事件迴圈各個階段圖，以及運行順序 每個階段都有自己的 先進先出 的要被執行的 callback queue 。每個階段都有自己特別的運行方式，一般來說，當事件迴圈跑到一個特定的階段，事件迴圈將會執行這個特定階段裡頭的操作，然後執行它的 callback ，這個執行的動作會重複，直到該階段內的 callback 都被執行完畢了，或者已經達到最大的執行數量。當 queue 裡頭的工作都被處理完了，或者已達最大執行數量限制，事件迴圈會進入下一個階段，反覆循環。 因為上述提到的這些程序很有可能排定更多的程序，且由 poll 階段處理的事件將被 kernel 佇列著 ， 所以 poll 事件可以在被佇列的同時也被執行。 造成的結果是，一個耗時較長的 callback ， 會允許 poll 階段執行的久一點，甚至讓 timer 階段的工作等待。 各階段概述 timers: 這個階段主要處理 setTimeout() 以及 setInterval() 排程的 callback I/O callbacks: 除了 timers, setImmediate(), close 之外的多數類型 idle, prepare: 只供內部使用 poll: 取回新的 I/O 事件; 某些情況， node 將會阻塞在這裡 check: setImmediate() callbacks 將會在這階段被觸發 close callbacks: socket, on … libuv 各階段詳述timers:簡單來說， timers 階段將處理 setTimeout() 以及 setInterval() 的工作。 timers 並不保證可以準確地在給予的時間點執行 callback ， 反之 ，給予的時間更像是一個最低的門檻，唯有過了這個給予的時間點， callback 才會被執行，這視乎當時的工作狀態。 系統的排程或者是其他 callback 的運行都可能會延遲 timers 執行的確切時間。總而言之，過了指定的時間點之後， timers 會盡可能地盡快執行排程的 callback可以看看以下的範例： var fs = require('fs');function someAsyncOperation (callback) &#123; // Assume this takes 0 ms to complete fs.readFile('/path/to/file', callback);&#125;function anotherAsyncOperation (callback) &#123; // Assume this takes 0 ms to complete fs.readFile('/path/to/file', callback);&#125;var timeoutScheduled = Date.now();setTimeout(function () &#123; var delay = Date.now() - timeoutScheduled; console.log(delay + \"ms have passed since I was scheduled\");&#125;, 100);// do someAsyncOperation which takes 200 ms to completesomeAsyncOperation(function () &#123; var startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 200) &#123; ; // do nothing &#125;&#125;);// do anotherSyncOperation which takes 200 ms to completeanotherAsyncOperation(function () &#123; var startCallback = Date.now(); // do something that will take 10ms... while (Date.now() - startCallback &lt; 200) &#123; ; // do nothing &#125;&#125;); 從上面的範例中可以看到， setTimeout 任務原定 100 ms 之後被執行，但是 someAsyncOperation 任務花了 0 + 200 ms ，當執行這個任務時，事件迴圈正處在 poll 階段，所以在一個循環中, 需等待 poll 階段中的任務完全處理完畢，或者達到最大處理數量限制。所以在上面的範例中，需等待 poll 階段的任務 someSyncOperation 以及 anotherSyncOperation 被執行完畢，總共花費 400 ms 左右， 之後才會執行 setTimeout() 的任務。 I/O callbacks這個階段主要執行系統端操作的 callbacks, 像是 TCP 錯誤。舉例來說，當試圖連接時，如果一個 TCP socket 接收到 ECONNREFUSED, 某個 *nix 系統想要等待並回報錯誤，這些都會在 I/O callbacks 階段被佇列。 pollpoll 階段有兩種主要功能: 替時間點已經到的 timers 執行腳本 處理 poll queue 當中的事件 當事件進入 poll 階段，且沒有 timers 排程事件 ， 下面兩件事中，其中一件會發生: 如果 poll 階段不為空，事件迴圈將會執行佇列中的所有 callbacks ，又或者達到最大 callbacks 處理上限 如果 poll 階段為空，以下兩件事中，其中一件會發生： 如果腳本已經被 setImmediate() 排程，事件迴圈將會結束 poll 階段，並且繼續進入到 check 階段來處理該佇列中的排程 如果腳本沒有 setImmediate() 的排程，那事件迴圈將會等待新的事件被加入到佇列，然後立即處理他們 一旦 poll 循環為空，事件迴圈將會檢查 timer 中有沒有可以執行的 callback。 如果有一個或多個可以執行了, 事件迴圈會回去執行 timer 階段的 callback check這個階段允許在 poll 階段完成後，立即執行 callback。如果 poll 階段處於空轉，或者已經有 setImmediate() 的排程，事件迴圈將會繼續進入到 check 階段，而不會等待。 setImmediate() 事實上，是一個很特別的 timer 階段，它跟 timer 在事件迴圈內跑在不同的階段。 它使用 libuv API ，這個 API 排程 callback 使之在 poll 階段結束後被執行 通常，事件迴圈會停在 poll 階段等待新的 request 或 connection ，但是當 setImmediate() 有排程，且 poll 階段處於空轉, 那事件迴圈將會結束 poll 階段，並且進入 check 階段 close callbacks如果一個 socket 或 handle 忽然被關閉， close 事件將會被置於這個階段，除非我們指定 process.nextTick 來執行它 setImmediate() vs setTimeout()setImmediate() 和 setTimeout() 很類似，但根據被呼叫的時機不一樣，行為也不同。 setImmediate() 被設計為，一旦 poll 階段結束時執行 setTimeout() 排程任務，在特定的時間之後執行 兩者之間執行的順序，根據被呼叫時的情況而有所不同。如果兩者都在主模組的時候被呼叫，那順序將由當時的程序的表現所決定，意思就是說，順序無法預測。範例如下：// timeout_vs_immediate.jssetTimeout(function timeout () &#123; console.log('timeout');&#125;,0);setImmediate(function immediate () &#123; console.log('immediate');&#125;); 然而，如果兩者是在 I/O cycle 中被呼叫，那 sedImmediate() 將會優先於 setTimeout() // timeout_vs_immediate.jsvar fs = require('fs')fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout') &#125;, 0) setImmediate(() =&gt; &#123; console.log('immediate') &#125;)&#125;) 對比 setTimeout() , 使用 setImmediate() 的主要優勢為，如果在 I/O cycle 中， setImmediate() 將會被優先執行，不管 setTimeout() 有幾個 process.nextTick()理解 process.nextTick()你可能已經注意到， process.nextTick() 並沒有被顯示在圖表上，儘管它也是 asynchronous API 的一部分。 這是因為 process.nextTick() 技術上來說不算是事件迴圈的一部分。 nextTickQueue 將會在目前操作完成後，立即被執行，不管目前是在事件迴圈內的哪一個循環。 看看我們的圖表，不管在什麼時候，只要你在特定的階段呼叫 process.nextTick() ， 所以經由 process.nextTick() 送出的 callbacks 將會在事件迴圈啟動下一個階段之前全部都處理完畢。 這樣的模式可能會造成一些不好的情況發生，因為如果你遞迴的使用 process.nextTick() callback ，就會造成所謂的 I/O 飢餓 ，事件迴圈將會無法進入 poll 階段 為什麼這樣的行為會被容許？你可能會想，為什麼這樣的行為在 Node.js 終會被容許？ Node.js 部分的設計哲學是， API 總是異步的，不管是否必要，可以參考以下範例:// this has an asynchronous signature, but calls callback synchronouslyfunction someAsyncApiCall (callback) &#123; callback(); &#125;;// the callback is called before `someAsyncApiCall` completes.someAsyncApiCall(() =&gt; &#123; // since someAsyncApiCall has completed, bar hasn't been assigned any value console.log('bar', bar); // undefined&#125;);var bar = 1; 如果我們執行上面的代碼，會出現輸出如下： 因為 someAsyncApiCall 並沒有做任何異步的動作，照同步的流程跑到 console.log 時， bar 還沒有被定義 如果我們將代碼改成以下：function someAsyncApiCall (callback) &#123; process.nextTick(callback);&#125;;someAsyncApiCall(() =&gt; &#123; console.log('bar', bar); // 1&#125;);var bar = 1; 可以得到以下的輸出： 如上所述， process.nextTick() 的執行時間，是在當前的階段內所有的工作都完成了，在進入下個階段之前，會將所有的 process.nextTick() 處理完畢。在上面的例子中， process.nextTick() 會等到所有在此階段的代碼都被執行完畢，也就是待 var bar = 1 執行後，才去執行這個 callback ，所以不會出現 undefined 的情況。請注意！這沒有最大處理數量限制，所以如果利用 process.nextTick() 指派遞迴任務，那就會造成 I/O 飢餓 情況， 事件迴圈將無法接收到新的 request 一個 tick 到底是多長？一個 tick 的時間長度，是 Event Loop 繞完一圈，把所有 queues 中的 callbacks 依序且同步地執行完，所消耗的總時間。因此，一個 tick 的值是不固定的。可能很長，可能很短，但我們希望它能盡量地短。 process.nextTick() vs setImmediate()千萬不要被這兩個階段的命名搞混了！ process.nextTick():在當前階段結束前執行完畢 setImmediate():在下一個階段，或者下一個事件迴圈的 tick 中執行 基本上，這兩個命名應該是要互換。 process.nextTick() 比 setImmediate() 更快地被觸發。這算是一個很難更動的部分，因為當初命名錯誤之後，隨時時間的推移，越來越多 npm 的 package 都是使用這樣的命名，所以一旦這命名變更了，影響會非常的大。 官方文件上建議開發者，在任何情況中，都使用 setImmediate() ，因為它可以更簡單的被邏輯思考，然後在不同的環境上，有著更廣的相容性。 Promise從下面的原始碼可以看到 Promise ， 或者又稱為 microtasks 的執行優先順序依照原始碼的執行順序來看，在一個階段結束之前，process.nextTick() 會先被執行，緊接著, 執行 Promise 。 startup.processNextTick = function() &#123; var nextTickQueue = []; // Callbacks 會排進這個 queue!! var pendingUnhandledRejections = []; var microtasksScheduled = false; var _runMicrotasks = &#123;&#125;; // ... 略 process.nextTick = nextTick; // nextTick 函式在下面 // ... 略 // process._setupNextTick 在 node.cc 中, 我認為意思到了, 就不用再挖下去了 const tickInfo = process._setupNextTick(_tickCallback, _runMicrotasks); _runMicrotasks = _runMicrotasks.runMicrotasks; // ... 略 function _tickCallback() &#123; var callback, args, tock; do &#123; while (tickInfo[kIndex] &lt; tickInfo[kLength]) &#123; // callbacks 從 queue 中一個一個被挖出來執行 tock = nextTickQueue[tickInfo[kIndex]++]; callback = tock.callback; args = tock.args; if (args === undefined) &#123; nextTickCallbackWith0Args(callback); &#125; else &#123; switch (args.length) &#123; case 1: nextTickCallbackWith1Arg(callback, args[0]); // ... &#125; &#125; if (1e4 &lt; tickInfo[kIndex]) tickDone(); &#125; tickDone(); // process.nextTick 的 callbacks 跑完, 接著跑 Promise 的 microtasks _runMicrotasks(); emitPendingUnhandledRejections(); &#125; while (tickInfo[kLength] !== 0); &#125; // ...略 function nextTick(callback) &#123; var args; if (arguments.length &gt; 1) &#123; args = []; for (var i = 1; i &lt; arguments.length; i++) args.push(arguments[i]); &#125; // 將 callback 連它的 arguments 用一個物件存起來推進 queue nextTickQueue.push(new TickObject(callback, args)); tickInfo[kLength]++; &#125; // ... &#125;; 事件迴圈總結 順序:timers &rarr; I/O callbacks &rarr; idle, pare &rarr; poll &rarr; check &rarr; close callbacks &rarr; timers … 往復循環 順序細節 timers 設定的時間過了之後，才會被’盡快’的執行。如果 poll 階段內還有工作還沒做完，會先做完，才會執行 timers 的工作，所以可能會延遲 當處於 I/O 程序中，比如說， fs 模組中， setImmediate() 順序一定大於 setTimeout() ，因為 check 階段緊接在 poll 階段之後 當處於主要模組中， setImmediate() 以及 setTimeout 的優先順序，取決於運行狀況，這個狀態下，次序無法確定 process.nextTick() 將在當前階段的工作結束前，在進入下一個階段之前執行, 所以他的優先性是第一名的 promise 的執行次序緊接在 process.nextTick() 之後，也是在當前階段結束前執行完畢 Express.js建立一個 app server 安裝 npm npm install --save 安裝 express npm install --save express 安裝 nodemon npm install --save-dev nodemon 將 npm start script 設為 nodemonSet script as nodemon fileName.js 指定 status coderes.status (statusCode); Promise以下的範例中， function test 中，我們 return 了一個 Promise ，如果帶入 test function 中的 argument 是 1 ，那就走 resolve 路線 ， 而除了 1 之外所有的 argument, 都走 reject 路線。在 function main 中, 我們使用了 function test, 並帶入 argument 1, 個人覺得這有點像是 PHP 當中的 ternary 用法。當 argument 等於我們在 promise 當中指定的 1 時，走 resolve 路線, 而 then 就是當 promise 為 resolve 路線時該做的事。當 argument 等於是除了 1 之外的任何數，也就是會走 promise 當中的 reject 路線, 此時將會執行 catch 的動作。我們在 promise 當中指定，當走 resolve 路線時，輸出為字串 Success, 所以在 then 的 closure 當中，被帶入的 argument 就是 Success反之，當走 reject 路線時，輸出字串為 Error, 所以在 catch 的 closure 當中，被帶入的 argument 則為 Errorfunction test(number) &#123; return new Promise((resolve, reject) =&gt; &#123; if (number === 1) &#123; resolve(\"Success\") &#125; else &#123; reject(\"Failed\") &#125; &#125;)&#125;function main() &#123; test(1).then((result) =&gt; &#123; // result === \"Success\" console.log(result) &#125;).catch((error) =&gt; &#123; // 不會被執行, 因為狀態是成功 &#125;) test(2).then((result) =&gt; &#123; // 不會被執行, 因為狀態是成功 console.log(result) &#125;).catch((error) =&gt; &#123; // error === \"Failed\" console.log(error) &#125;)&#125; 建立 Datastore Model// 從 google SDK 引用 Datastore functionconst &#123;Datastore&#125; = require('@google-cloud/datastore');// 輸入 project_idconst projectId = 'balmy-sanctuary-238903';// 初始一個 Datastore instanceconst datastore = new Datastore(&#123; projectId: projectId,&#125;);// 匯出這個 modulemodule.exports = datastore; 建立一個 Controller// 匯出這個 functionexports.test = function (req, res) &#123; async function quickStart() &#123; // The kind for the new entity const kind = 'abc'; // The name/ID for the new entity const name = 'sampletask1'; // The Cloud Datastore key for the new entity const taskKey = datastore.key([kind, name]); // Prepares the new entity const task = &#123; key: taskKey, data: &#123; description: 'Buy milk', &#125;, &#125;; console.log(datastore.key(['name', 'kind'])); // Saves the entity await datastore.save(task); console.log(`Saved $&#123;task.key.name&#125;: $&#123;task.data.description&#125;`); res.send(`Saved $&#123;task.key.name&#125;: $&#123;task.data.description&#125;`); &#125; quickStart().catch(console.error);&#125;; Routevar express = require('express');var router = express.Router();// 導入 controller 模組, 並給予名稱var datastore = require('../controllers/datastoreController');/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;);// 建一個 router, 並且導向 datastoreController 裡頭的 test functionrouter.get('/test', datastore.test);module.exports = router; Root address// 找一個地方新增一個檔案，輸入以下的 code// 之後我們就可以在任何一個檔案中，透過 require 這個檔案來 const rootDirconst path = require('path');module.exports = path.dirname('/Users/ray/code/datastore/app.js'); 若我們 console.log 上面 exports 的值，可以得到該專案下的 root 位址 Path利用 path module 來指定路徑// p 會等於專案根目錄下, data 資料夾之下的一個叫做 `products.json` 的檔案// 專案根目錄請參考 `root address` 章節const p = path.join(rootDir, 'data', 'products.json') object.assign 可用來複製或覆蓋目標物件let exampleObject = &#123;a:1, b:2, c:3, c:4&#125;;let copy = object.assign(&#123;&#125;, exampleObject, &#123;a:4, b:4, c:4, d:4&#125;); test 用來確認該 string 是否符合該 regex pattenvar str = \"Hello world!\";// look for \"Hello\"var patt = /Hello/g;var result = patt.test(str);// result = true 時間var moment = require('moment-timezone');var test = moment(createdDate).tz(\"Asia/Taipei\").format('YYYY-MM-DD HH:MM:SS');console.log(test); // 2019-05-21 08:05:44 同時異步發多請求，並待全部有結果後繼續// 需安裝兩個套件 `request-promise` 以及 `p-limit`const request = require('request-promise');const pLimit = require('p-limit');class HealthCheckService &#123; static async getHealthCheckResults(sites) &#123;// 指定 limit 同時最多發十個 request const limit = pLimit(10);// 利用 map 從 sites 中拿到我們要發請求的 url// 然後利用套件 `limit` 來限制同時發請求的數量，再來使用 `request-promise` 套件來對上面拿到的 url 發請求 let promises = sites.map((site) =&gt; &#123; let url = `https://yourAPI?host=$&#123;site.host&#125;&amp;cname=$&#123;site.cname&#125;`; return limit(() =&gt; request(url)); &#125;);// 上面的每一個 promises, 都是一個請求。 現在我們利用 `Promise.all`, 待所有的結果都回來之後，在 return return await Promise.all(promises); &#125;&#125; dotenv安裝npmnpm install dotenv yarnyarn add dotenv 建立 .env 檔.envtouch .env require 語法, 會自動去讀 .env 檔require('dotenv').config(); customName.envtouch custom.env require 語法, 需要額外指定require('dotenv').config(&#123; path: 'custom.env' &#125;); 使用方法直接使用 process.envlet DB_AUTH = process.env.DB_AUTH; 使用 multer 上傳檔案安裝npm install multer --save 定義 storage在 /Storages/local.js 輸入以下 codeconst multer = require('multer');const moment = require('moment');module.exports = multer.diskStorage(&#123; destination: function (req, file, cb) &#123; // 目的地資料夾位址 cb(null, 'uploads') &#125;, filename: function (req, file, cb) &#123; // 上傳檔案命名規則 cb(null, file.fieldname + '-' + moment(new Date()).format(\"YYYYMMDD-hhmmss\")) &#125;&#125;); 建立 middleware在 server.js require 上面定義的 storage 以及 multerconst multer = require('multer');const storage = require('./Storages/local');const upload = multer(&#123;storage: storage,&#125;); 將 upload 加到 routeApp.post('/logParsing/upload', [upload.single('log'), LogParsingController.validate('upload')], LogParsingController.upload); Error Handing在 Controller 中自定義 error handing, 也可建立一個 middleware 來驗。 注意： err, req, res, next 的順序至關重要！！upload(err, req, res, next) &#123; if (err instanceof multer.MulterError) &#123; return res.status(400).send(Output(false, [], &apos;Wrong field&apos;)) &#125;&#125; validator安裝Documentnpm install express-validator --save 引用模組在 controller 引用模組const &#123; body &#125; = require('express-validator');const &#123; validationResult &#125; = require('express-validator'); 設立規則在 controller 定規則, 新增一個 method validate(method)&#123; switch (method) &#123; case &apos;getCountHost&apos;: &#123; return [ body(&apos;measurement&apos;).exists(), ] &#125; case &apos;getSumData&apos;: &#123; return [ body(&apos;measurement&apos;).exists(), body(&apos;host&apos;).exists(), ] &#125; case &apos;getData&apos;: &#123; return [ body(&apos;measurement&apos;).exists(), body(&apos;host&apos;).exists(), ] &#125; &#125;&#125; 驗證並回報錯誤在 controller 中定義錯誤並設定回報格式const errors = validationResult(req);if (!errors.isEmpty()) &#123; return res.status(400).send(Output(false, [], errors.errors[0].msg))&#125; 使用 validator以 middleware 的方式使用 validatorApp.post('/netdatadb/sum', NetdataController.validate('getSumData'), NetdataController.getSumData); 結果若有錯誤, 結果如下： &#123; \"succeeded\": false, \"data\": [], \"message\": [ &#123; \"msg\": \"Invalid value\", \"param\": \"measurement\", \"location\": \"body\" &#125; ]&#125; serve static file in Expressapp.use('/static', express.static(path.join(__dirname, 'public'))) path.join(__dirname, ‘public’): 使用絕對路徑讀取檔案 以下為請求的路徑範例：http://localhost:3000/static/images/kitten.jpghttp://localhost:3000/static/css/style.csshttp://localhost:3000/static/js/app.jshttp://localhost:3000/static/images/bg.pnghttp://localhost:3000/static/hello.html Error Handing in Express參考文件 同步的錯誤需要被 catch 嗎？ 不需要 對 controller 的 error handler 的 error catch? exports.catchErrors = (fn) =&gt; &#123; return function(req, res, next) &#123; return fn(req, res, next).catch(next); &#125;;&#125;; next() 與 next(err) 的分別？ next() 是將當前的 middleware 終止, 並導向下一個 middleware, 而 next(err) 則是會直接導向 err handler 異步錯誤需要特別被 catch 嗎？ 需要哦！ 下面的代碼中, next 的位置是怎麼樣的一種寫法？ 將 next 置於 callback 的位置, 當沒有錯時, 跳往下一個 handler, 而當有錯誤時, 將錯誤導向 error handler app.get('/', [ function (req, res, next) &#123; fs.writeFile('/inaccessible-path', 'data', next) &#125;, function (req, res) &#123; res.send('OK') &#125;]) 在 asynchronous 中, 如何處理 error? 若出錯, 要將 err 放到 next() 中帶往 error handler 下面的代碼中, 處理 error 的邏輯是什麼？ 當 fs.readFile 沒錯時, 跳往下一個 handler, 如果有錯, 跳往 error handler app.get('/', [ function (req, res, next) &#123; fs.readFile('/maybe-valid-file', 'utf-8', function (err, data) &#123; res.locals.data = data next(err) &#125;) &#125;, function (req, res) &#123; res.locals.data = res.locals.data.split(',')[1] res.send(res.locals.data) &#125;]) 在 production 環境中, Express 會將 stack trace 送往客戶端嗎？ 不會 如果已經開始回 response 了才遇到錯誤, 比如說正在串流到客戶端, Express 預設的 error handler 會結束掉連線嗎？ 會哦 在使用自定義 error handler 時, 若要避免正在回 response 時遇到錯誤, 要注意什麼？ 要檢查 header 是否已經傳送了, 若是, 則要將錯誤導向 Express 預設 error handler 來中止連線 以下代碼是什麼樣的錯誤處理邏輯？ 如果 header 已經傳送了, 將錯誤傳給 Express 預設 error handler 來中止連線 function errorHandler (err, req, res, next) &#123; if (res.headersSent) &#123; return next(err) &#125; res.status(500) res.render('error', &#123; error: err &#125;)&#125; 什麼情況之下, 即使已經有建立自定義 error handler 了, Express 還是會將 error 送到預設的 error handler? 當 next(err) 被呼叫了一次以上 定義一個 error-handling middleware, 需要幾個參數？ 四個 如何在自訂的 error handler 中, 在回應 client 之前, log stack trace? console.error(err.stack) 怎麼寫一個最簡單的 log error 的 middleware? function logErrors (err, req, res, next) &#123; console.error(err.stack) next(err)&#125; 請敘述下面的 error handler 邏輯 若請求有使用 xhr 的話, 直接回應指定錯誤訊息, 若無, 導向預設 error handler (因為已經呼叫兩次) function clientErrorHandler (err, req, res, next) &#123; if (req.xhr) &#123; res.status(500).send(&#123; error: 'Something failed!' &#125;) &#125; else &#123; next(err) &#125;&#125; 如果我有兩組以上的 app.get(‘/‘, [fn1, fn2, fn3]), 現在我已經執行了 fn1, 我想要跳掉 fn2, fn3 到下一個 app.get(‘/‘, [fn4, fn5, fn6]), 該怎麼做? fn1(req, res, next)&#123; //do something next(&apos;route&apos;)&#125;","link":"/zh-tw/Node-js/"},{"title":"用 NGINX 配置一個 WebDAV Server","text":"前言 用 NGINX 配置一個 WebDAV Server 使用者可透過帳號密碼登入存取指定資料夾 環境GCP InstanceUbuntu 18.04NGINXRoot 安裝apt-get install nginx-full 開啟 gzip頻寬有限, 機器速度較快, 開啟 gzip 讓 server 回覆的資料都先經過壓縮, 減少經由網路傳送的資料大小sed -i '/gzip_/ s/#\\ //g' /etc/nginx/nginx.conf /gzip_/: 尋找含有 /gzip_/ 的行數s/#\\ //g: 將 # 替換成 空白 意思就是 uncomment 掉 gzip 啦 配置 WebDAV Server建立檔案vim /etc/nginx/conf.d/webdav.conf 配置檔案server &#123; listen 80; listen [::]:80; server_name yourDomain; # 使用者認證 auth_basic realm_name; # 使用者身份檔案位置 auth_basic_user_file /etc/nginx/.passwords.list; # dav 允許的使用方法 dav_methods PUT DELETE MKCOL COPY MOVE; # 在目前的範圍內啟動支持特定的 WebDAV 方法, PROPFIND 可參考 https://docs.oracle.com/cd/E19857-01/819-0824/agdav.html dav_ext_methods PROPFIND OPTIONS; # 在此資料夾內, 新建的文件以及資料夾的權限, 若無特別設定, 預設為 user:rw。 若以指定 all 及 group 權限, 則 user 可忽略 dav_access user:rw group:rw all:r; # 臨時中轉目錄 client_body_temp_path /tmp/nginx/client-bodies; # 上傳檔案最大限制, 0 為不限制 client_max_body_size 0; # 允許在現有目錄中增加檔案時, 如果指定的資料夾不存在, 自動創建 create_full_put_path on;&#125; 建立使用者 輸入 userecho -n 'userName:' | sudo tee -a /etc/nginx/.passwords.list; 印出使用者名稱, tee 會將使用者名稱印在螢幕上以及導入 /etc/nginx/.passwords.list 檔案, -a = append 輸入密碼openssl passwd -apr1 | sudo tee -a /etc/nginx/.passwords.list; 使用 openssl passwd 的 -apr1 規則來將密碼明文變成密文, tee 印出加密後密碼以及導入 /etc/nginx/.passwords.list 檔案, -a = append 大功告成！","link":"/zh-tw/buildAWebDavServerWithNginx/"},{"title":"在 Linux 上建立一個 SFTP Server","text":"前言本篇記錄如何在 Linux 上建立一個 SFTP Server, 需滿足以下幾點條件： 使用者不可經由 SSH 登入 使用者可經由 SFTP 登入 使用者只可在指定目錄活動 使用者可上傳下載指定目錄內的檔案 環境GCP Ubuntu 18.04以下操作皆默認 root 操作, 請在前面加上 sudo 如果你不是使用 root 操作 建立 SFTP 群組 建立 group group add sftp-users 確認 group 有正確被建立 grep 'sftp-users' /etc/group 建立 SFTP 使用者 建立使用者useradd -g sftp-users -d /upload -s /sbin/nologin test -g: 預設 group-d: 預設家目錄-s: 預設 shell, nologin shell 一般用於系統帳號, 表示不可經由 ssh 登入 確認使用者有正確被建立 grep test /etc/passwd 如果使用者早已建立, 可直接更改使用者設定即可 usermod -g sftp-users -d /upload -s /sbin/nologin test SSH 設定 打開 SSH 設定檔 vim /etc/ssh/sshd_config 複製 Subsystem 以作修改用, 並註解原本的 # Subsystem sftp /usr/lib/openssh/sftp-serverSubsystem sftp internal-sftp 指定群組根目錄 Match Group sftp-users ChrootDirectory /home/sftp-users/%u ForceCommand internal-sftp ChrootDirectory: 設定該群組根目錄 %u: user 的意思, 所以任何該群組下的 user 登入之後的根目錄就會變成 user 的名稱, 以這個例子來看, 根目錄就是 /home/sftp-users/test ForceCommand: 強制使用 internal-sftp 以上 Match 的設定, 請置於檔案的最末處, 否則會有語法錯誤。 上傳下載資料夾建立 建立使用者上傳下載用資料夾install -d -o test -g sftp-users /home/sftp-users/test/upload -d: 類型為資料夾-o: owner-g: group 使用者只能在這個剛剛建立的 upload 資料夾裡頭, 才有權限上傳跟下載。根據 SSH 安全規則, chrootDirectory 的 owner 必須是 root 才行, 且權限只有 root 才可以有 w 的權限, 如果這邊沒有設定為 root, 使用者是無法登入的 大功告成","link":"/zh-tw/buildSftpServerOnLinux/"},{"title":"OOP-Class and Object","text":"大家好，我是Ray! 今天想跟大家分享，什麼是Ｃlass，以及什麼是Object，還有他們之間的關係！ 講到class就不得不講到object，而要解釋object就離不開class，這也常常是讓許多人感到困惑與不解的地方。 簡單來說，class算是一用來創造object的code模板。 廢話不多說，讓我們來創一個class先： 我們可以自訂我們喜歡的class的名稱，class的名稱可以是數字與字母的組成，但開頭的第一個字不可以是數字，如下面的code：class ＭyAccessories&#123; // class body&#125; 雖然上面的東西看起來沒什麼用，但是這已經是一個符合標準的class 如上所述，我們說class是產出object的一個模板，現在讓我們來產出幾個object，如以下的code:$accessory1 = MyAccessories();$accessory2 = MyAccessories(); 以上我們使用MyAccessories class 造出了兩個object，由於這兩個object是由同樣的class造出來的，所以他們有著相同的功能與類型。 那你會問，他們一樣嗎？ 答案是，不。 或許在功能以及類型上它們是一樣的，但他們的確是不同的object。 我知道你可能還有疑惑，讓我們把他們印出來看看！新增以下的code:var_dump($accessory1);var_dump($accessory2); 沒有意外的話，你應該會印出下面的東西。#後面的編號代表著他們的獨特性。或許你會說，啊～這會不會是照順序來顯示＃後面數字啊？object(MyAccessories)#1 (0) &#123;&#125;object(MyAccessories)#2 (0) &#123;&#125; 那我們再來做一個實驗 我們將var_dump內的object名稱互換，如果說＃後面的數字只是照順序來顯示的話，照理說印出來的東西應該不會變，是吧？var_dump($accessory2);var_dump($accessory1); 你應該會印出下面的東西： object(MyAccessories)#2 (0) &#123;&#125;object(MyAccessories)#1 (0) &#123;&#125; ＃後面的數字變了！ 這代表一個事實，那就是每個object，儘管他們是由同一個class所產出的，都會有屬於自己的一組編號，代表他們的獨特性，所以每一個object都會是不同的。 如果你還有些困惑，讓我再來舉個例子： Class就像是生產鑄件的模具，而object就像是被壓出來的鑄件，可以是一個鍵帽，或是一個同型號的耳機。外觀看來他們都是一模一樣的，但是他們確實是不同的獨立個體。你或許可以在上面看到生產流水編號，那就相當於上面印出來的#後面的數字。 看完以上的文章，各位是否對class以及object有更深一層的認識了呢？","link":"/zh-tw/OOP-ClassAndObject/"},{"title":"Cloud Functions 初探 - Command Line","text":"概述Google Cloud Functions 是一個用來建立以及連結雲端服務的無伺服器執行環境。 你可以利用 Cloud Functions 來寫簡單，單一用途的 functions, 這些 functions 被附加到雲端基礎設施以及服務的事件上。 當監聽的事件被觸發， Cloud Function 也會被觸發。 你的代碼將在一個完全自動化管理的環境中被執行。 你完全不需要提供任何的基礎設施或管理任何的伺服器。 Cloud Functions 由 Javascript 所編寫，並且執行在 Google Cloud Platform 的 Node.js 環境。 你可以讓你的 Cloud Functions 運行在任何的 Node.js 執行階段上，這不只攜帶輕便，而且更讓本地測試非常簡單。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 連結並且延伸雲端服務Cloud Functions 提供一個邏輯的連結層，它可以讓你在上面寫代碼來連接並且延伸雲端服務。 監聽並且回應 Cloud Storage 的檔案上傳事件，一個紀錄改變事件，或是 Cloud Pub/Sub 的訊息觸發事件。 Cloud Functions 擴大已經存在的雲端服務，並且允許使用客制的程式邏輯來處理越來越多的使用情境。 Cloud Functions 擁有 Google Service Account credential 的存取權，因此可以無縫接軌大部分的 Google Cloud Platform 服務，像是 Datastore, Cloud Spanner, Cloud Translation API, Cloud Vision API, 以及很多很多其他的服務。 並且，很多的 Node.js client libraries 都有支援 Cloud Functions, 這更是簡化了這些服務之間的整合。 事件以及觸發 (Events and Triggers)雲端事件是發生在雲端環境的事。 像是資料庫的資料有所改變，檔案被上傳到儲存區，或是一台新的虛擬機背建立。 不管你是否選擇回應，事件都會發生。 你可以使用 trigger 來建立對一個事件的回應。 Trigger 是一個宣告，對那些你有興趣的特定的或是一連串事件的宣告。 將一個 function 連結到 trigger 讓我們可以捕捉，並且隨著事件的發生有所動作。 更多有關建立 trigger 並且將它與 function 關聯的資訊，請參考 Events and Triggers 無伺服器Cloud Functions 幫我們拿掉了這些工作，像是伺服器管理，軟體設置，框架更新，作業系統更新。 你只需要專注在代碼的部分，因為 Google 完全地幫你管理軟體以及基礎設施的部分。 再者，資源會隨著事件的回應自動地被提供。 這代表說，你完全不需要做任何事就可以讓一個 function 從一天幾次的調用，到一天好幾百萬次的調用。 使用情境異步的工作量像是輕量化的 ETL, 或是雲端自動化像是應用被觸發而自動建立，不再需要獨立的伺服器以及開發者的維護。 你只要簡單的部署 Cloud Function 並且和你想要的事件做連結。 Cloud Functions 的這些細緻的，立即提供的特質讓它非常適合輕量化的 API 以及 webhooks。 再者，當你部署一個 HTTP Function，該 HTTP endpoints 將會自動地被提供，這代表你不再需要像其他服務的複雜設置。 下面的表格列出了一些額外的常用 Cloud Function 的使用情境： 使用情境 敘述 Data Processing / ETL 監聽並且回應 Cloud Storage 事件像是當一個檔案被建立，被改變，或是被移除了。 處理圖片，影片編譯，資料驗證及轉換，以及從 Cloud Functions 上觸發任何網路上的服務。 Webhooks 經由簡單的 HTTP trigger, 回應那些來自第三方的事件，像是 GitHub, Slack, Stripe, 或是任何可以發 HTTP requests 的來源。 輕量化 APIs 使用輕量化、不緊密相依、快速建立，以及立即可調整大小的邏輯來建構你的應用。 你的 functions 可以被事件驅動或者是直接通過 HTTP/S 觸發 可攜式後端 使用 Google 專為 App 開發者的可攜式平台, Firebase, 以及在 Cloud Functions 建構你自己的移動後端。 監聽以及回應來自於 Firebase Analytics, Realtime Database, Authentication, 以及 Storage 的事件。 IoT 想像一個數以萬計的裝置串流資料到 Cloud Pub/Sub, 然後啟動 Cloud Functions 來處理，轉換，並且儲存資料。 Cloud Functions 讓你使用完全無伺服器的方式來做到這些事。 這個手把手的教程將會教你如何使用 Google Cloud 主控台來建立，部署，並且測試 Cloud Function 你將會做什麼？ 建立一個 cloud function 部署並且測試這個 function 檢視紀錄 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個 function首先，你將會建立一個名為 helloWorld 的簡單 function。 這個 function 會寫一段訊息到 Cloud Functions 的紀錄。 它被 cloud function 事件所觸發，並且當這個 function 成功執行完成, 可以執行一個回呼函式 在本教程中, cloud function 事件會是一個 cloud pub / sub topic 事件。 Cloud Pub / Sub 是一種「發佈/訂閱 (Pub / Sub) 服務」：將訊息傳送者與訊息接收者分離的訊息傳遞服務。 若欲了解更多有關 pub / sub 的資訊，可以參考文件 執行以下指令來建立一個 cloud function: 在 Cloud Shell 命令列視窗中, 建立一個置放 function 代碼的資料夾 mkdir gcf_hello_world 移動到 gcf_hello_world 資料夾 cd gcf_hello_world 建立並且打開編輯 index.js vim index.js 將以下的代碼複製貼上到 index.js /** * Cloud Function. * * @param &#123;object&#125; event The Cloud Functions event. * @param &#123;function&#125; callback The callback function. */exports.helloWorld = function helloWorld (event, callback) &#123; console.log(`My Cloud Function: $&#123;JSON.stringify(event.data.message)&#125;`); callback();&#125;; 輸入 :wq 儲存並且離開檔案 建立一個 cloud storage bucket (儲存區)使用以下指令來為你的 function 建立一個新的 cloud 儲存區cloudgsutil mb -p [PROJECT_ID] gs://[BUCKET_NAME] PROJECT_ID 為此教程中的 GCP Project ID, 如下圖。 如果你沒有使用 Qwiklab, 此 Project ID 為你 GCP 帳號下的 Project ID BUCKET_NAME 是你給予這個儲存區的名稱。 它必須是獨一無二的名字。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 部署你的 function當部署一個新的 function, 你必須要指令 --trigger-topic, --trigger-bucket, 或 --trigger-http。 當你更新現有的 function 時, 觸發條件不會更改, 除非你有另外指定。 在本教程中, 你將會設定 hello_world 為 --trigger-topic 部署這個 function, 並使用 pub / sub 為觸發事件, 名稱為 hello_world, 將以下的 [BUCKET_NAME] 替換成你的儲存區名稱 cloudgcloud functions deploy helloWorld \\ --stage-bucket [BUCKET_NAME] \\ --trigger-topic hello_world \\ --runtime nodejs6 核對 function 的狀態cloudgcloud functions describe helloWorld 狀態 ACTIVE 顯示這個 function 已經被成功部署 entryPoint: helloWorldeventTrigger: eventType: providers/cloud.pubsub/eventTypes/topic.publish failurePolicy: &#123;&#125; resource:...status: ACTIVE... 每一條由這個主題發布的訊息都將觸發這個 function, 訊息內容為輸入的資料 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 測試部署上去的 function在你部署這個 function 上去, 並且知道它的狀態是 active 之後，讓我們來測試看看這個 function 會不會再偵測到事件之後寫一段訊息到 cloud 紀錄 輸入以下指令來建立一個訊息, 測試這個 function gcloud functions call helloWorld --data &apos;&#123;&quot;message&quot;:&quot;Hello World!&quot;&#125;&apos; cloud 工具返回了一個此 function 的 execution ID, 這表示訊息已經被寫到紀錄了 範例輸出：executionId: 3zmhpf7l6j5b 檢視紀錄來確認有這個 execution ID 的訊息記錄 檢視紀錄檢視歷史紀錄 gcloud functions logs read helloWorld 如果 function 成功地被執行, 訊息記錄會被列出，如下： LEVEL NAME EXECUTION_ID TIME_UTC LOGD helloWorld 3zmhpf7l6j5b 2017-12-05 22:17:42.585 Function execution startedI helloWorld 3zmhpf7l6j5b 2017-12-05 22:17:42.650 My Cloud Function: Hello World!D helloWorld 3zmhpf7l6j5b 2017-12-05 22:17:42.666 Function execution took 81 ms, finished with status: &apos;ok&apos; 你的應用已經完成部署, 測試, 並且你可以檢視紀錄 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 答案: true","link":"/zh-tw/cloudFunctionsQwikStartCommandLine/"},{"title":"Cloud Functions 初探 - 主控台","text":"概述Google Cloud Functions 是一個用來建立以及連結雲端服務的無伺服器執行環境。 你可以利用 Cloud Functions 來寫簡單，單一用途的 functions, 這些 functions 被附加到雲端基礎設施以及服務的事件上。 當監聽的事件被觸發， Cloud Function 也會被觸發。 你的代碼將在一個完全自動化管理的環境中被執行。 你完全不需要提供任何的基礎設施或管理任何的伺服器。 Cloud Functions 由 Javascript 所編寫，並且執行在 Google Cloud Platform 的 Node.js 環境。 你可以讓你的 Cloud Functions 運行在任何的 Node.js 執行階段上，這不只攜帶輕便，而且更讓本地測試非常簡單。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 連結並且延伸雲端服務Cloud Functions 提供一個邏輯的連結層，它可以讓你在上面寫代碼來連接並且延伸雲端服務。 監聽並且回應 Cloud Storage 的檔案上傳事件，一個紀錄改變事件，或是 Cloud Pub/Sub 的訊息觸發事件。 Cloud Functions 擴大已經存在的雲端服務，並且允許使用客制的程式邏輯來處理越來越多的使用情境。 Cloud Functions 擁有 Google Service Account credential 的存取權，因此可以無縫接軌大部分的 Google Cloud Platform 服務，像是 Datastore, Cloud Spanner, Cloud Translation API, Cloud Vision API, 以及很多很多其他的服務。 並且，很多的 Node.js client libraries 都有支援 Cloud Functions, 這更是簡化了這些服務之間的整合。 事件以及觸發 (Events and Triggers)雲端事件是發生在雲端環境的事。 像是資料庫的資料有所改變，檔案被上傳到儲存區，或是一台新的虛擬機背建立。 不管你是否選擇回應，事件都會發生。 你可以使用 trigger 來建立對一個事件的回應。 Trigger 是一個宣告，對那些你有興趣的特定的或是一連串事件的宣告。 將一個 function 連結到 trigger 讓我們可以捕捉，並且隨著事件的發生有所動作。 更多有關建立 trigger 並且將它與 function 關聯的資訊，請參考 Events and Triggers 無伺服器Cloud Functions 幫我們拿掉了這些工作，像是伺服器管理，軟體設置，框架更新，作業系統更新。 你只需要專注在代碼的部分，因為 Google 完全地幫你管理軟體以及基礎設施的部分。 再者，資源會隨著事件的回應自動地被提供。 這代表說，你完全不需要做任何事就可以讓一個 function 從一天幾次的調用，到一天好幾百萬次的調用。 使用情境異步的工作量像是輕量化的 ETL, 或是雲端自動化像是應用被觸發而自動建立，不再需要獨立的伺服器以及開發者的維護。 你只要簡單的部署 Cloud Function 並且和你想要的事件做連結。 Cloud Functions 的這些細緻的，立即提供的特質讓它非常適合輕量化的 API 以及 webhooks。 再者，當你部署一個 HTTP Function，該 HTTP endpoints 將會自動地被提供，這代表你不再需要像其他服務的複雜設置。 下面的表格列出了一些額外的常用 Cloud Function 的使用情境： 使用情境 敘述 Data Processing / ETL 監聽並且回應 Cloud Storage 事件像是當一個檔案被建立，被改變，或是被移除了。 處理圖片，影片編譯，資料驗證及轉換，以及從 Cloud Functions 上觸發任何網路上的服務。 Webhooks 經由簡單的 HTTP trigger, 回應那些來自第三方的事件，像是 GitHub, Slack, Stripe, 或是任何可以發 HTTP requests 的來源。 輕量化 APIs 使用輕量化、不緊密相依、快速建立，以及立即可調整大小的邏輯來建構你的應用。 你的 functions 可以被事件驅動或者是直接通過 HTTP/S 觸發 可攜式後端 使用 Google 專為 App 開發者的可攜式平台, Firebase, 以及在 Cloud Functions 建構你自己的移動後端。 監聽以及回應來自於 Firebase Analytics, Realtime Database, Authentication, 以及 Storage 的事件。 IoT 想像一個數以萬計的裝置串流資料到 Cloud Pub/Sub, 然後啟動 Cloud Functions 來處理，轉換，並且儲存資料。 Cloud Functions 讓你使用完全無伺服器的方式來做到這些事。 這個手把手的教程將會教你如何使用 Google Cloud 主控台來建立，部署，並且測試 Cloud Function 你將會做什麼？ 建立一個 cloud function 部署並且測試這個 function 檢視紀錄 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 建立一個 function在這個步驟，你將使用主控台建立一個 cloud function 在主控台，點擊 Navigation menu &gt; Cloud Functions 點擊 Create function 在 Create function 對話框，輸入以下的值欄位 | 值— |Name | GCFunctionMemory allocated | DefaultTrigger | HPPT triggerSource code | Inline editor (使用預設被提供給 index.js 的 **helloWorld function 實作) 在下個章節部署 function 部署 function還是在 Create function 對話框，在底部點擊 Create 來部署 function 在你點擊 Create 後，主控台會重導向 Cloud Functions Overview 頁面 當 function 正被部署時，旁邊的小圖案會顯示轉圈圈，當部署完畢，會變成一個打勾的圖案 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 測試 function測試這個被部署上去的 function 在 Cloud Functions Overview 頁面，從右邊三個小點的選單處點擊 Test function 在 Triggering event 欄位，在大括號 {} 之間輸入以下代碼並且點擊 Test the function &quot;message&quot;:&quot;Hello World!&quot; 在 output 欄位，你應該可以看到一段訊息 Success: Hello World! 在 Logs 欄位，一段狀態碼 200 顯示成功。 (紀錄出現可能會需要幾分鐘的時間) View logs (檢視紀錄)從 Cloud Functions Overview 頁面檢視紀錄 點擊藍色箭頭來回到 Cloud Functions Overview 頁面 在 Cloud Functions Overview 頁面，從右邊三個小點的選單處點擊 View logs 紀錄歷史範例如下： 你的應用已經被部署，被測試，而且你已經可以檢視它的紀錄 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： true HTTP 恭喜你已經完成本教程","link":"/zh-tw/cloudFunctionsQwikStartConsole/"},{"title":"Cloud IAM - 初探","text":"概述Google Cloud 身份與存取權管理 (IAM)，提供了為 GCP 資源建立且管理權限。 Cloud IAM 統一 GCP 眾多服務的存取權限控制，且提供一致性的操作。 在本教程中，你將會學到如何賦予使用者角色權限，或是移除 IAM 相關角色權限。 更確切的說，在此教程中登入兩組帳密來體驗權限的允許與廢除在 GCP Owner 與 Viewer 上是如何運作的。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 必要條件這是入門級的教程，如果你對 Cloud IAM 沒有經驗，或只有一點點經驗的話，這個教程會蠻適合你的。 如果你有 Cloud Storage 的經驗，會可能會讓你比較容易完成這個教程，但是如果沒有也沒關係，因為這不是必須的。 要完成本教程，你必須要可以建立 .txt 檔，或者 .html 檔。 如果你在找更進階一點的 Cloud IAM 課程，一定不要錯下面這個： IAM Custom Roles 設定兩個使用者如同早先提到的，本教程提供兩組帳號密碼來模擬 IAM 政策以及特定的角色有什麼樣的權限 在教程頁面的左方，你可以看到帳號密碼列表，代表如下： 注意到，有兩組帳號密碼: Username1 還有 Username2。 分別代表 不同的 Cloud IAM，每一個 IAM 都有各自被分配到的存取權限。 這些 GCP “roles” 根據被分配的權限限制哪些資源你可以存取，哪一些不行 用第一個 user 登入 GCP 主控台 點擊 Open Google Console 按鈕。 這會打開一個新的瀏覽視窗。 如果你被要求 Choose an account, 點擊 Use another account 打開 GCP 登入頁面，複製代表 `googlexxxxxx_student@qwiklabs.net` 的第一使用者帳號，然後貼到 “Email or phone” 欄位 從 “Connection Details” 複製密碼，然後貼到 Google 登入密碼欄位 點擊 Next 然後 Accept 服務條款。 Google Cloud Platform 主控台開啟。 Agree 服務條款，以及在 Email updates 處勾選 No 用第二個使用者登入 GCP 主控台 再次點擊 Open Google Console 按鈕。 這會打開一個新的瀏覽視窗。 如果你被要求 Choose an account, 點擊 Use another account 打開 GCP 登入頁面，複製代表 `googlexxxxxx_student@qwiklabs.net` 的第二使用者帳號，然後貼到 “Email or phone” 欄位 從 “Connection Details” 複製密碼，然後貼到 Google 登入密碼欄位 點擊 Next 然後 Accept 服務條款。 Google Cloud Platform 主控台開啟。 Agree 服務條款，以及在 Email updates 處勾選 No 現在你應該要有兩個 GCP Console 視窗是在你的瀏覽器打開的，一個是使用者 1, 一個是使用者 2 在瀏覽視窗重置或者檢視使用者有時候，一個使用者可能會被另一個使用者覆蓋掉，這時候可能會讓你很疑惑目前登入的使用者是哪一個 要知道目前確切登入的使用者是誰，將滑鼠停在大頭貼處，你就可以看到目前的 username 如果你要重置目前登入的使用者 點擊你的 Avatar, 然後點擊 Sign out 來登出 在 Connection Details 面板處，點擊 Open Google Console, 然後再用對的帳號密碼登入一次 IAM 主控台以及專案等級角色 到 Username 1 的 GCP 主控台頁面 選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM 。你現在已經在 “IAM &amp; admin” 主控台 在頁面上方點擊 +ADD 按鈕, 從下拉選單探索與專案相關的角色 你應該會看到 Browser (瀏覽者), Editor (編輯者), Owner (擁有者), 還有 Viewer (檢視者) 角色。 這四種在 GCP 被熟知為 原始角色 (primitive roles) 。 原始角色設定專案等級的權限，並且，除非有特別指定，否則他們的存取管理權限範圍涵蓋所有的 GCP 服務 下面表格中的角色從 GCP roles documentation 提取定義，給予瀏覽者，編輯者，擁有者，以及檢視者權限的簡單概述 角色名稱 權限 角色/檢視者 擁有不影響狀態的 只讀 權限，例如檢視 (但不可修改) 已存在的資源或檔案 角色/編輯者 擁有檢視者的所有權限，外加修改的權限，例如可以改變已存在的資源 角色/擁有者 擁有編輯者的所有權限，外加以下的權限 管理專案內所有角色的權限設定專案的帳單 角色/瀏覽者 (beta) 擁有可以瀏覽專案階層關係的權限，包含資料夾，組織，以及 Cloud IAM 政策。 但此角色不包含檢視專案內資源的權限 因為我們可以管理這個專案的角色以及全縣，所以 Username 1 有專案擁有者的權限 點擊 CANCEL 離開 “Add member” 面板 探索編輯者角色現在切換到 Username 2 主控台 移動到 IAM &amp; admin 主控台，選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM 在表格內搜尋一下 Username 1 以及 Username 2, 然後看一下他們被賦予的角色，你應該可以看到如下圖: 你應該會看到: Username 2 有 “檢視者” 的角色 頁面上方的 +ADD 按鈕是反灰的 - 如果你試圖點擊它，你會看到以下的訊息 這是一個範例，展示了 IAM 角色影響決定了你在 GCP 專案中哪些可以做，哪些不能做 下一步，我們切換到 Username 1 主控台 準備一個資源來測試存取確定你在 Username 1 的主控台 建立一個儲存區 建立一個 GCS 儲存區，給予一個獨特的名字。 從主控台，選擇 Navigation menu &gt; Storage &gt; Browser 點擊 Create bucket 注意: 如果出現一個儲存區建立的權限錯誤，先登出再使用 Username 1 登入 更新以下的欄位，沒提到的留為預設 注意儲存區的名字，之後會用到 點擊 Create 注意: 如果出現一個儲存區建立的權限錯誤，先登出再使用 Username 1 登入 上傳一個範例檔案 在儲存區的細節頁面，點擊 Upload files 按鈕 瀏覽你的電腦，找一個可以使用的檔案，任何 text 或 html 檔都可以 在檔案那一行的行末，點擊三個小點的圖案，然後點擊 Rename 更新檔名為 sample.txt 點擊 Rename 點擊 Check my progress 來核對目前進度 核對專案檢視者存取權限現在切換到 Username 2 主控台 從主控台： 選擇 Navigation menu &gt; Storage &gt; Browser 。 核對這個使用者可以看到這個儲存區 Username 2 被賦予 “檢視者” 角色，這個角色有不影響狀態的 “只讀” 權限。 這個範例說明了這個功能 - 在權限範圍內的 GCP 專案，他們可以檢視 Cloud Storage 儲存區，以及檔案 移除專案存取權限現在切換到 Username 1 主控台 移除 Username 2 的專案檢視權限 選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM , 然後點擊 Username2 旁的鉛筆圖案 你可以要將螢幕變寬來看到鉛筆圖案 點擊角色名稱旁邊的垃圾桶圖案來移除 Username 2 的檢視者權限, 然後點擊 SAVE 注意到這個使用者已經從清單上消失了，這個使用者現在已經沒有存取權了 備註: 這個動作要完全生效到所有的服務，可能會需要最多 80 秒的時間，更多資訊請參考這裏 核對 Username 2 已經沒有存取權了 切換到 Username 2 主控台。 確認一下目前是 Username 2 登入狀態，而且 Username 2 在生效之後還沒被登出, 如果登出了，在登入一次。 選擇 Navigation menu &gt; Home 點擊 Navigation menu &gt; Storage &gt; Browser 來移動到 Cloud Storage 你應該會看到錯誤如下： 備註： 如同之前提到的，變更生效大概需要最多 80 秒。 如果你沒有收到權限錯誤，等兩分鐘之後再重整一下頁面 點擊 Check my progress 來和對目前進度都有完成 增加儲存權限 從 “Connection Details” 面板複製 Username 2 切換到 Username 1 主控台。 確認一下目前是 Username 2 登入狀態，而且 Username 2 在生效之後還沒被登出, 如果登出了，在登入一次。 選擇 Navigation menu &gt; IAM &amp; admin &gt; IAM 點擊 +ADD 然後貼上 Username 2 的名字到 member field 在角色欄位，從下拉選單選擇 Storage &gt; Storage Object Viewer 點擊 SAVE 核對存取權 切換到 Username 2 主控台Username 2 沒有專案檢視者的角色，所以使用者不能在主控台看到專案或者任何專案的資源。但是，這個使用者對 Cloud Storage 有特別的存取權，讓我們來驗證一下 點擊 Activate Cloud Shell 圖案來打開 Cloud Shell 命令列 打開 Cloud Shell 視窗，輸入以下的指令，記得用我們一開始建立的儲存區名字來將指令中的 [YOUR_BUCKET_NAME] 取代掉 gsutil ls gs://[YOUR_BUCKET_NAME] 你應該會收到類似下面的輸出 gs://[YOUR_BUCKET_NAME]/sample.txt 如你所見，你已經給了 Username 2 Cloud Storage 儲存區的檢視權限 點擊 Check my progress 來和對目前進度都有完成 恭喜你已經完成本教程！","link":"/zh-tw/cloudIAMQwikStart/"},{"title":"PayPal REST API 串接金流好簡單","text":"前言本篇將會分享，如何使用 PayPal REST API，來做到以下的動作： 建立授權訂單 授權 請款 退款 部分款項凍結 本篇屬於個人學習筆記，所以可能會參雜一些個人的專案內容，請選擇性參考。 安裝 PayPal REST API 官方 SDK本篇使用的為目前 PayPal 最新釋出的 SDK 版本 安裝composer require paypal/paypal-checkout-sdk 設定個人設定 安裝完成之後，可在 SDK 的資料夾底下，找到範例，如下圖： 設定 PayPalClient.php 檔案，如下: 申請開發者帳號並登入 建立一個App 取得 Client ID 以及 Secret 將取得的 Client ID 以及 Secret 填入， Ray 是設在環境變數 public static function environment()&#123; $clientId = env('PAYPAL_SANDBOX_API_ClientID'); $clientSecret = env('PAYPAL_SANDBOX_API_SECRET'); return new SandboxEnvironment($clientId, $clientSecret);&#125; 開始在上面提到的範例資料夾中，可以找到幾乎所有會用到的範例。這邊可以根據每個人的需求不同來客制，以下是 Ray 自己的版本任何疑惑，請參考 sample 裡頭的範例，以及官方文件如下:orderpayment order 跟 payment 的差異主要的差異如下： order： 只支援 PayPal 的會員。可以延後付款，並且視乎貨物的狀態做部分的請款 payment: 可以延後付款，但不可以分批請款。 詳細的介紹可以參考原文解說 建立訂單 ( order )public function createOrder($toBeSavedInfo, Recipient $recipient, $debug = false)&#123; // 引用SDK $request = new OrdersCreateRequest(); $request-&gt;headers[\"prefer\"] = \"return=representation\"; // 這邊的RequestBody等等會貼在下面 $request-&gt;body = self::buildRequestBody($toBeSavedInfo, $recipient); // 這邊引用剛剛設定好的 PayPalClient $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print \"Status Code: &#123;$response-&gt;statusCode&#125;\\n\"; print \"Status: &#123;$response-&gt;result-&gt;status&#125;\\n\"; print \"Order ID: &#123;$response-&gt;result-&gt;id&#125;\\n\"; print \"Intent: &#123;$response-&gt;result-&gt;intent&#125;\\n\"; print \"Links:\\n\"; foreach ($response-&gt;result-&gt;links as $link) &#123; print \"\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n\"; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), \"\\n\"; &#125; // 建立建立完成後，我只取讓使用者用來確認的連結，預設 PayPal 提供了很多的連結，但是其他的我們都可以靠 API 來達成。 foreach (($response-&gt;result-&gt;links) as $link) &#123; if ($link-&gt;rel === 'approve') &#123; $linkForApproval = $link-&gt;href; break; &#125; &#125; // 這邊取得建立訂單之後的一些會用到的資訊，然後 return $toBeSavedInfo['payment_id'] = $response-&gt;result-&gt;id; $toBeSavedInfo['statusCode'] = $response-&gt;statusCode; $toBeSavedInfo['custom_id'] = $response-&gt;result-&gt;purchase_units[0]-&gt;custom_id; $toBeSavedInfo['PayPal_total_amount'] = $response-&gt;result-&gt;purchase_units[0]-&gt;amount-&gt;value; $toBeSavedInfo['orderStatus'] = $response-&gt;result-&gt;status; $toBeSavedInfo['linkForApproval'] = $linkForApproval; return $toBeSavedInfo;&#125; 下面是建立訂單功能會用到的 RequestBodypublic static function buildRequestBody($toBeSavedInfo, Recipient $recipient)&#123; // 這邊的設定，使得我們可以在 PayPal 的付款頁面，看到多個商品的明細 $item = []; $i = 1; foreach ($toBeSavedInfo['orders'] as $order) &#123; $item[] = [ 'name' =&gt; $order-&gt;item_name, 'description' =&gt; $order-&gt;item_description, 'sku' =&gt; $i, 'unit_amount' =&gt; [ 'currency_code' =&gt; $toBeSavedInfo['mc_currency'], 'value' =&gt; $order-&gt;unit_price, ], 'quantity' =&gt; $order-&gt;quantity, ]; $i ++; &#125; // 這邊我們指定 intent ，我設在環境變數， return [ 'intent' =&gt; env('PAYPAL_SANDBOX_INTENT_OF_CREATED_ORDERS'), 'application_context' =&gt; [ 'return_url' =&gt; env('PAYPAL_SANDBOX_RETURN_URL'), 'cancel_url' =&gt; env('PAYPAL_SANDBOX_CANCEL_URL'), 'brand_name' =&gt; env('APP_NAME'), 'locale' =&gt; env('PAYPAL_SANDBOX_LOCALE'), 'landing_page' =&gt; env('PAYPAL_SANDBOX_LANDING_PAGE'), 'shipping_preferences' =&gt; env('PAYPAL_SANDBOX_SHIPPING_PREFERENCES'), 'user_action' =&gt; env('PAYPAL_SANDBOX_USER_ACTION'), ], // 這邊可以設定 purchase_unit ，一個 purchase_unit 裡面可以設定税、運費、等等，這邊省略 'purchase_units' =&gt; [ [ 'custom_id' =&gt; $toBeSavedInfo['merchant_trade_no'], 'amount' =&gt; [ 'currency_code' =&gt; $toBeSavedInfo['mc_currency'], 'value' =&gt; $toBeSavedInfo['total_amount'], 'breakdown' =&gt; [ 'item_total' =&gt; [ 'currency_code' =&gt; $toBeSavedInfo['mc_currency'], 'value' =&gt; $toBeSavedInfo['total_amount'], ], ], ], 'items' =&gt; $item, // 這邊可以指定收件人 'shipping' =&gt; array( 'name' =&gt; array( 'full_name' =&gt; $recipient-&gt;name, ), 'address' =&gt; array( 'address_line_1' =&gt; $recipient-&gt;others, 'admin_area_2' =&gt; $recipient-&gt;district, 'admin_area_1' =&gt; $recipient-&gt;city, 'postal_code' =&gt; $recipient-&gt;postcode, 'country_code' =&gt; $recipient-&gt;country_code, ), ), ], ], ];&#125; 授權 ( authorization )接下來，我們要使用 REST API 中的特別功能， Authorization 。 授權之後，我們有29天的時間可以使用 capture 來從使用者的帳戶裡面扣錢。 不過呢，雖然有效期限是29天，但是 PayPal 只能保證給予單次授權開始計算的三天內，使用者的帳戶裡頭會有足夠的金額。 意思就是說呢，在 authorization 開始計算的三天， PayPal 會暫時性的在付款方的 PayPal 帳戶中，凍結申請的款項，記住只有三天哦！ 這三天稱為 honor period 。 在首次的 authorization 之後，我們可以申請多次，最多10次的 authorization ，稱為 reauthorize 。如果你覺得這樣次數還是太少，可以通過跟 PayPal 客服聯絡的方式，將次數提升到最多99次！ 其實只要將時間算好，10次的授權應該很夠用了。平均三天授權一次，10次也一個月了，海運都到了！ 授權可以更改金額，最高可以授權115% 或 不超過 75 USD 的金額，如果運費或者稅務方面，或是其他原因造成費用有些許變動的話，可以透過重新授權來更改費用。 細節可以參考官方文件 授權的範例如下:記住這是 Ray 自己的版本，大家可以參考官方的範例，再依照自己的需求作更改，或者乾脆取SDK裡面的功能自己寫一個！ 這才是我認為的最佳解！ /** * This function can be used to perform authorization on the approved order. * Valid Approved order id should be passed as an argument. */ // 這邊我們可以變更授權的金額，根據你的需求public static function authorizeOrder($orderId, $amount = null, $debug = false)&#123; $request = new OrdersAuthorizeRequest($orderId); // RequestBody 跟上面提到的差不多，可以參考官方的範例！ $request-&gt;body = self::buildRequestBodyForAuthorizeOrder($amount); $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print \"Status Code: &#123;$response-&gt;statusCode&#125;\\n\"; print \"Status: &#123;$response-&gt;result-&gt;status&#125;\\n\"; print \"Order ID: &#123;$response-&gt;result-&gt;id&#125;\\n\"; print \"Authorization ID: &#123;$response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;id&#125;\\n\"; print \"Links:\\n\"; foreach ($response-&gt;result-&gt;links as $link) &#123; print \"\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n\"; &#125; print \"Authorization Links:\\n\"; foreach ($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;links as $link) &#123; print \"\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n\"; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), \"\\n\"; &#125; return $response;&#125; 授權之後呢，我們需要驗證授權是否成功，所以我利用回傳的response，寫一個驗證的 function，如下：public static function checkIfAuthorizedSuccessfully($response)&#123; $newPayPal = (new NewPayPal())-&gt;where('payment_id', request()-&gt;token)-&gt;first(); // 確認授權是否完成 if (($response-&gt;result-&gt;status) !== 'COMPLETED') return 'Authorization isn\\'t completed'; // 確認授權是否已開始 if (($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;status) !== 'CREATED') return 'Authorization was not created'; // 確認幣別是否一致 if (($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;amount-&gt;currency_code) !== ($newPayPal-&gt;mc_currency)) return 'The currency is mismatched'; // 確認授權金額是否正確。這邊是我自己的版本，有需要變動授權金額的話，這邊可以變一下。 if (intval($response-&gt;result-&gt;purchase_units[0]-&gt;payments-&gt;authorizations[0]-&gt;amount-&gt;value) !== ($newPayPal-&gt;total_amount)) return 'The total amount is not correct';&#125; 提款 ( capture ) 就像上面提到的，成功授權之後，我們可以在29天內隨時向買家請款。 不過 PayPal 只有保證三天買家帳戶裡頭會有足夠的金額，又稱 honor period 一般來說，我們只要把時間算好，可以透過 授權 以及 再次授權 ，將 這筆金額臨時凍結30天。 以下是提款 ( capture ) 的範例：public static function captureAuthorization(NewPayPal $newPayPal, $final_capture = false, $debug = false)&#123; $NewPayPal = (new NewPayPal)-&gt;where('merchant_trade_no', $newPayPal-&gt;merchant_trade_no)-&gt;first(); // 提款功能，需要帶入授權id $request = new AuthorizationsCaptureRequest($newPayPal-&gt;authorization_id); // 這邊帶入要提款的金額，如上所敘，提款金額是可以分批次的！ Final_capture 如果設定為true的話，會結束此次授權，此次授權之後無法再進行提款，若要提款需要再重新授權。 $request-&gt;body = self::buildRequestBodyForCaptureAuthorization($NewPayPal-&gt;to_be_captured_amount, $final_capture, $newPayPal-&gt;mc_currency); $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print \"Status Code: &#123;$response-&gt;statusCode&#125;\\n\"; print \"Status: &#123;$response-&gt;result-&gt;status&#125;\\n\"; print \"Capture ID: &#123;$response-&gt;result-&gt;id&#125;\\n\"; print \"Links:\\n\"; foreach ($response-&gt;result-&gt;links as $link) &#123; print \"\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n\"; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), \"\\n\"; &#125; return $response;&#125; 以下是提款 ( capture ) 的 RequestBodypublic static function buildRequestBodyForCaptureAuthorization($amount = null, $final_capture = false, $currency = 'USD')&#123; if ($amount != null) &#123; // 指定提款的金額與幣別，需要跟授權的一致 return [ \"amount\" =&gt; [ 'currency_code' =&gt; $currency, 'value' =&gt; $amount, ], 'final_capture' =&gt; $final_capture ]; &#125; return \"&#123;&#125;\";&#125; 以下是提款的邏輯Ray 的邏輯是設定一個提款期限來決定什麼時候提款，因為每次退款都會扣掉手續費，所以 Ray 的想法是利用金額凍結取代退款，在提款期限之前，如果買家申請退款的話， Ray 這邊只需要去更改要提款的最終數字，這樣就可以避免掉手續費的部分。 Ray 自己設定的容許退款期限為七天，所以 Ray 會將這筆金額凍結七天，在七天後等到一切都確定了再依照最終的提款金額一次提款。所以下面的function每天都會跑一次，如果已經過了提款期限就會真正執行提款，並更新該訂單在所有資料庫裡頭相對應的狀態。public static function dailyCaptureAuthorization()&#123; $toBeCapturedPayments = NewPayPal::whereNotNull(&apos;authorization_id&apos;)-&gt;whereNull(&apos;capture_id&apos;)-&gt;where(&apos;to_be_captured_date&apos;, &apos;&lt;&apos;, Carbon::now()-&gt;toDateTimeString())-&gt;get(); foreach ($toBeCapturedPayments as $toBeCapturedPayment) &#123; $response = NewPayPal::captureAuthorization($toBeCapturedPayment); if (($response-&gt;result-&gt;status) === &apos;COMPLETED&apos;) &#123; $toBeCapturedPayment-&gt;update([&apos;capture_id&apos; =&gt; $response-&gt;result-&gt;id, &apos;status&apos; =&gt; 7]); foreach ($toBeCapturedPayment-&gt;orderRelations as $orderRelation) &#123; if (($orderRelation-&gt;status == 5) || ($orderRelation-&gt;status == 6)) &#123; $orderRelation-&gt;order-&gt;update([&apos;status&apos; =&gt; 7]); $orderRelation-&gt;update([&apos;status&apos; =&gt; 7]); &#125; &#125; &#125; &#125;&#125; 退款 ( refund ) 退款的規則是，可以針對特定授權，進行一次性或者分批次的退款。 若屬於分批次，可以指定退款金額 若想要一次性，可以將整個 RequestBody 留空，像官方範例那樣public static function refundOrder($captureId, $amount, $currency, $debug = false)&#123; $request = new CapturesRefundRequest($captureId); // 這邊帶入指定的退款金額以及幣別，幣別必須要跟授權的一樣哦 $request-&gt;body = self::buildRequestBodyForRefundOrder($amount, $currency); $client = PayPalClient::client(); $response = $client-&gt;execute($request); if ($debug) &#123; print \"Status Code: &#123;$response-&gt;statusCode&#125;\\n\"; print \"Status: &#123;$response-&gt;result-&gt;status&#125;\\n\"; print \"Order ID: &#123;$response-&gt;result-&gt;id&#125;\\n\"; print \"Links:\\n\"; foreach ($response-&gt;result-&gt;links as $link) &#123; print \"\\t&#123;$link-&gt;rel&#125;: &#123;$link-&gt;href&#125;\\tCall Type: &#123;$link-&gt;method&#125;\\n\"; &#125; // To toggle printing the whole response body comment/uncomment below line echo json_encode($response-&gt;result, JSON_PRETTY_PRINT), \"\\n\"; &#125; return $response;&#125; 以下是退款的 RequestBodypublic static function buildRequestBodyForRefundOrder($amount = null, $currency = 'USD', $final_capture = false)&#123; // 若金額有指定就為指定值，若無指定便為預設格式 if ($amount != null) &#123; return [ \"amount\" =&gt; [ 'currency_code' =&gt; $currency, 'value' =&gt; $amount, ], 'final_capture' =&gt; $final_capture ]; &#125; return \"&#123;&#125;\";&#125; 退款的邏輯 相對應提款時所做的操作，在商家真正對買家做出提款之前，買家所申請的退款請求都只是去更改資料庫的數字。 如果過了七天，但實屬特殊案例，買家也還是可以申請退款，不過到時候就會有手續費產生 以上邏輯只適用於 PayPal ，因為本專案整合兩家金流，所以上面的邏輯並不適用於歐付寶，不過總體來說，對買家來說都是沒有影響的。public static function refund(Order $order, NewPayPal $paymentServiceInstance, OrderRelations $orderRelation)&#123; // 當該申請訂單為已授權，但尚未請款 if (($paymentServiceInstance-&gt;capture_id === null) &amp;&amp; ($paymentServiceInstance-&gt;authorization_id !== null)) &#123; // 如上所敘，我們只更新資料庫的請款金額 $paymentServiceInstance-&gt;update([ &apos;to_be_captured_amount&apos; =&gt; $paymentServiceInstance-&gt;to_be_captured_amount - $order-&gt;total_amount, &apos;total_amount&apos; =&gt; $paymentServiceInstance-&gt;total_amount - $order-&gt;total_amount ]); $order-&gt;update([&apos;status&apos; =&gt; 4]); $orderRelation-&gt;update([&apos;status&apos; =&gt; 4]); &#125; // 當該訂單已經請款了 if ($paymentServiceInstance-&gt;capture_id !== null) &#123; // 真正執行退款 API ，將款項退給買家 $response = self::refundOrder($paymentServiceInstance-&gt;capture_id, $order-&gt;total_amount, $paymentServiceInstance-&gt;mc_currency); // 如果退款確定成功，更新訂單狀態 if ($response-&gt;result-&gt;status == &apos;COMPLETED&apos;) &#123; $order-&gt;update([&apos;status&apos; =&gt; 4]); $orderRelation-&gt;update([&apos;status&apos; =&gt; 4]); $paymentServiceInstance-&gt;update([ &apos;total_amount&apos; =&gt; $paymentServiceInstance-&gt;total_amount - $order-&gt;total_amount ]); &#125; &#125;&#125; 取消授權取消方法非常簡單，只要使用官方範例，並且依照格式帶入授權的id就可以，這邊就不特別舉例！授權id在你成功授權的時候會回傳，在那時記得把它存起來！ 取得授權資料取得授權方法非常簡單，只要使用官方範例，並且依照格式帶入授權的id就可以，這邊就不特別舉例！授權id在你成功授權的時候會回傳，在那時記得把它存起來！ 取得提款資料取得提款方法非常簡單，只要使用官方範例，並且依照格式帶入提款的id就可以，這邊就不特別舉例！提款id在你成功提款的時候會回傳，在那時記得把它存起來！ 總結依照官方文件， PayPal REST API 是可以搭配 JavaScript 的 Smart Button 一起使用的，不過 Ray 負責的是後端的角色，所以這一部分就沒有深究。看起來還蠻有趣的！有興趣的可以花時間研究一下！PayPal 不愧是國際的金流系統，各項的支援都十分全面以及功能也十分多樣，可惜已經退出台灣了！不過據了解應該是因為相關法令的關係，退出在另一個角度來說也是在捍衛台灣的稅法，未嘗不是一件好事，這邊就不多做評論。這陣子算是針對 PayPal 的金流深入的研究了一下，當然還有許多比較細緻的功能因為時間的關係還沒有去接觸到，待之後有時間有機會再來好好研究，再把心得過程都記錄下來分享給大家！ 歡迎轉載，但麻煩請註明出處，感謝！","link":"/zh-tw/PayPalRestAPI/"},{"title":"Cloud Storage 初探 - CLI/SDK","text":"概述Google Cloud Storage 提供世界級的儲存服務並且你可以在任何時間取回任何大小的資料。 Google Cloud Storage 提供了很多的使用情況, 包含網站內容, 歸檔類型或是災後復原類型的資料儲存, 或是提供使用者大檔案物件直接下載的方式。 在這個手把手教程中, 你將會學習到如何使用 Google Cloud Platform 命令列工具 來建立一個儲存區, 然後上傳物件, 建立資料夾以及子資料夾, 以及讓這些物件可被公開存取。 在本教程中, 你將能夠在主控台的 Navigation menu &gt; Storage 核對你的進度。 你只需要在每一個指令之後重整你的瀏覽器來檢視你建立的新項目 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個儲存區執行 gsutil mb 指令並取代 unique name 來建立一個儲存區gsutil mb gs://YOUR-BUCKET-NAME/ 命名規則： 不要有機敏資訊，因為儲存區的名字是公開可被大家看到的 儲存區的名字一定只可以有 小寫字母 ,數字, -, _, ., 若是名字含有 ., 需要驗證 儲存區的名字必須由數字或字母來開始以及結束 儲存區的名字必須含有 3 到 63 的字元，含有 . 的名字最多 222 個字元，但是每個被 . 分開的字元，最多不可超過 63 字元。 儲存區的名字不可以帶點十進制的方式表示，像是 IP 位址 (例如, 192.168.5.4) 儲存區的名字不可由 goog 開頭 儲存區的名字不可含有 google 或近似字串 還有，為了符合 DNS 命名規則以及之後的相容性，不可使用 _, 或是兩個 . 相連，或與 dash 相連，例如 .., 或 -., 或 .-, 這些都不符合 DNS 命名規則 如果成功執行，回應如下：Creating gs://YOUR-BUCKET-NAME/... 你已經建立一個可以用來儲存你的東西的儲存區備註: 如果名字已經被使用了，可能是你或別人，回應如下Creating gs://YOUR-BUCKET-NAME/... ServiceException: 409 Bucket YOUR-BUCKET-NAME already exists. 用別的名字在試一次 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 每個儲存區中，都有一個預設的儲存類別，你可以在建立的時候指定它 true false 上傳一個物件到你的儲存區現在上傳一個物件到你的儲存區 先下載這個圖片到暫時性的 instance (ada.jpg) 到 Cloud Shellwget --output-document ada.jpg https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Ada_Lovelace_portrait.jpg/800px-Ada_Lovelace_portrait.jpg 使用 gsutil cp 指令, 從本地儲存的位置上傳圖片到你建立的儲存區中： gsutil cp ada.jpg gs://YOUR-BUCKET-NAME 訣竅: 當你輸入你的儲存區的名字, 可以使用 tab 來自動補齊你可以從 Command Line 看到圖片被上傳了，你已經完成了儲存一個物件在你的儲存區中!現在讓我們刪掉它rm ada.jpg 從儲存區下載物件使用 gsutil cp 指令, 將你存在儲存區的圖片下載到 Cloud Shellgsutil cp -r gs://YOUR-BUCKET-NAME/ada.jpg . 如果成功的話，應會回傳如下：Copying gs://YOUR-BUCKET-NAME/ada.jpg.../ [1 files][299.6 KiB/299.6 KiB]Operation completed over 1 objects/299.6 KiB. 你剛剛已經完成了從儲存區下載圖片！ 複製一個物件到儲存區內的一個資料夾使用 gsutil cp 指令來建立一個名為 image-folder 的資料夾，並且將圖片（ada.jpg) 複製過去gsutil cp gs://YOUR-BUCKET-NAME/ada.jpg gs://YOUR-BUCKET-NAME/image-folder/ 備註: 與本地的文件系統相比，在 Google Cloud Storage 的資料夾有一些限制, 但很多相同的操作是都有支援的。 如果成功的話，應該會回傳如下： Copying gs://YOUR-BUCKET-NAME/ada.jpg [Content-Type=image/png]...- [1 files] [ 299.6 KiB/ 299.6 KiB]Operation completed over 1 objects/299.6 KiB 現在，圖片已經被複製到儲存區內的新的資料夾內 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功上傳物件到 cloud storage 的資料夾的話，你將看到一個評定的分數 列出儲存區或資料夾內的內容gsutil ls gs://YOUR-BUCKET-NAME 如果成功，回傳應如下： gs://YOUR-BUCKET-NAME/ada.jpggs://YOUR-BUCKET-NAME/image-folder/ 這些是目前在儲存區內的東西 列出物件的細節使用 gsutil ls 指令, 配合 -l flag 來取得我們上傳圖片的細節資訊： gsutil ls -l gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，應會回傳： 306768 2017-12-26T16:07:570Z gs://YOUR-BUCKET-NAME/ada.jpgTOTAL: 1 objects, 30678 bytes (299.58 KiB) 現在你知道圖片的大小和建立的日期了 讓物件可被公開存取使用 gsutil acl ch 指令來給予全部使用者對儲存區內的物件有讀的權限 gsutil acl ch -u AllUsers:R gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，應該會回傳： Updated ACL on gs://YOUR-BUCKET-NAME/ada.jpg 你的圖片目前已經可被公開存取 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功的從 cloud storage 分享物件，你將看到一個評定的分數 驗證你的圖片是否公開可被存取。 到 Navigation menu > Storage , 然後點擊你的儲存區。 你應會看到你圖片的公開存取格子是有被打勾的，點擊檔案，然後圖片將會在瀏覽器的新視窗被開啟 測試你的理解程度底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 存取控制清單 Access Control List (ACL) 是一種可用來定義誰可以存取你的儲存區的一種機制 true false 移除公開存取權限若要移除被存取的權限，使用以下指令 gsutil acl ch -d AllUsers gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，回傳應像是：Updated ACL on gs://YOUR-BUCKET-NAME/ada.jpg 現在你已經移除對這物件的公開存取權限，你可以驗證看看，點擊控制面板中的 Refresh 按鈕。打勾符號將會被移除，這時如果你重新整理圖片，會出錯 測試你的理解程度底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧你可以藉由移除什麼樣的權限屬性來停止公開分享物件： allUsers 移除 project owner role 更新儲存區類別 刪除物件使用 gsutil rm 來移除一個物件 - 在儲存區中的圖片gsutil rm gs://YOUR-BUCKET-NAME/ada.jpg 如果成功，回傳應會如下：Removing gs://YOUR-BUCKET-NAME/ada.jpg... 重新刷新面板。 複製的圖片檔案已經不存在 Cloud Storage 了 （儘管複製在 image-folder 資料夾內還是存在唷） 恭喜!你已經完成本教程","link":"/zh-tw/cloudStorageQwikStartCLISDK/"},{"title":"Cloud Storage 初探 - 主控台","text":"概述Google Cloud Storage 提供世界級的儲存服務並且你可以在任何時間取回任何大小的資料。 Google Cloud Storage 提供了很多的使用情況, 包含網站內容, 歸檔類型或是災後復原類型的資料儲存, 或是提供使用者大檔案物件直接下載的方式。 在這個手把手教程中, 你將會學習到如何使用 Google Cloud Platform 主控台來建立一個儲存區, 然後上傳物件, 建立資料夾以及子資料夾, 以及讓這些物件可被公開存取。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 建立一個儲存區在控制面板，到 Navigation menu &gt; Storage &gt; Browser, 點擊建立儲存區 名字： 為你的儲存區建立一個特別的名字命名規則： 不要有機敏資訊，因為儲存區的名字是公開可被大家看到的 儲存區的名字一定只可以有 小寫字母 ,數字, -, _, ., 若是名字含有 ., 需要驗證 儲存區的名字必須由數字或字母來開始以及結束 儲存區的名字必須含有 3 到 63 的字元，含有 . 的名字最多 222 個字元，但是每個被 . 分開的字元，最多不可超過 63 字元。 儲存區的名字不可以帶點十進制的方式表示，像是 IP 位址 (例如, 192.168.5.4) 儲存區的名字不可由 goog 開頭 儲存區的名字不可含有 google 或近似字串 還有，為了符合 DNS 命名規則以及之後的相容性，不可使用 _, 或是兩個 . 相連，或與 dash 相連，例如 .., 或 -., 或 .-, 這些都不符合 DNS 命名規則 儲存種類： 多區域地區: United States 如果你已經設定好你的儲存區，按下建立 就這麼簡單，你已經建立了一個 Cloud Storage 儲存區 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 在整個 Cloud Storage 的命名空間裡，每個儲存區都要有一個獨一無二的名字 true false Cloud Storage 提供以下哪四種儲存區類別？ Nearline Storage Local storage Multi-Regional Storage Cross region storage Regional Storage Coldline Storage 上傳一個物件到儲存區在這個章節中，你將在儲存區中增加一個物件，在這個 lab 中，這個物件是一個圖片 取得圖片。 點擊這個 Ada Lovelace 的連結, 然後儲存圖片到你的本地電腦 儲存區的細節畫面應還會開著，將圖片拖曳到細節畫面處， Drop files here 你應該可以看到圖片被列在儲存區清單中 從儲存區中刪除圖片，勾選檔名旁的空格然後點擊 Delete, 然後再按一次 Delete 確認刪除 在上傳一次檔案，這次點擊 Upload files 從本地電腦中找到圖片，然後點擊 Open 你應該會看到圖片被列在儲存區清單中 重新命名檔案。點擊下拉式清單（三個平行的點） 在圖片列的最右邊，然後點擊 rename 你可能需要變寬你的瀏覽器視窗來顯示下拉式清單 上傳檔案，更名為 ada.jpg, 然後點擊 RENAME 你應會看到 ada.jpg 在你的儲存區中 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 物件的名稱只需要在一個儲存區中獨一無二 true false 公開分享物件點擊下拉式清單來取得這個物件的公開存取連結 從下拉式選單中，選擇 Edit permission 在出現的對話格中，點擊 + Add item 按鈕 完成以下的操作來開放權限給所有人 為此實體選擇 User 名字輸入 AllUsers 存取部分選擇 Reader 然後點擊 Save 一旦公開分享，一個連結的圖案會出現在公開存取欄位-點擊連結在新的視窗打開檔案 測試是否完成點擊 check my progress 來驗證任務是否完成。如果你已經成功完成 Cloud Storage 儲存區，你將看到一個評定的分數 建立資料夾在這個章節中，你將建立資料夾 在接近頁面頂端，點擊 Create Folder 連結 取名為 folder1, 然後點擊 Create 你應會看到資料夾出現在儲存區中，而且以不同的圖示來與物件作區分 建立子資料夾現在你將在 folder1 當中建立一個資料夾，並且上傳一個檔案 點擊 folder1, 在頁面頂端處點擊 create Folder 命名為 folder2, 並點擊 Create 點擊剛剛建立的 folder2 將圖片 Ada Lovelace 從本地電腦拖過去 Drop files here 上傳後，你將看到這個圖片列在 subfolder 中 重新命名檔案為 ada.jpg 點擊下拉式清單來取得這個物件的公開存取連結 從下拉式選單中，選擇 Edit permission 在出現的對話格中，點擊 + Add item 按鈕 完成以下的操作來開放權限給所有人 為此實體選擇 User 名字輸入 AllUsers 存取部分選擇 Reader 然後點擊 Save 一旦公開分享，一個連結的圖案會出現在公開存取欄位-點擊連結在新的視窗打開檔案 刪除資料夾在這個章節中，你將從儲存區中移除 folder1 還有他的內容 移動回 Buckets/[你的儲存區]。 你將看到 folder1 列在儲存區內容清單 勾選檔名旁的空格然後點擊 Delete, 然後再按一次 Delete 確認刪除 folder1 還有他的內容將永遠從你的儲存區中刪除 Congratulations!你已經完成本課程。","link":"/zh-tw/cloudStorageQwikStartConsole/"},{"title":"在 GCP 上建立一個 persistent disk","text":"概述Google Compute Engine 讓你在 Google 的基礎設施上建立以及運行虛擬機。 你可以在建立運行著不同作業系統的虛擬機，包含不同偏好的 Linux (Debian, Ubuntu, Suse, Red Hat, CoreOS) 以及 Windows Server Google Compute Engine 提供 persistent disks, 這是虛擬機上的主要儲存空間。 就像是實體的硬碟一樣， persistent disks 可獨立存在於你的虛擬機 - 如果一台虛擬機被刪除了，附加的 persistent disk 將可以持續將資料留住，並且可以附加到其他的虛擬機上。 Persistent disks 有兩種： 一般persistent diskSSD persistent disk 更多兩者差異的資訊，可以參考 Storage Options 。 兩種類型的 persistent type 有其不同的容量限制，更多資訊請參考 Persistent Disk 官方文件 本篇將會做什麼？ 建立一個新的 VM instance ，然後在其新增 persistent disk 掛載並格式化 persistent disk 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記原文請參閱Refer to official link 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 VM instance 建立一個名為 ‘gcelab’ 的新虛擬機 instance gcloud compute instances create gcelab --zone us-central1-c 新建的VM instance將有內建10GB的初始化disk 建立新的 persistent disk 在 Cloud Shell 中輸入以下指令，注意 zone 參數需與 VM instance 一致gcloud compute disks create mydisk --size=200GB --zone us-centrall-c 在運轉中的 VM instance 上新增剛建立的 persistent diskgcloud compute instances attach-disk gcelab --disk mydisk --zone us-central1-c 在 VM instance 上找到剛剛新增的 persistent disk SSH 到 virtual machinegcloud compute ssh gcelab --zone us-central1-c 輸入y繼續 如果需要設定密碼，可以輸入密碼 在 /dev/disk/by-id/ 下找到 disk 裝置 ls -l /dev/disk/by-id/ 找到預設裝置名稱如下: scsi-0Google_PersistentDisk_persistent-disk-1. 如果你想要一個不一樣的裝置名稱，當你在新增 disk 時，你可以加入裝置名稱參數 gcloud compute instances attach-disk gcelab --disk mydisk --device-name yourDeviceName --zone us-central1-c 格式化，並且掛載 persistent disk 在找到裝置後，我們可以將 disk 分區，格式化，並且掛載 建立一個掛載點sudo mkdir /mnt/mydisk 使用 mkfs 工具，格式化 disk 為 ext4 格式，這個指令將會刪除指定 disk 下的所有資料 sudo mkfs.ext4 -F -E lazy_itable_init=0,lazy_journal_init=0,discard /dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 利用 mount 工具，掛載 disk sudo mount -o discard,defaults /dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 /mnt/mydisk 設定自動掛載 預設值中，在 VM instance 重新啟動之後， persistent disk 並不會自動掛載，我們需要在/etc/fstab檔案中增加一些輸入 sudo vim /etc/fstab 在開頭是 UUID 那段程式碼之後，加入： /dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 /mnt/mydisk ext4 defaults 1 1 此時，你的 /etc/fstab 應該看起來要像這樣:UUID=e084c728-36b5-4806-bb9f-1dfb6a34b396 / ext4 defaults 1 1/dev/disk/by-id/scsi-0Google_PersistentDisk_persistent-disk-1 /mnt/mydisk ext4 defaults 1 1 按:wq 小習題： Can you prevent the destruction of an attached persistent disk when the instance is deleted? No, attached persistent disks are always associated with the lifetime of the instance. Yes, deselect the option Delete boot disk when instance is deleted when creating an instance Yes, use the -keep-disks option with the gcloud compute instances delete command For migrating data from a persistent disk to another region, reorder the following steps in which they should be performed: Attach disk Create disk Create snapshot Create instance Unmount file system(s) (4, 1, 2, 3, 5) (2, 3, 1, 4, 5) (1, 3, 2, 4, 5) (5, 3, 2, 4, 1) 非必要指令 顯示活躍中帳戶gcloud auth list 顯示project idgcloud config list project","link":"/zh-tw/createAPersistentDisk/"},{"title":"使用 Spinnaker 在 Kubernetes Engine 中實作持續交付管道","text":"概述在本教程中, 你將會學到如何使用 Google Kubernetes Engine, Google Cloud Source Repositories, Google Cloud Container Builder, 以及 Spinnaker 來建立持續交付管道。 在你建立範例應用之後, 你將設定這些服務, 使他們可以自動建立, 測試, 以及部署。當你修改了應用的程式碼, 這個變更會觸發持續交付管道, 使用新的版本來重新建立, 測試, 以及部署。 目標 藉由啟動 Google Cloud Shell 來設定你的環境, 在裡面建立 Kubernetes Engine 叢集, 設定你的身份以及使用者管理方案 下載範例應用, 建立一個 Git 倉庫, 然後上傳到 Google Cloud Source Repository 使用 Helm 將 Spinnaker 部署到 Kubernetes Engine 建立你的 Docker 鏡像 建立觸發者, 當你的應用變更時, 會建立 Docker 鏡像 設定 Spinnaker 管道來可靠的, 持續地將應用部署到 Kubernetes Engine 部署一個變更過的程式碼, 觸發管道, 然後檢視滾動更新到正式環境的過程 管道結構你需要一個能夠可靠的建立, 測試, 以及更新軟體的自動化的程序來持續地將你的應用更新到使用者手上。 程式碼變更需要全自動化的經由一個管道, 這個管道包含成品建立, 單元測試, 功能測試, 以及正式環境部署。在某些情況下, 你會想要一個程式碼更新只作用到某部分的用戶, 這樣一來, 這個更新就可以在應用到所有用戶之前實際的先跑過了一次。 如果其中一個 canary 發佈確定不太適合, 你的自動化程序必須要能夠很快的將它回復到更新前的版本。 使用 Kubernetes Engine 以及 Spinnaker, 你可以建立一個可信賴的持續交付流程, 這個流程可以幫你確保你的軟體在開發以及核對之後, 可正確的被交付。 儘管快速部署是我們的最終目標, 但在更新的版次成為正式環境的選項之一之前, 我們必須確保它通過了所有的自動化驗證。 當更新通過了所有的自動化驗證, 你也可以再進行手動驗證, 以及更進一步的實施發布前的測試。 在你的團隊確定這個應用已經可以上正式環境了, 團隊中的其中一個成員可以手動核准這次的正式環境部署。 應用交付管道在本教程中, 你將建立一個如下圖般的持續交付管道 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 設定環境設定本教程中需要的基礎設施以及身份。 首先, 你將建立 Kubernetes Engine 叢集來部署 Spinnaker 以及範例應用 設定預設 zone gcloud config set compute/zone us-central1-f 使用 Spinnaker 教學範例, 建立一個 Kubernetes Engine gcloud container clusters create spinnaker-tutorial \\ --machine-type=n1-standard-2 這個部署將會耗費 5 到 10 分鐘。 你可能會看到一個預設範圍的警告, 你可以忽略他們, 因為對本教程沒有影響。 等待部署完成。 完成之後, 你會看到一些細節資訊, 像是名稱, 地區, 版本, ip-address, 機器類型, node 版本, node 數量, 以及叢集的狀態顯示該叢集已經處於運行中 設定身份以及存取管理建立一個 Cloud Identity Access Management (Cloud IAM) service account 來賦予 Spinnaker 權限, 允許它可以將資料存到 Cloud Storage 。 Spinnaker 將管道資料儲存到 Cloud Storage 以確保可靠度以及復原能力。 如果你的 Spinnaker 部署無預期的失敗了, 你可以利用存取相同管道內的資料, 在幾分鐘內建立一個相同的部署。 經由以下步驟來上傳啟動腳本到 Cloud Storage 建立 service account: gcloud iam service-accounts create spinnaker-account \\--display-name spinnaker-account 將 service account 的 email 以及目前的專案 ID 存到環境變數, 之後的指令會用到 export SA_EMAIL=$(gcloud iam service-accounts list \\ --filter=\"displayName:spinnaker-account\" \\ --format='value(email)') export PROJECT=$(gcloud info --format='value(config.project)') 賦予 service account storage.admin 的角色 gcloud projects add-iam-policy-binding $PROJECT \\--role roles/storage.admin \\--member serviceAccount:$SA_EMAIL 下載 service account 的 key 。 在之後的步驟, 你將會安裝 Spinnaker 以及上傳這個 key 到 Kubernetes Engine: gcloud iam service-accounts keys create spinnaker-sa.json \\--iam-account $SA_EMAIL (輸出) created key [12f224e036437704b91a571792462ca6fc4cd438] of type [json] as [spinnaker-sa.json] for [spinnaker-account@qwiklabs-gcp-gcpd-f5e16da10e5d.iam.gserviceaccount.com] 設定 Cloud Pub/Sub 來觸發 Spinnaker 管道 建立 Cloud Pub/Sub 主題來接收 Container Registry 的通知 gcloud pubsub topics create projects/$PROJECT/topics/gcr 建立一個訂閱, 所以 Spinnaker 可以讀取並接收到鏡像已被推送的通知 gcloud pubsub subscriptions create gcr-triggers \\--topic projects/$&#123;PROJECT&#125;/topics/gcr 給予 Spinnaker 的 service account 權限, 所以它可以讀取 gcr-triggers 的訂閱 export SA_EMAIL=$(gcloud iam service-accounts list \\--filter=\"displayName:spinnaker-account\" \\--format='value(email)') gcloud beta pubsub subscriptions add-iam-policy-binding gcr-triggers \\ --role roles/pubsub.subscriber --member serviceAccount:$SA_EMAIL 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成環境設定，你將獲得一個評價分數。 使用 Helm 部署 Spinnaker在本節中, 你會使用 Helm 從 Charts 倉庫來部署 Spinnaker 。 Helm 是一個套件管理器, 你可以用它來設定以及部署 Kubernetes applications 安裝 Helm 下載以及安裝 helm 二進制檔 wget https://storage.googleapis.com/kubernetes-helm/helm-v2.10.0-linux-amd64.tar.gz 解壓縮到本地系統 tar zxfv helm-v2.10.0-linux-amd64.tar.gz cp linux-amd64/helm . 給予 Tiller 在叢集中 cluster-admin role 的權限, Tiller 是 Helm 的伺服器端 kubectl create clusterrolebinding user-admin-binding \\--clusterrole=cluster-admin --user=$(gcloud config get-value account) kubectl create serviceaccount tiller \\--namespace kube-system kubectl create clusterrolebinding tiller-admin-binding \\--clusterrole=cluster-admin --serviceaccount=kube-system:tiller 賦予 Spinnaker cluster-admin 的權限, 所以 Spinnaker 可以部署資源到所有的命名空間上 kubectl create clusterrolebinding --clusterrole=cluster-admin \\--serviceaccount=default:default spinnaker-admin 安裝 Helm 以及 Tiller 到叢集, Tiller 是 Helm 的 Server 端 ./helm init --service-account=tiller ./helm repo update 輸入以下指令, 確定 Helm 已經正確安裝了。 如果 Helm 安裝正確, client 端及 server 端都會輸出 v2.10.0./helm version (輸出) Client: &amp;version.Version&#123;SemVer:&quot;v2.10.0&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;&#125;Server: &amp;version.Version&#123;SemVer:&quot;v2.10.0&quot;, GitCommit:&quot;618447cbf203d147601b4b9bd7f8c37a5d39fbb4&quot;, GitTreeState:&quot;clean&quot;&#125; 設定 Spinnaker 還是在 Cloud Shell, 建立一個儲存區讓 Spinnaker 可以儲存管道設定資料 export PROJECT=$(gcloud info \\--format='value(config.project)') export BUCKET=$PROJECT-spinnaker-config gsutil mb -c regional -l us-central1 gs://$BUCKET 輸入以下指令來建立 spinnaker-config.yaml 檔, 該檔告訴 Helm 該如何安裝 Spinnaker export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format='value(config.project)')export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFgcs: enabled: true bucket: $BUCKET project: $PROJECT jsonKey: '$SA_JSON'dockerRegistries:- name: gcr address: https://gcr.io username: _json_key password: '$SA_JSON' email: 1234@5678.com# Disable minio as the default storage backendminio: enabled: false# Configure Spinnaker to enable GCP serviceshalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_gcs_artifacts.sh: |- \\$HAL_COMMAND config artifact gcs account add gcs-$PROJECT --json-path /opt/gcs/key.json \\$HAL_COMMAND config artifact gcs enable enable_pubsub_triggers.sh: |- \\$HAL_COMMAND config pubsub google enable \\$HAL_COMMAND config pubsub google subscription add gcr-triggers \\ --subscription-name gcr-triggers \\ --json-path /opt/gcs/key.json \\ --project $PROJECT \\ --message-format GCREOF 部署 Spinnaker chart 使用 Helm 命令列介面, 用設定檔來部署 chart ./helm install -n cd stable/spinnaker -f spinnaker-config.yaml \\--timeout 600 --version 1.1.6 --wait 這個指令大概會需要 5~6 分鐘 完成 在指令完成後, 輸入以下指令來設定從 Cloud Shell 到 Spinnaker 的 port 轉發規則 export DECK_POD=$(kubectl get pods --namespace default -l \"cluster=spin-deck\" \\-o jsonpath=\"&#123;.items[0].metadata.name&#125;\") kubectl port-forward --namespace default $DECK_POD 8080:9000 &gt;&gt; /dev/null &amp; 這個指令會花好幾分鐘完成。 再繼續之前, 確認他已經完成了。 點擊 Cloud shell 視窗上方的 Web Preview 圖案, 並選擇 Preview on port 8080 來打開 Spinnaker 使用者介面 會先看到歡迎畫面, 然後是 Spinnaker 使用者介面 保持這個視窗開啟, 這是我們存取 Spinnaker UI 的地方 測試進度點擊 Check my progress 來確認目前的進度。如果你已經正確的使用 Kubernetes Helm 部署 Spinnaker chart，你將獲得一個評價分數。 建立 Docker 鏡像在本節中, 你將設定 Cloud Build 來偵測程式碼變更, 建立 Docker 鏡像, 然後推送到 Container Registry 建立源碼倉庫 在 Cloud Shell, 下載範例應用源碼 wget https://gke-spinnaker.storage.googleapis.com/sample-app-v2.tgz 解壓縮 tar xzfv sample-app-v2.tgz 進到源碼目錄 cd sample-app 設定在 Git 當中的 username 以及 email, 將 [USERNAME] 替換成你自己的 git config --global user.email \"$(gcloud config get-value core/account)\" git config --global user.name \"[USERNAME]\" 做第一個 commit git init git add . git commit -m \"Initial commit\" 建立源碼倉庫 gcloud source repos create sample-app 如果看到你可能會被收費的訊息, 請無視 git config credential.helper gcloud.sh 將剛剛建立的源碼倉庫設為遠端 export PROJECT=$(gcloud info --format='value(config.project)') git remote add origin https://source.developers.google.com/p/$PROJECT/r/sample-app 推送程式碼到新的倉庫的 master 分支 git push origin master 在主控台點擊 Navigation Menu &gt; Source Repositories, 確認你可以看到你的源碼 點擊 sample-app 設定建立觸發者設定 Container Builder, 所以每次你推送 Git tags 到你的源碼倉庫時, 會自動建立以及推送 Docker 鏡像。 Container Builder 會自動切換到你的程式碼, 依照你倉庫中的 Dockerfile 來建立 Docker 鏡像, 然後推送鏡像到 Google Cloud Container Registry 在 Cloud Platform 主控台, 點擊 Navigation menu &gt; Cloud Build &gt; Triggers 點擊 Create trigger 選擇 Cloud Source Repository, 然後點擊 Continue 選擇你新建立的 sample-app 倉庫, 然後點擊 Continue 設定以下的觸發設定 Name: sample-app-tags Trigger type: Tag Tag (regex): v.* Build configuration: Cloud Build configuration file (yaml or json) cloudbuild.yaml location: /cloudbuild.yaml 點擊 Create trigger 從現在開始, 只要你推送一個帶有前綴為 “v” 的 Git tag 到你的源碼倉庫, Container Builder 會自動的建立並推送應用的 Docker 鏡像到 Container Registry 準備將使用在 Spinnaker 的 Kubernetes Manifests (Kubernetes 的部署文件)要部署到你的集群, Spinnaker 需要存取你的 Kubernetes manifests 。 本節中會建立一個 Cloud Storage 儲存區, 這個儲存區會在 Cloud Build 的 CI 過程中載入 manifest 。 當你的 manifest 被存在 Cloud Storage 之後, Spinnaker 可以在整個管道執行過程中, 下載以及應用它 建立儲存區 export PROJECT=$(gcloud info --format='value(config.project)')gsutil mb -l us-central1 gs://$PROJECT-kubernetes-manifests 啟用儲存區的 versioning (物件版本管理), 所以我們將有整個 manifests 的歷史 gsutil versioning set on gs://$PROJECT-kubernetes-manifests 在 Kubernetes deployment manifests 中設定正確的 project ID sed -i s/PROJECT/$PROJECT/g k8s/deployments/* 提交 commit 到倉庫 git commit -a -m \"Set project ID\" 建立鏡像按照以下步驟, 推送你的第一個鏡像 在 Cloud Shell, sample-app 資料夾, 建立一個 Git tag: git tag v1.0.0 推送 tag git push --tags (輸出)To https://source.developers.google.com/p/qwiklabs-gcp-ddf2925f84de0b16/r/sample-app* [new tag] v1.0.0 -&gt; v1.0.0 到 GCP 主控台。 在 Cloud Build, 點擊左方面板的 History, 確認 build 是否已經被觸發。 若否, 確認在之前的章節中, trigger 有正確的被設定 先在此頁面等待, 待 build 完成, 再到下一個章節 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Docker 鏡像，你將獲得一個評價分數。 設定部署管道現在你的鏡像已經自動地被建立, 你需要將他們部署到 Kubernetes 叢集部署到規模縮減的環境來實施整合測試。 整合測試通過後, 手動核准這次的變更來將代碼部署到正式生產服務。 安裝 spin CLI 來管理 Spinnakerspin 是用來管理 Spinnaker 的應用以及管道的命令列工具 下載 1.6 版本的 spin curl -LO https://storage.googleapis.com/spinnaker-artifacts/spin/1.6.0/linux/amd64/spin 使 spin 可執行 chmod +x spin 建立部署管道 使用 spin, 在 Spinnaker 建立一個叫做 sample 的應用。 設定使用者 email./spin application save --application-name sample \\ --owner-email \"$(gcloud config get-value core/account)\" \\ --cloud-providers kubernetes \\ --gate-endpoint http://localhost:8080/gate 請忽略 Cloud not read configuration file... 輸出訊息 接下來, 建立一個持續交付管道。 在本教程中, 管道被設定偵測, 當一個前綴為 “v” 的 tag 被推送到我們的 Container Registry 在 sample-app 程式碼資料夾, 執行以下命令來更新範例管道到 Spinnaker instanceexport PROJECT=$(gcloud info --format='value(config.project)')sed s/PROJECT/$PROJECT/g spinnaker/pipeline-deploy.json &gt; pipeline.json./spin pipeline save --gate-endpoint http://localhost:8080/gate -f pipeline.json 請忽略 Cloud not read configuration file... 輸出訊息 手動觸發以及檢視你的管道執行狀況當有鏡像被推送且有符合規則的新標籤時, 我們剛剛建立的設定會觸發 Spinnaker 管道。 在之前的步驟中, 我們推送一個標籤到 Cloud Source Repositories, 然後觸發 Cloud Build 來建立以及推送我們的鏡像到 Container Registry 。 要核准這個管道, 手動觸發它 在 Spinnaker UI 介面, 在螢幕最上方點擊 Application 來檢視被管理應用的清單。 sample 是我們的應用。 如果你沒看到 sample, 嘗試重刷新 Spinnaker Application 頁面 點擊 sample 來檢視你的應用部署 在上方點擊 Pipelines 來檢視你的應用管道狀態 點擊 Start Manual Execution 來首次觸發管道 點擊 Run 點擊 Details 來檢視管道進度的更多資訊 進度條顯示部署管道的狀態以及階段 藍色部分為目前正在運行中, 綠色為已經成功完成, 紅色為已經失敗的 點擊一個階段來看細節資訊在 3 ~ 5 分鐘 後, 整合測試階段完成, 且管道需要手動核准來持續部署 在游標停在黃色的”人形”圖案上, 並且點擊 Continue 你的推送持續的到正式環境的前端以及後端部署。 它在幾分鐘後完成。 在 Spinnaker UI 的上方選擇 **Infrastructure &gt; Load Balancers 來檢視 app 下捲 load balancers 清單並且在 service sample-frontend-production 下點擊 Default 在右方 details 面板下捲並且在 Ingress IP 點擊 clipboard 按鈕來複製你的 app IP 位址。 Spinnaker UI 頁面的 ingress IP 預設為 HTTPS, 儘管應用是被設定使用 HTTP 將位址貼到一個新的視窗來檢視應用的正式版本 現在你已經手動的觸發管道建立, 測試, 以及部署你的應用 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立服務平衡負載，你將獲得一個評價分數。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功部署鏡像到正式環境，你將獲得一個評價分數。 從程式碼變更來觸發你的管道現在讓我們改變程式碼, 推送一個 Git 標籤, 以及檢視管道執行的回應來從端對端的測試管道。 藉由推送前綴為 “v” 的 Git 標籤來觸發 Container Builder 建立一個新的 Docker 鏡像, 然後將它推送到 Container Registry 。 Spinnaker 將偵測是否有新的有著 Git 標籤為 “v” 的鏡像被推送, 然後觸發管道來部署鏡像到 canaries, 運行 tests, 然後推送一樣的鏡像到所有 deployment 中的所有 pods 在 sample-app 資料夾, 將 app 的顏色從 orange 改成 blue sed -i 's/orange/blue/g' cmd/gke-info/common-service.go 將變更的 commit 貼上標籤並且推送到程式碼倉庫 git commit -a -m \"Change color to blue\"git tag v1.0.1git push --tags 在主控台, Cloud Build &gt; History, 等待幾分鐘待新的 build 完成。 到下一個步驟之前, 你可能需要重整你的頁面, 等待新的 build 完成 回到 Spinnaker UI 並點擊 Pipelines 來檢視管道正開始部署。 自動被觸發的管道將需要幾分鐘才會顯示在頁面上, 你可能需要重刷新頁面。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功從程式碼變更觸發管道，你將獲得一個評價分數。 觀察 canary 部署 當部署停下, 等待推送到正式環境時, 我們回到網頁顯示運行中的應用並且重整頁面。 後端中有 四個正運行之前版本的應用, 而只有一個後端運行 canary 。 你可以看到那個藍色新版本的應用大概每重整五次會出現一次 在測試完成後, 回到 Spinnaker 頁面, 點擊 Continue 來核准部署 當管道完成後, 你的 app 看起來會像以下的截圖一樣。 注意到顏色都已經變成藍色因為你的程式碼變了, 而且 Version 欄位目前顯示 production 你已經成功地將你的 app 推送到整個正式環境 你也可以藉由取消當前版本來取消變更。 取消當前版本並且新增一個標籤, 然後經由同一個管道部署 git revert v1.0.1git tag v1.0.2git push --tags 當 build 以及管道完成, 點擊 Infrastructure &gt; Load Balancers 來核准這次的回滾, 然後點擊 service sample-frontend-canary Default, 然後複製 Ingress IP 位址到新的視窗 現在你的應用已經回到橘色, 且你可以看到 canary 的版本號 恭喜你已經完成本教程 Q&amp;A 以下 gcloud 指令的意思? gcloud iam service-accounts create spinnaker-account \\--display-name spinnaker-account 建立一個名為 spinnaker-account 的 service account --display-name: 好記的名稱為 spinnaker-account 以下 gcloud 指令的意思? export SA_EMAIL=$(gcloud iam service-account list \\--filter=\"displayName:spinnaker-account\" \\--format='value(email)') export: 將 SA_EMAIL 的值變成環境變數 --filter: 取得 displayName 為 spinnaker-account 的那一行 --format: 取得上面那行 email 的值 以下 gcloud 指令的意思? export PROJECT=$(gcloud info --format='value(config.project)') --format: 取得 info 輸出中的 config property 下的 project 可使用 –format=json 來檢視, 會比較清楚 以下 gcloud 指令的意思? gcloud projects add-iam-policy-binding $PROJECT \\--role roles/storage.admin \\--member serviceAccount:$SA_EMAIL 在指定專案中, 新增 add-iam-policy-binding policy 是 binding 的集合 binding 綁定了一個或多個 member 到一個單獨的 role --role: 賦予 roles/storage.admin 的角色 --member: 透過 service account 綁定這個 member 到這個專案 以下 gcloud 指令的意思? gcloud iam service-accounts keys create spinnaker-sa.json \\--iam-account $SA_EMAIL 建立一把 service account 的 private key service account 為 $SA_EMAIL $SA_EMAIL 為 spinnaker-account 的 email 以下 gcloud 指令的意思? gcloud pubsub topics create projects/$PROJECT/topics/gcr 建立一個 topic, 名為 project/$PROJECT/topics/gcr 以下 gcloud 指令的意思? gcloud pubsub subscriptions create gcr-triggers \\--topic projects/$&#123;PROJECT&#125;/topics/gcr 建立一個 subscriptions, 名為 gcr-triggers 接收的 topic 為 project/${PROJECT}/topics/gcr 以下 gcloud 指令的意思? gcloud beta pubsub subscriptions add-iam-policy-binding gcr-triggers \\ --role roles/pubsub.subscriber --member serviceAccount:$SA_EMAIL 在 gcr-triggers 這個 subscriptions 建立一個政策繫結 role 為 pubsub 的 subscriber member 為 spinnaker 的 service account 以下 kubectl 指令的意思? kubectl create clusterrolebinding user-admin-binding \\--clusterrole=cluster-admin --user=$(gcloud config get-value account) 建立一個叢集角色綁定, 名為 user-admin-binding 叢集角色為 cluster-admin, 為系統內建角色 user 為預設帳號的擁有者 tiller 跟 helm 的關係？如下圖, Helm 為 client 端, Tiller 為 server 端 以下 kubectl 指令的意思? kubectl create clusterrolebinding --clusterrole=cluster-admin \\--serviceaccount=default:default spinnaker-admin 建立一個叢集角色綁定 綁定的角色的叢集預設的 cluster-admin serviceaccount 為 default 命名空間下的 default service account 該綁定的名稱為, spinnaker-admin 以下 helm 指令的意思? ./helm init --service-account=tiller 安裝 tiller 到 server 端 使用 service-account 名為 tiller 以下 gsutil 指令的意思? gsutil mb -c regional -l us-central1 gs://$BUCKET gsutil: google storage utility mb: make a bucket -c: class, 儲存空間等級 -l: location, 位置 gs://$BUCKET: 儲存區的名稱 以下的 spinnaker 的 yaml 檔中, gcs 的區塊部分代表什麼意思？設定預設儲存後端為 gcs, 可參考官方文件 export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format='value(config.project)')export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFgcs: enabled: true bucket: $BUCKET project: $PROJECT jsonKey: '$SA_JSON' 以下的 spinnaker 的 yaml 檔中, dockerRegistries 的區塊部分代表什麼意思？設定 docker registry 為 Google Container Registry, 可參考官方文件 export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format='value(config.project)')export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFdockerRegistries:- name: gcr address: https://gcr.io username: _json_key password: '$SA_JSON' email: 1234@5678.com Spinnaker 的預設儲存服務為？minio, 可參考文件 Spinnaker 的 artifact 是什麼？代表一個參考外部資源的物件, 可參考文件 以下的 Spinnaker 指令是什麼意思？ 啟用 GCP pubsub 服務 增加一個名為 gcr-trigger 的 subscription 到 pubsub subscription 的 name 為 gcr-trigger 可參考文件export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format='value(config.project)')export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFhalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_pubsub_triggers.sh: |- \\$HAL_COMMAND config pubsub google enable \\$HAL_COMMAND config pubsub google subscription add gcr-triggers \\ --subscription-name gcr-triggers \\ --json-path /opt/gcs/key.json \\ --project $PROJECT \\ --message-format GCREOF 以下的 Spinnaker 指令是什麼意思？ 啟用 GCS 服務 增加一個 artifact account 到 GCS provider 可參考文件export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format='value(config.project)')export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFhalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_gcs_artifacts.sh: |- \\$HAL_COMMAND config artifact gcs account add gcs-$PROJECT --json-path /opt/gcs/key.json \\$HAL_COMMAND config artifact gcs enableEOF 以下的指令中, |- 代表什麼意思？ | 為 Block Style Indicator, literal style, 如果 string 當中有空行, 會被保留下來 - 為 Block Chomping Indicator, strip style, 在 string 結尾不保留任何空行 可參考文件 可參考 Stackoverflow 可參考範例export SA_JSON=$(cat spinnaker-sa.json)export PROJECT=$(gcloud info --format='value(config.project)')export BUCKET=$PROJECT-spinnaker-configcat &gt; spinnaker-config.yaml &lt;&lt;EOFhalyard: spinnakerVersion: 1.10.2 image: tag: 1.12.0 additionalScripts: create: true data: enable_gcs_artifacts.sh: |- \\$HAL_COMMAND config artifact gcs account add gcs-$PROJECT --json-path /opt/gcs/key.json \\$HAL_COMMAND config artifact gcs enable enable_pubsub_triggers.sh: |- \\$HAL_COMMAND config pubsub google enable \\$HAL_COMMAND config pubsub google subscription add gcr-triggers \\ --subscription-name gcr-triggers \\ --json-path /opt/gcs/key.json \\ --project $PROJECT \\ --message-format GCREOF 以下的 helm 指令是什麼意思？ ./helm install -n cd stable/spinnaker -f spinnaker-config.yaml \\--timeout 600 --version 1.1.6 --wait -n: namespace 為 cd -f: file 為 spannaker-config.yaml –timeout: timeout 600 秒 –version: 版本 1.1.6 –wait: helm 會等待所有的 Pods 都 ready, PVCs 掛載, 部署有達到最小數量, 狀態為 ready 的 Pods, server 有 IP 位址, 可參考文件 以下指令的意思是？ export DECK_POD=$(kubectl get pods --namespace default -l \"cluster=spin-deck\" \\-o jsonpath=\"&#123;.items[0].metadata.name&#125;\") export: 將輸出設為環境變數 –namespace: 取得該 namespace 中的資源 -l: selector(label) -o: 指定輸出格式 以下指令的意思是？ kubectl port-forward --namespace default $DECK_POD 8080:9000 &gt;&gt; /dev/null &amp; port-forward: 轉發 port 指令 –namespace: 指定命名空間 $DECK_POD: port 的名稱 8080:9000: 指定外面的 8080 port 到 pod 的 9000 port, 再將輸出隱藏。 以下指令的用途是？git config credential.helper gcloud.sh 正常來說, 新增一個遠端 git 倉庫會需要設定 ssh 金鑰, 上面指令可以省略這個步驟, 讓我們可以使用我們在 gcloud 的 key 來做到這件事 以下指令的意思是？sed -i s/PROJECT/$PROJECT/g k8s/deployments/* 找到 PROJECT, 並把他替換成 $PROJECT, $PROJECT 為事先設好的變數, 尋找對象為 k8s/deployments/ 下面所有的檔案 Spinnaker 中, spin 是什麼？spinnaker 的 CLI 管理工具 以下的程式碼代表什麼意思? export PROJECT=$(gcloud info --format='value(config.project)')sed s/PROJECT/$PROJECT/g spinnaker/pipeline-deploy.json &gt; pipeline.json./spin pipeline save --gate-endpoint http://localhost:8080/gate -f pipeline.json 利用 gcloud 指令取得 project, 在帶入變數 PROJECT 並將之變成環境變數 sed 指令將 pipeline-deploy.json 檔案中的 PROJECT 替換為上一部取得的 $PROJECT 變數的值, 在複製一份到新檔案 pipeline.json 使用 spin 建立一個 pipeline, 參數為上一部建立的檔案 pipeline.json, gate-endpoint 會通往遠端部署 spinnaker 的機器 以下的 cloud build 設定黨的意思是？ steps:- name: 'gcr.io/cloud-builders/docker' args: ['build', '--tag=gcr.io/$PROJECT_ID/sample-app:$TAG_NAME', '.']- name: 'gcr.io/cloud-builders/docker' args: ['run', 'gcr.io/$PROJECT_ID/sample-app:$TAG_NAME', 'go', 'test']- name: 'gcr.io/cloud-builders/gsutil' args: ['cp', '-r', 'k8s/*', 'gs://$PROJECT_ID-kubernetes-manifests']images: ['gcr.io/$PROJECT_ID/sample-app:$TAG_NAME'] steps: 建構執行步驟 name: 雲端建構工具, 可參考文件, 以及文件 args: 會被傳送至 name 欄位參照的建構工具。 若建構工具擁有進入點, 則 args 為 args, 若否, 則第一個 args 為進入點。 images: 要傳送到 Container Registry 的鏡像, 可參考文件 以及 文件 以下的 gsutil 指令是什麼意思？ gsutil versioning set on gs://$PROJECT-kubernetes-manifests 啟用物件版本管理功能, 啟用後, 每當物件的使用中版本遭到複寫或刪除, Cloud Storage 會為該物件建立一個封存版本, 可參考文件","link":"/zh-tw/continuousDeliveryPipelinesWithSpinnakerAndKubernetesEngine/"},{"title":"Kubernetes - Health Check","text":"概述本篇會示範如何設定 liveness probe(存活探針), readiness probe(就緒探針), 以及 startup probe(啟動探針)。 kubelet 使用 liveness probe 來決定何時重啟容器, 舉例來說, 當你的應用處於運行中, 但是卻無法處理 request。 kubelet 使用 readiness probe 來決定這個容器是否已經準備就緒, 可以接收流量了。 當一個 Pod 內的所有容器都就緒了, 該 Pod 才算是就緒。 如果一個 Pod 尚未就緒, 它將會從 Service 負載平衡的後端清單中被移除。kubelet 使用 startup probe 來決定一個容器應用是否已經成功啟動了。 當 startup probe 判定為 success 之前, liveness probe 跟 readiness probe 是沒有作用的。 這可以用在某些會花比較久時間來啟動的應用, 這樣就不會在還沒啟動完成前就因為 liveness 判定失敗而給殺掉了。 本篇主要是個人學習 Kubernetes health check 的一篇筆記, 內容你會看到很多很多的 Q&amp;A, 因為 Ray 個人習慣將長篇的理論知識切割成零碎 Q&amp;A, 適合我個人學習吸收, 考試都考 100 分呢！ 定義存活探針指令許多應用長時間運行後, 就陷入一個壞掉的狀態, 這時候唯有重啟才可恢復。 Kubernetes 提供了 liveness probe 來偵測並且排除這樣的狀況讓我們啟動一個 Pod, 這個 Pod 會運行 k8s.gcr.io/busybox 鏡像, 以下是該 Pod 的設定檔:apiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-execspec: containers: - name: liveness image: k8s.gcr.io/busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 這邊針對上面的 yaml file 做解說： periodSeconds: liveness probe 多久檢查一次 initialDelaySeconds: 首次啟動後, 要延遲多久在執行 cat /tmp/healthy: livenessProbe 會執行這段執行, 如果成功則回傳 0, 其他都是失敗。 當容器啟動時, 會執行 /bin/sh -c &quot;touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600&quot;, 會先建立 /tmp/healthy, 然後 sleep 30 秒, 所以在這 30 秒間, /tmp/healthy 是存在的。 30 秒後會把 /tmp/healthy 砍了, 然後 sleep 600 秒, 在這 600 秒間, 指令會回傳錯誤 接著來實際操作一回: 建立 Pod kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml 頭 30 秒, 執行以下指令檢視 Pod 事件： kubectl describe pod liveness-exec 輸出未顯示 liveness probe 失敗 FirstSeen LastSeen Count From SubobjectPath Type Reason Message--------- -------- ----- ---- ------------- -------- ------ -------24s 24s 1 &#123;default-scheduler &#125; Normal Scheduled Successfully assigned liveness-exec to worker023s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulling pulling image &quot;k8s.gcr.io/busybox&quot;23s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulled Successfully pulled image &quot;k8s.gcr.io/busybox&quot;23s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Created Created container with docker id 86849c15382e; Security:[seccomp=unconfined]23s 23s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Started Started container with docker id 86849c15382e 35 秒後, 在檢視一次 kubectl describe pod liveness-exec 輸出可以看到, liveness probe 失敗了 FirstSeen LastSeen Count From SubobjectPath Type Reason Message--------- -------- ----- ---- ------------- -------- ------ -------37s 37s 1 &#123;default-scheduler &#125; Normal Scheduled Successfully assigned liveness-exec to worker036s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulling pulling image &quot;k8s.gcr.io/busybox&quot;36s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Pulled Successfully pulled image &quot;k8s.gcr.io/busybox&quot;36s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Created Created container with docker id 86849c15382e; Security:[seccomp=unconfined]36s 36s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Normal Started Started container with docker id 86849c15382e2s 2s 1 &#123;kubelet worker0&#125; spec.containers&#123;liveness&#125; Warning Unhealthy Liveness probe failed: cat: can&apos;t open &apos;/tmp/healthy&apos;: No such file or directory 在等 30 秒, 看容器有沒有被重啟 kubectl get pod liveness-exec 看來是重啟了, 並且重啟次數加一 NAME READY STATUS RESTARTS AGEliveness-exec 1/1 Running 1 1m 定義 liveness HTTP requestliveness probe 另外一種方式為 HTTP request, 以下設定檔為運行鏡像 k8s.gcr.io/liveness 的 PodapiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-httpspec: containers: - name: liveness image: k8s.gcr.io/liveness args: - /server livenessProbe: httpGet: path: /healthz port: 8080 httpHeaders: - name: Custom-Header value: Awesome initialDelaySeconds: 3 periodSeconds: 3 針對以上的設定檔做解釋: periodSeconds: 每 3 秒檢查一次 initialDelaySeconds: 容器啟動後, 要延遲 3 秒再開始探針 這次探針實施的方式為傳送 HTTP GET request 到 server 的 port 8080 如果 /haalthz 回傳 200~399, 則表示成功, 其餘都失敗 如果有興趣可以去看此鏡像的原始碼, 如以下程式碼, 10 秒後開始回傳 500, 10 秒內回傳 200 http.HandleFunc(&quot;/healthz&quot;, func(w http.ResponseWriter, r *http.Request) &#123; duration := time.Now().Sub(started) if duration.Seconds() &gt; 10 &#123; w.WriteHeader(500) w.Write([]byte(fmt.Sprintf(&quot;error: %v&quot;, duration.Seconds()))) &#125; else &#123; w.WriteHeader(200) w.Write([]byte(&quot;ok&quot;)) &#125;&#125;) kubelet 會在容器啟動後 3 秒開始探測, 所以一開始的健康健康會是 success 的, 但是 10 秒後就會開始 fail, 然後 kubelet 會把容器殺掉並且重啟 以下實際試試 HTTP liveness check 建立 Pod kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml 10 秒後, 檢視 liveness probe 事件, 可以發現已經失敗並且又重啟了 kubectl describe pod liveness-http 在版本 v1.13 之前 (包含 v1.13), 如果在 node 有設定 http_proxy (或 HTTP_PROXY) 環境變數, 則 HTTP liveness 會使用這個 proxy, v1.13 之後的版本不會影響 HTTP liveness probe 定義 TCP liveness probe第三種 liveness probe 使用 TCP Socket, 如下設定檔, kubelet 會嘗試在你容器上的一個特定的 port 開啟一個 socket, 如果可以建立連線, 則成功, 反之則視為失敗apiVersion: v1kind: Podmetadata: name: goproxy labels: app: goproxyspec: containers: - name: goproxy image: k8s.gcr.io/goproxy:0.1 ports: - containerPort: 8080 readinessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 periodSeconds: 10 livenessProbe: tcpSocket: port: 8080 initialDelaySeconds: 15 periodSeconds: 20 以下依序來解釋上面設定檔的步驟： TCP 檢查跟 HTTP 檢查很類似 這個範例同時使用了 readiness probe 以及 liveness probe 容器啟動五秒後, kubelet 會發送第一個 readiness 探測 readiness 探測會嘗試連結 goproxy 容器的 port 8080, 如果成功, 表示該容器 ready kubelet 會持續的每十秒做一次檢查 kubelet 會在容器啟動十五秒後, 發送第一個 liveness 探測 liveness 探測會嘗試連結 goproxy 容器的 port 8080, 如果失敗, 容器會被重新啟動 liveness probe 每二十秒探測一次 以下可以實際操作看看： 建立 Pod kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml 十五秒後, 檢視 Pod 事件來看看 liveness 的狀態: kubectl describe pod goproxy 使用命名 port在 HTTP 或 TCP liveness 檢查中, 你可以使用一個命名過的 port, 如下ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port 使用 startup probes 來保護啟動較慢的容器某些時候, 你可能會碰到會花較久時間在容器首次啟動的應用, 這個時候你不需要提高 liveness probe 的失敗門檻, 你可以使用 startup probe, 重點就是, 設定 failureThreshold * periodSeconds 的時間, 這個時間要長於正常應用啟動可能耗費的最大時間, 如下範例：ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 以下針對上面的配置檔做解說: 應用會有最長五分鐘的啟動時間 (30 * 10 = 300s) 一旦 startup probe 被判定為成功, liveness probe 會接手, 從原本擁有高容許失敗門檻啟動偵測變成一次失敗就重啟的卡死偵測 如果 startup probe 一直失敗, 那超過 300s 後, 容器會被殺掉, 並視乎 restartPolicy 看是否重啟 定義 readiness probes某些時候, 應用會暫時的無法處理流量, 舉例來說, 當在啟動時載入大量資料或是設定檔時, 或是在啟動後依賴外部服務時。 在這些情況下, 你不需要殺掉容器, 但你需要暫時的不將請求送往這些容器。 Kubernetes 提供了 readiness probe 來解決這個問題, 如果一個 Pod 被 readiness probe 回報 not ready 的話, 那該 Pod 將不會收到來自於 Kubernetes Services 的流量Readiness probe 的運行是不間斷的Readiness probe 的設定基本上跟 liveness probe 差不多, 只差在 readinessProbe 換成 livenessProbe, 如下：readinessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 Readiness probe 跟 liveness probe 可以一起使用, 避免一些狀況, 例如說該容器暫時還無法處理流量, 但還收到 Service 的請求, 這時候 liveness probe 探測失敗, 就直接將容器殺掉了。 設置 Probes以下介紹幾個 Probes 的 field, 更精確的控制 livenss 跟 readiness 的檢查行為 intialDelaySeconds: 在容器首次啟動時, 控制 liveness probe 或 readiness probe 開始探測的延遲時間, 預設為 0 秒, 最小為 0 periodSeconds: 多久探測一次, 預設 10 秒, 最短 1 秒 timeoutSeconds: 幾秒沒收到回應時判斷為失敗, 預設 1 秒, 最短 1 秒 successThreshold: 在檢查被判定失敗後, 接下來要多少次連續判定成功才算成功, 預設 1 次, liveness 必須設為 1 次, 最小可設為 1 次 failureThreshold: 當 Pod 被偵測到失敗時, Kubernetes 會持續嘗試直到滿足此欄位設定的次數, 這樣才算失敗, 套用在 liveness probe 上就是重啟容器, 而套用在 readiness probe 上就是標示該容器為 unready, 預設為 3 次, 最小可設為 1 次 以下介紹幾個 HTTP probes, 可設在 httpGet 的欄位： host: 要連結的 host name, 預設為 pod IP, 相比在 httpHeaders 中設定, 你可能會想要使用這一個欄位來設定 scheme: 連接到 host 的 scheme (HTTP 或 HTTPS), 預設為 HTTP path: 存取 HTTP server 的路徑 httpHeaders: 客製化設定請求的 header, HTTP 允許重複的 header port: 可以使用 port number 或已命名的 port, 如果是 port number, 範圍須介於 1 ~ 65535 針對上面的 HTTP probes 行為做補充解釋: 如果使用 HTTP probe, kubelet 會發送 HTTP 請求到指定的 path 以及 port 來做檢查 kubelet 預設使用 pod 的 IP 位址, 除非在 host 欄位有特別指定 如果 scheme 欄位設為 HTTPS, 則 kubelet 會發送 HTTPS 請求, 並且略過憑證檢查 大部分的情況, 你不會去設定 host 欄位, 除非以下特殊情況 假如你的容器監聽 127.0.0.1, 然後 pod 的 hostNetwork 欄位為 true, 那 httpGet 下的 host 欄位需設定為 127.0.0.1 如果你的 pod 取決於 virtual hosts, 你不可使用 host 欄位, 而是要設定 httpHeaders 欄位中的 Host header TCP probe 中, kubelet 是在 node 中建立連線, 不是在 pod 中, 所以 host 欄位中不可使用 service name, 否則 kubelet 將無法解析它 參考資料 官方文件 Fantastic Probes And How To Configure Them — A Kubernetes Story Q&amp;A Kubernetes 中, 當我使用 TCP probe 時我無法在 httpGet 下的 host 使用 service name, 為什麼？因為 kubelet 是在 node 建立 connection, 並非在 pod Kubernetes 中, 如果我將 httpGet 下的 scheme 欄位設置為 HTTPS, 那會怎麼樣？kubelet 會發送 HTTPS 請求且會略過憑證驗證 Kubernetes 中, 預設 httpGet 下的 host 是什麼？pod 的 ip kubernetes 中, failureThreshold 預設為幾次?3 次 kubernetes 中, successthreshold 在 liveness probe 必須設為多少？1 Kubernetes 中, 健康檢查可以設定最短多久檢查一次？1 秒 Kubernetes 中, 健康檢查預設幾秒檢查一次？10 秒 Kubernetes 中, startup probe 解決了什麼問題？對於啟動時間較長的應用可以有高容許失敗門檻, 一旦啟動完成後, 切換成低失敗容許門檻的 liveness probe Kubernetes 中, liveness probe 可以解決什麼問題？一個 container 有在運行, 但是卻無法正常運作 Kubernetes 中, 如果一個 pod 裡頭有一個 container 沒通過 readiness probe, 那這個 pod 算 ready 嗎？不算 Kubernetes 中, readiness probe 的作用是？決定容器是否已準備開始接受流量 Kubernetes 中, 一個尚未通過 readiness probe 的 container, 會被列在 service load balancers 的後端之一嗎？不會 Kubernetes 中, startup probe 的作用是？判斷一個容器何時完成啟動 Kubernetes 中, 如果 startup probe 尚未通過, readiness probe 或 liveness probe 會開始運作嗎？不會哦 請試著解釋以下 kubernetes yaml file 中的每一條 directive ？ yaml file: apiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-execspec: containers: - name: liveness image: k8s.gcr.io/busybox args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 periodSeconds: 5 Answer: # API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 labels, 可被 selector 選擇, 為 key/value pair labels: test: liveness # 該 pod 的 name name: liveness-exec# 該 pod 運行的規格spec: # 定義容器 containers: # 容器名稱 - name: liveness # 鏡像名稱 image: k8s.gcr.io/busybox # 容器啟動後運行的指令 args: - /bin/sh - -c - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600 # 存活探針 livenessProbe: # 探測方式為 exec, 執行指定的 command, 若回傳值非為 0, 則視為失敗 exec: # 定義 command command: - cat - /tmp/healthy # 首次啟動容器時, 探針延遲 5 秒, 以等待所有資源準備就緒 initialDelaySeconds: 5 # 每五秒探測一次 periodSeconds: 5 Kubernetes 中, health check 有哪三種探針？ startup probe liveness probe readiness probe 試著解釋以下 kubernetes yaml file 中的每一條 directive yaml file: apiVersion: v1kind: Podmetadata: labels: test: liveness name: liveness-httpspec: containers: - name: liveness image: k8s.gcr.io/liveness args: - /server livenessProbe: httpGet: path: /healthz port: 8080 httpHeaders: - name: Custom-Header value: Awesome initialDelaySeconds: 3 periodSeconds: 3 Answer: # API 版本apiVersion: v1# 種類為 podkind: Pod# 該 pod 的 metadatametadata: # 該 pod 的 label, 可被選擇器選擇, 為自定義 key/value pair labels: test: liveness # 該 pod 的 name name: liveness-http# 該 pod 運行規格spec: # 定義容器 containers: # 容器名稱 - name: liveness # 鏡像名稱 image: k8s.gcr.io/liveness # 容器啟動後執行的指令 args: - /server # 存活探針 livenessProbe: # 探測類型為 httpGet, 就像是透過呼叫一支 API 並取得回應來判斷是否運作正常 httpGet: # API 位址 path: /healthz # API port 號 port: 8080 # 定義 header httpHeaders: # header name - name: Custom-Header # header value value: Awesome # 首次啟動時, delay 3 秒以待資源就緒 initialDelaySeconds: 3 # 每 3 秒探測一次 periodSeconds: 3 Kubernetes liveness probe 中, 若使用 httpGet, 怎樣的回應算是成功？status code 200 &gt;= 成功 &lt; 400 試著解釋以下的 Kubernetes yaml file 中的每一條 directive yaml file: apiVersion: v1kind: Podmetadata: name: goproxy labels: app: goproxyspec: containers: - name: goproxy image: k8s.gcr.io/goproxy:0.1 ports: - containerPort: 8080 readinessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 periodSeconds: 10 livenessProbe: tcpSocket: port: 8080 initialDelaySeconds: 15 periodSeconds: 20 Answer: # API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 pod 的 name name: goproxy # 該 pod 的 label, 可被 selector 選擇, 為自定義的 key/value pair labels: app: goproxy# 該 pod 的運行規格spec: # 定義容器 containers: # 容器名稱 - name: goproxy # 鏡像名稱 image: k8s.gcr.io/goproxy:0.1 # 定義 port ports: # 容器 port 為 8080 - containerPort: 8080 # 定義 readiness 探針 readinessProbe: # 探測類型為 tcpSocket tcpSocket: # 探測的 port port: 8080 # 首次啟動容器時, 延遲 5 秒 initialDelaySeconds: 5 # 每 10 秒探測一次 periodSeconds: 10 # 定義存活探針 livenessProbe: # 探測方式為 tcpSocket tcpSocket: # 探測的 port 為 8080 port: 8080 # 首次啟動容器時, 延遲 15 秒 initialDelaySeconds: 15 # 每 20 秒探測一次 periodSeconds: 20 請解釋以下的 Kubernetes yaml file 中的 directives yaml file: ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port Answer: # 定義 portports: # port name- name: liveness-port # port 號 containerPort: 8080 # 宿主機 port 號 hostPort: 8080# 定義存活探針livenessProbe: # 定義類型為 httpGet httpGet: # API 位址 path: /healthz # 使用定義好的 port port: liveness-port Kubernetes 中, 如果我有一個應用可能啟動需要長一點啟動時間, 舉例來說, 可能容器啟動之後, 應用還需要一段時間才會正常運作, 那我可以使用什麼 probe 來讓 liveness probe 可以在應用啟動完成後馬上開始探測？使用 startup probe 以下的 Kubernetes yaml file 中, 如果超過了 300 秒都沒有成功, Kubernetes 會如何處置這個 pod? yaml file: ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 Answer:該容器會被砍掉 以下的 Kubernetes yaml file 中, 如果 startupProbe 成功了, Kubernetes 會如何處置這個 pod? yaml file: ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 Answer:livenessProbe 會開始運作, 接手探測工作 請解釋以下 Kubernetes yaml file 中的每一條 directive yaml file: ports:- name: liveness-port containerPort: 8080 hostPort: 8080livenessProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 1 periodSeconds: 10startupProbe: httpGet: path: /healthz port: liveness-port failureThreshold: 30 periodSeconds: 10 Answer: # 定義 portports: # port name- name: liveness-port # 容器 port containerPort: 8080 # 宿主機 port hostPort: 8080# 定義存活探針livenessProbe: # 定義 httpGet 方式 httpGet: # 呼叫的 path path: /healthz # 呼叫的 port, 使用上面定義的 port port: liveness-port # 失敗一次就算失敗 failureThreshold: 1 # 每 10 秒探測一次 periodSeconds: 10# 定義 startup 探針startupProbe: # 定義 httpGet httpGet: # 探測 path path: /healthz # 探測 port port: liveness-port # 失敗 30 次才算失敗 failureThreshold: 30 # 每 10 秒探測一次 periodSeconds: 10 Kubernetes 中, 當 readiness probe 失敗, 會怎麼樣？將不會從 Kubernetes Service 收到 traffic Kubernetes 中, 當我使用 httpGet 探測方式時, 該探測行為在 pod 還是在 node?pod Kubernetes 中, 當我使用 tcpSocket 探測方式時, 該探測行為在 pod 還是在 node?node Kubernetes 中, 當 startup probe 失敗, 會怎麼樣？該 pod 會被 killed","link":"/zh-tw/config-liveness-readiness-startup-probes/"},{"title":"在 GCP 上開立一台虛擬機","text":"本篇將會做什麼？ 利用 GCP 主控台建立一個 virtual machine 利用 gcloud command line 建立一個 virtual machine 在 virtual machine 上部署一個 web server 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記原文可參閱Refer to official link 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 理解 Regions 和 Zones 特定的 Compute Engine 資源位於特定的 regions 或 zones. Region 表示一個你可以運行你的資源的特定地理位置。 每個 region 都有一個或多個 zones，舉例來說，us-central1 region 位於 Central United States，並且下面有 us-central1-a, us-central1-b, us-central1-c, us-central1-f 這些 zones 位於 zone 的資源算是 zonal 資源。 Virtual machine instance 還有 persistent disk 都位於 zone, 如果要在一個 virtual machine 上加一個 persistent disk，那兩者必須位於同一個 zone 很類似的，如果你要分配一個 static IP 位址到一個 instance，這個 instance 必須要跟這個 static IP 同一個 region 從 Cloud Console 建立一個新的 instance Navigation menu &gt; Compute Engine &gt; VM instance 按 create 欄位 值 額外資訊 name gcelab region us-central1(Iowa) or asia-south1(Mumbai) 更多regions的資訊 zone us-central1-c or asia-south1-c 注意：記住你選擇的 zone, 待會會用到 更多zone的資訊 Machine Type 2 vCPUs 這是一個(n1-standard-1), 1-CPU, 3.75GB RAM instance 有很多種類型可以選擇，從基礎型的到 32-core/208GB RAM 的都有，更多資訊可以參考機型種類文件 一個新專案有所謂的resource quota, 他會限制可以開立的機型規格。我們可以要求更高規格的機型在此 lab 之外 Boot Disk New 10 GB standard persistent disk OS Image: Debian GNU/Linux 9 (Stretch) 有很多種類的 images 可以選擇，包含 Debian, Ubuntu, CoreOS，以及一些高級的iamges，像是 RedHat Enterprise, Linux，和 Windows Server, 更多資訊可以參考作業系統文件 Firewall 勾選 Allow HTTP traffic 勾選這個選項，所以我們等等才能存取安裝好的 server 注意：這會自動建立防火牆規則，容許 HTTP 80 port 通道 點擊 Create 點擊 SSH, 經由瀏覽器連到 virtual machine 注意：更多資訊可以參考文件 安裝 NGINX web server 經由 SSH 連接 virtual machine 之後，先取得 root 權限 sudo su - 更新 OS apt-get update 安裝 NGINX apt-get install nginx -y 確認 NGINX 正常運行中 ps auwx | grep nginx 現在我們可以經由點擊 Cloud Console 上的 External IP 連結按鈕，或者直接在瀏覽器上輸入http://EXTERNAL_IP/ IP位址來連結到 Server 的網頁 使用 gcloud 來建立一個 instance除了使用 GCP 主控台之外，我們也可以使用 gcloud 的 command line 工具來建立一個 virtual machine instance, 這個工具已經事先被安裝在 Google Cloud Shell 中了。Cloud Shell 是一台以 Debian 為基礎的 virtual machine, 預載有所有你需要的開發工具 (gcloud, git, 還有其他的等等), 並且提供 5GB persistent disk 的 home 目錄如果你之後想要在自己的機器上嘗試看看，可以參考gcloud command line tool guide 在 Cloud Shell, 利用 command line gloud 工具建立一台新的 virtual machine instance gcloud compute instances create gcelab2 --zone us-central1-c 建立的 instance 將會有以下的預設值 最新的 Debian 9 image n1-standard-1 machine type, 在這個 lab 中，你可以選擇其他的 machine type, 像是 n1-highmen-4 或 n1-highcpu-4, 如果你在做這個 lab 之外的專案，你可以選擇客製化的 machinee type 預設的 persistent disk 名稱將與此 instance 一樣，並自動加到此 instance 使用 gcloud compute instances create --help 檢視所有預設 如果你總是使用同一個區域，你可以將指定的地區設為預設，這樣就不需要每次都要使用--zone參數gcloud config set compute/zone gcloud config set compute/region 檢視你的 instance, Navigation menu &gt; Compute Engine &gt; VM instances 最後，你可以使用 gcloud 經由 SSH 連線到你的 instance, 當你在連接時，確定一下後面的 zone 是跟你當初建的時候指定的一樣，或者如果你已經使用的上述的指定默認指令，那就不需要在指定一次。 gcloud compute ssh gcelab2 --zone us-central1-c 選 y 繼續 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： Through which of the following ways you can create a VM instance in Google Compute Engine(GCE)? Through web console The gcloud command line tool.","link":"/zh-tw/createAVirtualMachineInGCP/"},{"title":"建立紀錄指標並基於紀錄指標建立警告","text":"概述Logs-based metrics (紀錄指標) 是由 Stackdriver Monitoring 提供的, 基於記錄數據內容的指標。 他可以幫你發現動向, 從紀錄中取出數字數據, 還有建立一個特定的指標來完成事件觸發, 這樣當特定的記錄數據出現時, 就可以發出警告。 在 Stackdriver Monitoring 服務中, 你可以同時使用系統提供的指標, 或是使用者自定義的紀錄指標來建立圖表以及警告政策。 紀錄指標是由紀錄的資料產生的時間序列, 在本教程中你將會動手實作上面所提到的。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立本教程所需的資源本教程中所需的第一個資源是一個產生紀錄的 app。 你將會部署一個 App 到 App Engine, 然後建立一些 url 的運作時間檢查讓 App 紀錄使用以下的指令來複製 app 的範例到你的 GCP 專案中：git clone https://github.com/GoogleCloudPlatform/appengine-guestbook-python cd appengine-guestbook-python/ cloudgcloud app create 輸入號碼來選擇你希望這個 app 被部署到哪一個 region 的 App Engine接下來, 執行:cloudgcloud app deploy --version 1 輸入 Y 繼續 cloudgcloud datastore indexes create index.yaml 輸入 Y 繼續 監控索引 (Monitor indexes)到主控台的 Datastore &gt; Indexes 。 會需要幾分鐘的時間設定。 使用視窗上方的 “Refresh” 按鈕。 目前的狀態應該會是 “Serving” 準備安裝 Stackdriver Monitoring當你開始 Qwiklab 上的教程時, 一台虛擬機會自動被建立。 如果你不是使用 Qwiklab, 可以自己建立一台虛擬機。 下一個步驟，你將會需要安裝 monitoring agent (監視代理程式)。 到 Compute Engine &gt; VM instances 準備安裝吧！ 建立一個 Stackdriver 工作區要使用 Stackdriver, 你的專案必須有一個 Stackdriver 帳號。 以下的步驟會建立一個新的 Stackdriver 免費試用帳號 在 Google Cloud Platform 主控台, 點擊 Navigation Menu &gt; Monitoring當你看到 Stackdriver 的顯示面板, 這代表你的 Stackdriver 工作區已經準備好了 在上層的橫幅點擊 Install Agents 從 VM Instance 使用 SSH 到虛擬機裡, 然後執行以下的指令來安裝 Stackdriver 監控代理以及 Stackdriver 紀錄代理 Stackdriver 代理程式設定 Stackdriver 代理程式Stackdriver 代理讓你更了解你的基礎設施以及應用。 安裝兩種代理到你想要獲取更多資訊的環境。 監控代理Stackdriver Monitoring 代理程式是一個以 collectd 為基礎的 Daemon，可從虛擬機器執行個體收集系統與應用程式指標，並將其傳送至 Monitoring。根據預設，Monitoring 代理程式會收集磁碟、CPU、網路與處理程序指標。您可以將 Monitoring 代理程式設定為監控第三方應用程式，以取得代理程式指標的完整清單。更多資訊 安裝監控代理curl -sSO https://dl.google.com/cloudagents/install-monitoring-agent.shsudo bash install-monitoring-agent.sh Logging 代理在預設設定中，Stackdriver Logging 代理程式會將記錄從常見第三方應用程式與系統軟體串流至 Stackdriver Logging；請參閱預設記錄的清單。您可以設定代理程式，使其串流其他記錄。如要瞭解代理程式設定與作業，請參閱設定 Stackdriver Logging 代理程式一文。 最佳做法是在所有 VM 執行個體上執行 Stackdriver Logging 代理程式。代理程式會在 Linux 與 Windows 下執行。如要安裝 Stackdriver Logging 代理程式，請參閱安裝記錄代理程式一文。 更多資訊 安裝 logging 代理curl -sSO https://dl.google.com/cloudagents/install-logging-agent.shsudo bash install-logging-agent.sh 點擊 Monitoring Overview 回到顯示面板 本教程額外的資源因為本教程需要使用紀錄, 所以你需要產生一些有趣的紀錄。 本教程將會使用運作時間確認以及 VM 建立來產生紀錄 建立一些運作時間確認現在你將針對這個目前運作在 App Engine 上的應用, 建立一些運作時間確認。 運作時間確認將會模擬應用載入。 App Engine 將會自動地從所有的請求當中捕捉紀錄, 然後會每分鐘產生紀錄, 所以等等你就會有可以分析的資料了。 回到 GCP 主控台並且點擊 Navigation menu &gt; App Engine 。 點擊右上方的連結, 然後複製你的應用的連結。 你會需要這個來建立一個運行時間確認。 回到 Stackdriver 視窗, 在 Overview 頁面, Uptime Checks 區塊, 點擊 Create Selected Checks 按鈕並且則預設專案 (預設沒勾選), 然後點擊 Create Check 你也可以從左手邊選單的 Uptime Checks 選擇 Uptime Checks Overview , 然後在新視窗點擊 Add Uptime Check 使用以下資訊來編輯 New Uptime Check:Title: pizza checkCheck type: HTTPResource Type: URLHostname: 貼上我們應用的 URL。 從 URL 中移除掉 https:// 以及結尾的 /Path: /?food=pizzaCheck every: 1 min 點擊 Test 來核對 uptime check 有在正常運作中。 當你看到一個綠色的打勾符號, 這表示有在正確運作中。 點擊 Save 你將會看到如下： 勾選 “Don’t ask again” 方塊匡, 然後點擊 “No thanks” 來跳過 uptime check 的警告政策建立 再建立兩個 uptime check 點擊第一個 uptime check 的三個點的圖案, 選擇 “copy” 將名稱變更為 “burger check”, 然後改變 path 到 “/?food=burger” 再複製 uptime check 一次 更名為 “cake check”, 然後 path 變更為 “/?food=cake” 你可以在顯示面板上看到所有增加的 uptime check 系統定義紀錄指標以及使用者定義紀錄指標紀錄指標又分為系統定義以及使用者自定義 系統定義紀錄指標系統定義紀錄指標馬上就可以使用, 這些系統定義指標包含： 收到的紀錄的指標 Byte_count: 收到的記錄項目位元組總數。 被細分為監控資源類型, 紀錄串流名稱, 以及嚴重等級。 被排除的紀錄的指標 Excluded_byte_count: 排除的記錄項目位元組總數。 被細分為監控資源類型 Excluded_log_entry_count: 排除的記錄項目總數。 被細分為監控資源類型。 紀錄指標的指標 Dropped_log_entry_count: 不要看這個名字這樣, 事實上這個不是被 Stackdriver 放棄的紀錄數據, 而是因為遲到了, 所以未被歸進紀錄指標的紀錄項目總數 Log_entry_count: 有被歸進紀錄指標的紀錄項目總數, 所以 dropped_log_entry_count + log_entry_count 為 Stackdriver Logging 收到的紀錄項目總數 Metric_throttled: 顯示數據點是否因為超過時間順序限制而被紀錄指標放棄 Time_series_count: 在紀錄指標中, 活躍的時間序列項目總數的估計值 大部分的系統紀錄指標都是計數器指標。 Counter metrics(計數器指標) 計算符合進階紀錄篩選器的記錄數據數量。 現在, 你將更進一步的看看系統產生的紀錄指標： Log_entry_count 在 Stackdriver 主控台, 點擊 Resources &gt; Metrics Explorer: 開始輸入 “GCE”, 然後選擇 “GCE VM Instance” 為你的資源。 指標的話則是輸入 “log” 以及選擇 “Log entries”: 呈現在你眼前的是一台機器的記錄數據圖表, 這台機器從這個教程開始時就開啟了, 是你的眾多資源之一。 使用者定義的紀錄指標你可以使用已經存在的紀錄來建立你自己的紀錄指標。 他們被稱為使用者定義紀錄指標。 現在你將使用記錄數據來建立一個指標。 在 Stackdriver 主控台, 從左側選單點擊 Logging 現在你已經在紀錄頁面, 在這裡你可以篩選結果 在第一個下拉選單選擇 GCE VM Instance 然後在第二個下拉選單選擇 cloudaudit.googleapis.com/activity , 然後點擊 OK 在其中一筆數據點擊 “insert” 標籤, 然後選擇 Show matching entries 進階篩選器現在已經被啟動並且顯示這個指標的標準 第三行的 protoPayload.methodName 讓你可以經由很多方式來篩選, 更多資訊可以參考這裏 在螢幕上方點擊 Create Metrics 在指標編輯器將你的指標命名為 “newVM” , 然後點擊 Create Metric 你將可以看到你的使用者自定義紀錄指標被加到紀錄指標頁面 針對 VM 建立指標建立警告政策現在你將建立一個警告, 當一個新的 VM 被加到專案時, 你會收到提醒 在 Stackdriver 主控台, 重整螢幕, 然後點擊 Alerting &gt; Create a Policy 加入以下資訊：Condition: 點擊 Add Condition。 開始輸入 “logging” 以及將 Resource Type 更新為 “logging/user/newVM”, 以及 Condition 設為 “is above” 0 For 1 minute 。 現在點擊 Save** Notification: 將你的個人信箱加到 email 欄位, 你才能收到 email 通知 Name this Policy: 輸入 “New Virtual Machine” 點擊 Save 建立一台新的機器現在讓我們來觸發剛剛建立的警告, 建立一台新的機器吧！ 在 GCP 主控台的顯示面板, 到 Navigation menu &gt; Compute Engine &gt; VM instances , 然後在螢幕上方點擊 Create Instance 將你的虛擬機取名為 “instance2”, 然後在允許 HTTP 以及 HTTPs 流量的框框打勾。 剩下的都預設值即可。 點擊 Create 等待幾分鐘讓機器啟動。 3~5 分鐘內, 你應會在 Stackdriver 主控台看到一個事件。 繼續本教程, 我們可以在最後確認結果 標籤 (Labels) 以及使用者自定義指標 (user defined metrics)當你建立指標時, 使用者自定義標籤可以被建立。 每一個配置的標籤都需要一個提取器表達式來告訴 Stackdriver Logging, 如何從紀錄中提取數據, 並且將他們置於標籤數據。 你無法在系統定義指標中加入標籤。 現在你將建立一個含有標籤的使用者定義指標 在 Stackdriver 視窗頁面, 點擊 Logging 篩選紀錄為 GAE Application 以及 appengine.googleapis.com/request_log &gt; OK 在螢幕上方點擊 Create Metric 將指標命名為 “Foodcount”, 然後如果你想要的話也可以加入敘述 再來點擊 Add item 來建立一個標籤 標籤Labels 讓紀錄指標可以含有多個時間序列 - 每一個標籤值。 所有的紀錄指標都有一些預設的標籤。 在本教程中, 你將會建立一個指標, 條件為當一個 uptime check 的紀錄產生, 且這個紀錄含有 “food” 標籤 如果你還沒完成這件事情, 點擊 Add Item 填入以下資訊： Name: foods Label Type: String Field Name: search for “resource” and choose “protoPayload.resource” 點擊 Build 按鈕, 然後輸入表達式: /?food=(.*) 點擊 Done 注意： 要確定你有仔細的設定好標籤值提取器。 一個錯誤可能會導致很大量的活躍時間序列。 超過時間序列限制會導致指標被限制住, 圖表表現下降, 以及額外的時間序列超時成本 點擊 Create Metric 現在你將會看到你的使用者定義指標被加到紀錄指標的畫面 建立 Foodcount 警告政策現在你將建立一個 Foodcount 的警告政策, 就是那個你剛建立的指標在 Stackdriver 主控台, 重整螢幕, 然後點擊 Alerting &gt; Create a Policy 你也可以從 Google Cloud 主控台, 到 Stackdriver 區塊然後點擊 Logging , 然後一樣照著上面的動作來建立 設定以下的條件： 條件: 點擊 Add Condition 。 在 Find Resource 欄位輸入 “logging/user/“ 然後選擇 “logging/user/Foodcount” 。 門檻為 0 以及 1 分鐘, 然後 save 通知: 輸入你的個人信箱到 email 欄位來接收 email 通知 命名這個政策: 輸入 “food alert” 點擊 save 當下一輪的 uptime check 發生, 門檻一定會高於 1 分鐘, 所以警告會被觸發, 且你將會看到一個事件出現在 Monitoring Overview 頁面 分布 (Distribution) 以及延遲 (latency) 指標分佈指標 從符合篩選的數據中累積數字資料。 指標含有一個 Distribution 物件的時間序列, 每一個都含有以下的東西: 在分佈中, 數值的數量累積 數值的平均 偏差值平方的總和 一組直方 buckets 以及 每個 bucket 中都有數值的總和。 你可以使用預設的 bucket 設計, 或是選擇你自己想要的 一個分佈指標常見的使用情境是追蹤延遲。 當接收到每一筆記錄數據, 延遲值會從記錄數據中被取出, 並且加到分佈中。 在規律的間隔下, 累積的分佈被寫到 Stackdriver Monitoring。 接下來你將建立一個追蹤延遲的指標 到 Logs-based Metric 視窗 在 Logs Viewer 控制列上, 在你的指標, 你可以建立一個只會計算你想要的記錄數據的篩選器。 在頁面上方, 點擊 Create Metric 在 Metric Editor 控制列, 填入以下欄位 Name: AppLatency 將 Type 變更為 “Distribution” Field name 為 “latency”, 並選擇 “protoPayload.latency” 點擊 Create Metric 你的新指標出現在 Logs Viewer 指標的列表中, 並且立即出現在相關的 Stackdriver Monitoring 選單 在紀錄指標頁面, 點擊 AppLatency 指標旁的三個小點圖案, 然後選擇 **View in Metrics Explorer 來檢視分佈指標的結果。 你可能需要重整 Stackdriver 的頁面 在圖表上方的下方選單改變圖表的風格為 heatmap Metric Explorer 的結果大概會需要 3~5 分鐘。 你可以一些時候再回到這個頁面來核對結果 你也可以從 Stackdriver 主控台, 到 Resources &gt; Metrics Explorer 輸入你的指標名稱 heatmap 客製顯示面板建立一個客製的面板來顯示特定的指標是一個檢視資料很好的方式。 接下來你會建立一個客製面板來顯示你方才使用的延遲指標 在 Stackdriver 主控台, 點擊 Dashboard &gt; Create Dashboard , 然在右手邊點擊 Add Chart Resource type: GAE ApplicationMetric: Response latency 圖表將會以你使用的指標自我命名, 你可以將他更名為任何你想要的 - 在這個範例中為 “Heatmap” 在螢幕下方點擊 Save 面板需要一個名字 - 點擊 Untitled 然後命名它為 “App Response” 確認警告事件回到 Stackdriver 的 Monitoring Overview 檢視 uptime check 政策的警告。 你也可以回到 Resource 頁面的 Metrics Explorer 點擊 Alerting &gt; Policies overview, 然後點擊政策的名字來更清楚的檢視 newVM 警告。 因為問題已經自我解決了, 點擊 Resolved 視窗, 然後你可以看到 new VM 發生的事件通知 如果你有設定任何 email 通知, 收信並確認核對收到的警告。 這個可能會花更久的時間, 但沒關係, 就算這個教程結束了, 你還是可以收到。 別忘了點擊 Metrics Explorer 視窗並重整頁面來檢視 heatmap 恭喜！你已經完成本教程！","link":"/zh-tw/creatingAndAlertingOnLogsBasedMetrics/"},{"title":"使用 Jenkins 在 Kubernetes Engine 中實作持續交付","text":"概述在本教程中, 你將學習到如何在 Kubernetes engine 中, 使用 Jenkins 來設定持續交付管道。 Jenkins 是一個開發者們經常會使用到的自動化 server, 這些開發者們會經常的需要將他們的程式碼整合到一個共同分享的倉庫中… 在本教程中你將建立一個解決方案, 如下方圖表： 你可以在這裡找到更多在 Kubernetes 中運行 Jenkins 的資訊 你將會做什麼？在本教程中, 你將會完成以下的任務： 提供一個 Jenkins 應用到 Kubernetes Engine 叢集中 使用 Helm Package Manager 來設定你的 Jenkins 應用 探索 Jenkins application 的功能 建立以及運作 Jenkins 管道 先決條件這是一個進階等級的教程。 在我們開始之前, 你應該要會基礎的 shell 程式, Kubernetes, 以及 Jenkins 。 這裡有一些 Qwiklabs 的課程可以讓你達到應有的速度： Introduction to Docker Hello Node Kubernetes Managing Deployments Using Kubernetes Engine Setting up Jenkins on Kubernetes Engine 如果你已經準備好了, 往下拉, 學習更多 Kubernetes, Jenkins, 以及持續交付。 Kubernetes Engine 是什麼？Kubernetes Engine 是由 GCP 所管理的 Kubernetes 版本 - 一個強大的叢集管理器以及容器編排系統。 Kubernetes 是一個開源的專案, 可以運行在很多不同的環境上, 從筆電到高可用的多主機叢集; 從公開的雲端到人為部署; 從虛擬機到裸機 如上所敘, Kubernetes 應用建立在 容器上 - 有一些含有所有 dependencies 以及 libraries 的輕量化應用來運行 Kubernetes 應用。 這些底層的架構讓 Kubernetes 更加的高可用, 安全, 以及快速部署 - 這是雲端開發者理想中的框架 Jenkins 是什麼？Jenkins 是一個開源的自動化 server, 它可以讓你更靈活的編排你的 build, test, 以及部署管道。 Jenkins 讓開發者可以更快速的迭代專案, 不需擔心由持續交付所造成的問題 什麼是持續交付 / 持續部署？當你需要設定 continuous delivery (CD) pipeline (持續交付管道), 部署 Jenkins 到 Kubernetes Engine 相比傳統一般的 VM 部署, 提供了巨大的好處 當你使用容器來運行 build 程序, 虛擬主機可以在多作業系統上運行 jobs 。 Kubernetes Engine ephemeral build executors (暫時性的 build 執行者) - 他們只有當 builds 需要運行時才會被使用到, 這個機制可以將資源留給其他有需要的叢集任務, 像是批量處理的工作。 另外一個 ephemeral build executors 的好處是它的速度 - 啟動只是幾秒鐘的事 Kubernetes Engine 也內建了 Google 全球平衡負載, 你可以利用它來將流量自動化的導向你的機器。 平衡負載提供了 SSL 處理端點, 以及使用一個由 Google 的基礎網路設定的全球 IP - 與你的前端配合, 這個平衡負載將建立一條在你的服務與使用者之間最有效率的通道 現在你已經知道一點 Kubernetes, Jenkis, 以及兩者之間如何在 CD 管道中互動的知識, 是時候來自己做一個了。 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 複製倉庫一開始, 在 Cloud Shell 開啟一個新的視窗, 執行以下的指令來設定 zone 為 us-east1-dgcloud config set compute/zone us-east1-d 複製本教程的範例程式碼：git clone https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes.git 切換到正確的資料夾內:cd continuous-deployment-on-kubernetes 提供 Jenkins建立一個 Kubernetes 叢集現在執行以下的指令來建立一個 Kubernetes 叢集gcloud container clusters create jenkins-cd \\--num-nodes 2 \\--machine-type n1-standard-2 \\--scopes \"https://www.googleapis.com/auth/source.read_write,cloud-platform\" 這個步驟會耗費幾分鐘完成。 額外的 scopes 讓 Jenkins 可以存取 Cloud Source Repositories 以及 Google Container Registry 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Kubernetes 叢集, 你將獲得一個評價分數。 在開始前, 使用以下指令來確認你的叢集有在正常運行中gcloud container clusters list 現在, 取得叢集的憑證gcloud container clusters get-credentials jenkins-cd Kubernetes Engine 使用這些憑證來存取你新建立的叢集 - 使用以下指令來確認你可以連接它kubectl cluster-info 安裝 Helm在本教程中, 你將會使用 Helm, 從 Charts 倉庫來安裝 Jenkins 。 Helm 是一個套件管理器, 他讓設定以及部署 Kubernetes 應用更加的簡單。 一旦你安裝了 Jenkins 到你的叢集, 你將可以設定你的 CD/CD 管道。 下載以及安裝 helm 二進制檔 wget https://storage.googleapis.com/kubernetes-helm/helm-v2.14.1-linux-amd64.tar.gz 在 Cloud Shell 中解壓縮檔案 tar zxfv helm-v2.14.1-linux-amd64.tar.gzcp linux-amd64/helm . 把你自己加到叢集的 RBAC 中, 身份為叢集管理者, 所以你將可以在叢集中賦予 Jenkins 權限 kubectl create clusterrolebinding cluster-admin-binding --clusterrole=cluster-admin --user=$(gcloud config get-value account) Tiller 是 server side 的 Helm, 在叢集中賦予它叢集管理的角色 kubectl create serviceaccount tiller --namespace kube-systemkubectl create clusterrolebinding tiller-admin-binding --clusterrole=cluster-admin --serviceaccount=kube-system:tiller 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Tiller 服務帳戶, 你將獲得一個評價分數。 初始化 Helm 。 這確保了 server side 的 Helm 已經正確的安裝到你的叢集./helm init --service-account=tiller./helm update 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功的初始化 Helm, 以及安裝 Tiller, 你將獲得一個評價分數。 執行以下指令來確保 Helm 已經正確的被安裝。 你應該會看到 server 端以及 client 端的版本號: ./helm version 範例輸出 Client: &amp;version.Version&#123;SemVer:&quot;v2.14.1&quot;, GitCommit:&quot;5270352a09c7e8b6e8c9593002a73535276507c0&quot;, GitTreeState:&quot;clean&quot;&#125;Server: &amp;version.Version&#123;SemVer:&quot;v2.14.1&quot;, GitCommit:&quot;5270352a09c7e8b6e8c9593002a73535276507c0&quot;, GitTreeState:&quot;clean&quot;&#125; 設定並安裝 Jenkins你將使用一個客製的檔案來增加一個必要的 GCP 插件, 要使用 service account 憑證來存取 Cloud Source Repository, 這個插件是必要的 使用 Helm CLI 來根據設定部署 chart./helm install -n cd stable/jenkins -f jenkins/values.yaml --version 1.2.2 --wait 這個指令可能會花幾分鐘完成 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功設定好 Jenkins chart, 你將獲得一個評價分數。 一旦指令完成了, 確保 Jenkins pod 是處於正常運行狀態, 並且容器是 READY 的狀態 kubectl get pods 範例輸出: NAME READY STATUS RESTARTS AGEcd-jenkins-7c786475dd-vbhg4 1/1 Running 0 1m 設定 Jenkins 服務帳號, 讓它可以部署應用到叢集上 kubectl create clusterrolebinding jenkins-deploy --clusterrole=cluster-admin --serviceaccount=default:cd-jenkins 你應該會收到以下輸出： clusterrolebinding.rbac.authorization.k8s.io/jenkins-deploy created 執行以下指令來設定 port forwarding, 將本機的 port 映射到 Jenkins UI export POD_NAME=$(kubectl get pods --namespace default -l \"app.kubernetes.io/component=jenkins-master\" -l \"app.kubernetes.io/instance=cd\" -o jsonpath=\"&#123;.items[0].metadata.name&#125;\")kubectl port-forward $POD_NAME 8080:8080 &gt;&gt; /dev/null &amp; 現在, 確認 Jenkins 服務已經被成功建立： kubectl get svc 範例輸出: NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGEcd-jenkins 10.35.249.67 &lt;none&gt; 8080/TCP 3hcd-jenkins-agent 10.35.248.1 &lt;none&gt; 50000/TCP 3hkubernetes 10.35.240.1 &lt;none&gt; 443/TCP 9h 你正使用 Kubernetes Plugin, 所以我們的 builder nodes 當有需要時, Jenkins master 會發請求給他們, 而這些 nodes 會自動地被啟動。當這些 nodes 完成了工作, 他們會被自動關閉, 而他們的資源會回到叢集的資源池 注意到這個服務暴露了任何符合 selector 規則的 pods 的 ports 8080 以及 50000 。 這將在叢集內暴露 Jenkins web UI 以及 builder/agent 註冊 ports 。 另外, jenkins-ui 服務是使用 ClusterIP 暴露, 所以不可從叢集外部被存取。 連接到 Jenkins Jenkins chart 會自動幫你建立一個管理者密碼。 執行以下指令來取得它: printf $(kubectl get secret cd-jenkins -o jsonpath=\"&#123;.data.jenkins-admin-password&#125;\" | base64 --decode);echo 如下圖, 在 cloud shell 點擊 Web Preview 按鈕, 然後點擊 “Preview on port 8080” 來連接到 Jenkins 使用者介面: 現在你應該能夠使用 username admin, 以及自動產生的密碼登入現在你已經在叢集中設定好 Jenkins, 在下一個章節使用 Jenkins 來管理我們的 CI/CD 管道 理解應用你將在持續部署的管道中部署範例應用 gceme 。 這個應用由 GO 語言所編寫, 位於 sample-app 資料夾底下。 當你在 Computer Engine instance 運行這個 gceme 二進制檔, 這個應用將會該 instance 的資訊如下圖般的形式顯示出來: 這個應用藉由支援兩個運作模式來模擬一個微服務 在 後端模式: gceme 監聽 port 8080, 並且以 JSON 格式返回 Computer Engine instance 的 metadata 在 前端模式: gceme 向後端發請求, 並在使用者介面渲染收到的 JSON 部署應用你將部署應用到兩種不同的環境： Production: 使用者使用的正式環境 Canary: 一個規模小一點的網站, 它只會收到一定比例的使用者流量。 在我們將它發佈到所有的使用者之前, 使用這個環境來使用正式流量驗證你的軟體的正確性。 在 Google Cloud Shell, 到範例的資料夾內:cd sample-app 建立 Kubernetes 的命名空間來邏輯性的區隔不同的部署kubectl create ns production 使用 kbectl apply 指令建立 production, canary 部署, 以及服務kubectl apply -f k8s/production -n productionkubectl apply -f k8s/canary -n productionkubectl apply -f k8s/services -n production 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立部署, 你將獲得一個評價分數。 預設來說, 前端只有一個 replica 被部署。 使用 kubectl scale 指令來確保至少有 4 個 replicas 同時運行執行以下指令來擴大 production 環境的前端kubectl scale deployment gceme-frontend-production -n production --replicas 4 現在確認一下, 你將會有 5 個 pods 運行前端, 4 個運行 production 流量, 1 個運行 canary (canary 的變更只會影響到 1/5, 20% 的使用者) kubectl get pods -n production -l app=gceme -l role=frontend 再確認 2 pods 運行後端, 1 個運行 production 然後一個是 canarykubectl get pods -n production -l app=gceme -l role=backend 取得 production 服務的外部 IPkubectl get service gceme-frontend -n production 備註: 這邊可能需要幾分鐘的時間讓平衡負載外部 IP 顯示出來 範例輸出:NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEgceme-frontend LoadBalancer 10.79.241.131 104.196.110.46 80/TCP 5h 在瀏覽器貼上 External IP 來檢視 info card 如下: 現在, 將前端服務的平衡負載外部 IP 記到一個變數, 稍等會用到:export FRONTEND_SERVICE_IP=$(kubectl get -o jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\" --namespace=production services gceme-frontend) 在瀏覽器打開外部 IP, 確認兩個服務都運作正常。 輸入以下指令確認版本(應該要是 1.0.0)：curl http://$FRONTEND_SERVICE_IP/version 你已經成功地部署了範例應用, 接下來, 你將設定一個管道以持續的, 可靠的部署你的變更。 建立 Jenkins 管道建立一個程式碼倉庫來存放範例 app 程式碼建立一份 gceme 範例 app 的複製, 然後推送到 Cloud Source Repository:gcloud source repos create default 如果看到警告請忽略, 你將不會被請款 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立代碼倉庫, 你將獲得一個評價分數。 git init 初始化範例 app 資料夾並設定 Git 倉庫:git config credential.helper gcloud.sh 執行以下指令：git remote add origin https://source.developers.google.com/p/$DEVSHELL_PROJECT_ID/r/default 設定 Git commit 的 username 以及 email 。 請將 [EMAIL_ADDRESS] 及 [USERNAME] 替換成你自己的git config --global user.email \"[EMAIL_ADDRESS]\"git config --global user.name \"[USERNAME]\" 將變更的內容加到 stage area, 提交 commit, 並推送到 Git 倉庫git add .git commit -m \"Initial commit\"git push origin master 增加你的服務帳戶憑證設定你的憑證, 讓 Jenkins 可以存取你的程式碼倉庫。 Jenkins 將會使用你的叢集服務帳戶憑證從 Cloud Source Repositories 下載程式碼 Step 1: 在 Jenkins 的使用者介面, 在左邊導覽介面點擊 CredentialsStep 2: 點擊 Jenkins Step 3: 點擊 Global credentials (unrestricted)Step 4: 在左側導航介面點擊 Add CredentialsStep 5: 從 KIND 的下拉式窗點擊 Google Service Account from metadata 並點擊 OK 全域憑證已經被加入。 憑證的名字為 CONNECTION DETAILS 區塊的 GCP Project ID 建立 Jenkins job到你的 Jenkins 使用者介面並依造以下的步驟設定管道工作 Step 1: 左側點擊 Jenkins &gt; New Item Step 2: 將專案取名為 sample-app, 然後選擇 Multibranch Pipeline 選項, 點擊 OK Step 3: 在下一頁, Branch Sources 區塊, 點擊 Add Source 然後選擇 git Step 4: 在 Project Repository 欄位貼上 sample-app 資料夾在 Cloud Source Repositories 的 HTTPS clone URL 。 請將 [PROJECT_ID] 替換成你的 GCP Project ID:https://source.developers.google.com/p/[PROJECT_ID]/r/default Step 5: 在 Credentials 下拉選單, 選擇之前增加服務帳戶時所建立的憑證名稱 Step 6: 在 Scan Multibranch Pipeline Triggers 區塊下, 勾選 Periodically if not otherwise run, 並設定 Interval 為 1 分鐘 Step 7: 你的 job 設定應該看起來會如下： Step 8: 其餘選項留為預設, 點擊 Save在你完成這些步驟之後, 一個叫做 “Branch indexing” 的 job 會運行。 這個 meta-job 會辨識你的倉庫中的分支, 並且確保變更沒有出現在現存的分支中。 如果你在左上方點擊 sample-app, 你該會看到 master job 備註： master 的第一次運行應該會失敗, 直到你再下一個步驟提交一些程式變更 你已經成功地建立了一個 Jenkins 管道, 接下來, 你將會建立一個持續整合的開發環境 建立開發環境開發分支是在我們提交整合到正式環境之前, 讓開發者們用來測試程式碼變更的環境。 這個環境是應用的縮小規模版本, 但需要比較正式環境完全相同的機制下部署。 建立一個開發分支你可以推送分支到 Git server, 讓 Jenkins 來部署你的環境, 藉此建立從功能分支來建立一個開發環境建立一個開發分支並且推送到 Git servergit checkout -b new-feature 修改管道定義定義管道的 Jenkinsfile 是由 Jenkins Pipeline Groovy syntax 所編寫。 使用 Jenkinsfile, 可以藉由僅僅一個檔案來敘述整個的 build 管道程序。管道支援強大的功能, 像是並行化, 以及使用者手動核准 要讓管道如預期般運作, 我們需要修改 Jenkinsfile 來設定我們的 project ID 在 terminal 打開 Jenkinsfilevim Jenkinsfile 開始修改i 將 REPLACE_WITH_YOUR_PROJECT_ID 替換成你的 PROJECT_ID 。 你可以在這個教程的 CONNECTION DETAILS 區塊找到你的 PROJECT_ID, 也可以輸入 gcloud config get-value project 來取得它def project = &apos;REPLACE_WITH_YOUR_PROJECT_ID&apos;def appName = &apos;gceme&apos;def feSvcName = &quot;$&#123;appName&#125;-frontend&quot;def imageTag = &quot;gcr.io/$&#123;project&#125;/$&#123;appName&#125;:$&#123;env.BRANCH_NAME&#125;.$&#123;env.BUILD_NUMBER&#125;&quot; 儲存並退出 Jenkinsfile 檔案:wq 修改網站要展示應用的變更, 你需要改變 gceme cards 的顏色, 從 藍色 改為 橘色 打開 html.go:vim html.go 開始編輯i 改變兩個位置的 &lt;div class=&quot;card blue&quot;&gt;&lt;div class=\"card orange\"&gt; 儲存 html.go 檔案, 按下 Esc, 然後：:wq 打開 main.io:vim main.io 開始編輯:i 版本被定義在這一行const version string = &quot;2.0.0&quot; 再次儲存 main.go, 按下 Esc, 然後：:wq 開始部署提交 commit 並推送變更git add Jenkinsfile html.go main.gogit commit -m \"Version 2.0.0\"git push origin new-feature 這將會開始一個開發環境的建立 在變更被推送到 Git repository 後, 到 Jenkins 使用者介面可以看到針對 new-feature 分支的建立已經開始。 大概會需要 1 分鐘完成 在 build 開始運行後, 點擊 build 旁, 位於左手邊的下拉箭頭, 選擇 Console output: 花幾分鐘的時間來追蹤 build 的輸出然後可以看到 kubectl --namespace=new-feature apply... 訊息開始。 你的 new-feature 分支將開始被部署到叢集上。 備註: 在開發情境中, 你不會使用面向公開的平衡負載。 你可以使用 kubectl proxy 來讓你的應用更安全。 這個代理 (proxy) 會自己使用 kubernetes API 來驗證, 並且代理從你本機發出到叢集中的服務的請求, 不須將你的服務暴露到網路上。 如果你沒有看到 Build Executor 裡有任何東西, 別擔心。 到 Jenkins homepage -&gt; sample app 。 確認 new-feature 管道已經被建立 一旦全部的工作都完成後, 開始在背景開啟代理 kubectl proxy &amp; 如果有錯誤, 按下 ctrl + c 來退出。 發一個請求到你的 localhost, 並讓 proxy 幫你轉發到你的服務, 確認你的應用是可被存取的。curl \\http://localhost:8001/api/v1/namespaces/new-feature/services/gceme-frontend:80/proxy/version 你應該會看到回應 2.0.0, 這是目前運行中的版本 如果你收到類似錯誤如下：&#123; &quot;kind&quot;: &quot;Status&quot;, &quot;apiVersion&quot;: &quot;v1&quot;, &quot;metadata&quot;: &#123; &#125;, &quot;status&quot;: &quot;Failure&quot;, &quot;message&quot;: &quot;no endpoints available for service \\&quot;gceme-frontend:80\\&quot;&quot;, &quot;reason&quot;: &quot;ServiceUnavailable&quot;, &quot;code&quot;: 503 這代表你的前端端點還沒有準備好。 等待一下下, 用 curl 指令再試一次。 如果你收到以下的輸出, 那我們可以繼續往下了。2.0.0 你已經設定好開發環境了！ 接下來, 你將會建立你之前所學到的, 部署一個金絲雀發佈 (canary release) 來測試一個新功能 部署一個金絲雀發佈 (Canary Release)你已經確認過你的應用目前正在開發環境運行著最新的程式碼, 所以現在部署這些程式碼到金絲雀環境 建立一個 canary 分支, 然後推送到 Git server:git checkout -b canarygit push origin canary 在 Jenkins 中, 你應該會看到 canary 管道已經啟動。 一旦它完成了, 你可以確認看看服務的 URL, 確保一些流量已經是由新的版本服務。 每五個請求中應該會有一個請求會返回 version 2.0.0 (無特定的順序)export FRONTEND_SERVICE_IP=$(kubectl get -o \\jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\" --namespace=production services gceme-frontend) while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; done 如果你一直看到 1.0.0, 試著再次運行上面的指令。 一但你確認 Okay 了, 按下 Ctrl-c 來結束指令 就是這樣！ 你已經部署了金絲雀發佈。 現在你將部署新版到正式環境 部署到正式環境現在我們的金絲雀發佈已經成功, 且沒有收到任何客戶的抱怨, 可以部署到其他的地方了！ 建立一個金絲雀分支, 然後推送到 Git servergit checkout mastergit merge canarygit push origin master 在 Jenkins 中, 你應該會看到 master 管道已經啟動。 一旦它完成了(可能會花個幾分鐘), 你可以確認看看服務的 URL, 確保所有流量都是由 version 2.0.0 所服務export FRONTEND_SERVICE_IP=$(kubectl get -o \\jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\" --namespace=production services gceme-frontend) while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; done 如果你一直看到 1.0.0, 試著再次運行上面的指令。 一但你確認 Okay 了, 按下 Ctrl-c 來結束指令 範例輸出:gcpstaging9854_student@qwiklabs-gcp-df93aba9e6ea114a:~/continuous-deployment-on-kubernetes/sample-app$ while true; do curl http://$FRONTEND_SERVICE_IP/version; sleep 1; done2.0.02.0.02.0.02.0.02.0.02.0.0^C 你可以到 gceme 應用的網站上, 顯示 info cards 的地方去看看, card 的顏色已經從藍色變為橘色。 以下的指令可以取得外部 IP 位置kubectl get service gceme-frontend -n production 範例輸出 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 你已經完成了！幹得好, 你已經成功地將你的應用部署到正式環境！ 恭喜你已經完成本教程！","link":"/zh-tw/continuousDeliveryWithJenkinsInKubernetesEngine/"},{"title":"GCP Deployment Manager - 正式環境","text":"概述在本教程中, 你將會使用一個叫做 Deployment Manager 的基礎設施策劃工具來啟動一個服務, 並且使用 Stackdriver 來監控這個服務。 在 Stackdriver, 你將會使用 Stackdriver 主控台來設定基礎的黑盒子監控, 並且建立一個運行時間確認 (Uptime Check) 來觸發事件通知 (alert notification) 更精確的說, 你將會： 使用 Deployment Manager 範本來安裝並且設定一個進階的的 deployment 啟動 Stackdriver monitoring 設定 Stackdriver 運行時間確認以及通知 設定 Stackdriver 主控台, 設定兩個圖表, 一個顯示 CPU 使用率, 另一個顯示 ingress 流量 實施一個負載測試以及模擬服務斷供 Stackdriver Monitoring 提供性能, 運行時間, 以及雲端執行應用的健康度的資訊。 Stackdriver 從 Google Cloud Platform, Amazon Web Service, 被管理的運行時間探測, 應用儀表, 以及包含 Cassandra, Nginx, Apache Web Server, Elasticsearch, 等等的多樣的常用應用元件搜集指標, 事件, 以及中繼資料。Stackdriver 攝入這些資料, 進而經由顯示面板, 圖表, 以及警告輸出讓使用者可以更理解的資訊。 Stackdriver 的警告功能讓你更簡單地與 Slack, PagerDuty, HipChat, Campfire, 以及更多的應用做整合。 目標在本教程中, 你將會學習： 從一系列的範本啟動一個雲端服務 設定一個應用的基礎黑盒子監控 建立一個運行時間確認來發現喪失功能的服務 建立一個警告政策來觸發事件回應程序 建立以及設定顯示面板, 進而做到動態更新的圖表 給予應用負載, 進而測試監控以及警告規則 模擬一個服務中斷, 進而測試監控以及警告規則 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立一個虛擬環境執行以下指令來下載以及安裝套件清單sudo apt-get update Python 虛擬環境被使用來隔離系統內的套件安裝sudo apt-get install virtualenv 如果 [Y/n] 彈出視窗, 按下 Enter virtualenv -p python3 venv 啟動虛擬環境source venv/bin/activate 複製 Deployment Manager 範本Google 提供一組優秀的 Deployment 範本, 你可以從中學習並且在之上建立 在 Cloud Shell 輸入下面的指令來建立一個置放範本的資料夾, 並且複製範本mkdir ~/dmsamples 到資料夾內cd ~/dmsamples 複製範本git clone https://github.com/GoogleCloudPlatform/deploymentmanager-samples.git 範例輸出:remote: Counting objects: 1917, done.remote: Compressing objects: 100% (31/31), done.remote: Total 1917 (delta 11), reused 29 (delta 7), pack-reused 1874Receiving objects: 100% (1917/1917), 426.86 KiB | 0 bytes/s, done.Resolving deltas: 100% (1060/1060), done. 探索範例檔案我們剛下載了一組範本到資料夾內, 讓我們更進一步地探索它們 列出範例範本執行以下指令來導向並且列出 version2 的範例：cd ~/dmsamples/deploymentmanager-samples/examples/v2 ls 你應該會看到輸出如下：access_context_manager cloud_functions common folder_creation iam_custom_role internal_lb_haproxy quick_start ssl vm_with_disksaccess_control cloudkms container_igm gke igm-updater metadata_from_file regional_igm step_by_step_guide vpn_auto_subnetbigtable cloud_router container_vm ha-service image_based_igm nodejs saltstack template_modules waiterbuild_configuration cloudsql custom_machine_type htcondor instance_pool nodejs_l7 single_vm vlan_attachmentcloudbuild cloudsql_import dataproc iam internal_lb project_creation sqladmin vm_startup_script 不是所有的子資料夾都是獨立的專案。 例如說, 叫做 common 的資料夾含有會被使用在多個專案的範本。 如果你打算之後逐個研究, 使用 README 來當作導引吧。 nodejs 資料夾含有所有你在本教程中會需要的東西。 請注意這裡有 nodejs 資料夾以及 nodejs_17 資料夾, 使用 nodejs 列出並檢視 Nodejs deployment導向並列出 version2 範例：cd nodejs/python ls 範例輸出：frontend.py frontend.py.schema nodejs.py nodejs.py.schema nodejs.yaml Deployment Manager 主要的設定檔是 nodejs.yaml 。 它使用了範本來產生基礎設施。 其他的檔案是範本。 範本使用了被定義在 nodejs.yaml 檔案中的變數來產生自訂義的結果。 frontend.pyfrontend.py 包含 frontend.py.schema, 它依據 container_instance_template.y 建立了一個 instance 範本。 這個範本被用來建立一個 managed instance group 以及一個 autoscaler 。 範本也建立了一個含有單一公開 IP 轉發規則的負載平衡器。 它也將建立： 一個指向 managed instance group 的 target pool 附加在 target pool 的健康檢查 nodejs.pynodejs.py 包含 nodejs.py.schema, 他帶來了前端以及後端的範本。 注意, 前端的是 frontend.py 後端是 /common/python/container_vm.py 這是一個運行著 MySQL Docker 容器的 VM, 所以他不需要客制範本 其他檔案 /common/python/container_instance_template.py /common/python/container_vm.py /common/python/container_helper.py 客制 Deployment現在你已經下載了, 也檢視過了 nodejs Deployment Manager 範本, 讓我們開始來客制 deployment 指定 zonenodejs.yaml 需要輸入一個 zone, 讓我們加一個 輸入以下指令來打開 zone 列表： gcloud compute zones list 複製 zone 的名字, 在設定檔會用到 用 vim 打開 nodejs.yaml, 所以你可以編輯 zone 值vim nodejs.yaml nodejs.yaml 檔案包含resources:- name: nodejs type: nodejs.py properties: zone: ZONE_TO_RUN 將 ZONE_TO_RUN 更換成靠近你的地區, 然後退出 vim 並儲存檔案 這個範例顯示 ZONE_TO_RUN 設定成 us-east1-dresources:- name: nodejs type: nodejs.py properties: zone: us-east1-d 修改 instance group 中的最大 instance 數量編輯 nodejs.py 檔案 使用 vim 打開 nodejs.py vim nodejs.py 在 nodejs.py 檔案中, 核對 frontend 的擴充限制 &#123; &apos;name&apos;: frontend, &apos;type&apos;: &apos;frontend.py&apos;, &apos;properties&apos;: &#123; &apos;zone&apos;: context.properties[&apos;zone&apos;], &apos;dockerImage&apos;: &apos;gcr.io/deployment-manager-examples/nodejsservice&apos;, &apos;port&apos;: application_port, # Define the variables that are exposed to container as env variables. &apos;dockerEnv&apos;: &#123; &apos;SEVEN_SERVICE_MYSQL_PORT&apos;: mysql_port, &apos;SEVEN_SERVICE_PROXY_HOST&apos;: &apos;$(ref.&apos; + backend + &apos;.networkInterfaces[0].networkIP)&apos; &#125;, # If left out will default to 1 &apos;size&apos;: 2, # If left out will default to 1 &apos;maxSize&apos;: 20 &#125; &#125;, 目前的擴充限制是 20 (參考 maxSize) 修改 maxSize 然後設成 4:&#123; &apos;name&apos;: frontend, &apos;type&apos;: &apos;frontend.py&apos;, &apos;properties&apos;: &#123; &apos;zone&apos;: context.properties[&apos;zone&apos;], &apos;dockerImage&apos;: &apos;gcr.io/deployment-manager-examples/nodejsservice&apos;, &apos;port&apos;: application_port, # Define the variables that are exposed to container as env variables. &apos;dockerEnv&apos;: &#123; &apos;SEVEN_SERVICE_MYSQL_PORT&apos;: mysql_port, &apos;SEVEN_SERVICE_PROXY_HOST&apos;: &apos;$(ref.&apos; + backend + &apos;.networkInterfaces[0].networkIP)&apos; &#125;, # If left out will default to 1 &apos;size&apos;: 2, # If left out will default to 1 &apos;maxSize&apos;: 4 &#125; &#125;, 儲存並離開 vim 執行應用現在你將使用 Deployment Manager 來部署並使他運行。 這將會建立基礎設施, 但是它不允許流量。 在 Deployment Manager 設定好基礎設施後, 你可以採用服務標籤。 部署應用輸入以下指令, 使用 nodejs.yaml 設定檔建立一個名為 advanced-configuration 的應用gcloud deployment-manager deployments create advanced-configuration --config nodejs.yaml 輸出：The fingerprint of the deployment is PiYc6OsIFkWzQpCDklHvaA==Waiting for create [operation-1529913842103-56f72d31872d9-90070017-aec5761d]...done.Create operation operation-1529913842103-56f72d31872d9-90070017-aec5761d completed successfully.NAME TYPE STATE ERRORS INTENTadvanced-configuration-application-fw compute.v1.firewall COMPLETED []advanced-configuration-backend compute.v1.instance COMPLETED []advanced-configuration-frontend-as compute.v1.autoscaler COMPLETED []advanced-configuration-frontend-hc compute.v1.httpHealthCheck COMPLETED []advanced-configuration-frontend-igm compute.v1.instanceGroupManager COMPLETED []advanced-configuration-frontend-it compute.v1.instanceTemplate COMPLETED []advanced-configuration-frontend-lb compute.v1.forwardingRule COMPLETED []advanced-configuration-frontend-tp compute.v1.targetPool COMPLETED [] 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 確認 instance 的最大數量： 到 Compute Engine &gt; Instance groups 點擊 advanced-configuration-frontend-igm 點擊 Detail tab, 然後確認最大 instance 數量 你將看到它已經被設定成 4 確認應用正常運作中應用會需要幾分鐘啟動。 你可以從 Deployment Manager 的主控台 (Navigation menu &gt; Deployment Manager), 或從 Compute Engine 的主控台看到 instance (Navigation menu &gt; Compute Engine &gt; VM) 要確認應用正在運作中, 你將打開瀏覽器, 存取 port 8080, 然後檢視服務。 因為當 Deployment Manager 實作全球轉發規則時 (被指定在範本中), IP 會動態的被建立, 所以我們需要取得 IP 來測試應用是否正常 取得實作全球轉發規則的平衡負載 IP 在 Cloud Shell 輸入以下指令來取得轉發規則gcloud compute forwarding-rules list 範例輸出 在輸出中, IP_ADDRESS 就是轉發 IP 。 記得把他複製下來, 在本教程中你會使用它好幾次http://&lt;your IP address&gt;:8080 類似如下圖, 你會看到一個空白頁面 服務要正常運作會需要幾分鐘。 如果你看到一個錯誤, 像是 404, 等兩分鐘再試一次。 現在, 從 IP 輸入紀錄訊息http://&lt;your forwarding IP address&gt;:8080/?msg=&lt;enter_a_message&gt; 將 enter_a_message 更換為任何一段訊息 下面是記錄訊息範例 - 你的 IP 會跟它的不同 http://35.196.56.153:8080/?msg=my dog has spots 在你輸入紀錄之後, 瀏覽器回返回 added 到 http://&lt;your IP address&gt;:8080 來檢視紀錄。 例如： 繼續建立更多的訊息記錄, 然後到 http://&lt;your IP address&gt;:8080 來檢視他們 建立 Stackdriver 工作區在 Navigation menu, 點擊 Monitoring 當你看到 Stackdriver 顯示面板時, 你的工作區已經準備就緒了。 在 Stackdriver 設定一個運行時間確認以及警告政策現在 Stackdriver 已經在運行中了, 你經設定警告以及顯示面板 設定運行時間確認 在 Stackdriver 視窗, 點擊 Uptime Checks &gt; Uptime Checks Overview 。 點擊 Add Uptime Check** 指定數值如下： 點擊 Test 來測試這個確認 如果測試失敗, 確認服務正常運作中, 且防火牆規則正確且存在。 測試成功後, 點擊 Save 在儲存 Uptime Check 之後, Stackdriver 提供建立一個警告政策的選項 設定警告政策以及通知 點擊 Create Alerting Policy 為政策取名, 點擊 Save 在 Notification 選擇 “email”, 以及加入你的個人 email 在之後的步驟, 你將會觸發事件, 事件會經由 email 來通知你 為政策取名 點擊 Save 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 在顯示面板設定幾個有用的圖表設定顯示面板 在 Stackdriver 視窗, 點擊 Dashboards &gt; Create Dashboard 點擊 Untitled Dashboard, 然後更名為 DMDash 點擊 Auto Refresh 圖案, 所以變更會自動顯示 點擊 Add Chart 設定圖表如下： 點擊 Save 點擊 Add Chart, 使用以下屬性, 增加另一個圖表到顯示面板: 點擊 Save, DMDash 看起來應該如下： 建立設有 ApacheBench 的測試 VM現在, 你已經在指定的地區, 設定一個針對流量的監控, 看看有沒有正常運作。 你將安裝並且使用 ApacheBench 來施加三種等級的負載到你的服務, 然後從你已經設定好的 Stackdriver 顯示面板來檢視 建立一台 VM 在 Cloud Console, 點擊 Compute Engine &gt; VM instances 點擊 Create Instance, 在 Create an instance 對話框, 使用所有的預設設定。 點擊 Create 安裝 ApacheBench 還是在 VM Instance 視窗, 點擊 instance-1 的 SSH 按鈕來 SSH 連線到你剛剛建立的 VM 輸入以下指令來安裝最新版的 ApacheBench: sudo apt-get update sudo apt-get -y install apache2-utils 點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 施加負載以及監控現在你將使用 ApacheBench 來施加負載到你的服務。 檢視 Stackdriver 的 DMDash 顯示面板來監控 CPU 使用率以及 Network Inbound Traffic 。 你也將能夠藉由將滑鼠移到線上來追蹤 instance 的數量, 或者到 Cloud 主控台 (Navigation menu &gt; Compute Engine &gt; VM) 在 SSH 視窗, 輸入這個指令讓 ApacheBench 來施加負載到服務。 將 Your_IP 替換成你的轉發 IP 。 執行以下的指令兩到三次來創造流量。 ab -n 1000 -c 100 http://&lt;Your_IP&gt;:8080/ 範例輸出This is ApacheBench, Version 2.3 &lt;$Revision: 1757674 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking 35.196.195.26 (be patient)Completed 100 requestsCompleted 200 requestsCompleted 300 requestsCompleted 400 requestsCompleted 500 requestsCompleted 600 requestsCompleted 700 requestsCompleted 800 requestsCompleted 900 requestsCompleted 1000 requestsFinished 1000 requestsServer Software:Server Hostname: 35.196.195.26Server Port: 8080Document Path: /Document Length: 40 bytesConcurrency Level: 100Time taken for tests: 0.824 secondsComplete requests: 1000Failed requests: 0Total transferred: 140000 bytesHTML transferred: 40000 bytesRequests per second: 1213.57 [#/sec] (mean)Time per request: 82.402 [ms] (mean)Time per request: 0.824 [ms] (mean, across all concurrent requests)Transfer rate: 165.92 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 36 37 0.5 37 40Processing: 36 43 8.7 38 73Waiting: 36 43 8.7 38 73Total: 73 80 9.1 75 112Percentage of the requests served within a certain time (ms) 50% 75 66% 78 75% 81 80% 84 90% 95 95% 101 98% 106 99% 110 100% 112 (longest request) 等幾分鐘, 然後將負載提升到 5000 執行以下的指令兩到三次來創造流量。 ab -n 5000 -c 100 http://&lt;Your_IP&gt;:8080/ 等幾分鐘, 將負載提升到 10000 執行以下的指令兩到三次來創造流量。ab -n 10000 -c 100 http://&lt;Your_IP&gt;:8080/ 現在讓我們來看看, 當我們降低每台 instance 的 CPU 使用率時, 會發生什麼事 在 cloud 主控台, 點擊 Navigation menu &gt; Compute Engine &gt; Instance group 點擊你的 instance group 名稱, 然後 “Edit Group” 將 Target CPU usage 變更為 20 點擊 Save target CPU usage 是在這一個 instance group 當中的每一台 VM 的總使用率。 它控制何時自動擴充啟動。 在正式生產環境中, 通常你至少會設定 60% 。 在這個案例中, 你將會暫時性地將它設定成 20% 來更快地檢視自動擴充行為 執行以下的指令兩到三次來創造流量。ab -n 10000 -c 100 http://&lt;Your_IP&gt;:8080/ 可預測的行為: 當負載消耗了超過 20% 的群組累積 CPU, 將觸發自動擴充。 一個新的 instance 會被建立 現在看看當你把自動擴充關閉後, 會發生什麼事 到 Compute Engine &gt; Instance groups 點擊你的 instance group 名稱, 點擊 Edit Group 將 Autoscaling 變更為 Off 點擊 Save 等幾分鐘, 然後執行以下指令來創造流量 ab -n 10000 -c 100 http://&lt;Your_IP&gt;:8080/ 可預測的行為: 當 autoscaling 處於關閉狀態, 新的 instance 不會被建立, 所以累積 CPU 將會上升 結果Stackdriver 顯示面板大概會有五分鐘的延遲才會看到改變 模擬服務中斷移除防火牆規則來模擬服務中斷 點擊 Navigation menu &gt; VPC Network &gt; Firewall rules 勾選防火牆規則 allow-8080 旁邊的方格, 然後在頁面上方點擊 Delete 你將會在 15 到 30 分鐘後收到通知 email 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 恭喜你已經完成本教程！","link":"/zh-tw/deploymentManagerFullProduction/"},{"title":"使用 vsftpd 在 GCP VM 上部署 FTP Server","text":"前言本篇將分享： vsftpd 的設定細節 建立一個特定的 FTP user 使用 gcloud command line 開啟相對應的防火牆 環境 GCP VM ubuntu 18.04 安裝 vsftpdsudo apt install vsftpd 設定檔 打開設定檔 sudo vim /etc/vsftpd.conf 設定參數如下： # 如果不想跑在預設的 21 port, 這個必須要打開listen=YES# 承上，如果 listen 為 yes, 這個必須是 NOlisten_ipv6=NO# 是否允許匿名者登入，預設是 NO。此例子中，我們只允許我們設定的 user 存取 server, 所以設定為 NOanonymous_enable=NO# 本篇目的是要建立一個特定使用者，並且只允許這位使用者登入，所以須為 YESlocal_enable=YES## 允許寫入的權限write_enable=YES# 該使用者的預設 umasklocal_umask=002# 在每個資料夾內，我們可以建一個檔名為 `.mssage` 的檔案，裡頭輸入訊息，當登入者進到這個資料夾實，就會顯示這則訊息dirmessage_enable=YES# 使用當地時間use_localtime=YES# 當登入者上傳或下載檔案時，都將之記錄下來xferlog_enable=YES# 檔案傳輸的 port 為 20, 我們用被動模式, 所以選 NOconnect_from_port_20=NO# 啟用被動模式pasv_enable=YES# xferlog 的位置，可以更改xferlog_file=/var/log/vsftpd.log# 是否使用正式格式。 選擇 NO 的話會比較易讀，但若有使用 log 分析軟體，建議選 YESxferlog_std_format=YES# 當使用者登入時，會顯示的歡迎訊息ftpd_banner=\"Welcome to QCDN's FTP server, feel free to upload whatever you would like to deploy on Website.\"# chroot 意思就是 change root，是否要將使用者預設就限制在自己的根目錄內，為了安全性考量，此選項建議打開, 否則登入者就被允許在你的 server 裡面閒晃chroot_local_user=YES# 允許這項功能的話，我們可以建立一個列表，列表裡頭的使用者將被允許可以離開自己的根目錄chroot_list_enable=YES# 乘上，該列表位置chroot_list_file=/etc/vsftpd.chroot_list# 須為一個名稱為 empty 的資料夾，且使用者不可對該資料夾有寫入的權限。當使用者未獲得檔案存取權限之前，會被限制在這個資料夾內secure_chroot_dir=/var/run/vsftpd/empty# 這是用來管理使用者權限的一個檔案，檔案位於 /etc/pam.d/vsftpd, 裡頭可以找到一個被限制存取的列表, /etc/ftpusers, 如果你不想讓哪一位使用者存取，你只要把他的帳號加到這個檔案裡頭就行了pam_service_name=vsftpd## 利用 TLS 加密傳輸的資料，本篇不使用rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NO# 為了要指定每個不同登入者的家目錄，這邊取得登入者的變數user_sub_token=$USER# 指定本地登入者的 root 位置, 若指定在別的位置，會跟 chroot 相衝突，如果要將使用者限制在自己的根目錄，需指定此路徑local_root=/home/$USER/ftp# 如果不想使用預設的 21 port, 可以自己指定 port 號listen_port=21212# 預設0, 使用任何 port 號。 這邊是一個被動模式的 port 使用範圍。 當伺服器端收到使用者端的被動模式要求，伺服器端會從這個區間內回覆使用者端一個用來傳輸資料的 port 供資料傳輸使用pasv_min_port=40000# 預設0, 使用任何 port 號。 這邊是一個被動模式的 port 使用範圍。 當伺服器端收到使用者端的被動模式要求，伺服器端會從這個區間內回覆使用者端一個用來傳輸資料的 port 供資料傳輸使用pasv_max_port=50000# 啟用 userlist 功能來限制可以存取的使用者，其功能基本上跟 pam 是類似的，是另外一種方式, 若要啟用，為 YESuserlist_enable=YES# 當此值為 YES, 則填入下一個設定檔中的帳號為禁止存取。 當此值為 NO, 為嚴格模式，只有被加入檔案的使用者可以存取userlist_deny=NO# 呈上，為使用者限制的列表檔案userlist_file=/etc/vsftpd.userlist# 每秒存取的最大流量 bytslocal_max_rate=10000000# 是否允許被限制在 chroot 的使用者有寫入的權限，因為我們要允許使用者上傳檔案，所以為 YESallow_writeable_chroot=YES# 預設為0, 表示無限制。 最大允許連線 server 的用戶端數量max_clients=50# 預設為0, 表示無限制。 來自同 ip 的最大允許連線數量max_per_ip=5# 是否使用 TCP Wrappers。TCP wrappers 是透過用戶端想要連結的程式檔名，然後分析用戶端的 IP ，看看是否需要放行tcp_wrappers=YES# 是否允許紀錄兩種不同格式的 logdual_log_enable=YES# log 的位置vsftpd_log_file=/var/log/vsftpd.log 建立 usersudo adduser test 之後再輸入密碼，假設為 1234 建立相關設定檔sudo touch /etc/vsftpd.chroot_list &amp;&amp; sudo mkdir /home/test/ftp &amp;&amp; sudo touch /etc/vsftpd.userlist &amp;&amp; sudo touch /var/log/vsftpd.log 權限設定 我架設這個 FTP Server 主要是要讓前端可以簡單地利用上傳來做簡單的部署，所以下面才會有 www-data 的相關權限設定。 有興趣可以看看，不然跳過也沒關係，因為這跟 FTP Server 沒有很直接的關係 建立共同群組此資料夾，預設只有該使用者以及 nginx 的 www-data 可以存取，所以先建立共同群組 sudo groupadd ftp_access 將 ftp 使用者以及 www-data 加入此群組 sudo usermod -a -G ftp_access test &amp;&amp; sudo usermod -a -G ftp_access www-data 設定權限 sudo find /home/test/ftp -type d -exec chmod 2770 &#123;&#125; \\; &amp;&amp; sudo find /home/test/ftp -type f -exec chmod 0664 &#123;&#125; \\; &amp;&amp; sudo chmod /home/test/ftp test:ftp_access 設定允許存取者echo 'test' &gt; /etc/vsftpd.userlist GCP 防火牆設定給機器加 tag 我個人習慣用 gcloud shell, 可以選擇以下兩種方式 從官網安裝SDK 可參考 GCP 提供的 gcloud shell 網頁版, 快速教學 在此 若你對 gcloud 不熟，也可以選擇使用網頁 UI 操作 登入跟開機器的部分就略過，因為不在本篇主題範圍內 給機器加 taggcloud compute instances add-tags instanceName \\--tags test 開啟防火牆 依據指定的 tag 來開啟防火牆，這樣才不會開到所有的機器上 開啟連線 port gcloud compute firewall-rules create ftp-communication --allow tcp:21212 --target-tags test 開啟 passive port 的範圍 gcloud compute firewall-rules create ftp-dataportrange --allow tcp:40000-50000 --target-tags test FTP 連線安裝 mac brew install inetutils ubuntu應該已經有了 重啟sudo service vsftpd restart;sudo service vsftpd status 應該要是 running 連線ftp -p yourIP 21212 輸入我們設定 user: test 輸入密碼: 1234 試試上傳一個檔案put whateverFile 結論沈浸在技術研究的感覺總是令人沈醉，雖然當遇到難題時，還真的想大醉一場有設定到 www-data 的部分，那是因為其實這個 FTP server 是架設來讓前端可以做簡單的部署，只要把 code 上傳，我的 NginX 會有一個 config 是反向代理這個資料夾, 不過因為跟本篇較無關係，看看就好！ 參考資料 我心目中的 Linux 之神，鳥哥大http://linux.vbird.org/linux_server/0410vsftpd.php Digital Ocean 的大神https://www.digitalocean.com/community/questions/proper-permissions-for-web-server-s-directory","link":"/zh-tw/ftpServer/"},{"title":"Stackdriver Logging 的根本應用","text":"概述Stackdriver Logging 是 Google Cloud Platform (GCP) Stackdriver 套裝產品的一部分。 它包含紀錄的儲存，一個使用者介面名為 Logs Viewer, 還提供 API 讓你可程式化的去管理紀錄. 使用 Stackdriver logging 來讀寫紀錄, 搜尋以及篩選紀錄, 匯出紀錄, 以及建立記錄指標 在這個練習中, 你將學習如何使用 Stackdriver Logging, 在同一個地方累積應用的 logs, 通過篩選來取得實際上需求的 紀錄, 理解如何建立紀錄指標來進行更進階的分析, 稽核紀錄 的使用案例, 以及匯出紀錄如果有更進階分析的需要 你需要做什麼？ 部署一個 Google App Engine 應用的範例來產生紀錄 使用 Stackdriver Logging 主控台來對應用產生的紀錄做相關操作 建立 Stackdriver monitoring 記錄指標 建立 Stackdriver logs 的 Export 至 Google BigQuery 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 部署應用使用 Cloud Shell 命令行工具來部署 guestbook, 一個 Google App Engine 的範例應用。 這個網頁應用將會產生我們需要的紀錄 從遠端 Clone guestbook 應用 git clone https://github.com/GoogleCloudPlatform/appengine-guestbook-python.git 移動到 clone 下來的資料夾內 cd appengine-guestbook-python/ 部署 guestbook 應用 gcloud app deploy app.yaml index.yaml 選擇離你較近的地區 Please choose the region where you want your App Engine application located: [1] europe-west2 (supports standard and flexible) [2] us-east1 (supports standard and flexible) [3] us-east4 (supports standard and flexible) [4] asia-northeast1 (supports standard and flexible) [5] asia-south1 (supports standard and flexible) [6] australia-southeast1 (supports standard and flexible) [7] southamerica-east1 (supports standard and flexible) [8] us-central (supports standard and flexible) [9] europe-west3 (supports standard and flexible) [10] europe-west (supports standard and flexible) [11] cancelWhen prompted to continue type &quot;Y&quot;:Do you want to continue (Y/n)? Y 輸入 “Y” 繼續。幾分鐘後，應用將會被完全部署完畢 檢視以及搜尋紀錄移動到 Stackdriver Logs Viewer 設置要檢視的紀錄 選擇Navigation menu &gt; Logging &gt; Logs Viewer Stackdriver Logging 主控台有以下功能： (1) 服務篩選器： 根據資源種類篩選 (2) 紀錄篩選器： 根據選擇的資源的特定類型來篩選 (3) 紀錄等級篩選器： 篩選特定紀錄等級 (4) 日期篩選器： 根據特定日期篩選來檢視之前發生的問題 (5) 切換持續串流 (6) 一個搜索框，可以根據文字，標籤，正則，進階篩選器來搜尋 產生紀錄 造訪早前建立的 Google App Engine 應用 (guestbook) 來產生用來檢視的紀錄 在一個新的網頁視窗，打開 guestbook 應用，應用的 URL 如下： https://&lt;PROJECT_ID&gt;.appspot.com 用位於 lab 左方面板上的GCP Project ID來替換&lt;PROJECT_ID&gt; 或者，你也可以從 Cloud Shell (當你部署 App Engine app 時的輸出) 複製完整的 URL，然後在新的網頁視窗貼上 如果你看到Internal Server Error, 那是因為 Datastore Index 還沒準備好，等個一分鐘再重新整理瀏覽器 預測該有的結果： 當你在你的瀏覽器視窗看到 App Engine Guestbook, 這代表你的 App Engine 應用已經部署且驗證完畢，讓我們來產生一些紀錄吧 重整瀏覽器幾次，並且輸入一些名字到 Guestbook 應用來產生一些紀錄 回到 Stackdriver Logs Viewer 篩選器Logs Viewer 提供多樣化的基本篩選以及進階篩選的搜尋功能 基礎篩選 一樣在 Logs Viewer，在第一個下拉式窗 (服務選擇器)，選擇GAE Application &gt; Default Service &gt; All version_id, 表示我們想要檢視該服務的紀錄。這會顯示 guestbook 的所有紀錄 在下一個下拉選單 (紀錄選擇器), 選擇All logs 在下一個下拉選單 (紀錄等級選擇器), 選擇Any log level 其他下拉選單為默認值, 你的 Basic Filter 應該看起來是像這樣 注意，當你更換選擇時紀錄清單會自動重整 進階篩選器使用進階篩選器來進一步訂做你的搜尋 在Filter by label or text search下拉選單，選擇Covert to advanced filter 注意，你選擇的基礎篩選器已經在進階篩選器被轉譯成查詢表達式 在進階篩選器的輸入文字區塊，加上下面新的一行。 輸入新的一行來看自動完成功能 protoPayload.latency&gt;=0.01s 這行顯示所有延遲大於或等於 0.01 秒的 GAE app 紀錄 點擊Submit Filter然後檢視更新過的紀錄資料，可看到所有延遲超過 0.01 秒的紀錄 回到基礎篩選模式。點擊右上方，位於進階篩選器文字區塊區中的箭頭，在下拉選單選擇Clear filters and return to basic mode 紀錄指標紀錄指標是根據於紀錄的內容的 Stackdriver Monitoring 指標。 因此，你的紀錄不會只坐在那什麼事情也不做就等著別人來發現錯誤; Stackdriver Monitoring 會自動地監控你的紀錄，監控那些你定義的事件以及指標。由此可見，紀錄指標真是一個監控你客製化應用的一個絕佳的好方式。如果你的應用可以寫紀錄到 VM 的文件系統，你可以在那之上建立監控系統。 Stackdriver Monitoring 提供兩種使用者定義的紀錄指標 - Counter 以及 Distribution 計數器指標 (Counter Metrics)計數器指標計數那些符合進階紀錄篩選器的紀錄內容。舉例來說，一種指標，計數著那些，在特定資源中，代表某些類型的錯誤的紀錄內容。當很多拜訪你網頁的使用者收到了 HTTP 500 錯誤，想要收到警告嗎？ 計數器指標可以幫到你 分佈指標分布指標從紀錄中，累積那些符合篩選器的數據資料並且做數學運算。來說說一個分佈指標的普遍運用，像是追蹤一段時間的延遲模式/趨勢。當收到每一筆紀錄，延遲的數據會從紀錄中被取出並且加到分佈。累積的分佈將會有規律間隔的被寫到 Stackdriver Monitoring 建立計數器指標在此節中，你將建立一個計數器指標來計數成功拜訪網站的次數 - 在這個例子中，所有帶的 HTTP 200 的紀錄都算 依然在 Logs Viewer, 在select service的下拉選單中，選擇GAE Application &gt; Default Service 在log level selector下拉選單中，選擇All logs, 你的篩選器應該看起來如下： 在紀錄清單中，點擊狀態 “200” (任何列有 200 就行) 然後選擇Show matching entries 你將會看到 清單只會列出狀態 200 的紀錄 在進階的篩選編輯器中，一條進階的篩選條件已經自動地被建立了 protoPayload.status=200 根據你的篩選器建立一個監控指標 點擊Create Metric 來建立監控指標，根據你的進階篩選器 在指標編輯器中，根據下圖賦值，其他的欄位留為預設值就可 點擊Create Metric 下滑紀錄指標清單來檢視剛剛建立的回應 200 的指標, 你的新指標被列在最尾端， User-defined Metrics 的區塊中 在下圖三點圖案處點擊，選擇 View in Metrics Explorer 來檢視回應 200 的指標 在 Metrics Explorer 視窗打開 Stackdriver 主控台大概會需要一分鐘的時間 在 Metric Explorer, 點擊 GAE Application 資源類型，應該在數秒後會被自動增添進去 如果在資源類型選項中你沒有看到 GAE Application 關閉 Metrics Explorer 視窗 重整你的 guestbook app 幾次，來產生紀錄數據 等待一分鐘，等你的記錄數據被添載進去 (在你重整 App Engine app 之後), 很有可能會花 2 到 3 分鐘 點擊三個點圖案，選擇View in Metrics Explorer 一旦紀錄有被吃到，你將會看到 GAE Application 出現在Resource types 選擇器當中 這個指標已經準備好可以監控並且分析你應用的行為 建立一個分佈指標在此節中，你將會建立一個分佈計數器來監控 guestbook 應用的延遲 回到 Stackdriver Logging Console &gt; Logs Viewer, 建立一個篩選器來選擇GAE Application &gt; Default Service, All Logs, 以及 Any Log Level, 如下圖: 在頁面上方點擊Create Metrics 在指標編輯器的面板中，設定如下圖中的值 點擊Create Metric 核對延遲指標已經被建立在使用者定義的指標中 產生更多紀錄。重整 guestbook 應用多次，給指標 1 到 2 分鐘去取得以及累積新的紀錄資料 點擊三個點的圖案，然後點擊View In Metrics Explorer, 如下圖: 跟之前一樣，從resource type點擊GAE Application, 然後確認一下指標是你剛剛建立的那一個 如果GAE Application沒有自動載入 關閉 Metrics Explorer 視窗 重整你的 guestbook app 幾次，來產生紀錄數據 等待一分鐘，等你的記錄數據被添載進去 (在你重整 App Engine app 之後), 很有可能會花 2 到 3 分鐘 點擊三個點圖案，選擇View in Metrics Explorer 一旦紀錄有被吃到，你將會看到 GAE Application 出現在Resource types 選擇器當中 在 Stackdriver 監控主控台中檢視紀錄指標Stackdriver Monitoring Overview 視窗提供監控資源縱覽，紀錄指標就被列在圖表中 Stackdriver 會用這四種格式的其中一種來顯示圖表資料: Line, Stacked Bar, Stacked Area, 或是 HeatMap, 如果你想要指定格式： 在其中一個圖表點擊三個點的圖案，然後點擊Edit 在格式的下拉選單中，選擇一種格式 點擊Save把四種格式都試試看，看哪一種可以最好的呈現延遲指標 也試試其他圖表 稽核紀錄GCP 默認為所有的 GCP 資源提供稽核。稽核紀錄提供了 “誰做的？什麼時候做的？”, 讓我們來看看稽核紀錄吧，讓我們從建立一台 VM 開始。 開啟一台 VM 算是稽核權限活動的一種，所以會產生紀錄 開啟一台 VM 來產生稽核紀錄事件 在 GCP 主控台，選擇Navigation menu &gt; Compute Engine &gt; VM Instances 等待 Compute Engine 服務初始化 點擊Create 依下圖設定相關欄位中的值，其餘的保留預設 點擊Create 在活動檢視器中檢視稽核紀錄GCP Dashboard 的活動檢視器提供快速檢視稽核紀錄的功能 點擊主控台視窗上方的Google Cloud Platform來回到 GCP Dashboard 切到 ACTIVITY 視窗，你可能要點擊Navigation menu來關閉選單，所以才能看到ACTIVITY視窗 檢視最近的稽核紀錄數據，可以看到在最上面，有很多跟建立 VM 相關的數據 在上面的截圖，注意到四筆紀錄數據記錄著 VM 的建立以及與之相關的 HTTP 防火牆規則 點擊其他行來看看他們說明些什麼。是否有認出這好像是在本教程中我們先前做過的動作 從 Stackdriver 記錄檢視器來檢視稽核紀錄在 Stackdriver 記錄檢視器中，就像在活動檢視器一樣，你可以看到稽核紀錄數據。不同的是，記錄檢視器提供了更多功能，像是進階的篩選器以及其他的記錄管理功能 從 GCP 主控台回到 Stackdriver 記錄檢視器 (Navigation menu &gt; Logging &gt; Logs Viewer) 在service selector, 選擇 GCE VM Instance &gt; All instance_id 在 logs selector 下拉選單，選擇cloudaudit.googleapis.com/activity, 然後點擊OK 檢視與Create VM 以及 Completed對應的兩筆稽核紀錄, 以及在活動檢視器看到的Create VM紀錄 看看基本篩選器是怎麼呈現的，對比進階篩選器。從標籤或文字搜尋下拉視窗，點擊篩選器，並且轉換成進階篩選器，看看進階篩選器的代碼如下： 進階篩選器只顯示 GCE instance 的被稽核的活動 放寬範圍來看看 GCP 服務的所有稽核紀錄。 移除第一行，第一行限制了稽核紀錄的範圍，然後點擊Submit Filter 檢視所有在 Google Cloud Platform 上被使用者所執行的活動 在任何一行，點擊你的 Qwiklabs 使用者名稱（信箱）, 然後點擊Show matching entries 這增加了一行新的規則到進階篩選器中，限制只顯示被你所執行的活動 匯出紀錄Stackdriver Logging 保留 30 天的記錄，超過就刪除。如果你要保留紀錄久一點，你可以將他們會出到其他的儲存系統，或者 sink, 像是 BigQuery 。 Stackdriver Logging 可以讓你設定自動化的匯出腳本，所以所有的紀錄都會自動地被匯出。 紀錄也可以在你選擇的接收器被進一步的分析 建立一個匯出工作設定一個匯出工作來發送所有的稽核紀錄到 BigQuery 來長期儲存與分析。 在 Stackdriver 記錄檢視器的視窗，從進階篩選器移除第二行，然後點擊Submit Filter, 然後你可以檢視 GCP Project 所有的稽核紀錄 在頁面的上方，點擊Create Export，然後依照下圖輸入值 點擊Create Sink。 點擊Close離開接收器建立確認視窗 在 BigQuery 檢視稽核紀錄 開啟 BigQuery, 選擇Navigation menu &gt; BigQuery 關閉歡迎標語 在左邊面板處，點擊 Project ID 旁邊的箭頭來展開 GCP 專案名稱，來看新的 AuditLogs 資料 注意到 AuditLogs 之下還沒有任何的表格。 Log Exporting 會再匯出作業建立之後，開始發送資料到接受器。 Log Exporting 會產生一些稽核記錄數據，然後會再接受器建立表格，並且開始存入資料 回到 VM instance 視窗 (Navigation menu &gt; Compute Engine &gt; VM instances) 點擊 GCE VM instance 來檢視細節 點擊上方的Edit, 對 VM 做兩個小變更 (1) 勾選Enable connection to serial ports 的小格子，來允許連續 port 的連線 (2) 往下滑，勾選Allow HTTPS Traffic來允許 HTTPS 連線 點擊Save 到主要 GCP Dashboard 的 Activity 視窗，你應會看到一些 Audit Log 數據，包含一個叫做 “Set metadata on VM (設定 VM 的中繼資料)”, 另一個叫做 “Create firewall rule (建立防火牆規則)”, 還有一些其他跟 VM 變更有關的。 你將會看到一個叫做 “Create Table (建立表格)” 的事件，顯示 BigQuery 接收器已經被建立 約一分鐘後(你可能需要重整頁面), 你將會看到 Audit Log 數據，顯示 BigQuery 的表格已經被更新了，更新資料為我們剛剛變更 VM 之後而產生的新的 Audit Log 數據。 看一下時間戳記來辨認所有 BigQuery 有接收到，那些與這次 VM 變更有關的數據資料 回到 BigQuery 主控台，展開 AuditLog 資料組。你可能需要重整頁面。 你應會看到新的 cloudaudit 表格已經被建立了，點擊它 使用 BigQuery 來探查稽核紀錄 點擊新的 cloudaudit 表格, 然後點擊 Query Table 按鈕 Query Editor 的輸入文字處已經事先仔入一部分的 SQL query, 且游標置於 “SELECT”, 以及 “FROM” 在 “SELECT” 以及 “FROM” 之間輸入 *, 然後點擊 Run 幾分鐘後，查詢完成了，你會在下方的結果處看到 Audit Log 數據, 有很多欄位, 裡頭有些是巢狀的 點擊結果視窗的任何地方，然後使用方向鍵來左右移動，可以看到稽核紀錄非常的詳細 現在定義一個範圍小一點的查詢來檢視每個稽核數據的大概 (1) 在右上方點擊 Compose New Query (2) 複製下面的 code, 貼到查詢編輯器 SELECTtimestamp,resource.type,protopayload_auditlog.authenticationInfo.principalEmail,protopayload_auditlog.methodNameFROM `&lt;your-project-ID&gt;.AuditLogs.&lt;your_audit_log_table_name&gt;`WHERE protopayload_auditlog.authenticationInfo.principalEmail = \"&lt;your_qwiklabs_username_email&gt;\"LIMIT 1000 (3) 上面有些參數，參照下圖的表格內資訊替換 (4) 點擊 Run 來開始查詢。 你應會看到小一點的欄位，根據我們做的操作做限制，結果應會跟下圖相似: 這個簡單的查詢只是使用 BigQuery 來產生客制紀錄的一個範例，你可以建構任何數量的 SQL queries 來分析你的稽核紀錄來符合你的需求 恭喜，你已經完成本教程","link":"/zh-tw/fundamentalsOfStackdriverLogging/"},{"title":"Git 學習筆記","text":"前言Git 學習筆記, 學什麼記什麼！ Q&amp;A 如何在新建的檔案中, git add 部分的程式碼? git add -N new_filegit add -i Git 中, 如何指定 git 指令作用的目錄？ 比方說, 我目前的目錄不是 ~/code/project, 但我想要 git commit 作用的範圍在 ~/code/project? git -C `~/code/project` commit -m 'whatever'` Git 中, 如何取得當前 branch 最新的 commit 的 message? git log --oneline --format=%B -n 1 | cat %B: 輸出 subject + 主體 %s: subject %b: 主體 -n: 只顯示最新的幾筆 commit, 後面接數字, 也可使用 -(n) 方式","link":"/zh-tw/git/"},{"title":"Docker 技術筆記","text":"前言這是一份未整理過的 Docker 學習筆記 環境GCP - ubuntu 18.04 安裝移除舊版本sudo apt-get remove docker docker-engine docker.io containerd runc 安裝前設定更新 aptsudo apt-get update 使 apt 可以經由 HTTPS 使用倉庫 安裝以下套件，使 apt 可以經由 HTTPS 使用倉庫sudo apt-get install -y \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 增加 Docker 的正式 GPG 密鑰curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 核對一下我們現在擁有含有 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 指印的密鑰，我們可以搜尋最後八碼 sudo apt-key fingerprint 0EBFCD88 理應得到輸出如下： pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;sub rsa4096 2017-02-22 [S] 設定 Docker 倉庫版本 將 Docker 倉庫 設定為 stable 版，若要設定為 nightly 或 test 版，可在以下的指令中自由取代 stablesudo add-apt-repository \\ \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\" 安裝 Docker 安裝最新的 Docker CE 版本 sudo apt-get install docker-ce docker-ce-cli containerd.io -y 你也可以安裝特定版本的 Docker: 列出版本 apt-cache madison docker-ce 應該會得到輸出如下： docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 18.06.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages ... 使用上面輸出的第二欄位版本號，結合下面的指令來安裝特定版本 sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io 運行鏡像 hello-world 來驗證 Docker CE 是否已經正確安裝 sudo docker run hello-world 如果要使用非 root 身份運行 Docker 的話，可以把你的使用者加到 Docker 群組 sudo usermod -aG docker your-user 解除安裝 解除安裝 Docker CE sudo apt-get purge docker-ce 刪除所有的 image, containers, volumes, 可以使用以下指令。慎用！此指令適合解除安裝後使用。 sudo rm -rf /var/lib/docker/ docker 列出 Docker 的指令docker docker version 查看 Docker 版本docker version Docker info 查看 Docker 完美安裝資訊docker info docker network列出 networkdocker network ls 查看 networkdocker network inspect networkName 建立 networkdocker network create -d driverType networkName docker volume列出 volume 清單docker volume ls 列出特定 volume 訊息docker volume inspect volumeName 刪除 volumedocker volume rm volumeName 清除所有未掛載的 volumedocker volume prune docker container exec以 root 登入容器docker exec -it --user root &lt;container id&gt; /bin/bash 連接還在運行中的 containerdocker container exec -it yourContainerIDOrContainerName bash exec 在運行中的 container 中運行一個新的程序 docker cp傳檔案進 containerdocker cp file containerName:/location 確認 Docker daemon 運行狀況service docker status systemctl is-active docker Docker container run運行 containerdocker container run -it ubuntu:latest /bin/bash Docker container run 告訴 Docker daemon 開始一個新的 container -i 告訴 Docker daeman 讓 container 可以互動 -t 使目前的 terminal 視窗連接 container 的 shell ubuntu:latest 為開始這個 container 的 image /bin/bash 指定了我們想要運行 container 裡頭的哪一個程序 docker container run -d \\--name web1 \\ -p 8080:8080 \\test:latest -d 表示讓 container 運行在背景 ， 與 -it 相反，無法共存--name 指定 container 的名稱-p 指定 port ， 左邊的是外部可以從瀏覽器存取的 port ，右邊的是 container 向外暴露的 port 架設一個私有倉庫docker run -d -p 5000:5000 registry 我們也可以將上傳的映像檔備份一份到容器外docker run -d -p 5000:5000 -v outsideAddress:insideAddress registry 備份容器的 volume 比方說, 先建立一個容器叫做 dbstore, 並且內建一個匿名 volume, 掛在容器內的 /dbdata 位址 docker run -v /dbdata --name dbstore ubuntu /bin/bash 接下來, 備份的步驟如下： 建立一個新容器, 並且掛載 dbstore 上的 volume, 下面指令中的 --volumes-from 達成這一項 將本機的一個資料夾掛到容器中的 /backup, 下面指令中的 -v $(pwd):/backup 達成這一項 接下來, 我們要把從 dbstore 掛載過來的, 容器內的 /dbdata 資料夾備份到容器外, 下面指令中的 tar cvf /backup/backup.tar /dbdata 達成這一項 當備份完成後, 該容器內沒有其他執行的任務, 所以該容器關閉, --rm 會讓關閉後的容器自行銷毀 docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata 掛載一個 volumedocker run -d --name mysql2 -v mysql:/var/lib/mysql -p 3310:3306 -e MYSQL_ALLOW_EMPTY_PASSWORD=true mysql:5.7 -v: 外部建立一個 volume 叫做 mysql, 並且掛載到容器內部的 /var/lib/mysql 位置-p: 映射內外 port-e: 環境變數-d: 背景執行 連接到一個指定的容器docker run --name test2 --link test1 -d busybox /bin/sh -c \"while true; do echo hello; sleep 10; done\" 指定一個 networkdocker run --name test3 --network demo -d busybox /bin/bash --network: 指定連接到 demo network 與該 container 共享網路docker run --name test3 --network container:test2 -d busybox /bin/bash docker system查看 Docker 真實系統佔用空間docker system df 離開 container 但不關掉它CTRL + PQ docker container ls 列出運行中的 container docker container ls 列出所有的 container ， 包含已停止的 docker container ls -a or docker ps -a docker container stop 停止 containerdocker container stop containerIdOrContainerName docker container start 重新開始停止中的 containerdocker container start containerName docker rm 刪除 container docker rm containerID 刪除所有的 container docker rm $(docker container ls -aq) -f docker commit 將現有的 container 存成一個新的 imagedocker commit -m 'imageMessage' -a 'AuthorName' containerSHA imageName:imageTag Multi Stage (多階段構建) Multi Stage Build 範本# 給予該層一個名字, storefrontFROM node:latest AS storefront# 指定目前工作目錄WORKDIR /usr/src/atsea/app/react-app# 複製 context 中的 react-app 到當前目錄, 即上一行指令的 react-appCOPY react-app .# 執行 npm installRUN npm install# 執行 npm run buildRUN npm run build# 給予該層一個名字, 即 appserverFROM maven:latest AS appserver# 指定目前的工作目錄, 即 /usr/src/atseaWORKDIR /usr/src/atsea# 複製 context 中的 pom.xml 到當前位置, 即 atseaCOPY pom.xml .# 執行以下指令RUN mvn -B -f pom.xml -s /usr/share/maven/ref/settings-docker.xml dependency:resolve# 複製 context 中的所有檔案到容器內的當前目錄下, 即 atseaCOPY . .# 執行以下指令RUN mvn -B -s /usr/share/maven/ref/settings-docker.xml package -DskipTests# 該是最終鏡像了, 沒給 aliasFROM java:8-jdk-alpine# 執行以下命令RUN adduser -Dh /home/gordon gordon# 指令當前工作目錄WORKDIR /static# 從上面建構 storefront 中, 複製 /usr/src/atsea/app/react-app/build/ 當中的所有資料到當前工作目錄, 即 /staticCOPY --from=storefront /usr/src/atsea/app/react-app/build/ .# 指令當前工作目錄, 即 /appWORKDIR /app# 從上面建構的 appserver 中, 複製 /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar 到當前工作目錄, 即 appserverCOPY --from=appserver /usr/src/atsea/target/AtSea-0.0.1-SNAPSHOT.jar .# 指令 ENTRYPOINT, 該命令為容器啟動後默認一定會執行的命令, 無法被替換ENTRYPOINT [\"java\", \"-jar\", \"/app/AtSea-0.0.1-SNAPSHOT.jar\"]# CMD 在這個位置的角色為上面的 ENTRYPOINT 的 flag, 若在容器啟動指令輸入其他命令, 該 CMD 將會被替換掉CMD [\"--spring.profiles.active=postgres\"] -t 用來指定 image 的名字-f 可以用來指定名稱不是 Dockfile 的 DockerfileFrom 指定基礎 image 來源RUN 可以在 image 內執行 command 並建立新的 layer ，每一個 RUN 都會建立一層 layerCOPY 可以增加複製檔案到你的 image 內EXPOSE 暴露 APP 用的 portENTRYPOINT 設定當 image 被啟動為一個 container 時，預設執行的指令 Docker image pull 拉下 image docker image pull ubuntu:latest 根據 digests 拉下 image docker image pull imageNane@sha256:specificDigests docker image ls 列出下載過的 image docker image ls 列出下載過的 image 以及 digest docker image ls --digests docker rmi 刪除 image docker rmi imageID 刪除所有的 image docker image rm $(docker image ls -q) -f docker build 建立 image docker image build -t imageName:tagName . docker image inspect 列出一個 image 的結構docker image inspect inamgeID docker save 將 image 存成映像檔docker save -o outputFileName imageName:imageTag -o 代表 output docker logs 查 logdocker logs -f containerID Docker push 首先， tag 本地的 image 一個可以用來推上 DockerHub 的名字 docker tag localImageName:localTagName userAccount/toBeTaggedImageName:toBeTaggedImageTagName 推上 DockerHub docker push userAccount/taggedImageName:taggedImageTag Docker-Compose安裝 docker-compose 安裝 Docker Compose, 儘管我們可以從官方的 ubuntu 倉庫 安裝 Docker Compose ，但因為最新的版本中有很多細小的版本差異，所以我們從 Docker GitHub 來安裝。 先到官方頁面確認版本，並且視需求更新下面指令的版本號。 sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 設定權限 sudo chmod +x /usr/local/bin/docker-compose 確認 Docker-compose 版本 docker-compose --version 建立 yaml 檔案 vim docker-compose.yml 輸入內容如下： my-test:image: hello-world 建立一個 container docker-compose up 輸出理應如下： 建立一個 Swarm 開啟 docker swarm 模式docker swarm init \\--advertise-addr 0.0.0.1:8080 \\--listen-addr 0.0.0.1:8080 上面的 IP 跟 PORT 自己訂的--advertise-addr: 指定別的節點要連接這個 manager 時該使用的 IP 以及 port。這不是個必要的選項，但是你可以對哪個 IP 被使用有完全的控制權，並且你也可以訂一個不存在於節點上的 IP ，像是負載平衡的 IP --listen-addr: 讓你可以指定用來聽 swarm traffic 的 IP 以及 port ，通常他會跟 --advertise-addr 相同，但如果你想要限制 swarm 在特定的 IP，就特別有用。 還有一種情況，當 advertise-addr 是一個遠端的 IP ，像是平衡負載器，那這個也是必要的。 建議總是使用兩個附加選項。 從一個 node 開始 swarm mode ，並且設為 leader docker swarm init \\--advertise-addr yourInternalIP:yourPort \\--listen-addr yourInternalIP:yourPort 取得新增 manager 的 token docker swarm join-token manager 輸出大概如下： docker swarm join \\token SWMTKN-1-0uahebax...c87tu8dx2c \\10.0.0.1:2377 取得新增 worker 的 tokendocker swarm join-token token 輸出大概如下： docker swarm join \\token SWMTKN-1-0uahebax...c87tu8dx2c \\10.0.0.1:2377 重新產生 token docker swarm join-token --rotate managerOrWorker 開啟並且登入一台新的 instance ， 輸入上面的 token 還有自己的 IP 位址 docker swarm join \\token SWMTKN-1-0uahebax...c87tu8dx2c \\10.0.0.1:2377 \\advertise-addr yourInternalIP:yourPort \\listen-addr yourInternalIP:yourPort 不管你是想加入成為 manager 或是 workder ，只要輸入相對應的 token 就可以加入。 在 Leader 的 node 上可以查看 swarm 的詳細資料 docker swarm node ls 離開當前的 swarm docker swarm leave --force 開啟一個 SERVICE 要開立 service 首先必須確定， swarm 已建立。docker service create --name web-fe \\-p 8080:8080 \\--replicas 5 \\nigelpoulton/pluralsight-docker-ci docker service create: 建立一個 service--name: 指定 service 的名稱-p: 指定 container 內以及連接外部的 port--replicas: 在這個服務內，至少要有 5 個 containernigelpoulton/pluralsight-docker-ci: image 以及 tag 開立 service 之後， swarm 會一直的監看真實的狀態是否跟我的理想的狀態一致，如果一致的話那很好，如果不， swarm 會採取相對應的動作。舉例來說，如果五個 container 裡面有一個關閉了， swarm 會自動在啟動一個 查看 service 清單 docker service ls 查看 service 內的任務狀態 docker service ps serviceName 更詳盡的資訊 docker service inspect --pretty serviceName 擴展規模 docker service scale web-fe=10 刪除 service docker service rm web-fe 建立一個 overlay network docker network create -d overlay uber-net 連接到相同 overlay network 的 container ， 儘管他們的 docker host 連接的網路不同，彼此也可以互相溝通連接。 列出 network 資料 docker network ls 刪除一個 network docker network rm networkName 依據指定的 network 建立一個新的服務 docker service create --name uber-svc \\--network uber-net \\-p 80:80 --replicas 12 \\nigelpoulton/tu-demo:v1 --network: 指定 network 滾動升級 rolling update 滾動升級運行中的服務docker service update \\--image nigelpoulton/tu-demo:v2 \\--update-parallelism 2 \\--update-delay 20s uber-svc docker service update: 升級 service--image: 升級的 image 來源--update-parallelism 2: 一次升級兩個 container--update-delay 20s uber-svc: 每批次的等待時間為 20 秒 ， 需等當前批次的升級完成，時間才會開始計算。 最後指定要升級的 service 名稱 查看上次升級的參數docker service inspect --pretty serviceName 如上圖，前一次升級的參數都會被保留下來，除非你再次升級去覆蓋它 Composer 利用 container 安裝 Composer docker run --rm -v $(pwd):/app composer install --rm: 當 container 關閉後，自動刪除-v: 使用 volumes$(pwd):/app: $(pwd) 表示當前資料夾, /app 表示 container 裡頭一個叫做 app 的資料夾, 所以這個指令代表 : 前後的兩個資料夾會在 container 關閉之前，同步所有資料composer install: 安裝 composer 所以這個指令實際上做的事情，就是從 Docker Hub 拉下官方的 composer image ，然後開啟一個 container 並執行安裝， composer 會依照資料夾內 composer.json 或 composer.lock 來安裝相對應的 package 。 package 會被安裝在 app 這個資料夾內，但因為 volumes 的關係，所以兩個資料夾會同步， $(pwd) 內也會有安裝的 package 。 當安裝結束後， container 關閉，因為 --rm 的作用， container 會自動刪除。 利用 Docker-compose 部署 Laravel安裝 docker-compose 環境為 Ubuntu 18.04 安裝 Docker Compose, 儘管我們可以從官方的 ubuntu 倉庫 安裝 Docker Compose ，但因為最新的版本中有很多細小的版本差異，所以我們從 Docker GitHub 來安裝。 先到官方頁面確認版本，並且視需求更新下面指令的版本號。 sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 設定權限sudo chmod +x /usr/local/bin/docker-compose 利用 Docker 來安裝環境MySQL 安裝 MySQL ， 並指定連接一個外部不同的 port 號 ， 像是 52000docker run --name serviceName -e MYSQL_ROOT_PASSWORD=yourPassword -d -p 52000:3306 mysql:5.7 docker run: 啟動一個 container--name: 指定這個服務的名稱-e MYSQL_ROOT_PASSWORD: 指定環境參數-d: 使這個服務跑在 container 當中-p: 指定外跟內的 port 號， container 內部的 3306 連接外部的 52000mysql:5.7: 指定 image 以及 tag 連接本地安裝的 MySQL 以及 Docker container 內的 MySQL 本地安裝的 sudo mysql -uroot Docker Container mysql -h 127.0.0.1 -uroot -p2434 -P52000 製作 Docker image 時區問題我的第一個目標，是利用 Docker commit 來做一個專屬的 image。簡單來說，就是起一個純淨的 container ，然後在這個 container 裡頭部署完之後，再使用 docker commit 將這個 container 變成一個 image ， 結果發現在安裝 php7.2-imagick 中會出現 Configuring tzdata ，會彈出一個視窗並要求選擇時區，如下圖 後來找到解決方法，是在安裝 php7.2-imagick 之前就把時區設定好，所以在一開始就加入export DEBIAN_FRONTEND=noninteractive &amp;&amp; apt-get install -y tzdata &amp;&amp; ln -fs /usr/share/zoneinfo/Asia/Taipei /etc/localtime &amp;&amp; dpkg-reconfigure --frontend noninteractive tzdata MySQL 問題接下來，又遇到一個問題，在我利用我製作好的 image 開一個 container 時， MySQL 無法成功啟動，會一直出現 Failed後來的解決方法非常的奇怪，我是到 /var/www/mysql/mysql 中，下 chown -R mysql:mysql . 的指令，然後它就好了…可問題是，我仔細地確認過，在我下這指令之前，這個資料夾下的所有 user 以及 group 早就已經是 mysql:mysql 了 Apache 以及 MySQL 無法設定自動重啟的問題 所以我們必須要在 container 裏頭啟動這些服務，需要啟動的服務如下： Apache MySQL 所以從目前的進度看來， container 啟動之後，我們必須要執行三個指令，如下：chown -R mysql:mysql /var/www/mysql/mysqlservice apache restartservice mysql restart 沒想到實際執行之後，我們遇到了一個新的問題… Container 自動退出的問題Container 的特性，是只要 command 執行完畢後，就會自動退出。 container 一旦退出了，我們原本建構的環境當然也就不在了。我們怎麼可以容許這種事情發生呢？因此，我們需要給 container 一個會一直持續存在的指令，好比是 /bin/bash 該怎麼樣讓 container 在啟動的時候又執行多個指令呢？在 container 啟動時， 我們需要執行多個指令來啟動 container 裡面的服務，但是 entrypoint 只能帶一個指令進去，所以我們要寫一個 shell script ，然後當 container 開啟之後去執行這個 shell script ，當然，這個 shell script 裡頭的指令就是上述提到的指令，如下： chown -R mysql:mysql /var/www/mysql/mysqlservice apache2 restartservice mysql restart/bin/bash 假設這個 shell script 叫做 test.sh ，然後放在 /usr/sbin/ 之下，那我們的 docker 指令如下：docker run -dt --entrypoint \"/usr/sbin/test.sh\" -p 8880:80 --name containerName yourAccount/imageName:tagName ENV man 指令Docker 為了縮小 image 大小，預設不產生 man 說明文件。 在安裝 man 以及 man-pages 之前，需要先將此設定改掉 修改設定Docker 為了縮小 image 大小，預設不產生 man 說明文件。 在安裝 man 以及 man-pages 之前，需要先將此設定改掉vi /etc/yum.conf 將以下這行 comment 掉tsflags=nodocs 安裝 yum install man-pages -y; yum install man -y 更新 mandb mandb 安裝 vim 套件測試 yum install vim 測試 man vim 可以用了 Q &amp; A 當執行 Docker build 時, 如果不想要 context 中的某些資料夾或檔案被上傳到 docker daemon 去, 可以怎麼做？ 建立一個 dockerignore 檔案, 並將不想上傳的檔案或資料夾加進去 如果不想使用預設的 dockerfile, 可以怎麼做？ docker -t -f dockerFileNameYouWant . 在 Docker CLI, 哪一個 flag 可以指定環境變數？ -e 在 Docker CLI, 哪一個 MYSQL 的 flag 可以允許空的密碼？ -e MYSQL_ALLOW_EMPTY_PASSWORD=yes 在 Docker CLI, 哪一個 flag 可以指定 volume？ -v 如何列出 volume 清單？ docker volume ls 如何列出指定 volume 訊息？ docker volume inspect volumeName Docker 中, 預設的網路模式是？ Bridge 可透過何種方式證明 Docker 預設容器可互聯互通？ 在容器內取得 ip, 並使用 ping 當使用 –link 來連接到一個容器時, 實際上容器做了什麼事, 讓我們可以直接使用名字連接？ Docker 在 /etc/hosts 裡頭將 IP 以及該容器名稱做連結 Docker 當中, --link 是單向還是雙向的？ 單向 Docker 當中, --network 是單向還是雙向的？ 雙向 docker –network host 只在哪一個 OS 上有用 Linux docker –network container 的效果? 與指定的 container 共用網路 docker –network host 的效果? 與當前宿主機同網路, 換言之, 不需 port binding docker –network none 的效果？ 不為容器配置任何網路 以下的 Docker command 會輸出什麼？ Hello, Cloud Man 。 環境變量 name 已經被值 Cloud Man 替換掉了 ENV name Cloud ManENTRYPOINT echo \"Hello, $name\" 以下的 Docker command 會輸出什麼？ Hello, $name 。 環境變量沒有被替換 ENV name Cloud Man ENTRYPOINT [\"/bin/echo\", \"Hello, $name\"] 以下的 Docker command 中, 如果要使輸出使用環境變量, 該怎麼修改？ 在 /bin/echo 跟 Hello, $name 之間新增 command -c ENV name Cloud Man ENTRYPOINT [\"/bin/echo\", \"Hello, $name\"] Docker 中, apt-get update 和 apt-get install 建議放在同一個 RUN 指令中執行, 為什麼？ Docker 會使用 Cache 如果指令沒有改變的話。 要是將這兩個指令分開了, 當執行到 apt-get update 時, 由於指令沒有變更, 所以 docker 使用緩存, 但是 apt-get install 這層的指令變了, 可能會變成使用很久之前的緩存來安裝新的套件的情況, 這樣就找不到套件了。 Docker 中, CMD 允許被使用者替換嗎？ 允許 Docker 中, 如果 CMD 已有設定, 但 docker run 之後沒有指令命令, 那 container 會執行哪一個命令？ CMD 如果 Dockerfile 中有多個 CMD, 哪一個為準？ 只有最後一個 CMD 有效 CMD 有幾種格式？ 三種 CMD 有哪三種格式？ exec, shell, CMD [“param1”, “param2”] 在 Docker image 中, CMD 設定為 [“/bin/echo”, “Hello World”], 執行 docker run -it [image] /bin/bash 時, 會怎麼樣？ 會只執行 /bin/bash Docker 中, ENTRYPOINT 有幾種格式？ 兩種？ Docker 中, ENTRYPOINT 有哪兩種格式？ exec, shell Docker 中, ENTRYPOINT 的參數可以被動態替換掉嗎？ 不行 在 Docker image 中, ENTRYPOINT 的設定為 [“/bin/echo”, “Hello”], CMD 為[“world”], 當我執行容器 docker run -it [image], 輸出為？ Hello world 在 Docker image 中, ENTRYPOINT 的設定為 [“/bin/echo”, “Hello”], CMD 為[“world”], 當我執行容器 docker run -it [image] Ray, 輸出為？ Hello Ray 在 Docker image 中, ENTRYPOINT 為 shell 格式時, CMD 跟 docker run 的參數會？ 被無視 在 Dockerfile 中, 哪三個指令會增加新的層數？ RUN, ADD, COPY 在多階段構建中, 如何從指定層數 COPY 東西過來當層 藉由 AS 給該層一個名字, 然後使用 COPY --from NAME 在 Docker 中, 如何使用 ENV 來更新 PATH 環境變量？ 如下 ENV PATH /new/directory:$PATH 在 Docker 中, 當 COPY 的內容變了, 緩存是否會失效？ 會哦 使用 docker-compose 部署 Laravel-LEMP下載專案並安裝依賴 下載專案 git clone https://github.com/laravel/laravel.git laravel-app 進到資料夾 cd laravel-app 安裝依賴套件 -v 同步當層目錄與容器內的 /app 執行命令 composer install --rm 當容器關閉時, 自動刪除容器 容器建立時, 外頭的 laravel-app 會與容器內的 /app 同步, 這時候在容器內部的 /app 執行 composer install, 安裝在容器內部 /app 資料夾內的 composer 套件會即時的同步到外頭的 laravel-app 資料夾內。 執行完畢後, 容器沒有其餘的任務, 因此容器會關閉, --rm 會自動刪除容器 更多 docker composer 的應用可參考官方文件 docker run --rm -v $(pwd):/app composer install 更改權限sudo chown -R $USER:$USER ~/laravel-app 建立 Docker Compose 檔案 建立並打開 docker-compose 設定檔 vim ~/laravel-app/docker-compose.yml 在 docker-compose 檔案中, 你將會自定義三個服務： app, webserver, 以及 db 。 在檔案中輸入以下的代碼, 別忘了將 MY_SQL_ROOT_PASSWORD 替換成你自己的密碼 # 版本version: '3'services: #PHP Service app: # 這裡建構客製鏡像, Dockerfile 之後會提到 build: # 上下文目錄為當層 context: . # Dockerfile 為當層的 dockerfile dockerfile: Dockerfile # 客製化鏡像的名稱 image: digitalocean.com/php # 容器名稱, 若不指定也可, 但 docker 會用歷史名人命名 container_name: app # 若停止自動重啟 restart: unless-stopped # 為避免容器開啟後即關閉, 設定 tty: true tty: true # 環境變數 environment: SERVICE_NAME: app SERVICE_TAGS: dev # 當前工作目錄 working_dir: /var/www # 持久化數據 volumes: # 將當層目錄與容器內的 /var/www 同步 - ./:/var/www # 將當層目錄下的 php/local.ini 與容器內的 /usr/local/etc/php/conf.d/local.ini 同步 - ./php/local.ini:/usr/local/etc/php/conf.d/local.ini # 使用的網路為 app-network networks: - app-network #Nginx Service webserver: # 使用官方 nginx:alpine 鏡像 image: nginx:alpine # 容器名稱, 若不指定也可, 但 docker 會用歷史名人命名 container_name: webserver # 若停止自動重啟 restart: unless-stopped # 為避免容器開啟後即關閉, 設定 tty: true tty: true # 將容器內的 80, 443 port 跟宿主機的 80, 443 port 對接 ports: - \"80:80\" - \"443:443\" # 持久化數據 volumes: # 將當層目錄與容器內的 /var/www 同步 - ./:/var/www # 將當層目錄下的 nginx/conf.d/ 與容器內的 /etc/nginx/conf.d/ 目錄同步 - ./nginx/conf.d/:/etc/nginx/conf.d/ # 使用的網路為 app-network networks: - app-network #MySQL Service db: # 使用官方 mysql:5.7.22 鏡像 image: mysql:5.7.22 # 容器名稱, 若不指定也可, 但 docker 會用歷史名人命名 container_name: db # 若停止自動重啟 restart: unless-stopped # 為避免容器開啟後即關閉, 設定 tty: true tty: true # 將容器內的 3306 port 跟宿主機的 3306 port 對接 ports: - \"3306:3306\" # 設定環境變數 environment: # 資料庫名稱, 可自定義 MYSQL_DATABASE: laravel # 資料庫密碼, 可自定義 MYSQL_ROOT_PASSWORD: your_mysql_root_password SERVICE_TAGS: dev SERVICE_NAME: mysql # 持久化數據 volumes: # 將自定義的數據卷 dbdata 跟容器內的 /var/lib/mysql/ 目錄做同步 - dbdata:/var/lib/mysql/ # 將當層目錄下的 mysql/my.cnf 跟容器內的 /etc/mysql/my.cnf 做同步 - ./mysql/my.cnf:/etc/mysql/my.cnf # 使用的網路為 app-network networks: - app-network#Docker Networksnetworks: # 定義 network 名稱 app-network: # 定義 network driver 為 bridge, 還有其他類型如 host, none, container 等等... driver: bridge#Volumesvolumes: # 定義數據卷名稱 dbdata: # 定義數據卷類型 driver: local app: 運行 Laravel build 客制鏡像 digitalocean.com/php, 下面會有建立的 dockerfile 使用客製的鏡像 digitalocean.com/php, 將當前工作目錄設在了 /var/www webserver: 使用官方 nginx:aline 鏡像 將容器內的 80 以及 443 port 接到宿主機的 80 以及 443 port db: 使用官方 mysql:5.7.22 鏡像 定義一些環境變數, 包含資料庫名稱, 資料庫密碼, 這部分可以依個人需求更改 將容器內的 3306 接到宿主機的 3306 port 我們把容器名稱跟服務名稱定義成一樣, 如果我們不定義容器名稱, Docker 會自動使用歷史上有名的人物的名稱來命名 我們為不同容器群組定義了專屬的 network, 位於相同 network 下的容器可以互相溝通, 反之則不行, 這確保了高等級的安全性, 不同類型的容器群不可以互相溝通, 像是前端只能跟前端溝通, 後端跟後端 建立 Dockerfile# 使用官方 php:7.3-fpmFROM php:7.3-fpm# 複製 composer.lock 以及 composer.json 從上下文資料夾複製到鏡像內的 /var/www/COPY composer.lock composer.json /var/www/# 設定工作目錄為 /var/wwwWORKDIR /var/www# 安裝依賴# mariadb-clientRUN apt-get update &amp;&amp; apt-get install -y \\ build-essential \\ mariadb-client \\ mysql-client \\ libpng-dev \\ libjpeg62-turbo-dev \\ libfreetype6-dev \\ locales \\ zip \\ jpegoptim optipng pngquant gifsicle \\ vim \\ unzip \\ git \\ curl# 清除 /var/cache/apt/archives 下的所有 deb 檔, 以及清除 /var/lib/apt/lists/ 下的所有安裝檔RUN apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*# 安裝 extensionsRUN docker-php-ext-install pdo_mysql mbstring zip exif pcntlRUN docker-php-ext-configure gd --with-gd --with-freetype-dir=/usr/include/ --with-jpeg-dir=/usr/include/ --with-png-dir=/usr/include/RUN docker-php-ext-install gd# Install composerRUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer# 建立 laravel 應用 user# 建立 group www 並指定 GID 為 1001RUN groupadd -g 1001 www# 建立 user www 並指定 UID 為 1001, 將之加入群組 wwwRUN useradd -u 1001 -ms /bin/bash -g www www# 複製檔案以及重新定義權限COPY --chown=www:www . /var/www# 將使用者切換到 wwwUSER www# 暴露 9000 portEXPOSE 9000# 執行 php-fpmCMD [\"php-fpm\"] PHP 設定檔現在我們需要建一個 PHP 設定檔來同步宿主機以及容器內 建立資料夾 mkdir ~/laravel-app/php 設定檔 vim ~/laravel-app/php/local.ini 設定檔內容範例, 你可以添加其他設定 # 單檔的最大上傳限制upload_max_filesize=40M# 整個 post 的最大限制post_max_size=40M Nginx 設定檔 建立資料夾 mkdir -p ~/laravel-app/nginx/conf.d 建立設定檔 vim ~/laravel-app/nginx/conf.d/app.conf 範例設定檔內容, 可視需求添加 server &#123; # 監聽 80 port listen 80; # 尋找 index.php index.html index index.php index.html; # error log 位置 error_log /var/log/nginx/error.log; # access log 位置 access_log /var/log/nginx/access.log; # 資源的默認位置 root /var/www/public; # 如果請求是 php 結尾的話, 進到 location location ~ \\.php$ &#123; # 尋找 uri, 若沒找到則 404 try_files $uri =404; # fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass app:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; &#125; location / &#123; try_files $uri $uri/ /index.php?$query_string; gzip_static on; &#125;&#125; 設定 MySQL 建立資料夾 mkdir ~/laravel-app/mysql 建立設定檔 vim ~/laravel-app/mysql/my.cnf 輸入設定檔內容, 可自行添加 [mysqld]# 產生 loggeneral_log = 1# log 位址general_log_file = /var/lib/mysql/general.log 運行容器以及修改 env 設定 建立 .env cp .env.example .env 運行容器 docker-compose up -d 查看容器 docker ps 修改 .env 檔 docker-compose exec app vim .env DB_CONNECTION=mysql# DB 容器服務DB_HOST=dbDB_PORT=3306# 上面設定的 databaseNameDB_DATABASE=laravel# 上面設定的 userNameDB_USERNAME=laraveluser# 上面設定的 passwordDB_PASSWORD=your_laravel_db_password 產生 key docker-compose exec app php artisan key:generate 開啟 cache","link":"/zh-tw/docker/"},{"title":"串接 Facebook graph API","text":"前言本篇將分享如何使用 JavaScript SDK 讓用戶登入並取得 token, 然後利用 PHP SDK 向 Facebook 發請求, 進而取得使用者的資訊。 到FB的開發者頁面, 申請一個帳號, 並且在主控台的地方, 新增一個應用程式 到應用程式內的基本資料裡頭, 複製應用程式編號以及應用程式密鑰創建 Laravel 專案laravel new Facebook 初始化 Gitgit init 安裝 Facebook PHP SDK 於專案目錄下composer require facebook/graph-sdk 建立一個稍後用來向 FB 拿資料的 Controllerphp artisan make:controller FBController 建立一個 getFacebookResources function 複製 Facebook SDK 首頁的範例程式碼,並貼在這個 function 裏頭 require_once __DIR__ . &apos;/vendor/autoload.php&apos;; // change path as needed$fb = new \\Facebook\\Facebook([ &apos;app_id&apos; =&gt; &apos;&#123;app-id&#125;&apos;, &apos;app_secret&apos; =&gt; &apos;&#123;app-secret&#125;&apos;, &apos;default_graph_version&apos; =&gt; &apos;v2.10&apos;, //&apos;default_access_token&apos; =&gt; &apos;&#123;access-token&#125;&apos;, // optional]);// Use one of the helper classes to get a Facebook\\Authentication\\AccessToken entity.// $helper = $fb-&gt;getRedirectLoginHelper();// $helper = $fb-&gt;getJavaScriptHelper();// $helper = $fb-&gt;getCanvasHelper();// $helper = $fb-&gt;getPageTabHelper();try &#123; // Get the \\Facebook\\GraphNodes\\GraphUser object for the current user. // If you provided a &apos;default_access_token&apos;, the &apos;&#123;access-token&#125;&apos; is optional. $response = $fb-&gt;get(&apos;/me&apos;, &apos;&#123;access-token&#125;&apos;);&#125; catch(\\Facebook\\Exceptions\\FacebookResponseException $e) &#123; // When Graph returns an error echo &apos;Graph returned an error: &apos; . $e-&gt;getMessage(); exit;&#125; catch(\\Facebook\\Exceptions\\FacebookSDKException $e) &#123; // When validation fails or other local issues echo &apos;Facebook SDK returned an error: &apos; . $e-&gt;getMessage(); exit;&#125;$me = $response-&gt;getGraphUser();echo &apos;Logged in as &apos; . $me-&gt;getName(); 填入應用程式編號以及應用程式密鑰 上頭的範例中, 在以下地方填入我們從 FB 開發者帳號中得到的資訊$fb = new \\Facebook\\Facebook([ &apos;app_id&apos; =&gt; &apos;應用程式編號&apos;, &apos;app_secret&apos; =&gt; &apos;應用程式密鑰&apos;, &apos;default_graph_version&apos; =&gt; &apos;目前版本&apos;, //&apos;default_access_token&apos; =&gt; &apos;&#123;access-token&#125;&apos;, // optional]); 建立使用者登入按鈕 使用者要先登入進而拿到 token, 我們才可以使用 token 來做事 於 routes/web.php 檔案中, 新建一個給登入頁面使用的 route Route::get(&apos;/FBToken&apos;, function()&#123;return view(&apos;FBToken&apos;);&#125;); 於 resources/views/ 資料夾底下, 新增 FBToken.blade PHP 檔, 然後在裡頭貼上以下的 JS code &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Facebook Login JavaScript Example&lt;/title&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; // This is called with the results from from FB.getLoginStatus(). function statusChangeCallback(response) &#123; console.log(&apos;statusChangeCallback&apos;); console.log(response); // The response object is returned with a status field that lets the // app know the current login status of the person. // Full docs on the response object can be found in the documentation // for FB.getLoginStatus(). if (response.status === &apos;connected&apos;) &#123; // Logged into your app and Facebook. testAPI(); &#125; else &#123; // The person is not logged into your app or we are unable to tell. document.getElementById(&apos;status&apos;).innerHTML = &apos;Please log &apos; + &apos;into this app.&apos;; &#125; &#125; // This function is called when someone finishes with the Login // Button. See the onlogin handler attached to it in the sample // code below. function checkLoginState() &#123; FB.getLoginStatus(function(response) &#123; statusChangeCallback(response); &#125;); &#125; window.fbAsyncInit = function() &#123; FB.init(&#123; appId : &apos;&#123;your-app-id&#125;&apos;, cookie : true, // enable cookies to allow the server to access // the session xfbml : true, // parse social plugins on this page version : &apos;&#123;api-version&#125;&apos; // The Graph API version to use for the call &#125;); // Now that we&apos;ve initialized the JavaScript SDK, we call // FB.getLoginStatus(). This function gets the state of the // person visiting this page and can return one of three states to // the callback you provide. They can be: // // 1. Logged into your app (&apos;connected&apos;) // 2. Logged into Facebook, but not your app (&apos;not_authorized&apos;) // 3. Not logged into Facebook and can&apos;t tell if they are logged into // your app or not. // // These three cases are handled in the callback function. FB.getLoginStatus(function(response) &#123; statusChangeCallback(response); &#125;); &#125;; // Load the SDK asynchronously (function(d, s, id) &#123; var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = &quot;https://connect.facebook.net/en_US/sdk.js&quot;; fjs.parentNode.insertBefore(js, fjs); &#125;(document, &apos;script&apos;, &apos;facebook-jssdk&apos;)); // Here we run a very simple test of the Graph API after login is // successful. See statusChangeCallback() for when this call is made. function testAPI() &#123; console.log(&apos;Welcome! Fetching your information.... &apos;); FB.api(&apos;/me&apos;, function(response) &#123; console.log(&apos;Successful login for: &apos; + response.name); document.getElementById(&apos;status&apos;).innerHTML = &apos;Thanks for logging in, &apos; + response.name + &apos;!&apos;; &#125;); &#125;&lt;/script&gt;&lt;!-- Below we include the Login Button social plugin. This button uses the JavaScript SDK to present a graphical Login button that triggers the FB.login() function when clicked.--&gt;&lt;fb:login-button scope=&quot;public_profile,email&quot; onlogin=&quot;checkLoginState();&quot;&gt;&lt;/fb:login-button&gt;&lt;div id=&quot;status&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同樣, 在上面的程式碼中需填入編號及版本號, 如下 FB.init(&#123; appId : &apos;編號&apos;, cookie : true, // enable cookies to allow the server to access // the session xfbml : true, // parse social plugins on this page version : &apos;版本&apos; // The Graph API version to use for the call&#125;); 熟悉 FB graph API 工具 利用 FB graph API 測試工具,我們可以找到我們需要的 API 客製 endpoint 因為之後我們可能會直接複製經由 graph API 工具 取得的 endpoint, 如下： 所以我們可以把 endpoint 這段移到 .env 中, 如下： $endpoint = env(&apos;FBEndpoint&apos;);try&#123; // Get the \\Facebook\\GraphNodes\\GraphUser object for the current user. // If you provided a &apos;default_access_token&apos;, the &apos;&#123;access-token&#125;&apos; is optional. $response = $fb-&gt;get($endpoint, $token); 然後 .env 裡頭 FBEndpoint=me?fields=id,name,email 如此一來, 之後我們只要直接複製 graph API 取得的值, 貼到 .env, 打完收工！ 修改錯誤回傳值 PHP SDK 預設錯誤時, 會依照錯誤狀況回傳錯誤訊息, 可我只需知道 true or false, 就行了, token 無效有可能是因為以下幾種狀況 根本沒帶 帶的是錯的 過期了 不管是哪一種, 我都需要回傳錯誤訊息給前端, 並要求前端再去跟 FB 要一次, 拿對的來, 所以說, 我必須要判斷 PHP SDK 的輸出, 有沒有錯誤, 若錯做一件事, 對也做一件事, 因此我們需要修改原本錯誤訊息輸出的地方, 改成簡單的 true or false, 如下：catch (\\Facebook\\Exceptions\\FacebookResponseException $e) { return false; // echo &apos;Graph returned an error: &apos; . $e-&gt;getMessage(); // exit; } 取得 public url 使用 ngrok 取得用來拿 token, HTML 頁面的 public url 登入開發者應用程式 =&gt; 找到產品 Facebook 登入 =&gt; 快速入門 =&gt; 網站 =&gt; 貼上 public url 登入取得 token將 token 打到 Laravel 裡的 FBController 裡頭的 getFacebookResources將取得的資料,存入資料庫,完成會員建檔打完收工","link":"/zh-tw/getINFOViaFBToken/"},{"title":"伸縮自如的 git flow","text":"前言今天將分享一個具有以下特性的 git flow: 在開發過程中，可以隨意 commit 測試完成後，即可將相對較友善於開發的 commit 轉換成正式上線標準的 commit 兩個分支檔案內容完全相同，但卻擁有完全不相干的 commit 歷史 以 Ray 來說，我在開發時，習慣畫流程圖，並且將我腦中覺得可行的邏輯一條條寫下來，然後實踐。 通常一個大功能可能會由好幾個邏輯組成，而這個 git flow 讓我可以在一個 feature 分支上，將我的每一個小邏輯都記錄下來，分成一個個 commit 。 最後確定沒有問題了，在轉換成正式上線時需要的大功能 commit 。在實踐這個 git flow 的過程中，我對 git rebase 的熟悉與日俱增，並且訓練自己以更嚴謹的方式來做每一個 commit。以下 Ray 個人覺得這個 git flow 可以帶來的好處： 因為 commit 很小，邏輯單一，不管是在實驗或是除錯方面，都有不可言諭的便利性。 利用小 commit 的方式將邏輯都記錄下來，一方面讓自己的思緒清晰，一方面讓每一個功能的邏輯清清楚楚。 看似複雜的流程，但其實熟悉之後，分支的整理只是一瞬間，可以在開發過程中更加的熟悉 Git 的進階操作。 因為 commit 很小，可以訓練較嚴謹的 commit 風格。 理想的 commit今天提出的 git flow 只是一個舉例，不一定適用於每一個人，但重點是在實現這個 git flow 所需要的概念！ 當我們在本地 commit 時，我們傾向這個 commit 可以越小越好，因為越小越純粹功能越單一的 commit ，不管是在 Debug ，或是邏輯實驗與印證都有不可言傳，只可意會的妙用！ 例如呢？讓我們具體一點! 當今天你在 Debug ，發現印出來的東西不如你的預期。你嘗試不同的方式來測試，直到印出的數據是你想要的！ 如果你的 commit 有符合上面的原則，在這個時候呢，在每一次失敗的嘗試之後，你不需要繁複的修修改改。你只需要簡單的git reset --hard 就算你一個 commit 邏輯整個錯了，如果你的 commit 功能夠單一，要拿掉這個 commit ，你只需要git reset @^ --hard 我們想要的是什麼？然而，正式上線的 git flow 不容許我們這樣做。正式上線的 git flow 通常會要求推上去的每一個 commit 都要’指定的功能正常’。意思可以理解說，如果要將 commit 最小化，那很有可能我們會需要多個最小化的 commit 來組成一個正式上線公司所需要的大功能。 需求整理 開發時： 我們需要隨時可以 commit 的靈活度，功能越單一越好 正式上線後： 我們需要每一個 commit 都符合公司指定的要求，功能正常 該選哪一種？人家說，魚與熊掌，不可兼得，真的是這樣嗎？可以兩種都要嗎？ 歸納具體需求那先來歸納一下，我們具體上，需要的東西 我們需要一支本地開發的 develop 分支，在這分支上，只要你爽，你想怎麼 commit 就怎麼 commit 我們需要一支正式要推上線的 master 分支，在這分支上，每個 commit 都代表著公司指定的功能 上面兩個分支，被 commit 的檔案內容是完全一樣 (選擇性)以上兩個分支我都要保留其各自獨特的歷史 具體看起來是？如下圖可以看到，左邊是檔案內容，右邊是 commit ，大家可以看到，在 develop branch 上，每個 small function 都對應到相應的檔案，這只是範例，表達我們所要的最小 commit 的概念。 master 分支:接下來，如下圖我們來看看實際上線時， commit 應該是什麼樣子。我們可以看到，在 master branch 上，我們只有4個 commit ，而每個 commit 都包含了4個檔案(除了 .gitignore 的 commit 之外)。這只是範例，表達正式上線時所需求的 commit 標準往往比我們理想的最小 commit 還要大。 範例連結 實作一切的起點通常 .gitignore 會是一切的起點！ 使用 vim 建立 .gitignore 檔案，然後輸入想要 ignore 的檔案，再按 :wq 離開。 vim .gitignore 完成第一個 commit git add .ignore; git commit -m 'Added .gitignore'; develop 分支接下來，我們將以 master branch 為基礎，建立 develop branch ，如同前面敘述的， develop branch 上面的 commit 會是最細最小的，而 master branch 上的 commit 會是符合正式上線標準的。 首先，從已經設定好 .gitignore 的 master 分支為基礎，建立 develop 分支 git checkout -b develop feature 分支然後呢，我們要開始開發了！ 建立一個 feature 分支 這個 feature 分支代表當前正在開發的功能 這邊所說的功能，是依照正式上線的標準 所以，一個功能等於一個 feature 分支git checkout -b feature; 自由的 commit 在 feature branch 上，我們可以隨便 commit ，可以完全依照我們本身的 commit 習慣，把 commit 做到最細小，以享受在開發以及測試過程中帶來的方便 建立檔案1~4，然後每個檔案分別代表一個最細小的 committouch &#123;1..4&#125;;git add 1;git commit 1 -m 'small function 1';git add 2;git commit 2 -m 'small function 2';git add 3;git commit 3 -m 'small function 3';git add 4;git commit 4 -m 'small function 4'; 功能完成了 在測試完成之後，確定沒有問題了！現在我們要把我們 commit 的標準轉換成正式上線的標準 如同前面提過的， feature branch 的開發範圍，是以正式上線的一個功能為單位 所以呢？我們要將一整個 feature branch ，濃縮成一個 commit 因為我們要保有兩個分支，所以我們不可以直接在 feature branch 幹這件事，因為 develop branch 會需要它！ 這邊特別說明一下，其實以這個 git flow 來說，開發過程中的 develop 分支不見得需要保留，但本篇範例會以如果你需要保留的狀況下來實作。如果開發用的 develop 不須保留的話，程序上會簡化很多。 用來 merged 的分支 為正式上線的 master branch 來建一個一次性的 toBeMerged branch git checkout -b toBeMerged 接下來，要把 toBeMerged branch 變成符合被 master branch merge 的狀態 git rebase -i master 壓縮、重新命名 commit 然後，我們剛剛有說過，我們要將多個開發流程中的最小 commit 壓縮成一個正式上線的 commit ，對吧？所以我們要將所有的 commit 往前壓縮，可以利用 fixup 這個選項，再來，正式上線的 commit 名稱肯定會跟我們開發時的 commit 名稱不同，所以這邊我們要重新命名這個壓縮後的 commit ，如下： reword 96c6c18 small function 1fixup 1dd84d2 small function 2fixup 1a71401 small function 3fixup f9c90c6 small function 4 接下來，我們將這個壓縮過後的 commit 命名為 big function 1 然後:wq存檔離開 此時使用git log來看看，看起來會像是下圖那樣git log merge 讓我們回到 master 來把它 merge 掉吧！ git checkout master;git merge toBeMerged; 接下來，切到 develop ，並且 merge feature branch git checkout develop;git merge feature; 最後，把已經被 merge 完成的 feature branch 以及 toBeMerge branch 刪掉吧！ git branch -D feature toBeMerged 複習一下，還記得我們要的是什麼嗎？ 在 develop 分支上，是最小的 commit 在 master 分支上，是正式上線標準的 commit 兩個分支的檔案內容必須要一模一樣 (選擇性的)同時保有兩個分支 看看我們的現在的 master 分支是否跟我們要的一樣？ git checkout master;git log 看看檔案內容ls 看看 develop 分支的 commit git checkout develop;git tag 'bigFunction1'git log 看看檔案內容 ls 第二階段 一樣的流程，建立 feature branch ，然後是 toBeMerge branch git checkout develop;git checkout -b feature;touch &#123;5..8&#125;;git add 5;git commit -m 'small function 5';git add 6;git commit -m 'small function 6';git add 7;git commit -m 'small function 7';git add 8;git commit -m 'small function 8';git checkout -b toBeMerged; 重點來了，這時我們不能使用傳統的 rebase 來改造 toBeMerged branch ，因為 toBeMerged branch 的歷史不曾存在於 master branch 。 讓我們想想，toBeMerged branch 應該要是什麼樣子才符合我們要的，適合被 master branch merge ？ 兩者要有共同的歷史(同sha1值) 先前已經被 merge 過的，未壓縮過的 commit 不可以重複出現。簡單來說， samll function 1~4 早就被壓縮成 big function 1 了，所以 small funciton 1~4 不可以再出現 master branch 上面沒有的內容，要壓縮成一個 commit 完成以上條件之後， toBeMerged branch 就可以被 master merge 了 第二次 rebase 與壓縮 所以具體該怎麼操作？ 我們將會使用到 git rebase 的進階應用 git rebase --onto 。我們 rebase toBeMerged branch 到 master branch 上，然後只要是 develop branch 上已經存在的 commit ，我們都不要，最後，將被 rebase 的 branch 叫做 toBeMerged，照這個順序往下排列，就成了以下的指令。 git rebase --onto 的用法，可以參考官方的文件 git rebase -i --onto master develop toBeMerged 然後同上，將最小的 commit 壓縮成一個正式上線的 commit reword 3668e72 small function 5fixup fd05fa1 small function 6fixup 3a87c08 small function 7fixup c38957e small function 8 壓縮後的 commit ，名稱為big function 2 重複之前步驟，該 merge 的 merge ，該刪的刪 來看看當前 develop 分支上的 commit 狀態，以及檔案內容 git checkout develop;git tag bigFunction2;git log --oneline develop 分支上的 commit ls develop 分支上的檔案內容 來看看當前 master 分支上的 commit 狀態，以及檔案內容 git checkout master;git log develop 分支上的 commit ls develop 分支上的檔案內容 總結此範例中的git flow，可以讓我們在開發過程中以最小的 commit 來進行，甚至是以任何我們喜歡的方式來進行，而不需因為正式上線的 commit 標準有所犧牲。過程看似複雜，看就 Ray 的使用經驗，如果相關原理都已經非常熟悉，其實指令輸入很快就完成了。範例中的 develop 分支不一定需要保留，因為日後若正式上線的 commit 有錯誤的話還是得從正式上線的 commit 來做修正，當然如果保留的話，應該還可以衍生一些其他的變化以及應用，這些就留待各位自己去發掘啦！若大家有任何想法歡迎在下面留言，我相信意見想法的交流是進步的捷徑。","link":"/zh-tw/flexibleGitFlow/"},{"title":"一下子敏感, 一下子不敏感, Git 你搞得我好亂啊","text":"概述在一個因緣際會之下, 我與 Git 有場美麗的邂逅, 殊不知, 對我這個情場處子來說, Git 就像一隻貓, 忽遠忽近, 忽冷忽熱, 忽上忽下, 忽快忽慢… 一下子敏感, 一下子又不敏感, 那個… 我說的是大小寫。 故事開始什麼是 case-sensitive 與 case-insensitive? 就是大小寫敏感 以及 大小寫不敏感! 不同的作業系統對於 case-sensitiveness 這件事情會有不同的設定, 拿 case-sensitive 的 Linux 來說, 在同一個資料夾我可以有檔案 a 跟檔案 A, 但是在 case-insensitive 的 MacOS 中, 檔案 a 即 A 試想, 在 Linux 中我在一個資料夾內有兩個檔案為 a 跟 A, 並且我都上了 commit 並推上遠端, 那這時在 MacOS 上將如何呈現這件事呢？macOS 視角: Commit 裡面有幾個我不管, 對我來說只有 一個 檔案, 因為 a 即 A 媽媽樂勒, 你搞得我好亂啊！ 該如何解決這件事情呢？ 我們可以使用 git 指令git config [--local/--global] core.ignorecase true/false 這個指令是在幹什麼的勒？它可以決定 Git 的世界是 如何看待 case-sensitiveness(大小寫敏感度) 這件事。 舉例來說, 在一個 git 專案中, 當我們今天設定為 true, 代表 case-insensitivegit config --local core.ignorecase true 這時候如果我們在 macOS 中變更檔名:mv a A 將原本控管中的一個 a 更名為 A, 這時候呢, 對 case-insensitive 的 macOS 來說檔案還是只有一個, 只是檔名變了, 所以什麼事都沒有改變。 同理, 對此設定的 Git 來說也是一樣的; 資料夾中不管是 A 還是 a, 對 Git 來說都是一個檔案, 因為目前的設定是 case-insensitive(大小寫不敏感), 所以如果我們使用以下指令檢查狀態:git status 我們是不會看到有任何 modified 的檔案的 但如果這時 Git 的設定為 false, 即 case-sensitive(大小寫敏感), 老天爺… 那就是完全不一樣的事了。先設定：git config --local core.ignorecase false 再改個檔名：mv a A 然後看個狀態：git status 這時我們會發現, 多了一個 new file A ! 因為這時 Git 的角度是 case-sensitive(大小寫敏感), a 對我來說是一個檔案, A 是另一個檔案, 所以我的 commit 中並不存在 A 這個檔案。 更有趣的事情, 使用git add . 然後新增一個 commit:git commit -m 'Add A' 這時在變更一次檔名：mv A a``` 然後檢視狀態：```bashgit status 此時我們可以發現, 已經不會有任何提示 modified 了, 因為此時在 Git 的 commit 中存有兩個檔案, 一個是 a, 一個是 A, 所以兩個我都有, 自然不會出現 modified 了 若要驗證這一點, 可以先在 GitHub 建立一個 repo, 然後將目前這個分支推上 GitHub, 再到 GitHub 上去看, 會發現… 傻眼貓咪勒… 我的資料夾內明明就只有一個檔案, 怎麼上了 GitHub 之後變兩個了? 再來, 我們試著變更這個檔案:vim a 隨便加個 “123” 之類的, 然後儲存並離開::wq``` 再檢視一下狀態：```bashgit status 嚇死寶寶, 竟然發現同時出現了 modified: A 以及 modified: a!!! 因為此時在 Git 的世界中是有兩個檔案的, 兩個都對應到資料夾中的檔案 a 有興趣的話, 你可以再做個實驗, 如果你有 Linux 系統的主機的話, 可以開一個專案, 使用以下指令來建立兩個檔案：touch a A 初始化 Gitgit init 做一個 commitgit add .git commit -m 'init' 先在 GitHub 上面開一個 repo, 然後推到遠端:git remote add origin yourRepoURLgit push -u origin master 這時候你可以到遠端看看, 遠端的資料夾內應該是確實會有 a 跟 A 兩個檔案, 因為 Linux 系統是 case-sensitive(大小寫敏感) 現在找一台 macOS 的電腦來 clone 專案：git clone yourRepoURL 進到專案內cd yourProject 檢視資料夾內容：ls 林周公勒！ 我剛剛明明就有看到兩個檔案, 阿怎麼少了一個？你應該只會看到 a 檔案, 因為 macOS 檔案系統是 case-insensitive 的 綜合以上所得, 我歸納出以下幾點： 佛曰一沙一世界, 獨自開發時, 請務必讓你的 Git config case-sensitiveness 的設定跟你的作業系統是一致的, 這樣至少兩邊行為一樣, 才不會把自己搞到精神錯亂啊! 如果 Git 設定為 case-insensitive, 那麼儘管你實際上有兩個大小寫不同, 但檔名相同的檔案, Git 只會視為一個。 如果 Git 設定為 case-sensitive, 那麼儘管你只是使用 mv 做小寫更名成大寫的動作, Git 還是會當作是有兩個不同的檔案 一個專案如果參與的開發者們橫跨了不同的作業系統, 那請一定要在這一點上有共識, 同一個資料夾內不要有同檔名但大小寫不同的檔案, 不然是想逼死誰？ 如果遇到需要重新命名檔名的話, 記得確保修改的是 commit 內 的檔名, 務必使用 git mv currentFileName newFileName Q&amp;A這邊將一些概念歸納成 Q&amp;A 的方式, 希望可以幫助理解 在 Git 中, 當我們設定 git config --local core.ignorecase true 時, 此時 git 為 case-sensitive 或 case-insensitive?case-insensitive 在 Git 中, 當我們設定 git config --local core.ignorecase false 時, 此時 git 為 case-sensitive 或 case-insensitive?case-sensitive macOS 的檔案系統是 case-insensitive 還是 case-sensitive?case-insensitive Linux 的檔案系統是 case-insensitive 還是 case-sensitive?case-sensitive 為什麼 Git 的 case-sensitiveness 跟作業系統的視角要一致？這樣才會兩邊的行為一致 結論天下無不散的宴席, 送君千里終須一別, 將琴寄語兮, 予以相將…不好意思讓你們聽到髒東西… 大家新年快樂！ 最後人非聖賢, 孰能無過… 阿不是, 是人非草木, 豈能無情…你清脆的掌聲於我, 有如浪頭與衝浪者的關係！ 讓我找到存在的價值…拍 1 下: 來都來了, 刻個到此一遊吧！拍 10 下: 覺得小生寫得還可以, 馬馬虎虎普普通通淒淒慘慘戚戚...拍 20~30 下: 這篇文章有幫助到你, 讓你的概念清晰了百分之零點零零一拍 40~50 下: 看完覺得心情愉悅, 或是覺得 Ray 很帥","link":"/zh-tw/gitSensitiveness/"},{"title":"Git-從哪裡開始？","text":"嗨大家好，我是Ray! 如上一篇提到，Git對於一個coder來說可以說是不可或缺的，今天我就來分享一下Git的基本操作 首先呢，讓我們先來創一個範例資料夾，名稱就叫做my-git-repository吧！ 到Command Line cd 你想要這個資料夾在哪的路徑/ 輸入mkdir my-git-repository 然後cd code/my-git-repository 進到資料夾內，code是我自己的母資料夾，各位請輸入你們自己的路徑 進到資料夾的位置，如下圖：￼ 讓我們在裡面建立一個檔案touch example1.html 然後在該檔案裡面添加以下內容：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 輸入git init ￼ 然後輸入 git status ￼ 如上圖所示，我們已經可以開始使用git的相關功能，目前example1的檔案還處於untracked狀態，在建立任何存擋點之前，我們必須要先將檔案加入追蹤，就好像我們在FB上追蹤那些名人一樣！ 輸入git add example1.html 如下圖：￼ 再來輸入git commit 看起來如下：￼ 應該會出現以下的畫面￼ 接著我們隨便輸入first example當作這個存擋點的訊息記錄 接著我們按:wq 儲存並離開視窗 輸入git status 看起來如上圖： 輸入git log 然後你應該可以看到一串代表著此次commit，獨一無二的號碼。￼ 你應該會看到以下的commit，commit 的號碼每個人都不同，所以如果你的號碼跟我的不同是正常的，不用覺得奇怪！ 這樣一來就算是完成了一次的存擋啦！之後我們可以隨時回到這個狀況只要我們想要的話！ 今天的分享就先到這啦，之後若有機會會再做進一步的介紹！","link":"/zh-tw/gitInit/"},{"title":"推錯了Commit該怎麼辦？","text":"有時我們把功能做好並且推上公共資料夾之後才發現，靠…我commit好像推錯了…別緊張，這時候我們可以使用git revert 來取消我們的commit。現在讓我來為各位做個示範： 建立一個本地遠端資料夾 因為有些朋友可能沒有網路，所以本篇範例將創立一個在本地的遠端資料夾 到你一般存放專案的資料夾底下 mkdir git_demonstration git_demonstration_central cd git_demonstration_central git init --bare git_demonstration_central將會是本篇範例中的遠端資料夾 建造本地測試環境 進到本範例本地資料夾 cd ../git_demonstration 初始化git git init 建立名為test的檔案 touch test 在檔案內增加內容1 cat 1 &gt; test 將test檔案加到git追蹤清單 git add test 針對目前檔案以及內容做一個commit名為1 git commit -m&#39;1&#39; 在檔案test中增加數字2，並做一個新的commit名為2 cat 2 &gt;&gt; test;git commit -am&#39;2&#39; 在檔案test中增加數字3，並做一個新的commit名為3 cat 3 &gt;&gt; test;git commit -am&#39;3&#39; 建立遠端branchBuild remote branch 將我們一開始建立的位於本地的模擬遠端資料夾加到當前測試環境的遠端 git remote add origin /user/yourUserName/yourDirectory/git_demonstration_central 將目前master branch 推到此遠端，並將遠端新增的分支設為本地的上游分支 git push -u origin master 到遠端資料夾看一下，目前狀況 cd ../git_demonstration_central;git log Revert已存在的commit 假設今天我們要將commit 3的內容移除 git revert f06550f7 更新到遠端 git push 看一下檔案test的內容是否已變更 cat test 得值1 2，原本數字3已經在revert之後被移除了 確認遠端歷史狀況 cd ../git_demonstration_central;git log 總結有些剛接觸git的人可能會跟我當初有同樣的疑問，那為啥不要整個git的log紀錄都抹掉就好，為啥要多一個commit？這邊跟大家解釋一下，如果今天我們已經把我們完成的進度推到共同資料夾了，我們就不建議去修改歷史了，因為你一但修改了歷史再往上推，整個共同資料夾的歷史就會改變，共同資料夾的紀錄相當於所有協作者的紀錄，所以如果你單方面變動了歷史，很可能會造成所有協作者的歷史都跟你的不一致，甚至在commit的過程中會有衝突，這在多人協作是相當不建議的。我們要拿掉的，是我們檔案內的一段有commit紀錄的code，所以實際上我們要取消的是code，不是歷史，而在多人協作中，歷史是可以增加，不建議修改的。你可以新增一個commit明確說明我這段commit是新增或者拿掉了什麼東西，但是不建議單方面地把東西拿掉並且去修改你的歷史紀錄，因為你改的東西只有你自己知道，對於其他的協作者來說他們並不知道在你的電腦上發生了什麼事。簡單來說，在你上傳到共同資料夾之前，你可以對你的歷史做任何事（這邊僅限於還未上傳的部分，已經上傳的不建議去修改），但是一但上傳之後，就不建議去修改歷史。如果你要對檔案內容做任何修改，請新增一個commit說明修改的內容，這樣才不會造成其他協作者的疑惑以及大家的git歷史有衝突。以上就是今天的分享，我們明天見！","link":"/zh-tw/gitRevert/"},{"title":"Gitlab 學習筆記","text":"前言個人 Gitlab 學習筆記，內容未整理過。 Event 通知Project =&gt; Settings =&gt; Integrations =&gt; Slack notifications","link":"/zh-tw/gitlab/"},{"title":"利用 Gitlab CI/CD 部署專案到 GCP virtual machine","text":"前言本篇將分享如下： 利用 gcloud 開立一台 GCP instance 如何利用 gcloud 在 instance 上匯入 ssh key 利用 Daemon 使服務常駐 利用 gitlab pusher 部署專案到 GCP virtual machine 上 環境建立開啟一台 GCP 虛擬機以下是個人做法，不需要照做 Ray 使用 Mac 所以我在本地端安裝了 Google Cloud SDK, 安裝方式可以參考官方文件 建立一台 VM 建立一台機器, 叫做 example-instance-1 開機碟的空間為 10GB 從 ubuntu-os-cloud, 來 pull 我們需要的 image 我們使用 ubuntu-1804-lts 的 image 版本, 這會自動使用這個版本的最新版 硬碟類型為 pd-stand, 不知道類型可以跑 gcloud compute disk-types list 來看看 機器型號為 f1-micro, 不知道類型可以跑 gcloud compute machine-types list 來看看 tags 用來當作該 instance 的一個識別，等等開防火牆的時候會用到 zone 指定該 instance 的地區, 有些資源只有相同 zone 或者 region 可以取用，要注意 如下:gcloud compute instances create example-instance-1 \\--image-project=ubuntu-os-cloud \\--image-family=ubuntu-1804-lts \\--boot-disk-size=10GB \\--boot-disk-type=pd-standard \\--machine-type=f1-micro \\--tags=example-instance-1,http-server,https-server \\--zone=asia-east1-a 開啟後，我們先來產 keyssh-keygen -t rsa -b 4096 -C \"root@example\" 假設 key 的名稱為 examplecat example.pub &gt; instanceSSHConfig &amp;&amp; vim instanceSSHList 在最前面加上 root, 格式如下：[USERNAME]:ssh-rsa [KEY] [USERNAME] 我們只有一把 key 獲得 instance 名稱gcloud compute instances list 新增 public key 到 instance(這邊請注意，這個指令會替換掉這個 instance 在 GCP 的 SSH key, 換言之，這個檔案裡面沒有的 key 都會消失)gcloud compute instances add-metadata instanceName --metadata-from-file ssh-keys=instanceSSHList 安裝以下主要是安裝 nvm, node 版本v12.1.0, 以及 npm, 細節可以參考官方文件apt-get update -y &amp;&amp; apt-get install curl -y &amp;&amp; curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash &amp;&amp; export NVM_DIR=\"$HOME/.nvm\" &amp;&amp; [ -s \"$NVM_DIR/nvm.sh\" ] &amp;&amp; \\. \"$NVM_DIR/nvm.sh\" &amp;&amp; [ -s \"$NVM_DIR/bash_completion\" ] &amp;&amp; \\. \"$NVM_DIR/bash_completion\" &amp;&amp; nvm install v12.1.0 &amp;&amp; apt-get install npm -y Daemon接下來，以下為 Daemon 設定, 我們將使用 Daemon 來幫我們跑我們的服務，並且讓我們的服務在斷開的時候可以自動重啟sudo vim /etc/init.d/serviceName #!/bin/sh### BEGIN INIT INFO# Provides: yourServiceName (optional)# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start daemon at boot time# Description: Enable service provided by daemon.### END INIT INFOdir=\"yourProjectLocation\"cmd=\"theCommandItRequiresToStartYourService\"user=\"root\"name=`basename $0`pid_file=\"/var/run/$name.pid\"stdout_log=\"/var/log/$name.log\"stderr_log=\"/var/log/$name.log\"get_pid() &#123; cat \"$pid_file\"&#125;is_running() &#123; [ -f \"$pid_file\" ] &amp;&amp; ps -p `get_pid` &gt; /dev/null 2&gt;&amp;1&#125;case \"$1\" in start) if is_running; then echo \"Already started\" else echo \"Starting $name\" cd \"$dir\" export NODE_ENV=test if [ -z \"$user\" ]; then sudo $cmd &gt;&gt; \"$stdout_log\" 2&gt;&gt; \"$stderr_log\" &amp; else sudo -u \"$user\" $cmd &gt;&gt; \"$stdout_log\" 2&gt;&gt; \"$stderr_log\" &amp; fi echo $! &gt; \"$pid_file\" if ! is_running; then echo \"Unable to start, see $stdout_log and $stderr_log\" exit 1 fi fi ;; stop) if is_running; then echo -n \"Stopping $name..\" kill `get_pid` for i in 1 2 3 4 5 6 7 8 9 10 # for i in `seq 10` do if ! is_running; then break fi echo -n \".\" sleep 1 done echo if is_running; then echo \"Not stopped; may still be shutting down or shutdown may have failed\" exit 1 else echo \"Stopped\" if [ -f \"$pid_file\" ]; then rm \"$pid_file\" fi fi else echo \"Not running\" fi ;; restart) $0 stop if is_running; then echo \"Unable to stop, will not attempt to start\" exit 1 fi $0 start ;; status) if is_running; then echo \"Running\" else echo \"Stopped\" exit 1 fi ;; *) echo \"Usage: $0 &#123;start|stop|restart|status&#125;\" exit 1 ;;esacexit 0 若發現找不到 service 的話，那需要重新載入 daemon sudo systemctl daemon-reload 記得更改權限，讓 deamon 可以執行 sudo chmod 755 serviceName 開啟自動重啟，當 VM 重啟時，服務會跟著重啟 sudo systemctl enable serviceName Daemon 的名稱在此範例中，會設置的跟專案名稱一樣 CI/CDGitlab variables setting 我們將使用 Gitlab 的 pusher 來做 CI/CD 的部分，所以這邊先建立一組 ssh key, 並且在 gitlab 中設定為 $SSH_PRIVATE_KEY ssh-keygen -t rsa -b 4096 -C \"root@deploy\" Gitlab yaml config file下面我們會開始設定 Gitlab 的 pusher config yaml 檔案在我們的專案中：vim .gitlab-ci.yml # This file is a template, and might need editing before it works on your project.# Official framework image. Look for the different tagged releases at:# https://hub.docker.com/r/library/node/tags/# 在 Docker 內部，我們要使用的環境 imageimage: node:8# This folder is cached between builds# http://docs.gitlab.com/ce/ci/yaml/README.html#cache# cache 可以讓我們使用在所有的 buildcache: paths: - node_modules/stages:- build- deploy# 只是個名字npm-build: stage: build script: # 刪掉 node_modules, 安裝最新版的 npm, 並更新 project 裡頭的 npm 套件 - rm -rf node_modules/ &amp;&amp; npm i npm@latest -g &amp;&amp; npm install # 只是個名字depoly-test:# 將在 `deploy` stage 做以下的事 stage: deploy script: # cfr. https://docs.gitlab.com/ee/ci/ssh_keys/README.html # Install ssh-agent if not already installed, it is required by Docker. # (change apt-get to yum if you use a CentOS-based image) # 如果 ssh-agent 不存在，更新 apt-get 並且安裝 openssh-client - 'which ssh-agent || ( apt-get update -y &amp;&amp; apt-get install openssh-client -y )' # Run ssh-agent (inside the build environment) # 當運行 ssh-agent -s 時，會輸出一些 command, 但是他們並還沒有被執行，所以必須使用 eval ，他可以用來執行迭代運算 - eval $(ssh-agent -s) # Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store # 將 $SSH_PRIVATE_KEY 加到 ssh agent - ssh-add &lt;(echo \"$SSH_PRIVATE_KEY\") # For Docker builds disable host key checking. Be aware that by adding that # you are suspectible to man-in-the-middle attacks. # WARNING: Use this only with the Docker executor, if you use it with shell # you will overwrite your user's SSH config. #- mkdir -p ~/.ssh #- '[[ -f /.dockerenv ]] &amp;&amp; echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config' # In order to properly check the server's host key, assuming you created the # SSH_SERVER_HOSTKEYS variable previously, uncomment the following two lines # instead. # 在 docker container 中，建立 .ssh 資料夾, 並設立權限 - mkdir -m 700 -p /root/.ssh # 使用 gz 格式來將位於當層的專案資料夾整個壓縮，並將壓縮檔丟到上一層目錄去 - tar zcf ../$CI_PROJECT_NAME.tar.gz ./ # 將壓縮檔丟到指定機器上的指定目錄 - scp -o StrictHostKeyChecking=no ../$CI_PROJECT_NAME.tar.gz root@35.201.171.244:/locationYouPrefer # 接下來，我們利用 ssh 到指定的機器，然後開始做以下的事 # 建立一個跟專案同名的資料夾 # 將剛剛打包好的檔案，解壓縮到這個資料夾內，並不顯示解壓縮訊息 # 更改專案資料夾的權限 # 進到資料夾中, npm rebuild, 並且打開事先設定好的 daemon service - ssh root@yourIP \"rm -rf /locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; mkdir -p locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; tar zxf locationYouPrefer/$CI_PROJECT_NAME.tar.gz -C locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; chmod -R 655 locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; cd locationYouPrefer/$CI_PROJECT_NAME &amp;&amp; npm rebuild &amp;&amp; /etc/init.d/$CI_PROJECT_NAME restart\" # 以上的 deploy stage 唯有在你指定的 branch 觸發 only: - branchYouPrefer 結論到這邊，當我們 git push 到指定的 branch 時，就會觸發 gitlab 的 pusher 來達成自動部署。","link":"/zh-tw/gitlabCICDOnGCP/"},{"title":"Git-標注一個版本號碼","text":"哈囉大家好，我是Ray！ 今天我將跟大家分享git tag，如何建立一個版本號。 當我們接二連三地完成了專案裡的一些功能，一系列的功能可能代表著一個版本的產生，比方來說，大家都玩過線上遊戲吧？ 每次改版時，常常都是釋出一些新的功能，這個版本號常常意味著，除了這些功能開發完成之外，並且都正常的運作著。 這個版本號對於開發者來說非常方便與重要，這樣來解釋，一系列的小功能構成一個大功能，而這個大功能的完成也代表著新版本的推出。 當每一次我們完成了一個小功能，我們使用git commit把它記錄下來，而當我們陸陸續續完成一系列的小功能而構成一個大功能時，我們使用git tag來標注，代表著一個版本的釋出。若日後我們需要回到這一版來做相關的一些測試的話，非常的方便！ 輸入 git log --oneline 以上是我們還沒有tag之前的樣子。 輸入git tag -a v1.0 -m “The stable version of example” 如上圖你可以看到我們剛剛加入的版本號 v1.0 輸入 git tag 可以看到我們至今tag的任何版本號 現在讓我們新增一個檔案，example2.html，並且新增以下的code: &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the experimental file created after reversion v1.0&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 然後輸入Git add example2.htmlgit commit -am “An example2 file after v1.0”Git log --oneline 如上圖，我們目前在第六個commit，而我們的版本是在第五個commit 當我們想要回到v1.0的版本時，我們不需要checkout第五個commit的名稱，我們只需要輸入版本編號即可，如下輸入： Git checkout v1.0Git log --oneline 如上圖，我們已經回到版本v1.0的紀錄了 希望我今天的文章對你有所幫助！","link":"/zh-tw/gitTag/"},{"title":"Google Cloud Pub/Sub 初探 - Command Line","text":"概述Google Cloud Pub/Sub 是一個可以讓你再不同的應用以及服務之間交換事件資料的訊息服務。 藉由分離發送者以及接收者, 它提供了一個在獨立、不同的應用之間的安全、高可用的訊息傳遞服務。 Google Cloud Pub/Sub 遞送低延遲/持久的訊息服務, 並且被開發者們廣泛地使用在實作異步工作流程, 分派事件通知, 以及不同的程序以及裝置的資料串流。 在本教程中, 你將會實作以下動作。 學習 Pub/Sub 的基礎 建立, 刪除, 以及列出 Pub/Sub 主題 建立, 刪除, 以及列出 Pub/Sub 訂閱 發布訊息到一個主題 使用提取訂閱者來輸出各自的主題訊息 使用提取訂閱者以及不同的 flag 來輸出多個訊息 前提這是一個入們級別的教程。 如果你只有一點 Pub/Sub 的相關經驗或是完全沒有經驗都是 okay 的, 且本教程會教你基本的設定以及使用 GCP 服務 在本教程之前, 評估一下你 Pub/Sub 的熟練度。以下是一些更有挑戰性的教程, 他們可以讓你使用你的 Pub/Sub 的知識在不同的 GCP 服務以及使用情境。 Dataflow: Qwik Start - Templates Building an IoT Analytics Pipeline with Google Cloud Platform Scanning User-generated Content Using the Cloud Video Intelligence and Cloud Vision APIs如果你想要從 Google Cloud 主控台使用 Pub/Sub, 別錯過這個教程： Google Cloud Pub/Sub: Qwik Start - Console 一旦你準備好了, 往下滑並且依照以下的步驟來設定你的教程環境。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Pub/Sub 基礎如同先前提到的, Google Cloud Pub/Sub 是一個異步的全同訊息服務。 這是三個會常出現在 Pub/Sub 用語： topics (主題), publishing (發佈), 以及 subscribing (訂閱) topic 是一個被分享的字串, 允許應用間通過一個共同的鏈來連結彼此。 發布者推送 (或 publish) 一條訊息到 Cloud Pub/Sub 主題 訂閱者向 topic 訂閱, 訂閱可以從訂閱來提取訊息, 或者可通過 webhooks 來推送訂閱。 每一個訂閱者必須在收到訊息後, 在一段設定的時間內給予確認 簡單來說, 一個生產者發布訊息到一個主題, 然後消費者對這個主題建立一個訂閱, 並且從這個訂閱收取訊息 Pub/Sub topic (主題)Pub/Sub 已被事先安裝在 Google Cloud Shell, 所以要使用這個服務不需要再安裝一次。 執行以下指令來建立一個主題, 名為 myTopic: cloudgcloud pubsub topics create myTopic 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 為了更佳的測試, 在建立兩個主題, 名為 Test1 以及 Test2 cloudgcloud pubsub topics create Test1 cloudgcloud pubsub topics create Test2 執行以下指令來檢視剛剛建立的主題： cloudgcloud pubsub topics list 輸出應會如下：name: projects/qwiklabs-gcp-3450558d2b043890/topics/myTopic---name: projects/qwiklabs-gcp-3450558d2b043890/topics/Test2---name: projects/qwiklabs-gcp-3450558d2b043890/topics/Test1 清除的時間到了。 執行以下指令來刪除 Test1 以及 Test2 cloudgcloud pubsub topics delete Test1 cloudgcloud pubsub topics delete Test2 再執行 gloud pubsub topics list 指令一次來確認主題已經被刪除了 cloudgcloud pubsub topics list 輸出應會如下： ---name: projects/qwiklabs-gcp-3450558d2b043890/topics/myTopic Pub/Sub subscription (訂閱)現在你已經準備好可以建立, 檢視, 刪除主題, 是時候試試看訂閱了 執行以下指令來建立對主題 myTopic 的訂閱, 名為 mySubscription cloudgcloud pubsub subscriptions create --topic myTopic mySubscription 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 再多增加兩個對 myTopic 的訂閱, 執行以下指令來建立 Test1 以及 Test2 訂閱 cloudgcloud pubsub subscriptions create --topic myTopic Test1 cloudgcloud pubsub subscriptions create --topic myTopic Test2 執行以下指令來列出對 topic 的訂閱cloudgcloud pubsub topics list-subscriptions myTopic 輸出應會如下：--- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/Test2--- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/Test1--- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/mySubscription 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 現在刪除 Test1 以及 Test2 訂閱，執行以下指令: cloudgcloud pubsub subscriptions delete Test1 cloudgcloud pubsub subscriptions delete Test2 確認 Test1 以及 Test2 以及被刪除了, 再次執行 list-subscriptionscloudgcloud pubsub topics list-subscriptions myTopic 輸出應會如下：--- projects/qwiklabs-gcp-3450558d2b043890/subscriptions/mySubscription Pub/Sub 發布以及提取單一訊息接下來, 你將會學習如何發布一個訊息到 Pub/Sub 主題 執行以下指令來發布訊息 &quot;hello&quot; 到你剛剛建立的主題 (myTopic): cloudgcloud pubsub topics publish myTopic --message &quot;Hello&quot; 再發布一些訊息到 myTopic。 執行以下指令 (將 &lt;YOUR NAME&gt; 替換成你的名字, 以及 &lt;FOOD&gt; 替換成一種你喜歡吃的食物): cloudgcloud pubsub topics publish myTopic --message &quot;Publisher&apos;s name is &lt;YOUR NAME&gt;&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher likes to eat &lt;FOOD&gt;&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher thinks Pub/Sub is awesome&quot; 接下來, 使用 pull 指令來從主題取得訊息。 pull 是基於訂閱的指令, 也就是說這應該會運作正常, 因為早些時候你已經設定好了對主題 myTopic 的訂閱 mySubscription 使用以下指令來提取你剛剛從 Pub/Sub 主題發布的訊息 cloudgcloud pubsub subscriptions pull mySubscription --auto-ack 輸出應會如下： 在最後一個章節, 你將會學習如何使用 flag 來從主題提取多個訊息 Pub/Sub 從訂閱提取所有訊息因為在上一個範例中, 你已經從你的主題提取了所有的訊息, 所以現在加載更多訊息到主題 myTopic 執行以下指令：cloudgcloud pubsub topics publish myTopic --message &quot;Publisher is starting to get the hang of Pub/Sub&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher wonders if all messages will be pulled&quot; cloudgcloud pubsub topics publish myTopic --message &quot;Publisher will have to test to find out&quot; 增加一個 flag 到你的指令, 所以你可以在一個請求中輸出所有三筆訊息。 你可能沒有注意到, 但事實上你一直都在使用 flag: pull 指令中的 --auto-ack 就是一個你剛剛才用過的可以將你的訊息格式化成整齊的視窗的一個指令 limit 是另外一個 flag, 可以設定提取訊息數量的最高限制 cloudgcloud pubsub subscriptions pull mySubscription --auto-ack --limit=3 輸出應會如下： 現在你已經知道如何加 flag 到 Pub/Sub 的指令上來輸出大量的訊息, 你已經走在成為 Pub/Sub 大師的路上。 恭喜在本教程中, 你學到了 Pub/Sub 主題, 訂閱, 以及提取指令和 flag 的指令","link":"/zh-tw/googleCloudPubSubQwikStartCommandLine/"},{"title":"如何在 AWS 上部署多個專案？","text":"建立一個AWS EC2 instance, 本文章使用的instance型號為 Amazon Linux 2 AMI (HVM), SSD Volume Type - ami-0d7ed3ddb85b521a6 連結到你的EC2 instance, 輸入：sudo vim /etc/httpd/conf.d/yourProjectName.conf 貼上下面的code &lt;VirtualHost *:443&gt; # port 443，給https用的 ServerName letussleep.space # 你的Domain名稱 DocumentRoot &quot;/var/www/html/yourLaravelProjectName/public&quot; # 你在EC2上的專案絕對路徑 SSLEngine on SSLCertificateFile /whateverLocationYouWant/certificate.crt SSLCertificateKeyFile /whateverLocationYouWant/private.key SSLCertificateChainFile /whateverLocationYouWant/ca_bundle.crt # 簽署SSL簽證，分別對應你從從簽證網站上面取得的簽證檔案&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; # port 80 給 http用的 ServerName letussleep.space DocumentRoot &quot;/var/www/html/yourLaravelProjectName/public&quot; redirect / Https://letussleep.space # 當使用者使用http連接，重新導向到https&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt;ServerName oldletussleep.space # 在同一個conf檔案裡頭，其實就可以部署不同的專案，只要把Domain name區分好DocumentRoot &quot;/var/www/html/yourProjectName/public&quot;&lt;/VirtualHost&gt; 雖然在同一個config檔案裡頭，只要設好domain name 以及不同的專案路徑就可以完成多專案部署，但是這樣難免混亂，所以個人偏好一個專案一個conf檔案。 所以只要重複上面的步驟，創一個新的config檔，並且輸入相對應的資訊，最後輸入sudo service httpd restart 連到你的Domain, 應該已經沒問題了！","link":"/zh-tw/howToDeployMultipleProjectOnAWS/"},{"title":"Google Cloud Pub/Sub 初探 - 控制面板","text":"概述Google Cloud Pub/Sub 是一個訊息服務，提供在不同的應用或服務之間，傳遞事件資料，資料的產生者發佈訊息到 Cloud Pub/Sub topic, 訂閱者可以經由訂閱拉回訊息，或是設定好，當某事件被觸發時，就觸發訂閱。 每個訂閱者必須在可設定的一段時間內確認收到訊息 你將會做什麼？ 設定一個 topic 來存放資料 訂閱一個 topic 來存取資料 發佈，然後經由訂閱者來消耗訊息 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 設定 Pub/Sub你可以使用 Google Cloud Shell 主控台來操作 Google Cloud Pub/Sub 要使用 Pub/Sub, 你建立一個 topic 來存放資料，以及一個訂閱來存取被發佈到 topic 的資料 點擊 Navigation menu &gt; Pub/Sub &gt; Topics 點擊Create a topic topic 必須是一個獨一無二的名字，在這個 lab 中，將你的 topic 取名為 MyTopic. 在 Create a topic 視窗中： 將你的 topic 取名為 MyTopic 將 Encryption 留為默認值 點擊 CREATE TOPIC 你已經建立了 topic 測試任務是否完成點擊Check my progress 來和對目前任務進度。如果你已經成功建立 Cloud Pub/Sub topic, 你會得到評價的分數 增加一個訂閱現在你將建立一個訂閱來存取 topic 在左邊的控制列點擊 Topics 回到 Topics 對話框, 在我們剛剛建立的 topic，在三個點的圖案處按一下，然後點擊 Create subscription 在 Add subscription to topic 對話框： 輸入 subscription 的名字，例如 MySub 將 Delivery type 設為 Pull 將其他選項都留為預設值 點擊 Create 你的訂閱被列在訂閱清單中 測試任務是否完成點擊Check my progress 來和對目前任務進度。如果你已經成功建立 Cloud Pub/Sub topic, 你會得到評價的分數 測試你的理解底下有一些問題用來鞏固你對這個 lab 概念的了解，盡你所能的去回答吧 一個發佈者的的應用，建立並且傳送訊息到 ___. 訂閱者的應用建立一個 ___ 到 topic 來取得訊息 topic, subscription topic, topic subscription, subscription subscription, topic Cloud Pub/Sub 是一個被設計為高度可靠以及可規模化的異步訊息服務 發佈訊息到 topic 在 Topics details 對話框的上方，點擊 PUBLISH MESSAGE。 你可能需要調寬瀏覽器的視窗來檢視 PUBLISH MESSAGE 選項 在 Message 欄位中輸入 Hello World, 然後點擊 Publish 檢視訊息要檢視訊息，你將需要使用 subscription (MySub) 來從 topic (MyTopic) 取得訊息 (Hello World) 在命令行輸入以下指令 gcloud pubsub subscriptions pull --auto-ack MySub 訊息將會出現在輸出的 DATA 欄位 你建立了 Pub/Sub topic，並且發佈到這個 topic, 建立了 subscription, 然後使用 subscription 來取得在 topic 的資料 恭喜完成本教程！","link":"/zh-tw/googleCloudPubSubQwikStartConsole/"},{"title":"如何經由 PHP 導入中文到 MySQL 而不會出現亂碼？","text":"如何正確的導入中文而不會出現亂碼？ 大家好, 我是 Ray!今天我想跟大家分享 CSV 檔案匯入 MySQL 的更多細節部分, 像是如何正確的導入中文字而不會出現亂碼。 首先, 先講 PHP 的部分： &lt;?phpmysqli_set_charset($dbc,&quot;utf8&quot;); 在連接資料庫之後, 請記得一定要加入上面的 code, 目的是明確來往資料庫的資料編碼格式。 檔案部分： 首先, 打開 Excel, 然後開啓新檔案 接下來, 點選 Data, 並且選取 From text 這邊請選擇使用分界符號 這裏選擇使用逗號來做分隔 最後選擇一般即可 接下來爲, 資料庫部分： 如果你是使用 Sequel Pro, 那請務必在創建表格時點選 UTF-8, 如下圖 如果你是使用終端機部分, 如下圖, 請記得要在創立表格的同時賦予 utf8 的編碼。 如果依然在匯入之後顯示亂碼, 請確認 column 的編碼是否爲 utf-8 基本上如果以上的細節都有注意到, 應該就可以順利的導入中文, 並且成功的在資料庫內顯示中文, 如下圖： 大家寫code愉快！","link":"/zh-tw/howToImportChineseIntoDatabaseWithoutGarble/"},{"title":"怎麼在 Laravel 中, 利用 AWS SES 發郵件?","text":"申請 AWS SES(simple Email Service) 服務 建立一個使用者, 並建立政策 (SES full access), 取得 Access key 跟 Secret key 到 AWS SES 主控台, 左方 Email Addresses, 然後進去點選 verify a new email address 進行驗證 Google AWS support center, 提交‘移出沙盒’申請, 約24小時內會解封。否則寄信數量跟頻率都會被很大程度上限制住, 且任何收件人都必須要經過AWS驗證。 開立一個 Laravel 專案 輸入 composer require guzzlehttp/guzzle, 安裝套件 安裝AWS SDK composer require aws/aws-sdk-php 到 config/mail.php 中, 將 driver 選項相對的 env 參數改成 ses 到 config/services.php 中, 進行以下配置 &apos;ses&apos; =&gt; [ &apos;key&apos; =&gt; &apos;your-ses-key&apos;, &apos;secret&apos; =&gt; &apos;your-ses-secret&apos;, &apos;region&apos; =&gt; &apos;ses-region&apos;, // e.g. us-east-1], 以上參數在 env 的配置, 大概如下： MAIL_DRIVER=sesMAIL_FROM_ADDRESS=your-mail-addressMAIL_FROM_NAME=BuyBuyGoSES_KEY=your-ses-keySES_SECRET=your-ses-secretSES_REGION=us-west-2 建立 Maiiables class, php artisan make:mail OrderCreated --markdown=emails.orders.created 到 OrderCreated 中, 建立 build 檔案, 大略如下: &lt;?phpnamespace App\\Mail;use Illuminate\\Bus\\Queueable;use Illuminate\\Mail\\Mailable;use Illuminate\\Queue\\SerializesModels;use Illuminate\\Contracts\\Queue\\ShouldQueue;class OrderShipped extends Mailable&#123; use Queueable, SerializesModels; protected $order; /** * Create a new message instance. * * @return void */ public function __construct($order) &#123; $this-&gt;order = $order; // &#125; /** * Build the message. * * @return $this */ public function build() &#123; return $this-&gt;markdown(&apos;emails.orders.created&apos;) -&gt;with([ &apos;buyer&apos; =&gt; $this-&gt;order-&gt;user-&gt;name, &apos;order&apos; =&gt; $this-&gt;order-&gt;name, &apos;item_name&apos; =&gt; $this-&gt;order-&gt;item_name, &apos;item_description&apos; =&gt; $this-&gt;order-&gt;item_description, &apos;quantity&apos; =&gt; $this-&gt;order-&gt;quantity, &apos;total_amount&apos; =&gt; $this-&gt;order-&gt;total_amount, &apos;unit_price&apos; =&gt; $this-&gt;order-&gt;unit_price, &apos;expiry_time&apos; =&gt; $this-&gt;order-&gt;expiry_time, ]); &#125;&#125; 到 created.blade 當中做版面客制, 大略如下： @component(&apos;mail::message&apos;)# Dear &#123;&#123; $buyer &#125;&#125;Thanks for your patronage!- Order: &#123;&#123;$order&#125;&#125;- Item: &#123;&#123;$item_name&#125;&#125;- Item description: &#123;&#123;$item_description&#125;&#125;- Quantity: &#123;&#123;$quantity&#125;&#125;- Unit price: &#123;&#123;$unit_price&#125;&#125;- Amount: &#123;&#123;$total_amount&#125;&#125;## Kindly make this payment before &lt;span style=&quot;color: red&quot;&gt;&#123;&#123;$expiry_time&#125;&#125;&lt;/span&gt;&lt;hr&gt;&lt;br&gt;## If you have any question, feel free to contact us@component(&apos;mail::button&apos;, [&apos;url&apos; =&gt; &apos;https://tn710617.github.io/&apos;])Contact Us@endcomponentThanks,&lt;br&gt;&#123;&#123; config(&apos;app.name&apos;) &#125;&#125;@endcomponent 在任何你想要發這封mail的地方, 使用 mail 來寄信, 大略如下： Mail::to($buyer-&gt;email)-&gt;send(new OrderCreated($order)); 至此, 應該可以成功寄信了！ 你以為結束了嗎？ 呵呵, 是快結束了啦！ 不過呢, 還有一件事情非常重要！上面的部分大概花了我一天, 然後我遇到一個未解的謎題, 又被搞了一天。身為一個 backend programmer, 如果遇到需要接金流的話, 我都是用 ngrok 來測試。這次遇到的問題很奇怪, 當我收到金流服務商的回饋時, 我必須要去做一些事, 自 controller 收到 request 之後所做的任何 function 都沒有問題, 資料庫的 CRUD 也都正常, 可偏偏只要執行到這一行寄 mail 的, 就給我報錯！！ 錯誤訊息如下： &quot;message&quot;: &quot;Expected response code 250 but got code \\&quot;530\\&quot;, with message \\&quot;530 5.7.1 Authentication required\\r\\n\\&quot;&quot;,&quot;exception&quot;: &quot;Swift_TransportException&quot;,&quot;file&quot;: &quot;/Users/ray/code/FacebookOptimizedSellingSystem/vendor/swiftmailer/swiftmailer/lib/classes/Swift/Transport/AbstractSmtpTransport.php&quot;,&quot;line&quot;: 457,&quot;trace&quot;: [ 以下省略一千行… 在經過超級無敵疲勞的 Debug 之後, 終於發現問題… 只要使用 valet share, 就不會有這個問題只要是用 php artisan serve --port=yourPort, 然後 ngrok http yourPort, 這樣就會遇到我說的這個問題。 雖然最後問題解決了, 但說實在的我還是不知道為什麼… 如果有大大知道這是什麼原因, 還請麻煩來信幫我解惑一下！感激不盡！","link":"/zh-tw/howToSendMailViaAWSSES/"},{"title":"如何設置Git的個人資訊？","text":"大家好，我是Ray! 今天要來跟大家分享，如何配置Git的基本資訊。 讓我們新增一行敘述在現有的example1.html 的檔案裡，如下： &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;p&gt;This is the example commit for git commit -am&lt;/p&gt;&lt;p&gt;This is the example1 for git configuration&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; Git commit -am “Before configuration” Git log 各位可以看一下上面我們我們剛剛所commit的Author 資料。 現在加入另一段敘述在example1.html檔案內，如下： &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;p&gt;This is the example commit for git commit -am&lt;/p&gt;&lt;p&gt;This is the example1 for git configuration&lt;/p&gt;&lt;p&gt;This is the example after git configuration&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 現在讓我們來定義git 配置的使用者資訊： 輸入 Git config --global user.name RayGit config --global user.email example@email.com 上面的Ray以及example@email欄位請填你們自己的！ 接下來輸入 Git commit -am “after configuration” Git log 由上面的截圖可以看到，我們已經成功的配置的使用者的名稱還有信箱改掉了！ 這邊補充說明，這裡使用–global進行配置，所以這裡的設定是全域通用的，簡單來說，你電腦內的所有資料夾都套用這個資料，之後有機會我們再介紹如何針對單一資料夾進行更改。 今天的分享就到這裡了，我們明天見！","link":"/zh-tw/howToConfigureGit/"},{"title":"利用 PayPal 付款標準版 (PayPal Payment Standard) 以及 PayPal 即時付款通知 (PayPal IPN) 方式結帳付款","text":"前言有嘗試串接過 PayPal 的人都知道， PayPal 提供了好幾種方式供使用者串接使用。本篇記錄了： 如何使用 PayPal 付款標準版 (PayPal Payment Standard) 來付款結帳。 如用使用 PayPal 即時付款通知 (PayPal IPN) 來驗證付款結果。 如何在 PayPal 付款標準版 (PayPal Payment Standard) 中，自定義多個商品以及每個商品的明細，包含名稱、單價、數量。 在本文章中，我使用的是PHP的框架，Laravel因為此篇文章主要紀錄我這個專案大概的一個流程，雖說主題是金流部分，但難免會記錄到一些跟金流無關的部分。可以直接從’建金流訂單’的部分開始看即可。 驗證此節是整個流程的一個程序，跟金流較無關係，可以跳過。$toBeValidatedCondition = [ 'order_id' =&gt; 'required|array',];$failMessage = Helpers::validation($toBeValidatedCondition, $request);if ($failMessage) return Helpers::result(false, $failMessage, 400);if (!Helpers::checkIfIDExists($request, new Order(), 'order_id')) return Helpers::result(false, 'The orders doesn\\'t exist', 400);if (!Helpers::checkIfBelongToTheUser($request, new Order(), 'order_id')) return Helpers::result(false, 'The order doesn\\'t belong to this user', 400);$orders = Order::whereIn('id', $request-&gt;order_id)-&gt;get();if (Order::checkIfOrderPaid($orders)) return Helpers::result(false, 'The order has already been paid', 400);if (Order::checkIfOrderExpired($orders)) return Helpers::result(false, 'The order has expired', 400);if ($recipient-&gt;user_id !== User::getUserID($request)) return Helpers::result(false, 'The recipient doesn\\'t belong to the user', 400); 收集必要資訊因為我在做這個專案時，前端的時間比較吃緊一點，所以後端這邊決定除必要資訊之外，後端這邊將所有資訊搞定，盡量讓前端帶最少的資料，做最多的事。$toBeSavedInfo = [ 'total_amount' =&gt; Order::getTotalAmountForPayments($orders), 'orders_name' =&gt; Order::getOrdersNameForPayments($orders), 'merchant_trade_no' =&gt; time() . Helpers::createAUniqueNumber(), 'merchant_trade_date' =&gt; date('Y/m/d H:i:s'), 'trade_desc' =&gt; 'BuyBuyGo', 'quantity' =&gt; 1, 'user_id' =&gt; User::getUserID($request), 'payment_service' =&gt; $thirdPartyPaymentService, 'expiry_time' =&gt; (new Carbon())-&gt;now()-&gt;addDay(1)-&gt;toDateTimeString(), 'orders' =&gt; $orders, 'mc_currency' =&gt; 'TWD', 'ClientBackURL' =&gt; $request-&gt;ClientBackURL]; 分流點因為這個專案接了兩家金流，所以會需要一個地方來判定金流服務商switch ($thirdPartyPaymentService-&gt;id)&#123; case 1: $error = (new AllPay)-&gt;make($toBeSavedInfo, $request, $recipient); if($error) return Helpers::result(false, $error,400); return (new AllPay())-&gt;send($toBeSavedInfo, $request); break; case 2: $error = (new PayPal)-&gt;make($toBeSavedInfo, $request, $recipient); if($error) return Helpers::result(false, $error, 400); $url = (new PayPal)-&gt;send($toBeSavedInfo, $request, $recipient); return Helpers::result(true, $url, 200); break;&#125; 建金流訂單在使用者按下付款之後，一張臨時的金流訂單會被建立。此訂單只介於你與你與 PayPal 之間，使用者不會接觸到這張訂單。因為會一次性的寫入兩張 table ，所以這邊會特別使用 Laravel 的 Transaction 來將資料處理，如果對 Laravel Transaction 有興趣的，可以參考我在另外一篇文章中，有一小段針對 Laravel Transaction 的解說public function make(Array $toBeSavedInfo, Request $request, Recipient $recipient)&#123; DB::beginTransaction(); try &#123; $PayPal = new self(); $PayPal-&gt;user_id = $toBeSavedInfo['user_id']; $PayPal-&gt;payment_service_id = $toBeSavedInfo['payment_service']-&gt;id; $PayPal-&gt;expiry_time = $toBeSavedInfo['expiry_time']; $PayPal-&gt;merchant_trade_no = $toBeSavedInfo['merchant_trade_no']; $PayPal-&gt;total_amount = $toBeSavedInfo['total_amount']; $PayPal-&gt;trade_desc = $toBeSavedInfo['trade_desc']; $PayPal-&gt;item_name = $toBeSavedInfo['orders_name']; $PayPal-&gt;mc_currency = $toBeSavedInfo['mc_currency']; $PayPal-&gt;recipient_id = $recipient-&gt;id; $PayPal-&gt;save(); foreach ($toBeSavedInfo['orders'] as $order) &#123; $order_relations = new OrderRelations(); $order_relations-&gt;payment_service_id = $toBeSavedInfo['payment_service']-&gt;id; $order_relations-&gt;payment_service_order_id = $PayPal-&gt;id; $order_relations-&gt;order_id = $order-&gt;id; $order_relations-&gt;save(); &#125; &#125; catch (Exception $e) &#123; DB::rollBack(); return 'something went wrong with DB'; &#125; DB::commit();&#125; 建立提交付款申請的 URL這邊會用到很多 PayPal 付款標準版 (PayPal Payment Standard) 的 變量 (variable)，各種變量的使用可以參考這篇文章另外，因為 Ray 在做這個案子時，前端的時間上比較吃緊，所以 Ray 將所以非必要的資料全部由後端這邊處理，前端只帶入先前已建立的使用者訂單，後端從資料庫內調出所有的資料並提供給 PayPal public function send(Array $toBeSavedInfo, Request $request, Recipient $recipient)&#123; // 如果你是使用測試環境的話，請選 true $enableSandbox = env('PAYPAL_SANDBOX_ENABLESANDBOX'); $paypalUrl = $enableSandbox ? 'https://www.sandbox.paypal.com/cgi-bin/webscr' : 'https://www.paypal.com/cgi-bin/webscr'; $data = []; // 設定PayPal 帳號, 請先到以下網址申請測試者帳號，商家跟一般用戶都要申請，這邊填入的是商家的帳號，所以買家付款後，金額會直接匯入這個帳號 // https://developer.paypal.com/developer/accounts/ // Set the PayPal account $data['business'] = env('PAYPAL_SANDBOX_MAIL'); // 此數值為前端帶入，使用者完成付款後，將可以經由此URL返回原本的服務中 // Set the PayPal return addresses, after the transaction is completed, the user could be back via this URL. $data['return'] = $toBeSavedInfo['ClientBackURL']; // 在付款過程中，使用者可以選擇取消，並且經由此URL回到我們的服務 // During the transaction process on PayPal's site, the user could cancel the transaction and go back via this URL. $data['cancel_return'] = env('PAYPAL_SANDBOX_CANCEL_URL'); // 在使用者完成交易之後， PayPal 會發一封 IPN 到我們在這邊指定的 listener ，然後我們可以依據此 IPN 來判定付款是否成功，然後做相對應的事 // After the transaction is completed, PayPal will send IPN message to this URL. $data['notify_url'] = env('PAYPAL_SANDBOX_NOFITY_URL'); // 這邊我們指定了每一樣商品的明細，包含單價，名稱，數量。 這邊要將這些明細顯示在 PayPal 的付款頁面上 // Set the details about the products being purchased, including the price for every individual // and currency so that these aren't overridden by the form data. $i = 1; foreach ($toBeSavedInfo['orders'] as $order) &#123; $data[\"item_name_$i\"] = $order-&gt;item_name; $data[\"item_number_$i\"] = $order-&gt;quantity; $data[\"amount_$i\"] = $order-&gt;total_amount; $i++; &#125; // 這邊指定了幣別，細節部分可以參考官網資料 // https://developer.paypal.com/docs/classic/api/currency_codes/ $data['currency_code'] = $toBeSavedInfo['mc_currency']; // 這邊我們可以帶一個任何我們想要的值過去給 PayPal ，然後 PayPal 會再回傳 IPN 時一併帶回來，以本篇例子，我帶入的是我金流訂單的編號 // Add any custom fields for the query string. $data['custom'] = $toBeSavedInfo['merchant_trade_no']; // 這邊我指定了收件人，否則 PayPal 會顯示測試帳號上的假的收件人資料。 在這邊設定後，我們可以在 PayPal 上顯示任何我們想要的收件人資料 // Add recipient's information $data['address_override'] = 1; $data['country'] = $recipient-&gt;country_code; $data['city'] = $recipient-&gt;city; $data['address1'] = $recipient-&gt;others; $data['zip'] = $recipient-&gt;postcode; $data['first_name'] = $recipient-&gt;name; // 這邊的設定允許了我們上傳多個商品到 PayPal 的購物車裡面，所以可以分成多個商品並且一次性結帳。 // This setting allow to add multiple items with IPN method $data['upload'] = '1'; $data['cmd'] = \"_cart\"; // Add charset $data['charset'] = 'utf-8'; // 產生 query string // Build the query string from the data. $queryString = http_build_query($data); // 產生最終的要在 PayPal 建立付款請求的 URL，我們只需要將此URL回傳給前端，前端就可以直接利用這個 URL 將使用者導向付款頁面 // Build the URL to PayPal $url = $paypalUrl . '?' . $queryString; return $url; &#125; 使用者付款 使用者經由我們上面產出的 URL 到達 PayPal 付款頁面，這邊請先去申請測試帳號 到達付款頁面 這邊可以看到我們指定的商品明細，以及金額，選擇繼續 這邊可以看到我們指定的住址 交易成功，這邊可以看到全部的細節 驗證付款狀態使用者完成付款程序後， PayPal 會發一封 IPN 給我們，有關於 IPN 的規格可以參考官方文件 首先，我們先安裝 PayPal 的 官方 IPN CODE SAMPLES git clone https://github.com/paypal/ipn-code-samples 進到 php 的資料夾內 cd ipn-code-samples/php 接下來，我們複製PaypalIPN.php到我們的專案內， Ray 是把它放到 App 底下。 接著，在把 ipn-code-samples 裡頭的 cert 整個資料夾也放到 App 底下，大概如下圖 再來，我們到composer.json檔案中，在autoload-dev底下的files加入PaypalIPN.php這個檔案，如果沒有files的可能要自己建一個 \"autoload-dev\": &#123; \"psr-4\": &#123; \"Tests\\\\\": \"tests/\" &#125;, \"files\": [ \"app/Helpers.php\", \"app/AllPay.Payment.Integration.php\", \"app/PaypalIPN.php\" ]&#125;, 重新執行composer，在terminal的專案資料夾底下，執行 composer install 萬事俱備，只欠東風！ 接下來讓我們將example_usage_advanced.php的檔案裡頭的內容複製到你想要的地方，可以是你的Controller，也可以是你的某個class下面的一個function，如下：下面的 code 有點長，可以不必全看，除了我中文有特別解釋的地方之外，大概跟原本的sample一樣。 public function listen(Request $request) &#123; // 因為官方sample是去接 $_POST，所以這邊直接將Laravel的輸入轉成 POST ，想要自己改的人也可以哦 $_POST = $request-&gt;post(); // 這個資訊代表是否該交易已付款 $payment_status = $_POST['payment_status']; // 還記得我們之前帶過去的金流訂單號碼嗎？ $merchant_trade_no = $_POST['custom']; // 很重要，等等會用到 $txn_id = $_POST['txn_id']; $txn_type = $_POST['txn_type']; // 付款時間 $payment_date = Carbon::parse($_POST['payment_date'])-&gt;setTimezone('UTC'); // 總付款金額 $mc_gross = $_POST['mc_gross']; // 幣別 $mc_currency = $_POST['mc_currency']; $enable_sandbox = env('PAYPAL_SANDBOX_ENABLESANDBOX');// 這邊表示收款人的email，如果IPN裡頭的收款人不在這個清單裡面的話，驗證將會失敗// Use this to specify all of the email addresses that you have attached to paypal: $my_email_addresses = array(env('PAYPAL_SANDBOX_MAIL'));// Set this to true to send a confirmation email: $send_confirmation_email = env('PAYPAL_SANDBOX_SEND_CONFIRMATION_EMAIL'); $confirmation_email_address = \"buybuybuygogo@gmail.com\"; $from_email_address = \"test@gmail.com\";// 選true的話，會自動記log// Set this to true to save a log file: $save_log_file = env('PAYPAL_SANDBOX_SAVE_LOG_FILE'); $log_file_dir = storage_path() . \"/app/payment_logs\";// Here is some information on how to configure sendmail:// http://php.net/manual/en/function.mail.php#118210// 這邊就是主要驗證的function $ipn = new PaypalIPN(); if ($enable_sandbox) &#123; $ipn-&gt;useSandbox(); &#125; $verified = $ipn-&gt;verifyIPN(); $data_text = \"\"; foreach ($_POST as $key =&gt; $value) &#123; $data_text .= $key . \" = \" . $value . \"\\r\\n\"; &#125; $test_text = \"\"; if ($_POST[\"test_ipn\"] == 1) &#123; $test_text = \"Test \"; &#125;// 上面提到的mail，就在這邊確認// Check the receiver email to see if it matches your list of paypal email addresses $receiver_email_found = false; foreach ($my_email_addresses as $a) &#123; if (strtolower($_POST[\"receiver_email\"]) == strtolower($a)) &#123; $receiver_email_found = true; break; &#125; &#125; date_default_timezone_set(\"America/Los_Angeles\"); list($year, $month, $day, $hour, $minute, $second, $timezone) = explode(\":\", date(\"Y:m:d:H:i:s:T\")); $date = $year . \"-\" . $month . \"-\" . $day; $timestamp = $date . \" \" . $hour . \":\" . $minute . \":\" . $second . \" \" . $timezone; $dated_log_file_dir = $log_file_dir . \"/\" . $year . \"/\" . $month; $paypal_ipn_status = \"VERIFICATION FAILED\"; if ($verified) &#123; // 進到下面的if之後，表示已經驗證成功了，我們可以在驗證成功之後做一些該做的事 $paypal_ipn_status = \"RECEIVER EMAIL MISMATCH\"; if ($receiver_email_found) &#123; $paypal_ipn_status = \"Completed Successfully\"; $PayPal = (new PayPal())-&gt;where('merchant_trade_no', $merchant_trade_no)-&gt;first(); // 這邊檢查了幾項，大概如下： // 1. 檢查txn_id，為了避免這筆交易之前就已經有處理過。所以資料庫裡面如果已經有這個txn_id，將不予理會 // 2. 檢查mc_gross，總金額必須與我們金流訂單裡頭的金額相等 // 3. 檢查幣別，幣別必須與我們金流訂單裡頭的幣別相同 // 4. 檢查payment_status，該交易必需已經付款完成 if ((!PayPal::checkIfTxnIdExists($txn_id)) &amp;&amp; ($mc_gross == $PayPal-&gt;total_amount) &amp;&amp; ($mc_currency == $PayPal-&gt;mc_currency) &amp;&amp; ($payment_status == 'Completed')) &#123; // 將該txd_id新增到該金流訂單內，並更新該訂單數據，主要可被識別為已結單。 $PayPal-&gt;update(['txn_id' =&gt; $txn_id, 'txn_type' =&gt; $txn_type, 'payment_date' =&gt; $payment_date, 'status' =&gt; 1, 'expiry_time' =&gt; null]); $recipient = $PayPal-&gt;recipient; $orderRelations = $PayPal-&gt;orderRelations-&gt;where('payment_service_id', 2); // 更新完金流訂單後，根據該金流訂單取得相對應的使用者訂單，並更新使用者訂單狀態。 Order::updateStatus($orderRelations, $recipient); // 付款完成，寄mail通知使用者 Helpers::mailWhenPaid($PayPal, $orderRelations); &#125; &#125; &#125; elseif ($enable_sandbox) &#123; if ($_POST[\"test_ipn\"] != 1) &#123; $paypal_ipn_status = \"RECEIVED FROM LIVE WHILE SANDBOXED\"; &#125; &#125; elseif ($_POST[\"test_ipn\"] == 1) &#123; $paypal_ipn_status = \"RECEIVED FROM SANDBOX WHILE LIVE\"; &#125; if ($save_log_file) &#123; // Create log file directory if (!is_dir($dated_log_file_dir)) &#123; if (!file_exists($dated_log_file_dir)) &#123; mkdir($dated_log_file_dir, 0777, true); if (!is_dir($dated_log_file_dir)) &#123; $save_log_file = false; &#125; &#125; else &#123; $save_log_file = false; &#125; &#125; // Restrict web access to files in the log file directory $htaccess_body = \"RewriteEngine On\" . \"\\r\\n\" . \"RewriteRule .* - [L,R=404]\"; if ($save_log_file &amp;&amp; (!is_file($log_file_dir . \"/.htaccess\") || file_get_contents($log_file_dir . \"/.htaccess\") !== $htaccess_body)) &#123; if (!is_dir($log_file_dir . \"/.htaccess\")) &#123; file_put_contents($log_file_dir . \"/.htaccess\", $htaccess_body); if (!is_file($log_file_dir . \"/.htaccess\") || file_get_contents($log_file_dir . \"/.htaccess\") !== $htaccess_body) &#123; $save_log_file = false; &#125; &#125; else &#123; $save_log_file = false; &#125; &#125; if ($save_log_file) &#123; // Save data to text file file_put_contents($dated_log_file_dir . \"/\" . $test_text . \"paypal_ipn_\" . $date . \".txt\", \"paypal_ipn_status = \" . $paypal_ipn_status . \"\\r\\n\" . \"paypal_ipn_date = \" . $timestamp . \"\\r\\n\" . $data_text . \"\\r\\n\", FILE_APPEND); &#125; &#125; if ($send_confirmation_email) &#123; // Send confirmation email mail($confirmation_email_address, $test_text . \"PayPal IPN : \" . $paypal_ipn_status, \"paypal_ipn_status = \" . $paypal_ipn_status . \"\\r\\n\" . \"paypal_ipn_date = \" . $timestamp . \"\\r\\n\" . $data_text, \"From: \" . $from_email_address); &#125;// Reply with an empty 200 response to indicate to paypal the IPN was received correctly header(\"HTTP/1.1 200 OK\"); &#125; 結語以上大概就是整個利用 PayPal 付款標準版 (Payment Standard) 來付款 ，然後經由 IPN 驗證的流程，流程大概如下： 買家完成付款 PayPal 發送 IPN Message 到 Listener Listener 回饋 HTTP 200 Response 到 PayPal Listener 將剛剛收到的 IPN Message 原封不動的回傳到 PayPal PayPal 驗證無誤後，回傳 Verified ，若驗證失敗，回傳 Invalid","link":"/zh-tw/implementATransactionViaPayPalIPN/"},{"title":"如何將 CSV 檔, 經由 PHP 導入 MYSQL？","text":"大家好, 我是 Ray！我將跟大家分享如何使用 PHP 來將 CSV 檔案的內容導入 MySQL 資料庫。首先, 一個 CSV 檔如下： 以下爲 PHP 腳本, 請將 csv 的檔案跟腳本放在同一個資料夾內 &lt;?php// 連接資料庫$dbc = mysqli_connect('Your location', 'Your MySQL user_name', 'Your MySQL password', 'Your Database Name');// 設定編碼爲 utf8mysqli_set_charset($dbc,\"utf8\");// 利用 fopen 功能讀取檔案$handle = fopen(\"The file name.csv\", \"r\");// 設定變數 i, 之後會用到$i=0;// 使用 fgetcsv 功能, 配合 while 迴圈, 可以拿到檔案內的每一行資料while (($data = fgetcsv($handle, 1000, ',')))&#123; //如圖片所示, 第一行是行的名稱, 我們不想要將這行導入資料庫, 所以我們設定條件句, //當變數 i 爲 0 正是跑到第一行, 進入條件句內, 變數 i 變爲 1, 並且 continue 使迴圈將之後的 code 都跳掉, //直接回到迴圈的最上面在開始跑, 此時變數i已經是1, 所以將不會在進到條件句中。如此一來我們就完成我們的目標, //只跳掉第一行。 if($i == 0) &#123; $i++; continue; &#125; // 如 csv 的圖片所示, 降雨量那一行中有出現非數字的 NaN 字串, // 但我們又想要將這一行的屬性設爲 float 或 decimal 方便之後若有需要用到計算。 // 要避免資料匯入出錯, 我們必須將非數字的字串轉換爲數字, // 因此利用條件句, 當 $data array 裏面的當三項爲 NaN 時, 替換爲0 if($data[2] == 'NaN') &#123; $data[2] = 0; &#125; // 最後, 將資料導入資料庫 $query = 'INSERT INTO rainfall (district, date, rainfall)VALUES (\"'.$data[0] . '\", \"' . $data[1] . '\", \"' . $data[2].'\")'; echo $query; $result = mysqli_query($dbc, $query); if ($result == false) &#123; echo 'Error description &lt;br/&gt;' . mysqli_error($dbc); &#125;&#125;?&gt; 最後, 在終端機中執行該腳本, php -f 腳本名稱, 完成！","link":"/zh-tw/importDataFromCSVIntoMySQLDatabaseViaPHP/"},{"title":"利用 Jenkins 在 AWS 上達到 CI","text":"前言以下為本篇記錄重點： 部署 jenkins 到 AWS EC2 的 Amazon Linux 2 AMI (HVM) 部署 jenkins 到 AWS EC2 的 Amazon Linux AMI 2018.03.0 (HVM) 當GitHub 上的進度有更新時，自動在 AWS EC2 執行 git pull 並與 GitHub 上的進度同步， 建立 EC2 instance 利用 SSH 連結到 AWS EC2 點擊 Connect ，並遵照指示操作 Amazon Linux 2 AMI (HVM)安裝sudo yum install java-1.8.0 sudo yum update -y sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key sudo yum install jenkins -y 設定sudo vim /etc/sysconfig/jenkins 並更改如右邊的參數 JENKINS_USER=&quot;root&quot; sudo service jenkins start sudo systemctl enable jenkins.service sudo vim /etc/sysconfig/jenkins 在瀏覽器設定 Jenkins 於瀏覽器輸入 http://yourPublicDNS:8080 於終端機輸入 sudo cat /var/lib/jenkins/secrets/initialAdminPassword 複製密碼以登入 安裝建議的插件 創立帳號 存檔並登入 到Jenkins管理頁面 安裝GitHub插件 開始一個自由專案 到設定的地方 輸入專案 url 選取 git , 並填入 git 資料夾的 url 勾選 GitHub hook trigger for GITScm polling 輸入客製化的shell script如果你的 jenkins 跟你的專案在同一台電腦的話 ssh -i /root/.ssh/yourKey.pem ec2-user@127.0.0.1 \"cd /var/www/html/yourProjectName;git reset @^ --hard;git pull;/usr/local/bin/composer install;php artisan migrate --force;\" 設定 GitHub 到 GitHub 的設定頁面 建立一個 webhook ，如下: Amazon Linux AMI 2018.03.0 (HVM)安裝sudo yum update -y sudo yum remove java-1.7.0-openjdk sudo yum install java-1.8.0 sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins.io/redhat/jenkins.repo sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key sudo yum install jenkins -y 設定sudo vim /etc/sysconfig/jenkins 修改為 JENKINS_USER=&quot;root&quot; sudo service jenkins start 當 Server 重啟時，自動啟動 jenkinssudo chkconfig jenkins on 在瀏覽器設定 Jenkins 於瀏覽器輸入 http://yourPublicDNS:8080 於終端機輸入 sudo cat /var/lib/jenkins/secrets/initialAdminPassword 複製密碼以登入 安裝建議的插件 創立帳號 存檔並登入 到 Jenkins 管理頁面 安裝 GitHub 插件 開始一個自由專案 到設定的地方 輸入專案url 選取 git , 並填入 git 資料夾的 url 勾選 GitHub hook trigger for GITScm polling 輸入客製化的 shell script如果你的 jenkins 跟你的專案在同一台電腦的話 ssh -i /root/.ssh/yourKey.pem ec2-user@127.0.0.1 \"cd /var/www/html/yourProjectName;git reset @^ --hard;git pull;/usr/local/bin/composer install;php artisan migrate --force;\" 設定 GitHub 到 GitHub 的設定頁面 建立一個 webhook ，如下:","link":"/zh-tw/implementCIWithJenkinsOnAWS/"},{"title":"InfluxDB 學習筆記","text":"前言InfluxDB 學習筆記，內容未整理，學到什麼記什麼 CLICLI 中使用 where clausemeasurement 的 double quotes &quot; 是必要的，但需要 escapeinflux -execute \"select * from \\\"netdata.ipv4.packets.delivered\\\" WHERE host = 'netdata' AND time &gt; now() - 1m\" -database 'opentsdb' 定時清理資料庫可將以下的 command 寫成 shell script, 用 crontab 執行influx -execute \"delete WHERE time &lt; now() - 1h\" -database 'opentsdb' 串接 Node.js安裝npm install --save influx 串接檔範例module.exports = (() =&gt; &#123; const Influx = require('influx/lib/src/index'); const Netdata = new Influx.InfluxDB(&#123; database: 'opentsdb', username: '', password: '', // 預設 port 號會自動設定為 8086 hosts: [&#123; host: 'IP' &#125;], &#125;); // 在設定檔中新增 method Netdata.getData = async (measurement, host, time = '1m') =&gt; &#123; let toBeReturnedObject = []; let result = await Netdata.query( `select * from \"$&#123;measurement&#125;\" WHERE host = '$&#123;host&#125;' AND time &gt; now() - $&#123;time&#125;` ); result.map(dot =&gt; &#123; let object = &#123; host: dot.host, value: dot.value, time: Number(dot.time.getNanoTime()) &#125;; toBeReturnedObject.push(object); &#125;); return toBeReturnedObject; &#125;; return Netdata;&#125;); require 串接檔 後面需加上 ();const Netdata = require('../models/netdatadb')(); SHOWSHOW TAG VALUESSHOW TAG VALUES FROM &quot;measurement&quot; WITH KEY = &quot;host&quot; SHOW TAG KEYSSHOW TAG KEYS on DBName from &quot;measurement&quot; SHOW FIELD KEYSSHOW FIELD KEYS ON &quot;database&quot; FROM &quot;measurement&quot; Downsampling and data retention定義 Continuous query (QC): 自動且規律性的執行, 可以用來降低採樣率。 文件 Retention policies (RP): InfluxDB 資料結構的一部分, 決定 InfluxDB 要保留資料多長的時間 文件 建立 retention policies 語法範例 CREATE RETENTION POLICY &quot;two_hours&quot; ON &quot;food_data&quot; DURATION 2h REPLICATION 1 DEFAULT 在資料庫 food_data 中, 建立一個 RETENTION POLICY two_hours, 並設定他的 DURATION 為 2h, REPLICATION 1 為保留一台 node 的資料, DEFAULT 為此資料庫的預設 RP 當我們建立一個新的資料庫時, InfluxDB 會自動地產生一個 RP 叫做 autogen。 當我們建立另外一個 RP 並且設為 default 之後, autogen 將會被取代掉 建立 continuous query 語法範例 CREATE CONTINUOUS QUERY &quot;cq_30m&quot; ON &quot;food_data&quot; BEGIN SELECT mean(&quot;website&quot;) AS &quot;mean_website&quot;,mean(&quot;phone&quot;) AS &quot;mean_phone&quot; INTO &quot;a_year&quot;.&quot;downsampled_orders&quot; FROM &quot;orders&quot; GROUP BY time(30m)END 在資料庫 food_data 中建立一個 QC 名為 cq_30m 將 website 以及 phone 欄位的資料從 measurement orders 將上一行的資料匯入 retention policy a_year 中的 measurement downsampled_orders 計算區隔為每 30 分鐘 Retention PolicyDuration 單位 解釋 ns nanoseconds (1 billionth of a second) u or µ microseconds (1 millionth of a second) ms milliseconds (1 thousandth of a second) s second m minute h hour d day w week 開啟身份驗證 開啟身份驗證之前, 請先建立至少一個 admin user 如果開啟了身份驗證, 但是沒有任何 admin user 的話, InfluxDB 將不會強制執行身份驗證, 並只會接受建立新的 admin user的 query 打開設定檔 vim /etc/influxdb/influxdb.conf 將 [http] 中的 auth-enabled 更改為 true [http] enabled = true bind-address = &quot;:8086&quot; auth-enabled = true # ✨ log-enabled = true write-tracing = false pprof-enabled = false https-enabled = true https-certificate = &quot;/etc/ssl/influxdb.pem&quot; 重新啟動 InfluxDB systemctl restart influxdb 使用者權限管理建立 admin 使用者語法CREATE USER &lt;username&gt; WITH PASSWORD &apos;&lt;password&gt;&apos; WITH ALL PRIVILEGES 範例CREATE USER paul WITH PASSWORD &apos;timeseries4days&apos; WITH ALL PRIVILEGES 給予現存使用者 admin 權限語法GRANT ALL PRIVILEGES TO &lt;username&gt; 範例GRANT ALL PRIVILEGES TO &quot;todd&quot; 顯示目前所有使用者是否為 adminSHOW USERS 建立一般使用者語法CREATE USER &lt;username&gt; WITH PASSWORD &apos;&lt;password&gt;&apos; 範例CREATE USER todd WITH PASSWORD &apos;influxdb41yf3&apos; 給予一般使用者非 admin 權限語法GRANT [READ,WRITE,ALL] ON &lt;database_name&gt; TO &lt;username&gt; 範例GRANT READ ON &quot;NOAA_water_database&quot; TO &quot;todd&quot; 廢除一般使用者非 admin 權限語法REVOKE [READ,WRITE,ALL] ON &lt;database_name&gt; FROM &lt;username&gt; 範例REVOKE ALL ON &quot;NOAA_water_database&quot; FROM &quot;todd&quot; 列出使用者權限語法SHOW GRANTS FOR &lt;user_name&gt; 範例SHOW GRANTS FOR &quot;todd&quot; 重新設定使用者密碼語法SET PASSWORD FOR &lt;username&gt; = &apos;&lt;password&gt;&apos; 範例SET PASSWORD FOR &lt;username&gt; = &apos;&lt;password&gt;&apos; 刪除使用者語法DROP USER &lt;username&gt; 範例DROP USER &quot;todd&quot;","link":"/zh-tw/influxdb/"},{"title":"如何省略 git add?","text":"大家好，我是Ray! 今天要跟大家分享，git commit -am 如之前的文章跟大家分享的，每次在commit 之前，我們需要使用git add來明確要commit 的進度，然後commit的同時我們需要留下屬於該commit的訊息。 有些人覺得這樣的設計很好，然而有些則不然，他們覺得這樣有點麻煩。 不管您是屬於哪一派，今天我要跟大家分享，如何將這兩個步驟化為一個動作。 首先，讓我們新增一行code在我們現有的檔案example1.html，如下：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;p&gt;This is the example commit for git commit -am&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 現在輸入 git status 如下圖，example1.html已經被修改了，必且如果要commit，我們需要先git add來明確要commit的進度。 依照之前的文章分享，我們需要先git add，然後git commit，並留下屬於此次commit的訊息來完成這次的commit。 現在讓我們來試試看比較簡單一點的方法吧！ 輸入git commit -am &quot;example for git commit -am&quot; 輸入git status 確認狀況 輸入Git log 如下圖，我們已經成功的commit了！ 這邊要跟大家更進一步解釋一下git add的功能。 當我們今天新增一個新的檔案時，我們需要將該檔案加入“追蹤”的檔案清單中，我們使用git add 來達到這個功能。 當“已經入追蹤”的檔案有更改，且我們要做commit時，我們需要更新該檔案將被commit記錄下來的進度！簡單來說，就是訂出將被commit的資料範圍，而這時我們也是使用git add來更新這個進度。 所以說啦，如果今天我們新增一個檔案，且該檔案從未被加入“追蹤”清單中，那這個時候git commit -am 是不會對這個檔案起作用的！ 有一點請大家注意，-a 在這裡代表automatic，它會自動的更新”所有已經加入追蹤清單且有更改”的檔案！ 看完今天的分享，大家是不是對git有更進一步地瞭解了呢？ 我們明天見！","link":"/zh-tw/howToSkipGitAdd/"},{"title":"kubernetes - Storage Classes","text":"概述StorageClass 提供給管理者一個方法, 一個管理者可用來描述儲存空間的 classes","link":"/zh-tw/kubernetes-concepts-storage-storage-classes/"},{"title":"如何使用 git checkout","text":"大家好，我是Ray! 還記得我們上次到了哪裡了嗎？看完上面的圖片有沒有讓你回想些什麼呢？ 沒錯，上次的git介紹我們從初始化開始，並且建立一個名為example1.html的檔案，然後完成了我們第一個存擋！ 如同之前提到的，我說git讓我們再存擋後，如果我們有需要的話，我們可以隨時地回到任何一個我們用git做的存擋點，今天我將跟大家分享如何回到存擋點，並且在存擋點之間自由的切換。 現在，讓我們在檔案內加入下面highlight的一段 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;First example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;This is the first example&lt;/p&gt;&lt;p&gt;We add a new paragraph on the first example&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 然後我們到command line，輸入git status 你應該會看到如下圖，如下圖所示，git 顯示example1.html已經被修改過了。 如上一篇提到的，再做存擋之前，我們必須要先使用git add 來指定我們想要存擋的進度，所以 輸入git add example1.html 輸入git status 如上圖，我們已經指定了要存擋的進度 現在輸入git commit 並記錄訊息”New paragraph added in example1.html file” 完成後輸入git status確認一下狀態 然後git log 現在我們可以看到我們的第二個commit如下圖： 好啦，接下來我們來切換回第一個記錄點 git log 的功能是顯示我們所有記錄點的歷史，我們可以經由log裡面提供的資料自由的切換於不同的紀錄點。 輸入 git checkout b45934852da471efbbbc52b5a119e8723fb01866 這是我的版本，你們的版本會是一串不同的數字 如下圖所示，我們現在已經在一個第一個記錄點。 現在可以打開我editor查看，我們新增加的We add a new paragraph on the first example 已經不見了，此時版本恢復到我們第一個記錄點的狀態，不管我們是否有另外在editor做任何的紀錄。 那要如何回到我們的最新的紀錄點呢？ 輸入git checkout master 如上圖，我們現在已經回復到我們最新的紀錄點啦！ 現在打開我們的editor做確認，登登！ 原本消失的new paragraph 又出現啦！ 是不是很神奇呢？ 以上是今天的分享，希望可以讓大家對Git有更深的了解，我們明天見！","link":"/zh-tw/howToUseCheckout/"},{"title":"Kubernetes Engine - 入門","text":"概述Google Kubernetes Engine (GKE) 提供了一個 Google 管理的環境，這個環境可使用 Google 的基礎設施來部署，管理容器化應用，以及調整容器化應用的規模大小。 Kubernetes Engine 環境包含了多台的機器(這邊專指為 Google Compute Engine 的實例)，形成一個容器的叢集。在這個課程中，你將可以實際操作練習如何建立一個容器，以及在 GKE 上部署你的應用。 前言本篇為 GCP Kubernetes Engine 的學習筆記 Kubernetes Engine 的叢集管理Kunernetes Engine 叢集器由 Kunernetes 開源叢集管理系統所提供。Kubernetes 提供與你的容器叢集互動的機制。使用Kebernetes的指令以及資源來部署、管理你的應用，執行管理任務、制訂政策，以及監控部屬工作量的健康度。 Kubernetes 使用了與目前運行在 Google 熱門服務相同的設計原則，並提供相同的優勢:自動管理, 應用容器的監控以及健康檢查, 自動擴展, 滾動升級, 以及更多…當你在一個容器叢集中運行你的應用, 相當於你使用了 Google 這10幾年正式在容器內上線的經驗來運行你的應用。 Kubernetes on Google Cloud Platform當你使用Kubernetes Engine 叢集，你同時也得到了 Google Cloud Platform 提供的優勢以及進階的叢集管理功能, 如下： Compute Engine 實例的平衡負載 節點池：在叢集內分配子集節點以提升靈活度 叢集節點實例數量的自動擴展 叢集節點軟體的自動升級 節點自動修復:保持節點的健康度以及可用性 使用 Stackdriver 來紀錄與監控，讓您可以掌握叢集的狀態 現在你已經對 Kubernetes 有基本的認識，你將在30分鐘內，學習如何使用 Kubernetes Engine 來部署你的容器化應用。繼續往下看並遵照每一個步驟來設定你的Lab環境。 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 設定一個預設的 compute zone你的 [compute zone] 是一個你的叢集以及其資源大概所在的一個位置。 例如說， us-central1-a 是一個位於 us-central1 region 的 zone 在 Cloud Shell 開始一個新的區塊，並且依照下面的指令來將你的預設 compute zone 設定為 us-central1-a gcloud config set compute/zone us-central1-a 你將會收到以下的輸出Updated property [compute/zone]. 建立一個 Kubernetes Engine 叢集一個叢集包含至少一個叢集主要機器，以及多台工作機器，稱為 nodes (節點)。 Nodes 是 Compute Engine 虛擬機器實例，運行著 Kubernetes 的必要程序，使他們成為叢集的一部分。 執行以下的 command 來建立一個叢集。以你喜歡的叢集名稱(例如： my-cluster )來取代 command 中的 CLUSTER-NAME 。叢集的名稱必須由一個字母開始，並且需同時包含字母以及數字，且長度不可超過40個字。gcloud container clusters create [CLUSTER-NAME] 你可以無視輸出裡的任何警告。建立叢集會需要一些時間，很快的你將會收到類似下面的輸出：NAME LOCATION ... NODE_VERSION NUM_NODES STATUSmy-cluster us-central1-a ... 1.10.9-gke.5 3 RUNNING 點擊 Check my progress 來確認目前的進度。 取得叢集的授權證明在建立叢集之後，你需要取得授權證明來進行對叢集的進一步操作執行下面的 command 來授權叢集，並用你自己的叢集名稱取代 command 裡面的 CLUSTER-NAMEgcloud container clusters get-credentials [CLUSTER-NAME] 你將會收到類似下面的輸出：Fetching cluster endpoint and auth data.kubeconfig entry generated for my-cluster. 部署應用到叢集上現在你已經建立了一個叢集，你可以部署一個容器化的應用到這上面。在這個 Lab ，你將會部署 hello-app 到你的叢集上 Kubernetes Engine 使用 Kubernetes 物件來建立以及管理你的叢集資源。 Kubernetes 提供 部署 物件來部署無狀態的應用，像是 web server。服務物件定義了從網路上存取你應用的規則，以及負載平衡。 在 Cloud Shell 執行下面的 [kubectl run] 指令，從 hello-app 容器鏡像建立一個新的部署 hello-serverkubectl run hello-server --image=gcr.io/google-samples/hello-app:1.0 --port 8080 你應該會收到以下的輸出:deployment.apps \"hello-server\" created 這一個 Kubernetes 的指令，建立了一個代表 hello-app 的部署物件，在此指令中： --image 指定了一個容器鏡像來部署，在此範例中，這個指令從Google Container Registry儲存區裡，拉下一個範例鏡像。gcr.io/google-samples/hello-app:1.0 表示一個特定的鏡像。如果版本沒有明確標示，最新的版本將會被使用。 --port 指定容器暴露的 port 號 執行以下的 kubectl 暴露指令，建立一個 Kubernetes 的服務，一個 Kubernetes 的資源，讓你暴露你的應用到外部。 kubectl expose deployment hello-server --type=\"LoadBalancer\" 你應該會收到以下的輸出：service \"hello-server\" exposed 點擊 Check my progress 來確認目前的進度。 帶入參數 type=&quot;LoadBalancer&quot; ，在容器中建立一個 Compute Engine 平衡負載 執行 kubectl get 來檢查 hello-server 服務kubectl get service hello-server 你應該會收到類似以下的輸出： NAME TYPE ... EXTERNAL-IP PORT(S) AGEhello-server LoadBalancer ... 35.184.112.169 8080:30840/TCP 2m 備註：外部IP位址的產生，可能需要1分鐘。如果外部IP一直在沒有產生，你可以在執行一次上面的指令 從這個指令的輸出，從 `EXTERNAL-IP 欄位，複製服務的外部 IP 位址。 從瀏覽器，經由外部 IP 還有對應的 port 號來拜訪我們的應用 http://[EXTERNAL-IP]:8080 你的頁面應該看起來如下： 點擊 Check my progress 來確認目前的進度。 清除執行下面的指令來清除叢集gcloud container clusters delete [CLUSTER-NAME] 當選項跳出，輸入 Y 確認。清除叢集將會花費一些時間。你可以參閱 文件 來獲得更多刪除 Google Kubernetes Engine 叢集 的資訊 點擊 Check my progress 來確認目前的進度。 恭喜你已經完成本教程","link":"/zh-tw/kubernetesEngineQwikStart/"},{"title":"Kubernetes - Container Lifecycle Hooks","text":"概述如許多的程式語言框架, 如 Angular, 有著元件生命週期 hooks, Kubernetes 也為容器提供了生命週期 hooks。 Hooks 使容器在管理的生命週期間可以意識到事件的發生, 並且當對應的生命週期 hook 被觸發時, 執行在 handler 中實作的程式碼。 簡單來說呢, 就是 Kubernetes 內建兩種 hook, 在兩個特殊的時機點會被觸發, 而我們可以針對這兩點 hook, 也就是這兩個時機點去設定 handler, 當這個時機點到了, 你希望執行什麼程式碼, 做些什麼事, 等等…比如說, 你可以在 Nginx 容器退出時, 在其 PreStop hook handler 加上一段 nginx -s quit 來優雅退出 此處 hooks 中文翻譯為鉤子, 但是 Ray 個人覺得有點彆扭, 可能是 Ray 已經習慣原文 hook, 所以在本篇中不會特別翻譯 前言Kubernetes 的學習筆記, 內文可能會有大量的 Q&amp;A, 因為這是 Ray 的獨特學習方式！ 就像是獨孤求敗之於獨孤九劍一樣～ 容器 hooks共有兩種 hooks, PostStart 以及 PreStop PostStart 在容器啟動之後, 會立即的觸發 PostStart hook, 但是無法保證 PostStart 會先被觸發, 或者是容器的 ENTRYPOINT 會先被觸發, 因為這個動作是非同步的 PreStop 在容器被結束之前, 會觸發 PreStop, 這個動作是同步的, 所以 PreStop 必須在刪除容器的請求送出之前先完成 Hook handler 實作容器可以存取一個 hook, 藉由實作以及註冊一個 handler 給這個 hook。 可以在容器中被實作的 hook handler 有兩種： Exec - 在 cgroups 以及命名空間中, 執行一個特定的指令, 像是 pre-stop.sh。 這個指令消耗的資源會被算在這個容器上 HTTP - 在容器的一個特定端點執行一個 HTTP 請求 執行 hook handler當 hook 被觸發, Kubernetes 管理系統會執行註冊給該 hook 的 handlerHook handler 的呼叫在裝有這個容器的 Pod 當中是同步的, 這表示說, PostStart hook 的觸發, 以及該容器的 ENTRYPOINT 是非同步的。然而, 如果 hook 耗費太久的時間運行或僵在那, 容器便無法進到 running 狀態, 類似的行為也套用在 PreStop hook 上, 如果 hook 一直卡在執行中, Pod 會一直處於 Terminating 階段, 然後在 terminationGracePeriodSeconds 時間過後會被砍掉, terminationGracePeriodSeconds 是預設的優雅退出的秒數。 如果 PostStart 或 PreStop hook 失敗了, 容器會被 killed使用者應該盡可能地讓 hook handler 越輕量化越好。 然而, 有時候執行一些長的指令還是必要的, 像是在停止容器之前儲存狀態 Hook 交付保證通常 hook 至少會被交付一次, 這表示, 依據不同的事件, hook 有可能被呼叫多次, 像是 PostStart 或 PreStop通常 hook 只會交付一次, 但在一些少數的例子中會重複交付, 例如, kubelet 在傳送一個 hook 的途中被重啟, 那當 kubelet 重啟完成後, 這個 hook 可能會被再次傳送 Debugging Hook handlerHook handler 的 logs 並不會被暴露在 Pod 事件中。 如果一個 handler 因為某些原因失敗了, 它會廣播一個事件。 如果 PostStart 失敗了, 那就是 FailedPostStartHook 事件, 如果是 PreStop, 那就是 FailedPreStopHook 事件, 你可以執行 kubectl describe pod podName 來檢視這些事件, 以下是這個指令取得的一些事件範例：Events: FirstSeen LastSeen Count From SubObjectPath Type Reason Message --------- -------- ----- ---- ------------- -------- ------ ------- 1m 1m 1 &#123;default-scheduler &#125; Normal Scheduled Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Pulling pulling image &quot;test:1.0&quot; 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Created Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined] 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Pulled Successfully pulled image &quot;test:1.0&quot; 1m 1m 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Started Started container with docker id 5c6a256a2567 38s 38s 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Killing Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1 37s 37s 1 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Normal Killing Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1 38s 37s 2 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; Warning FailedSync Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;main&quot; with RunContainerError: &quot;PostStart handler: Error executing in Docker Container: 1&quot; 1m 22s 2 &#123;kubelet gke-test-cluster-default-pool-a07e5d30-siqd&#125; spec.containers&#123;main&#125; Warning FailedPostStartHook 範例實作PostStart hook以下 yaml 依照順序執行以下動作, 讓我們一步步來解釋: 啟動一個 nginx 容器 在啟動之後, 執行一段指定的 command 將 Hello this is post-start-demo-hook-handler 這一段話 echo 到 /demo-messages 檔案 接著我們使用 kubectl exec -it post-start-demo-hook-handler /bin/bash 進到這個容器 執行 cat demo-message, 可看到上面我們 echo 進去的 string 這代表說, postStart hook handler 確實有在容器啟動之後執行 apiVersion: v1kind: Podmetadata: name: post-start-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: post-start-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: postStart: exec: command: - \"/bin/bash\" - \"-c\" - \"echo 'Hello this is post-start-demo-hook-handler' &gt; /demo-message\" PreStop hook以下的步驟將會示範 PreStop hook, 請依照以下步驟操作 執行 kubectl apply -f fileName 來建立一個 nginx pod, yaml 檔如下 執行 kubectl delete pod pre-stop-demo-hook-handler, 把 pod 刪除 因為有設定 preStop lifecycle hook, 所以 pod 會在刪除前執行設定好的 hook handler hook handler 為執行一段 command, 會將 Hello this is the pre-stop-demo-hook-handler 這段 string echo 到 /demo/message 這個檔案中 因為這個 pod 馬上就要關閉了, 如果關閉了自然 pod 內的 /demo/message 也會銷毀, 所以我們在外頭定義一個 volume, 並掛在到容器裡, 這樣當 string 被 echo 到 /demo/message 時, 也會同步到外面來 最後執行 cat var/tmp/demo/message, 成功印出 Hello this is the pre-stop-demo-hook-handler, 代表在容器結束前, 確實有執行 preStop handler apiVersion: v1kind: Podmetadata: name: pre-stop-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: pre-stop-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: preStop: exec: command: - \"bin/bash\" - \"-c\" - \"echo 'Hello this is the pre-stop-demo-hook-handler' &gt; /demo/message\" volumeMounts: - mountPath: /demo/ name: demo volumes: - name: demo hostPath: path: /var/tmp/demo Q&amp;A 請解釋以下的 kubernetes yaml file 中的每一條 directive yaml file: apiVersion: v1kind: Podmetadata: name: post-start-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: post-start-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: postStart: exec: command: - \"/bin/bash\" - \"-c\" - \"echo 'Hello this is post-start-demo-hook-handler' &gt; /demo-message\" Answer: # API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # Pod name name: post-start-demo-hook-handler # 定義 label labels: app: life-cycle-hook# 定義 pod 規格spec: # 定義容器 containers: # 定義容器名稱 - name: post-start-demo-hook-handler # 定義鏡像名稱 image: nginx # 定義 ports ports: # 容器內 port - containerPort: 80 # port name name: demo-port # 定義 lifecycle lifecycle: # 定義 postStart hook, 會自容器啟動後執行 postStart: # hook handler 類型為 exec exec: # 執行以下指令 command: - \"/bin/bash\" - \"-c\" - \"echo 'Hello this is post-start-demo-hook-handler' &gt; /demo-message\" 請解釋以下的 Kubernetes yaml file 中的每一條 directive yaml file: apiVersion: v1kind: Podmetadata: name: pre-stop-demo-hook-handler labels: app: life-cycle-hookspec: containers: - name: pre-stop-demo-hook-handler image: nginx ports: - containerPort: 80 name: demo-port lifecycle: preStop: exec: command: - \"bin/bash\" - \"-c\" - \"echo 'Hello this is the pre-stop-demo-hook-handler' &gt; /demo/message\" volumeMounts: - mountPath: /demo/ name: demo volumes: - name: demo hostPath: path: /Users/ray/code/kubernetes/demo Answer: # API 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod name name: pre-stop-demo-hook-handler # 定義 label labels: app: life-cycle-hook# Pod 運行的規格spec: # 定義容器 containers: # 容器名稱 - name: pre-stop-demo-hook-handler # 鏡像名稱 image: nginx # 定義 ports ports: # 容器 port - containerPort: 80 # port name name: demo-port # 定義生命週期 lifecycle: # 定義 hook preStop: # 定義 handler 類型 exec: # 執行指令 command: - \"bin/bash\" - \"-c\" - \"echo 'Hello this is the pre-stop-demo-hook-handler' &gt; /demo/message\" # 掛載 volume volumeMounts: # 掛載到容器內的位置 - mountPath: /demo/ # volume 內, 需先定義 name: demo # 定義 volume volumes: # volume 名稱 - name: demo # volume 在外部 host 的位置 hostPath: # 路徑 path: /Users/ray/code/kubernetes/demo Kubernetes 中, 如果要強制刪除, 可使用哪一個指令？kubectl delete pod podName –grace-period=0 –force=true Kubernetes 中, 當使用 kubectl delete pod podName 時, 預設會等待幾秒, 才會強制刪除？30 秒 Kubernetes 中, 當使用 kubectl delete pod podName 時, 事實上使用了 docker stop, 它會發送一個什麼信號？SIGTERM Kubernetes 中, 當使用 kubectl delete pod podName, 事實上是使用了哪一個 docker 的指令？docker stop Kubernetes 中, 如果 PostStart hook 失敗了, 會廣播什麼事件？FailedPostStartHook Kubernetes 中, 如果 PreStop hook 失敗了, 會廣播什麼事件？FailedPreStopHook Kubernetes 中, 要如何檢視 pod 的事件？ kubectl describe pod podName Kubernetes 中, 如果 hook handler 失敗了, 會發生什麼事？會廣播一個事件 Kubernetes 中, 什麼情況下 hook 有可能被呼叫兩次？當呼叫 hook 到一半時, kebelet 被重啟 Kubernetes 中, hook 有可能被呼叫兩次嗎？有可能 Kubernetes 中, 如果 PostStart 或 PreStop hook 失敗了, 會發生什麼事？容器會被 killed Kubernetes 中, 如果 PreStop 一直卡在執行中, 會發生什麼事？pod 會在 terminationGracePeriodSeconds 之後被砍掉 為什麼 Kubernetes PostStart hook 跟容器的 ENTRYPOINT 是非同步的？因為 PostStart hook 跟裝有該容器的 Pod 是同步的 Kubernetes hook handler 的呼叫與哪個元件來說是同步的？pod Kubernetes hook handler 中, HTTP 做了什麼事？在容器的一個特定端點執行一個 HTTP request Kubernetes hook handler 中, Exec 消耗的資源算在哪裡？該容器上 Kubernetes hook handler 中, Exec 具體來說是什麼？執行一個特定的指令 Kubernetes 中, 可被實作的 hook handler 是哪兩種？ Exec HTTP Kubernetes 中, PreStop hook 跟刪除容器的請求, 哪一個要先完成?PreStop hook Kubernetes 中, PreStop hook 觸發時機為?容器被結束前 Kubernetes 中, PostStart hook 和 container entrypoint 哪一個會先觸發？不一定, 是非同步的 Kubernetes 中, 共有哪兩種 container hooks? PostStart PreStop Kubernetes 中, PostStart hook 觸發時機為？容器啟動後","link":"/zh-tw/kubernetes-container-lifecycle-hooks/"},{"title":"Docker 實戰入門","text":"概述Docker 是一個提供開發, 運送, 以及運行應用的開放平台。 妥善地使用 Docker, 你可以將你的應用從基礎設施分離, 並且如管理應用般的管理基礎設施。 Docker 可讓你更快速的輸送你的程式碼, 更快速的測試, 以及更快速的部署, 讓開發到運行之間的週期更加縮短。 Docker 藉由使用工作流程以及工具來融合 kernel 容器化功能, 讓你可以管理以及部署你的應用。 Docker 容器可以直接地被使用在 Kubernetes, 這讓 Docker 可以很簡單的被運行在 Kubernetes Engine, 在學習 Docker 的一些重要的核心知識後, 你將擁有可以開始開發 Kubernetes 以及容器化應用的技能組合。 學習目標在本教程中, 你將會學習到以下： 如何建立, 運行, 以及 debug Docker 容器 如何從 Docker Hub 以及 Google Container Registry 拉下 Docker 鏡像 如何將 Docker 鏡像推上 Google Container Registry 事前準備這是個入門等級的教程。 只有一點點, 或是完全沒有 Docker 相關知識也是 okay 的。 建議熟悉 Cloud Shell 以及其命令列工具, 但非必要。 如果你在尋找在一個範圍內更進階的學習素材的話, 可以參考以下的教程： App Dev: Deploying the Application into Kubernetes Engine - Python Hello Node Kubernetes Managing Deployments Using Kubernetes Engine 如果你已經準備好了, 往下滑開始設定教程環境吧 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Hello World打開 Cloud Shell 並輸入以下指令來運行一個 hello world 容器docker run hello world (輸出)Unable to find image &apos;hello-world:latest&apos; locallylatest: Pulling from library/hello-world9db2ca6ccae0: Pull completeDigest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdcStatus: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.... 這個簡單的容器回傳 Hello from Docker! 到你的螢幕上。 儘管指令很簡單, 但仔細看看在輸出中, 執行步驟的數量。 Docker daemon 搜尋名為 hello-world 的鏡像, 但沒有在本地端找到, 所以從名為 Docker Hub 的公開 registry 拉下這個鏡像, 並且使用這個鏡像建立了容器, 最後運行容器。 執行以下的指令檢視從 Docker Hub 拉下的 Docker 鏡像docker images (輸出)REPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest 1815c82652c0 6 days ago 1.84 kB 這是一個從 Docker Hub 公開 registry 被拉下的鏡像。 鏡像 ID 為 SHA256 加密 格式 - 這個欄位明確的指定被提供的鏡像。 當 docker daemon 無法在本地端找到鏡像, 預設會自動地從公開 registry 尋找鏡像。 讓我們再次運行容器：docker run hello-world (輸出)Hello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps:... 注意到, 當你第二次執行這個指令, docker daemon 在本地端找到了這個鏡像並且使用這個鏡像運行容器。 不需要再從 Docker Hub 拉下鏡像。 最後, 執行以下指令來檢視運行中的容器：docker ps (輸出)CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 目前並沒有運行中的容器。 你之前運行的 hello-world 容器已經退出了。 如果要檢視所有的容器, 包含已經結束運行的容器, 可以執行 docker ps -a:docker ps -a (輸出)CONTAINER ID IMAGE COMMAND ... NAMES6027ecba1c39 hello-world &quot;/hello&quot; ... elated_knuth358d709b8341 hello-world &quot;/hello&quot; ... epic_lewin 這會顯示 Container ID, 這是一個由 Docker 建立的 UUID, 用以辨識容器, 除此之外, 還有一些容器的資訊。 容器的 Names 也是隨機產生的, 但你也可以使用 docker run --name [container-name] hello-world 來指定它 建立現在讓我們來建立一個基於 node 簡單應用的 Docker 鏡像。 執行以下指令來建立並且切換到這個名為 test 的資料夾mkdir test &amp;&amp; cd test 建立一個 Dockerfile:cat &gt; Dockerfile &lt;&lt;EOF# Use an official Node runtime as the parent imageFROM node:6# Set the working directory in the container to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Make the container's port 80 available to the outside worldEXPOSE 80# Run app.js using node when the container launchesCMD [\"node\", \"app.js\"]EOF 這個檔案指示 Docker daemon 該怎樣建立這個鏡像 第一行指定了基礎鏡像, 在這個範例中為 node 版本 6 的官方 Docker 鏡像 第二行, 我們指定了容器內的工作(目前)目錄 第三行, 我們當層資料夾內的內容(容器外), 複製到容器內 最後, 我們暴露了容器的 port, 所以此容器可經由該 port 被存取, 然後運行 node 的指令來運行應用 花一些時間看一下 Dockerfile command references 來了解 Dockerfile 中每一行的意思 現在, 你將寫入 node 應用, 且在那之後你將建立鏡像 執行以下指令來建立 node 應用cat &gt; app.js &lt;&lt;EOFconst http = require('http');const hostname = '0.0.0.0';const port = 80;const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n');&#125;);server.listen(port, hostname, () =&gt; &#123; console.log('Server running at http://%s:%s/', hostname, port);&#125;);process.on('SIGINT', function() &#123; console.log('Caught interrupt signal and will exit'); process.exit();&#125;);EOF 這是一個簡單的 HTTP server, 監聽 port 80 且回傳 “Hello world.” 現在讓我們來建立鏡像吧 再次注意, &quot;.&quot; 這個符號代表目前的資料夾為止, 所以你必須要在有 Dockerfile 的資料夾底下運行這個指令docker build -t node-app:0.1 . 這個指令可能會花個幾分鐘才會執行完畢。 當它執行結束, 你的輸出應會如下：Sending build context to Docker daemon 3.072 kBStep 1 : FROM node:66: Pulling from library/node.........Step 5 : CMD node app.js ---&gt; Running in b677acd1edd9 ---&gt; f166cd2a9f10Removing intermediate container b677acd1edd9Successfully built f166cd2a9f10 -t 是為使用 name:tag 語法來命名鏡像的 tag, 鏡像名稱為 node-app, tag 為 0.1, 高度建議當建立鏡像時一定要使用 tag 。 如果你沒指定 tag, tag 將預設為 latest, 這會讓你更難分辨新舊鏡像。 也請注意到, 在鏡像被建立的過程中, Dockerfile 中的每一行指令在中間的容器層中造成什麼樣的結果。 現在, 執行以下指令來檢視建立的鏡像：docker images 輸出應如下：REPOSITORY TAG IMAGE ID CREATED SIZEnode-app 0.1 f166cd2a9f10 25 seconds ago 656.2 MBnode 6 5a767079e3df 15 hours ago 656.2 MBhello-world latest 1815c82652c0 6 days ago 1.84 kB 注意到, node 為基礎鏡像, 而 node-app 為你建立的鏡像。 在移除 node 鏡像之前, 你必須要先移除 node-app 。 鏡像的大小跟虛擬機比起來的話小了非常多。 其他版本的 node 鏡像, 像是 node:slim 以及 node:alpine 提供了更小的體積, 更好的攜帶性。 降低鏡像大小的主題, 你可探索更進階的主題。 你可以在 官方倉庫 檢視所有的版本 運行在這個章節中, 執行這個程式碼, 使用之前建立的鏡像運行容器:docker run -p 4000:80 --name my-app node-app:0.1 (輸出)Server running at http://0.0.0.0:80/ --name flag 讓你可以自由的命名你的容器。 -p 指定容器映射本機端的 port 4000 到容器內的 port 80, 而現在你應可經由 http://localhost:4000 存取 server。 如果沒有做 port 映射, 你將無法經由 localhost 來存取容器 打開另外一個終端機 (在 Cloud Shell, 點擊 + icon), 然後測試 servercurl http://localhost:4000 (輸出)Hello World 第一個終端機視窗開啟多久, 這個容器就會運行多久。 如果你想要將容器運行在背景中 (不會綁住終端機), 你需要指定 -d flag 關閉第一個終端機視窗, 然後執行以下指令來停止並移除容器：docker stop my-app &amp;&amp; docker rm my-app 現在執行以下指令來開始在背景運行另外一個容器：docker run -p 4000:80 --name my-app -d node-app:0.1docker ps (輸出)CONTAINER ID IMAGE COMMAND CREATED ... NAMESxxxxxxxxxxxx node-app:0.1 &quot;node app.js&quot; 16 seconds ago ... my-app 從 docker ps 的輸出, 我們可以看到容器正在運行中。 你可以執行 docker logs [container_id] 指令來檢視 logs 小技巧: 你不需要完整的容器 ID, 只要前幾個字是獨一無二足以代表這個容器。 舉例來說, 你可以執行 docker ps 17b, 如果你的容器 ID 是 17bcaca6f... docker logs [container_id] (輸出)Server running at http://0.0.0.0:80/ 現在讓我們來修改應用。 在 Cloud Shell, 打開之前建立的 test 資料夾：cd test 使用你的編輯器 (比如 namo 或 vim) 來編輯 app.js, 然後將 “Hello World” 替換成其他字串:....const server = http.createServer((req, res) =&gt; &#123; res.statusCode = 200; res.setHeader(&apos;Content-Type&apos;, &apos;text/plain&apos;); res.end(&apos;Welcome to Cloud\\n&apos;);&#125;);.... 建立這個新的鏡像, 並給予 tag 0.2:docker build -t node-app:0.2 . (輸出)Step 1/5 : FROM node:6 ---&gt; 67ed1f028e71Step 2/5 : WORKDIR /app ---&gt; Using cache ---&gt; a39c2d73c807Step 3/5 : ADD . /app ---&gt; a7087887091fRemoving intermediate container 99bc0526ebb0Step 4/5 : EXPOSE 80 ---&gt; Running in 7882a1e84596 ---&gt; 80f5220880d9Removing intermediate container 7882a1e84596Step 5/5 : CMD node app.js ---&gt; Running in f2646b475210 ---&gt; 5c3edbac6421Removing intermediate container f2646b475210Successfully built 5c3edbac6421Successfully tagged node-app:0.2 注意到, 在 step 2我們使用了以存在的緩存層。 從 step 3 開始, 層被修改了因為我們在 app.js 中做了一些變更 使用新的鏡像版本啟動另外一個容器。 注意到我們是如何的映射本機端的 port 8080, 而不是 port 80, 我們不能在使用 port 4000 因為它已經在使用中了。 docker run -p 8080:80 --name my-app-2 -d node-app:0.2docker ps (輸出)CONTAINER ID IMAGE COMMAND CREATED xxxxxxxxxxxx node-app:0.2 &quot;node app.js&quot; 53 seconds ago ...xxxxxxxxxxxx node-app:0.1 &quot;node app.js&quot; About an hour ago ... 測試容器curl http://localhost:8080 (輸出)Welcome to Cloud 現在測試第一個容器curl http://localhost:4000 (輸出)Hello World Debug現在我們已經熟悉如何建立以及運行容器, 來學習一下一些 debugging 的方法。你可以使用 docker logs [container_id 來檢視容器的日誌, 如果你想要檢視即時的日誌輸出的話, 可以使用 -f 選項docker logs -f [container_id] (輸出)Server running at http://0.0.0.0:80/ 有時, 你可能會想要啟動一個容器內的 Bash, 你可以使用 docker exec 來做到這件事。 打開另外一個終端機 (在 Cloud Shell, 點擊 + 圖示), 然後執行以下指令:docker exec -it [container_id] bash -it flags 讓你可以分配一個虛擬的 TTY 給容器, 保持輸入開啟並與之互動。 注意到目前 bash 正運行在 Dockerfile 內指定的 WORKDIR 資料夾 (/app), 現在你有一個容器內的互動式的 shell 可以用來 debug 了 (輸出)root@xxxxxxxxxxxx:/app# 檢視資料夾ls (輸出)Dockerfile app.jsroot@xxxxxxxxxxxx:/app# 若要離開 Bash, 在 Bash 中輸入 exit:exit 你可以使用以下指令來檢視容器的元資料docker inspect [container_id] (輸出)[ &#123; &quot;Id&quot;: &quot;xxxxxxxxxxxx....&quot;, &quot;Created&quot;: &quot;2017-08-07T22:57:49.261726726Z&quot;, &quot;Path&quot;: &quot;node&quot;, &quot;Args&quot;: [ &quot;app.js&quot; ],... 使用 --format 從回傳的 JSON 當中檢查特定的欄位。 例如說：docker inspect --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' [container_id] (輸出)192.168.9.3 務必到以下的連結去參考更多有關 debugging 的資訊 Docker inspect reference Docker exec reference 發佈現在, 你將推送你的鏡像到 Google Container Registry (gcr)。 在那之後, 你將會將本地的容器以及鏡像都刪除來模擬一個全新的環境, 然後從遠端拉取鏡像並啟動容器。 這將是 Docker 容器可攜性的最佳示範。 要推送鏡像到你的私人 gcr 的 registry, 你需要 tag registry 的名稱到這個鏡像。 格式就像是 [hostname]/[project-id]/[image]:[tag] GCR 的格式： [hostname] = gcr.io [project-id] = 你的 project ID [image] = 你的鏡像名稱 [tag] = 你選擇的 tag, 若無特別指定, 預設為 “latest” 你可以執行以下指令來找到你的 project IDgcloud config list project (輸出)[core]project = [project-id]Your active configuration is: [default] 給予 tag node-app:0.2, 並將 [project-id] 替換成你的設定 docker tag node-app:0.2 gcr.io/[project-id]/node-app:0.2 docker images (輸出)REPOSITORY TAG IMAGE ID CREATEDnode-app 0.2 76b3beef845e 22 hours agogcr.io/[project-id]/node-app 0.2 76b3beef845e 22 hours agonode-app 0.1 f166cd2a9f10 26 hours agonode 6 5a767079e3df 7 days agohello-world latest 1815c82652c0 7 weeks ago 將這個鏡像推送到 gcr, 記住要將 [project-id] 替換成你的設定docker push gcr.io/[project-id]/node-app:0.2 (輸出)The push refers to a repository [gcr.io/[project-id]/node-app]057029400a4a: Pushed342f14cb7e2b: Pushed903087566d45: Pushed99dac0782a63: Pushede6695624484e: Pushedda59b99bbd3b: Pushed5616a6292c16: Pushedf3ed6cb59ab0: Pushed654f45ecb7e3: Pushed2c40c66f7667: Pushed0.2: digest: sha256:25b8ebd7820515609517ec38dbca9086e1abef3750c0d2aff7f341407c743c46 size: 2419 從瀏覽器拜訪鏡像位址來確認鏡像已存在於 gcr, 你可以從主控台到 Tools &gt; Container Registry 或是拜訪 http://gcr.io/[project-id]/node-app, 顯示頁面應如下： 現在讓我們測試這個鏡像。 你可以開啟一個新的 VM, ssh 到這個 VM, 然後安裝 gcloud, 但為求簡單化, 我們將簡單的移除所有的容器以及鏡像來模擬一個全新的環境。 停止並刪除所有的容器：docker stop $(docker ps -q)docker rm $(docker ps -aq) 在移除 node 鏡像之前, 你必須要移除它的子鏡像 (node:6 的), 運行已下指令, 記得將 [project-id] 替換成你自己的docker rmi node-app:0.2 gcr.io/[project-id]/node-app node-app:0.1docker rmi node:6docker rmi $(docker images -aq) # remove remaining imagesdocker images (輸出)REPOSITORY TAG IMAGE ID CREATED SIZE 現在你應該有一個虛擬全新的環境。 拉取並運行鏡像。 記得將 [project-id] 替換成你自己的docker pull gcr.io/[project-id]/node-app:0.2docker run -p 4000:80 -d gcr.io/[project-id]/node-app:0.2curl http://localhost:4000 (輸出)Welcome to Cloud 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功發布容器鏡像到 Container Registry, 你將獲得一個評價分數。 在這裏, 我們示範了容器的可攜帶性。 只要機器上有安裝 Docker (實機或虛擬機), 你可以從公開或私人的 registries 拉取鏡像並運行容器。 在你的機器上除了 Docker, 你不需要再安裝其他的應用相依。 恭喜你已經完成本教程","link":"/zh-tw/introductionToDocker/"},{"title":"Configure a Pod to Use a ConfigMap","text":"概述本篇為 ConfigMap 的介紹與使用筆記, 參考來源為 官方文件, 除了文件內容翻譯外, 也會有 Questions and Answers 區塊來將重點摘出。 建立 ConfigMap你可以使用 kubectl create configmap 或是 kustomization.yaml 中的 ConfigMap 產生器來建立 ConfigMap。 kubectl 從 1.14 開始支援 kustomization.yaml 使用 kubectl 建立 ConfigMap使用 kubectl create configmap 指令, 從 資料夾, 檔案, 或 輸入值 來建立 ConfigMapskubectl create configmap &lt;map-name&gt; &lt;data-source&gt; 是你想要給予這個 COnfigMap 的名字, 而 是資料的來源, 可以是資料夾, 檔案, 或是輸入值 當你從檔案建立 ConfigMap, 的 key 預設為檔案名稱, 而 value 為檔案內容 你可以使用 kubectl describe 或是 kubectl get 來取得 ConfigMap 的資訊 從資料夾建立 ConfigMap你可以使用 kubectl create configmap 從一個資料夾裡頭多個檔案來建立 ConfigMap。 當你從資料夾建立 ConfigMap, kubernetes 會辨識出資料夾內合法的檔案名稱, 然後將這些檔案都裝到一個新的 ConfigMap。 所以非 regular 類型的檔案都會被無視 (像是, 子資料夾, 連結, 裝置, 管道, 等等)舉例來說:# 建立本地資料夾mkdir -p configure-pod-container/configmap/# 下載範例檔wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.propertieswget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties# 建立 configmapkubectl create configmap game-config --from-file=configure-pod-container/configmap/ 上面的指令會打包每個檔案, 此範例中為 configure-pod-container/configmap/ 資料夾中的 game.properties 以及 ui.properties, 會裝到 game-config 這個 ConfigMap。 你可以使用下面的指令來顯示 ConfigMap 細節:kubectl describe configmaps game-config 輸出類似這樣：Name: game-configNamespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30ui.properties:----color.good=purplecolor.bad=yellowallow.textmode=truehow.nice.to.look=fairlyNice config-pod-container/configmap/ 資料夾中的 game.properties 以及 ui.properties 被列在 ConfigMap 中的 data 區塊 執行指令檢視：kubectl get configmaps game-config -o yaml 輸出類似：apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T18:52:05Z name: game-config namespace: default resourceVersion: &quot;516&quot; uid: b4952dc3-d670-11e5-8cd0-68f728db1985data: game.properties: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 ui.properties: | color.good=purple color.bad=yellow allow.textmode=true how.nice.to.look=fairlyNice 從檔案建立 ConfigMaps你可以使用 kubectl create configmap 從單檔或多檔案建立 ConfigMap例如, 執行以下指令:kubectl create configmap game-config-2 --from-file=configure-pod-container/configmap/game.properties 會建立以下 ConfigMap, 執行以下指令檢視：kubectl describe configmaps name-config-2 輸出類似：Name: game-config-2Namespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30 你可以多次使用 --from-file 這個 flag, 藉此從多個檔案建立 ConfigMap:kubectl create configmap game-config-2 --from-file=configure-pod-container/configmap/game.properties --from-file=configure-pod-container/configmap/ui.properties 執行以下指令來顯示 game-config-2 細節資訊kubectl describe configmaps game-config-2 輸出類似：Name: game-config-2Namespace: defaultLabels: &lt;none&gt;Annotations: &lt;none&gt;Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30ui.properties:----color.good=purplecolor.bad=yellowallow.textmode=truehow.nice.to.look=fairlyNice 使用 --from-env-file 選項, 從 env-file 建立 ConfigMap, 例如以下為 env 範例# Env-files 含有一系列的環境變數# 以下為語法：# env file 中的每行必須是 VAR=VAL 格式# # 開頭的那行會被忽略 (也就是 comment)# 空白行會被忽略# quotation marks 在 configMap 中不具有特別意義, 也就是說會變成 configMap 的 value 一部分# 下載範例檔案wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties# 範例檔如下：cat configure-pod-container/configmap/game-env-file.propertiesenemies=alienslives=3allowed=&quot;true&quot;# 這個 comment 以及上面的空行會被忽略 執行以下指令：kubectl create configmap game-config-env-file \\ --from-env-file=configure-pod-container/configmap/game-env-file.properties 會產生以下 ConfigMap, 執行以下指令檢視這個 ConfigMapkubectl get configmap game-config-env-file -o yaml 輸出類似：apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2017-12-27T18:36:28Z name: game-config-env-file namespace: default resourceVersion: &quot;809965&quot; uid: d9d1ca5b-eb34-11e7-887b-42010a8002b8data: allowed: &apos;&quot;true&quot;&apos; enemies: aliens lives: &quot;3&quot; 注意: 當多次使用 --from-env-file 時, 只有最後一個會被採用 多次使用 --from-env-file 的行為如下：# 下載範例wget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties# 建立 ConfigMapkubectl create configmap config-multi-env-files \\ --from-env-file=configure-pod-container/configmap/game-env-file.properties \\ --from-env-file=configure-pod-container/configmap/ui-env-file.properties 會產生以下的 ConfigMap, 執行以下指令檢視這個 ConfigMapkubectl get configmap config-multi-env-files -o yaml 輸出如下：apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2017-12-27T18:38:34Z name: config-multi-env-files namespace: default resourceVersion: \"810136\" uid: 252c4572-eb35-11e7-887b-42010a8002b8data: color: purple how: fairlyNice textmode: \"true\" 當從檔案建立 ConfigMap 時, 自己定義 key當你使用 --from-file 來建立 ConfigMap 時, 你不一定要使用檔名為 key, 你也可以自己定義 key, 如以下語法：kubectl create configmap game-config-3 --from-file=&lt;my-key-name&gt;=&lt;path-to-file&gt; &lt;my-key-name&gt; 為你想要的 key name, 而 &lt;path-to-file&gt; 為檔案來源例如說kubectl create configmap game-config-3 --from-file=game-special-key=configure-pod-container/configmap/game.properties 以上指令會產生一個 ConfigMap, 執行以下指令來檢視它kubectl get configmaps game-config-3 -o yaml 輸出類似:apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T18:54:22Z name: game-config-3 namespace: default resourceVersion: \"530\" uid: 05f8da22-d671-11e5-8cd0-68f728db1985data: game-special-key: | enemies=aliens lives=3 enemies.cheat=true enemies.cheat.level=noGoodRotten secret.code.passphrase=UUDDLRLRBABAS secret.code.allowed=true secret.code.lives=30 從輸入值建立 ConfigMap你可以使用 kubectl create configmap 的 --from-literal flag, 從命令行來定義輸入值kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charm 這個 flag 可以使用多次, 每一次都會產生 ConfigMap 中的一個 key / value pair, 輸入以下指令檢視:kubectl get configmaps special-config -o yaml 輸出類似：apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T19:14:38Z name: special-config namespace: default resourceVersion: \"651\" uid: dadce046-d673-11e5-8cd0-68f728db1985data: special.how: very special.type: charm 從產生器建立 ConfigMap從 1.14 開始, kubectl 支援使用 kustomization.yaml。 你可以使用產生器來建立 ConfigMap 並且在 Apiserver 中建立這個物件。 產生器必須被定義在 kustomization.yaml 檔案中 從檔案建立 ConfigMaps舉例來說, 從 configure-pod-container/configmap/game.properties 這個檔案來建立 ConfigMap# 建立一個有產生器的 kustomization.yaml 檔cat &lt;&lt;EOF &gt;./kustomization.yamlconfigMapGenerator:- name: game-config-4 files: - configure-pod-container/configmap/game.propertiesEOF apply 這個資料夾來建立 ConfigMap 物件kubectl apply -k .configmap/game-config-4-m9dm2f92bt created 你可以像這樣來確認 ConfigMap 是否有被建立：kubectl get configmapNAME DATA AGEgame-config-4-m9dm2f92bt 1 37skubectl describe configmaps/game-config-4-m9dm2f92btName: game-config-4-m9dm2f92btNamespace: defaultLabels: &lt;none&gt;Annotations: kubectl.kubernetes.io/last-applied-configuration: &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;data&quot;:&#123;&quot;game.properties&quot;:&quot;enemies=aliens\\nlives=3\\nenemies.cheat=true\\nenemies.cheat.level=noGoodRotten\\nsecret.code.p...Data====game.properties:----enemies=alienslives=3enemies.cheat=trueenemies.cheat.level=noGoodRottensecret.code.passphrase=UUDDLRLRBABASsecret.code.allowed=truesecret.code.lives=30Events: &lt;none&gt; 可以注意到, 被產生的 ConfigMap name 後面有串 hash 的字串, 這確保每次內容被修改時, 都會建立一個新的 ConfigMap 當從 file 產生 ConfigMap 時, 自定義 key使用 ConfigMap 產生器時, 不一定要使用檔名來當作 key, 你也可以自訂義, 例如說, 從 configure-pod-container/configmap/game.properties 檔案來建立 ConfigMap, 並且使用 game-special-key 當作 key# 使用 kustomization.yaml 定義 ConfigMapGeneratorcat &lt;&lt;EOF &gt;./kustomization.yamlconfigMapGenerator:- name: game-config-5 files: - game-special-key=configure-pod-container/configmap/game.propertiesEOF Apply kustomization.yaml 所在資料夾來建立 ConfigMap 物件kubectl apply -k .configmap/game-config-5-m67dt67794 created 從輸入值來建立 ConfigMap現在要從輸入值 special.type=charm 以及 special.how=very 來產生 ConfigMap, 先在 kustomization.yaml 檔案定義 ConfigMap 產生器# Create a kustomization.yaml file with ConfigMapGeneratorcat &lt;&lt;EOF &gt;./kustomization.yamlconfigMapGenerator:- name: special-config-2 literals: - special.how=very - special.type=charmEOF Apply kustomization.yaml 檔所在資料夾來建立 ConfigMap 物件kubectl apply -k .configmap/special-config-2-c92b5mmcf2 created 使用 ConfigMap 資料來定義容器環境變數使用單一 ConfigMap 定義容器環境變數 建立 configMap kubectl create configmap special-config --from-literal=special.how=very 將 ConfigMap 的 special.how 的值指派給環境變數 SPECIAL_LEVEL_KEY, vim pods/pod-single-configmap-env-variable.yaml 並輸入以下值 apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \"/bin/sh\", \"-c\", \"env\" ] env: # 定義環境變數 - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: # ConfigMap 含有你想要指派給 SPECIAL_LEVEL_KEY 的值 name: special-config # 指定想要指派的 value 的 key key: special.how restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml 現在, 該 Pod 的輸出將包含環境變數 SPECIAL_LEVEL_KEY=very 使用多個 ConfigMap 定義容器環境變數 跟上一個 example 一樣, 建立一個 ConfigMap, vim configmap/configmaps.yaml, 並輸入以下值: apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: special.how: very---apiVersion: v1kind: ConfigMapmetadata: name: env-config namespace: defaultdata: log_level: INFO 建立 ConfigMap kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml 定義一個 Pod 檔, 並定義該 Pod 環境變數, vim pods/pod-multiple-configmap-env-variable.yaml, 輸入以下值: apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \"/bin/sh\", \"-c\", \"env\" ] env: - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: name: special-config key: special.how - name: LOG_LEVEL valueFrom: configMapKeyRef: name: env-config key: log_level restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml 現在, 該 Pod 輸出包含環境變數 SPECIAL_LEVEL_KEY=very 以及 LOG_LEVE=INFO 在 ConfigMap 中配置所有的 key-value pairs 如容器環境變數注意: 這個功能在 Kubernetes 1.6 以及之後版本才可用 建立包含多組 key-value 的 ConfigMap, vim configmap/configmap-multikeys.yaml 並輸入以下內容： apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: SPECIAL_LEVEL: very SPECIAL_TYPE: charm 建立該 ConfigMap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml 使用 envFrom 來將 ConfigMap 中的所有 data 都定義成容器環境變數。 ConfigMap.metadata.name 會成為 .spec.containers.envFrom.configMapRef.name 建立 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml 現在, Pod 的輸出包含了環境變數 SPECIAL_LEVEL=very 以及 SPECIAL_TYPE=charm 在 Pod 的指令選項使用由 ConfigMap 定義的環境變數你可以在 Pod 的 command 區塊使用由 ConfigMap 定義的環境變數, 語法為 $(VAR_NAME), 啥？ 看不懂？ 簡單來說, 如果 env 的 name 是 SPECIAL_LEVEL_KEY, 那你可以在 command 區塊中使用 $(SPECIAL_LEVEL_KEY), 這樣夠清楚明白了吧？ 範例如下： apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \"/bin/sh\", \"-c\", \"echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)\" ] env: - name: SPECIAL_LEVEL_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_LEVEL - name: SPECIAL_TYPE_KEY valueFrom: configMapKeyRef: name: special-config key: SPECIAL_TYPE restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml test-container 輸出如下： very charm 將 ConfigMap 資料加到 Volume如同 Create ConfigMaps from files 的解釋, 當你使用 --from-file 建立 ConfigMap, 檔名會變成存在 ConfigMap data 區塊中的 key, 而這個檔案的內容會是該 key 的值 本節中的 ConfigMap 範例為 special-config, 如下： apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: SPECIAL_LEVEL: very SPECIAL_TYPE: charm 建立該 ConfigMap kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml 將 ConfigMap 的資料載入到 Volume 中將 ConfigMap 的 name 加到 Pod spec 中的 volumes 區塊。 這會將 ConfigMap 的資料加到由 volumeMounts.mountPath 指定的資料夾 (在本範例中, 為 /etc/config)。 command 列出在該資料中, 符合 ConfigMap key name 的檔案 範例檔： apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \"/bin/sh\", \"-c\", \"ls /etc/config/\" ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: # Provide the name of the ConfigMap containing the files you want # to add to the container name: special-config restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml 當該 Pod 運行時, 會執行 ls /etc/config/ 產生以下輸出： SPECIAL_LEVELSPECIAL_TYPE 注意: 如果在 /etc/config 資料夾中有其他檔案的話, 他們會被刪除哦! 將 ConfigMap 資料加到 Volume 中特定的路徑使用 path 欄位來指定特定的 ConfigMap item 到想要的檔案路徑。 在這個例子中, SPECIAL_LEVEL item 將會被掛載到 config-volume volume 中的 /etc/config/keys 範例如下： apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \"/bin/sh\",\"-c\",\"cat /etc/config/keys\" ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: special-config items: - key: SPECIAL_LEVEL path: keys restartPolicy: Never 建立該 Pod kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml 當 Pod 開始運行, 指定 cat /etc/config/keys 會產生以下輸出 very 投射 keys 到指定的路徑以及檔案權限我們可以投射 keys 到指定的路徑以及特定的檔案權限, 根據每個檔案的狀況。 這部分會在 Secrets 有更詳細介紹, 這邊不多家贅述 掛載的 ConfigMap 會被自動更新當已經被掛載到 volume 的 ConfigMap 更新了, 映射的 key 最終也會更新。 kubelet 會每一段時間確認一次掛載的 ConfigMap 是否有更新。 然而, kubelet 使用了 ttl-based cache 來取得 ConfigMap 當下值, 結果就是, 從 ConfigMap 更新之後到新的 key 被投射到 Pod 的延遲時間會等於 kubelet 同步頻率 (預設 1 分鐘) + ttl ConfigMap cache (預設 1 分鐘), 你也可以藉由更新該 pod 的 annotations 來觸發立即刷新注意: 使用 ConfigMap 為 subPath volume 的容器將不會收到 ConfigMap 的更新 理解 ConfigMap 以及 PodsConfigMap API 資源以 key-value pairs 的方式儲存配置資料。 這個資料可以被 pods 所運用, 也可提供給系統元件的配置資料, 像是 controllers。 ConfigMap 跟 Secrets 很類似, 但主要是提供不含敏感資訊的字串用途。 使用者或系統元件可以使用 ConfigMap 儲存配置檔資料 注意: ConfigMap 需參照屬性檔案, 而非取代他們。 想像 ConfigMap 就像是類似 Linux /etc 資料夾以及其內容。 舉例來說, 如果你從 ConfigMap 建立了 Kubernetes Volume, volume 中的每個檔案就代表著 ConfigMap 當中的每一個 data item ConfigMap 的 data 欄位含有設定檔資料。 如以下範例, 它可以很簡單 - 比如說使用 --from-literal 定義每一個 item, 或複雜一點 - 像使用 --from-file 定義一個JSON 格式的配置檔案apiVersion: v1kind: ConfigMapmetadata: creationTimestamp: 2016-02-18T19:14:38Z name: example-config namespace: defaultdata: # example of a simple property defined using --from-literal example.property.1: hello example.property.2: world # example of a complex property defined using --from-file example.property.file: |- property.1=value-1 property.2=value-2 property.3=value-3 Restrictions 你必須在 Pod specification 區塊中參考一個 ConfigMap 之間先建立它 (除非你把它標註為 optional)。如果你參考一個不存在的 ConfigMap, 這個 Pod 不會開始。 同樣的, 如果你參考一個不存在的 key, 那 Pod 也是不會開始 如果你使用 envFrom 從 ConfigMaps 定義環境變數, 若 keys 被判斷為不合法的話, 將會被忽略。 Pod 還是可以啟動, 但是不合法的名稱將會被記錄在事件 (InvalidVariableNames)。 log 的訊息會列出每一個忽略的 key, 例如說: kubectl get events 輸出像是： LASTSEEN FIRSTSEEN COUNT NAME KIND SUBOBJECT TYPE REASON SOURCE MESSAGE 0s 0s 1 dapi-test-pod Pod Warning InvalidEnvironmentVariableNames &#123;kubelet, 127.0.0.1&#125; Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names. ConfigMap 隸屬於特定的 Namespace, 且只可被隸屬於同個 namespace 中的 pods 所使用。 ConfigMap 不可被用在 static pods 上, 因為 kubelet 不支援 Questions and AnswersKubernetes ConfigMap 中, ConfigMap 可以被使用在不同 namespace 的 pod 嗎？不行 Kubernetes ConfigMap 中, ConfigMap 可以被使用在 static pod 嗎？不可 Kubernetes ConfigMap 中, 如果我建立了一個 Pod, 並 reference 一個不存在的 ConfigMap 的 key 那會怎麼樣？該 Pod 不會開始 Kubernetes ConfigMap 中, 如果我建立了一個 Pod, 並 reference 一個不存在的 ConfigMap, 那會怎麼樣？該 Pod 不會開始 Kubernetes ConfigMap 中, 如果我要立即觸發 ConfigMap 更新同步的話, 我可以怎麼做？更新該 Pod 的 annotation Kubernetes ConfigMap 中, 使用 ConfigMap 為 subPath volume 的容器會收到 ConfigMap 更新嗎？不會 Kubernetes ConfigMap 中, ttl based cache 預設多久？1 分鐘 Kubernetes ConfigMap 中, kubelet 預設多久會確認一次 ConfigMap 是否有更新？1 分鐘 Kubernetes ConfigMap 中, 當掛載到 volume 的 ConfigMap 更新了, 同步到 Pod 的延遲時間跟哪兩個因素有關？ kubelet 確認變更的頻率 ttl cache 使用的時間 Kubernetes ConfigMap 中, 當掛載到 volume 的 ConfigMap 更新了, 會同步更新到 Pod 嗎？會哦 Kubernetes 中, 如果我要在 Pod 的 command 區塊中使用 env 的話, 假設我 env 的 name 為 SPECIAL_LEVEL_KEY, 那在 command 區塊中的變數為？$(SPECIAL_LEVEL_KEY) Kubernetes 中, 假設我有 ConfigMap 如下, 我該怎麼樣一次性的將此 ConfigMap 中的所有 data 都設成環境變數？ 該使用哪一個 field? Example: apiVersion: v1kind: ConfigMapmetadata: name: special-config namespace: defaultdata: SPECIAL_LEVEL: very SPECIAL_TYPE: charm Answer: apiVersion: v1kind: Podmetadata: name: dapi-test-podspec: containers: - name: test-container image: k8s.gcr.io/busybox command: [ \"/bin/sh\", \"-c\", \"env\" ] envFrom: - configMapRef: name: special-config restartPolicy: Never 請解釋以下的 kustomization.yaml 檔案 Example: configMapGenerator:- name: special-config-2 literals: - special.how=very - special.type=charm Answer: # 定義 configMapGeneratorconfigMapGenerator:# 定義 configMap name- name: special-config-2 # 使用 liberals 方式, 並定義 literals: - special.how=very - special.type=charm 以下的 kustomization.yaml 檔案中, 如果我要自定義 key, 我可以怎麼做？ Example: configMapGenerator:- name: game-config-5 files: - configure-pod-container/configmap/game.properties Answer: configMapGenerator:- name: game-config-5 files: - game-special-key=configure-pod-container/configmap/game.properties 以下的 kubernetes kustomization.yaml 代表什麼意思？ Example: configMapGenerator:- name: game-config-4 files: - configure-pod-container/configmap/game.properties Answer: configMapGenerator:# 定義 configMap 物件名稱- name: game-config-4 # 定義 data source files: - configure-pod-container/configmap/game.properties Kubernetes 中, 如果我想要使用產生器來建立 ConfigMap, 我可以在哪個檔案中定義？kustomization.yaml 以下的 Kubernetes ConfigMap 範例中, 如果我不想使用檔名為 key, 我想要自己定義 key 的話, 我可以怎麼修改？ Example: kubectl create configmap game-config-3 --from-file=&lt;path-to-file&gt; Answer: kubectl create configmap game-config-3 --from-file=&lt;my-key-name&gt;=&lt;path-to-file&gt; Kubernetes ConfigMap 中, 當我使用 --from-file flag 來建立 ConfigMap 時, 除了使用檔名為 key 之外, 我可以自己定義 key 嗎？可以 Kubernetes 中, 當我多次使用 --from-env-file 這個 flag 多次, 會發生什麼事？只有最後一個會被採用 Kubernetes 中, 如果我想要從 env 檔來建立 ConfigMap, 我可以使用哪一個 flag?--from-env-file Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, Kubernetes 會如何處理 quotation marks, 像是 &#39;, 或 &quot;？會將他們變成 ConfigMap value 的一部分 Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, Kubernetes 會如何處理 # 開頭的 comment？無視 Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, Kubernetes 會如何處理空行？無視 Kubernetes ConfigMap 中, 當我使用 --from-env-file 時, 內容必須是什麼格式？VAR=VAL 以下的 K8s ConfigMap yaml 檔, 代表什麼意思? yaml 檔: kind: ConfigMapapiVersion: v1metadata: name: cm-demo namespace: defaultdata: data.1: hello data.2: world config: | property.1=value-1 property.2=value-2 property.3=value-3 Answer: data: data.1: 單個屬性, data.1 為 key, hello 為 value data.2: 單個屬性, 同上 config: config 為整個配置文件, 內容如下 | 為 Block Style Indicator, literal style, 如果 string 當中有空行, 會被保留下來, 可參考範例 Kubernetes 中, 當我們不知道要怎麼樣建立一個資源時, 可以使用哪一個指令來檢視範例？kubectl create RESOURCE -h Kubernetes 中, 如果我在 tls 資料夾下有 4 個 檔案(如下), 現在我要建立一個 configMap, 這個 configMap 需同時包含這 4 個檔案, 檔名為 key, value 為檔案內容, 那我可以怎麼做？ 資料夾: Answer:kubectl create configMap configMapName --from-file=./ Kubernetes 中, 如果我要 print 出 configMap 的內容, 我可以使用哪一個指令？kubectl get configMap configMapName -o=format Kubernetes 中, 如果我在 tls 資料夾下有 4 個 檔案(如下), 現在我要建立一個 configMap, 這個 configMap 只包含 key.pem 的內容, 檔名為 key, value 為檔案內容, 那我可以怎麼做？ 資料夾: Answer:kubectl create configMap configMapName --from-file=./key.pem kubectl create configmap 中, --from-file 的 flag 可以重複使用嗎?可以哦 以下的 Kubernetes Pod yaml 配置檔是什麼意思？ 配置檔: apiVersion: v1kind: Podmetadata: name: testcm1-podspec: containers: - name: testcm1 image: busybox command: [ \"/bin/sh\", \"-c\", \"env\" ] env: - name: DB_HOST valueFrom: configMapKeyRef: name: cm-demo3 key: db.host - name: DB_PORT valueFrom: configMapKeyRef: name: cm-demo3 key: db.port envFrom: - configMapRef: name: cm-demo1 Answer: # API version, 可參考[文件](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#-strong-api-overview-strong-)apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: testcm1-pod# 該 Pod 要實作的規格spec: # 該 Pod 內的容器規格 containers: # 容器名稱 - name: testcm1 # 容器鏡像 image: busybox # 容器開啟後執行的 command command: [ \"/bin/sh\", \"-c\", \"env\" ] env: # env 的名稱 - name: DB_HOST # env 的值的來源 valueFrom: # 引用 configMap configMapKeyRef: # 引用的 configMap 的名稱 name: cm-demo3 # 引用的 configMap 檔案中的 key key: db.host # 另一個 env 的名稱 - name: DB_PORT # env 的值的來源 valueFrom: # 引用 configMap configMapKeyRef: # 引用的 configMap 的名稱 name: cm-demo3 # 引用的 configMap 檔案中的 key key: db.port # 或者, 也可以直接從一個檔案引用整個 configMap 檔案 envFrom: - configMapRef: name: cm-demo1 以下的 Kubernetes yaml 檔是什麼意思？ yaml 檔: apiVersion: v1kind: Podmetadata: name: testcm3-podspec: containers: - name: testcm3 image: busybox command: [ \"/bin/sh\", \"-c\", \"cat /etc/config/redis.conf\" ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: cm-demo2 Answer: # 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod 的名字 name: testcm3-pod# 該 Pod 的運行規格spec: # 定義容器規格 containers: # 容器名稱 - name: testcm3 # 鏡像名稱 image: busybox # 容器啟動後運行指令 command: [ \"/bin/sh\", \"-c\", \"cat /etc/config/redis.conf\" ] # mount 一個 volume volumeMounts: # 要 mount 的 volume 的名稱 - name: config-volume # 要將這個 volume mount 到哪個位置 mountPath: /etc/config # 定義 volume volumes: # volume 的名稱 - name: config-volume # volume 來自於 configMap configMap: # configMap 的名稱 name: cm-demo2 以下的 Kubernetes yaml 檔是什麼意思？ yaml 檔: apiVersion: v1kind: Podmetadata: name: testcm4-podspec: containers: - name: testcm4 image: busybox command: [ \"/bin/sh\",\"-c\",\"cat /etc/config/path/to/msyql.conf\" ] volumeMounts: - name: config-volume mountPath: /etc/config volumes: - name: config-volume configMap: name: cm-demo1 items: - key: mysql.conf path: path/to/msyql.conf Answer: # 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: testcm4-pod# 該 Pod 運行的規格spec: # 容器規格 containers: # 容器名稱 - name: testcm4 # 鏡像名稱 image: busybox # 容器啟動後運行的指令 command: [ \"/bin/sh\",\"-c\",\"cat /etc/config/path/to/msyql.conf\" ] # 定義掛載 volume volumeMounts: # 要掛載的 volume 的名稱 - name: config-volume # 要掛載到哪一個路徑 mountPath: /etc/config # 定義 volumes volumes: # volume 名稱 - name: config-volume # volume 來源為 configMap configMap: # configMap 的名稱 name: cm-demo1 # 定義要使用該 configMap 下的 key 以及 value 來為路徑 items: # 定義 configMap 內的 key - key: mysql.conf # 定義 value 在此 volume 中的路徑位置 path: path/to/msyql.conf 以下的 Kubernetes yaml 檔是什麼意思？ yaml 檔: apiversion: v1kind: podmetadata: name: testcm2-podspec: containers: - name: testcm2 image: busybox command: [ \"/bin/sh\", \"-c\", \"echo $(db_host) $(db_port)\" ] env: - name: db_host valuefrom: configmapkeyref: name: cm-demo3 key: db.host - name: db_port valuefrom: configmapkeyref: name: cm-demo3 key: db.port Answer: # 版本apiVersion: v1# 類型為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: testcm2-pod# 該 Pod 運行的規格spec: # 容器規格 containers: # 容器名稱 - name: testcm2 # 鏡像名稱 image: busybox # 容器啟動時運行的指令, 印出變數 command: [ \"/bin/sh\", \"-c\", \"echo $(DB_HOST) $(DB_PORT)\" ] # 定義變數 env: # 變數名稱為 DB_HOST - name: DB_HOST # 定義 value 來源 valueFrom: # 使用 configMap configMapKeyRef: # configMap 的名稱為 cm-demo3 name: cm-demo3 # 裡頭的 key 為 db.host key: db.host # 定義變數 DB_PORT - name: DB_PORT # value 來源 valueFrom: # 使用 configMap configMapKeyRef: # configMap 名稱為 cm-demo3 name: cm-demo3 # configMap 內的 key 為 db.port key: db.port Kubernetes 中, 如果我要建立一個 configMap, key/value 不經由檔案提供, 而是透過我的指令輸入提供, 那我可以使用哪一個 flag?kubectl create configMap configMapName --from-literal=key1=value --from-literal=key2=value Kubernetes 中, 當我建立 configMap 時, --from-literal 這個 flag 可以重複使用嗎？可以","link":"/zh-tw/kubernetes-tasks-configure-pod-container-configure-pod-configmap/"},{"title":"Kubernetes 學習筆記","text":"前言Kubernetes 的學習筆記, 內容未整理 環境OS: MacOSHypervisor: VMware Fusion 安裝官方文件 安裝虛擬機 確認 macOS 有無支援虛擬機 sysctl -a | grep -E --color 'machdep.cpu.features|VMX' 下載並安裝 安裝 minikubebrew cask install minikube 安裝 kubectl參考文件 這邊是直接安裝 gcloud sdk, 參考文件 設定 kubectl auto completion打開 zshrc vim ~/.zshrc 加入設定檔source &lt;(kubectl completion zsh) 啟動 minikube參考文件 啟動 minikube start --vm-driver=&lt;driver_name&gt;, 在這個例子中, 就是 minikube start --vm-driver=vmwarefusion kubectlconfig 顯示目前有的 contexts kubectl config get-contexts 取得目前套用的 contexts kubectl config current-contexts 刪除指定 contexts kubectl config delete-contexts 從 kubeconfig 刪除指定叢集 kubectl config delete-cluster 取得 kubeconfig 中定義的叢集 kubectl config get-clusters 從 kubeconfig 檔案中重新命名 context kubectl config rename-context createcreate -f FILENAME 建立元件 kubectl create component componentName secret genericgeneric NAME [--type=string] [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run] 建立一個 secret, 基於一個檔案, 資料夾, 或是指定的值 一個單一個 secret 可能會包含一個或多個 key/value 組 當基於檔案建立 secret, key 預設會是檔案名稱, value 為檔案內容 如果檔名是不合法的, 而你希望選擇你自己的, 可以自己指定 當基於資料夾建立 secret 時. 每個資料夾內合法的檔名都會成為一個 key, 被打包進 secret, 任何除了 regular file 之外的內容都會被忽略 (e.g. subdirectories, symlinks, devices, pipes, etc). configMap logs 取得 log kubectl logs componentName 取得即時 loglogs [-f] [-p] (POD | TYPE/NAME) [-c CONTAINER] kubectl logs -f componentName execexec (POD | TYPE/NAME) [-c CONTAINER] [flags] -- COMMAND [args...] 元件Pod Service Dashboard安裝kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml 開啟kubectl proxy 取得 tokenkubectl -n kube-system describe secret $(kubectl -n kube-system get secret | awk '/^deployment-controller-token-/&#123;print $1&#125;') | awk '$1==\"token:\"&#123;print $2&#125;' Kubectl CLI YAML YAML 檔案支援使用 Tab 縮進嗎？不支援 YAML 檔案中, 什麼是註解？# 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？ &#123; \"apiVersion\": \"v1\", \"kind\": \"pod\"&#125; ---apiVersion: v1kind: Pod 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？&#123; \"apiVersion\": \"v1\", \"kind\": \"Pod\", \"metadata\": &#123; \"name\": \"kube100-site\", \"labels\": &#123; \"app\": \"web\" &#125; &#125;&#125; ---apiVersion: v1kind: Podmetadata: name: kube100-site labels: app: web 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？&#123; \"args\": [\"Cat\", \"Dog\", \"Fish\"]&#125; args - Cat - Dog - Fish 以下的 YAML 格式, 若使用 JSON 呈現的話, 是如何？&#123; \"apiVersion\": \"v1\", \"kind\": \"Pod\", \"metadata\": &#123; \"name\": \"kube100-site\", \"labels\": &#123; \"app\": \"web\" &#125; &#125;, \"spec\": &#123; \"containers\": [&#123; \"name\": \"front-end\", \"image\": \"nginx\", \"ports\": [&#123; \"containerPort\": 80 &#125;] &#125;, &#123; \"name\": \"flaskapp-demo\", \"image\": \"jcdemo/flaskapp\", \"ports\": [&#123; \"containerPort\": 5000 &#125;] &#125;] &#125;&#125; ---apiVersion: v1kind: Podmetadata: name: kube100-site labels: app: webspec: containers: - name: front-end image: nginx ports: - containerPort: 80 - name: flaskapp-demo image: jcdemo/flaskapp ports: - containerPort: 5000 靜態 Pod Kubernetes 中, 靜態 Pod 可以通過 kubectl 管理嗎？不行 Kubernetes 中, 如何建立靜態 pod?在 node 的 /etc/kubernetes/manifests 資料夾中, 新增 YAML 檔 Kubernetes 中, 如何刪除靜態 pod?將該 YAML 檔案移除 Kubernetes 中, 靜態 pod 由誰管理?特定節點上的 kubelet RBAC Kubernetes 中, RBAC 的全寫是什麼？Role-based access control Kubernetes 中, 如何啟用 RBAC?在 apiserver yaml 檔案中添加 --authorization-mode=RBAC Kubernetes 中, Role 和 ClusterRole 的差別？Role 適用於單個命名空間, ClusterRole 適用於整個叢集 Kubernetes 中, 叢集中有哪三種 subject 資源？User Account, Group, Service Account Secret Kubernetes 中, Secret 有哪三種類型？ Opaque dockerconfigjson service-account-token Kubernetes 中, Opaque 類型的 secret 是什麼編碼格式？base64 Kubernetes 中, dockerconfigjson 類型的 secret 的用途是？用來儲存私人 docker registry 的認證資訊, 可使用在需要從私人雲端拉取鏡像的 Pod 或 Deployment Kubernetes 中, secret 的 value 必須先做過什麼處理？base 64 以下的 Kubernetes 設定檔, 代表什麼意思? 設定檔: apiVersion: v1kind: Secretmetadata: name: mysecrettype: Opaquedata: username: YWRtaW4= password: YWRtaW4zMjE= Answer: # API versionapiVersion: v1# 種類為 Secretkind: Secret# 此 secret 的 metadatametadata: # 此 secret 的 name name: mysecret# 此 secret 的類型為 Opaquetype: Opaque# 此 secret 內容data: # key 為 username, value 為 base64 編碼後的 string username: YWRtaW4= # key 為 password, value 為 base64 編碼後的 string password: YWRtaW4zMjE= 以下的 Kubernetes 設定檔是什麼意思？ 設定檔: apiVersion: v1kind: Podmetadata: name: secret1-podspec: containers: - name: secret1 image: busybox command: [ \"/bin/sh\", \"-c\", \"env\" ] env: - name: USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: PASSWORD valueFrom: secretKeyRef: name: mysecret key: password Answer: # API 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod 的 name name: secret1-pod# 運行此 Pod 的規格spec: # 容器規格 containers: # 容器名稱 - name: secret1 # 指定鏡像 image: busybox # 容器啟動後運行的指令 command: [ \"/bin/sh\", \"-c\", \"env\" ] # env, 以下開始定義 env: # env 名稱 - name: USERNAME # env value 的來源 valueFrom: # 使用 secret secretKeyRef: # secret 的 name name: mysecret # secret 的 key key: username # env 名稱 - name: PASSWORD # env value 的來源 valueFrom: # 使用 secret secretKeyRef: # secret 的 name name: mysecret # secret 的 key key: password Kubernetes 的 secret 通常有哪兩種使用方式? 環境變量 掛載 volume 以下的 Kubernetes 設定檔是什麼意思? 設定檔: apiVersion: v1kind: Podmetadata: name: secret2-podspec: containers: - name: secret2 image: busybox command: [\"/bin/sh\", \"-c\", \"ls /etc/secrets\"] volumeMounts: - name: secrets mountPath: /etc/secrets volumes: - name: secrets secret: secretName: mysecret Answer: # API 版本apiVersion: v1# 種類為 Podkind: Pod# Pod 的 metadatametadata: # Pod 的 name name: secret2-pod# 此 Pod 運行的規格spec: # 容器規格 containers: # 容器名稱 - name: secret2 # 指定鏡像 image: busybox # 容器啟動後運行的指令 command: [\"/bin/sh\", \"-c\", \"ls /etc/secrets\"] # 使用 volume, 定義如下: volumeMounts: # 使用名為 secrets 的 volume - name: secrets # 掛載路徑 mountPath: /etc/secrets # 定義 volume 資訊 volumes: # volume 的 name - name: secrets # 使用 secret 為 volume 的 value secret: # secret 的 name secretName: mysecret Kubernetes 中, 如何建立一個 dockerconfigjson 的 secret? kubectl create secret docker-registry myregistry --docker-server=DOCKER_SERVER --docker-username=DOCKER_USER --docker-password=DOCKER_PASSWORD --docker-email=DOCKER_EMAIL Kubernetes 中, 在建立一個 dockerconfigjson 的 secret 之後, 如何取得 output? kubectl get secret secretName -o=yaml/json Q&amp;A In Kubernetes, 如何列出 pods?kubectl get pods In Kubernetes, 如何暴露一個 deployment, 並建立一個外部的平衡負載?kubectl expose deployment nginx –port 80 –type LoadBalancer In Kubernetes, 如何列出 service？kubectl get services In Kubernetes, Pod 內可以裝幾個容器？一個或多個 In Kubernetes, 什麼元件提供了 namespace?Pods In Kubernetes, 一個 Pod 有幾個 IP?一個 In Kubernetes, 如何利用 YAML 檔案建立一個 podkubectl create -f configFile.yaml In Kubernetes, 如何取得物件的更多資訊？kubectl describe component componentName In Kubernetes, 假設我本地的 port 為 10080, Pod 的 port 為 80, 如何將兩個連接起來？kubectl port-forward podName 10080:80 In Kubernetes, 如何取得 logkubectl logs [-f] componentName In Kubernetes, 如何在容器內開一個 shell?kubectl exec podName -c containerName -it –stdin /bin/sh In Kubernetes, Service 的作用？提供端點給 Pods In Kubernetes, Service 如何選擇 Pod?利用 label In Kubernetes, Service 提供給 Pod 的存取等級, 有幾種？三種 In Kubernetes, Service 提供的存取等級中, ClusterIP 有誰可以看見？只能在叢集內部 In Kubernetes, Service 提供的存取等級中, NodePort 有誰可以看見？給予叢集內的節點一個外部可以存取的 IP In Kubernetes, Service 提供的存取等級中, LoadBalancer 有誰可以看見？從雲端提供者那增加一個平衡負載, 將外部流量經由 Service 導向節點 In Kubernetes, Volume 的生命週期？跟 Pod 共存亡 kubernetes 中, 同一個 pod 內的 container 可以啟用相同的 port 嗎？不可, 因為共享一個空間, 若 port 相同會衝突 kubernetes 中, replicaSet 是什麼？Pod 副本的抽象, 用以擴縮 Pod 參考資料 官方文件 Medium","link":"/zh-tw/kubernetesNote/"},{"title":"Laradock 學習筆記","text":"前言Laradock 的學習筆記, 紀錄所學技術, 本篇專案環境為 GCP instance, OS 為 ubuntu 18.04 安裝 安裝 git (若無) clone 專案, 可參考 官方文件 專案配置已經有一個專案參考 官方文件 還沒有專案參考 官方文件 多專案參考 官方文件 env 檔設定cp env-example .env MySQL 設定修改驗證方式為避免 MySQL 8 會有一些問題, 我們需要修改驗證方式vim laradock/mysql/my.cnf 貼上[mysqld]default_authentication_plugin= mysql_native_password 如修改無法生效, 需把 MySQL 的檔案刪除重建rm -rf ~/.laradock/data/mysql 設定編碼為 utf8my.cnf my.cnf (與 create.sql 擇一即可) vim laradock/mysql/my.cnf 加入以下設定 [client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]collation-server = utf8_unicode_ciinit-connect=&apos;SET NAMES utf8&apos;character-set-server = utf8 create.sql create.sql (與 my.cnf 擇一即可) vim laradock/mysql/docker-entrypoint-initdb.d/createdb.sql 加入以下設定 SET CHARACTER_SET_CLIENT=utf8mb4;SET CHARACTER_SET_RESULTS=utf8mb4;SET CHARACTER_SET_database= utf8;SET COLLATION_CONNECTION=utf8_unicode_ci; 建立 Database 複製範例檔 cp laradock/mysql/docker-entrypoint-initdb.d/createdb.sql.example laradock/mysql/docker-entrypoint-initdb.d/createdb.sql 批量新增資料庫uncomment 以下的設定檔, 並將 dev_db_1 … 換成自己需要的資料庫名字 #CREATE DATABASE IF NOT EXISTS `dev_db_1` COLLATE &apos;utf8_general_ci&apos; ;#GRANT ALL ON `dev_db_1`.* TO &apos;default&apos;@&apos;%&apos; ;#CREATE DATABASE IF NOT EXISTS `dev_db_2` COLLATE &apos;utf8_general_ci&apos; ;#GRANT ALL ON `dev_db_2`.* TO &apos;default&apos;@&apos;%&apos; ;#CREATE DATABASE IF NOT EXISTS `dev_db_3` COLLATE &apos;utf8_general_ci&apos; ;#GRANT ALL ON `dev_db_3`.* TO &apos;default&apos;@&apos;%&apos; ; 更改帳號密碼vim laradock/.env 搜尋 MySQL 並將 default user 的密碼以及 root 的密碼更改 專案設置.envvim yourProject/.env 更改 DB_HOST 為 mysql 更改 DB_DATABASE 為 上面步驟建立的資料庫 更改 DB_USERNAME 為 default (可自定義) 更改 DB_PASSWORD 修改 storage 權限sudo chmod -R 777 storage bootstrap/cache Supervisor當我們有使用 queue 或是 scheduler 的功能時, 會需要在背景起一個 process 用來監聽 queue job, 這時便需要使用程序管理器, 像是 supervisor 或 pm2Laradock 以內建 supervisor 可以使用, 相當方便。 用法 切換到 Laradock/php-worker 目錄中, 可依據需求修改 Dockerfile 以及 supervisord.conf, 若無需求不需修改 建立 config 檔, cp *.conf.example *.conf 啟動 docker-compose up -d php-worker 設置 NGINX如果有多專案的話, 需要特別設定 NGINX config 檔, 範例如下：// 重導 HTTP 到 HTTPSserver &#123; listen 80; listen [::]:80; server_name yourDomainName; return https://yourDomainName;&#125;server &#123; # For https listen 443 ssl; # listen [::]:443 ssl ipv6only=on; // 這個資料夾預設會跟 host 的 laradock/nginx/ssl/ 資料夾同步, 所以在外面放入正確的 SSL 憑證即可啟動 HTTPS ssl_certificate /etc/nginx/ssl/fullchain.pem; ssl_certificate_key /etc/nginx/ssl/privkey.pem; server_name yourDomainName; // 當使用多專案模式時, /var/www 會與 laradock 同層資料夾同步, 所以與 laradock 資料夾同層的專案都會被同步到這個資料夾內 root /var/www/yourProjectName/public; index index.php index.html index.htm; location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_pass php-upstream; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #fixes timeouts fastcgi_read_timeout 600; include fastcgi_params; &#125; location ~ /\\.ht &#123; deny all; &#125; location /.well-known/acme-challenge/ &#123; root /var/www/letsencrypt/; log_not_found off; &#125; // 此層資料夾會跟 laradock/logs/nginx 資料夾同步, 所以需要更名為你的專案名稱, 否則要是有多專案的話, 每個專案的 log 就重疊了 error_log /var/log/nginx/yourProjectName_error.log; access_log /var/log/nginx/yourProjectName_access.log;&#125; 啟動專案視需求啟動容器docker-compose up -d mysql nginx workspace redis php-worker 執行專案前設置docker-compose exec workspace php artisan key:generatedocker-compose exec workspace php artisan migratedocker-compose exec workspace php artisan db:seed Add Swap Space當部署的機器 Memory 較低時, 常常會把 RAM 耗光, 這時我們可以通過切割一部分沒用到的硬碟給 RAM 作業系統ubuntu 18.04 確認目前 swap 大小, 如果沒有輸出, 代表目前 server 沒有劃分這一塊, 可以加了 sudo swapon --show 建立 Swap 檔案 fallocate: 切割硬碟給檔案 -l: length, 檔案大小 /swapfile: 檔案sudo fallocate -l 1G /swapfile 設定正確的權限 sudo chmod 600 /swapfile 設定 Swap Space mkswap: 建立 swap 區域, 可以是 disk partition, 也可以是一個檔案sudo mkswap /swapfile 輸出： OutputSetting up swapspace version 1, size = 1024 MiB (1073737728 bytes)no label, UUID=f59595fb-754b-47ae-af6b-8dd6e98654d8 啟用 Swap Space sudo swapon /swapfile 確認 swap 是否已可被使用 sudo swapon --show 輸出 OutputNAME TYPE SIZE USED PRIO/swapfile file 1024M 0B -2 確認可用使用量 free -h 輸出 Output total used free shared buff/cache availableMem: 581M 275M 62M 103M 243M 110MSwap: 1.0G 0B 1.0G 使 Swap 永久有效 sudo vim /etc/fstab 增加以下代碼到檔案中 /swapfile swap swap defaults 0 0 設定 swappinessswappiness 為 0 時, kernel 將不會將 data 換到 disk 除非真的有必要, 值越高時 kernel 會盡可能地將 data 放到 swap, 讓 RAM 更空一點所以, 告訴系統盡量不要依賴 swap 可以讓系統運行的快一點 查看目前的 swappiness cat /proc/sys/vm/swappiness 輸出 Output60 將 swappiness 設定為 10 sudo sysctl vm.swappiness=10 輸出 Outputvm.swappiness = 10 持久化 swappiness sudo vim /etc/sysctl.conf 加入下面這一行 vm.swappiness=10 移除 Swap Space sudo swapoff -v /swapfile 從 /etc/fstab 移除上面加入的代碼 /swapfile swap swap defaults 0 0 最後, 刪除 swap 檔案 sudo rm /swapfile Jenkins設定簡易個人 side project 用的 CD 可參考 這篇文章 Shell Script 從容器連到欲部署的 Serverssh -i /var/jenkins_home/yourDeployKey root@yourServerIP \\\"cd /yourProjectLocation/ &amp;&amp; \\\\git reset @^ --hard &amp;&amp; git pull \\\\&amp;&amp; cd /laradockProjectLocation/ \\\\&amp;&amp; /usr/bin/docker-compose exec -T workspace php /var/www/yourProjectName/artisan migrate --force \\\\&amp;&amp; /usr/bin/docker-compose exec -T workspace composer install -d /var/www/yourProjectName \\\\&amp;&amp; /usr/bin/docker-compose exec -T workspace php /var/www/yourProjectName/artisan queue:restart \\\\&amp;&amp; /usr/bin/docker-compose exec -T workspace php /var/www/yourProjectName/artisan db:seed\" 非正規設置法以下是個人配置, 旨在利用 Let’s Encrypt Certbot 自動每三個月續簽 SSL 憑證, 並自動套用到每個專案所以會在 Host 處安裝 NGINX + CertBot, 因為自動續簽 SSL 憑證會用到 NGINX 80 port, 所以容器外的 NGINX 會監聽 80 port, 並把符合條件的請求都導向由容器直接監聽的 443 port, 所以會在容器內外都安裝 NGINX NGINX 配置因為 Let’s Encrypt 在自動續簽的過程中, CertBot 會 restart NGINX, 所以 NGINX 會分成容器內跟容器外 容器內 NGINX// 容器外的 NGINX 會將指定 server_name 的流量導向 443 port, 所以這邊不需監聽 80 portserver &#123; # For https listen 443 ssl; # listen [::]:443 ssl ipv6only=on; // 這個資料夾預設會跟 host 的 laradock/nginx/ssl/ 資料夾同步, 所以在外面放入正確的 SSL 憑證即可啟動 HTTPS ssl_certificate /etc/nginx/ssl/fullchain.pem; ssl_certificate_key /etc/nginx/ssl/privkey.pem; server_name yourDomainName; // 當使用多專案模式時, /var/www 會與 laradock 同層資料夾同步, 所以與 laradock 資料夾同層的專案都會被同步到這個資料夾內 root /var/www/yourProjectName/public; index index.php index.html index.htm; location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_pass php-upstream; fastcgi_index index.php; fastcgi_buffers 16 16k; fastcgi_buffer_size 32k; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #fixes timeouts fastcgi_read_timeout 600; include fastcgi_params; &#125; location ~ /\\.ht &#123; deny all; &#125; // 此層資料夾會跟 laradock/logs/nginx 資料夾同步, 所以需要更名為你的專案名稱, 否則要是有多專案的話, 每個專案的 log 就重疊了 error_log /var/log/nginx/yourProjectName_error.log; access_log /var/log/nginx/yourProjectName_access.log;&#125; 容器外 NGINX// 容器外相當簡單, 將來自 80 port 的請求導向 443 即可server &#123; listen 80; server_name *.yourDomainName; return https://$host$request_uri;&#125; Let’s Encrypt安裝可參考 取得 wildcard SSL 憑證 其他配置檔docker-compose.yaml取拿掉 80 port 對應, 因為 80 port 會由容器外的 NGINX 監聽ports: - \"$&#123;NGINX_HOST_HTTPS_PORT&#125;:443\" Laradock 的 .env// 因為 80 port 沒開, 所以參數也不需設定### NGINX #################################################NGINX_HOST_HTTP_PORT=NGINX_HOST_HTTPS_PORT=443NGINX_HOST_LOG_PATH=./logs/nginx/NGINX_SITES_PATH=./nginx/sites/NGINX_PHP_UPSTREAM_CONTAINER=php-fpmNGINX_PHP_UPSTREAM_PORT=9000NGINX_SSL_PATH=./nginx/ssl/","link":"/zh-tw/laradock/"},{"title":"Laravel - The Basics - Middleware","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 IntroductionLaravel 中, 哪個地方可以找到所有的 Middleware?app/Http/Middleware 資料夾 Defining MiddlewareLaravel 中, 如果我要使用 CLI 建立一個 middleware, 該怎麼做？php artisan make:middleware MiddewareName 請解釋以下的 Laravel Middleware example 邏輯 Example &lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckAge&#123; /** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */ public function handle($request, Closure $next) &#123; if ($request-&gt;age &lt;= 200) &#123; return redirect('home'); &#125; return $next($request); &#125;&#125; Answer: 如果 age 小於 200, 重導到 home route 去 如果 age 大於 200, 通過此 middleware 如果 request 沒有通過 middleware, 可以到達 route 嗎？不行 Before &amp; After Middleware以下的 Laravel Middleware example 中, Middleware 中的邏輯會先被執行, 還是 Controller 中的邏輯會先被執行？ Example: &lt;?phpnamespace App\\Http\\Middleware;use Closure;class AfterMiddleware&#123; public function handle($request, Closure $next) &#123; $response = $next($request); // Perform action return $response; &#125;&#125; Answer:Controller 中的邏輯會先被執行 以下的 Laravel Middleware example 中, Middleware 中的邏輯會先被執行, 還是 Controller 中的邏輯會先被執行？ Example: &lt;?phpnamespace App\\Http\\Middleware;use Closure;class BeforeMiddleware&#123; public function handle($request, Closure $next) &#123; // Perform action return $next($request); &#125;&#125; Answer:Middleware Laravel Middleware 中, 如果我要先執行 Controller 內的邏輯, 執行完後再執行 Middleware 邏輯, 那我可以怎麼做？&lt;?phpnamespace App\\Http\\Middleware;use Closure;class AfterMiddleware&#123; public function handle($request, Closure $next) &#123; $response = $next($request); // Perform action return $response; &#125;&#125; Registering MiddlewareGlobal Middleware如果我要定義一個 Global Middleware, 也就是每一個 HTTP request 都會通過它, 那我可以在 哪一個檔案 的 哪一個 property 中加入此 middleware? app/Http/Kernel.php $middleware Assigning Middleware To Routes如果我要定義一個 middleware, 並把它分配給特定的 route, 那我應該在 哪個檔案 中的 哪個 property 去定義？ App\\Http\\Kernel.php $routeMiddleware 以下的 Laravel middleware register example 主要用在什麼地方？ Example: &lt;?php// Within App\\Http\\Kernel Class...protected $routeMiddleware = [ 'auth' =&gt; \\App\\Http\\Middleware\\Authenticate::class, 'auth.basic' =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class, 'bindings' =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class, 'cache.headers' =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class, 'can' =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class, 'guest' =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class, 'signed' =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class, 'throttle' =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class, 'verified' =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,]; Answer:註冊用在特定 route 的 middleware Laravel middleware 中, 如果我已經註冊好 middleware, 在以下的 route example 中, 我該如何使用這個 middleware? 假設這個 middleware 叫做 auth Example: &lt;?phpRoute::get('admin/profile', function () &#123; //&#125;); Answer: &lt;?phpRoute::get('admin/profile', function () &#123; //&#125;)-&gt;middleware('auth'); Laravel middleware 中, 如果我已經註冊好 middleware, 在以下的 route example 中, 我該如何使用多個 middleware? 假設有兩個 middleware 叫做 first, 以及 second Example: &lt;?phpRoute::get('/', function () &#123; //&#125;); Answer: &lt;?phpRoute::get('/', function () &#123; //&#125;)-&gt;middleware('first', 'second'); 以下的 Laravel example 中, 如果我要給這個 route 套上一個 middleware, 以 class 的方式, 假設該 class 為 CheckAge, 我可以怎麼做？ Example: &lt;?phpuse App\\Http\\Middleware\\CheckAge;Route::get('admin/profile', function () &#123; //&#125;); Answer: &lt;?phpuse App\\Http\\Middleware\\CheckAge;Route::get('admin/profile', function () &#123; //&#125;)-&gt;middleware(CheckAge::class); Middleware GroupsLaravel 中, 如果我想要註冊一個 Middleware Group, 該 Group 中可以有多個 Middleware, 而我只需要 assign 這個 group 就等於一次性的附加內含的所有 middleware, 那我可以在 哪一個檔案 中的 哪一個 propery 註冊這個 Middleware Group? app\\Http\\Kernel.php $middlewareGroups Laravel 中, 當我使用 /routes/web.php 時, 默認會使用哪一個 Middleware Group?web Sorting MiddlewareLaravel 中, 如果我要定義 middleware 執行的順序, 我可以在 哪個 檔案定義？app/Http/Kernel.php Laravel 中, 如果我要定義 middleware 執行的順序, 我可以在 app/Http/Kernel.php 中的哪個 property 定義？$middlewarePriority Middleware Parameters以下的 Laravel 範例中, 如果我要帶入 $role 這個 parameter, 我可以從哪裡帶入？ Example: &lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckRole&#123; /** * Handle the incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next) &#123; if (! $request-&gt;user()-&gt;hasRole($role)) &#123; // Redirect... &#125; return $next($request); &#125;&#125; Answer: &lt;?phpnamespace App\\Http\\Middleware;use Closure;class CheckRole&#123; /** * Handle the incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @param string $role * @return mixed */ public function handle($request, Closure $next, $role) &#123; if (! $request-&gt;user()-&gt;hasRole($role)) &#123; // Redirect... &#125; return $next($request); &#125;&#125; 以下的 Laravel example, 如果我要帶入一個 middleware role 的 parameter 叫做 editor, 那我可以怎麼做？ Example: &lt;?phpRoute::put('post/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;middleware('role'); Answer: &lt;?phpRoute::put('post/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;middleware('role:editor'); 以下的 Laravel example, 如果我要帶入 2 個 middleware role 的 parameter 叫做 editor 以及 author, 那我可以怎麼做？ Example: &lt;?phpRoute::put('post/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;middleware('role'); Answer: &lt;?phpRoute::put('post/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;middleware('role:editor,author'); Laravel 中, 除了 $request 之外, 我可以帶入其他的 parameters 到 middleware 嗎？可 Terminable MiddlewareLaravel 中, 如果我想要在 Laravel return response 之後在 middleware 做一些事, 我可以利用 middleware 的哪個 method?terminate 以下的 Laravel middleware example 中, 如果我想要在 return response 之後再做一些事, 那我可以怎麼修改？ Example: &lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125;&#125; Answer: &lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate($request, $response) &#123; // Do something here &#125;&#125; 以下的 Laravel terminable example, 預設 terminate method 應該要接收什麼 arguments? Example: &lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate() &#123; // Store the session data... &#125;&#125; Answer: &lt;?phpnamespace Illuminate\\Session\\Middleware;use Closure;class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate($request, $response) &#123; // Store the session data... &#125;&#125; Laravel 中, 當我定義好一個 middleware 之後, 有哪幾種註冊方式？ global 註冊 route 註冊 middleware group 註冊 Laravel 中, 當我呼叫 middleware 的 terminate method, 預設會取得原本的那一個 middleware instance 還是一個新的 instance?新的 Laravel 中, 當我呼叫 middleware 的 terminate method, 預設會取得該 middleware 的一個新的 instance, 如果我要取得原本的那一個 instance, 我可以在 哪一個檔案 的 哪一個 method 做這件事？ AppServiceProvider.php register() 以下的 Laravel 程式碼的意思是？ Example: &lt;?phpuse App\\Http\\Middleware\\TerminableMiddleware;/** * Register any application services. * * @return void */public function register()&#123; $this-&gt;app-&gt;singleton(TerminableMiddleware::class);&#125; Answer:註冊 TerminableMiddleware, 所以每次觸發 terminate method 時都會取得同一個 middleware instance Laravel 中, 當我呼叫 middleware 的 terminate method, 預設會取得該 middleware 的一個新的 instance, 如果我要取得原本的那一個 instance, 在以下的 App/Service/Provider 中, 該怎麼做？ Example: &lt;?phpuse App\\Http\\Middleware\\TerminableMiddleware;/** * Register any application services. * * @return void */public function register()&#123; // What should I do here?&#125; Answer: &lt;?phpuse App\\Http\\Middleware\\TerminableMiddleware;/** * Register any application services. * * @return void */public function register()&#123; $this-&gt;app-&gt;singleton(TerminableMiddleware::class);&#125;","link":"/zh-tw/laravel-basics-middleware/"},{"title":"Laravel - The Basics - CSRF Protection","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 IntroductionCSRF 的全寫是？cross-site request forgery CSRF 是什麼？利用使用者的 token 或 cookie 送出不合法的請求, 藉此更改使用者在後端的資料或其他惡意的動作。 Laravel 中, 以下的 form example, 我該如何附加一個 CSRF token? Example: &lt;form method=\"POST\" action=\"/profile\"&gt; // &lt;/form&gt; Answer: &lt;form method=\"POST\" action=\"/profile\"&gt; @csrf ...&lt;/form&gt; Laravel 中, 哪一個 middleware 會去檢驗 form 裡頭的 CSRF token 是否正確？VerifyCsrfToken CSRF Token &amp; JavaScriptLaravel 中, 哪個檔案中有提供 Axios HTTP library, 可以自動的將 XSRF_TOKEN cookie 的值利用 X-XSRF-TOKEN header 發送？resources/js/bootstrap.js Excluding URLs From CSRF ProtectionLaravel 中, 如果我要將某些 routes 排除 CSRF 驗證, 除了不將這些 routes 放在 web API 下之外, 還可以在 哪一個 middleware 中的 哪一個 property 中新增 route 的 URIs？ VerifyCsrfToken $except Laravel 中, 如果我要將某些 routes 排除 CSRF 驗證, 新增到 VerifyCsrfMiddleware 中的 $except property 中的是什麼？要排除的 routes 的 URIs 以下的 Laravel example 是什麼意思？ Example: &lt;?phpnamespace App\\Http\\Middleware;use Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;class VerifyCsrfToken extends Middleware&#123; /** * The URIs that should be excluded from CSRF verification. * * @var array */ protected $except = [ 'stripe/*', 'http://example.com/foo/bar', 'http://example.com/foo/*', ];&#125; Answer:將要排除的 routes 的 URIs 加到 VerifyCsrfMiddleware 的 $except property 內 Laravel 中, 在 tests 中, CSRF middleware 還會運作嗎？不會 X-CSRF-TOKENLaravel VerifyCsrfToken middleware 除了會從 POST parameter 中檢查 CSRF token 之外, 還會從哪裡檢查？request 的 X-CSRF-TOKEN header Laravel 中, 我可以將 CSRF token 發到 HTML 的哪一個 tag?meta 以下的 Laravel 中的 HTML 程式碼的意思是？ Example: &lt;meta name=\"csrf-token\" content=\"&#123;&#123; csrf_token() &#125;&#125;\"&gt; Answer:將 csrf token 放到 meta 中 以下的 Laravel 中使用 AJAX 的程式碼的意思是？, Example: $.ajaxSetup(&#123; headers: &#123; 'X-CSRF-TOKEN': $('meta[name=\"csrf-token\"]').attr('content') &#125;&#125;); Answer:使用 AJAX 從 meta 中拿出 CSRF token X-XSRF-TokenLaravel 預設會將 CSRF token 存在 Response 的哪？XSRF_TOKEN cookie Laravel 中, 前端可以從哪一個 cookie 中來設定 X-XSRF-TOKEN？XSRF-TOKEN cookie 一些 JavaScript 框架, 像是 Angular 以及 Axios, 預設會取 哪個 cookie 中帶入同源請求的 哪個 header 中？ XSRF-TOKEN cookie X-XSRF-TOKEN header","link":"/zh-tw/laravel-the-basics-csrf-protection/"},{"title":"Laravel - The Basics - Controllers","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Basic ControllersDefining ControllersLaravel 中, 如果不 extend basic controller 的話, 是有什麼影響？無法使用一些方便的功能, 像是 middleware, validate, 以及 dispatch Controllers and NamespacesLaravel 中, 如果以下是我的 Controller 路徑, 那我該在 Route 中怎樣定義我的 Controller 位址？ 路徑:App\\Http\\Controllers\\Photos\\AdminController Answer:&lt;?phpRoute::get('foo', 'Photos\\AdminController@method'); Single Action ControllersLaravel 中, 如果我要從 CLI 建立一個 single action controller, 我可以怎麼做？php artisan make:controller ControllerName --invokable Laravel 中, 如果我要建立一個 single action controller, 那在這個 controller 中的 method 會是？__invoke() 下面的 Laravel example 中, 如果我要的是一個 single action controller, 我該怎麼修改？ Example: &lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\User;class ShowProfile extends Controller&#123; /** * Show the profile for the given user. * * @param int $id * @return View */ public function `what is the function name here?` &#123; return view('user.profile', ['user' =&gt; User::findOrFail($id)]); &#125;&#125; Answer: &lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\User;class ShowProfile extends Controller&#123; /** * Show the profile for the given user. * * @param int $id * @return View */ public function __invoke($id) &#123; return view('user.profile', ['user' =&gt; User::findOrFail($id)]); &#125;&#125; Laravel 中, 在 route 註冊 single action controller 時, 需要指定 method 嗎？不用 Controller MiddlewareLaravel 中, 如果我要在 Controller 中指定 middleware, 我可以在該 Controller 中的哪個 method 做這件事？__construct() 以下的 Laravel example 中, 如果我要讓 middleware log 只跑 index method, 我可以怎麼修改？ Example: &lt;?phpclass UserController extends Controller&#123; /** * Instantiate a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware('auth'); $this-&gt;middleware('log'); &#125;&#125; Answer: &lt;?phpclass UserController extends Controller&#123; /** * Instantiate a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware('auth'); $this-&gt;middleware('log')-&gt;only('index'); &#125;&#125; 以下的 Laravel 範例中, 如果我要讓 middleware subscribed 只略過 store method, 我可以怎樣修改？ Example: &lt;?phpclass UserController extends Controller&#123; /** * Instantiate a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware('auth'); $this-&gt;middleware('subscribed'); &#125;&#125; Answer: &lt;?phpclass UserController extends Controller&#123; /** * Instantiate a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware('auth'); $this-&gt;middleware('subscribed')-&gt;except('store'); &#125;&#125; Laravel 中, 除了在 route, global, 以及 group 中指派 middleware 之外, 我還可以在什麼地方指派？Controller 請解釋以下的 Laravel 程式碼 Example: &lt;?phpclass UserController extends Controller&#123; /** * Instantiate a new controller instance. * * @return void */ public function __construct() &#123; $this-&gt;middleware('auth'); $this-&gt;middleware('log')-&gt;only('index'); $this-&gt;middleware('subscribed')-&gt;except('store'); &#125;&#125; Answer: &lt;?phpclass UserController extends Controller&#123; /** * Instantiate a new controller instance. * * @return void */ public function __construct() &#123; // 指派 auth middleware 給這個 controller $this-&gt;middleware('auth'); // 指派 log middleware 給 index method $this-&gt;middleware('log')-&gt;only('index'); // 指派 subscribed middleware 給除了 store method 之外所有的 method $this-&gt;middleware('subscribed')-&gt;except('store'); &#125;&#125;###### **Laravel 中, 如果我要在 controller 中定義 (非指派) 一個 middleware, 那我可以怎麼做？**在 Controller 中```php&lt;?php$this-&gt;middleware(function ($request, $next) &#123; // ... return $next($request);&#125;); Resource ControllersLaravel 中, 如果我要使用 CLI 來建立一個 Resource Controller, 我可以怎麼做？php artisan make:controller ControllerName --resource Laravel 中, 如果我要定義一個 resourceful route 到一個 controller, 也就是說, 一個 route 可以處理多種 action, 包含 create 跟 edit, 那我可以使用哪一個 route 的 method?route::resource 以下的 Laravel 範例中, 如果我要把這些 resource route 簡略成一個, 我可以怎麼做？ Example: &lt;?phpRoute::resource('photos', 'PhotoController')Route::resource('posts', 'PostController') Answer: &lt;?phpRoute::resources([ 'photos' =&gt; 'PhotoController', 'posts' =&gt; 'PostController']); Specifying The Resource ModelLaravel 中, 當我使用 CLI 建立一個 resource controller 時, 如果我要指定各個 method 中自動 type hint 的 model, 那我可以怎麼做？php artisan make:controller ControllerName --resorce --nodel=ModelName Spoofing Form MethodsLaravel 中, 因為 HTML 表單不支援 PUT, PATCH 或 DELETE request, 在以下的範例中, 如果使用 Blade directive, 那我可以怎麼修改？ Example: &lt;form action=\"/foo/bar\" method=\"POST\"&gt; // Put something here&lt;/form&gt; Answer: &lt;form action=\"/foo/bar\" method=\"POST\"&gt; @method('PUT')&lt;/form&gt; Partial Resource Routes以下的 Laravel resource route, 如果我只要開放 index 以及 show method, 我可以怎麼做？ Example: &lt;?phpRoute::resource('photos', 'PhotoController'); Answer: &lt;?phpRoute::resource('photos', 'PhotoController')-&gt;only([ 'index', 'show']); 以下的 Laravel resource route, 如果我要限定不使用 create, store, update, 以及 destroy, 那我可以怎麼修改？ Example: &lt;?phpRoute::resource('photos', 'PhotoController'); Answer: &lt;?phpRoute::resource('photos', 'PhotoController')-&gt;except([ 'create', 'store', 'update', 'destroy']); API Resource RouteapiResource route 跟 resource route 的差別在於？apiResource route 不包含 create 以及 edit method 以下的 Laravel example 中, 如果我要一次性的註冊所有 apiResource route, 我可以怎麼修改？ Example: &lt;?phpRoute::apiResource('photos' =&gt; 'PhotoController');Route::apiResource('posts' =&gt; 'PostController'); Answer: &lt;?phpRoute::apiResources([ 'photos' =&gt; 'PhotoController', 'posts' =&gt; 'PostController']); Laravel 中, 如果我要使用 CLI 來建立 apiResource controller, 我可以怎麼做？php artisan make:controller ControllerName --api Nested ResourcesLaravel 中, 假設我有 photo 以及 comment model, 而我要定義一個 resource route, 可以讓我從 URLs 帶入 {photo} 以及 {comment}, 那我可以如何定義下面這個 route? Example: &lt;?phpRoute::resource('what should I define here?', 'PhotoCommentController'); Answer: &lt;?phpRoute::resource('photos.comments', 'PhotoCommentController'); 以下的 Laravel route 的 URI 會是什麼樣子？ Example &lt;?phpRoute::resource('photos.comments', 'PhotoCommentController'); Answer: /photos/&#123;photo&#125;/comments/&#123;comment&#125; Shallow NestingLaravel 中, 如果我要定義一個 resource route 具有以下的模式, 那我可以怎麼樣來定義我的 route? Example: Verb URI Action Route Name GET /photos/{photo}/comments index photos.comments.index GET /photos/{photo}/comments/create create photos.comments.create POST /photos/{photo}/comments store photos.comments.store GET /comments/{comment} show comments.show GET /comments/{comment}/edit edit comments.edit PUT/PATCH /comments/{comment} update comments.update DELETE /comments/{comment} destroy comments.destroy Answer:&lt;?phpRoute::resource('photos.comments', 'CommentController')-&gt;shallow(); Naming Resource RoutesLaravel 中, 如果我要自定義以下的 resource route 的 create 的 name, 我可以怎麼做？ Example: &lt;?phpRoute::resource('photos', 'PhotoController'); Answer: &lt;?phpRoute::resource('photos', 'PhotoController')-&gt;names([ 'create' =&gt; 'photos.build']); Naming Resource Route Parameters以下的 Laravel resource route 預設 URI 為 /users/{user}, 如果我要修改成 /users/{admin_user}, 那我可以怎麼做? Example: &lt;?phpRoute::resource('users', 'AdminUserController'); Answer: &lt;?phpRoute::resource('users', 'AdminUserController')-&gt;parameters([ 'users' =&gt; 'admin_user']); 以下的 Laravel resource route 的 URI 會是怎麼樣？ Example: &lt;?phpRoute::resource('users', 'AdminUserController')-&gt;parameters([ 'users' =&gt; 'admin_user']); Answer/users/{admin_user} Localizing Resource URIsLaravel 中, 當我使用 resource route, Laravel 會幫我建立各種 action 的 URIs, 比如說 Route::resource(&#39;photos&#39;, &#39;PhotoController&#39;) 會幫我建立 /photos/create 以及 /photos/{photo}/edit 的 URIs, 如果我想要自定義 action 的 verb, 像是 create 以及 edit, 那我可以在 哪個檔案中 的 哪一個 method 中做這件事？ AppServiceProvider boot Laravel 中, 當我使用 resource route, Laravel 會幫我建立各種 action 的 URIs, 比如說 Route::resource(&#39;photos&#39;, &#39;PhotoController&#39;) 會幫我建立 /photos/create 以及 /photos/{photo}/edit 的 URIs, 如果我想要自定義 action 的 verb, 像是 create 以及 edit, 那我可以在 AppServiceProvider 的 boot method 中使用 哪一個 class 的 哪一個 method ？ Route resourceVerbs 解釋以下的 Laravel example 的意思 Example: &lt;?phpuse Illuminate\\Support\\Facades\\Route;/** * Bootstrap any application services. * * @return void */public function boot()&#123; Route::resourceVerbs([ 'create' =&gt; 'crear', 'edit' =&gt; 'editar', ]);&#125; Answer: &lt;?phpuse Illuminate\\Support\\Facades\\Route;/** * Bootstrap any application services. * * @return void */public function boot()&#123; // 將 action verb create 改成 crear, edit 改成 editar Route::resourceVerbs([ 'create' =&gt; 'crear', 'edit' =&gt; 'editar', ]);&#125; Laravel 中, 當我使用 resource route, Laravel 會幫我建立各種 action 的 URIs, 比如說 Route::resource(&#39;photos&#39;, &#39;PhotoController&#39;) 會幫我建立 /photos/create 以及 /photos/{photo}/edit 的 URIs, 如果說我想要 global 的將 create 改成 crear, edit 改成 editar, 那我可以如何修改以下的 example? Example: &lt;?phpuse Illuminate\\Support\\Facades\\Route;/** * Bootstrap any application services. * * @return void */public function boot()&#123; // What should I put here?&#125; Answer: &lt;?phpuse Illuminate\\Support\\Facades\\Route;/** * Bootstrap any application services. * * @return void */public function boot()&#123; Route::resourceVerbs([ 'create' =&gt; 'crear', 'edit' =&gt; 'editar', ]);&#125; Supplementing Resource ControllersLaravel 中, 當我使用了 resource route, 但我同時也定義了其他的 route 給同一個 controller 除了 resource 以外的 action, 那這些額外定義的 route 應該置於 resource route 之前還是之後？之前 Laravel 中, 如果你發現你常常需要增加額外的 method 到一個 resource controller, 那你可能該怎麼做？增加新的 Controller 讓 controller 的功能比較單一 Dependency Injection and ControllersLaravel 中, 在 Controller 中可以使用哪兩種 dependency injection 方式? Constructor Injection Method Injection 以下的 Laravel example 當中, 如果我想要 inject UserRepository, 變數為 $user, 那我可以怎麼做？ Example: &lt;?phpnamespace App\\Http\\Controllers;use App\\Repositories\\UserRepository;class UserController extends Controller&#123; // What should I define here?&#125; Answer: &lt;?phpnamespace App\\Http\\Controllers;use App\\Repositories\\UserRepository;class UserController extends Controller&#123; /** * The user repository instance. */ protected $users; /** * Create a new controller instance. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125; 在以下的 Laravel example 中, 如果我想要 inject Request, 變數為 $request 到 store method 當中, 我可以怎麼修改？ Example: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Store a new user. * * @param Request $request * @return Response */ public function store(What should I put here?) &#123; $name = $request-&gt;name; // &#125;&#125; Answer: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) &#123; $name = $request-&gt;name; // &#125;&#125; Laravel 中, 假設我的 Route 帶入參數 {id} 如下, 而我的 Controller 定義如下, 現我欲在 Controller 中的 update method inject Request $request 以及 {id}, 那我該怎麼做？ Example route: &lt;?phpRoute::put('user/&#123;id&#125;', 'UserController@update'); Example controller: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Update the given user. * * @param Request $request * @param string $id * @return Response */ public function update(what should I put here?) &#123; // &#125;&#125; Answer: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Update the given user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) &#123; // &#125;&#125; Route CachingLaravel 中, closure based routes 可以被 cached 嗎？不行哦 Laravel 中, route cache 的優點是？可以大幅的縮小註冊 routes 的時間 Laravel 中, 如果我要用 CLI 來 cache route, 我可以怎麼做？php artisan route:cache Laravel 中, 在我使用了 route:cache 之後, 如果我又新增了一個 route, 那我該怎麼樣讓它生效？php artisan route:clearphp artisan route:cache","link":"/zh-tw/laravel-the-basics-controllers/"},{"title":"Kubernetes - Deployments","text":"概述Deployment 提供宣告式的方法來更新 Pods 以及 ReplicaSets透過 Deployment 描述希望的狀態, 然後 Deployment Controller 會將目前的狀態改變成希望的狀態, 你可以定義 Deployments 來建立一個新的 ReplicaSets, 或是移除已存在的 Deployments, 然後重新建一個。 建立一個 Deployment以下是 Deployment 的範例, 它建立了一個 ReplicaSet 來啟動三個 nginx Pods:apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-deployment labels: app: nginxspec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 這邊針對上面的範例做解說: 一個叫做 nginx-deployment 的 Deployment 被建立了, 可從 .metadata.name 這裡看到 這個 Deployment 建立了三個 replicated Pods, 可從 replicas 欄位得知 selector field 用於定義 Deployment 管理的 Pods 對象, 本範例中的對象為 template 中定義的 app: nginx template 欄位中又含有以下子欄位： 經由 labels 欄位, 我們給 Pods 貼上標籤 app: nginx 從 .template.spec 欄位, 可以看到 Pods 運行一個容器, nignx, 使用 nginx Docker Hub 鏡像, 版本 1.7.9 建立一個容器, 並透過 name 欄位來命名為 nginx 現在讓我們來建立一個 Deployment 吧： 使用以下指令建立一個 Deployment, 你可以給指定最後加上 --record, 它會將執行的指令寫入資源的 annotation 欄位中 kubernetes.io/change-cause, 這對之後的追蹤十分有用, 比如說, 可用來檢視每個 Deployment 版本執行的指令 kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml 執行 kubectl get deployments 來確認 Deployment 是不是已經建立了。 如果還在建立中, 輸出應如下： 輸出 NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 0/3 0 0 1s 如果是在叢集中檢視 Deployments, 會顯示以下欄位 NAME 列出在這個叢集中 Deployments 的名稱 DESIRED 列出宣告的 replicas 的數量, 建立 Deployment 時定義的 CURRENT 顯示目前共有幾個 replicas 在運行 UP-TO-DATE 顯示已被更新來達成期望狀態的 replicas 數量 AVAILABLE 顯示可用的 replicas 數量 AGE 顯示 replica 已運行的時間 replicas 數量的宣告值是根據 .spec.replicas 欄位 執行以下指令來檢視 Deployment rollout status 指令 kubectl rollout status deployment.v1.apps/nginx-deployment 預計輸出 Waiting for rollout to finish: 2 out of 3 new replicas have been updated...deployment.apps/nginx-deployment successfully rolled out 幾秒後, 在執行以下指令一次 指令 kubectl get deployments 預計輸出 NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 3/3 3 3 18s 可以看到 Deployment 已經建立了三個 replicas, 且所有的 replicas 都是最新狀態以及可用 檢視被 Deployment 建立的 ReplicaSet (rs) 執行以下指令 kubectl get rs 預計輸出 NAME DESIRED CURRENT READY AGEnginx-deployment-75675f5897 3 3 3 18s ReplicaSet 的格式為 [DEPLOYMENT-NAME]-[RANDOM-STRING], random string 為隨機產生, 且使用 pod-template-hash 為來源之一 檢視每個 Pod 自動產生的 labels 執行指令 kubectl get pods --show-labels 預計輸出 NAME READY STATUS RESTARTS AGE LABELSnginx-deployment-75675f5897-7ci7o 1/1 Running 0 18s app=nginx,pod-template-hash=3123191453nginx-deployment-75675f5897-kzszj 1/1 Running 0 18s app=nginx,pod-template-hash=3123191453nginx-deployment-75675f5897-qqcnn 1/1 Running 0 18s app=nginx,pod-template-hash=3123191453 已建立完成的 ReplicaSet 會確保有三個 nginx Pods 這邊要注意的是, 務必要正確的在 Deployment 中指定適當的 selector 以及 Pod template labels (在本範例中, app:nginx), 不要讓 labels 或 selectors 跟其他的 controllers 有重疊 (包含其他的 Deployments 以及 StatefulSets), Kubernetes 不會阻止這件事, 且如果上述情形發生的話, 可能會產生衝突以及一些預期外的行為 Pod-template-hash label注意: 不可改變這個 labelpod-template-hash label 由 Deployment controller 加到每一個它所建立的 ReplicaSet 當中。 Updating a Deployment注意: Deployment 的 rollout 唯有當 Deployment 的 Pod template (也就是 .spec.template) 變更了, 舉例來說, 像是 template 當中的 labels 或是容器鏡像更新了。其他的更新, 例如 Deployment 的擴縮, 不會觸發 rollout 遵循以下步驟來更新你的 Deployment: 將 nginx Pods 從鏡像版本 nginx:1.7.9 更新成 nginx:1.9.1 執行以下指令 kubectl --record deployment.apps/nginx-deployment set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 或是簡化版本的 kubectl set image deployment/nginx-deployment nginx=nginx:1.9.1 --record 輸出應如下： deployment.apps/nginx-deployment image updated 又或者, 你也可以使用 edit 指令, 到編輯器中將 .spac.template.spec.container[0].image 的版本從 nginx.1.7.9 變更為 nginx:1.9.1 kubectl edit deployment.v1.apps/nginx-deployment 輸出應如下： deployment.apps/nginx-deployment edited 檢視 rollout status 執行指令 kubectl rollout status deployment.v1.apps/nginx-deployment 或是簡化版 kubectll rollout status deployment nginx-deployment 輸出應如下: Waiting for rollout to finish: 2 out of 3 new replicas have been updated... 或 deployment.apps/nginx-deployment successfully rolled out 從更新後的 Deployment 取得更多細節： 檢視 rollout 成功的 Deployment 執行 kubectl get deployments 輸出 NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 3/3 3 3 36s 檢視 ReplicaSets 執行 kubectl get rs 輸出 NAME DESIRED CURRENT READY AGEnginx-deployment-1564180365 3 3 3 6snginx-deployment-2035384211 0 0 0 36s 下一次你想要更新這些 Pod 的話, 你只需要再次更新 Deployment 的 Pod template 就行了Deployment 確保更新過程中只會有一定數量的 Pods 是不可用的。預設, 最少要有 75% 的 Pod 要處於運行中, 最多 25% 的 Pod 可容許不可用Deployment 同時確保在升級過程中同時只有一定數量的 Pod 會被建立, 預設最多 Pod 的 125% 期望數量可被運行 (最多 25% 增加)舉例來說, 如果你仔細的檢視 rollout 的過程, 你會發現, 首先 Deployment 會先建立一個新的 Pod, 然後殺掉某個舊的 Pod, 然後建立一個新的。 它不會等到新的 Pod 都已經足夠了才殺掉舊的 Pod, 也不會等到舊的 Pod 已經被砍到一個足夠的數量才去建立新的 Pod, 它確保至少有兩個 Pods 可用, 而最多四個 Pods 可用 檢視 Deployment 的細節資訊: 執行 kubectl describe deployments 輸出 Name: nginx-deploymentNamespace: defaultCreationTimestamp: Thu, 30 Nov 2017 10:56:25 +0000Labels: app=nginxAnnotations: deployment.kubernetes.io/revision=2Selector: app=nginxReplicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template:Labels: app=nginx Containers: nginx: Image: nginx:1.9.1 Port: 80/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailableOldReplicaSets: &lt;none&gt;NewReplicaSet: nginx-deployment-1564180365 (3/3 replicas created)Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 2m deployment-controller Scaled up replica set nginx-deployment-2035384211 to 3 Normal ScalingReplicaSet 24s deployment-controller Scaled up replica set nginx-deployment-1564180365 to 1 Normal ScalingReplicaSet 22s deployment-controller Scaled down replica set nginx-deployment-2035384211 to 2 Normal ScalingReplicaSet 22s deployment-controller Scaled up replica set nginx-deployment-1564180365 to 2 Normal ScalingReplicaSet 19s deployment-controller Scaled down replica set nginx-deployment-2035384211 to 1 Normal ScalingReplicaSet 19s deployment-controller Scaled up replica set nginx-deployment-1564180365 to 3 Normal ScalingReplicaSet 14s deployment-controller Scaled down replica set nginx-deployment-2035384211 to 0 這邊可以看到, 一開始當你建立了 Deployment, 它建立了一個 ReplicaSet (nginx-deployment-2035384211), 然後直接擴增到 3 個 replicas, 而當你更新 Deployment, 它建立了一個新的 ReplicaSet (nginx-deployment-1564180365) 並且擴增到 1 個然後將舊的 ReplicaSet 縮為 2, 所以最少有 2 個 Pods 是可用的, 最多可以有 4 個 Pods 是啟動的。 之後, 遵循著相同的滾動升級策略, 它持續的擴縮, 最後, 你會有三個新的 replicas, 然後 0 個舊的 Replicas Rollover (aka multiple updates in-flight)每次 Deployment controller 觀察到有新的 Deployment 時, 一個新的 ReplicaSet 會被建立來提供期望數量的 Pods。 如果說 Deployment 被更新了, 那 label 有符合 .spec.selector 但 template 不符合 .spec.replicas 的已存在 ReplicaSet 會開始縮減數量。 最後, 新的 ReplicaSet 會擴增到符合 .spec.replicas 的數量, 然後所有舊的 ReplicaSets 都縮減為 0如果你在滾動升級途中更新一個 Deployment, Deployment 會建立一個新的 ReplicaSet 並開始擴容, 同時縮減原本擴容到一半的 ReplicaSet, 它會被加到舊的 ReplicaSets 清單, 並且開始縮減舉例來說, 假如你建立了一個 Deployment 來建立 5 個 nginx:1.7.9 replicas, 但是當只有 3 個 replicas 的 nginx:1.7.9 被建立完成時, 你將這個 Deployment 更新成 5 個 nginx:1.9.1 的 replicas。 在這個範例中, Deployment 會立即的開始砍掉這三個 nginx:1.7.9 的 Pods, 並開始建立 nginx:1.9.1 的 Pods。 他不會等到 5 個 nginx:1.7.9 的 replicas 都建好之後, 再改變狀態 Label selector 更新通常不建議修改 label selector, 且 selector 建議在一開始就規劃好。 不管怎樣, 如果你需要更新 label selector, 那請一定要很小心, 並且確保你已經掌握任何它可能會造成的影響。注意: 在 API 版本 apps/v1, Deployment 的 label selector 在建立之後就無法變更了。 Selector 的增加需要也更新 Deployment spec 中的 Pod template labels, 否則會回傳 validation error。 這個變更是不可覆蓋的, 這表示說, 新的 selector 不會去選擇舊的 selector 建立的 ReplicasSet 以及 Pods, 所以結果會是, 建立了新的 ReplicaSet, 然後所有舊的 ReplicaSets 都成了孤兒。 Selector 的更新改變了 selector key 的現存 value - 造成的結果跟增加 selector 相同 Selector 的刪除會從 Deployment selector 中移除已經存在的 key - 這不需要 Pod template labels 有任何改變。 已經存在的 ReplicaSets 也不會變成孤兒, 也不會有新的 ReplicaSets 會被建立。 但被移除的 label 還是存在於現存的 Pods 以及 ReplicaSets 之中。 回滾 Deployment有時, 你可能會想要回滾 Deployment; 例如說, 當一個 Deployment 並不穩定, 一直的 crash looping。 預設, 所有的 Deployment rollout 歷史都會被記錄下來, 所以任何時候你都可以回滾 (你可以修改版本歷史限制來改變這一個特性)Note: 當 Deployment 的 rollout 被觸發時, 會建立一個 Deployment revision。 這表示唯有當 Deployment 的 Pod template (.spec.template) 改變了, 例如你更新了 template 的 labels 或 container images, 這樣 revision 才會被建立。 其他更新, 像是擴容 Deployment 並不會建立 Deployment revision, 所以你可以無礙的手動或自動的擴縮 Deployment。 這表示說, 當你回滾到一個早些的版本, 只有 Deployment 的 Pod template 部分會被回滾。 假如你在更新 Deployment 時打錯字, 把 nginx:1.9.1 打成 nginx:1.91: 執行指令 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=true 輸出 deployment.apps/nginx-deployment image updated 這時 rollout 卡住了, 確認一下： 執行 kubectl rollout status deployment.v1.apps/nginx-deployment 輸出 Waiting for rollout to finish: 1 out of 3 new replicas have been updated... 按下 Ctrl-C 來停止 rollout status 輸出, 可以參考這裏, 有更多 rollout 卡住的資訊 可以看到舊的 replicas nginx-deployment-1564180365 跟 nginx-deployment-2035384211 的數量是 2, 然後新的 replicas (nginx-deployment-3066724191) 是 1 執行 kubectl get rs 輸出 NAME DESIRED CURRENT READY AGEnginx-deployment-1564180365 3 3 3 25snginx-deployment-2035384211 0 0 0 36snginx-deployment-3066724191 1 1 0 6s 從建立的 Pods 可以看到這個由新的 ReplicaSet 建立的 Pod 卡在 image pull loop 執行 kubectl get pods 輸出 NAME READY STATUS RESTARTS AGEnginx-deployment-1564180365-70iae 1/1 Running 0 25snginx-deployment-1564180365-jbqqo 1/1 Running 0 25snginx-deployment-1564180365-hysrc 1/1 Running 0 25snginx-deployment-3066724191-08mng 0/1 ImagePullBackOff 0 6s 注意: Deployment controller 自動停止了錯誤的 rollout, 並且停止擴容新的 ReplicaSet。 這取決於你定義的 rollingUpdate 的參數 (更準確的說, maxUnavailable), Kubernetes 的預設值為 25% 取得 Deployment 描述 執行 kubectl describe deployment 輸出 Name: nginx-deploymentNamespace: defaultCreationTimestamp: Tue, 15 Mar 2016 14:48:04 -0700Labels: app=nginxSelector: app=nginxReplicas: 3 desired | 1 updated | 4 total | 3 available | 1 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template: Labels: app=nginx Containers: nginx: Image: nginx:1.91 Port: 80/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True ReplicaSetUpdatedOldReplicaSets: nginx-deployment-1564180365 (3/3 replicas created)NewReplicaSet: nginx-deployment-3066724191 (1/1 replicas created)Events: FirstSeen LastSeen Count From SubObjectPath Type Reason Message --------- -------- ----- ---- ------------- -------- ------ ------- 1m 1m 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-2035384211 to 3 22s 22s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-1564180365 to 1 22s 22s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled down replica set nginx-deployment-2035384211 to 2 22s 22s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-1564180365 to 2 21s 21s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled down replica set nginx-deployment-2035384211 to 1 21s 21s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-1564180365 to 3 13s 13s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled down replica set nginx-deployment-2035384211 to 0 13s 13s 1 &#123;deployment-controller &#125; Normal ScalingReplicaSet Scaled up replica set nginx-deployment-3066724191 to 1 要解決這個問題, 你需要回滾到前一個穩定的 Deployment reversion 確認 Deployment 的 Rollout 歷史照著以下步驟來確認 rollout 歷史: 確認 Deployment reversion 執行 kubectl rollout history deployment.v1.apps/nginx-deployment 輸出 deployments &quot;nginx-deployment&quot;REVISION CHANGE-CAUSE1 kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=true2 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true3 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=true CHANGE-CAUSE 是當 revisions 建立時, 從 Deployment 的 annotation kubernetes.io/change-cause 複製到你的 revisions, 你也可以藉由以下方法指定 CHANGE-CAUSE 的 message: 輸入指令 kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause=\"image updated to 1.9.1\" 當我們在做資源變更時, 最後加入 --record 的 flag 手動編輯資源的 manifest 檔案, 就是 yaml 檔 若要檢視每個 revision 的細節資訊： 執行 kubectl rollout history deployment.v1.apps/nginx-deployment --revision=2 輸出 deployments &quot;nginx-deployment&quot; revision 2 Labels: app=nginx pod-template-hash=1159050644 Annotations: kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true Containers: nginx: Image: nginx:1.9.1 Port: 80/TCP QoS Tier: cpu: BestEffort memory: BestEffort Environment Variables: &lt;none&gt; No volumes. 版本回滾照著以下步驟將 Deployment 從目前的版本回滾到之前的版本, 之前的版本為版本2 取消當前版本並回滾到之前版本 執行 kubectl rollout undo deployment.v1.apps/nginx-deployment 輸出 deployment.apps/nginx-deployment 或使用 --to-revision 指定要回滾至的版本 kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision=2 輸出 deployment.apps/nginx-deployment 更多關於 rollout 的指令可以參考kubectl rolloutDeployment 目前已經回滾到之前的穩定版本, 所以你可以看到, Deployment 產生了一個 DeploymentRollback 的事件, 代表回滾到版本 2 要確定 rollback 有成功並且 Deployment 如預期般的正常運行: 執行 kubectl get deployment nginx-deployment 輸出 NAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 3/3 3 3 30m 取得 Deployment 的細節描述 執行 kubectl describe deployment nginx-deployment 輸出 Name: nginx-deploymentNamespace: defaultCreationTimestamp: Sun, 02 Sep 2018 18:17:55 -0500Labels: app=nginxAnnotations: deployment.kubernetes.io/revision=4 kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=trueSelector: app=nginxReplicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailableStrategyType: RollingUpdateMinReadySeconds: 0RollingUpdateStrategy: 25% max unavailable, 25% max surgePod Template: Labels: app=nginx Containers: nginx: Image: nginx:1.9.1 Port: 80/TCP Host Port: 0/TCP Environment: &lt;none&gt; Mounts: &lt;none&gt; Volumes: &lt;none&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailableOldReplicaSets: &lt;none&gt;NewReplicaSet: nginx-deployment-c4747d96c (3/3 replicas created)Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 12m deployment-controller Scaled up replica set nginx-deployment-75675f5897 to 3 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-c4747d96c to 1 Normal ScalingReplicaSet 11m deployment-controller Scaled down replica set nginx-deployment-75675f5897 to 2 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-c4747d96c to 2 Normal ScalingReplicaSet 11m deployment-controller Scaled down replica set nginx-deployment-75675f5897 to 1 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-c4747d96c to 3 Normal ScalingReplicaSet 11m deployment-controller Scaled down replica set nginx-deployment-75675f5897 to 0 Normal ScalingReplicaSet 11m deployment-controller Scaled up replica set nginx-deployment-595696685f to 1 Normal DeploymentRollback 15s deployment-controller Rolled back deployment &quot;nginx-deployment&quot; to revision 2 Normal ScalingReplicaSet 15s deployment-controller Scaled down replica set nginx-deployment-595696685f to 0 擴縮 Deployment使用以下指令擴縮 Deployment: 執行 kubectl scale deployment.v1.apps/nginx-deployment --replicas=10 輸出 deployment.apps/nginx-deployment scaled 假設 水平 Pod 自動擴縮 在你的叢集中是有打開的, 可以設定擴縮你的 Deployment 依據給予的 Pods 最大及最小數量, 以及 CPU 的使用率 執行 kubectl autoscale deployment.v1.apps/nginx-deployment --min=10 --max=15 --cpu-percent=80 輸出 deployment.apps/nginx-deployment scaled 比例擴縮滾動升級 Deployment 支援同時運行不同版本的應用。 當一個 Deployment 正處於 rollout 狀態 (在途中或暫停狀態), 此時你或者是自動調節器又發出一個擴縮請求, Deployment controller 會將額外增加的 replicas 成比例的分配到目前運作中的 ReplicaSets (有啟動 Pods 的 ReplicaSets) 以降低風險。 這樣的行為稱為比例擴縮 (proportional scaling), 例如說, 你正運行著有 10 個 replicas 的 Deployment, maxSurge=3, maxUnavailable=2 確保 Deployment 下的 10 個 replicas 都有在運行 執行 kubectl get deploy 輸出 NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEnginx-deployment 10 10 10 10 50s 將鏡像版本更新成無法被解析的版本 執行 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:sometag 輸出 deployment.apps/nginx-deployment image updated 這個鏡像的更新會啟動一個新的 rollout 以及 ReplicaSet nginx-deployment-1989198191, 但它會因為上面提到的 maxUnavailable 而被阻塞住 執行 kubectl get rs 輸出 NAME DESIRED CURRENT READY AGEnginx-deployment-1989198191 5 5 0 9snginx-deployment-618515232 8 8 8 1m 這時再將數量提升到 15 個 執行 kubectl scale deployment nginx-deployment --replicas=15 此時, Deployment controller 需要決定要把這新的 5 個 replicas 使用哪一個 replicaSet 來啟動。 如果你沒有使用比例擴縮的話, 所有 5 個都會使用新的 ReplicaSet。 使用比例擴縮, 你將額外的 replicas 散佈到所有的 ReplicaSets, 比較多的 replicas 會被分配給擁有比較多 replica 的 replicaSet, 而比較少的 replicas 會被分配給擁有比較少 replica 的 replicaSet, 而擁有 0 個 replica 的 replicaSet 將不會被分配任何 replica 執行以下指令確認目前狀態 kubectl get deploy 輸出 NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEnginx-deployment 15 18 7 8 7m 執行指令確認 rs 狀態 kubectl get rs 輸出 NAME DESIRED CURRENT READY AGEnginx-deployment-1989198191 7 7 0 7mnginx-deployment-618515232 11 11 11 7m 如果最後 rollout 恢復正常, replica 恢復健康的話, 所有的 replica 都會被移動到新的 ReplicaSet 暫停以及恢復一個 Deployment你可以在觸發一個或多個更新之前先暫停 Deployment, 然後再恢復。 這讓你可以進行多個更新, 並避免掉不必要的 rollout 比如說, 取得剛建立的 Deployment 資訊： 執行 kubectl get deploly 輸出 NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGEnginx 3 3 3 3 1m 取得 rollout 狀態 kubectl get rs 輸出 NAME DESIRED CURRENT READY AGEnginx-2142116321 3 3 3 1m 使用以下指令停止 執行 kubectl rollout pause deployment.v1.apps/nginx-deployment 輸出 deployment.apps/nginx-deployment paused 更新鏡像 執行 kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 輸出 deployment.apps/nginx-deployment image updated 可以看到 rollout 完全沒有開始 執行 kubectl rollout history deployment.v1.apps/nginx-deployment 輸出 deployments &quot;nginx&quot;REVISION CHANGE-CAUSE1 &lt;none&gt; 取得 rollout status 確保 Deployment 已經有成功更新 執行 kubectl get rs 輸出 NAME DESIRED CURRENT READY AGEnginx-2142116321 3 3 3 2m 你可以盡可能地建立你需要的更新, 例如說, 更新資源: 執行 kubectl set resources deployment.v1.apps/nginx-deployment -c=nginx --limits=cpu=200m,memory=512Mi 輸出 deployment.apps/nginx-deployment resource requirements updated 在暫停前的 Deployment 狀態將會保持運作, 只要 Deployment 是處於暫停的狀態, 那你所建立的更新都不會對目前狀態有任何影響。 最後, 恢復 Deployment 並且觀察新的 ReplicaSet 進行所有新的更新 執行 kubectl rollout resume deployment.v1.apps/nginx-deployment 輸出 deployment.apps/nginx-deployment resumed 觀察 rollout 的狀態直到結束 執行 kubectl get rs -w 輸出 NAME DESIRED CURRENT READY AGEnginx-2142116321 2 2 2 2mnginx-3926361531 2 2 0 6snginx-3926361531 2 2 1 18snginx-2142116321 1 2 2 2mnginx-2142116321 1 2 2 2mnginx-3926361531 3 2 1 18snginx-3926361531 3 2 1 18snginx-2142116321 1 1 1 2mnginx-3926361531 3 3 1 18snginx-3926361531 3 3 2 19snginx-2142116321 0 1 1 2mnginx-2142116321 0 1 1 2mnginx-2142116321 0 0 0 2mnginx-3926361531 3 3 3 20s 取得最新 rollout 狀態 執行 kubectl get rs 輸出 NAME DESIRED CURRENT READY AGEnginx-2142116321 0 0 0 2mnginx-3926361531 3 3 3 28s Deployment 狀態Deployment 的生命週期中有很多種狀態, progressing 當建立一個新的 ReplicaSet, 又或者是 complete 或 fail to progress 進行中的 Deployment當以下任務在進行中時, Kubernetes 會將 Deployment 標註為 progressing 當 Deployment 建立新的 ReplicaSet 當 Deployment 正在擴容 ReplicaSet 當 Deployment 正在縮減 ReplicaSet 有新的 Pod 可用, 至少 (就緒時間打 MinReadySeconds 定義) 你可以使用 kubectl rollout status 來監控 Deployment 狀態 完成 Deployment有以下特點時, Kubernetes 會將 Deployment 標註為 complete 所有此 Deployment 的 replicas 都已更新到指定的最新版本, 代表說任何要求的更新都已經完成。 所有與此 Deployment 相關的 replicas 都可用 此 Deployment 下沒有舊的 replicas 在運行中 若要確認 Deployment 狀態是否為 completed, 可使用 kubectl rollout status。 如果 rollout 成功完成, kubectl rollout status 回應一個值為 0 的 exit code執行kubectl rollout status deployment.v1.apps/nginx-deployment 輸出Waiting for rollout to finish: 2 of 3 updated replicas are available...deployment.apps/nginx-deployment successfully rolled out$ echo $?0 失敗的 Deployment以下原因可能造成 rollout 卡住： 資源配額不足 Readiness 探測結果失敗 拉取鏡像錯誤 權限不足 資源限制 應用 runtime 配置錯誤 偵測這個情況的一個方法就是在 Deployment 的 spec (.spec.progressDeadlineSeconds), 這是個時間, 表示 Deployment controller 會在 Deployment 卡住多久之後回報這個異常 使用 kubectl 指令來設定 progressDeadlineSeconds 讓 controller 會在卡住 10 分鐘之後回報異常 執行 kubectl patch deployment.v1.apps/nginx-deployment -p '&#123;\"spec\":&#123;\"progressDeadlineSeconds\":600&#125;&#125;' 輸出 deployment.apps/nginx-deployment patched 一旦超過設定的 deadline, Deployment controller 在 Deployment 的 .status.confitions 增加一個具有下面內容的 DeploymentCondition 屬性 Type=Progressing Status=False Reason=ProgressDeadlineExceeded 更多有關 [status conditions] 的資訊可以參考 Kubernetes API conventions 注意: Kubernetes 對異常的 Deployment 除了回報 Reason=ProgressDeadlineExceeded 之外, 不會有其他動作。 更高階層的調節器可以利用這個訊息做相對應的動作, 比方說, 將 Deployment 回滾到之前的版本 注意: 如果你暫停 Deployment, Kubernetes 就不會確認你指定的 deadline, 你可以放心的暫停以及恢復 rollout, 不用擔心會因此而觸發 deadline 有時你可能會遇到暫時性的 Deployment 錯誤, 可能是因為你設了過短的 timeout 或是其他被認為是短暫的。 例如說, 你沒有足夠的資源。 如果你 describe Deployment, 你會看到以下： 執行 kubectl describe deployment nignx-deployment 輸出 &lt;...&gt;Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True ReplicaSetUpdated ReplicaFailure True FailedCreate&lt;...&gt; 如果你執行 kubectl get deployment nginx-deployment -o yaml, Deployment status 如下：status: availableReplicas: 2 conditions: - lastTransitionTime: 2016-10-04T12:25:39Z lastUpdateTime: 2016-10-04T12:25:39Z message: Replica set &quot;nginx-deployment-4262182780&quot; is progressing. reason: ReplicaSetUpdated status: &quot;True&quot; type: Progressing - lastTransitionTime: 2016-10-04T12:25:42Z lastUpdateTime: 2016-10-04T12:25:42Z message: Deployment has minimum availability. reason: MinimumReplicasAvailable status: &quot;True&quot; type: Available - lastTransitionTime: 2016-10-04T12:25:39Z lastUpdateTime: 2016-10-04T12:25:39Z message: &apos;Error creating: pods &quot;nginx-deployment-4262182780-&quot; is forbidden: exceeded quota: object-counts, requested: pods=1, used: pods=3, limited: pods=2&apos; reason: FailedCreate status: &quot;True&quot; type: ReplicaFailure observedGeneration: 3 replicas: 2 unavailableReplicas: 2 最後, 一旦 Deployment progress deadline 超過, Kubernetes 會將 status 以及 reason 更新:Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing False ProgressDeadlineExceeded ReplicaFailure True FailedCreate 你可以藉由擴縮 Deployment 或是增加資源配額到你的命名空間來解決資源配額不足的問題。 只要你滿足了資源配額, Deployment controller 會自動完成 Deployment rollout, 你將會看到 Deployment 的 status 會更新為 Status=True 以及 Reason=NewReplicaSetAvailableConditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable Type=Available 配上 Status=True 表示你的 Deployment 已具有最小可用性。 最小可用性是由 Deployment strategy 的設定來決定。 Type=Progressing 配上 Status=true 表示你的 Deployment 正在 rollout 途中, 或者是 process 已完成, 且心 replicas 的最低需求已滿足 (詳細資料可以查看 condition 的 reason - 在我們的案例中, Reason=NewReplicaSetAvailable, 這代表這個 Deployment 已經完成)你可以使用 kubectl rollout status 確認 Deployment 是否有 process 失敗, 如果 Deployment 以及超出 procession deadline 的話, 會回傳一個值為非 0 的 exit code 執行 kubectl rollout status deployment.v1.apps/nginx-deployment 輸出 Waiting for rollout to finish: 2 out of 3 new replicas have been updated...error: deployment &quot;nginx&quot; exceeded its progress deadline$ echo $?1 在失敗的 Deployment 上的操作所有你可以在完成的 Deployment 上做的操作也可以使用在失敗的 Deployment 上。 你可以對它擴縮容, 回滾到之前的版本, 或是暫停, 如果你需要對這個 Deployment 的 Pod template 做多次的調整的話 Clean up Policy你可以在 Deployment 中的欄位 .spec.revisionHistoryLimit 指定你想要保留的舊的 ReplicaSets 的數量, 超出這個數量的會在背景被垃圾回收掉, 預設值為 10 注意: 如果你特別將這個欄位設為 0, 所有的 history 都會被清理掉, 因此你將會無法回滾你的 Deployment Canary Deployment如果你想要使用 Deployment 發佈 release 到不同的使用者群或伺服器群, 你可以建立多個 Deployment, 每個發佈都有各自的 Deployment, 更多有關金絲雀 (Canary) 部署的描述, 請參考managing resources 撰寫 Deployment Spec跟所有其他的 Kubernetes 配置檔一樣, Deployment 也需要 apiVersion, kind, 以及 metadata 欄位。 一些通用的資訊可以參考 應用部署, 設置容器, 以及 使用 kubectl 管理資源 文件Deployment 也需要 .spec 區塊 Pod Template.spec.template 以及 .spec.selector 是 .spec 中唯一要求的欄位.spec.template 為 Pod template。 它跟 Pod 有完全相同的配置, 唯一的不同處是它不需要 apiVersion 以及 kind, 以及它被包在另外一個一個物件內除了 Pod 中要求的欄位之外, 在 Deployment 中的 Pod template 必須指定合適的 labels 以及 restart policy。 不可與其他 controller 重疊 labels, 可參考 selector .spec.template.spec.restartPolicy 只被允許設為 Always, 這也是默認值 Replicas.spec.replicas 可填可不填, 用來指定想要啟動的 Pod 的數量, 預設為 1 Selector.spec.selector 是一個必要的欄位, 它指定了一個 label selector, 定義這個 Deployment 的目標 Pods .spec.selector 必須符合 .spec.template.metadata.labels, 否則將被 API 拒絕。 在 API 版本 apps/v1, .spec.selector 以及 .metadata.labels 預設並非 .spec.template.metadata.labels, 所以他們必須被明確的設定。 再者, .spec.selector 在 app/v1 中, 建立後就不可再更改 如果 Pods 的 template 跟 Deployment 的 .spec.template 不同, 又或者 Pods 的總數量超過了 .spec.replicas 定義的數量, Deployment 可能會將 label 符合該 Deployment selector 的 Pods 結束掉。 如果 Pods 的數量小於 Deployment 定義期望的數量, Deployment controller 會依照 .spec.template 開啟新的 Pods 注意: 不可重複建立 label 符合這個 selector 的 Pod, 或透過 Deployment 建立, 又或者透過其他的 controller, 像是 ReplicaSet 或 ReplicationController。 如果你這麼做了, 第一個 Deployment 依然會認為是她建立了這些其他的 Pods, 且 Kubernetes 也不會阻止你這麼做。 如果你有多個 controller, 彼此的 selector 都有重疊, 那這些 controller 將會互相打架而無法正確運作。 Strategy.spec.strategy 指定了更新 Pod 時採用的策略.spec.strategy.type 可以是 “Recreate” 或 “RollingUpdate”, 預設為 “RollingUpdate” Recreate Deployment當使用 .spec.strategy.type==Recreate 時, Kubernetes 會先將所有的 Pod 都殺掉, 在建立新的 Rolling Update Deployment上面有介紹過 RollingUpdate 的方式, 可參考 Rolling Date。 當 .spec.strategy.type==RollingUpdate 時, 你可以指定 maxUnavailable 以及 maxSurge 來控制滾動升級的步驟 Max Unavailable.spec.strategy.rollingUpdate.maxUnavailable 是一個選擇性的選項, 它指定了在更新的過程中, Pod 不可用的容許最大數量。 值可以是確切的數字 (像是 5), 或是比例 (像是 10%)。 如果使用比例的話, 會計算出絕對數字, 然後無條件去位。 spec.strategy.rollingUpdate.maxSurge 以及 .spec.strategy.rollingUpdate.maxUnavailable 不可同時設為 0, 後者預設為 25%比如說, 當我把值設為 30%, 那在滾動升級過程中舊的 ReplicaSet 最多可以縮容到期望可用 Pod 數量的 70%。 一旦新的 Pod 擴容了並且可用了, 舊的 ReplicaSet 才可以進一度的縮容, 確保在更新的過程中, Pods 的可用數量保持在 70% 的期望數量以上 Max Surge.spec.strategy.rollingUpdate.maxSurge 是一個選擇性的選項, 它指定了在更新的過程中, 可用 Pods 的容許最大數量。 值可以是確切的數字 (像是 5), 或是比例 (像是 10%)。 如果使用比例的話, 會計算出絕對數字, 然後在無條件進位。 spec.strategy.rollingUpdate.maxSurge 以及 .spec.strategy.rollingUpdate.maxUnavailable 不可同時設為 0, 後者預設為 25%比如說, 當我把值設為 30%, 那在滾動升級過程中舊的 ReplicaSet 最多可以擴容到期望可用 Pod 數量的 130%。 一旦舊的 Pod 被殺掉了, 新的 ReplicaSet 才可以進一度的擴容, 確保在更新的過程中, Pods 的可用數量保持在最多 130% 的期望數量 Progress Deadline Seconds.spec.progressDeadlineSeconds 是一個選擇性的欄位, 它指定了當 process 卡住的時候, Kubernetes 需要等待多久時間才回報failed progressing, 回報 Type=Progressing, Status=False, 以及 Reason=ProgressDeadlineExceeded 到 資源的 status.condition 中。 Deployment controller 會持續嘗試這個 Deployment。 在未來, 如果有實施自動回滾機制的話, Deployment controller 會自動地回滾 Deployment 當偵測到這樣的情況。如果有指定的話, 那這個欄位必須要大於 .spec.minReadySeconds 欄位 Min Ready Seconds.spec.minReadySeconds 是一個選擇性的配置欄位, 它指定了一個秒數, 一個新建立的 Pod, 被認定為可用, 並且沒有任何容器 crashing 的最低秒數。 默認為 0 (Pod 被建立就被認定是可用的), 更多關於 Pod 何時會被認為是 ready 的資訊, 可參考 Container Probes Rollback To.spec.rollbackTo 這個欄位已經在 API 版本 extensions/v1beta1 以及 apps/v1beta1 就被廢棄了, 並且在 apps/v1beta2 已經不再被支援。 取而代之的, kubectl rollout undo, 可參考 Rolling Back to a Previous Revision, 將被使用。 Revision History LimitDeployment 的 revision history 被儲存在它所控制的 ReplicaSet 中。.spec.revisionHistoryLimit 是一個可選配置項, 它指定了舊的 ReplicaSets 的保留數量, 所以之後可以回滾。 這些舊的 ReplicaSets 會消耗 etcd 中的資源, 以及會塞滿 kubectl get rs 的輸出。 Deployment 的不同版本的配置都被儲存在 ReplicaSets, 因此, 一旦舊的 ReplicaSet 被刪除了, 你將無法再回滾到該版本的 Deployment。 預設會保留 10 個舊的 ReplicaSet, 然而最佳的數量取決於新版 Deployment 的頻率以及穩定性更準確的說, 若將這個欄位設為 0, 代表所有舊的 ReplicaSets 都會被清理掉, 所以新版的 Deployment 將無法回退。 Paused.spec.paused 是一個可選配置選項, 其值為 boolean, 它表示了該 Deployment 是否是 paused 的狀態。 狀態是否為 paused 的唯一不同之處在於, 如果我對 PodTemplateSpec 的內容作修改, 那當狀態是 paused 時, 將不會觸發新的 rollout。 Deployment 預設狀態是 not paused Alternative to Deploymentskubectl rolling-updatekubectl rolling-update 可以使用類似的模式更新 Pods 以及 ReplicationControllers, 但還是建議使用 Deployment 的方式, 因為 Deployment 是宣告式的, 並且是 server side 的, 以及有額外的功能, 例如可以回滾到之前的版本。 Q&amp;A Kubernetes 中, kubectl rolling-update 與 Deployment 的方式, 在官方文件中比較推薦使用哪一種？Deployment Kubernetes 中, .spec.paused true 或 false 的唯一不同之處在於？ paused 時, 不會觸發 rollout not paused 時, 會觸發 rollout Kubernetes 中, Old replicaSets 的數量會消耗哪個元件的資源？etcd Kubernetes 中, 不同版本的 Deployment 實際上都儲存在哪裡？ReplicaSets Kubernetes 中, spec.progressDeadlineSeconds 務必要大於哪一個欄位？.spec.minReadySeconds Kubernetes 中, 當 spec.strategy.rollingUpdate.maxUnavailable 的值為 70% 時, 假如算出來的數字非整數, Kubernetes 會怎麼做？無條件去掉小數點成整數 Kubernetes 中, spec.strategy.rollingUpdate.maxUnavailable 與 spec.strategy.rollingUpdate.maxSurge 的值可以同時設為 0 嗎？不可 Kubernetes 中, spec.strategy.rollingUpdate.maxUnavailable 的值可以是哪兩種方式？ 絕對數字 比例 Kubernetes, 當我使用 .spec.strategy.type==Recreate 時, 會怎樣的更新 Pod?先把舊的全都殺掉, 再建立新的 Kubernetes 時, 更新 Pod 預設的 strategy 是？RollingUpdate Kubernetes Deployment 中, .spec.replicas 預設值為多少?1 Kubernetes Deployment 中, .spec.template.spec.restartPolicy 預設值為?Always Kubernetes Deployment 中, .spec.template.spec.restartPolicy 只可設為什麼?Always Kubernetes deployment 中, .spec 中唯一要求哪兩個欄位？ .spec.template .spec.selector Kubernetes 中, 如果我將 .spec.revisionHistoryLimit 的值設為 0, 會發生什麼事？所有 revision history 都會被回收掉, Deployment 會無法回滾 Kubernetes 中, .spec.revisionHistoryLimit 預設的值為多少？10 個 Kubernetes 中, 可使用哪一個欄位來設定要保留的舊的 revision 數量？.spec.revisionHistoryLimit Kubernetes 中, 當我在 progress 途中使用 pause, 會計算 deadline 的時間嗎？不會 Kubernetes 中, 當 ProgressDeadlineExceeded 被觸發, Deployment 除了回報狀況以外, 還會做什麼事情嗎？不會 Kubernetes 中, 如果 Deployment progress 卡住超過指定的 deadline, Deployment controller 會在 DeploymentCondition 屬性中增加什麼內容？ Type=Progressing Status=False Reason=ProgressDeadlineExceeded Kubernetes 中, 如果 Deployment progress 卡住超過指定的 deadline, Deployment controller 會在什麼地方增加一個 DeploymentCondition 屬性？.status.conditions Kubernetes 中, 哪一個屬性可以決定 process 卡住之後多久會回報異常？.spec.progressDeadlineSeconds Kubernetes 中, 如何使用 CLI 來設定資源限制 kubectl set resources deployment/deploymentName -c=nginx --limits=cpu=200m,memory=512Mi Kubernetes 中, 如何 resume 一個 deployment? kubectl rollout resume deployment/deploymentName Kubernetes 中, 如何 pause 一個 deployment? kubectl rollout pause deployment/deploymentName Kubernetes 中, 如果我 pause 一個 Deployment, 那它還會保持運作嗎？會哦, 只是會鎖住目前的版本而已 Kubernetes 中, 當我暫停一個 Deployment 時, 我可以回滾它嗎？不行哦 Kubernetes 中, pause 跟 resume 可以帶來什麼好處？有時要進行多個修正時, 可以避免不必要的 rollout Kubernetes 當中, 假如現在正 rollout 到一半, 這時有新的擴容需求被呼叫, 那如果我有使用 proportional scaling 的話, 新的 replica 會被加到新的 replicaSet 還是舊的 replicaSet?會照比例分配, 擁有多個 replica 的 replicaSet 會被分配多組, 反之亦然 Kubernetes 當中, 假如現在正 rollout 到一半, 這時有新的擴容需求被呼叫, 那如果我沒有使用 proportional scaling 的話, 新的 replica 會被加到新的 replicaSet 還是舊的 replicaSet?新的 以下的 Kubernetes CLI 的意思是？ CLI kubectl autoscale deployment.v1.apps/nginx-deployment --min=10 --max=15 --cpu-percent=80 Answer: 最少 10 個 pod 最多 15 個 pod 當 CPU 使用超過 80% 時, 多開一個 Pod Kubernetes 中, 假如我要指定自動擴縮 Deployment 的範圍以及 CPU 使用率, 我可以怎麼做？ kubectl autoscale deployment/deploymentName --min=10 --max=15 --cpu-percent=80 Kubernetes 中, 假如我現在要擴縮指定 Deployment 到 10 個 replica, 我可以怎麼做？ kubectl scale deployment/deploymentName --replicas=replicasNumber Kubernetes 中, 如果我要放棄目前的版本回滾到一個指定的版本, 我可以怎麼做？ kubectl rollout undo deployment/deploymentName --to-revision=revisionName Kubernetes 中, 如果我要放棄目前的版本回滾到前一個版本, 我可以怎麼做？ kubectl rollout undo deployment/deploymentName Kubernetes 中, 如果我要檢視指定 revision 的細節資訊, 我可以怎麼做？ kubectl rollout history deployment/deploymentName --revision=revisionName Kubernetes 中, 有哪三種方法可以指定 CHANGE-CAUSE message? 藉由 kubectl annotate 指令 變更資源時, 加入 --record flag 手動變更 Kubernetes 中, 當我回滾到之前的版本, 會否對 replica 的期望數量有影響？不會, rolling back 只會影響到 spec.template 中的內容 Kubernetes 中, Deployment revision 唯有當什麼情況之下才會被建立？當 spec.template 中的內容有變更時 Kubernetes 中, 自 apps/v1 的版本後, Deployment 的 label selector 在建立後可以再變更嗎？不行 Kubernetes 中, 在滾動升級的過程中, 如果新的 Deployment 還沒完成擴容我就更新了這個 Deployment, 那 Deployment controller 會等到原本的擴容任務完成之後再開始新的任務嗎？不會, 會立即縮減舊的, 擴容新的 Kubernetes 中, 當 Deployment 被更新了, 新的 ReplicaSet 會被建立來提供期望的 Pods 數量, 那 Kubernetes 是如何判斷舊的 ReplicaSet?label 符合 .spec.selector 但 .spec.template 不符合 Kubernetes 中, 在滾動升級的過程中, Deployment 建立新的 Pod 以及刪除舊的 Pod 的模式是？確保不可用以及可用的 Pod 都處於指定的範圍之內, 它不會等到新的 Pod 都建好才去砍舊的, 也不會等到舊的 Pod 都砍完才去建新的 Kubernetes 中, 預設最多幾 % 的期望 Pod 數量可以處於運行中？125% Kubernetes 中, 當實施滾動升級時, 預設最多可以有幾% 的 Pod 不可用？25% Kubernetes 中, 當實施滾動升級時, 預設至少會保持幾 % 的 Pods 運行？75% Kubernetes 中, 當 rollout 被觸發, Deployment 是透過建立一個新的什麼資源來建立新的 Pod?ReplicaSet Kubernetes 中, 如果我要利用 kubectl CLI 來更新指定鏡像的版本, 我可以使用哪一個指令？ kubectl set image deployment/deploymentName containerName=imageName:tagName --record Kubernetes 中, Deployment 的 rollout 唯有在什麼情況下會被觸發？當 .spec.template 的內容變了 Kubernetes 中, pod-template-hash 是由 hash 哪一個 field 得來的？PodTemplate Kubernetes 中, pod-template-hash 的用途是？確保一個 Deployment 建立的 ReplicaSet 不會重疊 Kubernetes 中, pod-template-hash 是由誰加到 ReplicaSet 上的？Deployment Controller Kubernetes 中, pod-template-hash 可以被變更嗎？不可 Kubernetes 中, 當我們在定義 labels 以及 selectors 時, 務必要注意什麼？ 否則會造成衝突以及預期外的行為不可讓 labels 或 selectors 在多個 controller 之間互相重疊 Kubernetes 中, 如果要檢視每個 pod 自動產生的 labels, 可以使用哪一個 kubectl 指令？ kubectl get pods --show-labels Kubernetes 中, ReplicaSet 的命名格式為？[DEPLOYMENT-NAME]-[RANDOM-STRING] Kubernetes 中, 如果要透過 CLI 取得 ReplicaSet, 可以使用哪一個 kubectl command? kubectl get rs Kubernetes 中, rs 是哪一個資源的縮寫？ReplicaSet Kubernetes 中, 要如何查看 rollout status? kubectl rollout status deployment deploymentName Kubernetes 中, 當我在建立資源時加上了 --record flag, 我要怎樣才可以看到運行的 command 的紀錄？ kubectl describe resource resourceName Kubernetes 中, 如果我想要之後使用 kubectl describe 時都可以看到該 resource 之前執行過什麼執行, 那我可以在建立該 resource 時加上哪一個 flag?--record Kubernetes 中, matchExpressions field 的 operator Lt 代表的意思是？該 label 的 value 需小於指定值 Kubernetes 中, matchExpressions field 的 operator Gt 代表的意思是？該 label 的 value 需大於指定值 Kubernetes 中, matchExpressions field 的 operator DoesNotExist 代表的意思是？該 label key 有存在的都算 Kubernetes 中, matchExpressions field 的 operator Exist 代表的意思是？該 label key 有存在的都算 Kubernetes 中, matchExpressions field 的 operator NotIn 代表的意思是？該 label 的 value 需不存在於指定的 array list 當中 Kubernetes 中, matchExpressions field 的 operator In 代表的意思是？該 label 的 value 需存在於指定的 array list 當中 Kubernetes 中, matchLabels field 代表？一對 key/value pair Kubernetes 中, matchExpressions field 有哪幾個 operator？ In NotIn Exists DoesNotExist Lt Gt","link":"/zh-tw/kubernetes-workloads-controllers-deployments/"},{"title":"<未完成> Laravel - The Basics - Requests","text":"前言學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Accessing The Request以下的 Laravel example 中, 如果我要藉由 dependency injection 取得目前的 HTTP request, 我可以怎麼做？ Example: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Store a new user. * * @param Request $request * @return Response */ public function store(What should I put here?) &#123; $name = $request-&gt;input('name'); // &#125;&#125; Answer: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Store a new user. * * @param Request $request * @return Response */ public function store(Request $request) &#123; $name = $request-&gt;input('name'); // &#125;&#125; Dependency Injection &amp; Route ParametersLaravel 中, 假設我的 Route 帶入參數 {id} 如下, 而我的 Controller 定義如下, 現我欲在 Controller 中的 update method inject Request $request 以及 {id}, 那我該怎麼做？ Example route: &lt;?phpRoute::put('user/&#123;id&#125;', 'UserController@update'); Example controller: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Update the given user. * * @param Request $request * @param string $id * @return Response */ public function update(what should I put here?) &#123; // &#125;&#125; Answer: &lt;?phpnamespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class UserController extends Controller&#123; /** * Update the given user. * * @param Request $request * @param string $id * @return Response */ public function update(Request $request, $id) &#123; // &#125;&#125; Accessing The Request Via Route Closures以下的 Laravel closure based route example 中, 如果我要從 closure 中取得 current HTTP Request, 我可以怎麼做？ Example: &lt;?phpuse Illuminate\\Http\\Request;Route::get('/', function (What should I put here?) &#123; //&#125;); Answer: &lt;?phpuse Illuminate\\Http\\Request;Route::get('/', function (What should I put here?) &#123; //&#125;); Requests Path &amp; MethodRetrieving The Request PathLaravel 中, 假設我的 request URL 是 http://domain.com/foo/bar, 如果我想要取得 foo/bar, 我可以使用 哪一個 class 的 哪一個 method? Request path Laravel 中, 假設我的 request URL 是 http://domain.com/foo/bar, 以下的 example code 會取得什麼樣的輸出？ Example: &lt;?php$uri = $request-&gt;path(); Answer:foo/bar Laravel 中, 如果我要確認 request path 是否是 admin 開頭的, 我可以使用 Request class 的 哪一個 method?is 以下的 Laravel example 中, 如果我要驗證 request path 是否是 admin 開頭的, 那我該怎麼修改？ Example &lt;?phpif (What should I put here?) &#123; //&#125; Answer: &lt;?phpif ($request-&gt;is('admin/*')) &#123; //&#125; Retrieving The Request URLLaravel 中, 如果我要取得以下整個 Request URL, 那我可以怎麼做？ URL:http://domain.com/foo/bar?appearance=handsome&amp;personality=humourous Example: &lt;?php$url = what should I put here?; Answer: &lt;?php$url = $request-&gt;fullurl(); Laravel 中, 如果我要取得以下 Request URL 中的紅字部分, 那我可以怎麼做？ URL:http://domain.com/foo/bar?appearance=handsome&amp;personality=humourous Example: &lt;?php$url = what should I put here?; Answer: &lt;?php$url = $request-&gt;url(); Retrieving The Request MethodLaravel 中, 如果我要取得一個 request 的 method, 我可以怎麼修改以下範例？ Example &lt;?php$method = what should I put here?&#125; Answer: &lt;?php$method = $request-&gt;method(); Laravel 中, 如果我要確認 request 的 method 是否為 post, 我可以怎麼修改以下範例？ Example: &lt;?phpif (what should I put here?) &#123; // Do something here&#125; Answer: &lt;?php$method = $request-&gt;method();if ($request-&gt;isMethod('post')) &#123; //&#125; PSR-7 RequestsLaravel 中, 如果我想要取得 PSR-7 request, 而不是 Laravel request, 我需要安裝哪兩個套件？composer require symfony/psr-http-message-bridgecomposer require nyholm/psr7 Laravel 中, 如果我已經安裝好必要的套件, 在以下的範例中, 我該如何取得 PSR-7 的 request Example: &lt;?phpuse Psr\\Http\\Message\\ServerRequestInterface;Route::get('/', function (waht should I put here? $request) &#123; //&#125;); Answer: &lt;?phpuse Psr\\Http\\Message\\ServerRequestInterface;Route::get('/', function (ServerRequestInterface $request) &#123; //&#125;); Laravel 中, 當我 return 一個 PSR7- request, Laravel 默認會把它轉成什麼？Laravel response instance Input Trimming &amp; NormalizationLaravel 中, 若不想預設 trim string input 以及 convert empty string into null 的 feature, 可以在 哪個檔案 的 哪個 property 中, 把 TrimString 跟 ConvertEmptyStringToNull middleware 拿掉？ App\\Http\\Kernel $middleware Retrieving InputRetrieving All Input DataLaravel 中, 如果我要從 $request 取得所有的 input data, 型別為 array, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$input = What should I put here? Answer: &lt;?php$input = $request-&gt;all() Retrieving An Input ValueLaravel 中, 如果我要從 request 的 input 取得欄位為 name 的值, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$name = $request-&gt; What should I put here? Answer: &lt;?php$name = $request-&gt;input('name'); Laravel 中, 如果我要從 request 的 input 取得欄位為 name 的值, 假如 name 不存在, 那就 回傳 Sally, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$name = $request-&gt; What should I put here? Answer: &lt;?php$name = $request-&gt;input('name', 'Sally'); Laravel 中, 如果我要從 request 的 products 取得欄位為 name 的值, products 為一個 array, 底下有多個 index, 每個 index 下都有 name 欄位, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$name = $request-&gt; What should I put here? Answer: &lt;?php$name = $request-&gt;input('products.*.name'); Laravel 中, 如果我要取得所有的 input data, 同 $request-&gt;all(), 那我可以怎麼做？ Example: &lt;?php$input = What should I put here? Answer: &lt;?php$input = $request-&gt;input() Retrieving Input From The Query StringLaravel 中, 如果我要從 request 的 query 取得欄位為 name 的值, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$name = $request-&gt; What should I put here? Answer: &lt;?php$name = $request-&gt;query('name'); Laravel 中, 如果我要從 request 的 query 取得欄位為 name 的值, 若 name 不存在, 則回傳 Helen, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$name = $request-&gt; What should I put here? Answer: &lt;?php$name = $request-&gt;query('name', 'Helen'); Laravel 中, 如果我要從 request 取得所有的 query key / value, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$name = $request-&gt; What should I put here? Answer: &lt;?php$name = $request-&gt;query(); Retrieving Input Via Dynamic PropertiesLaravel 中, 當我使用 Request 的 Dynamic Properties 時, Laravel 會先找 request payload 還是 route parameters?request payload Laravel 中, $request-&gt;name 以及 $request-&gt;input(‘name’) 的差異？ $request-&gt;name 會先尋找 request payload, 再尋找 route parameter 的 field $request-&gt;input(‘name’) 只會從 request payload 中尋找 Retrieving JSON Input ValuesLaravel 中, 如果說我的 Content-type 是 application/json, 而我要從 input 中取得 user object 裡頭的 name property, 在以下的範例中, 我可以怎麼做？ Example: &lt;?php$name = $request-&gt; What should I put here? Answer: &lt;?php$name = $request-&gt;input('user.name'); Retrieving Boolean Input ValuesLaravel 中, 如果我要取得 input 為 boolean 的 value, 假設 field 為 archived, 在以下的 Laravel 範例中, 我可以怎麼做? Example: &lt;?php$archived = $request-&gt;?? What should I put here? Answer: &lt;?php$archived = $request-&gt;boolean('archived'); Laravel 中, Request 的 boolean method 會將哪些值轉化成 true? 1 “1” true “true” “on” “yes” Retrieving A Portion Of The Input DataLaravel 中, 如果說我要從 Request $request 中取得部份的資料, 舉例來說, 只取得 username 以及 password, 在以下的範例中, 那我可以怎麼做？ Example: &lt;?php$input = $request-&gt; What should I put here? Answer: &lt;?php$input = $request-&gt;only(['username', 'password']); Laravel 中, 如果說我要從 Request $request 中取得部份的資料, 舉例來說, 取得除了 credit_card 之外的資料, 在以下的範例中, 那我可以怎麼做？ Example: &lt;?php$input = $request-&gt; What should I put here? Answer: &lt;?php$input = $request-&gt;except('credit_card'); Determining If An Input Value Is PresentLaravel 中, 如果我要確認在 $request 中, 指定的 key 是否 present, 例如說, field 為 name 並回傳 boolean, 在以下的範例中, 我可以怎麼做？ Example: &lt;?phpif ($request-&gt;?? what should I put here?) &#123; //&#125; Answer: &lt;?phpif ($request-&gt;has('name')) &#123; //&#125; Laravel 中, 如果我要確認在 $request 中, 指定多個 key 是否都 present, 並回傳 boolean, , 例如說, field 為 name, email 在以下的範例中, 我可以怎麼做？ Example: &lt;?phpif ($request-&gt;?? what should I put here?) &#123; //&#125; Answer: &lt;?phpif ($request-&gt;has(['name', 'email'])) &#123; //&#125; Laravel 中, 如果我要確認在 $request 中, 指定多個 key 是否其中有一個 present, 並回傳 boolean, , 例如說, field 為 name, email 在以下的範例中, 我可以怎麼做？ Example: &lt;?phpif ($request-&gt;?? what should I put here?) &#123; //&#125; Answer: &lt;?phpif ($request-&gt;hasAny(['name', 'email'])) &#123; //&#125; Laravel 中, 如果我要確認在 $request 中, 指定 key 是否存在, 且值不為 empty, 並回傳 boolean, , 例如說, field 為 name, 在以下的範例中, 我可以怎麼做？ Example: &lt;?phpif ($request-&gt;?? what should I put here?) &#123; //&#125; Answer: &lt;?phpif ($request-&gt;filled('name') &#123; //&#125; Laravel 中, 如果我要確認在 $request 中, 指定 key 不存在時回傳 true, 否則回傳 false, 例如說, field 為 name, 在以下的範例中, 我可以怎麼做？ Example: &lt;?phpif ($request-&gt;?? what should I put here?) &#123; //&#125; Answer: &lt;?phpif ($request-&gt;missing('name') &#123; //&#125; Old Input Cookies FilesRetrieving Uploaded Files Storing Uploaded Files Configuration Trusted Proxies","link":"/zh-tw/laravel-the-basics-requests/"},{"title":"Laravel - Eloquent ORM - API Resources","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Generating Resources 在 Laravel 中, 如何使用 CLI 產生一個 resource php artisan make:resource resourceName 在 Laravel 中, 如何使用 CLI 產生一個 resource collection Answer1: php artisan make:resource resourceName --collection Answer2: php artisan make:resource resourceNameCollection Concept Overview1 在 Laravel 中, Resource 中的 toArray method 的作用是？將 model 以及自定義的值轉成 array, 然後 Laravel 會自動將 array 轉成 JSON 輸出 在 Laravel 中, 如何在 controller 或 route 中回傳 resource?直接帶入 closure 回傳 &lt;?phpuse App\\Http\\Resources\\User as UserResource;use App\\User;Route::get('/user', function () &#123; return new UserResource(User::find(1));&#125;); 在 Laravel 中, 如何在 controller 或 route 中利用 resource 回傳 resource 的集合, 或是一個有分頁的 response? &lt;?php// 可使用 collection methoduse App\\Http\\Resources\\User as UserResource;use App\\User;Route::get('/user', function () &#123; return UserResource::collection(User::all());&#125;); 在 Laravel 的 resource 當中, 當我們使用 collection method 時, 是否可回傳額外的 meta data? 不可 在 Laravel 的 resource 當中, 如果我要回傳一個 collection, 或是有分頁的 response, 應該使用？使用 resource collection 在 Laravel 的 resource 當中, 如何設定 resource collection, 所以我們可以在 collection 或是分頁的 response 中帶入額外的 meta data? &lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class UserCollection extends ResourceCollection&#123; /** * Transform the resource collection into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */ public function toArray($request) &#123; return [ 'data' =&gt; $this-&gt;collection, 'links' =&gt; [ 'self' =&gt; 'link-value', ], ]; &#125;&#125; 在 Laravel 的 resource 當中, 如何在 route 或 controller 中利用 resource collection 回傳? &lt;?phpuse App\\Http\\Resources\\UserCollection;use App\\User;Route::get('/users', function () &#123; return new UserCollection(User::all());&#125;); In Laravel 的 Resource 當中, collection 預設會繼承 resource 嗎？ 會的 Customizing The Underlying Resource Class In Laravel 的 Resource 當中, 如何客制 collection 來套用不同的 resource?&lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class UserCollection extends ResourceCollection&#123; /** * The resource that this resource collects. * * @var string */ public $collects = 'App\\Http\\Resources\\Member';&#125; Writing Resources Laravel resource 中, 如何帶入 relation?&lt;?php/** * Transform the resource into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */public function toArray($request)&#123; return [ 'id' =&gt; $this-&gt;id, 'name' =&gt; $this-&gt;name, 'email' =&gt; $this-&gt;email, 'posts' =&gt; PostResource::collection($this-&gt;posts), 'created_at' =&gt; $this-&gt;created_at, 'updated_at' =&gt; $this-&gt;updated_at, ];&#125; Data Wrapping Laravel 的 resource 當中, 如何移除 data 這個 key? 在AppServiceProvider 加入以下的代碼 &lt;?phpnamespace App\\Providers;use Illuminate\\Http\\Resources\\Json\\Resource;use Illuminate\\Support\\ServiceProvider;class AppServiceProvider extends ServiceProvider&#123; /** * Register bindings in the container. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Resource::withoutWrapping(); &#125;&#125; Laravel resource collection 當中, 如果我想要巢狀下的 collection 也有 data key 包住, 該怎麼做？ 在 collection 下加入以下程式碼 &lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class CommentsCollection extends ResourceCollection&#123; /** * Transform the resource collection into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */ public function toArray($request) &#123; return ['data' =&gt; $this-&gt;collection]; &#125;&#125; Laravel collection 當中, 如果我有做分頁, 還能取消最外層包住的 data key 嗎？ 不行, 因為分頁預設就會有 links, meta 等 key Laravel resource 當中, 如果我要有條件地顯示 secret, 可以用哪一個 clause? &lt;?php/** * Transform the resource into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */public function toArray($request)&#123; return [ 'id' =&gt; $this-&gt;id, 'name' =&gt; $this-&gt;name, 'email' =&gt; $this-&gt;email, 'secret' =&gt; $this-&gt;when(Auth::user()-&gt;isAdmin(), 'secret-value'), 'created_at' =&gt; $this-&gt;created_at, 'updated_at' =&gt; $this-&gt;updated_at, ];&#125; Laravel 的 resource 當中, 如果我有兩個以上的值想要有條件的顯示, 要就一起顯示, 要就都不顯示, 可以怎麼做？ &lt;?phppublic function toArray($request)&#123; return [ 'id' =&gt; $this-&gt;id, 'name' =&gt; $this-&gt;name, 'email' =&gt; $this-&gt;email, $this-&gt;mergeWhen(Auth::user()-&gt;isAdmin(), [ 'first-secret' =&gt; 'value', 'second-secret' =&gt; 'value', ]), 'created_at' =&gt; $this-&gt;created_at, 'updated_at' =&gt; $this-&gt;updated_at, ];&#125; Laravel 的 collection 當中, 如果我想要有條件的顯示 relationship, 該 model 有載入 relation 的話我才顯示, 不載入不顯示, 該怎麼做？ &lt;?phppublic function toArray($request)&#123; return [ 'id' =&gt; $this-&gt;id, 'name' =&gt; $this-&gt;name, 'email' =&gt; $this-&gt;email, 'posts' =&gt; PostResource::collection($this-&gt;whenLoaded('posts')), 'created_at' =&gt; $this-&gt;created_at, 'updated_at' =&gt; $this-&gt;updated_at, ];&#125; Laravel collection 當中, 如果我要有條件的顯示中間表格, 有載入就顯示, 無載入就不顯示, 可以使用哪一個語法？ whenPivotLoaded, 第一個 argument 為中間表格, 第二個為 closure &lt;?phppublic function toArray($request)&#123; return [ 'id' =&gt; $this-&gt;id, 'name' =&gt; $this-&gt;name, 'expires_at' =&gt; $this-&gt;whenPivotLoaded('role_user', function () &#123; return $this-&gt;pivot-&gt;expires_at; &#125;), ];&#125; Laravel collection 當中, 如果我想要只在最外層的 meta 中加入客製化的值, 可以怎麼做？ &lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\ResourceCollection;class UserCollection extends ResourceCollection&#123; /** * Transform the resource collection into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */ public function toArray($request) &#123; return parent::toArray($request); &#125; /** * Get additional data that should be returned with the resource array. * * @param \\Illuminate\\Http\\Request $request * @return array */ public function with($request) &#123; return [ 'meta' =&gt; [ 'key' =&gt; 'value', ], ]; &#125;&#125; Laravel Collection 當中, 如果我要在 Resource response 中新增回傳的 meta data, 除了在 resource 檔案中新增之外, 還可以在哪裡新增？ &lt;?phpreturn (new UserCollection(User::all()-&gt;load('roles'))) -&gt;additional(['meta' =&gt; [ 'key' =&gt; 'value', ]]); Laravel Collection 當中, additional method 的 class是什麼？Resource Laravel Collection 當中, 如果說在 return reosurce 的同時, 我還需要客制 header 的話, 除了加 method 在 resource 裡頭之外, 我還可以怎麼做？ &lt;?phpuse App\\Http\\Resources\\User as UserResource;use App\\User;Route::get('/user', function () &#123; return (new UserResource(User::find(1))) -&gt;response() -&gt;header('X-Value', 'True');&#125;); Laravel Collection 當中, 如果說在 return reosurce 的同時, 我還需要客制 header 的話, 如果是加在 resource 裡的話, 可以用哪一個 method？ &lt;?phpnamespace App\\Http\\Resources;use Illuminate\\Http\\Resources\\Json\\JsonResource;class User extends JsonResource&#123; /** * Transform the resource into an array. * * @param \\Illuminate\\Http\\Request $request * @return array */ public function toArray($request) &#123; return [ 'id' =&gt; $this-&gt;id, ]; &#125; /** * Customize the outgoing response for the resource. * * @param \\Illuminate\\Http\\Request $request * @param \\Illuminate\\Http\\Response $response * @return void */ public function withResponse($request, $response) &#123; $response-&gt;header('X-Value', 'True'); &#125;&#125;","link":"/zh-tw/laravelEloquentORMAPIResources/"},{"title":"Laravel 學習筆記","text":"前言本篇為 Laravel 的學習筆記, 主要將看到的, 學到的技術轉換成 Q&amp;A 的方式以加速學習 Q&amp;A 安裝完新的 PHP Extension, 記得要做些什麼事？ 重啟 PHP, 重啟 Web server, 若使用 valet, 記得重啟 valet 在 Laravel 中, 如何確認 model 是否已經被改過？ model-&gt;isDirty()// true or false 在 Laravel 中, 如何得到與該 model 相關的 table 的名字? model-&gt;getTable()// string 在 Laravel 中, 下面的代碼是什麼意思？ 若 $request 中有指定的值, 如 ‘row’, 則使用該值, 若該值不存在, 則使用第二個自己指定的值 $row = request(&apos;row&apos;, (new Deposit)-&gt;getPerPage()); 在 Laravel 中, 下面的代碼是什麼意思？ foreach ( ['status', 'system_order_number', 'order_number', 'user_card_number', 'system_card_number'] as $availableFilterKey) &#123; $deposits-&gt;when($request-&gt;&#123;$availableFilterKey&#125;, function (Builder $builder, $filterValue) use ($availableFilterKey) &#123; $builder-&gt;where($availableFilterKey, $filterValue); &#125;);&#125; foreach 依序 loop array 當中的每一個 value $availableFilterKey 這裡表示 array 當中的 value when 表示條件句, [boolean, executeIfTrue, executeIfFalse] $builder 代表 $deposit $filterValue 代表 $request-&gt;availableFilterKey 參考文件 在 Laravel 中, 如何取得 query builder? $query = yourModel::query(); 在 Laravel 中, ** 代表什麼意思？ power operator, 如果是 2 ** 16, 代表 2 * 2 * .. 16 次 在 Laravel 中, 如何取得 parent 的 method? # 如果沒複寫, 直接呼叫即可$this-&gt;method# 如果有複寫, 也是直接呼叫$this-&gt;method# 除非你有複寫, 但你要沒複寫的版本parent::method參考出處： https://stackoverflow.com/questions/11237511/multiple-ways-of-calling-parent-method-in-php Laravel 的時區設定檔位置在？ config 中的 app.php 資料庫欄位 int, 什麼是 signed 跟 unsigned? signed 的數值範圍橫跨正負數, unsigned 只有正數, 且為 signed 的兩倍, 但最小的負數為 0可參考文件如下： https://dev.mysql.com/doc/refman/8.0/en/integer-types.html Laravel 當中, 以下的語法代表什麼意思？ 列出 $users query builder 的 query 語法以及帶入的變數 &lt;?phpdd($users-&gt;toSql(), $users-&gt;getBindings()); Laravel 當中, 以下代碼代表什麼意思？ 當 $user-&gt;address 可獲得時, 取值, 不可獲得時, 回傳 null &lt;?phpreturn optional($user-&gt;address)-&gt;street; Laravel 當中, 哪裡可以設定 queue 的名字？ config 資料夾中的 queue Laravel 當中, 以下的 agent_id 驗證 exists 邏輯代表什麼意思？ 在 users table 當中, 帶入的 agent_id 必須要跟 table 裡頭的 id 相同, 且 role_id 必須得跟 Role::AGENT 相同 &lt;?php request()-&gt;validate([ 'q' =&gt; 'nullable | string | max:255', 'row' =&gt; 'nullable | int | digits_between:1,3', 'agent_id' =&gt; 'nullable | exists:users,id,role_id,'.Role::AGENT, ]); 以下的 Laravel 程式碼代表什麼意思？ &lt;?php $users = User::merchant() -&gt;with('owner') -&gt;when($q, function ($query, $q) &#123; return $query-&gt;where('username', 'LIKE', '%'.$q.'%') -&gt;orWhere('name', 'LIKE', '%'.$q.'%') -&gt;orWhere('email', 'LIKE', '%'.$q.'%'); &#125;); public function scopeMerchant(Builder $query) &#123; return $query-&gt;where('role_id', Role::MERCHANT); &#125; 取得 User model 的 merchant scope, eager load owner relation, 當 $q 不為 null, 執行 closure, 接上 closure 中的 query builder, 在 username, name, email 三個欄位中模糊搜尋 $q 以下的 Laravel 程式碼的 appends 邏輯是什麼? 在 Laravel 的分頁模式中, 若未將全部來自於前端的 query 帶入, 那分頁的 url 將會缺少必要的 query, 等於只有第一頁會有 帶入的 query 結果 &lt;?phpreturn new UserCollection($users-&gt;paginate($row)-&gt;appends(request()-&gt;query-&gt;all())); 以下的 Laravel 程式碼中的 latest 代表什麼意思？ 以 id 排序 &lt;?php$transactions = auth()-&gt;user()-&gt;transactions() -&gt;whereBetween('created_at', [$startedAt, $endedAt]) -&gt;latest('id') -&gt;with('wallet') -&gt;paginate() -&gt;appends($request-&gt;query-&gt;all()); 以下的 Laravel 程式碼中的 fill 代表什麼意思？ 將值注入 userBankCard model, 帶入參數可以是一個 array &lt;?php$userBankCard-&gt;fill( $request-&gt;only( 'card_holder_name', 'card_number', 'bank_name' )); 以下的 Laravel 程式碼中, 為什麼要使用 collect function？ 這樣如果前端帶錯, 帶成 string 的話, 會先將 string 轉成 collection, 再轉成 array &lt;?php$userBankCards = UserBankCard::when(request()-&gt;q, function ($query, $q) &#123; $query-&gt;where(function ($query) use ($q) &#123; $query-&gt;where('card_holder_name', 'LIKE', '%' . $q . '%') -&gt;orWhere('card_number', 'LIKE', '%' . $q . '%') -&gt;orWhere('bank_name', 'LIKE', \"%$q%\"); &#125;);&#125;) -&gt;when(request()-&gt;status, function ($query, $status) &#123; $query-&gt;whereIn('status', collect($status)-&gt;toArray()); &#125;) -&gt;where('user_id', auth()-&gt;user()-&gt;getKey()) -&gt;paginate($row) -&gt;appends(request()-&gt;query-&gt;all()); 以下的 Laravel 程式碼代表什麼意思？ &lt;?php$depositStats = Deposit::whereBetween('created_at', [$startDate, $endDate])-&gt;where('status', Deposit::STATUS_SUCCESS)-&gt;groupBy('system_bank_card_type')-&gt;get([ 'system_bank_card_type', DB::raw('SUM(amount) AS total_amount, SUM(fee) AS total_fee, COUNT(id) AS total_count')])-&gt;keyBy('system_bank_card_type'); 取得 Deposit model, 以帶入日期過濾, 以 SUCCESS status 過濾, 以 system_bank_card_type 分類, 在取得四個值, 分別是 system_bank_card_type, total_amount, total_fee, total_count, 若照預設, 會是一個 collection 裡面有兩個 model, index 為 0 跟 1, 使用 keyBy 來將 0 跟 1 依照 system_bank_card_type 做區分, 所以會變成一個 collection 裡頭有兩個 model, 以 system_bank_card_type 做區分 以下的 Laravel 程式碼為什麼要使用 first？ 因為該 query 撈出來後, 只會有一筆 model, 如果是用 get 的話, 會是一個 collection 裡有一個 model, 所以直接使用 first() 即可 &lt;?php$withdrawStat = Withdraw::whereBetween('created_at', [$startDate, $endDate]) -&gt;where('status', Withdraw::STATUS_SUCCESS) -&gt;first([ DB::raw('SUM(amount) AS total_amount, SUM(fee) AS total_fee, COUNT(id) AS total_count')]); 以下的 Laravel 程式碼中, keyBy 的用途是？ 如果不使用 keyBy 的話, 正常來說一個 collection 裡頭有多個 model 會以默認 index, 0, 1, 2 …, keyBy 可以使用指定的 key 來給 model 分組, 在這個例子中, 就是以 model 下的 slug 欄位的值做分組 &lt;?php$wallets = auth()-&gt;user()-&gt;wallets()-&gt;get()-&gt;keyBy('slug'); 以下的 Laravel 程式碼中, data_get 的用途是？ $depositStats 結構像是這樣 $depositStats = [&#39;BankCard::TYPE_FEE&#39; =&gt; [&#39;total_count&#39;, &#39;total_amount&#39;, &#39;total_count&#39;, &#39;total_amount&#39;]], data_get 可以取得一個 collection 裡頭的巢狀 array 值 &lt;?phpreturn response()-&gt;json([ 'data' =&gt; [ 'fee_wallet_deposit_success_count' =&gt; data_get($depositStats, [BankCard::TYPE_FEE, 'total_count'], 0), 'fee_wallet_deposit_success_amount' =&gt; data_get($depositStats, [BankCard::TYPE_FEE, 'total_amount'], 0) / 100, // todo remove hard code 'withdraw_wallet_deposit_success_count' =&gt; data_get($depositStats, [BankCard::TYPE_WITHDRAW, 'total_count'], 0), 'withdraw_wallet_deposit_success_amount' =&gt; data_get($depositStats, [BankCard::TYPE_WITHDRAW, 'total_amount'], 0) / 100, // todo remove hard code 'withdraw_success_count' =&gt; $withdrawStat-&gt;total_count ?? 0, 'withdraw_success_amount' =&gt; ($withdrawStat-&gt;total_amount ?? 0) / 100, // todo remove hard code 'fee_wallet_balance' =&gt; data_get($wallets, [User::SLUG_FEE_WALLET, 'balanceFloat'], 0), 'withdraw_wallet_balance' =&gt; data_get($wallets, [User::SLUG_WITHDRAW_WALLET, 'balanceFloat'], 0), ],]); 以下的 Laravel 程式碼代表什麼意思？ 定義一個 unique rule, 並且將範圍限定在特定的 user 上, 代表不同 user 之間的訂單不需要 unique &lt;?php$orderNumberUniqueRule = Rule::unique($withdrawTable, 'order_number')-&gt;where(function ($query) use ($user) &#123; $query-&gt;where('user_id', $user-&gt;getKey());&#125;); 以下的 Laravel function 的作用是什麼？ 將 request 裡的參數除了 sign 之外都調出來 排列這些 key 首先使用 http_build_query function 針對剛剛的參數來產生一組 url 加密的字串, 然後將這字串與 user 的 secret_key 欄位內的值相串, 然後使用 url 解密這一整個字串, 最後再使用 md5 處理取得 hash 值, 我們比對這個值跟帶進來的 sign 有沒有一樣, 如果不一樣就是不合法 唯有知道 secret_key 的雙方可以對內容加解密, 而經由這樣的加解密驗證, 確保 request 的內容再傳送過程中未被串改&lt;?phpprivate function signValid(Request $request, $secretKey)&#123; $allParametersExceptSign = $request-&gt;except('sign'); ksort($allParametersExceptSign); return strcasecmp( md5(urldecode(http_build_query($allParametersExceptSign)) . $secretKey), $request-&gt;sign ) === 0;&#125; 以下的 Laravel function 的作用是什麼？ 宣告 lock-key 以及持有時間 嘗試取得 lock-key, 如果不可得, 持續嘗試五秒 用 transaction 實作, 若有任何錯誤皆返回 如果無法取得 lock-key, 返回錯誤 回返錯誤訊息 如果 lock-key 還被持有中, 釋放 lock-key&lt;?phppublic function lock(User $user, $action)&#123; $lock = Cache::lock($user-&gt;lockKey(), 10); try &#123; $lock-&gt;block(5); return DB::transaction($action); &#125; catch (LockTimeoutException $e) &#123; abort(Response::HTTP_CONFLICT, '请稍候再试'); &#125; finally &#123; optional($lock)-&gt;release(); &#125;&#125; 以下的 Laravel 程式碼中, balance 是扣款前還是扣款後？ 扣款前, 因為 $transaction 還沒被執行完畢 &lt;?php$transaction = $user-&gt;withdrawFloat($request-&gt;input('amount'), [ 'before_balance' =&gt; $user-&gt;balance,]); 以下的 Laravel 程式碼是什麼意思呢？ 將資料存入 mysql 中的 json 欄位 &lt;?php$deposit-&gt;user_bank_meta = (object)[ 'subbranch' =&gt; $userBankCard-&gt;subbranch, 'province' =&gt; $userBankCard-&gt;province, 'city' =&gt; $userBankCard-&gt;city,]; 下面的 Laravel 程式碼是什麼意思？ 將檔案存在 $deposit-&gt;getTable(), 檔名為 $deposit-&gt;system_order_number, 使用 filesystem.cloud, 可設為 s3 &lt;?php$request-&gt;file('payment_instrument') -&gt;storeAs($deposit-&gt;getTable(), $deposit-&gt;system_order_number, config('filesystems.cloud')); 下面的 Laravel Requests 代表什麼意思？ 使用 captcha 的 extension captcha_api 來驗證, 因為該驗證器一定需要一個 key, 如果在 validation 期間 key 為 null, 那直接就回 500 了, 所以這邊處理, 當沒有 captcha_key 時, 給一個隨機 10 碼, 這樣會驗不過(key 沒帶原本就應該驗不過), 但是不會 500 &lt;?phppublic function rules()&#123; return [ 'username' =&gt; 'required_without:email|string', 'email' =&gt; 'required_without:username|email', 'password' =&gt; 'required|string', 'captcha_key' =&gt; 'required', 'captcha' =&gt; 'required|captcha_api:'.($this-&gt;request-&gt;get('captcha_key') ?? Str::random(10)), ];&#125; 以下的 Laravel 程式碼中, where 內為什麼只有一個參數？Laravel 中, 如果 request 中的 parameter 與資料庫中的欄位名稱相同, 就可以直接用這種方式 query &lt;?php $bankCard = BankCard::where($request-&gt;only('card_number')) -&gt;withTrashed() -&gt;first() ?? BankCard::create($data); 以下的 Laravel 程式碼是什麼意思？ 1. query 出 card_number 的 model2. withTrashed 代表強制顯示已被 soft deleted 的 model3. 取出第一筆4. 若無結果, 則根據輸入的資料建立一張卡5. 更新 bankCard6. 若 bankCard 為 soft deleted, 解除它 &lt;?php$bankCard = BankCard::where($request-&gt;only('card_number'))-&gt;withTrashed()-&gt;first() ?? BankCard::create($data);$bankCard-&gt;update($data);$bankCard-&gt;restore(); 在 Laravel 中, 如何從一個 collection 當中取得其中一個 model, 而該 model 中的 price 欄位的值是在這個 collection 的所有 model 之中最小或最大的？ &lt;?php$min = $data-&gt;where('price', $data-&gt;min('price'))-&gt;first(); // ['name' =&gt; 'test', 'price' =&gt; 10]$max = $data-&gt;where('price', $data-&gt;max('price'))-&gt;first(); // ['name' =&gt; 'test', 'price' =&gt; 600] 在 Laravel 當中, 如何在一個 collection 裡放入多個 model ? &lt;?phpcollection-&gt;push($model) 以下的 Laravel 程式碼代表什麼意思? 1. 帶入欄位的名稱需與資料庫的欄位一樣2. 依序檢查指定的欄位3. 若 request 中的該欄位是有值的, 並且該值與目前資料庫中的值是不同的, 這代表有變更產生4. 將變更的 key 跟 value 放入空的 collection $updateAttributes 中5. 如果這個 collection 含有 card_number, 這代表卡號變更了, 將 balance =&gt; 0 放入 updateAttributes6. 如果 updateAttributes 是存在的, 開始更新 &lt;?php$updatedAttributes = collect();foreach (['card_holder_name', 'card_number', 'bank_name', 'type', 'auto_withdraw'] as $attribute) &#123; if (!is_null($request-&gt;$attribute) &amp;&amp; ($request-&gt;$attribute != $bankCard-&gt;$attribute)) &#123; $updatedAttributes = $updatedAttributes-&gt;merge([$attribute =&gt; $request-&gt;$attribute]); &#125;&#125;if ($updatedAttributes-&gt;has('card_number')) &#123; $updatedAttributes = $updatedAttributes-&gt;merge(['balance' =&gt; 0]);&#125;if ($updatedAttributes-&gt;isNotEmpty()) &#123;$bankCard-&gt;update($updatedAttributes-&gt;toArray());&#125; Laravel 中, Model 的命名通常是單數還是複數?單數 操作 Resource 的 controller, 通常命名的規則是？該 Resource 對應的名稱, 如 IpController Laravel 中的變數命名習慣是？camel case Laravel 中, blade view 的命名習慣是？會以資料夾做區分, 像是 withdraws/index.blade.php、withdraws/store.blade.php Laravel 中, 如何將 namespace, prefix, middleware 同時作用到複數的 route 上？ &lt;?phpRoute::group([ 'namespace' =&gt; 'Worker', 'prefix' =&gt; 'worker', 'middleware' =&gt; 'check.worker.token',], function () &#123; Route::apiResource('working-tasks', 'WorkingTaskController')-&gt;only('store', 'update'); Route::apiResource('bank-cards', 'BankCardController')-&gt;only('update'); Route::post('captcha-cracks', 'CrackCaptchaController');&#125;); Laravel 中, 可否在 route 的 group 內再使用一個 group?可以的 Laravel 中, 巢狀內的 route group 的屬性會不會繼承外層的 group 的屬性？會的, 像是 &lt;?phpRoute::group([ 'middleware' =&gt; ['auth']], function () &#123; Route::get('me', 'AuthController@me'); Route::group([ 'namespace' =&gt; 'Admin', 'prefix' =&gt; 'admin', 'middleware' =&gt; ['check.role.admin', 'check.source.admin'], ], function () &#123; Route::post('users/&#123;user&#125;/reset-password', 'UsersController@resetPassword'); Route::post('users/&#123;user&#125;/reset-withdraw-password', 'UsersController@resetWithdrawPassword'); Route::post('users/&#123;user&#125;/reset-google2fa-secret', 'UsersController@resetGoogle2faSecret'); Route::post('users/&#123;user&#125;/reset-secret-key', 'UsersController@resetSecretKey'); Route::put('users/&#123;user&#125;/delete-group', 'UsersController@deleteGroup') -&gt;where(['user' =&gt; '[0-9]+']); &#125;);&#125;); 以下的 Laravel 程式碼中, 邏輯是怎麼樣的？ 如果環境是在 production 的話, 檢查來源 ip, 來源 ip 可能有很多個, 取最後一個代表 client, 若不存在則拒絕存取 &lt;?php public function handle($request, Closure $next) &#123; if (app()-&gt;environment(['production'])) &#123; abort_if(!IPs::where('address', Arr::last($request-&gt;ips()))-&gt;exists(), Response::HTTP_UNAUTHORIZED, 'Invalid source'); &#125; return $next($request); &#125; 以下的兩段 Laravel 在 Resource 中的程式碼, 有什麼差異？ &lt;?php'withdraws' =&gt; $this-&gt;whenLoaded('withdraws', Withdraw::collection($this-&gt;withdraws)) &lt;?php'withdraws' =&gt; $this-&gt;whenLoaded('withdraws', function () &#123;return Withdraw::collection($this-&gt;withdraws);&#125;) 第一個 block 中, PHP 會先去執行作為參數帶入的 $this-&gt;withdraws, 再將結果帶入 whenLoaded, 這便符合了 whenLoaded 的 relation 載入條件, 所以依然會將當前 resource 下的 relation 顯示出來, 實際運行上因為會先執行 $this-&gt;withdraws, 因此也會造成效能上的浪費 第二個 block 中, closure 在被呼叫之前, PHP 並不會去解析它, 所以會先執行 whenLoaded 函式, 如果條件吻合, 才會執行 closure, 所以不會去執行 $this-&gt;withdraws, 自然 whenLoaded 的條件就不會吻合, resource 中也就不會多撈一層 Laravel 中, 如何將 array 存到資料庫？ 資料庫類別為 json &lt;?phpSchema::table('users', function (Blueprint $table) &#123; $table-&gt;json('iAmarray')-&gt;nullable();&#125;); 存到資料庫前, 先使用 json_encode &lt;?phpdata = json_encode($iAmArray); 在 model 加入 &lt;?phpprotected $casts = [ 'iAmArray' =&gt; 'array']; 當我在 Route 當中使用 apiResource 如下, 自動帶入 controller 的 model binding 的變數名稱為？sub_account &lt;?phpRoute::apiResource('sub-accounts', 'SubAccountsController')-&gt;only(['store', 'update']); Laravel 中, 當我使用 scheduler, 腳本內的 user 務必要使用?與 webserver 同一個 user 以下的 Laravel 程式碼的邏輯是？ 程式碼: &lt;?php $canSeeSecretKey = optional(auth()-&gt;user())-&gt;isAdmin() || $this-&gt;is(auth()-&gt;user()); Answer: 如果 auth()-&gt;user() 的身份是 admin 的話 如果被帶入 resource 中的 model 的身份跟 auth()-&gt;user() 是同一個人的話(代表本人) 以下的 Laravel 程式碼的作用是? code: &lt;?php public static function depositTypeText() &#123; return collect((new ReflectionClass(__CLASS__))-&gt;getConstants()) -&gt;filter( function ($value, $key) &#123; return Str::startsWith($key, 'TYPE_DEPOSIT'); &#125; ) -&gt;mapWithKeys( function ($value, $key) &#123; return [$value =&gt; $key]; &#125; ); &#125; Answer: RefectionClass: 取得指定 class 中的資料 __class__: 代表當前 class getConstants: 取得 constants filter: 只取符合條件的 key mapWithKeys: 取得符合條件的 key/value pair 以下的 Laravel 程式碼的邏輯是? Example: &lt;?php if ($endedAt-&gt;diffInDays($startedAt) &gt; 31) &#123; $request-&gt;merge( [ 'ended_at' =&gt; (clone $startedAt)-&gt;addDays(31)-&gt;format('Y-m-d H:i:s'), ] ); &#125; Answer:如果 $endedAt 跟 $startedAt 相差大於 31 天, 那就把範圍定在最多相差 31 天","link":"/zh-tw/laravel/"},{"title":"Laravel - Getting Started - Deployment","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Server ConfigurationNginxserver &#123; // 監聽 80 port listen 80; server_name example.com; // Document root root /example.com/public; // iframe 以及 object 保護 add_header X-Frame-Options \"SAMEORIGIN\"; // XSS 保護 add_header X-XSS-Protection \"1; mode=block\"; // 禁止 NGINX 自動判斷資源型態 add_header X-Content-Type-Options \"nosniff\"; index index.html index.htm index.php; charset utf-8; location / &#123; // 先尋找 $uri, 在尋找 $uri/, 都沒有的話, 重寫規則成 /index.php?query_string try_files $uri $uri/ /index.php?$query_string; &#125; // 若 location 等於 /favicon.ico, 不記入 log location = /favicon.ico &#123; access_log off; log_not_found off; &#125; // 若 location 等於 /robots.txt, 不記入 log location = /robots.txt &#123; access_log off; log_not_found off; &#125; // error 導向 /index.php, 由 Laravel 處理 error_page 404 /index.php; // 結尾是 .php 結尾的話, 進入此 location location ~ \\.php$ &#123; // 經由 unix 通道 pass, 若跨主機或使用容器的話, 需使用 TCP fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; fastcgi_index index.php; // fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name; include fastcgi_params; &#125; location ~ /\\.(?!well-known).* &#123; deny all; &#125;&#125; add_header X-Frame-Options 的用途是？ 用來指示文件是否能夠載入 &lt;frame&gt;, &lt;iframe&gt;, 以及 &lt;object&gt; add_header X-Frame-Options header 中, SAMEORIGIN 的用途是？ 唯有當符合同源政策下, 才能被嵌入到 frame 中 add_header X-Frame-Options header 中, DENY 的用途是？ 表示文件無論如何都不可被嵌入到 frame 中, 即使自家網站也不行 add_header X-Frame-Options header 中, ALLOW-FROM uri 的用途是？ 唯有列表許可的 URI 才能嵌入到 frame 中 add_header X-XSS-Protection “1; mode=block”, 1 代表什麼意思？ 0: 禁用 XSS 保護1: 啟用 XSS 保護1; mode=blck; 啟用 XSS 保護, 並在檢查到 XSS 攻擊時, 停止渲染頁面 add_header X-Content-Type-Options “nosniff”; 的用途？ 網路上的資源有各種類型, 通常瀏覽器會根據 header 的 Content-Type 來分辨它們的類型。如：&quot;text/html&quot; 代表 html 文檔, &quot;image/png&quot; 是 PNG 圖片, &quot;text/css&quot; 是 CSS 樣式文檔。然而, 有些資源的 Content-Type 是錯的或者未定義。這時, 某些瀏覽器會啟用 MIME-sniffing 來猜測該資源的類型, 解析內容並執行。例如, 我們即使給一個 html 文檔指定 Content-Type 為 &quot;text/plain&quot;, 在 IE8 中這個文檔依然會被當做 html 來解析。利用瀏覽器的這個特性, 攻擊者甚至可以讓原本應該解析為圖片的請求被解析為 JavaScript 。通過下面這個響應頭可以禁用瀏覽器的類型猜測行為： OptimizationAutoloader Optimization 部署 Production 環境時, 如何優化 Composer 的 class autoloader map?composer install --optimize-autoloader --no-dev Optimizing Configuration Loading 部署 Laravel 到 production 時, 如何優化 cache? php artisan config:cache 當執行 php artisan config:cache, .env 檔會失效, 那該如何在程式碼中使用 .env 呢？ 可以寫在 config 裡 Optimizing Route Loading 當部署 Laravel 到 production 時, 該怎麼優化 route?php artisan route:cache","link":"/zh-tw/laravelGettingStartedDeployment/"},{"title":"Laravel - Getting Started - Configuration","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Environment Configuration 如果使用 Composer 安裝, 專案內會有 .env 檔案嗎？ 會哦, 會自動被 cp 一份 當執行 PHPUnit 時, 如何替換掉 .env？ 建立 .env.testing Environment Variable Types 在 Laravel .env 檔中, 如果 value 是含有空白的字串, 該怎麼做？&lt;?phpAPP_NAME=\"My Application\" Determining The Current Environment Laravel 中, 如果我想要依據目前的環境 (production, develop) 來做相對應的事的話, 可以怎麼做？&lt;?phpif (App::environment('local')) &#123; // The environment is local&#125;if (App::environment(['local', 'staging'])) &#123; // The environment is either local OR staging...&#125; Hiding Environment Variables From Debug Pages 當 Laravel 的環境變數 APP_DEBUG 為 true 時, 默認會輸出所有的環境變數以及內容, 假如我有一些變數不想顯示, 我可以怎麼做？&lt;?php// 修改 config/app.php 檔案中的 debug_blacklistreturn [ // ... 'debug_blacklist' =&gt; [ '_ENV' =&gt; [ 'APP_KEY', 'DB_PASSWORD', ], '_SERVER' =&gt; [ 'APP_KEY', 'DB_PASSWORD', ], '_POST' =&gt; [ 'password', ], ],]; Accessing Configuration Values 在 Laravel 中, 若要取得 config 的值, 可以怎麼做？ &lt;?php$value = config('app.timezone'); 在 Laravel 中, 若要在程式碼中設定 config 的值, 可以怎麼做？ &lt;?phpconfig(['app.timezone' =&gt; 'America/Chicago']); Configuration Caching php artisan config:cache 做了什麼事？ 將所有的 config 檔案 cache 成一份檔案, 以加速運行 php artisan config:cache 建議在 production 還是 develop 運行？ production 運行 php artisan config:cache 時, 會否讀 .env 檔？ 不會哦 所有 Laravel 的設定檔都放在哪裡？ config 資料夾底下 Maintenance Mode 在 Laravel 中, 如果要啟動維護模式, 可以怎麼做？ php artisan down 在 Laravel 中, 如果要啟動維護模式, 並且客制 message 以及 retry 可以怎麼做？ php artisan down --message=\"Upgrading Database\" --retry=60 在 Laravel 中, 以下的 –retry 代表什麼意思？ php artisan down --message=\"Upgrading Database\" --retry=60 會設定一個 Retry-After HTTP header, 目前大概只有 Google Bot 會特別去偵測, 在你指定的 downtime 時間不會去爬你的網站 在 Laravel 中, 如果在維護模式中, 我僅僅想對指定的 IP 開放, 我可以怎麼做？ php artisan down --allow=127.0.0.1 --allow=192.168.0.0/16 在 Laravel 維護模式中, queue job 還會被處理嗎？不會哦","link":"/zh-tw/laravelGettingStartedConfiguration/"},{"title":"利用 Let's Encrypt 來自動簽署並更新 SSL 憑證 (wildcard)","text":"前言本篇主要分享，如何利用 Let&#39;s Encrypt 的 cert bot 來自動簽署以及更新 SSL 憑證 (wildcard)什麼是 wildcard? 比方說你的域名是 example.com, 那一個 wildcard 的憑證將會適用於以下的網站:abc.example.comaaa.example.comwhatever.example.com wildcard 憑證不包含以下的域名, 但是照文章內的指令申請, 可以一併申請example.com 總之不管前面是什麼，都可以適用。要使用 Certbot 來取得 wildcard 的 certificate 需要安裝 DNS 提供商的插件，或者其他的手動插件，本篇文章採用 DNS 提供商為 Google 的情況 參考網頁官網 環境 Server: NginX OS: Ubuntu 18.04 DNS Provider: Google 確認你的 DNS Provider 是否支援看你的 DNS Provider 有無被 Certbot 支援, 看這份清單 沒支援如果你的 DNS provider 沒有被支援，在這停下。 參考這份文件，使用手動插件運行 Certbot 執行以下程式碼 certbot certonly --manual -d *.example.com -d example.com --preferred-challenges dns 執行後先別按下 Enter, 請看下一步 到你的 DNS 服務商去新增相對應的 hostName 以及指向的 value, type 為 TXT dig -t txt hostName 確認該 hostName 是否指向 上一步新增的 value 回到 terminal 按下 enter 大功告成 有支援如果你的 DNS provider 有支援，順著以下的步驟繼續 SSH 到你的 ServerSSH 到你的 server, 該使用者須擁有 sudo 權限 加入 Certbot PPA你將需要把 Certbot PPA 加入到 repository 清單，執行以下指令來加入：sudo apt-get update; sudo apt-get install software-properties-common; sudo add-apt-repository universe; sudo add-apt-repository ppa:certbot/certbot; sudo apt-get update 安裝 Certbot執行以下指令來安裝 Certbotsudo apt-get install certbot python-certbot-nginx 安裝正確的 DNS 插件執行以下指令以安裝插件，本教程中使用的 DNS 提供商為 Google 範例sudo apt-get install python3-certbot-dns-\\&lt;PLUGIN\\&gt; 本教程情境sudo apt-get install python3-certbot-dns-google 設定 credentials你將需要設定 DNS credentials。依循各 DNS 提供商文件中的 “Credentials” 區塊來建立或存取適當的 credential 設定檔點擊這份文件 來尋找指定 DNS 提供商的 credential 教學。 設定 Google Credentials需要哪些權限？由 Certbot 的 Google 文件, 可以得知 Certbot 需要的權限如下：dns.changes.createdns.changes.getdns.managedZones.listdns.resourceRecordSets.createdns.resourceRecordSets.deletedns.resourceRecordSets.listdns.resourceRecordSets.update 建立 role從 Navigation menu &gt; IAM &amp; admin &gt; role , 進到 role 頁面後點擊 CRETE ROLE, 然後點擊 ADD PERMISSION 按鈕。 在 filter 欄位中，逐一輸入上面的權限來將需求的權限加入 全部都加入之後，請在 title 以及其他欄位依照個人需求填入名稱，若覺得預設挺好的，也可以保留預設即可。 選擇 CREATE, 共有七項。 建立 Service Account 從左側選單點擊 Navigation menu &gt; IAM &amp; admin &gt; Service accounts , 進到 Service accounts 頁面後，點擊上方 CREATE SERVICE ACCOUNT 按鈕。 依照個人喜好輸入 Service account name 以及 Service account description 選擇 role, 想當然爾，自然是輸入我們上一步建立的 role 啦！ 然後點擊 CONTINUE 最後是建立一把 json key, 點擊 CREATE KEY 最後點擊 DONE, 結束這一回合 選擇你想要怎麼樣執行 Certbot, 是單純拿到 certificate 或要安裝這邊官網有提供兩種方式，一種是全自動安裝，不只獲得憑證還幫你安裝，另外一種是只有安裝。不過我看過 Google 的插件之後，發現好像只有獲得憑證的選項，因此下面的指令會是單純獲得憑證的方式，若有人知道怎麼同時安裝的，也可以提供哦！ 下面指令為 Google 版的，其他版的請勿使用哦！ certbot certonly --dns-google --dns-google-credentials yourCredentailLocation -d *.example.com. -d example.com. -i nginx 上面的 yourCredentailLocation 為上面我的建立的 Google Service Account JSON Key, 假如我放在 /home/ray/serviceAccountKey.json, 那上面的指令將會如下： certbot certonly --dns-google --dns-google-credentials /home/ray/serviceAccountKey.json -d *.example.com. -d example.com. -i nginx 拿到憑證之後，我們可以設定一個測試站來看 wildcard 憑證是否有效 建立測試 site 檔案vim example.com server &#123; server_name abc.example.com; listen 80; listen 443 ssl; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;&#125; 憑證的位置我們在上一步成功拿到憑證之後，輸出訊息會顯示憑證放置位置。 我們也可以把它放到任何我們想要的地方。 測試 syntax nginx -t 重啟 Nginx systemctl restart nginx.service 到域名服務商去新增 abc.example.com 這筆 A record, 然後 IP 為你 Server 的位置 給 DNS 一些時間來生效 在瀏覽器輸入 https://abc.example.com 來拜訪測試站，若成功的話可以看到 Welcome to nginx! 測試自動更新Certbot 套件附有 cron job 或是 systemd timer，可以在憑證過期前自動的更新你的憑證。 你將不需要再執行 Certbot, 除非你更動了你的設定。 你可以運行下面的指令來測試自動更新:sudo certbot renew --dry-run 自動更新 certbot 的指令安裝在以下位置：/etc/crontab//etc/cron.*/*systemctl list-timers 確認 Certbot 正確的設定我們的憑證拜訪你的網站，然後看左方鎖頭的圖案。如果你想看更多資訊，試試看這個網站故障排除請參考這份文件若需要更多客製化的設定，請參考這份文件若覺得 Certbot 不錯，也可以贊助 失敗了？如果有看到錯誤訊息如下：Encountered error deleting TXT record: &lt;HttpError 412 when requesting https://dns.googleapis.com/dns/v1/projects/yourProject/managedZones/yourZoneNumber/changes?alt=json returned &quot;Precondition not met for &#39;entity.change.deletions[0]&#39;&quot;&gt; 那檢查一下是不是之前有手動申請憑證，並且驗證完畢之後沒有把 TXT 檔刪掉","link":"/zh-tw/letsEncryptWildcard/"},{"title":"Laravel - The Basics - Routing","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Basic RoutingAvailable Router Methods Laravel 中, 怎樣才能建立一個可以回應多個 HTTP method 的 route?&lt;?phpRoute::match(['get', 'post'], '/', function () &#123; //&#125;);Route::any('/', function () &#123; //&#125;); CSRF Protection Laravel 中, 哪些 HTTP method 會有 CSRF Protection? POSTPUTDELETE Laravel 的 CSRF Protection 中, 是如何將 XSRF TOKEN 傳給前端的？ 1. Laravel 把 token 存在 Session 當中2. 把 Session 對應的 Cookie 傳給前端3. 前端帶著對應的 Cookie, token 上來4. Laravel 用 Cookie 找 Session 對應的值, 並驗證前端送來的 tokenLaravel =&gt; Cookie, token =&gt; 前端 =&gt; Cookie, token =&gt; Laravel Laravel 的 CSRF Protection 中, XSRF Token 會放在哪裡傳給前端？Cookie Laravel 的 CSRF Protection 中, XSRF Token 會否加密再傳給前端？ 會的 Laravel 的 CSRF Protection 中, 後端會傳什麼給前端？與 Session 相對應的 Cookie 以及寫在 Cookie 內的 token Laravel 的 CSRF Protection 中, 前端會傳什麼給後端？後端之前傳來的 Cookie 資訊以及裡頭的 token Redirect Routes HTTP 轉址中, 301 跟 302 差在哪？ 301: 永久轉址, 搜尋引擎會把新網址當作唯一 url302: 暫時轉址, 搜尋引擎會知道這只是暫時的 Laravel 中, 如何利用 route 轉址？ &lt;?phpRoute::redirect('/here', '/there'); Laravel 中, 如何利用 route 轉址, 並且帶上狀態碼？ &lt;?phpRoute::redirect('/here', '/there', 301); Laravel 中, 哪一個 route method 可以轉址 301？ &lt;?phpRoute::permanentRedirect('/here', '/there'); View Routes Laravel 中, 如果我知道我只是要 return 一個 view, 可以使用哪一個 route 的 method? &lt;?phpRoute::view('/welcome', 'welcome'); Laravel 中, 如果我使用了 route 的 view method, 而我想要將參數帶過去, 可以怎麼做? &lt;?phpRoute::view('/welcome', 'welcome', ['name' =&gt; 'Taylor']); Route ParametersRequired Parameters Laravel 中, 如何在 URL 中定義參數? &lt;?phpRoute::get('user/&#123;id&#125;', function ($id) &#123; return 'User '.$id;&#125;); Laravel 中, 如何在 URL 中定義多個參數? &lt;?phpRoute::get('posts/&#123;post&#125;/comments/&#123;comment&#125;', function ($postId, $commentId) &#123; //&#125;); Laravel 中, 定義 URL 中的參數時, 可以用 - 嗎？ 如果不行, 那要用什麼? 不可 可使用 underscore (_) Laravel 中, 取得從 URL 中定義的參數時, 是看名字, 還是看順序？順序, controller 參數的名字不重要, 隨便亂取都可以, 只看順序 以下的 Laravel 程式碼中, 假設 a = 1, b = 2, 那 $c 跟 $d 的 dd() 結果為何？2, 1, Laravel 會自動找到參數並按照帶入的順序排列 &lt;?php public function index($d, MerchantDepositIndex $request, $c, DepositManager $manager) &#123; dd($c, $d); $row = request('row', (new Deposit)-&gt;getPerPage()); $deposits = $manager-&gt;get($request); return DepositCollection::make($deposits-&gt;latest()-&gt;paginate($row)-&gt;appends(request()-&gt;query-&gt;all())); &#125; Route::apiResource('deposits/&#123;a&#125;/&#123;b&#125;', 'DepositController')-&gt;only(['index', 'show']); Optional Parameters Laravel 中, 如果我想要在 URL 中定義一個可有可無的參數時, 可以怎麼做？&lt;?phpRoute::get('user/&#123;name?&#125;', function ($name = null) &#123; return $name;&#125;);Route::get('user/&#123;name?&#125;', function ($name = 'John') &#123; return $name;&#125;); Regular Expression Constraints 在 Laravel route 中, 如何使用正則來限制 URL parameters?&lt;?phpRoute::get('user/&#123;name&#125;', function ($name) &#123; //&#125;)-&gt;where('name', '[A-Za-z]+');Route::get('user/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;where('id', '[0-9]+');Route::get('user/&#123;id&#125;/&#123;name&#125;', function ($id, $name) &#123; //&#125;)-&gt;where(['id' =&gt; '[0-9]+', 'name' =&gt; '[a-z]+']); Global Constraints 在 Laravel 中, 如果我想要定義一個全域的正則限制, 可以怎麼做？ &lt;?phppublic function boot()&#123; Route::pattern('id', '[0-9]+'); parent::boot();&#125; 在 Laravel 中, 如果我想要定義一個全域的正則限制, 該在哪一個檔案中定義這個規則？RouteServiceProvider 在 Laravel 中, 如果我想要定義一個全域的正則限制, 該使用 Route 的哪一個 method ? &lt;?phpRoute::pattern('id', '[0-9]+'); 在 Laravel 中, 如果我想要定義一個 URL parameter, 這個 parameter 可能是一個 /, 那我該怎麼讓做？ &lt;?phpRoute::get('search/&#123;search&#125;', function ($search) &#123; return $search;&#125;)-&gt;where('search', '.*'); 在 Laravel 中, 如果我想要定義一個 URL parameter, 這個 parameter 可能是一個 /, 那只有在 URL 的哪一個位置是容許的？最後一個區塊 Named Routes 在 Laravel 中, 該怎麼給 route 一個 name 呢？？ &lt;?phpRoute::get('user/profile', function () &#123; //&#125;)-&gt;name('profile');Route::get('user/profile', 'UserProfileController@show')-&gt;name('profile'); 在 Laravel 中, 該怎麼 redirect 到已命名的 route 去？ &lt;?php// Generating Redirects...return redirect()-&gt;route('profile'); 在 Laravel 中, 該怎麼根據已命名的 route 產生 url？ &lt;?php// Generating URLs...$url = route('profile'); 在 Laravel 中, 假設我命名 route 如下, 那當我想產生一個這個 route 的 url 時, 我該怎麼把 {id} 帶進 url, 假設 {id} 的 value 是 1？ &lt;?phpRoute::get('user/&#123;id&#125;/profile', function ($id) &#123; //&#125;)-&gt;name('profile'); &lt;?php$url = route('profile', ['id' =&gt; 1]); 在以下 Laravel 的 route 中, 產生的 url 會長怎樣？/user/1/profile?photos=yes &lt;?phpRoute::get('user/&#123;id&#125;/profile', function ($id) &#123; //&#125;)-&gt;name('profile');$url = route('profile', ['id' =&gt; 1, 'photos' =&gt; 'yes']); 在 Laravel 的 route 中, 當我要使用已命名的 route 來產生 url 時, 如何帶入 query string？ &lt;?phpRoute::get('user/&#123;id&#125;/profile', function ($id) &#123; //&#125;)-&gt;name('profile');$url = route('profile', ['id' =&gt; 1, 'photos' =&gt; 'yes']);// /user/1/profile?photos=yes 在 Laravel 的 route 中, 如何驗證 request 是導向一個命名的 route? &lt;?php/** * Handle an incoming request. * * @param \\Illuminate\\Http\\Request $request * @param \\Closure $next * @return mixed */public function handle($request, Closure $next)&#123; if ($request-&gt;route()-&gt;named('profile')) &#123; // &#125; return $next($request);&#125; Route GroupsMiddleware 在 Laravel 中, 如果我只是要將 middleware 做用到多個 route 上, 可以怎麼做？&lt;?phpRoute::middleware(['first', 'second'])-&gt;group(function () &#123; Route::get('/', function () &#123; // Uses first &amp; second Middleware &#125;); Route::get('user/profile', function () &#123; // Uses first &amp; second Middleware &#125;);&#125;); Namespaces 在 Laravel 中, 如果我只是要將 namespace 做用到多個 route 上, 可以怎麼做？&lt;?phpRoute::namespace('Admin')-&gt;group(function () &#123; // Controllers Within The \"App\\Http\\Controllers\\Admin\" Namespace&#125;); Sub-Domain Routing 在 Laravel 中, 如果我要根據請求的 domain 不同來將請求導向不同的 route, 可以怎麼做？ &lt;?phpRoute::domain('&#123;account&#125;.myapp.com')-&gt;group(function () &#123; Route::get('user/&#123;id&#125;', function ($account, $id) &#123; // &#125;);&#125;); 在 Laravel 中, 為了確保 sub-domain routing 可被存取, 當我們在定義時, 應該先定義 sub-domain routes 還是 root domain routes?sub-domain routes Route Prefixes 在 Laravel 中, 如果我只是要將 prefix 做用到多個 route 上, 可以怎麼做？ &lt;?phpRoute::prefix('admin')-&gt;group(function () &#123; Route::get('users', function () &#123; // Matches The \"/admin/users\" URL &#125;);&#125;); 以下的 Laravel route 將符合什麼樣的 URL ?/admin/users &lt;?phpRoute::prefix('admin')-&gt;group(function () &#123; Route::get('users', function () &#123; &#125;);&#125;); Route Name Prefixes 在 Laravel 中, 假如我想要指派 name 給很多個 route, 而我想要統一加一個前綴, 像是 admin, 那我可以怎麼做？&lt;?phpRoute::name('admin.')-&gt;group(function () &#123; Route::get('users', function () &#123; // Route assigned name \"admin.users\"... &#125;)-&gt;name('users');&#125;); Route Model BindingImplicit Binding Laravel 中, 如何實作 model binding? &lt;?phpRoute::get('api/users/&#123;user&#125;', function (App\\User $user) &#123; return $user-&gt;email;&#125;); Laravel 中, 如果 Model Binding 沒有找到相對應的 Model, 會回傳什麼？?404 Customizing the key Name 在 Laravel Model Binding 中, 如果我不想要用 id column 來當作 key, 可以怎麼做？&lt;?php/** * Get the route key for the model. * * @return string */public function getRouteKeyName()&#123; return 'slug';&#125; Explicit Binding 在 Laravel 當中, 如果我不想使用 type-hinted variable 來觸發 Model Binding, 我想要藉由 URL 的 parameter 命名來觸發的話, 我可以怎麼做？ 舉例來說, /admin/{user} &lt;?phppublic function boot()&#123; parent::boot(); Route::model('user', App\\User::class); // 這個用法會完全綁定 URL parameter 的名稱, 不需使用 type-hint&#125; Customizing The Resolution Logic Laravel 的 model binding 中, 如果我想要定義比單一 column 更複雜的規則, 有幾種做法？兩種 Laravel 的 model binding 中, 如果我想要定義比單一 column 更複雜的規則, 有哪兩種做法？ 1. RouteServiceProvider 增加規則2. 在 Model 中定義 method Laravel 的 model binding 中, 如果我想要定義比單一 column 更複雜的規則, Model 的做法？ &lt;?php/** * Retrieve the model for a bound value. * * @param mixed $value * @return \\Illuminate\\Database\\Eloquent\\Model|null */public function resolveRouteBinding($value)&#123; return $this-&gt;where('name', $value)-&gt;firstOrFail();&#125; Laravel 的 model binding 中, 如果我想要定義比單一 column 更複雜的規則, RouteServiceProvider 的做法？ &lt;?php/** * Bootstrap any application services. * * @return void */public function boot()&#123; parent::boot(); Route::bind('user', function ($value) &#123; return App\\User::where('name', $value)-&gt;firstOrFail(); &#125;);&#125; Fallback Routes 在 Laravel 中, 一個未找到 route 服務的請求會預設回傳 404, 如果我要自定義一個 route 專門來處理這種情況, 我該怎麼做？ &lt;?phpRoute::fallback(function () &#123; //&#125;); 在 Laravel 中, fallback route 的位置應該要放在什麼地方？最後 Rate Limiting 在 Laravel 中, 如果我要限制特定 route 或 route 群組在特定時間內接收請求的次數, 那我可以怎麼做？ &lt;?phpRoute::middleware('auth:api', 'throttle:60,1')-&gt;group(function () &#123; Route::get('/user', function () &#123; // &#125;);&#125;); 以下的 Laravel 程式碼中, throttle 的兩個參數分別代表什麼意思？ 次數分鐘 &lt;?phpRoute::middleware('throttle:10|60,1')-&gt;group(function () &#123; //&#125;); Dynamic Rate Limiting 在 Laravel 中, 如果我要動態的來限制來源在特定時間內的存取次數, 比如說, 特定 user 的存取次數限制, 那我可以怎麼做？&lt;?php// rate_limit 為該使用者在資料庫內的欄位Route::middleware('auth:api', 'throttle:rate_limit,1')-&gt;group(function () &#123; Route::get('/user', function () &#123; // &#125;);&#125;); Distanct Guest &amp; Authenticated User Rate Limits 在 Laravel 中, 如果我要限制 guest 以及 authenticated user 在特定時間內不同的存取次數限制, 我可以怎麼做？ &lt;?phpRoute::middleware('throttle:10|60,1')-&gt;group(function () &#123; //&#125;); 在 Laravel 中, 如果我要限制 guest 以及 authenticated user 在特定時間內不同的存取次數限制, 且 authenticated user 的次數是動態的, 我可以怎麼做？ &lt;?phpRoute::middleware('auth:api', 'throttle:10|rate_limit,1')-&gt;group(function () &#123; Route::get('/user', function () &#123; // &#125;);&#125;); Form Method Spoofing 使用 HTML Form 發 API 時, 常常遇到 PUT, PATCH, DELETE 方法不可用, 根本的原因是什麼？HTML Forms 不支援以上的 HTTP method 哪幾種 HTTP method 是不被 HTML Form 支援的？PUT, PATCH, DELETE 要讓 HTML form 可以使用 PUT, PATCH, DELETE 等 method, 可以怎麼做？ &lt;form action=\"/foo/bar\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"PUT\"&gt; &lt;input type=\"hidden\" name=\"_token\" value=\"&#123;&#123; csrf_token() &#125;&#125;\"&gt;&lt;/form&gt; Laravel 中, 如何使用 Blade 來產生 _method input？ &lt;form action=\"/foo/bar\" method=\"POST\"&gt; @method('PUT') @csrf&lt;/form&gt; Accessing The Current Route Laravel 中, 如果我要取得目前 route 的名稱, 可以怎麼做？ &lt;?php$name = \\Illuminate\\Support\\Facades\\Route::currentRouteName(); Laravel 中, 如果我要取得目前 route object, 可以怎麼做？ &lt;?php$name = \\Illuminate\\Support\\Facades\\Route::current(); Laravel 中, 如果我要取得目前 route 的 action, 可以怎麼做？ &lt;?php$name = \\Illuminate\\Support\\Facades\\Route::currentRouteAction(); Laravel 中, route 的 action 長什麼樣子？App\\Http\\Controllers\\Admin\\controllerName@controllerMethodName 下面提供所以可以被取得的 route methodunderlyingClass of the Route facadeRoute instance","link":"/zh-tw/laravelTheBasicsRouting/"},{"title":"利用 Let's Encrypt 來自動簽署並更新 SSL 憑證","text":"前言本篇主要分享，如何利用 Let&#39;s Encrypt 的 cert bot 來自動簽署以及更新 SSL 憑證 參考網頁官網 環境 Server: NginX OS: Ubuntu 18.04DNS 設定先將 DNS 設定好, 建一個 A record, 將我們喜歡的 domain 指向我們的 IP 設定檔 這邊使用最簡單的設定, 反向代理 server 內的 9527 port, 若無反向代理需求，可以單純指向專案的 Document root 即可sudo vim /etc/nginx/sites-available/yourSiteName server &#123; listen 80; server_name yourDomainName; access_log /var/log/nginx/test_access_log; location / &#123; proxy_pass http://127.0.0.1:9527; &#125;&#125; 測試 syntax sudo nginx -t 啟用設定 sudo ln -s /etc/nginx/sites-available/yourSiteName /etc/nginx/sites-enabled/yourSiteName 設完之後，重啟 nginx sudo service nginx restart 測試設定設定好之後，如果我們 curl http://yourIPOrDomain/endpoint , 應該要可以存取服務 新增 cerbot PPA (Personal Package Archives)sudo apt-get update &amp;&amp; sudo apt-get install software-properties-common &amp;&amp; sudo add-apt-repository universe &amp;&amp; sudo add-apt-repository ppa:certbot/certbot 安裝 Let’s Encryptsudo apt-get install certbot python-certbot-nginx 運行 cerbot全自動模式如果你希望 cerbot 可以幫我們全自動完成設定，輸入sudo certbot --nginx 半自動模式如果你希望 cerbot 只幫我們拿到憑證，其他我們自己來的話，輸入sudo certbot certonly --nginx 測試自動更新到這裡，應該已經可以自動更新憑證了，輸入以下指令測試sudo certbot renew --dry-run cerbot 安裝在以下路徑之一: /etc/crontab/ /etc/cron.*/* systemctl list-timers 測試簽證是否成功測試網頁","link":"/zh-tw/letsencrypt/"},{"title":"Laravel - Digging Deeper - Queues","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Connection Vs. Queues 在以下的 Laravel Queue 的程式碼, job 會被送往哪裡？會被送往預設的 queue &lt;?phpJob::dispatch(); 在以下的 Laravel Queue 的程式碼, job 會被送往哪裡？會被送往自定義的 emails queue &lt;?phpJob::dispatch()-&gt;onQueue('emails'); 在 Laravel Queues 當中, 如果我想要排列 queue 的優先順序, 我可以怎麼做？ php artisan queue:work --queue=high,default Driver Notes &amp; PrerequisitesDatabase 在 Laravel 中, 如果我使用的 driver 為 database, 該如何建立 queue table?php artisan queue:tablephp artisan migrate Redis 在 Laravel 的 QUEUE 當中, 如果我使用 redis 為 driver, 該如何設定 redis 的 database connection?在 config/database.php 檔案中 Redis Cluster 如果是使用 Redis Cluster, queue 的名稱需要包含什麼？&apos;redis&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;redis&apos;, &apos;connection&apos; =&gt; &apos;default&apos;, &apos;queue&apos; =&gt; &apos;&#123;default&#125;&apos;, &apos;retry_after&apos; =&gt; 90,], Blocking 在 Laravel Queue 當中, 如果我使用 redis, 且我想要讓 redis 在進去下一輪的 polling 之前等待數秒, 看有沒有新的 job 進來, 我可以怎麼做？&apos;redis&apos; =&gt; [ &apos;driver&apos; =&gt; &apos;redis&apos;, &apos;connection&apos; =&gt; &apos;default&apos;, &apos;queue&apos; =&gt; &apos;default&apos;, &apos;retry_after&apos; =&gt; 90, &apos;block_for&apos; =&gt; 5,], Creating JobsGenerating Job Classes Laravel 中, 一般 job 都會放在哪？app/Jobs Laravel 中, 如何建立一個 Job? php artisan make:job jobName 在 Laravel 中, 當我們注入一個 Model 到 Job, 是會整個 Model 都被注入, 還是只會注入該 Model 的一個辨識物？Only an identifier will be stored in the job 在 Laravel 中, 當我在 job 中注入一個 model, 當這個 job 被在 queue 中被取出執行時, 請入該 model 會是我當初注入時的狀態, 還是目前資料庫中最新的狀態？資料庫中的狀態 Handling Relationships Laravel queue 中, 當我注入 model 到 job 中時, 如果我不想要讓一個 model 的 relation 被載入, 我可以怎麼做？&lt;?php/** * Create a new job instance. * * @param \\App\\Podcast $podcast * @return void */public function __construct(Podcast $podcast)&#123; $this-&gt;podcast = $podcast-&gt;withoutRelations();&#125; Job Middleware 在 Laravel Queue 中, 可以建立一個 Job middleware 嗎？可以 在 Laravel Queue 中, 如果我想要建立一個 Job Middleware, 可以建立在什麼位置？什麼位置都可以, 官方範例位置為 app/Jobs/Middleware 在 Laravel Queue 中, 如果我要建立一個 Job Middleware, 如何建立？ &lt;?phpnamespace App\\Jobs\\Middleware;use Illuminate\\Support\\Facades\\Redis;class RateLimited&#123; /** * Process the queued job. * * @param mixed $job * @param callable $next * @return mixed */ public function handle($job, $next) &#123; Redis::throttle('key') -&gt;block(0)-&gt;allow(1)-&gt;every(5) -&gt;then(function () use ($job, $next) &#123; // Lock obtained... $next($job); &#125;, function () use ($job) &#123; // Could not obtain lock... $job-&gt;release(5); &#125;); &#125;&#125; 在 Laravel Queue 中, 如果我要在一個 Job 中使用建立好的 Job Middleware, 我可以怎麼做？ &lt;?phpuse App\\Jobs\\Middleware\\RateLimited;/** * Get the middleware the job should pass through. * * @return array */public function middleware()&#123; return [new RateLimited];&#125; Dispatching Jobs 在 Laravel Queue 中, 該如何 dispatch 一個 job?&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; /** * Store a new podcast. * * @param Request $request * @return Response */ public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast); &#125;&#125; Delayed Dispatching 在 Laravel Queue 中, 如果我想要 delay 一個 dispatch, 我可以怎麼做？ &lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; /** * Store a new podcast. * * @param Request $request * @return Response */ public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast) -&gt;delay(now()-&gt;addMinutes(10)); &#125;&#125; 在 Laravel Queue 中, AWS 的 SQS 最多支援到 delay 多久？15 分鐘 Synchronous Dispatching 在 Laravel Queue 中, 如果我立即 dispatch 一個 job, 不要 queue, 那我可以怎麼做？&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; /** * Store a new podcast. * * @param Request $request * @return Response */ public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatchNow($podcast); &#125;&#125; Job Chaining 在 Laravel Job chaining 中, 如果其中一個 job 失敗了, 後面的還會繼續執行嗎？不會 在 Laravel Job chaining 中, 如果我使用 $this-&gt;delete(), 會終止後面的 job 執行嗎？不會 在 Laravel, 如何實作一個 job chaining? &lt;?phpProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast])-&gt;dispatch(); Chain Connection &amp; Queue 在 Laravel, 當我使用 job chaining 時, 如何指定這個 job chaining 使用的 connection 以及 queue?&lt;?phpProcessPodcast::withChain([ new OptimizePodcast, new ReleasePodcast])-&gt;dispatch()-&gt;allOnConnection('redis')-&gt;allOnQueue('podcasts'); Customizing The Queue &amp; ConnectionDispatching To A Particular Queue 在 Laravel job 當中, 如何指定特定的 queue?&lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; /** * Store a new podcast. * * @param Request $request * @return Response */ public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast)-&gt;onQueue('processing'); &#125;&#125; Dispatching To A Particular Connection 在 Laravel job 當中, 如果我使用不只一個 connection, 如何指定特定的 connection? &lt;?Phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use App\\Jobs\\ProcessPodcast;use Illuminate\\Http\\Request;class PodcastController extends Controller&#123; /** * Store a new podcast. * * @param Request $request * @return Response */ public function store(Request $request) &#123; // Create podcast... ProcessPodcast::dispatch($podcast)-&gt;onConnection('sqs'); &#125;&#125; Laravel job 當中, 如果我想要從該 job 的 class 中指定該 job 使用的 connection, 我可以怎麼做？ &lt;?phpnamespace App\\Jobs;class ProcessPodcast implements ShouldQueue&#123; /** * The queue connection that should handle the job. * * @var string */ public $connection = 'sqs';&#125; Laravel job 當中, 如果我想要同時指定該 job 特定的 connection 以及 queue 時, 我可以怎麼做？ &lt;?phpProcessPodcast::dispatch($podcast) -&gt;onConnection('sqs') -&gt;onQueue('processing'); Specifying Max Job Attempts / Timeout ValuesMax Attempts Laravel job 當中, 如何透過 CLI 指定該 job 的最大嘗試次數？ php artisan queue:work --tries=3 Laravel job 當中, 如何在該 job class 中指定該 job 的最大嘗試次數？ &lt;?phpnamespace App\\Jobs;class ProcessPodcast implements ShouldQueue&#123; /** * The number of times the job may be attempted. * * @var int */ public $tries = 5;&#125; Laravel job 當中, 當我同時在 job class 中, 以及 CLI 中都指令最大嘗試次數, Laravel 會以誰為準？job class 中指定的 property Time Based Attempts Laravel job 當中, 如果我想要指定一段時間長度, Laravel 可在這段時間內嘗試執行這個 job, 但超過這段時間就不會再嘗試了, 那我該怎麼做？&lt;?php/** * Determine the time at which the job should timeout. * * @return \\DateTime */public function retryUntil()&#123; return now()-&gt;addSeconds(5);&#125; Timeout Laravel job 當中, 如果我要指定任務可以執行的最大秒數, 通過 CLI, 我可以怎麼做？ php artisan queue:work --timeout=30 Laravel job 當中, 如果我要指定任務可以執行的最大秒數, 在 job class 中, 我可以怎麼做？ &lt;?phpnamespace App\\Jobs;class ProcessPodcast implements ShouldQueue&#123; /** * The number of seconds the job can run before timing out. * * @var int */ public $timeout = 120;&#125; Laravel job 當中, 如果我再 CLI 以及 job 的 class 同時定義的 timeout, 哪一個的優先權比較大？job class Rate Limiting Laravel queue 當中, 如果我想使用 rate limiting, 哪一個服務會是必要的？redis Laravel queue 當中, 如果我想要限制一個 job 在一定時間內可被執行的次數, 我可以怎麼做？ &lt;?phpRedis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 下面的 Laravel 程式碼代表什麼意思？每 60 秒最大可執行 10 次, 若失敗的話, 10 秒後 release job &lt;?phpRedis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 下面的 Laravel 程式碼中的 key, 代表什麼意思？可以是任意 string, 官方範例中, 可以是 job 的類型 + 該 Eloquent Model 的 id &lt;?phpRedis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 下面的 Laravel 程式碼中, 當我 release 該 job, 這樣還會增加該 job 的 attempt 次數嗎？會哦 &lt;?phpRedis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 在 Laravel 中, 如何限制一個 job 只能同時由一個 worker 執行？ &lt;?phpRedis::funnel('key')-&gt;limit(1)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); Queueing Closures 在 Laravel 中, 什麼情況我們可能會需要 dispatch 一個 closure?當我們想要執行一個簡單的任務, 且需要它被在請求之外的週期執行 在 Laravel 中, 如何 dispatch 一個 closure? &lt;?php$podcast = App\\Podcast::find(1);dispatch(function () use ($podcast) &#123; $podcast-&gt;publish();&#125;); Running The Queue Worker 在 Laravel 中, 怎麼樣啟動 worker 來執行 queued job? php artisan queue:work 在 Laravel 中, 要維持 worker 持續運行, 我們需要額外啟動什麼？程序管理器, 像是 supervisor, 或 pm2 在 Laravel 中, 當我使用 php artisan queue:work, 當我代碼有變更時, 我需要重新啟動 queue 嗎？需要 在 Laravel 中, 如果我運行 php artisan queue:listen, 然後我變更了代碼, 我需要再重新啟動 queue 嗎？不需要 在 Laravel 中, 如果我不想要每次變更代碼就重新啟動 queue, 我可以使用哪一個 CLI? php artisan queue:listen 在 Laravel 中, php artisan queue:work 跟 php artisan queue:listen 何者較有效率？ php artisan queue:work Specifying The Connection &amp; Queue 在 Laravel 中, 如何透過 CLI 指定 queue connection? php artisan queue:work redis 在 Laravel 中, 如何透過 CLI 給特定的 queue 指定特定 connection? php artisan queue:work redis --queue=emails Processing A Single Job 在 Laravel 中, 如何透過 CLI 指定 worker 只執行 queued job 一次php artisan queue:work --once Processing All Queued Jobs &amp; Then Exiting 在 Laravel 中, 如果我想要讓 queue worker 執行完所有 job 之後就關閉, 我可以怎麼做？ php artisan queue:work --stop-when-empty 以下的 Laravel 指令什麼時候可能會用到？當我們利用容器運行 worker, 而我們需要工作都完成後自動關閉 container 時 php artisan queue:work --stop-when-empty Resource Considerations 在 Laravel 的 queue 中, 因為會緩存在 RAM 中運行, 所以如果我有執行到未釋放的資源, 像是 image 之類的, 那我是否要在 job 執行完成之後釋放掉這些資源？要哦 Queue Priorities 在 Laravel 的 queue 中, 我要如何排列 queue 的優先順序？可以使用逗號做分隔排序php artisan queue:work --queue=high,low Queue Workers &amp; DeploymentJob Expiration 在 Laravel 的 queue 監聽程序中, 我要如何重啟 queue？ php artisan queue:restart 在 Laravel 的 queue 監聽 CLI php artisan queue:restart, 會不會讓我丟失執行到一半的工作？不會哦, 它會 gracefully restart, 完成目前手邊工作之後再重啟 Laravel 中, 在沒有使用 supervisor 的情況下, 如果我執行 php artisan queue:restart, 會發生什麼事？worker 會關閉 Laravel 中, 若要使用 php artisan queue:restart, 務必先要確認什麼服務已經設置好？cache Laravel 中, 當我使用 php artisan queue:restart, queue 會將 restart 的 signal 存在什麼地方？cache Laravel queue 中, 如果我要指定一個 job 在執行之後多久時間之後才可以再被執行 (如果沒被刪除的話), 我可以怎麼做？在 queue.php 的 config 檔案中, 可以設定 retry_after 的參數 Laravel queue 中, 哪一個服務無法在 queue.php config 中設定 retry_after 參數Amazon SQS Worker Timeouts Laravel queue 中, --timeout 跟 retry_after 的差別在哪？--timeout: queue 的 master 程序需等待多久的時間才可以殺掉一個執行同樣一個 job 的子程序retry_after: queue 的 master 程序需要隔多久才可以重啟一個子程序來執行之前執行過的 job Laravel queue 中, --timeout 跟 retry_after 的時間, 哪個長哪個短？--retry_after 需要比 --timeout 來得長 Laravel queue 中, 如果 retry_after 比 --timeout 設定的時間還短, 可能會發生什麼事？同一個 job 會被執行兩次 Worker Sleep Duration Laravel queue 中, 如果我要讓 worker 沒有新的 job 時會進入休眠狀態, 那我可以怎麼做？ php artisan queue:work --sleep=3 Laravel queue 中, 如果我有使用 --sleep 的 option, 當 queue 裡頭有很多 job 還沒有執行完畢時, worker 會進入 sleep 狀態嗎？不會, 會等到所有 job 都處理完畢, 沒有新的 job 了 worker 才會進入 sleep 狀態 Laravel queue 中, 如果我有使用 --sleep 的 option, 當 worker 處於 sleep 的狀態時, 如果有新的 job 進來, worker 會等到 sleep 結束再處理, 還是會立即處理？待 sleep 結束才會處理 Supervisor ConfigurationInstalling Supervisor 如何安裝 supervisor ? sudo apt-get install supervisor Supervisor 的設定檔位置在哪？/etc/supervisor/conf.d 我該如何設定 Supervisor 設定檔？ [program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3// 是否隨 supervisor 啟動一起啟動autostart=true// 程序異常退出後自動重啟autorestart=trueuser=forgenumprocs=8// 是否教錯誤的 log 一併記錄到 stdoutredirect_stderr=true// 一般輸出的記錄檔案位址stdout_logfile=/home/forge/app.com/worker.log// 刪除一個 job 的等待時間, 這邊需設定大於會執行最久的 job 的時間, 不然會在執行完畢前被砍掉stopwaitsecs=3600 Starting Supervisor Supervisor 如何重新讀取 config 檔, 但不重啟 process? sudo supervisorctl reread Supervisor 如何重新讀取 config 檔, 並依照 config 檔案重啟 process? sudo supervisorctl update Supervisor 如何啟動? sudo supervisorctl start laravel-worker:* Supervisor 官方文件位址?Supervisor 官方文件 Dealing With Failed JobsLaravel queue 中, 當一個 job 一直執行失敗, 超出了指定的 tries 的限制, 那這個 job 會跑到哪裡去？failed_jobs Laravel queue 中, 如何建立 failed_jobs table?php artisan queue:failed-tablephp artisan migrate Laravel queue 中, 如果我要使用 CLI 指定 retry 一個 failed job 的間隔時間, 我可以怎麼做？使用 --delay flagphp artisan queue:work redis --tries=3 --delay=3 Laravel queue 中, 如果我要使用 job class 指定 retry 一個 failed job 的間隔時間, 我可以怎麼做？&lt;?php/** * The number of seconds to wait before retrying the job. * * @var int */public $retryAfter = 3; Cleaning Up After Failed JobsLaravel 中, 當我一個 job failed, 我想要在它 fail 的時候發通知, 我可以在哪一個地方寫這個邏輯？&lt;?phpnamespace App\\Jobs;use App\\AudioProcessor;use App\\Podcast;use Exception;use Illuminate\\Bus\\Queueable;use Illuminate\\Contracts\\Queue\\ShouldQueue;use Illuminate\\Queue\\InteractsWithQueue;use Illuminate\\Queue\\SerializesModels;class ProcessPodcast implements ShouldQueue&#123; use InteractsWithQueue, Queueable, SerializesModels; protected $podcast; /** * Create a new job instance. * * @param Podcast $podcast * @return void */ public function __construct(Podcast $podcast) &#123; $this-&gt;podcast = $podcast; &#125; /** * Execute the job. * * @param AudioProcessor $processor * @return void */ public function handle(AudioProcessor $processor) &#123; // Process uploaded podcast... &#125; /** * The job failed to process. * * @param Exception $exception * @return void */ public function failed(Exception $exception) &#123; // Send user notification of failure, etc... &#125;&#125; Failed Job EventsLaravel 中, 如果我想要註冊一個事件, 每當 job 失敗的時候就會去呼叫他, 我可以怎麼做？&lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Queue;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Queue\\Events\\JobFailed;class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Queue::failing(function (JobFailed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;exception &#125;); &#125;&#125; Retrying Failed Jobs Laravel Queue 中, 如果我要從 failed_jobs table 中檢視所有 failed jobs, 我可以怎麼做？ php artisan queue:failed Laravel Queue 中, 如果我要使用 CLI 獲取 failed jobs 的 ID, 我可以怎麼做？ php artisan queue:failed Laravel Queue 中, 如果我要從 CLI retry 特定的 failed jobs, 我可以怎麼做？5 為 failed job ID php artisan queue:retry 5 Laravel Queue 中, 如果我要從 CLI retry 所有的 failed jobs, 我可以怎麼做？ php artisan queue:retry all Laravel Queue 中, 如果我要從 CLI 刪除一個 failed job, 我可以怎麼做？5 為 failed job ID php artisan queue:forget 5 Laravel Queue 中, 如果我要從 CLI 刪除所有的 failed jobs, 我可以怎麼做？ php artisan queue:flush Ignoring Missing Models Laravel Queue 中, 我們注入一個 Eloquent model 到一個 job 當中, 而當執行該 job 時, 該 model 已遭刪除, 這時會發生什麼事？這個 job 會失敗, ModelNotFoundException Laravel Queue 中, 我們注入一個 Eloquent model 到一個 job 當中, 而當執行該 job 時, 該 model 已遭刪除, 這時會報錯, ModelNotFoundException, 如何設定當遇到這種情況時, 自動刪除 job？在 job class 當中 &lt;?php/** * Delete the job if its models no longer exist. * * @var bool */public $deleteWhenMissingModels = true; Job Events Laravel Queue 中, 如果我想要在 job 事件執行前做一些事, 那麼我可以怎麼做？在 AppServiceProvider 中 &lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Queue;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Queue\\Events\\JobProcessed;use Illuminate\\Queue\\Events\\JobProcessing;class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Queue::before(function (JobProcessing $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); Queue::after(function (JobProcessed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); &#125;&#125; Laravel Queue 中, 如果我想要在 job 事件執行後做一些事, 那麼我可以怎麼做？在 AppServiceProvider 中 &lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Queue;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Queue\\Events\\JobProcessed;use Illuminate\\Queue\\Events\\JobProcessing;class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Queue::before(function (JobProcessing $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); Queue::after(function (JobProcessed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); &#125;&#125; Laravel Queue 中, 以下的程式碼通常可以應用在什麼情況？ &lt;?phpnamespace App\\Providers;use Illuminate\\Support\\Facades\\Queue;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Queue\\Events\\JobProcessed;use Illuminate\\Queue\\Events\\JobProcessing;class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Queue::before(function (JobProcessing $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); Queue::after(function (JobProcessed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); &#125;&#125; 記 log 統計特定 job 運行次數 Laravel Queue 中, 如果我想要設定一個 closure, 當我的 worker 要從 queue fetch 新的 job 回來執行之前, 執行這個 closure, 那我可以怎麼做？在 AppServiceProvider 當中 &lt;?phpQueue::looping(function () &#123; while (DB::transactionLevel() &gt; 0) &#123; DB::rollBack(); &#125;&#125;);","link":"/zh-tw/laravelDiggingDeeperQueues/"},{"title":"Laravel - EloquentORM - Relationships","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Defining RelationshipsOne To One 在 Laravel relationship 當中, 如何建立一個 one to one relation?&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * Get the phone record associated with the user. */ public function phone() &#123; return $this-&gt;hasOne('App\\Phone'); &#125;&#125; Laravel hasOne relationship 當中, 預設 foreign key 的條件是什麼？model name Laravel hasOne relationship 當中, 如果我要自定義 foreign key, 我可以怎麼做？ &lt;?phpreturn $this-&gt;hasOne('App\\Phone', 'foreign_key'); Laravel hasOne relationship 當中, 預設 foreign key 的值需要對應 parent table 上的哪一個 column 的值?id Laravel hasOne relationship 當中, 如果我要自定義預設 foreign key 的值對應的 parent table 上的 column, 我可以怎麼做？ &lt;?phpreturn $this-&gt;hasOne('App\\Phone', 'foreign_key', 'local_key'); Defining The Inverse Of The Relationship Laravel one to one relationship 中, 如何定義反向的存取? &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Phone extends Model&#123; /** * Get the user that owns the phone. */ public function user() &#123; return $this-&gt;belongsTo('App\\User'); &#125;&#125; Laravel one to one relationship 中, 預設定義 belongsTo 的 foreign key 的規則是？根據 belongsTo method 的名稱, 在 method 名稱後加上 _id Laravel one to one relationship 中, 如何自訂義 foreign key? &lt;?php/** * Get the user that owns the phone. */public function user()&#123; return $this-&gt;belongsTo('App\\User', 'foreign_key');&#125; Laravel one to one relationship 當中, 在 belongsTo method 當中, 如果我的 parent table 不是使用 id 作為 primary key, 而我想要自定義, 我可以怎麼做？ &lt;?php/** * Get the user that owns the phone. */public function user()&#123; return $this-&gt;belongsTo('App\\User', 'foreign_key', 'other_key');&#125; One To Many Laravel one to many relationship 中, 如果我要建立一個 one to many 的 relation, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get the comments for the blog post. */ public function comments() &#123; return $this-&gt;hasMany('App\\Comment'); &#125;&#125; 以下的 relation 中, foreign key 預設是什麼？ post_id 預設, Laravel 會在擁有者 model 使用 “snake_case”, 並在最後加上 _id&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get the comments for the blog post. */ public function comments() &#123; return $this-&gt;hasMany('App\\Comment'); &#125;&#125; Laravel one to many relationship 中, 如何取得 relation？ &lt;?php$comments = App\\Post::find(1)-&gt;comments;foreach ($comments as $comment) &#123; //&#125; Laravel one to many relationship 中, 如何取得 relation 的 query builder？ &lt;?php$comment = App\\Post::find(1)-&gt;comments()-&gt;where('title', 'foo')-&gt;first(); Laravel one to many relationship 中, 如何自定義 foreign key 以及 local key? &lt;?phpreturn $this-&gt;hasMany('App\\Comment', 'foreign_key');return $this-&gt;hasMany('App\\Comment', 'foreign_key', 'local_key'); One To Many (Inverse) Laravel one to many relation 中, 如何定義一個反向的 relation? &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * Get the post that owns the comment. */ public function post() &#123; return $this-&gt;belongsTo('App\\Post'); &#125;&#125; Laravel one to many relationship 中, 如何自訂義 foreign key 以及 primary key? &lt;?php/** * Get the post that owns the comment. */public function post()&#123; return $this-&gt;belongsTo('App\\Post', 'foreign_key', 'other_key');&#125; Many To Many Laravel Relationship 中, 當我要建立一個 many to many 的中間表格, 表格的命名是什麼規格？alphabetical Laravel Relationship 中, 當我要建立一個 users, roles 的 many to many 的中間表格, 中間表格必須至少有什麼 column？user_id, role_id Laravel Relationship 中, 當我要建立一個 users, roles 的 many to many 的 relationship, 在 User 的 model 中, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany('App\\Role'); &#125;&#125; 承上面 Laravel 程式碼, 在 Laravel Relationship 中, 如果我已經在 User 跟 Role model 之間建立了 many to many relationship, 當我想要從 user model 取 roles, 我可以怎麼做？ &lt;?php$user = App\\User::find(1);foreach ($user-&gt;roles as $role) &#123; //&#125; 承上面 Laravel 程式碼, 在 Laravel Relationship 中, 如果我已經在 User 跟 Role model 之間建立了 many to many relationship, 當我想要取 roles 並 chain query 時, 我可以怎麼做？ &lt;?php$roles = App\\User::find(1)-&gt;roles()-&gt;orderBy('name')-&gt;get(); 在 Laravel many to many relationship 中, 我如果自定義中間表格的名稱, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany('App\\Role', 'table_name'); &#125;&#125; 在 Laravel many to many relationship 中, 如果我想要自定義中間表格中 column 的名稱, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany('App\\Role', 'role_user', 'currentModel', 'joiningToModel'); &#125;&#125; Retrieving Intermediate Table Columns 在 Laravel many to many relationship 中, 如果我想要取得中間表格的資料, 我可以怎麼做？ &lt;?php$user = App\\User::find(1);foreach ($user-&gt;roles as $role) &#123; echo $role-&gt;pivot-&gt;created_at;&#125; 在 Laravel many to many relationship 中, 當我取得 related model, related model 預設會載入中間 model 嗎？會哦 在 Laravel many to many relationship 中, 當我取得 related model, 自動載入的中間 model 預設只會有什麼資料？model key 在 Laravel many to many relationship 中, 當我取得 related model, 自動載入的中間 model 預設只會有 model key, 如果我想要讓他自動載入時自動載入其他特定 column 的資料, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany('App\\Role')-&gt;withPivot('column1', 'column2'); &#125;&#125; 在 Laravel many to many relationship 中, 如果我想要我的中間表格的 created_at 以及 updated_at 被自動維護, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany('App\\Role')-&gt;withTimestamps(); &#125;&#125; Customizing The pivot Attribute Name 在 Laravel many to many 的 relation 中, 中間表格的預設 model 都叫做 pivot, 如果我想要自定義它的名稱, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * The roles that belong to the user. */ public function roles() &#123; return $this-&gt;belongsToMany('App\\Podcast') -&gt;as('subscription') -&gt;withTimestamps(); &#125;&#125; 呈上, 如何存取這個 subscription 中間表格？ &lt;?php$users = User::with('podcasts')-&gt;get();foreach ($users-&gt;flatMap-&gt;podcasts as $podcast) &#123; echo $podcast-&gt;subscription-&gt;created_at;&#125; Filtering Relationships Via Intermediate Table Columns Laravel many to many relation 中, 如何在定義 relation 的時候, 使用中間表格的特定 attribute 條件來定義？&lt;?phpreturn $this-&gt;belongsToMany('App\\Role')-&gt;wherePivot('approved', 1);return $this-&gt;belongsToMany('App\\Role')-&gt;wherePivotIn('priority', [1, 2]);return $this-&gt;belongsToMany('App\\Role')-&gt;wherePivotNotIn('priority', [1, 2]); Defining Custom Intermediate Table Models Laravel 中, 如何在 User model 中定義 many to many relation 的時候, 同時定義中間表格代表的 model? User model: &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Role extends Model&#123; /** * The users that belong to the role. */ public function users() &#123; return $this-&gt;belongsToMany('App\\User')-&gt;using('App\\RoleUser'); &#125;&#125; 定義中間表格的 model &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Relations\\Pivot;class RoleUser extends Pivot&#123; //&#125; Laravel 中, 如何在 User model 中定義 many to many relation 的時候, 同時定義中間表格代表的 model, 同時定義額外可存取的 column? &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Role extends Model&#123; /** * The users that belong to the role. */ public function users() &#123; return $this-&gt;belongsToMany('App\\User') -&gt;using('App\\RoleUser') -&gt;withPivot([ 'created_by', 'updated_by', ]); &#125;&#125; Laravel many to many relation 中, pivot model 可以使用 SoftDeletes trait 嗎？不行哦 Custom Pivot Models And Incrementing IDs Laravel many to many relation 中, 為了讓 table 中的 primary key 運作正常, pivot model 中需要加什麼屬性？&lt;?php/** * Indicates if the IDs are auto-incrementing. * * @var bool */public $incrementing = true; Has One Through Laravel one to one relation 當中, 如果一個 supplier 下有一個 user, 而一個 user 會有一個 history, 那我該如何從 supplier 拿到 history 的資料？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Supplier extends Model&#123; /** * Get the user's history. */ public function userHistory() &#123; return $this-&gt;hasOneThrough('App\\History', 'App\\User'); &#125;&#125; 第一個參數為目標 model 第二個參數為中間 model Laravel hasOneThrough 中, 如果我要自定義 foreign key 跟 local key, 那我可以怎麼做？&lt;?phpSupplier extends Model&#123; /** * Get the user's history. */ public function userHistory() &#123; return $this-&gt;hasOneThrough( 'App\\History', 'App\\User', 'supplier_id', // Foreign key on users table... 'user_id', // Foreign key on history table... 'id', // Local key on suppliers table... 'id' // Local key on users table... ); &#125;&#125; Has Many Through Laravel one to many relation 中, 如果一個 country 有許多 user, 而一個 user 有許多 post, 那我現在要從 country 拿到 post, 我可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Country extends Model&#123; /** * Get all of the posts for the country. */ public function posts() &#123; return $this-&gt;hasManyThrough('App\\Post', 'App\\User'); &#125;&#125; 第一個參數為目標 model 第二個參數為中間 model 在 Laravel one to many through method 中, 如果我要自定義 foreign key 以及 local key, 我可以怎麼做？&lt;?phpclass Country extends Model&#123; public function posts() &#123; return $this-&gt;hasManyThrough( 'App\\Post', 'App\\User', 'country_id', // Foreign key on users table... 'user_id', // Foreign key on posts table... 'id', // Local key on countries table... 'id' // Local key on users table... ); &#125;&#125; Polymorphic RelationshipsOne To One (Polymorphic)Table Structure 在 Laravel 中, 如果說我有一個 image model, 而 user model 跟 post model 都跟 image 有 one to one 的關係, 那我可以使用什麼樣的 relation?One To One (Polymorphic) Laravel 中, 假設我的 Post model 有一個 Image model, 而 User model 也有一個 Image model, 現在我要定義 one to one (polymorphic) relation, 若要在 Post model 中定義與 Image model 的關係, 可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get the post's image. */ public function image() &#123; return $this-&gt;morphOne('App\\Image', 'imageable'); &#125;&#125; Laravel 中, 假設我的 Post model 有一個 Image model, 而 User model 也有一個 Image model, 現在我要定義 one to one (polymorphic) relation, 若要在 User model 中定義與 Image model 的關係, 可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class User extends Model&#123; /** * Get the user's image. */ public function image() &#123; return $this-&gt;morphOne('App\\Image', 'imageable'); &#125;&#125; Laravel 中, 假設我的 Post model 有一個 Image model, 而 User model 也有一個 Image model, 現在我要定義 one to one (polymorphic) relation, 若要在 Image model 中定義與 User model 以及 Post model 的關係, 可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Image extends Model&#123; /** * Get the owning imageable model. */ public function imageable() &#123; return $this-&gt;morphTo(); &#125;&#125; 以下的 Laravel one to one (Polymorphic) relation table structure 當中, imageable_id 跟 imageable_type 分別代表什麼？ posts id - integer name - stringusers id - integer name - stringimages id - integer url - string imageable_id - integer imageable_type - string imageable_id: user_id 或 post_id imageable_type: user model name 或 post model name Retrieving The Relationship 在 Laravel one to one (Polymorphic) relation 當中, 假設以下為我的 relation 定義, 如果我要從 parent model 拿到 child model, 那我可以怎麼做？ Relation 定義: &lt;?phpclass Post extends Model&#123; /** * Get the post's image. */ public function image() &#123; return $this-&gt;morphOne('App\\Image', 'imageable'); &#125;&#125; 取得 relation: &lt;?php$post = App\\Post::find(1);$image = $post-&gt;image; 在 Laravel one to one (Polymorphic) relation 當中, 假設以下為我的 relation 定義, 如果我要從 child model 取得 parent model, 我可以怎麼做？ Relation 定義： &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Image extends Model&#123; /** * Get the owning imageable model. */ public function imageable() &#123; return $this-&gt;morphTo(); &#125;&#125; 取得 relation &lt;?php$image = App\\Image::find(1);$imageable = $image-&gt;imageable; One To Many (Polymorphic)Table Structure Laravel 當中, 如果說在我的應用中的 user 可以同時在 video 以及 post 中留下 comments, 那我可以使用怎麼樣的 relation?one to many (Polymorphic) Laravel one to many (Polymorphic) 當中, 以下的 table structure 中的 commentable_id 以及 commentable_type 代表什麼？ posts id - integer title - string body - textvideos id - integer title - string url - stringcomments id - integer body - text commentable_id - integer commentable_type - string commentable_id: 代表 foreign key commentable_type: 代表 relation 的 model name Model Structure Laravel 當中, 假設每一個 Video model 以及 Post model 都有多個 Comment model, 現在我要定義一個 one to many (polymorphic) relation, 若要從 Video model 中定義與 Comment model 的 relation, 可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Video extends Model&#123; /** * Get all of the video's comments. */ public function comments() &#123; return $this-&gt;morphMany('App\\Comment', 'commentable'); &#125;&#125; Laravel 當中, 假設每一個 Video model 以及 Post model 都有多個 Comment model, 現在我要定義一個 one to many (polymorphic) relation, 若要從 Post model 中定義與 Comment model 的 relation, 可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get all of the post's comments. */ public function comments() &#123; return $this-&gt;morphMany('App\\Comment', 'commentable'); &#125;&#125; Laravel 當中, 假設每一個 Video model 以及 Post model 都有多個 Comment model, 現在我要定義一個 one to many (polymorphic) relation, 若要從 Comment model 中定義與 Post 以及 Video model 的 relation, 可以怎麼做？ &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * Get the owning commentable model. */ public function commentable() &#123; return $this-&gt;morphTo(); &#125;&#125; Retrieving The Relationship Laravel one to many (Polymorphic) relation 當中, 如果我要從 parent model 取得 child model, 我可以怎麼做？ 假設以下為我的 relation 定義 Relation 定義： &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * Get the owning commentable model. */ public function commentable() &#123; return $this-&gt;morphTo(); &#125;&#125;class Post extends Model&#123; /** * Get all of the post's comments. */ public function comments() &#123; return $this-&gt;morphMany('App\\Comment', 'commentable'); &#125;&#125;class Video extends Model&#123; /** * Get all of the video's comments. */ public function comments() &#123; return $this-&gt;morphMany('App\\Comment', 'commentable'); &#125;&#125; 取得 relation &lt;?php$post = App\\Post::find(1);foreach ($post-&gt;comments as $comment) &#123; //&#125; 在 Laravel one to many (Polymorphic) relation 當中, 假設以下為我的 relation 定義, 現在我要從 child model 取得 parent model, 那我可以怎麼做？ relation 定義： &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * Get the owning commentable model. */ public function commentable() &#123; return $this-&gt;morphTo(); &#125;&#125;class Post extends Model&#123; /** * Get all of the post's comments. */ public function comments() &#123; return $this-&gt;morphMany('App\\Comment', 'commentable'); &#125;&#125;class Video extends Model&#123; /** * Get all of the video's comments. */ public function comments() &#123; return $this-&gt;morphMany('App\\Comment', 'commentable'); &#125;&#125; 取得 relation &lt;?php$comment = App\\Comment::find(1);$commentable = $comment-&gt;commentable; Many To Many (Polymorphic)Table Structure 在 Laravel many to many (Polymorphic) relation 當中, 假如說我有 video 跟 post model, 而兩者都跟 tag model 有 many to many 的關係, 那我可以怎樣定義我的 table?posts id - integer name - stringvideos id - integer name - stringtags id - integer name - stringtaggables tag_id - integer taggable_id - integer taggable_type - string Model Structure 在 Laravel many to many polymorphic relation 當中, 假如我有 Post 跟 Video model, 而兩者都與 Tag model 有 many to many 的 relationship, 現在我要在 Post 定義 many to many polymorphic relation, 我可以怎麼做？&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get all of the tags for the post. */ public function tags() &#123; return $this-&gt;morphToMany('App\\Tag', 'taggable'); &#125;&#125; Defining The Inverse Of The Relationship 在 Laravel many to many polymorphic relation 當中, 假如我有 Post 跟 Video model, 而兩者都與 Tag model 有 many to many 的 relationship, 現在我要在 Tag 定義 many to many polymorphic relation, 我可以怎麼做？&lt;?phpclass Tag extends Model&#123; /** * Get all of the posts that are assigned this tag. */ public function posts() &#123; return $this-&gt;morphedByMany('App\\Post', 'taggable'); &#125; /** * Get all of the videos that are assigned this tag. */ public function videos() &#123; return $this-&gt;morphedByMany('App\\Video', 'taggable'); &#125;&#125; Retrieving The Relationship Laravel many to many polymorphic relationship 當中, 如果我的 relation 定義如下, 現在我要從 Post model 取得 Tag relation, 我該怎麼做？ Relation 定義: &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Post extends Model&#123; /** * Get all of the tags for the post. */ public function tags() &#123; return $this-&gt;morphToMany('App\\Tag', 'taggable'); &#125;&#125; Answer: &lt;?php$post = App\\Post::find(1);foreach ($post-&gt;tags as $tag) &#123; //&#125; Laravel many to many polymorphic relationship 當中, 如果我的 relation 定義如下, 現在我要從 Tag model 取得 Post relation, 我該怎麼做？ Relation 定義： &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Tag extends Model&#123; /** * Get all of the posts that are assigned this tag. */ public function posts() &#123; return $this-&gt;morphedByMany('App\\Post', 'taggable'); &#125; /** * Get all of the videos that are assigned this tag. */ public function videos() &#123; return $this-&gt;morphedByMany('App\\Video', 'taggable'); &#125;&#125; Answer: &lt;?php$tag = App\\Tag::find(1);foreach ($tag-&gt;videos as $video) &#123; //&#125; Custom Polymorphic Types 在 Laravel polymorphic relationship 當中, 預設 commentable_type 的內容會是像什麼樣的？model 的名稱, 像是 App\\Post 或是 App\\Video 在 Laravel polymorphic relationship 當中, polymorphic 關係的對應預設是依照 polymorphic type column 中的值來對應的, 格式預設是 App/ModelName, 如果我不想要使用這個預設格式, 我想要變更的話, 我可以在什麼地方變更？AppServiceProvider 的 boot function 內 在 Laravel polymorphic relationship 當中, 如果我要在 AppServiceProvider 當中自定義 polymorphic table 中的 type column 的值, 我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Relations\\Relation;Relation::morphMap([ 'posts' =&gt; 'App\\Post', 'videos' =&gt; 'App\\Video',]); 在 Laravel polymorphic relationship 當中, 如果我在 AppServiceProvider 當中自定義 polymorphic table 中的 type column 的值之後, 原本的 App\\Post 形式的 model 名稱需要依照自定義的名稱做變更嗎？需要哦 Querying Relations Laravel query 當中, 當我使用 orWhere 時, 如果我要限制 where condition 的範圍, 我可以怎麼做？&lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$user-&gt;posts() -&gt;where(function (Builder $query) &#123; return $query-&gt;where('active', 1) -&gt;orWhere('votes', '&gt;=', 100); &#125;) -&gt;get();// select * from posts// where user_id = ? and (active = 1 or votes &gt;= 100) Querying Relationship Existence 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我只要取得至少有一個 Comment 的 Post, 那我可以怎麼做？ &lt;?php// Retrieve all posts that have at least one comment...$posts = App\\Post::has('comments')-&gt;get(); 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我只要取得有三個以上 Comment 的 Post, 那我可以怎麼做？ &lt;?php// Retrieve all posts that have three or more comments...$posts = App\\Post::has('comments', '&gt;=', 3)-&gt;get(); 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我只要取得有至少一個以上 Comment 的 Post, 且這個 comment 的 content 要含有 ‘foo’, 那我可以怎麼做？ &lt;?php// Retrieve posts with at least one comment containing words like foo%...$posts = App\\Post::whereHas('comments', function (Builder $query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;)-&gt;get(); 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我只要取得有十個以上 Comment 的 Post, 且 10 個 Comment 的 content 都要含有 ‘foo’, 那我可以怎麼做？ &lt;?php// Retrieve posts with at least ten comments containing words like foo%...$posts = App\\Post::whereHas('comments', function (Builder $query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;, '&gt;=', 10)-&gt;get(); Querying Relationship Absence 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我要取得沒有任何 comments 的 post, 那我可以怎麼做？ &lt;?php$posts = App\\Post::doesntHave('comments')-&gt;get(); 在 Laravel relationship 當中, 假如我的 Post model 與 Comment model 關聯, 我要取得沒有某些特定 comment 的 post, 而這些特定的 comment 的 content 會含有 ‘foo’, 那我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::whereDoesntHave('comments', function (Builder $query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;)-&gt;get(); 在 Laravel relationship 中, 假設我有 post, comment, 以及 author Model, 現在我要取得 comment 的 author 未被 banned 的 post (以 post 的 comment 的 author 為條件 query), 那我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::whereDoesntHave('comments.author', function (Builder $query) &#123; $query-&gt;where('banned', 1);&#125;)-&gt;get(); Querying Polymorphic Relationships 在 Laravel polymorphic relationship 當中, 假如 Post 與 Video Model 都有多個 Comment Model, 現在我要取得 comment, 所屬的 video 或 post 的 title 含有 foo%, 那我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;// Retrieve comments associated to posts or videos with a title like foo%...$comments = App\\Comment::whereHasMorph( 'commentable', ['App\\Post', 'App\\Video'], function (Builder $query) &#123; $query-&gt;where('title', 'like', 'foo%'); &#125;)-&gt;get(); Laravel 中, 如果今天我的 Comment model 與 video 以及 post 有 polymorphic 的 relation, 那我想要取得 comment, 且該 comment 所屬的 post 的 title 不可含有 foo, 那我可以怎麼做？ &lt;?php// Retrieve comments associated to posts with a title not like foo%...$comments = App\\Comment::whereDoesntHaveMorph( 'commentable', 'App\\Post', function (Builder $query) &#123; $query-&gt;where('title', 'like', 'foo%'); &#125;)-&gt;get(); Laravel 中, 假如 Post model, Video model 與 Comment model 有 polymorphic 的關係, 現在我想要取得某些 Comment, 條件是 Video 的 title 必須含有 foo, 而 Post 的 title 或 content 必須含有 foo, 那我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$comments = App\\Comment::whereHasMorph( 'commentable', ['App\\Post', 'App\\Video'], function (Builder $query, $type) &#123; $query-&gt;where('title', 'like', 'foo%'); if ($type === 'App\\Post') &#123; $query-&gt;orWhere('content', 'like', 'foo%'); &#125; &#125;)-&gt;get(); Laravel polymorphic relationship 中, Comment model 與很多其他的 model 都有 morph relation, 如果我要一次性取得所有的 morph model, 不管我有幾個, 並且從這些 relation 當中搜尋任何 title 含有 foo 的 comment, 那我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$comments = App\\Comment::whereHasMorph('commentable', '*', function (Builder $query) &#123; $query-&gt;where('title', 'like', 'foo%');&#125;)-&gt;get(); Counting Relate Models Laravel relationship 中, 假設今天我的 Post model 有很多 Comment model, 我想要拿到每個 Post model 下有幾個 Comment model, 那我可以怎麼做？ &lt;?php$posts = App\\Post::withCount('comments')-&gt;get();foreach ($posts as $post) &#123; echo $post-&gt;comments_count;&#125; Laravel relationship 中, 假設今天我的 Post model 有 votes 以及 comments 的 relationships, 如果我現在想要取得每個 Post model 當中有幾個 Vote 跟 Comment, 其中, Comment 有特殊的條件, Comment 的 content 必須含有 foo, 那我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::withCount(['votes', 'comments' =&gt; function (Builder $query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;])-&gt;get();echo $posts[0]-&gt;votes_count;echo $posts[0]-&gt;comments_count; Laravel relationship 中, 當我使用了 withCount method, Laravel 會在取得的 model 中加入哪一個欄位？{relation}_count Laravel relationship 中, 假設今天我的 Post model 有 comments 的 relationships, 假如現在我要取得每個 Post 有幾個 comment, 以及我要自定義一個 comment 叫做 pending_comments_count, 條件是該 comment 的 approved 必須是 false, 那我可以怎麼做？ &lt;?phpuse Illuminate\\Database\\Eloquent\\Builder;$posts = App\\Post::withCount([ 'comments', 'comments as pending_comments_count' =&gt; function (Builder $query) &#123; $query-&gt;where('approved', false); &#125;,])-&gt;get();echo $posts[0]-&gt;comments_count;echo $posts[0]-&gt;pending_comments_count; Laravel Query Builder 當中, 如果我要同時使用 select 以及 withCount, 哪一種需排在前面？select Laravel 當中, 如果說現在我要同時取得 Post 中的 title 以及 body 欄位, 以及其 relation comments 的數量, 那我可以怎麼做？ &lt;?php$posts = App\\Post::select(['title', 'body'])-&gt;withCount('comments')-&gt;get();echo $posts[0]-&gt;title;echo $posts[0]-&gt;body;echo $posts[0]-&gt;comments_count; Laravel 當中, 如果我的 Book model 有很多 genres model relation, 現在我已取得特定的那一個 Book model, 我要再取得所屬的 genres 的數量, 那我可以怎麼做？ &lt;?php$book = App\\Book::first();$book-&gt;loadCount('genres'); Laravel 當中, 如果我的 Book model 有很多 reviews relation, 現在我已取得特定的那一個 Book model, 我要再取得所屬的 reviews 的數量, 但有一個特別的條件, 那就是 reviews 的 rating 必須要等於 5, 那我可以怎麼做？ &lt;?php$book-&gt;loadCount(['reviews' =&gt; function ($query) &#123; $query-&gt;where('rating', 5);&#125;]) Eager Loading 以下的 Laravel 程式碼中, author 為 book model 的 relation, 假設 $books 有 25 個 book model, 那以下的程式碼共會 query 幾次？ 程式碼: &lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; answer:26 次, 取所有的 book model 共花一次, 取各個 model 的 author relation 再花 25 次 Laravel 中, 假設以下為我的原始程式碼, 我要如何使用 eager loading 將所有的 author relation 一次取出? 原始程式碼： &lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; Answer: &lt;?php$books = App\\Book::with('author')-&gt;get();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; 以下的 Laravel 程式碼中, 實際上下的 MySQL query 是哪兩句？ 程式碼： &lt;?php$books = App\\Book::with('author')-&gt;get();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; query 語法: select * from booksselect * from authors where id in (1, 2, 3, 4, 5, ...) Eager Loading Multiple Relationships 在以下的 Laravel 程式碼中, 我如果想要一次性的 eager load relations author 跟 publisher, 我可以怎麼做？ 程式碼： &lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; Answer: &lt;?php$books = App\\Book::with(['author', 'publisher'])-&gt;get(); Nested Eager Loading 在以下的 Laravel 程式碼中, 如果我要一次性的 eager load book 的 author relation, 以及 author 的 contacts relation, 我可以怎麼做？ 程式碼： &lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; Answer: &lt;?php$books = App\\Book::with('author.contacts')-&gt;get(); Nested Eager Loading morphTo Relationships 如以下的 Laravel relation definition 當中, ActivityFeed 跟 Event, Photo, 以及 Post 有 morphTo 的關係。 現在假設, Event 與 calender 有關係, Photo 與 Tags 有關係, Post 與 author 有關係, 我要如何從 ActivityFeed 一次性的 eager load 撈出所有的 relationships? Relation definition &lt;?phpuse Illuminate\\Database\\Eloquent\\Model;class ActivityFeed extends Model&#123; /** * Get the parent of the activity feed record. */ public function parentable() &#123; return $this-&gt;morphTo(); &#125;&#125; Answer: &lt;?phpuse Illuminate\\Database\\Eloquent\\Relations\\MorphTo;$activities = ActivityFeed::query() -&gt;with(['parentable' =&gt; function (MorphTo $morphTo) &#123; $morphTo-&gt;morphWith([ Event::class =&gt; ['calendar'], Photo::class =&gt; ['tags'], Post::class =&gt; ['author'], ]); &#125;])-&gt;get(); Eager Loading Specific Columns 在以下的 Laravel 程式碼中, 如果我只想要 eager load author relation 中的 id 以及 name columns, 我可以怎麼做？ 程式碼: &lt;?php$books = App\\Book::all();foreach ($books as $book) &#123; echo $book-&gt;author-&gt;name;&#125; Answer: &lt;?php$books = App\\Book::with('author:id,name')-&gt;get(); 在 Laravel 當中, 如果說我今天使用 eager loading 來取得部份的 column, 有哪一個 column 是必須的？id Eager Loading By Default 在以下的 Laravel relation definition 當中, 如果說我想要預設 eager load author 這一個 relation, 那我可以怎麼做？ Relation definition: &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Book extends Model&#123; /** * Get the author that wrote the book. */ public function author() &#123; return $this-&gt;belongsTo('App\\Author'); &#125;&#125; Answer: &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Book extends Model&#123; /** * The relationships that should always be loaded. * * @var array */ protected $with = ['author']; /** * Get the author that wrote the book. */ public function author() &#123; return $this-&gt;belongsTo('App\\Author'); &#125;&#125; 在以下的 Laravel relation definition 當中, 如果說我想要從某次的 query 當中移除 $with 所賦予的 default eager loading 效果, 那我可以怎麼做？ Relation definition: &lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Book extends Model&#123; /** * The relationships that should always be loaded. * * @var array */ protected $with = ['author']; /** * Get the author that wrote the book. */ public function author() &#123; return $this-&gt;belongsTo('App\\Author'); &#125;&#125; Answer: &lt;?php$books = App\\Book::without('author')-&gt;get(); Constraining Eager Loads 在以下的 Laravel eager loading 範例程式碼中, 如果我想要指定 eager load title 含有 first 的 posts model, 那我可以怎麼做？ 範例程式碼: &lt;?php$users = App\\User::with('posts')-&gt;get(); Answer: &lt;?php$users = App\\User::with(['posts' =&gt; function ($query) &#123; $query-&gt;where('title', 'like', '%first%');&#125;])-&gt;get(); 在以下的 Laravel 範例程式碼中, 我可以加入額外的 query builder method 嗎？ 範例程式碼: &lt;?php$users = App\\User::with(['posts' =&gt; function ($query) &#123; $query-&gt;where('title', 'like', '%first%');&#125;])-&gt;get(); Answer:可以 Laravel eager loading constrain 當中, 像是以下的 Laravel 範例程式碼, 有哪些 query builder method 不適用？ 範例: &lt;?php$users = App\\User::with(['posts' =&gt; function ($query) &#123; $query-&gt;orderBy('created_at', 'desc');&#125;])-&gt;get(); Answer:limit 及 take Lazy Eager Loading 假如我的 Book model 有 author 以及 publisher 的 relation, 但我想要在特定的條件下才 eager load relation 如以下的範例程式碼, 那我可以怎麼做？ 範例程式碼: &lt;?php$books = App\\Book::all();if ($someCondition) &#123; // eager load here&#125; Answer: &lt;?php$books = App\\Book::all();if ($someCondition) &#123; $books-&gt;load('author', 'publisher');&#125; 在以下的 Laravel 範例程式碼中, 如果我想要 lazy eager load books, 並加入 orderBy(&#39;published_date&#39;, &#39;asc&#39;) 的 query constraint, 我可以怎麼做？ 範例程式碼: &lt;?php$author-&gt;load('books'); Answer: &lt;?php$author-&gt;load(['books' =&gt; function ($query) &#123; $query-&gt;orderBy('published_date', 'asc');&#125;]); Laravel 中, 如果我要 lazy eager loading 尚未 load 過的 relation, 我可以怎麼做？&lt;?phppublic function format(Book $book)&#123; $book-&gt;loadMissing('author'); return [ 'name' =&gt; $book-&gt;name, 'author' =&gt; $book-&gt;author-&gt;name, ];&#125; Nested Lazy Eager Loading &amp; morphTo Laravel 中, 假設我有一個 ActivityFeed Model, 它跟 Event, Photo, Post Model 有 morphTo 的關係, 如下面範例。 而 Event 又與 Calendar 有關, Photo 與 Tag 有關, 而 Post 與 Author 有關。 現在我要先 eager load ActivityFeed 的 morphTo 關係, 再使用 lazy eager loading 取得以上 morphTo 各自的 relationship, 我可以怎麼做？ 範例 relation: &lt;?phpuse Illuminate\\Database\\Eloquent\\Model;class ActivityFeed extends Model&#123; /** * Get the parent of the activity feed record. */ public function parentable() &#123; return $this-&gt;morphTo(); &#125;&#125; Answer: &lt;?php$activities = ActivityFeed::with('parentable') -&gt;get() -&gt;loadMorph('parentable', [ Event::class =&gt; ['calendar'], Photo::class =&gt; ['tags'], Post::class =&gt; ['author'], ]); Inserting &amp; Updating Related ModelsThe save method 在 Laravel 當中, 如果說我一個 Post model 有許多 Comment model, 在以下的範例程式碼中, 除了直接對 comment model 做操作之外, 我要如何儲存 comment 與 post 之間的 relation? 範例程式碼: &lt;?php$comment = new App\\Comment(['message' =&gt; 'A new comment.']);$post = App\\Post::find(1); Answer: &lt;?php$comment = new App\\Comment(['message' =&gt; 'A new comment.']);$post = App\\Post::find(1);$post-&gt;comments()-&gt;save($comment); 在 Laravel 當中, 在以下的範例程式碼當中, 我要如何一次儲存複數的 model? 範例程式碼: &lt;?php$comment = new App\\Comment(['message' =&gt; 'A new comment.']);$post = App\\Post::find(1);$post-&gt;comments()-&gt;save($comment); Answer: &lt;?php$post = App\\Post::find(1);$post-&gt;comments()-&gt;saveMany([ new App\\Comment(['message' =&gt; 'A new comment.']), new App\\Comment(['message' =&gt; 'Another comment.']),]); Recursively Saving Models &amp; Relationships 以下的 Laravel 程式碼代表什麼意思? 程式碼: &lt;?php$post = App\\Post::find(1);$post-&gt;comments[0]-&gt;message = 'Message';$post-&gt;comments[0]-&gt;author-&gt;name = 'Author Name';$post-&gt;push(); Answer: 指定 post 的 comment relation 的第一個 model 的 message 為 ‘Message’ 指定 post 的 comment relation 的第一個 model 的 author relation 的 name 為 ‘Author Name’ Laravel 當中, 如果我的 relation 是 Post-&gt;hasMany-&gt;comment, 現在我要變更第一個 comment 的 message 欄位為 ‘Message’, 以及 comment 的 author relation 的 name 欄位為 ‘Author Name’, 我可以怎麼做？&lt;?php$post = App\\Post::find(1);$post-&gt;comments[0]-&gt;message = 'Message';$post-&gt;comments[0]-&gt;author-&gt;name = 'Author Name';$post-&gt;push(); The create Method Laravel relationship 當中, save 跟 create method 的差別在於？ save 接受的參數為 model create 接受的參數為 array 以下的 Laravel 程式碼代表什麼意思？ 程式碼: &lt;?php$post = App\\Post::find(1);$comment = $post-&gt;comments()-&gt;create([ 'message' =&gt; 'A new comment.',]); Answer:使用 array 內的資料來建立一筆 Post 與 Comment 的關係 Laravel relation 中, 如果我的 relation 是 Post-&gt;hasMany-&gt;comments, 現在我要帶入 array 來建立新的 relational comment, 我可以怎麼做？ &lt;?php$post = App\\Post::find(1);$comment = $post-&gt;comments()-&gt;create([ 'message' =&gt; 'A new comment.',]); 以下的 Laravel 程式碼中, 該怎麼儲存 post 與 comment 的 relation? 程式碼: &lt;?php$post = App\\Post::find(1);$comment = ['message' =&gt; 'A new comment.']; Answer: &lt;?php$post = App\\Post::find(1);$comment = ['message' =&gt; 'A new comment.'];$comment = $post-&gt;comments()-&gt;create($comment); 以下的 Laravel 程式碼中, 我該怎麼使用定義好的多個 array 來建立 post-&gt;hasMany-&gt;comments 的 relation? 程式碼: &lt;?php$post = App\\Post::find(1);$comment1 = ['message' =&gt; 'A new comment.'];$comment2 = ['message' =&gt; 'Another new comment.']; Answer: &lt;?php$post = App\\Post::find(1);$post-&gt;comments()-&gt;createMany([$comment1, $comment2]); 如果我要使用多個 array 來建立 relation, 我可以使用哪一個 method?createMany Belongs To Relationships 以下的 Laravel 程式碼是什麼意思？ 程式碼: &lt;?php$account = App\\Account::find(10);$user-&gt;account()-&gt;associate($account);$user-&gt;save(); Answer: 取得目標 account 在該 user 的 account relation 中新增上面取得的 account model 以下的 Laravel 程式碼是什麼意思？ 程式碼: &lt;?php$manager = auth()-&gt;user();$sub_account-&gt;manager()-&gt;dissociate();$sub_account-&gt;save(); Answer: sub_account belongs to manager 將 sub_account 的 foreign key 設為 null 以下的 Laravel 程式碼是什麼意思？ 程式碼: &lt;?php$manager = auth()-&gt;user();$sub_account-&gt;manager()-&gt;associate($manager);$sub_account-&gt;save(); Answer: sub_account belongs to manager 將 sub_account 的 foreign key 設為 $manager 以下的 Laravel 程式碼中, $manager 可以是什麼？ 程式碼: &lt;?php$manager = auth()-&gt;user();$sub_account-&gt;manager()-&gt;associate($manager);$sub_account-&gt;save(); Answer: Eloquent Model 也可以是任意字元, 會儲存在 foreign key Laravel relation 當中, 如果我要更新 belongs to 的 relation, subAccount belongs to Manager, 如下面的程式碼中, 我已取得 manager 的 model, 除了直接使用 update method 去更新該 table 之外, 我可以使用哪個 method? 程式碼: &lt;?php$manager = App\\Manager::find(10); Answer: &lt;?php$manager = App\\Manager::find(10);$sub_account-&gt;manager()-&gt;associate($manager);$sub_account-&gt;save(); Laravel relation 當中, 如果我要移除 belongs to 表格的 relation, 除了直接使用 update method 去更新該 table 之外, 我可以使用哪個 method? &lt;?php$sub_account-&gt;manager()-&gt;dissociate();$sub_account-&gt;save(); Default Models Laravel 當中, 哪些種類的 relation 可以定義 default model? belongsTo hasOne hasOneThrough morphOne Laravel 當中, 如果我的 relation definition 如下, 現在我要定義一個 default model, name 為 guest author 我可以怎麼做？ 範例程式碼: &lt;?php/** * Get the author of the post. */public function user()&#123; return $this-&gt;belongsTo('App\\User');&#125; Answer 1: &lt;?php/** * Get the author of the post. */public function user()&#123; return $this-&gt;belongsTo('App\\User')-&gt;withDefault([ 'name' =&gt; 'Guest Author', ]);&#125; Answer 2: &lt;?php/** * Get the author of the post. */public function user()&#123; return $this-&gt;belongsTo('App\\User')-&gt;withDefault(function ($user, $post) &#123; $user-&gt;name = 'Guest Author'; &#125;);&#125; 以下的 Laravel relation definition, 如果該 relation 不存在, 會回傳什麼？ 範例 relation definition: &lt;?php/** * Get the author of the post. */public function user()&#123; return $this-&gt;belongsTo('App\\User')-&gt;withDefault([ 'name' =&gt; 'Guest Author', ]);&#125; Answer: &#123; \"name\": \"Guest Author\"&#125; Many To Many RelationshipsAttaching / Detaching Laravel many to many relation 中, 如果我要單純新增一筆 relation 紀錄, 我可以怎麼做? &lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;attach($roleId); Laravel many to many relation 中, 如果我要單純新增一筆 relation 紀錄, 然後我還要再在額外的欄位寫入資訊, 那我可以怎麼做? &lt;?php$user-&gt;roles()-&gt;attach($roleId, ['expires' =&gt; $expires]); Laravel many to many relation 中, 如果我要單純的移除一筆 relation 紀錄, 我可以怎麼做？ &lt;?php// Detach a single role from the user...$user-&gt;roles()-&gt;detach($roleId); Laravel many to many relation 中, 如果我要單純的移除多筆筆 relation 紀錄, 我可以怎麼做？ &lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;detach([1, 2, 3]); Laravel many to many relation 中, 如果我要移除該 model 下所有的 relation 紀錄, 我可以怎麼做？ &lt;?php$user-&gt;roles()-&gt;detach(); Laravel many to many relation 中, 如果我要新增多筆 relation 紀錄, 然後我還要再在額外的欄位寫入資訊, 那我可以怎麼做? &lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;attach([ 1 =&gt; ['expires' =&gt; $expires], 2 =&gt; ['expires' =&gt; $expires],]); Laravel many to many relation 中, 帶入一筆或多筆 relation 紀錄, 資料庫內需與帶入的資料完全符合, 沒有的新增, 多的刪除, 那我可以怎麼做？ &lt;?php$user-&gt;roles()-&gt;sync([1, 2, 3]); Laravel many to many relation 中, 帶入一筆或多筆 relation 紀錄, 資料庫內需與帶入的資料完全符合, 沒有的新增, 多的刪除, 我還要再額外的欄位新增資訊, 那我可以怎麼做？ &lt;?php$user-&gt;roles()-&gt;sync([1 =&gt; ['expires' =&gt; true], 2, 3]); Laravel many to many relation 中, 如果我要帶入一筆或多筆紀錄, 資料庫內若無資料則新增, 若有則保留不刪除, 那我可以怎麼做？ &lt;?php$user-&gt;roles()-&gt;syncWithoutDetaching([1, 2, 3]); Toggling Associations Laravel many to many relation 中, 如果我要帶入一組 relation 紀錄, 資料庫裡頭, 若沒有則則新增, 若有的話則移除, 那我可以怎麼做？&lt;?php$user-&gt;roles()-&gt;toggle([1, 2, 3]); Saving Additional Data On A Pivot Table Laravel many to many relation 中, 如果我要新增一筆 relation 紀錄, 同時如果此 relation 的對象不存在的話則建立, 再建立 relation 紀錄, 那我可以怎麼做？&lt;?phpApp\\User::find(1)-&gt;roles()-&gt;save($role, ['expires' =&gt; $expires]); Updating A Record On A Pivot Table Laravel many to many relation 中, 如果我要更新目前已經存在, 位於中間表格裡的 relation 紀錄, 那我可以怎麼做？$attribute 是一個 array&lt;?php$user = App\\User::find(1);$user-&gt;roles()-&gt;updateExistingPivot($roleId, $attributes); Touching Parent Timestamps Laravel many to many relation 中, 如果當我更新了中間表格的 relation timestamps 時, 我也想要一併更新 parent table 的 timestamp, 我可以怎麼做？&lt;?php&lt;?phpnamespace App;use Illuminate\\Database\\Eloquent\\Model;class Comment extends Model&#123; /** * All of the relationships to be touched. * * @var array */ protected $touches = ['post']; /** * Get the post that the comment belongs to. */ public function post() &#123; return $this-&gt;belongsTo('App\\Post'); &#125;&#125;","link":"/zh-tw/laravelEloquentORMRelationships/"},{"title":"使用 Stackdriver 在 Kubernetes Engine 上做紀錄","text":"概述Stackdriver Logging 可以讓你在所有的 GCP 資源，或是其他平台的資源做紀錄，然後針對紀錄以及指標做集中式的儲存。 紀錄被加總，並且可在提供的 Stackdriver Logging UI 內被檢視。 他們也可以被匯出到接收器來支援更多使用情境。 目前， Stackdriver Logging 支援匯出到下面的接收器: Cloud Storage Pub/Sub BigQuery 在這個教程，你將會部署一個簡單的 Kubernetes 應用，這個應用將轉發紀錄事件到 Stackdriver Logging 。 Terraform 一個強調基礎架構就是程式碼的工具， 可以使用配置檔來自動化部署，是雲端基礎架構的進化。 配置檔同時也會建立一個 Cloud Storage 儲存區，以及 BigQuery 資料組來接受被匯出的紀錄 本教程由 GKE Helmsman 的工程師所建立，為了讓你對 Stackdriver Logging 有更好地理解。 你可以在 Github 上檢視這個範例。 我們也鼓勵以及歡迎任何想對我們專案做出貢獻的開發者！ 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 架構Terraform 配置將會建立一個 Kubernetes Engine 叢集，這個叢集會產生可被 Stackdriver 處理的紀錄以及指標。 這個腳本也會同時建立紀錄的匯出接收器，有 CloudStorage, BigQuery, 以及 Cloud Pub/Sub。 這一切包含資料流，可參考下面的圖片 設定及要求 Qwiklabs setup在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Quiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Quiclabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Clone 範例clone 本教程需要的資源，執行以下指令git clone https://github.com/GoogleCloudPlatform/gke-logging-sinks-demo 進到專案內cd gke-logging-sinks-demo 設定你的 region 和 zone某些 Compute Engine 的資源位於 regions 以及 zones 。 region 是一個特定的地理位置，你只能在這個執行 region 運行你的資源, 每一個 region 有一個或多個 zone 如果你想要了解更多有關 region 以及 zone, 可以參考官方文件 執行以下指令來設定本教程中的 region 以及 zone (你可以使用對你來說最佳的 region 跟 zone) 部署遵從 程式碼及基本架構 以及 不可改變的基礎架構 , Terraform 支援利用陳述性的描述來決定理想的基礎架構狀態。 當述詞被採用， Terraform 使用 GCP APIs 來提供以及更新資源的狀態已符合述詞。 Terraform 比較想要的狀態以及目前的狀態，所以漸進式增加的變更不需要刪除任何東西，或者重新開始，即可被套用。 例如說，Terraform 可以建立 GCP 專案以及 compute 執行個體等等… 甚至是設定一個 Kubernetes Engine 叢集，並且部署應用到上面。 當要求改變了，敘詞可以被更新，然後 Terraform 將會相對應的更新雲端基礎設施 這個範例將會開始一個 Kubernetes Engine 叢集，然後部署一個簡單的範例應用上去。 預設， GCP Kubernetes Engine 叢集內建一個事先配置好的 Fluented 收集器，他會轉發記錄到 Stackdriver 更新 provider.tf 檔案 在 Terraform 的 provider.tf 腳本中，移除 provider 版本 編輯 provider.tf 腳本nano ~/gke-logging-sinks-demo/terraform/provider.tf 如果檔案含有 google 提供者的靜態版本字串，像下圖一樣，請移除 ....provider &quot;google&quot; &#123; project = var.project version = &quot;~&gt; 2.10.0&quot;&#125; 儲存檔案 部署叢集 本教程提供的範例檔案中，有三個 Teffaform 的配置檔。 第一個， main.tf ，是一個 Terraform 的起始點。 他描述了會使用到的功能，以及會被操縱到的資源，還有會輸出的結果。 第二個檔案是 provider.tf , 這個檔案顯示 Terraform 指令的目標是哪一個雲端提供者以及其版本，在這個範例中，是 GCP 。 最後一個檔案是 variables.tf ，它含有一個變數清單，用來當作 Terraform 的輸入。 任何沒有在 variables.tf 但有用在 main.tf 的變數都會在執行過程中跳出。 要建立環境，可以執行以下指令make create 備註： 如果你收到跟 zone 變數相關的廢棄警告，請無視，繼續本教程 驗證如果在部署過程中沒有顯示任何錯誤，在幾分鐘之後，你應該會在 GCP 主控台看到 Kubernetes Engine 叢集 到 Navigation menu &gt; Kubernetes Engine 來看同一個被部署的應用 若要驗證這個範例是否正確的部署，執行make validate 輸出看起來如下： 現在，應用已經被部署到 Kubernetes Engine, 它可以產生紀錄資料，然後可以使用 Stackdriver 或其他工具來檢視它 產生紀錄這個使用 Terraform 部署的範例應用提供一個簡單網頁的功能。 每次你在瀏覽器打開這個應用，這個應用將會發布紀錄事件到 Stackdriver Logging 。 重整頁面幾次來產生一些紀錄事件。 要取得應用頁面的 URL , 執行以下步驟: 在 GCP 主控台，從 Navigation menu, 移動到 Networking section, 然後點擊 Network services 在預設的 Load balancing 頁面，點擊已經設定好的 TCP load balancer 在 Load balancer detail 頁面，最上面已被下標籤 Fronted 複製 IP:Port URL, 打開一個新的瀏覽器然後貼上，瀏覽器應該會顯示類似以下的畫面： 在 Stackdiver 的紀錄Stackdriver 提供 UI 介面來檢視紀錄事件。 基本的搜尋以及篩選的功能都有提供，當在 Debug 系統問題時，這非常的有用。 Stackdriver Logging 最適合用來檢視比較近的紀錄事件，若對長期紀錄事件有要求的使用者，應該考慮其他一些工具，下面會介紹到 若要存取 Stackdriver Logging 主控台，執行以下的步驟： 在 GCP 主控台，從 Navigation menu Stackdriver 區塊，選擇 Logging 變更資源篩選器 GKE Container &gt; stackdriver-logging &gt; default ( stackdriver-logging 是叢集，而 default 是命名空間) 在這個頁面上，你可以展開紀錄來檢視紀錄數據更多的細節 在紀錄主控台，你可以執行任何類型的文字搜尋，或是嘗試很多紀錄類型的篩選器，事件等級，時間區間等等 檢視紀錄匯出Terraform 配置建立了兩個紀錄匯出接收器。 若要檢視接收器，執行以下的步驟: 你應該還在 Stackdriver -&gt; Logging 頁面 在左邊導航選單，點擊 Exports 選單選項 這會導引你到 Exports 頁面，在紀錄匯出的清單，你應該會看到兩個接收器 在接收器右手邊點擊 context 選單 (三個小點), 然後選擇 Edit sink, 你可以編輯/檢視這些接受器 另外，在導航視窗的頂部點擊 Create Export 選項，你可以建立額外的客制匯出接收器 在 Cloud Storage 的紀錄紀錄事件可以被儲存在 Cloud Storage, 這是一個適合用來儲存歸檔資料的物件儲存系統。 Cloud Storage 儲存區的政策可以被配置，舉例來說，久置的資料可變為過期，然後自動刪除，而新的資料可以依照不同的類別被儲存，類別會影響到價格以及可用性。 Terraform 配置檔建立了一個 Cloud Storage 儲存區，名為 Stackdriver-gke-logging-, 中長期的紀錄都會被匯出，然後儲存在這。 在這個範例中，儲存類別被定義為 Nearline, 因為正式環境中，紀錄中長期的紀錄不會經常性地被儲存（這將有助於管理中長期儲存成本）。 在正式環境中，儲存區也可以包含一個生命週期的政策，他可以將內容移動到 Coldline 儲存區，這樣對長期儲存記錄的成本會更低 要在 Cloud Storage 存取 Stackdriver 紀錄, 執行下面的步驟： 在 GCP 主控台， 從 Navigation menu 點擊 Storage 找到名為 stackdriver-gke-logging-&lt;random-Id&gt; 的儲存區，點擊名稱 你應會看到一系列與跑到叢集中的 pod 相對應的資料夾 (就是， autoscaler, dnsmasq, 等等) 你可以點擊任何一個資料夾來瀏覽特定的紀錄細節，像是 heapster, kubedns, sidecar, 等等… 在 BigQuery 的紀錄Stackdriver 紀錄事件可以被設定成發佈在 BigQuery, 一個快速的，精細的，供龐大資料查詢的資料儲存工具 Terraform 配置將會建立一個 BigQuery 資料組, 名為 gke_logs_dataset。 這個資料組將會被設定成包含所有與 Kubernetes Engine 相關的距今一個小時的紀錄 (設定預設的資料組表格過期時間)。 Stackdriver 匯出將會被建立且將 Kubernetes Engine 容器紀錄推送到資料組 若想要從 BigQuery 存取 Stackdriver 紀錄，執行下面的步驟： 在 GCP 主控台的 Navigation menu, 在 Big Data 的區塊點擊 BigQuery 在左邊的選單，點擊你的專案名稱。 你應會看到一個名為 gke_logs_dataset 的資料組。 展開這個資料組來檢視存在的表格 ( Note: 這個資料組會立即被建立，但表格會再當紀錄產生了，且新的表格有需要時建立) 點擊其中一個表格來檢視表格細節 檢視表格結構，並且注意到欄位的名稱以及他們的資料類型。 這些資訊在你下一步要對表格做查詢時會用到 點擊右上方 Query Table 來對表格執行客製化查詢 這會在查詢編輯器裡增加一個查詢，你它有一個語法錯誤 編輯這個查詢，在 after 之後增加一個星號 (*) 來從這個表格調出所有的細節。 備註: 一個 Select * 查詢通常是非常昂貴，且不建議的。 在本教程中，資料組被限制上最近一個小時的紀錄，所以整體上資料庫的相對小的。 點擊 Run 來執行查詢，並且從表格得到一些結果 結果視窗應該會顯示一些行和列，你可以捲動回傳的多行資料。如果你想要，執行一些客制的查詢從原本查詢的結果中篩選一些特定的資料 刪除安裝Qwiklabs 會將所有本教程中使用到的資源關掉，但是這邊可能需要你做的是清理你的環境來節省成果，當一個好雲端公民！make teardown 因為 Terraform 有對所有建立的資源做追蹤，所以他可以將他們全部清除 正式環境的故障排除執行 Terraform 時，安裝腳本失敗了，並且回傳 Permission denied。Terraform 使用的帳號沒有提供必須的權限來在選擇的專案中建立資源。 確保列在 gcloud config list 中的專案有必要的權限來建立資源。 如果它有，使用 gcloud auth application-default login 來重新產生應用預設帳號 Cloud Storage 儲存區沒有載入 。一旦 Terraform 配置已經完成，那 Cloud Storage 儲存區將會被建立。 但不是每次都會立即地將 Kubernetes Engine 叢集中的紀錄資料立即載入。 給這個程序一點時間，因為他可能會花上最多 2-3 個小時讓第一筆資料出現。 (參考資料) BigQuery 資料組中沒有表格一旦 Terraform 配置完成， BigQuery 資料組將自動被建立但表格不會總是在你檢視結果的時候就已經建立。 表格很少立即的載入資訊。 給這個程序一點時間，(最少 5 分鐘), 在你下可能出錯的判斷之前。 恭喜，你已完成本教程","link":"/zh-tw/loggingWithStackdriverOnKubernetesEngine/"},{"title":"Markdown 學習筆記","text":"前言這是我的 Markdown 學習筆記，看什麼學什麼記什麼！ 特殊字符 符號 解釋 代碼 ← 左箭頭 &amp;larr; → 右箭頭 &amp;rarr; ↑ 上箭頭 &amp;uarr; ↓ 下箭頭 &amp;darr; ↔ 水平箭頭 &amp;harr; ↕ 豎直箭頭 &amp;varr; ⇐ 雙線左箭頭 &amp;lArr; ⇒ 雙線右箭頭 &amp;rArr; ⇑ 雙線上箭頭 &amp;uArr; ⇓ 雙線上箭頭 &amp;dArr; ⇔ 雙線水平雙箭頭 &amp;hArr; ⇕ 雙線豎直箭頭 &amp;vArr;","link":"/zh-tw/markdown/"},{"title":"Kubernetes - Resources Limit","text":"概述當你指定一個 Pod, 你可以選擇性的指定每個容器需要多少 CPU 以及 memory (RAM), 當你有指定 資源要求 (resource request) 給容器, scheduler 可以更加的分配 Pods 到 nodes 上。 而當你有指定容器的 資源限制 (resource limits), 在 node 上的資源競爭將以指定的方式來處理。 更多 requests 以及 limits 的不同之處可以參考 Resource QoS 資源類型CPU 以及 memory 為 資源類型 (resource type), 資源類型有其基本單位。 CPU 以 cores 為單位, 而 memory 以 bytes 為單位。 如果你使用的是 Kubernetes v1.14 或更新的版本, 你可以指定 巨頁 (huge page) 資源。 Huge pages 是 Linux 上特定的功能, node 的 kernel 可以分配比預設 page 更大的 memory。比如說, 在預設 page 大小為 4KiB 的系統, 你可以指定一個限制, hugepages-2Mi: 80Mi。 如果容器試圖分配超過 40 2MiB huge pages (總共 80MiB), 則分配將失敗。Ray 第一次聽到 Huge Page 的概念時也是 一臉矇逼, 不過本著學習者的心態 Google 了幾下之後, 就不再那麼矇了。簡單來說, memory 有過被管理的單位叫做 頁 (page), 在很多系統中預設是 4Ki, 所以 1Mi 的 memory 就有 256 pages, 沒問題吧？ 而有個硬體叫做 TLB (Translation Lookaside Buffer), 它是個大小固定的緩存硬體, 而虛擬記憶體對應實體記憶體的 mapping 會緩存 TLB 上。簡單來說, 如果是使用 4Ki 為 page 為單位的話, 那就要有很多 page, 而越多 page 記憶體的位置就需要越大的緩存去管理, 偏偏 TLB 這東西又是固定大小, 所以能怎麼做？ 那自然就是加大 page 的大小, 讓總 page 的數量下降, 這樣緩存就不需要那麼大的空間來記住那麼多的記憶體位置了。 這便是 huge page 的簡單概念, 更詳細一點的資料可以參考 這篇文章 注意: 跟 memory 以及 cpu 資源不同, 你無法過量使用 hugepages-* 資源 CPU 以及 memory 都被歸類在 compute resources, 或 resources。 Compute resources 為可被要求, 分配, 以及消耗的可量測數量。 他們與 [API resources] 不同。 API resources, 像是 Pod 以及 Services 為可通過 Kubernetes API server 讀取以及修改的物件。 Pod 以及 Container 的資源要求以及資源限制每個 Container 或 Pod 可被指定下列一個或多個條件： spec.containers[].resources.limits.cpu spec.containers[].resources.limits.memory spec.containers[].resources.limits.hugepages-&lt;size&gt; spec.containers[].resources.requests.cpu spec.containers[].resources.requests.memory spec.containers[].resources.requests.hugepages-&lt;size&gt; 儘管 requests 以及 limits 只可被指定再單獨的 Container 上, 但要計算出 Pod 的 request 以及 limits 也很方便。 Pod 對某項特定資源的 request/limit 就等於該 Pod 裡的所有容器的 request/limit 總和。 CPU 解釋CPU 資源的 limits 以及 requests 都以 cpu 為單位衡量。 1 cpu, 在 Kubernetes 中, 相當於以下單位: 1 AWS vCPU 1 GCP Core 1 Azure vCore 1 IBM vCPU 1 Hyperthread, Hyperthreading 的 Intel bare-metal 處理器 小數的資源請求是容許的。 spec.container[].resources.requests.cpu 如果設為 0.5, 那相當於要求 1 CPU 的一半。 0.1 相等於 100m, 100m 也可讀為 “100 millicpu”。 有些人說 “100 millicores”, 都可理解為同樣的東西。 有小數點的請求, 像是 0.1, 會被 API 轉換到 100m, 而精度最小為 1m, 所以設定 100m 會是比較理想的 CPU 都是絕對數字, 不會是相對數字; 舉例來說, 0.1 在 1-core, 2-core, 或 48-core 的機器中代表的量都是一樣的。 Memory 解釋Memory 中的 limits 以及 requests 資源管理以 bytes 為單位。 記憶體可被表示為簡單的 integer, 或固定位數的 integer, 可使用以下後綴： E, P, T, G, M, K 。 你也可以使用: Ei, Pi, Ti, Gi, Mi, Ki, 舉例來說, 下面都代表大約相同的值：128974848, 129e6, 129M, 123Mi 這邊有個範例, 下面的 Pod 含有兩個容器。 每個容器都有 resource requests, 0.25 cpu 以及 64MiB 記憶體。 每個容器都有 resource limits 0.5 cpu 以及 128 MiB 記憶體。 可以說, 這個 Pod 有 resource requests 0.5 cpu 以及 128 MiB 記憶體, resource limits 1 cpu 以及 256 MiB 記憶體apiVersion: v1kind: Podmetadata: name: frontendspec: containers: - name: db image: mysql env: - name: MYSQL_ROOT_PASSWORD value: \"password\" resources: requests: memory: \"64Mi\" cpu: \"250m\" limits: memory: \"128Mi\" cpu: \"500m\" - name: wp image: wordpress resources: requests: memory: \"64Mi\" cpu: \"250m\" limits: memory: \"128Mi\" cpu: \"500m\" 有 resource requests 的 Pod 是被如何調度的？當你建立 Pod, Kubernetes scheduler 會挑選一個 node 來運行該 Pod。 每個 node 針對每種資源類型都有最大容量: 也就是說, 有多少 CPU 以及 memory 可以分配給 Pods。 Scheduler 會確保被調度的容器的各類型資源總和會小於該 Node 的資源總量。 注意到, 就算 node 上的資源使用量非常低, 如果容量確認沒過的話, Scheduler 還是不會分配 Pod 到這個 node 上。 這確保在 node 上資源短缺, 比如說, 在每日的資源用量高峰。 有 resource limits 的 Pod 是如何被調度？當 Kubelet 啟動 Pod 中的一個 Container, 它會將 CPU 以及 memory limits 帶入到該 container runtime。當使用 Docker: spec.containers[].resources.requests.cpu 會被轉換成 core 值, 它可能會是有小數點的, 以及會被乘以 1024。 在 docker run 指令中使用 --cpu-shares, 可以設定比這更高的數字或 2 spec.containers[].resources.limits.cpu 會被轉換成 millicore 值以及乘以 100。 結果值為容器在每 100ms (也就是十分之一秒)的 CPU time 中可使用的總量, 容器無法使用超過被分到的 CPU 配額, 這個部分如果看不是很懂, 有興趣的話最下面會有補充說明。注意: 預設的 quota period 為 100ms, 最小為 1ms spec.containers[].resources.limits.memory 會被轉換成 integer, 如同 docker run 指令的 [--memory] flag 的效果 如果容器超出了其 memory limits 限制, 它會被終止。 如果它設置為可重啟, 跟其他的 runtime failure 一樣, kubelet 將會重啟它。如果容器超出了其 memory request 限制, 當 node memory 耗光了之後, 就會把該 Pod 砍了, Ray 看到這一段的時候也有點矇逼, 下面會再補充解釋！容器可能會或者可能不會被允許超出其 CPU limit 限制, 然而, 超出了也不會被砍了。要得知容器是否無法被分配, 或者因為資源限制被殺掉了, 可以參考 Troubleshooting 區塊 監控資源使用量資源使用率會以 Pod 狀態的部分回報 Troubleshooting 以下是幫助釐清觀念的 Q&amp;AKubernetes 的可計算資源管理中, 所指定的資源配額是絕對數字還是相對數字？絕對數字 Kubernetes compute resource management 中, 如果我 CPU 設為 0.1, 在單核, 雙核, 甚至 48核的機器中, 代表的量會有所不同嗎？不會哦 什麼是 TLB?Translation lookaside buffer, 緩存虛擬記憶體到實體記憶體的 mapping 在 Linux 系統中, 虛擬記憶體管理系統中, 最小的 memory 單位是什麼？page Kubernetes resource limit management 中, huge page 是什麼?size 較大的 page Kubernetes 中, 如果一個 Pod 卡在 pending status, 那很有可能是甚麼原因？沒有 Node 有足夠的資源來運行這個 Pod Kubernetes 中, Resource 的限制可分為 CPU 以及 Memory, 限制類型主要分成哪兩種？ Request Limit Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, request 主要代表的是？這個 Pod 正常需要多少的資源可以正常運行 Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 在 Kubernetes 各元件當中, request resource 對哪一個元件格外重要？scheduler Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 在 Kubernetes 各元件當中, limit resource 對哪一個元件格外重要？kubelet Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 當 Scheduler 在選擇要在哪一個 Node 上面運行 Pod 時, 主要會考量哪一種類？request Kubernetes Resource 的限制又可分為 requests 以及 limits 兩大類, 當 Scheduler 跟 request 的關係是？Scheduler 會選擇有足夠資源 (request 要求的資源) 的 node 來運行該 pod 以下的 Kubernetes yaml 檔所代表的意思是? yaml 檔: resources: requests: cpu: 50m memory: 50Mi limits: cpu: 100m memory: 100Mi Answer: # 定義資源限制resources: # 定義 requests 種類限制, scheduler 會選擇有足夠 request 資源的 Node 來運行該 Pod requests: cpu: 50m memory: 50Mi # 定義 limits 種類限制, Kubelet 會根據 limits 資源來決定是否重啟該 Pod limits: cpu: 100m memory: 100Mi Kubernetes 中, 1 MiB 等於多少？1 MiB = 1024 KiB = 1024 * 1024 = 1048576 Bytes Kubernetes 中, 1 MB 等於多少？1 MB = 1000 KB = 1000 * 1000 = 1000000 Bytes Kubernetes 中, 一個 Pod 的資源總限制是 什麼 的總和？該 Pod 內所有容器的資源限制加總 Cgroup 的全寫是？Control Group Cgroup 簡單解釋?有著一系列相關屬性的容器, 控制 kernel 如何運行程序 Kubernetes resource limit 中, 當我們只設置 limits, 但沒設置 requests 時, 會發生什麼事？Kubernetes 會將 requests 設為 limits 的值 當宿主機面臨記憶體壓力時, 會做什麼事？會殺掉程序 當一個程序使用了超過在 cgroup 中規定的 memory 時, 會發生什麼事？該程序會被列入要殺掉的優先名單中 Server 中的 OOM 的全寫是??Out Of Memory Kubernetes resource limit 當中, 當我設定了 requests 的限制, Kubernetes 會否要求 docker 去設定 memory cgroup 中的 soft_limit?不會 Kubernetes resource limit 當中, requests 若設得太高會發生什麼事？可能會出現沒有 node 可以運行這個 pod, 明明這個 pod 正常不會需要這麼高的 memory Kubernetes resource limit 當中, requests 若設得太低會發生什麼事？如果一個 node 的剩餘空間已經沒有很多了, 因為 request 設得低, 所以依然會被分派到這個 node, 但該 pod 實際需要的資源遠高於 request 值, 所以該 node 面臨記憶體壓力時就會優先砍掉這個 pod Kubernetes 中, 一個 core 為幾 m?1000 m Kubernetes 將一個 core 分成幾份？1000 Docker 將一個 core 分成幾份？1024 CGroup 將一個 core 分成幾份？1024 Kubernetes 中, 當設定 memory 的 request limit 後, 會作用到 cgroup 嗎？不會 Kubernetes 中, 當設定 CPU 的 request limit 後, 會作用到 cgroup 嗎？會 Kubernetes resource limit 中, request resource 是由哪一個 cgroup 系統所管理的?cpu shares system cgroup cpu.cfs_period_us 中的 period 代表幾秒？1/10 秒 或 100000 microseconds (百萬分之一秒) cgroup cpu.cfs_quota_us 中的 quota 代表什麼？一個程序在 period 中容許可調用的最大值 假如我的 CPU request limit 是 200m, 那我的 cpu.cfs_period_us 以及 cpu.cfs_quota_us 分別是多少？ cpu.cfs_period_us: 100000 cpu.cfs_quota_us: 20000 cpu.cfs_period_us 跟 cpu.cfs_quota_us 是屬於哪一個 cgroup?cpu,cpuacct cpu.cfs_period_us 跟 cpu.cfs_quota_us 中的 cfs 的意思是?Completely Fair Scheduler Linux 的預設 CPU scheduler 是哪一個?CFS (Completely Fair Scheduler) Kubernetes 中, 當設定 CPU 的 request resource 限制, 會作用到 cgroup 嗎？會哦 Kubernetes 中, 程序可以超出 CPU request resource 限制 規定的用量嗎？不行 Kubernetes 中, 當程序使用了超過 CPU request resource 限制 規定的用量的話, 會發生什麼事？不會有這種情況, 因為 CPU request resource 限制 規定的用量不允許超出 Kubernetes resource limit 中, 如果我只設定了 limits, 但沒設定 requests, 會發生什麼事？requests 的預設值會被設為跟 limits 一樣 Kubernetes resource limit 中, 如果我只設定了 requests, 但沒設定 limits, 會發生什麼事？scheduler 會正常根據 requests 的資源數據啟動 pod, 但該 process 的資源使用量將無法被限制 以下的 Kubernetes yaml 設定檔的意思是? yaml 檔: apiVersion: v1kind: LimitRangemetadata: name: default-limitspec: limits: - default: memory: 100Mi cpu: 100m defaultRequest: memory: 50Mi cpu: 50m - max: memory: 512Mi cpu: 500m - min: memory: 50Mi cpu: 50m type: Container Answer: # API 版本apiVersion: v1# 種類為 LimitRangekind: LimitRange# 該 LimitRange 的 metadatametadata: # 該 LimitRange 的 name name: default-limit# 該 LimitRange 運行的規格spec: # 定義 limits limits: # 預設的 resource limits, 若該 namespace 下的 pod 在建立時沒有指定資源限制, 將套用此預設設定 - default: memory: 100Mi cpu: 100m # 預設的 resource requested, 若該 namespace 下的 pod 在建立時沒有指定資源限制, 將套用此預設設定 defaultRequest: memory: 50Mi cpu: 50m # 若欲在此 namespace 下建立 pod, 而該 pod 若指定資源限制高於此設定, 將不允許建立 - max: memory: 512Mi cpu: 500m # 若欲在此 namespace 下建立 pod, 而該 pod 若指定資源限制低於此設定, 將不允許建立 - min: memory: 50Mi cpu: 50m # 限制的類型為 container type: Container Kubernetes request resource 限制中, 1 core = 1000 m, 那允許的最小設定值是多少？1m Kubernetes 中, 要如何查看 node 有多少可用資源？kubectl describe nodes nodeName Kubernetes 中, 如何知道容器有沒有因為資源達到限制而被砍掉？ 取得 pod 資訊 kube describe pod podName 取得前一個 pod 被砍掉的原因 kubectl get pod -o go-template='&#123;&#123;range.status.containerStatuses&#125;&#125;&#123;&#123;\"Container Name: \"&#125;&#125;&#123;&#123;.name&#125;&#125;&#123;&#123;\"\\r\\nLastState: \"&#125;&#125;&#123;&#123;.lastState&#125;&#125;&#123;&#123;end&#125;&#125;' simmemleak-hra99 Kubernetes 中, local ephemeral storage 指的是什麼地方？root partition Kubernetes 中, emptyDir volumes, container logs, image layers, container writable layers, 這些都是使用哪一塊空間？root partition 以下的 Kubernetes yaml 檔是什麼意思呢？ yaml 檔 apiVersion: v1kind: Podmetadata: name: frontendspec: containers: - name: db image: mysql env: - name: MYSQL_ROOT_PASSWORD value: \"password\" resources: requests: ephemeral-storage: \"2Gi\" limits: ephemeral-storage: \"4Gi\" - name: wp image: wordpress resources: requests: ephemeral-storage: \"2Gi\" limits: ephemeral-storage: \"4Gi\" Answer: # API 版本apiVersion: v1# 種類為 Podkind: Pod# 該 Pod 的 metadatametadata: # 該 Pod 的 name name: frontend# 該 pod 運行的規格spec: # 定義容器規格 containers: # 容器名稱 - name: db # 鏡像名稱 image: mysql # 定義變數 env: # 變數名稱 - name: MYSQL_ROOT_PASSWORD # 變數值 value: \"password\" # 定義資源限制 resources: # 定義 requests 資源限制 requests: # 限制 ephemeral-storage ephemeral-storage: \"2Gi\" # 定義 limits 資源限制 limits: # 限制 ephemeral-storage ephemeral-storage: \"4Gi\" # 容器名稱 - name: wp # 鏡像名稱 image: wordpress # 定義資源限制 resources: # 定義 requests 資源限制 requests: # 限制 ephemeral-storage ephemeral-storage: \"2Gi\" # 定義 limits 資源限制 limits: # 限制 ephemeral-storage ephemeral-storage: \"4Gi\" Kubernetes, 哪一個元件依據 ephemeral-storage 資源分配 pod 到適當的 node?scheduler Kubernetes, 如果一個 pod 裡頭的某個容器的 writable layer 以及 logs 使用量超過的 ephemeral-storage 的資源限制, 會發生什麼事？該 pod 會被砍了 Kubernetes, 如果一個 pod 裡頭的所有容器使用的 ephemeral-storage 用量以及 emptyDir volumes 超過了資院限制, 會發生什麼事？該 pod 會被砍了 參考資源 Understanding resource limits in Kubernetes: memory Understanding resource limits in kubernetes: cpu time Docker Documentation Kubernetes Documentation Kubernetes/enhancements 概述Yo~ 這是針對 Kubernetes 的資源限制 (Resource Limits) 的一篇學習筆記, 探詢 requests 以及 limits 的用途, 不然都傻傻分不清楚！ 首先, 在概述會列出 Kubernetes 資源限制的一些規則, 如果你在這一節就找到你要的答案了, 那恭喜你, 慢走不送！ 接下來會有針對 Memory 以及 CPU 的剖析, 剖析什麼呢？ 會從 Kubernetes, 到 Docker, 最後到真正控制 Linux kernel 如何運行程序的 cgroup (Control Group), 一層層的抽絲剝繭！ 最後, 我們在學習的過程中, 尤其是資訊業, 一定會遇到排山倒海, 前仆後繼, 七上八下… 的疑惑, 這是無法避免的, 但也是 Ray 覺得資訊業的著迷之處。 所以啦, Ray 習慣每遇到一個問題就把它記下, 然後找出答案, 用 Q&amp;A 的方式記錄下來, 在下面 Q&amp;A 小節可以找到。 這樣方便 Ray 自己學習吸收, 也方便日後查找。 有興趣可以看看, 啥？你說你沒興趣？ 那你還在這幹嘛？ 還不快去找你有興趣的事！ 廢話不多說, 以下列出規則: 資源可限制的類型分為 requests 以及 limits 兩種, 每種都可以再指定各自限制的 memory 以及 CPU requests 為這個容器正常運行需要的資源, Scheduler 會根據該容器被指定的 requests 資源去挑選適合運行這個容器的 Node, Node 的可用資源需大於此容器被指定的 requests 資源, 這樣方可運行。 當沒有任何一個 Node 有大於該容器的 requests 資源限制的足夠可用資源時, 該容器將無法被建立, 會處於 pending 狀態 limits 為此容器最大可調用資源, 當該容器使用了超過被指定的資源限制後… 若該資源為 memory, 則該容器會被列在優先處決名單, 當 Node 的記憶體吃緊時, 會將這容器砍了, 此時 Kubelet 偵測到容器跟宣告的狀態不符, 就會再開一個新的。 若該資源為 CPU, 因為 cgroup 限制的關係, CPU 不會超過指定的資源限制。 若要了解更細節, 請參考頗析 Kubernetes 中, 1MB = 1000KB = 1000 * 1000 Bytes Kubernetes 中, 1MiB = 1024KiB = 1024 * 1024 Bytes Kubernetes 中, 1 core = 1000 m requests 資源若是設的太低, 則 Node 可輕易地啟動這個 pod, 可該 pod 實際的資源消耗量遠高於 requests 資源, 這樣一來, node 的資源耗費會比起它的預估高很多… 這就像是你交了一個普妹女朋友, 你看人家普妹妳就自以為是這個是低消耗的, 好維護！ 都叫你不要以貌取人了, 你不聽… 一餐吃掉你幾千塊, 一個禮拜刷你的卡買一個包包幾萬塊, 結果你在低估這件事的情況之下, 你就爆了, 嚷嚷要分手。 你看看你, 你這樣跟渣男有什麼分別？ 所以在設定 requests 資源時, 拒當渣男, 也不要製造渣 node, 好嗎？ 如果你只設了 limits, 沒設 requests, 那 Kubernetes 會將 requests 設的跟 limits 一樣, 如果你對你的 pod 資源耗費夠明瞭的話, 這樣倒也不是什麼大問題, 可通常我們會將 limits 設得稍微高一點, 你想想看, 你正常運行這個 pod 根本不需要這麼高的資源, 那是不是會變成每個 node 可運行該 pod 的數量變少了？ 頗析 (Memory)首先, 先針對 memory 的部分來頗析 limits 跟 requests 的詳細運作 建立一個沒有資源限制的 pod 輸入 kubectl run limit-test --image=busybox --command -- /bin/sh -c \"while true; do sleep 2; done\" 輸出 deployment.apps &quot;limit-test&quot; created 使用 Kubectl 來驗證看看 Kubernetes 是否建立沒有資源限制的 pod 輸入 kubectl get pods limit-test-7cff9996fc-zpjps -o=jsonpath='&#123;.spec.containers[0] .resources&#125;' 輸出 map[] 現在我們 ssh 到該 node, 然後使用以下指令看看 docker 是如何運行這個容器 輸入以下指令取得容器名稱 docker ps | grep busy | cut -d' ' -f1 得到容器名稱 5c3af3101afb 輸入指令取得容器限制的 memory value docker inspect 5c3af3101afb -f \"&#123;&#123;.HostConfig.Memory&#125;&#125;\" 得到輸出 0 .HostConfig.Memory 代表的意思是？對應到 docker run 的 –memory 參數 讓我們繼續往下追, 追到最終的 cgroup 取得容器 pid ps ax | grep /bin/sh 輸出 9513 ? Ss 0:00 /bin/sh -c while true; do sleep 2; done 取得該 pid cgroup sudo cat /proc/9513/cgroup 輸出 ...6:memory:/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574 kubepods: 程序將會繼承所有這個 group 中的屬性 burstable: 可參考burstable QOS class 取得細節, 將上面的路徑 append 到 /sys/fs/cgroups/memory ls -l /sys/fs/cgroup/memory/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574 輸出 ...-rw-r--r-- 1 root root 0 Oct 27 19:53 memory.limit_in_bytes-rw-r--r-- 1 root root 0 Oct 27 19:53 memory.soft_limit_in_bytes 先來看 memory.limit_in_bytes, 這是設定 memory limit 的 cgroup, 他等同於 docker 裡頭的 --memory, 以及 Kubernetes 限制的 memory limit 輸入以下指令取得數值 sudo cat /sys/fs/cgroup/memory/kubepods/burstable/podfbc202d3-da21-11e8-ab5e-42010a80014b/0a1b22ec1361a97c3511db37a4bae932d41b22264e5b97611748f8b662312574/memory.limit_in_bytes 輸出 9223372036854771712 這個數據代表沒有限制 memory, 可參考 Stackoverflow我們一開始在 Kubernetes 沒有設定 memory 限制, 導致 docker 建立一個 HostConfig.Memory 設定為 0 的容器, 最終導致這個容器的程序被放到 memory.limit_in_bytes 屬性設為 “no limit” 的 memory cgroup 現在讓我們來建立另外一個 pod, 限制 memory limit 為 100Mi 執行以下指令 kubectl run limit-test --image=busybox --limits \"memory=100Mi\" --command -- /bin/sh -c \"while true; do sleep 2; done\" 輸出 deployment.apps &quot;limit-test&quot; created 驗證這個 pod 有被設置特定的 limit 執行以下指令 kubectl get pods limit-test-5f5c7dc87d-8qtdx -o=jsonpath='&#123;.spec.containers[0].resources&#125;' 輸出 map[limits:map[memory:100Mi] requests:map[memory:100Mi]] 這邊可以看到, 如果我們有設置 limits resource, 但是沒設置 requests resource 的時候, Kubernetes 預設將 requests 設為 limits 取得容器 id 執行以下指令 docker ps | grep busy | cut -d' ' -f1 輸出 8fec6c7b6119 取得容器 pid 輸入以下指令 ps ax | grep /bin/sh 輸出 29532 ? Ss 0:00 /bin/sh -c while true; do sleep 2; done 取得該容器的 memory cgroup 輸入以下指令 sudo cat /proc/29532/cgroup 輸出 ...6:memory:/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11 印出 memory cgroup 中的 memory.limit_in_bytes 數值 輸入以下指令 sudo cat /sys/fs/cgroup/memory/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11/memory.limit_in_bytes 輸出 104857600 最後, 讓我們來看看前面跳過的, 位於 memory cgroup 當中的 momery.soft_limit_in_bytes 輸入以下指令 sudo cat /sys/fs/cgroup/memory/kubepods/burstable/pod88f89108-daf7-11e8-b1e1-42010a800070/8fec6c7b61190e74cd9f88286181dd5fa3bbf9cf33c947574eb61462bc254d11/memory.soft_limit_in_bytes 輸出 9223372036854771712 從上面的值可以得知, 就算我們有設定 requests 的限制, kubernetes 也不會命令 docker 去做這件事, 儘管 docker run 的參數 --memory-reservation 是可以做到這件事的 頗析 (CPU)CPU 的頗析模式大致上與 memory 相同, 但還是有不一樣的地方, 讓我們繼續看下去。 建立一個有 request CPU 限制的 pod 輸入以下指令建立 pod kubectl run limit-test --image=busybox --requests \"cpu=50m\" --command -- /bin/sh -c \"while true; do sleep 2; done\" 輸出 deployment.apps &quot;limit-test&quot; created 使用 kubectl 來檢視 pod 的資源限制資訊 輸入以下指令 kubectl get pods limit-test-5b4c495556-p2xkr -o=jsonpath='&#123;.spec.containers[0].resources&#125;' 輸出 map[requests:map[cpu:50m]] 從輸出可看到 kubernetes 有確實的設定 request 資源限制 取得容器 id 輸入以下指令 docker ps | grep busy | cut -d' ' -f1 輸出 f2321226620e 查看 Docker 是否確實設定資源限制 輸入以下指令 docker inspect f2321226620e --format '&#123;&#123;.HostConfig.CpuShares&#125;&#125;' 輸出 51 為什麼不是 50? 那是因為 Docker 以及 cgroup 都將 core 分成 1024 份, 而 Kubernetes 則是分成 1000 份 取得容器 pid 輸入以下指令 ps ax | grep /bin/sh 輸出 60554 ? Ss 0:00 /bin/sh -c while true; do sleep 2; done 取得容器的 CPU cgroup 輸入以下指令 sudo cat /proc/60554/cgroup 輸出 ...4:cpu,cpuacct:/kubepods/burstable/pode12b33b1-db07-11e8-b1e1-42010a800070/3be263e7a8372b12d2f8f8f9b4251f110b79c2a3bb9e6857b2f1473e640e8e75 取得 cgroup 屬性 輸入以下指令 ls -l /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pode12b33b1-db07-11e8-b1e1-42010a800070/3be263e7a8372b12d2f8f8f9b4251f110b79c2a3bb9e6857b2f1473e640e8e75 輸出 total 0drwxr-xr-x 2 root root 0 Oct 28 23:19 .drwxr-xr-x 4 root root 0 Oct 28 23:19 .....-rw-r--r-- 1 root root 0 Oct 28 23:19 cpu.shares 以上輸出可知, Docker 的 HostConfig.CpuShares 屬性映射到 cgroup 的 cpu.shares 屬性 取得 cpu.shares 的值 輸入以下指令 /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/podb5c03ddf-db10-11e8-b1e1-42010a800070/64b5f1b636dafe6635ddd321c5b36854a8add51931c7117025a694281fb11444/cpu.shares 輸出 51 咦, 以上的行為跟 memory 不太一樣對吧? 限制 memory 的 resource limit 是不會作用到 cgroup 的 soft limits 的 接下來, 建立一個有著 limit resource 的 pod 輸入以下指令 kubectl run limit-test --image=busybox --requests \"cpu=50m\" --limits \"cpu=100m\" --command -- /bin/sh -c \"while true; dosleep 2; done\" 輸出 deployment.apps &quot;limit-test&quot; created 使用 kubectl 來檢視第二個 pod 的資源限制資訊 輸入以下指令 kubectl get pods limit-test-5b4fb64549-qpd4n -o=jsonpath='&#123;.spec.containers[0].resources&#125;' 輸出 map[limits:map[cpu:100m] requests:map[cpu:50m]] 從輸出可看到 kubernetes 有確實的設定 request 資源限制 取得第二個容器 id 輸入以下指令 docker ps | grep busy | cut -d' ' -f1 輸出 f2321226620e 查看 Docker 是否確實設定資源限制 輸入以下指令 docker inspect 472abbce32a5 --format '&#123;&#123;.HostConfig.CpuShares&#125;&#125; &#123;&#123;.HostConfig.CpuQuota&#125;&#125; &#123;&#123;.HostConfig.CpuPeriod&#125;&#125;' 輸出 51 10000 100000 Dokcer 使用了兩個值來代表 memory resource limit, HostConfig.CpuPeriod 跟 HostConfig.CpuQuota, 而這兩個值又分別映射到 cgroup 的兩個屬性 cpu.cfs_period_us 跟 cpu.cfs_quota_us 取得 cpu.cfs_period_us 跟 cpu.cfs_quota_us 的值 輸入以下指令 sudo cat /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod2f1b50b6-db13-11e8-b1e1-42010a800070/f0845c65c3073e0b7b0b95ce0c1eb27f69d12b1fe2382b50096c4b59e78cdf71/cpu.cfs_period_us 輸出 100000 輸入以下指令 sudo cat /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod2f1b50b6-db13-11e8-b1e1-42010a800070/f0845c65c3073e0b7b0b95ce0c1eb27f69d12b1fe2382b50096c4b59e78cdf71/cpu.cfs_quota_us 輸出 10000 CPU 頗析的總結 period 為百萬分之一秒 quota 為程序容許在 period 中可調動的 CPU 100 m 就剛好是 1/10 core, 也是 10000/100000 百萬分之一秒 CPU 的資源限制中, request 是會作用到 cgroup 的, 該種類在 memory 是不會作用到 cgroup 的","link":"/zh-tw/managing-compute-resources-for-containers/"},{"title":"Cloud Functions 上的監控與紀錄","text":"概述你可以在 GCP 主控台檢視你的 Cloud Functions 的執行時間，執行次數，記憶體用量。 這些指標在 Stackdriver Monitoring 上也有，你可以在這裡根據這些指標來設定你的客製化警告。 更多資訊請參考 Stackdriver Monitoring 文件 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Quiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Quiclabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 Stackdriver 工作區在 Navigation menu, 點擊 Monitoring 當你看到 Stackdriver 的主控台時， 工作區已準備完畢 在 Stackdriver 檢視 Cloud Functions 的紀錄 &amp; 指標現在你將會建立一個可以被監控的 Hello World 的 cloud function 回到主控台，在左邊的選單，點擊 Cloud Functions, 然後 Create function 使用以下的設定來建立你的 function: Name: qwiklabsDemo Trigger: HTTP Index.js tab: 將 placeholder 替換成下面的代碼 /** * Cloud Function. * * */exports.qwiklabsDemo = function qwiklabsDemo (req, res) &#123; res.send(`Hello $&#123;req.body.name || 'World'&#125;!`); console.log(req.body.name);&#125; Function to execute: qwiklabsDemo 當你準備好時，點擊 Create cloud function 將會自動部署，且部署完畢後你可以在 Overview 頁面看到它。 這會需要幾分鐘的時間。 當你可以在名字的旁邊看到一個綠色的確認符號，這代表 cloud function 已經部署完畢。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 在 Cloud Shell, 執行以下的代碼來下載一個叫做 vegeta 的工具，它可以讓我們傳送一些測試用流量到 cloud function wget 'https://github.com/tsenart/vegeta/releases/download/v6.3.0/vegeta-v6.3.0-linux-386.tar.gz' 輸入以下指令來解壓縮 vegetatar xvzf vegeta-v6.3.0-linux-386.tar.gz 在主控台，點擊 cloud function 的名字, 然後點擊 trigger, 最後點擊下面的 URL 如果新的視窗開啟，並且你有看到 Hello World!, 這代表 cloud function 正常運作中。 現在傳送一些流量到 cloud function 執行以下的代碼，將 YOUR_PROJECT_ID 替換成你的 Project IDecho \"GET https://us-central1-&lt;YOUR_PROJECT_ID&gt;.cloudfunctions.net/qwiklabsDemo\" | ./vegeta attack -duration=300s &gt; results.bin 建立基於紀錄的指標現在你將建立一個分佈類型 (Distribution type) 的紀錄指標，使用正則表達式，從記錄數據的 textPayload 欄位取得延遲的值 點擊 Navigation menu 回到左方選單，然後在 Stackdriver section 區塊點擊 Logging, 你將會被引導到紀錄畫面 從第一個下拉選單選擇 Cloud Function，然後從所有的紀錄下拉選項裡選擇 cloud-functions, 然後點擊 OK, 這樣我們只會看到 Cloud Function 的紀錄： 在 *Filter By… 的欄位，輸入 “function execution took” (包含雙引號) 來篩選你的紀錄 然後在畫面上方點擊 Create Metric 在指標編輯器： 將指標命名為 CloudFunctionLatency-Logs 將 Type 改為 Distribution Field Name 請輸入 textPayload 點擊位於 Extraction regular expression 欄位旁的 Build 在 Regular Expression 欄位裡，輸入以下的代碼： execution took (\\d+) 指標編輯器應該看起來像這樣： 點擊 Create Metric 現在你會看到這個使用者自定義的指標已經被加到 Logs-based Metric 頁面 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 Metrics Explorer (指標探索器)接下來，使用指標探索器來檢視 cloud function 的資料 在 Stackdriver tab 的視窗，到 Resources &gt; Metrics Explorer 來檢視一些 Cloud Functions 的指標。 開始在欄位中輸入 execution, 然後從建議指標中選擇 Executions。 在圖表的上方的下拉選單，將圖表類型變更為 stacked bar 現在試試看不同的指標來看看有什麼其他的圖形選項。 點擊 Metric 旁邊的 X, 然後選擇 Execution times 圖表預設為 heatmap, 但你可以更改承認和你喜歡的類型 你也可以檢視不同的加總，例如百分位排名第 95 位： 客製化顯示面板客製化一個顯示面板是一個非常好的方式來儲存對你來說重要的指標圖表。 你將再次設定這些圖表，但這次他們會儲存在你的顯示面板 在 Stackdriver 主控台，點擊 Dashboards &gt; Create Dashboard 將這個顯示面板取名為 “Results”, 然後點擊 Add Chart 點擊到 Find resource type and metric 欄位，然後選擇我們在上面最後建立的表格的資源類型以及指標, 點擊 Add Chart 來建立下一個 在選擇指標後，圖表會自動被命名, 但你可以重新命名 當你完成這一切，你的圖表將會出現在你的顯示面板，提供一個快速的參考值來顯示目前資源的狀況 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 恭喜！你已完成本教程","link":"/zh-tw/monitoringAndLoggingForCloudFunctions/"},{"title":"<未完成> 使用 Stackdriver 在 Kubernetes Engine 上實施監控","text":"概述Stackdriver Kubernetes Monitoring 是 Stackdriver 上個一個新功能, 它更緊密地與 GKE 整合, 可以更好的顯示你運行在 GKE 上的工作、服務的重要統計資訊。新功能也包含了匯入, 可以匯入我們用 Prometheus 在 pods 取得的 metrics(指標), 就像是原生 Stackdriver metrics 一樣。 這讓我們可以使用 Prometheus 的 metrics 來觸發 Stackdriver 原生的警告功能, 不需要額外的設定以及串接。 在這個教程中, 你將會在 Kubernetes Engine 叢集設定 Monitoring 以及具現象 metrics 。 你將會使用 Terraform, 它是一個宣告式的 Infrastructure as Code 工具, 它讓我們可以使用設定檔來自動化部署, 以及更新雲端基礎設施。 我們從 Kubernetes Engine 取得的 logs(紀錄) 將會被利用來演示 Stackdriver 的監控能力。 注意: Stackdriver Monitoring workspace 不會被 script 自動化, 因為現階段 Terraform 或 gcloud command line 工具都不支援 本教程由 GKE Helmsman 工程師創建來幫助你更理解 Kubernetes Engine 上使用 Stackdriver Monitoring, 你可以從 Github repo 檢視範例程式碼。我們歡迎你們一起貢獻這個專案。 架構本教程將會建立一個 Kubernetes Engine 叢集, 這個叢集會部署一個範例應用。 這個叢集的紀錄以及指標會預設被載入到 Stackdriver Logging, 在本教程中會自動設定一個 Stackdriver Monitoring 帳號以檢視被捕捉到的指標 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 故障排除: 在 production 環境, 當你在運行 Teffaform 時如果出現 Permission denied 並且安裝腳本失敗, 那很有可能是因為 Terraform 使用的憑證沒有提供在該專案建立資源需要的權限。 務必確認 gcloud config list 指令列出的帳號有建立資源需要的權限。 如果有的話, 使用 gcloud auth applications-default login 來重新產生 application default 的憑證。 設定你的 region 和 zone某些 Compute Engine 的資源位於 regions 以及 zones 。 region 是一個特定的地理位置，你只能在這個執行 region 運行你的資源, 每一個 region 有一個或多個 zone 如果你想要了解更多有關 region 以及 zone, 可以參考官方文件 執行以下指令來設定本教程中的 region 以及 zone (你可以使用對你來說最佳的 region 跟 zone)gcloud config set compute/region us-central1gcloud config set compute/zone us-central1-a 複製範例執行以下指令來複製此教程需要的範例檔案git clone https://github.com/GoogleCloudPlatform/gke-monitoring-tutorial.git 到範例資料夾內：cd gke-monitoring-tutorial 驗證設定Terraform 設置會執行你的 GCP 環境並建立一個運行著簡單應用的 Kubernetes Engine 叢集。 這個設置會使用你的私人帳號來建立資源。 執行以下指令選擇適合的帳戶, Terraform 設置預設使用的帳戶gcloud auth application-default login 複製輸出的 URL, 貼到新的瀏覽器視窗選擇本教程的登入憑證, 並點擊 Allow複製提供的程式碼並貼到 Cloud Shell 視窗 建立 Stackdriver workspace要使用 Stackdriver, 你的專案必須在 Stackdriver 帳號內。 以下的步驟會建立一個帳號, 這個帳號可以試用 Stackdriver 在 Google Cloud Platform 主控台, 點擊 Navigation menu &gt; Monitoring, 使用本教程提供的憑證資訊登入。 點擊 NO THANKS!, 不使用 beta 版本的 Stackdriver Monitoring 當 Stackdriver 主控台開啟, 這代表此工作區已就緒。 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 Stackdriver 工作區, 你將獲得一個評價分數。 部署叢集","link":"/zh-tw/monitoringWithStackdriverOnKubernetesEngine/"},{"title":"MySQL 學習筆記","text":"前言一份未整理的 MySQL 學習筆記 中文亂碼問題先確認 locale 狀態： 確認 charset 狀態, 在 mysql 當中: show variables like 'char%'; 確認 database locale 狀態： SELECT default_character_set_name FROM information_schema.SCHEMATA WHERE schema_name = \"databaseName\"; 確認 table locale 狀態： SELECT CCSA.character_set_name FROM information_schema.`TABLES` T, information_schema.`COLLATION_CHARACTER_SET_APPLICABILITY` CCSAWHERE CCSA.collation_name = T.table_collation AND T.table_schema = \"databaseName\" AND T.table_name = \"tableName\"; 確認 column locale 狀態： show full columns from tableName; 確認 collation show variables like 'collation%'; locale 設定 確認 mysql 設定檔位置mysql --help -verbose | grep 'my.cnf' 通常，檔案會在 /etc/mysql/my.cnf vim /etc/mysql/my.cnf 貼上：[client]default-character-set=utf8mb4[mysql]default-character-set=utf8mb4[mysqld]collation-server = utf8_unicode_ciinit-connect='SET NAMES utf8'character-set-server = utf8mb4 修改 database locale ALTER DATABASE database_name CHARACTER SET utf8 COLLATE utf8_general_ci; 修改 table locale ALTER TABLE table_name CONVERT TO CHARACTER SET utf8; 完成以上設定之後，重啟 mysql service mysql restart 如果有用使用 PHP 的話，記得也將 PHP 那邊的 locale 設為 uft8, 可參考文章 mysqli_set_charset($dbc,&quot;utf8&quot;); 疑難雜症理論上，上面的都做完了，應該就不會有亂碼了，如果問題尚未解決，可以試試下面的方法 查看資料庫 locale 設定 show create database databaseName 查看 table locale 設定 show create table tableName 其餘設定 set names uft8; 密碼顯示密碼驗證相關show variables like &apos;validate_password%&apos;; 密碼驗證原則對照表 Policy Value Test Performed 0/Low length 1/MEDIUM length; numeric, lowercase/uppercase, and special characters 2/STRONG length; numeric, lowercase/uppercase, and special characters; dictionary file 確認驗證方式SELECT user,authentication_string,plugin,host FROM mysql.user; 更改 root 密碼ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;; FLUSH PRIVILEGES; 修改密碼長度規則set global validate_password_length=3; 修改密碼驗證原則set global validate_password_policy=0; 匯入大量資料從 sql 檔匯入mysql --max_allowed_packet=100M -u root -p database &lt; dump.sql 修改 my.cnf 或 my.ini 檔[mysqld]max_allowed_packet=100M 暫時性的變更set global net_buffer_length=1000000; set global max_allowed_packet=1000000000; 查單一資料庫 sizeSELECT table_schema &quot;databaseName&quot;, ROUND(SUM(data_length + index_length) / 1024 / 1024, 1) &quot;DB Size in MB&quot; FROM information_schema.tables where table_schema=&quot;databaseName&quot; GROUP BY table_schema; 建立資料庫CREATE DATABASE mydatabase CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; CLI 下指令(不登入)語法mysql -uroot -pYourPassword -Bse \"use test; delete from testTable;\" -B: batch -s: silent -e: execute 更改 log 的時區到系統時間set global log_timestamps = &apos;system&apos;; 刪除資料庫DROP DATABASE `databaseName`;","link":"/zh-tw/mysql/"},{"title":"使用 GCP Kubernetes Engine 來管理部署","text":"概述Dev Ops 實踐通常使用多重部署的方法來管理應用部署情境, 像是 “持續部署”, “Blue-Green 部署”, “Canary 部署”, 等等… 本教程主要提供擴充以及管理容器的方法, 所以你可以完成這些使用多重部署的通用情境。 你將會做什麼？ Kubectl 工具的練習 建立 deployment yaml 檔案 啟動, 更新, 以及擴充 deployments 更新 deployments 以及 部署風格的練習 事先準備 在開始本教程之前, 你應該至少完成 Introduction to Docker 以及 Hello Node Kubernetes Linux 系統管理技能 Dev Ops 理論： 持續部署的概念 deployments 介紹Heterogeneous deployments (多種類部署) 一般來說包含兩個或多個基礎設施或地區以解決特定技術或運作需求。 Heterogeneous deployments 又被稱為 “hybrid”, “multi-cloud”, 或 “public-private”, 取決於部署細節。在本教程中, heterogeneous deployments 包含地區橫跨單一雲端環境, 多公開雲端環境 (multi-cloud), 或是內部部署以及公開雲端的結合 (hybrid 或 public-private) 單一環境或地區的部署可能會在業務邏輯上或技術上有一些問題 資源耗盡: 在單一環境中, 尤其是內部部署環境, 你可能沒有正式環境需要的計算, 網路, 或儲存資源 被限制的觸及地區: 單一環境的部署需要不同區域的人們存取不同區域的部署, 他們的流量可能會繞了世界一周之後才到達一個中間地區 被限制的可用性: 網路擴充流量模式對應用保持容錯以及適應, 會是一個挑戰 供應商鎖定: 供應商等級的平台以及基礎設施抽象將讓應用移植變得困難 不靈活的資源: 你的資源可能會被限制在一組特定的計算機, 儲存區, 或網路 Heterogeneous 可幫我們解決這些難題, 但他們必須被建構在可程式化以及確定性的程序以及步驟。 一次性的或點對點的部署步驟會造成部署或程序脆弱, 以及容錯能力降低。 點對點程序會丟失資料或丟棄流量。 一個好的部署程序需要是可重複的, 使用已確認可用的方法來管理提供, 設定, 以及維護。 三個 heterogeneous 通用的情境, 分別是 multi-cloud deployments (多雲端部署), fronting on-premises data (前端導向內部資料), 以及 CI/CD (持續整合 / 持續部署) 程序 以下的練習會實作一些 heterogeneous deployments 通用使用情境, 以及透過良好架構的 Kubernetes 方法以及其他的基礎設施資源來達成 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 設定 zone執行以下指令來設定你的 GCP zone, 將 local zone us-central1-a 替換掉gcloud config set compute/zone us-central1-a 取得本教程範例程式碼取得建立, 運行容器以及 deployments 的範例程式碼git clone https://github.com/googlecodelabs/orchestrate-with-kubernetes.gitcd orchestrate-with-kubernetes/kubernetes 建立一個含有 5 台 n1-standard-1 node 的叢集 (會需要幾分鐘時間完成) gcloud container clusters create bootcamp --num-nodes 5 --scopes \"https://www.googleapis.com/auth/projecthosting,storage-rw\" 理解 deployment 物件讓我們從 Deployments 開始。 首先檢視一下 Deployment 物件。 kubectl 的 explain 指令可以告訴我們有關 Deployment 物件的資訊kubectl explain deployment 我們可以使用 --resursive 選項來檢視所有的欄位kubectl explain deployment --recursive 在你進行本教程的過程中, 你可以使用 explain 來更了解 Deployment 物件的結構, 以及每個欄位做什麼事kubectl explain deployment.metadata.name 建立 deployment更新 deployments/auth.yaml cs 檔案：vim deployments/auth.yaml 開始編輯模式i 將 container 區塊內的 image 變更如下：...containers:- name: auth image: kelseyhightower/auth:1.0.0... 儲存 auth.yaml 檔案, 按下 &lt;Esc&gt;, 然後：:wq 現在讓我們來建立一個簡單的 deployment 。 檢視 deployment 設定檔cat deployments/auth.yaml (輸出)apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: &quot;kelseyhightower/auth:1.0.0&quot; ports: - name: http containerPort: 80 - name: health containerPort: 81... 注意到 Deployment 是如何建立一個 replica 且使用 auth container 的 version 1.0.0 當你執行 kubectl create 指令來建立 auth deployment 時, 一個符合 Deployment 設定檔的 pod 將會被建立。 這表示說, 我們可以藉由變更 replica 欄位的數量擴縮 Pods 的數量 使用 kubectl create 來建立 deployment 物件kubectl create -f deployments/auth.yaml 一旦你已經建立 Depolyment, 你可以確認看看它是否有被建立kubectl get deployments 一旦 deployment 被建立了, Kubernetes 會建立一個相對應的 ReplicaSet 。 我們可以確認對應該 Deployment 的 ReplicaSet 是否有被建立kubectl get replicasets 我們應會看到一個名為 auth-xxxxxx 的 ReplicaSet 最後, 我們可以檢視 Pods, 它是 Deployment 的一部分。 當 ReplicaSet 被建立, Kubernetes 會建立一個 Podkubectl get pods 是時候建立一個 auth deployment 的 service 。 你已經看過 service 的設定檔, 所以在這我們不會探究更多細節。 使用 kubectl create 指令來建立 auth servicekubectl create -f services/auth.yaml 現在, 同樣的步驟, 讓我們建立以及暴露 hello Deploymentkubectl create -f deployments/hello.yamlkubectl create -f services/hello.yaml 然後再一次, 建立以及暴露 frontend Deploymentkubectl create secret generic tls-certs --from-file tls/kubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.confkubectl create -f deployments/frontend.yamlkubectl create -f services/frontend.yaml 注意: 你為 frontend 建立了一個 ConfigMap 取得 frontend 的外部 IP 然後使用 curl 與它互動kubectl get services frontendcurl -ks https://EXTERNAL-IP 然後你會得到一個 hello 的回應你也可以使用 kubectl 的輸出模板功能搭配 curl, 讓指令變成只需要一行curl -ks https://`kubectl get svc frontend -o=jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\"` 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立了 Kubernetes 叢集以及 Auth, Hello, 跟 Frontend deployments, 你將獲得一個評價分數。 擴縮 Deployment現在我們已建立一個 Deployment, 我們可以擴縮它。 可以藉由更新 spec.replicas 欄位來達成。 你可以再次使用 Kubectl explain 指令來檢視這個欄位的解釋kubectl explain deployment.spec.replicas 更新 replicas 欄位最簡單的方法就是使用 kubectl scale 指令kubectl scale deployment hello --replicas=5 注意: 要讓全部的 pods 都啟動且運行約需要幾分鐘Deployment 建立後, Kubernetes 會自動地更新相對應的 ReplicaSet 以及啟動新的 Pods, 讓 Pods 的總數量等於 5 確認是否有 5 個 hello Pods 運行中：kubectl get pods | grep hello- | wc -l 現在擴縮回原本的數量kubectl scale deployment hello --replicas=3 再一次, 確認 Pods 的數量是正確的kubectl get pods | grep hello- | wc -l 你已經學習了 Kubernetes deployments 以及如何管理 &amp; 擴縮 Pods 群組 rolling update (滾動升級)Deployments 支援透過滾動升級的機制進行鏡像升級。 當 Deployment 被更新成新的版本, 它會建立一個新的 ReplicaSet, 並且慢慢的增加新版的 replicas 的數量, 同時, 也慢慢地減少舊版的 replicas 數量 觸發滾動升級執行以下指令來更新 Deployment:kubectl edit deployment hello 將 containers 區塊內的 image 變更如下：...containers:- name: hello image: kelseyhightower/hello:2.0.0... 儲存並離開一但你成功的儲存編輯器, 更新的 Deployment 會被儲存到你的叢集, 然後 Kubernetes 將會開始滾動升級。檢視 Kubernetes 新建立的 ReplicaSetkubectl get replicaset 同時你也可以檢視 rollout 的紀錄kubectl rollout history deployment/hello 暫停滾動升級如果在滾動升級的過程中, 你發現一些問題, 你可以停止升級kubectl rollout pause deployment/hello 確認目前的滾動狀態kubectl rollout status deployment/hello 你也可以直接透過 Pods 資訊來確認kubectl get pods -o jsonpath --template='&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;\"\\t\"&#125;&#123;\"\\t\"&#125;&#123;.spec.containers[0].image&#125;&#123;\"\\n\"&#125;&#123;end&#125;' 繼續滾動升級滾動升級被中斷了, 這表示有一些 Pods 正運行著新版本而有些 Pods 運行舊版本。 我們可以使用以下的 resume 指令來繼續未完成的滾動kubectl rollout resume deployment/hello 當滾動完成了, 你執行 status 指令時, 應會看到輸出如下：kubectl rollout status deployment/hello (輸出)deployment &quot;hello&quot; successfully rolled out 回滾假設我們在新版本發現了一個 bug 。 因為新版本有問題, 任何存取新的 Pods 資源的使用者都會遇到這個問題你會想要回滾之前的版本, 所以你可以看看出了什麼問題, 待修復後再發布一個新的版本使用 rollout 指令來回滾到之前的版本kubectl rollout undo deployment/hello 確認回滾歷史kubectl rollout history deployment/hello 最後, 確認所有的 Pods 都有回滾到之前的版本kubectl get pods -o jsonpath --template='&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;\"\\t\"&#125;&#123;\"\\t\"&#125;&#123;.spec.containers[0].image&#125;&#123;\"\\n\"&#125;&#123;end&#125;' 帥氣！ 你已經學會 Kubernetes 的滾動升級, 以及如何 0 downtime 的更新你的應用 金絲雀部署 (Canary Deployments)當你想要在正式環境只對一部分的使用者進行新版本的測試, 你可以使用金絲雀部署。 金絲雀部署讓你可以只發布變更到一小部分的使用者, 降低新發布的風險 建立一個金絲雀部署 (canary deployment)金絲雀部署包含分開的 deployment, 以及一個共同的 service, 這個 service 可以導向穩定, 一般的版本, 以及金絲雀版本 首先, 建立一個新的金絲雀 deploymentcat deployments/hello-canary.yaml (輸出)apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-canaryspec: replicas: 1 template: metadata: labels: app: hello track: canary # Use ver 1.0.0 so it matches version on service selector version: 1.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81... 確認有更新到版本 1.0.0 (如果你的版本是指向其他的)現在建立一個金絲雀 deploymentkubectl create -f deployments/hello-canary.yaml 金絲雀 deployment 被建立後, 你應會有兩個 deployments, hello 以及 hello-canary 。 使用以下的 kubectl 指令來確認:kubectl get deployments 在 hello service, selector 使用 app:hello selector, 這將會同時符合 prod deployment 以及 canary deployment 。 然而, 因為 canary deployment 的 pods 數量較少, 所以它對使用者的可見度來說是相對低的。 確認 canary deployment你可以發請求, 並經由以下指令來確認服務該請求的 hello 版本curl -ks https://`kubectl get svc frontend -o=jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\"`/version 執行這個指令多次, 你應會看到有一些請求是由 hello 1.0.0 所服務, 而有一小部分 (1/4 = 25%) 的請求是由 2.0.0 所服務 測試進度點擊 Check my progress 來確認目前的進度。如果你已經建立金絲雀部署, 你將獲得一個評價分數。 在正式環境中的 Canary deployments - session affinity在本教程中, 每個發往 Nginx 服務的請求都有機率由 canary deployment 所服務。 但如果是你不想要某些使用者是由 canary deployment 來服務呢？ 一個使用情境是當你 canary deployment 的 UI 有變動, 而你不想要讓使用者覺得疑惑。 在這個使用情境中, 你想要讓使用者們可以固定的被不同的 deployment 所服務, 不會一直切換來切換去的。 你可以建立一個賦有 session affinity 的 service 。 這個方法會讓使用者總是被同一個版本的 deployment 服務。 在以下的範例中, service 跟之前的沒什麼不同, 但多了一個 sessionAffinity 欄位, 並設定成 ClientIP 。 所有有著相同 IP 的客戶端將會由相同的 hello 版本的應用所服務kind: ServiceapiVersion: v1metadata: name: &quot;hello&quot;spec: sessionAffinity: ClientIP selector: app: &quot;hello&quot; ports: - protocol: &quot;TCP&quot; port: 80 targetPort: 80 因為這個情境比較難測試, 所以我們不必在此測試, 但你可能會想要在正式環境中使用 sessionAffinity Blue-green deployment滾動升級是個理想的部署方式, 因為它讓我們可以用最小效能影響, downtime, 以及花費來部署應用。 然而在某些情況中, 待新版本部署完成後, 修改平衡負載指向新版本, 這種方式會是比較有利的。 在這樣的使用情境下, blue-green 部署會是我們需要的方式Kubernetes 藉由建立兩個分開的 deployments 來達成這個目的; 一個舊的 “blue” 版本的 deployment 以及一個新的 “green” 版本的 deployment 。 使用已存在的 hello 來作為 “blue” 版本。 這個 deployment 將會透過一個角色為路由的 Service 來被存取。 一旦新的 “green” 版本已成功啟動並且運行中, 你可以藉由更新這個 service 來切換使用新版本。 blue-green deployments 有一個主要的缺點, 那就是你必須在叢集中要有至少 2 組以上的資源來運行你的應用。 在你同時部署兩個版本的應用到叢集之前, 務必確認你有足夠的資源。 The service (服務)使用已存在的 hello service, 但是把它的 selector 更新成 app:hello, version: 1.0.0 。 這個 selector 會符合 “blue” deployment, 但不會符合 “green” deployment 因為它使用不同的版本首先更新服務：kubectl apply -f services/hello-blue.yaml 更新使用 Blue-Green deployment我們將建立一個新版本 “green” deployment 來支援 blue-green deployment 風格。 這個 green deployment 更新了版本標籤以及鏡像路徑。apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-greenspec: replicas: 3 template: metadata: labels: app: hello track: stable version: 2.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: 10Mi livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 建立 green deploymentkubectl create -f deployments/hello-green.yaml 一但你已經建立好 green deployment, 並且它已經被正確啟動且運行, 確認目前是否還是使用 1.0.0 的版本curl -ks https://`kubectl get svc frontend -o=jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\"`/version 現在更新服務來指向新的 deployment 版本kubectl apply -f services/hello-green.yaml 當 service 被更新後, “green” deployment 會立即地被使用。 你可以確認新版本是否一直被使用著curl -ks https://`kubectl get svc frontend -o=jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\"`/version Blue-Green 回滾如果需要的話, 你也可以使用同樣的方式回滾到舊的版本。 儘管 “blue” deployment 還在運行著, 可以直接更新 service 到舊的版本kubectl apply -f services/hello-blue.yaml 一但你更新了服務, 回滾也就完成了。 再一次, 確認看看目前使用中的是否是正確的版本curl -ks https://`kubectl get svc frontend -o=jsonpath=\"&#123;.status.loadBalancer.ingress[0].ip&#125;\"`/version 你做到了！ 你已經學到 blue-green deployment 以及如何立即全部一次切換的部署方法 恭喜你已經完成本教程! Q&amp;A 以下的 deployment yaml 檔設定分別代表什麼意思？ deployment yaml: apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: \"kelseyhightower/auth:1.0.0\" ports: - name: http containerPort: 80 - name: health containerPort: 81 Answer: # apiVersion: 版本, 會隨著版本而變動, 可參考[文件](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#-strong-api-overview-strong-)apiVersion: extensions/v1beta1# 種類, 可參考[文件](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.16/#-strong-api-overview-strong-)kind: Deployment# 該 Deployment 的 metadatametadata: # 該 deployment 的 name name: auth# 該 deployment 運行的規格spec: # pod 數量 replicas: 1 # pod 樣板 template: # pod 的 metadata metadata: # label, 可被 selector 挑選, 為 key/value pair labels: app: auth track: stable # pod 運行規格 spec: # 定義容器 containers: # 容器名稱 - name: auth # 鏡像名稱 image: \"kelseyhightower/auth:1.0.0\" # 定義 port ports: # port 名稱 - name: http # port 號 containerPort: 80 # port 名稱 - name: health # port 號 containerPort: 81 以下的 Kubernetes yaml 設定檔的意思是？ yaml 檔 apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: \"kelseyhightower/auth:2.0.0\" ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: \"10Mi\" livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer: # api 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# Deployment 的 metadatametadata: # Deployment 的 name name: auth# 該 Deployment 運行的規格spec: # 該 Deployment 共會啟動幾個 Pod replicas: 1 # 該 Pod 的詳細資料 template: # 該 Pod 的 metadata metadata: # 該 Pod 的 label, 可透過 selector 被選取 labels: # 自定義的 key/value pair app: auth track: stable # 該 Pod 的規格 spec: # 容器規格 containers: # 容器名稱 - name: auth # 鏡像名稱 image: \"kelseyhightower/auth:2.0.0\" # 該容器的 port 定義 ports: # port 名稱 - name: http # port 號 containerPort: 80 # port 名稱 - name: health # port 號 containerPort: 81 # 容器的資源定義 resources: # 限制 limits: cpu: 0.2 memory: \"10Mi\" # 存活探針 livenessProbe: # 探測類型 httpGet: # 探測路徑 path: /healthz # 探測 port 號 port: 81 scheme: HTTP # 首次執行探針時需要延遲的時間, 以確保容器內各項工作都已準備就緒, 如果一啟動就探測的話很可能會直接失敗 initialDelaySeconds: 5 # 每隔 15 秒探測一次 periodSeconds: 15 # 探測時, 如果超過幾秒沒回覆視為失敗 timeoutSeconds: 5 # 就緒探針, 如果尚未就緒, service 不會將流量導向該容器 readinessProbe: # 探測方式為 httpGet httpGet: # 探測 url path: /readiness # 探測 port 號 port: 81 # 使用 http 還是 https scheme: HTTP # 首次啟動 readinessProbe 時, 等待五秒 initialDelaySeconds: 5 # 若超過 1 秒沒有 response, 視為失敗 timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file: apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: frontendspec: replicas: 1 template: metadata: labels: app: frontend track: stable spec: containers: - name: nginx image: \"nginx:1.9.14\" lifecycle: preStop: exec: command: [\"/usr/sbin/nginx\",\"-s\",\"quit\"] volumeMounts: - name: \"nginx-frontend-conf\" mountPath: \"/etc/nginx/conf.d\" - name: \"tls-certs\" mountPath: \"/etc/tls\" volumes: - name: \"tls-certs\" secret: secretName: \"tls-certs\" - name: \"nginx-frontend-conf\" configMap: name: \"nginx-frontend-conf\" items: - key: \"frontend.conf\" path: \"frontend.conf\" Answer: # API 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# 該 Deployment metadatametadata: # 該 Deployment name 為 frontend name: frontend# 該 Deployment 運行規格spec: # 啟動 1 個 pod replicas: 1 # 該 pod 模板 template: # 該 pod metadata metadata: # label, 可被 selector 選擇 labels: app: frontend track: stable # 該 pod 運行規格 spec: # 定義容器 containers: # 容器名稱 - name: nginx # 鏡像名稱 image: \"nginx:1.9.14\" # 定義生命週期 lifecycle: # preStop hook preStop: # hook handler 為 exec exec: # 執行指令, 用意為在停止前優雅退出 nginx command: [\"/usr/sbin/nginx\",\"-s\",\"quit\"] # 掛載 volume volumeMounts: # 使用的 volume name - name: \"nginx-frontend-conf\" # 掛載於容器內的位置 mountPath: \"/etc/nginx/conf.d\" # 使用的 volume name - name: \"tls-certs\" # 掛載於容器內的位置 mountPath: \"/etc/tls\" # 定義容器 volumes: # 定義 volume name - name: \"tls-certs\" # volume 來源為 secret secret: # 使用的 secret name secretName: \"tls-certs\" # 定義 volume name - name: \"nginx-frontend-conf\" # volume 來源為 configMap configMap: # 使用的 configMap name name: \"nginx-frontend-conf\" # 指定該 configMap 內的 key items: # 取得 nginx-frontend-conf configMap 中的 frontend.conf 的 key - key: \"frontend.conf\" # 指定掛載後的位置 path: \"frontend.conf\" 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file: apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-canaryspec: replicas: 1 template: metadata: labels: app: hello track: canary version: 2.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: 10Mi livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer: # API 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# 該 Deployment metadatametadata: # 該 Deployment name name: hello-canary# 該 Deployment 運行規格spec: # 啟動一個 pod replicas: 1 # 該 Pod 範本 template: # 該 pod 的 metadata metadata: # 定義 labels labels: app: hello track: canary version: 2.0.0 # 該 pod 運行規格 spec: # 定義容器 containers: # 容器 name - name: hello # 使用鏡像 image: kelseyhightower/hello:2.0.0 # 定義 ports ports: # port name - name: http # 容器內的 port containerPort: 80 # port name - name: health # 容器內的 port containerPort: 81 # 定義資源限制 resources: # 定義 limits 類型資源限制 limits: cpu: 0.2 memory: 10Mi # 定義存活探針 livenessProbe: # 使用 httpGet 方式探測 httpGet: # 指定探測的 path path: /healthz # 指定探測的 port port: 81 # 指定探測的 scheme scheme: HTTP # 容器啟動後延遲五秒再開始探測 initialDelaySeconds: 5 # 每十五秒探測一次 periodSeconds: 15 # 超過五秒沒回應, 視為失敗 timeoutSeconds: 5 # 定義就緒探針 readinessProbe: # 使用 httpGet 方式探測 httpGet: # 指定探測的 path path: /readiness # 指定探測的 port port: 81 # 指定探測的 scheme scheme: HTTP # 容器啟動後延遲五秒再開始探測 initialDelaySeconds: 5 # 超過五秒沒回應, 視為失敗 timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file: apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hello-greenspec: replicas: 3 template: metadata: labels: app: hello track: stable version: 2.0.0 spec: containers: - name: hello image: kelseyhightower/hello:2.0.0 ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: 10Mi livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer: # API versionapiVersion: extensions/v1beta1# The kind is Deploymentkind: Deployment# The metadata of the Deploymentmetadata: # The name of the Deployment name: hello-green# The specspec: # Desired number of pod is 3 replicas: 3 # the template of the pod template: # the metadata of the pod metadata: # labels, could be selected by selector labels: app: hello track: stable version: 2.0.0 # spec of the pod spec: # define containers containers: - name: hello image: kelseyhightower/hello:2.0.0 # define ports ports: - name: http containerPort: 80 - name: health containerPort: 81 # define constraint resources resources: limits: cpu: 0.2 memory: 10Mi # define liveness probe livenessProbe: # use httpGet probe httpGet: path: /healthz port: 81 scheme: HTTP # wait for 5 seconds after the container starts before starting to probe initialDelaySeconds: 5 # probe every 15 seconds periodSeconds: 15 # consider it fails if not get responses for 5 seconds timeoutSeconds: 5 # define readiness probe readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file: apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: hellospec: replicas: 3 template: metadata: labels: app: hello track: stable version: 1.0.0 spec: containers: - name: hello image: \"kelseyhightower/hello:1.0.0\" ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: \"10Mi\" livenessProbe: httpGet: path: /healthz port: 81 scheme: HTTP initialDelaySeconds: 5 periodSeconds: 15 timeoutSeconds: 5 readinessProbe: httpGet: path: /readiness port: 81 scheme: HTTP initialDelaySeconds: 5 timeoutSeconds: 1 Answer: # API 版本apiVersion: extensions/v1beta1# 種類為 Deploymentkind: Deployment# the metadata of the deploymentmetadata: # define the deployment name name: hello# define the spec of the deploymentspec: # it will start 3 pods replicas: 3 # define the template of the pod template: # define the metadata of the pod metadata: # define teh labels, which could be selected by Selector labels: app: hello track: stable version: 1.0.0 # define the spec of the pod spec: # define containers containers: # define container name - name: hello # used image image: \"kelseyhightower/hello:1.0.0\" # define ports ports: # define port name - name: http # define port inside the container containerPort: 80 # define port name - name: health # define port inside the container containerPort: 81 # define resources resources: # define limits resources limits: cpu: 0.2 memory: \"10Mi\" # define liveness probe livenessProbe: # using httpGet probe httpGet: # define probe path path: /healthz # define probe port port: 81 # define probe scheme scheme: HTTP # the liveness probe will start to probe 5 seconds after the container starts initialDelaySeconds: 5 # probe every 15 seconds periodSeconds: 15 # if the probe doesn't receive responses for 5 seconds, it's considered failed timeoutSeconds: 5 # define readiness probe readinessProbe: # use httpGet probe httpGet: # specify probe path path: /readiness # specify probe port port: 81 # specify probe scheme scheme: HTTP # the readiness probe will start to probe 5 seconds after the container starts initialDelaySeconds: 5 # if the probe doesn't receive responses for 5 seconds, it's considered failed timeoutSeconds: 1 請解釋以下 kubernetes yaml file 中的每一條 directive yaml file: kind: ServiceapiVersion: v1metadata: name: \"auth\"spec: selector: app: \"auth\" ports: - protocol: \"TCP\" port: 80 targetPort: 80 Answer: # 種類為 Servicekind: Service# API 版本為 v1apiVersion: v1# 此 Service 的 metadatametadata: # 此 Service 的 name name: \"auth\"# 此 Service 的運行規格spec: # 可選擇指定 label, 並將流量導向這些 pod selector: app: \"auth\" # 定義 port ports: # 使用 TCP protocol - protocol: \"TCP\" # service 的 port 為 80 port: 80 # 目標對象的 port 為 80 targetPort: 80 請解釋以下的 kubernetes yaml file 中的每一條 directive yaml file: kind: ServiceapiVersion: v1metadata: name: \"monolith\"spec: selector: app: \"monolith\" secure: \"enabled\" ports: - protocol: \"TCP\" port: 443 targetPort: 443 nodePort: 31000 type: NodePort Answer: # 種類為 Servicekind: Service# API 版本為 v1apiVersion: v1# 該 service 的 metadatametadata: # 該 service name name: \"monolith\"# 該 service 運行規格spec: # 會將流量導向符合此 label 的 pod selector: app: \"monolith\" secure: \"enabled\" # 定義 ports ports: # protocol 為 TCP - protocol: \"TCP\" # service 的 port 為 443 port: 443 # 目標對象的 port 為 443 targetPort: 443 # 定義 node 的 31000 port 將流量導向 service 的 clusterIP nodePort: 31000 # 使用 NodePort type: NodePort 請解釋以下的 Kubernetes yaml file 中的每一條 directive yaml file kind: ServiceapiVersion: v1metadata: name: \"frontend\"spec: selector: app: \"frontend\" ports: - protocol: \"TCP\" port: 443 targetPort: 443 type: LoadBalancer Answer: # kind is servicekind: Service# api version is v1apiVersion: v1# the metadata of the serivicemetadata: # the name of the service name: \"frontend\"# the spec of the servicespec: # those selected by this selector will be the endpoint to which the traffic is redirected selector: # an arbitrary key / value pair app: \"frontend\" # define ports ports: # define the protocol - protocol: \"TCP\" # define service port port: 443 # define target endpoint' ports targetPort: 443 # this option is only for cloud provider type: LoadBalancer","link":"/zh-tw/managingDeploymentsUsingKubernetesEngine/"},{"title":"Laravel - The Basics - Validation","text":"Introduction學習一個框架, Ray 的想法是, 在深入理解底層實作的原理之前, 應該先知道這個框架的 使用方法; 先學習怎麼使用這個前人造的輪子, 再學習怎麼樣造一個輪子。所以本篇文章重點在於細讀官方文件, 並將內容理解後以 Q&amp;A 的方式記錄下來, 加速學習以及查詢。 Validation QuickstartWriting The Validation Logic 在 Laravel validation 中, 如果請求的是 HTTP request, 那 validation 會回什麼？redirect response 在 Laravel validation 中, 如果請求的是 AJAX request, 那 validation 會回什麼？JSON response Laravel validation rules 可以用哪兩種方式指定？ | delimited string array error bag, 待補… Stopping On First Validation Failure 在下面的 Laravel validation 中, 當驗證 title 時, 如果我想要讓 validation 在 unique 沒通過時就停下, 不再繼續驗 max, 那我可以怎麼做？ 範例程式碼: &lt;?php$request-&gt;validate([ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required',]); Answer: &lt;?php$request-&gt;validate([ 'title' =&gt; 'bail|required|unique:posts|max:255', 'body' =&gt; 'required',]); A Note On Nested Attributes Laravel validation 中, 如果 request 裡頭有巢狀的參數, 舉例來說, 我想要驗 author 下的 name 以及 description, 都要是 required 那我可以怎麼做？&lt;?php$request-&gt;validate([ 'title' =&gt; 'required|unique:posts|max:255', 'author.name' =&gt; 'required', 'author.description' =&gt; 'required',]); Displaying The Validation Errors Laravel validation 中, 我們不需要特別的 bind error message 以及 GET route, 但卻能夠把 error message 帶過去, 為什麼？因為 Laravel 將 error message 放在 flash session 當中 Laravel validation 中, $errors 變數是什麼的 instance?Illuminate\\Support\\MessageBag Laravel validation 中, $errors 變數是被哪一個 middleware 將之與 view 連接在一起?Illuminate\\View\\Middleware\\ShareErrorsFromSession Laravel 中, 如果我想要在 view 中顯示 errors, 我可以怎麼做？&lt;!-- /resources/views/post/create.blade.php --&gt;&lt;h1&gt;Create Post&lt;/h1&gt;@if ($errors-&gt;any()) &lt;div class=\"alert alert-danger\"&gt; &lt;ul&gt; @foreach ($errors-&gt;all() as $error) &lt;li&gt;&#123;&#123; $error &#125;&#125;&lt;/li&gt; @endforeach &lt;/ul&gt; &lt;/div&gt;@endif&lt;!-- Create Post Form --&gt; The @error Directive涉及前端, 目前尚不熟, 待日後學習前端時補上 A Note On Optional Fields Laravel 中, 空的 string 會被轉化成 null, 這是為什麼?因為以下兩個 global middleware TrimStrings ConvertEmptyStringsToNull Laravel validation 當中, 如果我要一直 input 是允許 null 的, 我可以加入哪一個 rule?nullable Form Request ValidationCreating Form Requests Laravel 中, 如果我要用 CLI 建立一個 “form request”, 我可以怎麼做？ php artisan make:request StoreBlogPort Laravel validation 當中, 我已經建立了一個 “form request”, 如果我想要加入驗證規則的話, 我可以怎麼做？ &lt;?php/** * Get the validation rules that apply to the request. * * @return array */public function rules()&#123; return [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ];&#125; 在以下的 Laravel validation “form request” 當中, 如果在 rule method 當中我需要一些 dependency, 那我可以怎麼做？ form request: &lt;?php/** * Get the validation rules that apply to the request. * * @return array */public function rules()&#123; return [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ];&#125; Answer:直接用 type-hint 加到 parameters 裏頭 在我建立一個 Laravel validation “form request” 後, 我該怎麼使用它呢？在 controller method type hint 這個 “form request” &lt;?php/** * Store the incoming blog post. * * @param StoreBlogPost $request * @return Response */public function store(StoreBlogPost $request)&#123; // The incoming request is valid... // Retrieve the validated input data... $validated = $request-&gt;validated();&#125; 以下的 validation “form request” 中, 如果我要拿到驗證過的 request, 我可以怎麼做？ 範例程式碼: &lt;?php/** * Store the incoming blog post. * * @param StoreBlogPost $request * @return Response */public function store(StoreBlogPost $request)&#123; // The incoming request is valid...&#125; Answer: &lt;?php/** * Store the incoming blog post. * * @param StoreBlogPost $request * @return Response */public function store(StoreBlogPost $request)&#123; // The incoming request is valid... // Retrieve the validated input data... $validated = $request-&gt;validated();&#125; 在 Laravel validation “form request” 當中, 如果我想要在 validate 之後再做額外的驗證, 我可以怎麼做？ &lt;?php/** * Configure the validator instance. * * @param \\Illuminate\\Validation\\Validator $validator * @return void */public function withValidator($validator)&#123; $validator-&gt;after(function ($validator) &#123; if ($this-&gt;somethingElseIsInvalid()) &#123; $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!'); &#125; &#125;);&#125; 在 Laravel validation “form request” 當中, 如果我想要在 validate 之後再做額外的驗證, 我可以在 “form request” 當中使用哪一個 method？withValidator Authorizing Form Requests Laravel 中, 如果我想要在 “form requests” 當中驗證一個 user 是否有相關 policy 定義的存取權限, 我可以使用哪一個 method?authorize() Laravel 中, 如果 “form request” 中的 authorize method return false, Laravel 會直接回什麼樣的 Response?403 Laravel 中, 如果我不打算使用 “form request” 中的 authorize, 我想在其他地方驗證權限部分, 那我必須要讓 authorize method return 什麼 response?true Customizing The Error Messages 在 Laravel 中, 如果我要客製化 “form request” 的錯誤訊息, 我可以使用哪一個 method?messages 在 Laravel 中, 如果我要客製化 “form request” 的錯誤訊息, 比如說, column title, 規則是 required, message 是 A title is required, 那我可以怎麼做？ &lt;?php/** * Get the error messages for the defined validation rules. * * @return array */public function messages()&#123; return [ 'title.required' =&gt; 'A title is required', 'body.required' =&gt; 'A message is required', ];&#125; Customizing The Validation Attributes 當我使用 Laravel validation 的 “form request” 時, 在以下的 Laravel validation response 當中, 如果我想要讓 response 的 email 變成 test email, 那我在 哪裏 使用 哪一個 method? 範例 response: &#123; \"message\": \"The given data was invalid.\", \"errors\": &#123; \"username\": [ \"The username field is required when email is not present.\" ], \"email\": [ \"The email field is required when username is not present.\" ] &#125;&#125; Answer: 在 form request 中 使用 attributes method 當我使用 Laravel validation 的 “form request” 時, 在以下的 Laravel validation response 當中, 如果我想要讓 response 的 email 變成 test email, 那我在 form request 中怎麼做? 範例 response: &#123; \"message\": \"The given data was invalid.\", \"errors\": &#123; \"username\": [ \"The username field is required when email is not present.\" ], \"email\": [ \"The email field is required when username is not present.\" ] &#125;&#125; Answer: &lt;?php/** * Get custom attributes for validator errors. * * @return array */public function attributes()&#123; return [ 'email' =&gt; 'test email', ];&#125; Prepare Input For Validation Laravel validation “form request” 中, 如果我想要讓 request 在被驗證之前先被處理過, 舉例來說, 我想要使用 Str::slug() 來處理 request 中的 slug, 我可以怎麼做？ &lt;?phpuse Illuminate\\Support\\Str;/** * Prepare the data for validation. * * @return void */protected function prepareForValidation()&#123; $this-&gt;merge([ 'slug' =&gt; Str::slug($this-&gt;slug), ]);&#125; Laravel validation “form request” 中, 如果我想要讓 request 在被驗證之前先被處理過, 我可以在 “form request” 中使用 哪一個 method?prepareForValidation() Manually Creating Validators 以下的 Laravel 範例程式碼是什麼意思？ 範例程式碼: &lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Validator;class PostController extends Controller&#123; /** * Store a new blog post. * * @param Request $request * @return Response */ public function store(Request $request) &#123; $validator = Validator::make($request-&gt;all(), [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ]); if ($validator-&gt;fails()) &#123; return redirect('post/create') -&gt;withErrors($validator) -&gt;withInput(); &#125; // Store the blog post... &#125;&#125; Answer: &lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Validator;class PostController extends Controller&#123; /** * Store a new blog post. * * @param Request $request * @return Response */ public function store(Request $request) &#123; // 手動建立一個 validator, make 的第一個 parameter 為 request, 第二個為 rules $validator = Validator::make($request-&gt;all(), [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ]); // 如果 validator 驗證失敗 if ($validator-&gt;fails()) &#123; // 重導向 post/create return redirect('post/create') // 將 error 存到 session -&gt;withErrors($validator) // 將指定的 input 存到 session, 若有帶則為帶入的 input array, 若沒帶則為 request-&gt;input, 可參考 https://github.com/laravel/framework/blob/6.x/src/Illuminate/Http/RedirectResponse.php#L74 -&gt;withInput(); &#125; // Store the blog post... &#125;&#125; Laravel validation 中, 什麼情況之下我會需要手動建立一個 validator?如果我想要控制 驗證到錯誤之後要做些什麼事 的情況 Laravel validation 中, 如果我希望在驗證到錯誤之後, 我可以選擇接下來要做的什麼事, 而不是遵循預設 Laravel 的行為, 我必須要手動的建立一個 validator, 那我可以使用哪個 class 的哪一個 method? use Illuminate\\Support\\Facades\\Validator class make method Laravel validation 中, 如果我希望在驗證到錯誤之後, 我可以選擇接下來要做的什麼事, 而不是遵循預設 Laravel 的行為, 我必需要手動的建立一個 validator, 我可以怎麼做？ &lt;?phpnamespace App\\Http\\Controllers;use App\\Http\\Controllers\\Controller;use Illuminate\\Http\\Request;use Illuminate\\Support\\Facades\\Validator;class PostController extends Controller&#123; /** * Store a new blog post. * * @param Request $request * @return Response */ public function store(Request $request) &#123; $validator = Validator::make($request-&gt;all(), [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required', ]); if ($validator-&gt;fails()) &#123; return redirect('post/create') -&gt;withErrors($validator) -&gt;withInput(); &#125; // Store the blog post... &#125;&#125; Automatic Redirection 以下的 Laravel 程式碼中, 我們手動建立了一個 validator, 如果我要讓這個 validator 有自動跳轉 (HTTP request)或回應 JSON(AJAX request) 的功能, 我可以怎麼做？ 程式碼: &lt;?phpValidator::make($request-&gt;all(), [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required',]); Answer: &lt;?phpValidator::make($request-&gt;all(), [ 'title' =&gt; 'required|unique:posts|max:255', 'body' =&gt; 'required',])-&gt;validate(); Named Error Bags 在 Laravel 中, $errors 是 MessageBag 的 instance, 試想, 如果我的前端頁面有多個 form, 而我必須給不同的 MessageBag 一個名字的話, 那我可以怎麼做？ 重導向 register 並且命名 MessageBag 為 login &lt;?phpreturn redirect('register') -&gt;withErrors($validator, 'login'); 在 Laravel 中, 假如我現在在前端頁面, 而我要從 $error 中取得名為 login 的 MessageBag instance 裡頭的 email, 我可以怎麼做？ &#123;&#123; $errors-&gt;login-&gt;first(&apos;email&apos;) &#125;&#125; After Validation Hook 在 Laravel validation 中, 假如我在 Controller 建立一個 validator 如下, 而我想要在驗證完成之後, 在自己加入額外的邏輯驗證, 我可以怎麼做？ 範例程式碼: &lt;?php$validator = Validator::make(...);if ($validator-&gt;fails()) &#123; //&#125; Answer: &lt;?php$validator = Validator::make(...);$validator-&gt;after(function ($validator) &#123; if ($this-&gt;somethingElseIsInvalid()) &#123; $validator-&gt;errors()-&gt;add('field', 'Something is wrong with this field!'); &#125;&#125;);if ($validator-&gt;fails()) &#123; //&#125; Working With Error Messages Laravel 中, 如果我呼叫 validator 的 errors method, 我會拿到 哪一個 class 的 instance?Illuminate\\Support\\MessageBag Laravel 中, $errors 這個全域變數是 哪一個 class 的 instance?Illuminate\\Support\\MessageBag Retrieving The First Error Message For A Field 從以下的 Laravel 程式碼中, 我們拿到了 $errors, 假設我驗了 email 欄位很多項規則, 現在我想要拿到 email 欄位的第一條錯誤訊息, 我可以怎麼做？ 範例程式碼: &lt;?php$errors = $validator-&gt;errors(); Answer: &lt;?php$errors = $validator-&gt;errors();echo $errors-&gt;first('email'); Retrieving All Error Messages For A Field 從以下的 Laravel 程式碼中, 我們拿到了 $errors, 假設我驗了 email 欄位很多項規則, 現在我想要拿到 email 欄位的所有錯誤訊息, 我可以怎麼做？ 範例程式碼: &lt;?php$errors = $validator-&gt;errors(); Answer: &lt;?php$errors = $validator-&gt;errors();foreach ($errors-&gt;get('email') as $message) &#123; //&#125; 從以下的 Laravel 程式碼中, 我們拿到了 $errors, 假設 attachments 這個欄位是一個 array, 而我要取得這個 array 下所有 elements 的錯誤訊息, 我可以怎麼做？ 範例程式碼: &lt;?php$errors = $validator-&gt;errors(); Answer: &lt;?php$errors = $validator-&gt;errors();foreach ($errors-&gt;get('attachments.*') as $message) &#123; //&#125; Retrieving All Error Messages For All Fields 從以下的 Laravel 程式碼中, 我們拿到了 $errors, 假設現在我要取得所有驗證過的欄位的所有錯誤訊息, 我可以怎麼做？ 範例程式碼: &lt;?php$errors = $validator-&gt;errors(); Answer: &lt;?php$errors = $validator-&gt;errors();foreach ($errors-&gt;all() as $message) &#123; //&#125; Determining If Messages Exist For A Field 如以下的 Laravel 程式碼, 我已經拿到了 $errors, 如果說現在我想要判斷某個特定欄位是否有錯誤, 我可以怎麼做？ 程式碼: &lt;?php$errors = $validator-&gt;errors(); Answer: &lt;?php$errors = $validator-&gt;errors();if ($errors-&gt;has('email')) &#123; //&#125; Custom Error Messages Laravel validation 中, 如果說我想要客製化錯誤訊息, 舉例來說, 只要是 required rule 的訊息都客製化成 The xxx is required, 如果要把 xxx 替換成欄位名稱, 我可以怎麼做？ &lt;?php$messages = [ 'required' =&gt; 'The :attribute field is required.',]; Laravel validation 中, 如果說我想要客製化錯誤訊息, 已有訊息如下, 那我該把這個訊息放到 哪一個 method 的 第幾個 argument？ 程式碼: &lt;?php$messages = [ 'required' =&gt; 'The :attribute field is required.',]; Answer: validator 第三個 Laravel validation 中, 如果說我想要客製化錯誤訊息, 已有訊息如下, 那我可以怎麼做？ 錯誤訊息: &lt;?php$messages = [ 'required' =&gt; 'The :attribute field is required.',]; Answer: &lt;?php$messages = [ 'required' =&gt; 'The :attribute field is required.',];$validator = Validator::make($input, $rules, $messages); Laravel validation 中, 如果我想要查詢各種在錯誤訊息中代表的相對應的 field, 我可以到哪一個檔案查詢？resources/lang/xx/validation.php, xx = 語言種類, 比如說, en Specifying A Custom Message For A Given Attribute Laravel validation 中, 如果我想要客製化錯誤訊息, 已有明確的欄位為 email, 規則為 required, 訊息內容為 We need to know your e-mail address!, 那我可以怎麼做？&lt;?php$messages = [ 'email.required' =&gt; 'We need to know your e-mail address!',]; Specifying Custom Messages In Language Files Laravel validation 中, 如果我要全域的客製化錯誤訊息, 可以在哪一個檔案中做修改?resources/lang/xx/validation.php, xx = 語言種類, 比如說, en Laravel validation 中, 如果我要全域的客製化錯誤訊息, 可以在 resources/lang/xx/validation.php 檔案中怎樣修改？?&lt;?php'custom' =&gt; [ 'email' =&gt; [ 'required' =&gt; 'We need to know your e-mail address!', ],], Specifying Custom Attributes In Language Files Laravel validation 中, 如果我想要全域的修改 attribute, 比如說, 將 email 替換成 email address, 可以在哪一個檔案中做修改？resources/lang/xx/validation.php Laravel validation 中, 如果我想要全域的修改 attribute, 比如說, 將 email 替換成 email address, 可以在 resources/lang/xx/validation.php 檔案中怎樣修改？&lt;?php'attributes' =&gt; [ 'email' =&gt; 'email address',], Specifying Custom Values In Language Files 在以下的 Laravel validation 程式碼中, 錯誤訊息會是 The credit card number field is required when payment type is cc., 如果我想要 global 的將 cc 替換成 credit card, 那我可以在哪一個檔案中修改？resources/lang/xx/validation.php 在以下的 Laravel validation 程式碼中, 錯誤訊息會是 The credit card number field is required when payment type is cc., 如果我想要 global 的將 cc 替換成 credit card, 那我可以在檔案 resources/lang/xx/validation.php 中怎樣修改？&lt;?php'values' =&gt; [ 'payment_type' =&gt; [ 'cc' =&gt; 'credit card' ],], Available Validation Rulesaccepted Laravel validation 中, 如果我要驗證一個 input 的 value 必須是 yes, on, 1, 或 true, 那我可以使用哪一個 rule?accepted active_url Laravel validation 中, 如果我要驗證一個 input 的 value 必須是一個 url, 經過 DNS 正解之後必須是 A 或 AAAA record, 我可以使用哪一個 rule?active_url after:date Laravel validation 中, 如果我要驗證一個 input 的 value 必須是一個指定日期之後, 我可以怎麼做？ &lt;?php'start_date' =&gt; 'required|date|after:tomorrow' Laravel validation 中, 如果我已經驗證了一個 input 的 value 須為日期如下, 那現在我想要驗證另外一個 input 的 value 須為日期, 且此日期須在第一個驗證的日期之後, 那我可以怎麼做？ 第一個 input validation: &lt;?php'start_date' =&gt; 'required|date|after:tomorrow' Answer: &lt;?php'finish_date' =&gt; 'required|date|after:start_date' after_or_equal:date Laravel validation 中, 如果我要驗證一個 input 必須跟我指定的一個日期相等, 或在指定的日期之後, 那我可以怎麼做？&lt;?php'start_date' =&gt; 'required|date|after_or_equal:tomorrow' alpha Laravel 中, 如果我要驗證一個 input 單純由字母所組成, 我可以使用哪一個 validation rule?alpha alpha_dash Laravel 中, 如果我驗證一個 input 只可含有 字母, 數字, - 或 _, 我可以使用哪一個 validation rule?alpha_dash alpha_num Laravel 中, 如果我驗證一個 input 只可含有 字母, 數字, 我可以使用哪一個 validation rule?alpha_num array Laravel 中, 如果我要驗證一個 input 必須是一個 array, 我可以使用哪一個 validation rule?array before:date Laravel 中, 如果我要驗證一個 input 必須是在某個指定的日期之前, 我可以使用哪一個 validation rule?before:date before_or_equal:date Laravel 中, 如果我要驗證一個 input 必須是相等於某個指定的日期, 或在這個日期之前, 那我可以使用哪一個 validation rule?before_or_equal:date between:min,max Laravel 中, 如果我要驗證一個 input 必須是介於兩個數值之間, 這兩個數值可以是 string, number, array 或 files, 我可以使用哪一個 validation rule?between:min,max boolean Laravel 中, 如果我要驗證一個 input 必須是 boolean, 即 true, false, 1, 0, &quot;1&quot;, 或 &quot;0&quot;, 那我可以使用哪一個 validation rule?boolean confirmed Laravel 中, 如果我在 password input 使用了 confirmed rule, 那我必須還要有另外一個 input 的名稱叫做什麼？password_confirmation Laravel 中, 如果我想要驗證兩個 input 必須有一模一樣的 value, 舉例來說, 讓用戶輸入密碼以及再次輸入密碼來確保用戶沒有不小心輸入錯誤, 那我可以使用哪一個 validation rule?confirmed date Laravel 中, 如果我要驗證一個 input 必須是 non-relative 的日期格式, 那我可以使用哪一個 validation rule?date date_equals:date Laravel中, 如果我要驗證一個 input 必須是一個日期且需與指定的日期相同, 那我可以使用哪一個 validation rule?date_equals:date date_format:format Laravel 中, 如果我要驗證一個 input 需跟我指定的日期格式相同, 那我可以使用哪一個 validation rule?date_format:format Laravel validation rule 當中, date_format 與 date 可否混用?不可 different:field Laravel validation 中, 如果我要驗證兩個 input 的 value 必須要是不同的, 那我可以使用哪一個 validation rule?different:field digits:value Laravel 中, 如果我要驗證一個 input 必須是 numeric, 且需與指定的位數一樣, 不可負數, 那我可以使用哪一個 validation rule?digits:value Laravel validation rule 中, digits:value 這個 rule 可否含有小數點？不可 Laravel validation rule 中, digits:value 這個 rule 可否含有負數？不可 digits_between:min,max Laravel 中, 如果我要驗證一個 input 必須為 numeric, 且長度須介於我指令的兩個 value, 那我可以使用哪一個 validation rule?digits_between:min,max dimensions Laravel 中, 如果我要驗證一個 input 必須是一個 image, 且尺寸須 100% 符合我指定的長寬及比例, 我可以使用哪一個 validation rule?dimensions:width=width,height=height Laravel 中, 如果我要驗證一個 input 必須是一個 image, 且尺寸須介於我指定的長寬及比例, 我可以使用哪一個 validation rule?dimensions:min_width=minWidth,max_width=maxWidth,min_height=minHeight,max_height=maxHeight,ratio=ratio1/ratio2 Laravel 中, 如果我要用 rule 的方式來使用 dimensions rule, 我可以怎麼做？Rule::dimensions()-&gt;maxWidth(1000)-&gt;maxHeight(500)-&gt;ratio(3 / 2) distinct Laravel 中, 假如我要驗一個 input, 這個 input 是一個 array, 我要確保 array 下的 field 的 value 必須不可重複, 舉例來說, foo array 下 不同 element 的 id field 的 value 必須不可相同, 我可以使用哪一個 validation rule?distinct email Laravel 中, 如果我要驗證一個 input, 其 value 必須是 email 格式, 我可以使用哪一個 validation rule?email Laravel 中, 可以使用不同的規則驗證 email 嗎？可以, 可參考官方文件 Laravel 中, validation email rule 預設使用哪一個 validation?RFCValidation ends_with:foo,bar,… Laravel 中, 如果我要驗證 input 必須是指定的 value 結尾, 我可以使用哪一個 validation rule?ends_with exclude_if:anotherfield,value Laravel 中, 如果我想要讓 input 的內容可以被 validate 以及 validated 排除, 當另外一個指定的 field 的 value 跟我指定的是相同的, 那我可以使用哪一個 validation rule?exclude_if:anotherfield,value exclude_unless:anotherfield,value Laravel 中, 如果我要預設就讓一個指定的 input 被 validate 以及 validated 排除驗證, 除非另外一個 field 的 value 跟我指定的是一樣的, 那我可以使用哪一個 validation rule?exclude_unless:anotherfield,value exists:table,column Laravel 中, 如果我要驗證一個 input, 這個 input 必須存在於指定的 table 中的指定 column, 那我可以使用哪一個 validation rule?exists:table,column Basic Usage Of Exists Rule 以下的 Laravel validation rule 當中, 什麼情況之下可以不需指定 column 名稱？ validation rule: &lt;?php'state' =&gt; 'exists:states' Answer:當 input 的 field 名稱跟 column 一樣時 Specifying A Custom Column Name 以下的 Laravel validation rule 當中, 第二個 argument 代表什麼？ validation rule: &lt;?php'state' =&gt; 'exists:states,abbreviation' Answer:指定該 table 中的 column Laravel 的 exists validation rule 中, 如果我要指定 connection, 該怎麼做？ 比如說, connection 為 test, table 為 staff, column 為 email &lt;?php'email' =&gt; 'exists:connection.staff,email' Laravel 中, exists validation rule 可以指定 model 來代替 table name 嗎？可以哦 Laravel 中, 如果我要使用 model name 來定義 exists validation rule, 我可以怎麼做？ &lt;?php'user_id' =&gt; 'exists:App\\User,id' Laravel 中, 如果我要驗證帶入的 email 必須存在於 staff table, 且其 account_id 欄位的值需為 1, 那我可以怎麼做？ &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::exists('staff')-&gt;where(function ($query) &#123; $query-&gt;where('account_id', 1); &#125;), ],]); 以下的 Laravel validation rule 代表什麼意思？ validation rule: &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::exists('staff')-&gt;where(function ($query) &#123; $query-&gt;where('account_id', 1); &#125;), ],]); Answer:驗證 email input 需存在於 staff table, 且期 account_id column 須為 1 file Laravel 中, 如果我要驗一個 input 必須是 file, 那我可以使用哪一個 validation rule?file filled Laravel 中, 如果我要驗一個 input, 內容不可為 empty, 我可以使用哪一個 validation rule?filled gt:field Laravel 中, 如果我要驗一個 input, 其 value 必須大於另外一個指定的 input, 我可以使用哪一個 validation rule?gt:field gte:field Laravel 中, 如果我要驗一個 input, 其 value 必須大於或等於另外一個指定的 input, 我可以使用哪一個 validation rule?gte:field image Laravel 中, 如果我要驗一個 input, 其 value 必須是一個 image, 即 jpeg, png, bmp, gif, svg, webp, etc…, 我可以使用哪一個 validation rule?image in:foo,bar,… Laravel 中, 如果我要驗一個 input, 其 value 必須要被你指定的 value list 包含在內, 那我可以使用哪一個 validation rule?in:foo,bar,… Laravel 中, 如果我要使用 Rule 來定義一個 in 規則, 我可以怎麼做？&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'zones' =&gt; [ 'required', Rule::in(['first-zone', 'second-zone']), ],]); in_array:anotherfield.* Laravel 中, 如果我要驗證一個 input, 其 value 必須被 另外一個 input 的 value 包含在內, 所以說另外一個 input 的 value 可能會是一個 array, 那我可以使用哪一個 validation rule?in_array:anotherfield.* integer Laravel 中, 如果我要驗一個 input, 其 value 必須是一個 integer, 我可以使用哪一個 validation rule?integer Laravel 中, validation rule integer, 會去驗證 input 的型別是否是 integer 嗎？不會 Laravel 中, validation rule integer, 實際上是驗證什麼？string 或是有著 數字的 string, 換句話說, 若是全數字的 string 也算通過 ip Laravel 中, 如果我要驗一個 input 是否一個 IP address, 我可以使用哪一個 validation rule?ip ipv4 Laravel 中, 如果我要驗一個 input, 其 value 是否符合 IPv4 address 格式, 我可以使用哪一個 validation rule?ipv4 ipv6 Laravel 中, 如果我要驗一個 input, 其 value 是否符合 IPv6 address 格式, 我可以使用哪一個 validation rule?ipv6 json Laravel 中, 如果我要驗一個 input, 其 value 是否為一個 json 字串, 我可以使用哪一個 validation rule?json lt:field Laravel 中, 如果我要驗一個 input, 其 value 必須小於另外一個指定的 input, 我可以使用哪一個 validation rule?lt:field lte:field Laravel 中, 如果我要驗一個 input, 其 value 必須小於或等於另外一個指定的 input, 我可以使用哪一個 validation rule?lte:field max:value Laravel 中, 如果我要驗一個 input, 其 value 必須 小於或等於 一個指定的 value, 那我可以使用哪一個 validation rule?max:value mimetypes:text/plain,… Laravel 中, 如果我要驗一個 input, 其 value 的 minetypes 必須符合指定值, 那我可以使用哪一個 validation rule? &lt;?php'video' =&gt; 'mimetypes:video/avi,video/mpeg,video/quicktime' Laravel 中, 當我使用 validation rule minetypes 時, 框架會真正去讀這個檔案嗎?會哦 Laravel 中, 當我使用 validation rule minetypes 時, 有可能框架驗到的跟 client 提供的 minetypes 不同嗎? 為什麼? 會哦 因為框架會自己去讀檔案, 不會以 client 提供的為依據 Laravel 中, validation rule minetypes, 是會比對實際上框架讀的 minetypes, 還是讀到 minetypes 之後再去取得相對應得副檔名？實際上框架讀的 minetypes mines:foo,bar Laravel 中, 如果我要驗一個 input, 其 value 必須要是我指定的 minetype 相對應的副檔名, 那我可以使用哪一個 validation rule?mines:foo,bar,… Laravel 中的 validation rule mines 會去呼叫哪一個 method?guessExtension Laravel 中的 validation rule mines 會去呼叫 guessExtension, 然後 guessExtension 會去呼叫哪一個 method?getMineType Laravel 中的 validation rule mines 會去讀檔案內容以判斷其 minetypes 嗎？會的 哪裡可以找到 minetype 以及其相對應的 extension?https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types min:value Laravel 中, 如果我要驗證一個 input, 其 value 必須大於或等於我所指定的一個值, 那我可以使用哪一個 validation rule?min:value not_in:foo,bar,… Laravel 中, 如果我要驗一個 input, 其 value 不可被包含在我所提供的一個 list 當中, 即該 list 可以是一個 array, 那我可以使用哪一個 validation rule?not_in:foo,bar,… Laravel 中, 如果我要使用 Rule 來定義 not_in, 那我可以怎麼做？&lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'toppings' =&gt; [ 'required', Rule::notIn(['sprinkles', 'cherries']), ],]); not_regex:pattern Laravel 中, 如果我要驗一個 input, 其 value 不可符合我所定義的 regex pattern, 那我可以使用哪一個 validation rule?not_regex:pattern Laravel, 當我使用 not_regex 及 regex 時, 該使用 array 形式, 還是 pipe 形式？array Larevel 的 validation rule regex 以及 not_regex, 其格式須符合 PHP 的哪一個 function?preg_match numeric Laravel 中, 如果我要驗一個 input, 其 value 需為 numeric, 那我可以使用哪一個 validation rule?numeric Laravel validation rule 中的 numeric 跟 integer 差別在哪？numeric 可以有小數點, integer 為整數 password Laravel 中, 如果我要驗一個 input, 其 value 必須可以通過登入者的 password 驗證, 那我可以使用哪一個 validation rule?password Laravel 的 validation rule password 可否指定 guard? 怎麼做？ 可&apos;password&apos; =&gt; &apos;password:api&apos; present Laravel 中, 如果說我要驗一個欄位必須要出現在 request 的 input list 裡, 至於有沒有 value 的話不管, 那我可以使用哪一個 validation rule?present required Laravel 中, 如果我要驗一個 input, 該欄位必須要出現在 input data 之中, 且欄位的值不可為 null, 那我可以使用哪一個 validation rule?required Laravel validation rule required 中, 欄位在哪四種情況下會被視為 “empty”? The value is null. The value is an empty string. The value is an empty array or empty Countable object. The value is an uploaded file with no path. Laravel 中, required 的驗證條件是？ input data 中必須要有該欄位 該欄位不可為 null Laravel 中, present 的驗證條件是？ input data 中必須要有該欄位就可, 欄位是否為空不驗 Laravel 中, filled 的驗證條件是？ input data 中如果有出現的欄位, 其欄位不可為 empty, 如果沒出現則不管 required_if:anotherfield,value,… Laravel 中, 如果我要驗一個 input, 情境需求如下, 我可以使用哪一個 validation rule? 需求: 如果該 input 的值與我指定的一個欄位的 value 一樣, 那我才使用以下規則 該 input 必須出現在 request 的 input list 中 該 input 的 value 不可為 empty Answer:required_if:anotherfield,value,… Laravel 中, 如果我使用 Rule class 來定義 required_if, 那 requiredIf method 接受什麼樣的 arguments? boolean closure Laravel 中, 如果我使用 Rule class 來定義 required_if, 並且帶入 closure, 那 closure 的輸出必須要是什麼型別？boolean Laravel, 如果我要使用 Rule class 來自定義 required_if, 假如條件是 $request-&gt;user()-&gt;is_admin, 帶入 boolean, 那我可以怎麼實作？ &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($request-&gt;all(), [ 'role_id' =&gt; Rule::requiredIf($request-&gt;user()-&gt;is_admin),]); Laravel, 如果我要使用 Rule class 來自定義 required_if, 假如條件是 $request-&gt;user()-&gt;is_admin, 帶入 closure, 那我可以怎麼實作？ &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($request-&gt;all(), [ 'role_id' =&gt; Rule::requiredIf(function () use ($request) &#123; return $request-&gt;user()-&gt;is_admin; &#125;),]); required_unless:anotherfield,value,… Laravel 中, 如果我要驗一個 input, 情境需求如下, 我可以使用哪一個 validation rule? 需求: 默認使用以下規則驗證, 除非該 input 的值與我指定的一個欄位的 value 一樣 該 input 必須出現在 request 的 input list 中 該 input 的 value 不可為 empty Answer:required_unless:anotherfield,value,.. required_with:foo,bar,… Laravel 當中, 如果我要驗一個 input, 規則如下, 那我可以使用哪一個 validation rule? 案例規則: 當某個指定的 field 出現在 input data 中時, 啟用以下規則 該 field 必須存在於 input data 該 field 的 value 不可為 empty Answer:required_with:foo,bar,… required_with_all:foo,bar,… Laravel 當中, 如果我要驗一個 input, 規則如下, 那我可以使用哪一個 validation rule? 案例規則: 當指定的 fields 全部都有出現在 input data 中時, 啟用以下規則 該 field 必須存在於 input data 該 field 的 value 不可為 empty Answer:required_with_all:foo,bar,… required_without:foo,bar,… Laravel 當中, 如果我要驗一個 input, 規則如下, 那我可以使用哪一個 validation rule? 案例規則: 當某個指定的 field 沒出現在 input data 中時, 啟用以下規則 該 field 必須存在於 input data 該 field 的 value 不可為 empty Answer:required_without:foo,bar,… required_without_all:foo,bar,… Laravel 當中, 如果我要驗一個 input, 規則如下, 那我可以使用哪一個 validation rule? 案例規則: 當指定的 fields 全部都沒有出現在 input data 中時, 啟用以下規則 該 field 必須存在於 input data 該 field 的 value 不可為 empty Answer:required_without_all:foo,bar,… same:field Laravel 當中, 如果我要驗一個 field, 其 value 必須跟我指定的另外一個 field 的 value 是一樣的, 那我可以使用哪一個 validation rule?same:field size:value Laravel 當中, 如果我要驗一個 field, 其 value 的 size 必須要跟我指定的相同, 那我可以使用哪一個 validation rule?size:value Laravel validation rule size:value 中, 如果 input 是 string, 那 value 會是？string 的字元數目 Laravel validation rule size:value 中, 如果 input 是 integer, 那 value 會是？integer 的值 Laravel validation rule size:value 中, 如果 input 是 array, 那 value 會是？array 的 count Laravel validation rule size:value 中, 如果 input 是 files, 那 value 會是？files 的大小 Laravel validation rule size:value 中, 如果 input 是 files, 那 value 會是 files 大小, 以什麼為單位？kilobytes starts_with:foo,bar,… Laravel 中, 如果我要驗一個 field, 其 value 必須要是指定的 value 開頭, 那我可以使用哪一個 validation rule?starts_with:foo,bar,… string Laravel 當中, 如果我要驗一個 field, 其 value 必須是不可為 null 的 string, 那我可以使用哪一個 validation rule?string timezone Laravel 當中, 如果我要驗一個 input, 其 value 必須是一個可被 PHP function timezone_identifiers_list 驗證合法的 timezone, 那我可以使用哪一個 validation rule?timezone unique:table,column,except,idColumn Laravel 中, 如果我要驗一個 input, 其 value 必須在一個指定的 table 以及 column 中是獨一無二的, 那我可以使用哪一個 validation rule?unique:table,column,except,idColumn Specifying A Custom Table / Column Name: Laravel validation rule unique 中, 除了指定 table 之外, 我可否指定 model?可 Laravel validation rule unique 中, 什麼樣的條件之下我可以不需指定 column ?當我 input 的 field name 跟 column name 一樣時 Custom Database Connection Laravel validation rule unique 中, 如果我要指定 database, 那我可以怎麼做？ 例如, 我要指定 carSharing database 中的 users table, column 為 email_address&lt;?php&apos;email&apos; =&gt; &apos;unique:connection.users,email_address&apos; Forcing A Unique Rule To Ignore A Given ID: Laravel validation rule unique 中, 如果說我要驗這個 input 為 unique, 但我要忽略一個指定的 row, 那我可以如何使用 Rule class 來實作？ &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::unique('users')-&gt;ignore($user-&gt;id), ],]); 當使用 Rule class 來實作 Laravel validation rule unique 時, 帶入 ignore method 的值可以從 request 獲得嗎？ 為什麼？ 不可 為防止 SQL injection 以下的 Laravel validation unique 透過 Rule class 的實作範例, 在 ignore method 中除了帶入 $user-&gt;id 之外, 我還可以帶入什麼？ 範例: &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::unique('users')-&gt;ignore($user-&gt;id), ],]); Answer:$user 以下的 Laravel validation unique 透過 Rule class 的實作範例, 如果說我的 primary column 的名稱不叫做 id, 而是叫做 user_id, 那我要怎麼修改？ 範例: &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::unique('users')-&gt;ignore($user-&gt;id), ],]); Answer: &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::unique('users')-&gt;ignore($user-&gt;id, 'user_id'), ],]); 以下的 Laravel validation unique 透過 Rule class 的實作範例, 如果說我的 column 不叫 email, 而是叫做 email_address, 那我可以怎麼修改？ 範例: &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::unique('users')-&gt;ignore($user-&gt;id), ],]); Answer: &lt;?phpuse Illuminate\\Validation\\Rule;Validator::make($data, [ 'email' =&gt; [ 'required', Rule::unique('users', 'email_address')-&gt;ignore($user-&gt;id, 'user_id'), ],]); Adding Additional Where Clauses 當使用 Laravel validation rule unique 時, 如果我要加入額外的 query constraints, 我可以怎麼做？ 假如說, users table 中 account_id 為 1 的都是指定範圍&lt;?php'email' =&gt; Rule::unique('users')-&gt;where(function ($query) &#123; return $query-&gt;where('account_id', 1);&#125;) url Laravel 中, 如果我要驗一個 input, 其 value 必須要是一個 url, 那我可以使用哪一個 validation rule?url uuid Laravel 中, 如果我要驗一個 input, 其 value 必須要是一個 uuid, 那我可以使用哪一個 validation rule?uuid Conditionally Adding RulesValidating When Present Laravel 中, 如果我要驗一個 input, 如果該 input 有出現在 request 的 input array 中的話我才驗, 若是不存在我就不驗, 那我可以使用哪一個 validation rule?sometimes 以下的 validation rule 中, 如果 email 有出現在 request 的 input array 當中時我就驗, 如果沒出現的話那我就略過這個驗證, 我可以怎樣修改這個 validation rule? 範例: &lt;?php$v = Validator::make($data, [ 'email' =&gt; 'required|email',]); Answer: &lt;?php$v = Validator::make($data, [ 'email' =&gt; 'sometimes|required|email',]); Complex Conditional Validation Laravel 中, 如果說我要有條件式的對指定的欄位附加規則驗證, 當條件滿足為 true 我才驗, 當條件不滿足為 false 我就不驗, 那我可以使用 哪一個 instance 的 哪一個 method? validator sometimes 以下的 Laravel 範例中, 如果說, 當 games 的 value 大於 100 的話就驗 reason 欄位, 驗的規則為 required|max:500, 那我可以怎麼做？ 範例: &lt;?php$v = Validator::make($data, [ 'email' =&gt; 'required|email', 'games' =&gt; 'required|numeric',]); Answer: &lt;?php$v-&gt;sometimes('reason', 'required|max:500', function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); 請解釋以下的 Laravel 程式碼的語意？ 程式碼 &lt;?php$v-&gt;sometimes('reason', 'required|max:500', function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); Answer:如果 closure 的 return 值為 true, 就驗 reason 這個 input, rule 為 required|max:500 以下的 Laravel 程式碼中, 如果我要在符合條件後, 一次驗多個 input, 舉例來說, input 為 reason 跟 cost, 那我可以怎麼修改？ 程式碼 &lt;?php$v-&gt;sometimes('reason', 'required|max:500', function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); Answer: &lt;?php$v-&gt;sometimes(['reason', 'cost'], 'required|max:500', function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); 以下的 Laravel 程式碼中, $input 是哪一個 class 的 instance? 程式碼 &lt;?php$v-&gt;sometimes('reason', 'required|max:500', function ($input) &#123; return $input-&gt;games &gt;= 100;&#125;); Answer:Illuminate\\Support\\Fluent Validating Arrays Laravel validation 當中, 如果說 photos 是一個 array, 我要驗證該 photos 裡 key 為 profile 的 value, 該 value, 規則為 required|image, 那我可以怎麼做？ &lt;?php$validator = Validator::make($request-&gt;all(), [ 'photos.profile' =&gt; 'required|image',]); Laravel 中, 如果說我 person 是一個 array, 下面有複數的 index, 每個 index 裡都有 email, first_name 等等… 資訊, 如果說我要針對每個 index 下面的 email 去做驗證, 那我可以怎麼做？ &lt;?php$validator = Validator::make($request-&gt;all(), [ 'person.*.email' =&gt; 'email|unique:users', 'person.*.first_name' =&gt; 'required_with:person.*.last_name',]); Custom Validation Rules Laravel 中, 如果我要客製 validation rule 的話, 有哪幾種方式？ rule object closure extensions Using Rule Objects Laravel 中, 如果我要使用 CLI 建立一個 rule, 指令該怎麼下？ php artisan make:rule RuleName Laravel validation 中, 當我在定義 rule object 時, 可使用哪兩個主要 method? passes message Laravel validation 中, 當我使用 rule object 時, passes method 的 argument 是什麼？ attribute key attribute value Laravel validation 中, 當我使用 rule object 時, passes method 的 return 值是什麼？boolean Laravel validation 中, 當我使用 rule object 時, message method 的 return 值是什麼？error message 以下的 Laravel rule object 範例中, 如果我要將規則定義成, attribute 的 value 必須是 1, 那我可以怎麼修改？ Example: &lt;?phpnamespace App\\Rules;use Illuminate\\Contracts\\Validation\\Rule;class Uppercase implements Rule&#123; /** * Determine if the validation rule passes. * * @param string $attribute * @param mixed $value * @return bool */ public function passes($attribute, $value) &#123; return strtoupper($value) === $value; &#125; /** * Get the validation error message. * * @return string */ public function message() &#123; return 'The :attribute must be uppercase.'; &#125;&#125; Answer: &lt;?phpnamespace App\\Rules;use Illuminate\\Contracts\\Validation\\Rule;class Uppercase implements Rule&#123; /** * Determine if the validation rule passes. * * @param string $attribute * @param mixed $value * @return bool */ public function passes($attribute, $value) &#123; return $value === 1; &#125; /** * Get the validation error message. * * @return string */ public function message() &#123; return 'The :attribute must be uppercase.'; &#125;&#125; 在以下的 Laravel validation rule object 的 message method 當中, 如果我想要從 translation file 中 return 錯誤訊息的話, 我可以怎麼做? Example: &lt;?php/** * Get the validation error message. * * @return string */public function message()&#123; //&#125; Answer: &lt;?php/** * Get the validation error message. * * @return string */public function message()&#123; return trans('validation.uppercase');&#125; Laravel validation 中, 如果我已經自定義好 rule object 了, 在以下的範例中, 我該怎麼使用它? 假設定義好的 rule 叫做 Uppercase Example: &lt;?phpuse App\\Rules\\Uppercase;$request-&gt;validate([ 'name' =&gt; ['required', 'string'],]); Answer: &lt;?phpuse App\\Rules\\Uppercase;$request-&gt;validate([ 'name' =&gt; ['required', 'string', new Uppercase],]); Using Closures Laravel validation 中, 如果我要使用 closure 自定義一個 rule, 在以下的範例中, 我可以把 closure 放在哪？ Example: &lt;?php$validator = Validator::make($request-&gt;all(), [ 'title' =&gt; [ 'required', 'max:255', ],]); Answer: &lt;?php$validator = Validator::make($request-&gt;all(), [ 'title' =&gt; [ 'required', 'max:255', function ($attribute, $value, $fail) &#123; if ($value === 'foo') &#123; $fail($attribute.' is invalid.'); &#125; &#125;, ],]); Laravel validation 中, 如果我要使用 closure 自定義一個 rule, 第幾個 closure 的 argument 代表 input 欄位的名稱?第一個, $attribute Laravel validation 中, 如果我要使用 closure 自定義一個 rule, 第幾個 closure 的 argument 代表 input 欄位的 value?第二個, $value Laravel validation 中, 如果我要使用 closure 自定義一個 rule, 第幾個 closure 的 argument 代表 error message?第三個, $fail 請根據以下的 Laravel 使用情境, 使用 closure 來自訂一個 rule Requirement: input 名稱為 ‘title’ 如果 input 的 value 必須等於 ‘foo’ 如果不等於, 返回錯誤訊息 ‘title is invalid’ Answer:&lt;?php$validator = Validator::make($request-&gt;all(), [ 'title' =&gt; [ 'required', 'max:255', function ($attribute, $value, $fail) &#123; if ($value === 'foo') &#123; $fail($attribute.' is invalid.'); &#125; &#125;, ],]); Using Extensions Laravel 中, 請解釋以下的 extension example Example: &lt;?phpnamespace App\\Providers;use Illuminate\\Support\\ServiceProvider;use Illuminate\\Support\\Facades\\Validator;class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Validator::extend('foo', function ($attribute, $value, $parameters, $validator) &#123; return $value == 'foo'; &#125;); &#125;&#125; Answer: 在 AppServiceProvider 的 boot method 定義 closure 的參數 $attribute 為 input 名稱 $value 為 input value $parameters 為一個 array, 要帶入 rule 的參數 $validator 為 Validator instance Laravel 中, 當我使用 extension 來自定義 validation rule 時, 是在哪一個檔案裡定義？AppServiceProvider Laravel 中, 當我使用 extension 來自定義 validation rule 時, 是在哪一個 AppServiceProvider 中的哪一個 method 裡定義？boot Laravel 中, 當我使用 extension 來自定義 validation rule 時, 是使用哪一個 class 的哪一個 method? validator extend Laravel 中, 當我使用 extension 來自定義 validation rule 時, validator::extend() 的 extend method 有兩個重要 argument 依序分別是？ ruleName closure Laravel 中, 當我使用 extension 來自定義 validation rule 時, validator::extend() 中, 除了帶入 closure 外, 還可以帶入什麼？一個 class 的 method, 像是&lt;?phpValidator::extend('foo', 'FooValidator@validate'); Defining The Error Message Laravel 中, 當我使用 extension 來自定義 validation rule 時, Error Message 可以定義在哪？extend method 的第三個 argument 或 language validation file 中 Laravel 中, 當我使用 extension 來自定義 validation rule 時, 我可以經 Error Message 定義在 language validation file 的哪一層中？第一層 Laravel 中, 當我使用 extension 來自定義 validation rule 時, 我可以經 Error Message 定義在 language validation file 的第一層, 為什麼不是定義在 custom 層下？因為這是一個新的 rule 的 message, 不是 attribute-specific message Laravel 中, 當我使用 extension 來自定義 validation rule 時, 我們可能會需要設定一些佔位符, 例如 :attribute, :value, :other 這些, 那我可以使用哪一個 class 的哪一個 method 來定義這些佔位符呢？ Validator replacer Laravel 中, 當我使用 extension 來自定義 validation rule 時, 我可以在哪個地方使用 Validator::replacer 來自定義佔位符？AppServiceProvider 的 boot method 在以下的 Validator::replacer 自定義佔位符範例中, 如果說我要使用 $parameters 來取代 :value 跟 :other, 那我可以怎麼修改？ Example: &lt;?php/** * Bootstrap any application services. * * @return void */public function boot()&#123; Validator::extend(...); Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) &#123; return str_replace(...); &#125;);&#125; Answer: &lt;?php/** * Bootstrap any application services. * * @return void */public function boot()&#123; Validator::extend(...); Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) &#123; return str_replace(array(':value', ':other'), $parameters, $message); &#125;);&#125; Implicit Extensions 以下的 Laravel validation example 的結果會是 true 還是 false? Why? Example: &lt;?php$rules = ['name' =&gt; 'unique:users,name'];$input = ['name' =&gt; ''];Validator::make($input, $rules)-&gt;passes(); Answer: true 因為 rule 對於沒有 present 的 attribute, 或值為 empty string 的 attribute 不會生效 當使用 Laravel validation extension rule 時, 如果驗證對象 attribute 沒有出現在 input array list 當中的話, Laravel 預設不會執行這個 rule, 那如果我要強制執行該 rule, 除了加入 required rule 之外, 還可以怎麼做？使用 Validator::extendImplicit() method 當使用 Laravel validation rule object 時, 如果驗證對象 attribute 沒有出現在 input array list 當中的話, Laravel 預設不會執行這個 rule, 那如果我要強制執行該 rule, 除了加入 required rule 之外, 還可以怎麼做？在該 rule object 中 implement Illuminate\\Contracts\\Validation\\ImplicitRule","link":"/zh-tw/laravelTheBasicsValidation/"},{"title":"Netdata 學習筆記","text":"前言這是一份未整理過的 Netdata 學習筆記內容參考出處：官方文件 Configuration (設定檔)檔案位置: /etc/netdata/netdata.conf backend[backend] enabled = yes | no type = graphite | opentsdb:telnet | opentsdb:http | opentsdb:https | prometheus_remote_write | json | kinesis | mongodb host tags = list of TAG=VALUE destination = space separated list of [PROTOCOL:]HOST[:PORT] - the first working will be used, or a region for kinesis data source = average | sum | as collected prefix = Netdata hostname = my-name update every = 10 buffer on failures = 10 timeout ms = 20000 send charts matching = * send hosts matching = localhost * send names instead of ids = yes enabled = yes | no, 開啟或關閉後端 type = graphite | opentsdb:telnet | opentsdb:http | opentsdb:https | json | kinesis | mongodb, 選擇後端類型 destination = host1 host2 host3 ..., 接受一個空白來分開多個欲連接的 hostnames, IPs (IPv4 以及 IPv6), 以及 port 號。 Netdata 會使用第一個可用目的地來傳送指標。 每個品項的格式 [PROTOCOL:]IP[:PORT] PROTOCOL 可以是 udp 或 tcp, 預設為 tcp 且只被目前的後端支援。 IP 可以是 XX.XX.XX.XX (IPv4), 或 [XX:XX…XX:XX] (IPv6). IPv6 的話你可以將 IP 包在 [] 內來與 port 分開。 PORT 可以是服務名稱的號碼。 如果沒填, 後端預設的 PORT 將會被使用 (graphite = 2003, opentsdb = 4242) IPv4 範例： destination = 10.11.14.2:4242 10.11.14.3:4242 10.11.14.4:4242 IPv4 以及 IPv6 範例： destination = [ffff:...:0001]:2003 10.11.12.1:2003 當多個 server 被定義, 第一個失敗時, Netdata 將會自動嘗試下一個。 這讓我們可以平衡負載不同的 server: 在每一個 Netdata 給予不同的後端服務順序 Netdata 也提供了 nc-backend.sh, 一個備用解決方法來將指標先存到硬碟中, 待 time-series 資料庫可用了, 再將資料傳到資料庫。 它也可用來監控 / 追蹤 / 除錯 Netadata 產生的指標。 如果是 kinesis 後端目的地, 應該要被設定成 AWS region (例如, us-east-1) MongoDB 後端在這設定中不使用 destination 選項, 它使用 mongodb.conf 設定 data source = as collected, 或 data source = average, 或 data source = sum, 選擇要被傳送到後端的資料類型 as-collected: 當指標被採集時, 傳送到後端, 以他們被採集時的單位。 所以說， counter 將會以 counter 傳送, gauge 也被以 gauge 傳送, 就像所有的資料採集器那樣。 例如說, 若要算出在這格式下的 CPU 使用率，你需要知道怎麼轉換 kernel ticks 到百分比 average: 將正規化之後的指標從 Netdata 資料庫傳送到後端。 在這個模式下，所有的指標都被以 gauges 傳送，並且使用 Netdata 使用的單位。 這抽象化了資料收集以及簡單化了視覺顯示，但你將沒有辦法從其他來源複製貼上 query 來轉換單位。 例如， CPU 使用百分比是被 Netdata 計算，所以 Netdata 將會轉換 ticks 到百分比，然後傳送平均百分比到後端 sum or volume: Netdata 圖表上的總合將會被傳送到後端。 所以，如果 Netdata 被設定為每 10 秒傳送資料一次，那 10 秒的總合將會被傳送。 Time-series 資料庫建議以原始數值的方式收集資料 (as-collected)。 如果你打算建立你自己的監控系統搭配 time-series 資料庫，且你已經（或你將會花時間學習）知道如何轉換單位以及正規化資料已符合 Grafana 或其他視覺化工具，我們建議使用 as-collected 如果，另一方面，你只是需要長期的 Netdata 資料歸檔，並且妳主要打算使用 Netdata, 我們建議使用 average。 它將視覺化以及資料收集分離，所以整體來說它會簡單很多。 再進一步來說，如果你使用 average, 在後端看到的圖表將會完全符合你在 Netdata 看到的，如果是在別種模式的話，可能不是這樣。 利用 InfluxDB 作為 Netdata backendNetdata安裝bash &lt;(curl -Ss https://my-netdata.io/kickstart.sh) --dont-wait Config 開啟設定檔 vim /etc/netdata/netdata.conf 設定 [backend] # host tags = enabled = yes data source = average type = opentsdb destination = localhost:4242 # prefix = netdata # hostname = netdata update every = 10 # buffer on failures = 10 # timeout ms = 20000 # send names instead of ids = yes # send charts matching = * # send hosts matching = localhost * 重新啟動 systemctl restart netdata InfluxDB安裝參考官方流程 開啟設定檔vim /etc/influxdb/influxdb.conf 設定[[opentsdb]] enabled = true bind-address = \"localhost:4242\" database = \"opentsdb\"","link":"/zh-tw/netdata/"},{"title":"NGINX 學習筆記","text":"前言這是我的 NGINX 學習筆記，看什麼學什麼記什麼！ 安裝sudo apt-get install nginx 建立新的設定檔vim /etc/nginx/sites-available/configName server &#123;listen 80;server_name yourServerName;access_log /locationYouPrefer;listen 443 ssl;ssl_certificate /location/fullchain.pem;ssl_certificate_key /location/privkey.pem; location /upstream &#123;proxy_set_header Host www.tu8686.com;set $upstream_url 210.209.13.49:80;proxy_pass http://$upstream_url;add_header Q-Status $upstream_cache_status;break;&#125;location / &#123;proxy_pass_header Server;proxy_redirect off;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Scheme $scheme;proxy_pass http://127.0.0.1:50005; &#125;&#125; proxy_pass_header: 若回應 request 時, header 有設定了, 那告訴 NGINX 不要更改設定的 header, 若要加 header 需使用 via, 例如 範例圖片 server_name: request 的 header 中的 server 需符合 access_log: log 的位置 location: 符合 server 後, 改搜尋相對應的 location proxy_redirect: 重新導向 proxy_set_header: 設定 header 值 proxy_pass: 將 request 導向指定的位置 proxy_set_header: set host set $upstream_url: set $upstream_url add_header: add header break: 終止目前的 rewrite 規則。 如果有規則是被指定在目前的 location 內的，繼續將此 location 的 request 處理完畢。 啟用設定檔複製到 enabled 資料夾ln -s /etc/nginx/sites-available/yourConfig /etc/nginx/sites-enabled 啟用systemctl restart nginx.service location參考官方文件 語法Syntax: location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;location @name &#123; ... &#125;Default: —Context: server, location 規則搜尋分為以下兩種方式 正則搜尋 (regular expression) ~*: 不區分大小寫 ~: 區分大小寫 前綴字串 (prefix string) 規則搜尋順序：使用前綴字串搜尋 &rarr; 搜尋到符合最長的 url, 並且記下結果 &rarr; 依照設定檔中的順序， 使用正則規則搜尋 &rarr; 如果正則規則有搜尋到符合的，會立即停止搜尋，因此正則順序至關重要 &rarr; 如果正則沒有搜尋到符合的，會採用使用前綴字串搜尋到的 在一些不區分大小寫的系統中，像是 macOS 或是 Cygwin, 前綴字串規則會無視大小寫 正則規則可以捕捉一些變數，在其他的規則中使用 如果最長的前綴字串規則有 ^~, 那就不會再使用正則規則搜尋 前綴規則有 =, 代表字串須完全符合，如果有找到，搜尋終止。 例如，如果 “/“ 請求很頻繁，那麼可以定義 “location = /“, 這樣可以加速請求處理 在版本 0.7.1 到 0.8.41 中，如果請求符合前綴規則，就算沒有加上 =, 或者 ^~, 搜尋也會立即停止 範例location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; 請求 / 將會符合 A 請求 /index.html 將會符合 B 請求 /documents/document.html 將會符合 C 請求 /images/1.gif 將會符合 D 請求 /documents/1.jpg 將會符合 E 請求 @name: 只用於內部重新導向，不用於正常使用, 例如：location /img/ &#123; not_found 404 @not_found; &#125; location @not_found &#123; # 规则 &#125; alias 與 rootalias參考文件定義特定 location 的替換。 舉例來說, 看看下面的設定 location /i/ &#123; alias /data/w3/images/;&#125; 如果請求是 /i/top.git 的話, 檔案 /data/w3/images/top.git 將會被送出 路徑可以包含變數, 除了 $document_root 以及 $realpath_root 之外 如果 alias 被使用在正則定義的 location 之內, 那 alias 必須要參考正則捕捉到的條件, 範例如下： location ~ ^/users/(.+\\.(?:gif|jpe?g|png))$ &#123; alias /data/w3/images/$1;&#125; 當 location 的值跟 alias 的最後一個資料夾的值相同, 像下面這樣： location /images/ &#123; alias /data/w3/images/;&#125; 那會建議使用 rootlocation /images/ &#123; root /data/w3;&#125; root參考文件設定 root 的資料夾位置為請求路徑, 例如以下範例： location /i/ &#123; root /data/w3;&#125; /data/w3/i/top.git 檔案將會被送出, 以回應 /i/top.git 請求 路徑可以包含變數, 除了 $document_root 以及 $realpath_root 之外 總結 alias 會取代 location 成為新的請求資源路徑 root + location 的值 = 請求資源路徑 部署 vue 專案Buildnpm run build, 看 script 怎麼寫, 這邊只管部署 configserver &#123; # Listen port 號 listen 8080; # Server name server_name localhost; # Log 位置 access_log logs/host.access.log; # root 位置, 可以參考上面的 root 詳解 root /Users/rainy/Desktop/MyWork/Work/website/dist; # 預設檔案 index index.html index.htm; location / &#123; # try to find $uri, and then $uri/, and if they both are not found, go for @router try_files $uri $uri/ @router; # If the path is found, go for index file below index index.html index.htm; &#125; location @router &#123; # rewite whatever to /index.html # 不管 request 是什麼, 都 rewrite 到 /index.html, 並且執行 last, last 代表說, 結束這一次的 rewrite 規則, 並且使用 rewrite 後的結果重新對 server 發一次請求 rewrite ^.*$ /index.html last; &#125;&#125; upstream語法Syntax: upstream name &#123; ... &#125;Default: —Context: http 範例upstream backend &#123; server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; server backup1.example.com backup;&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; 詳解定義多個 server, server 可以 listen 不同的 port 號, TCP 以及 UNIX-domain socket 可以混用預設的話, 會採用權重輪詢分配請求到不同的 server, 以上面的範例來看, 每 7 個 request 中, 5 個會被分配到 backend1.example.com (weight=5), 2 個分別到 127.0.0.1:8080 以及 unix:/tmp/backend3如果在溝通途中有錯誤, 請求會被分派到下一個 server, 直到出現成功回應的 server 。 如果裡面都沒有可以成功回應的, 那客戶端會收到最後一個 server 的回應 (backup) PHP-FPMfast 請求網址為 http://lemp.test/test.php/foo/bar.php?v=1 各項資訊如下:array ( &apos;USER&apos; =&gt; &apos;www-data&apos;, &apos;HOME&apos; =&gt; &apos;/var/www&apos;, &apos;FCGI_ROLE&apos; =&gt; &apos;RESPONDER&apos;, &apos;QUERY_STRING&apos; =&gt; &apos;v=1&apos;, &apos;REQUEST_METHOD&apos; =&gt; &apos;GET&apos;, &apos;CONTENT_TYPE&apos; =&gt; &apos;&apos;, &apos;CONTENT_LENGTH&apos; =&gt; &apos;&apos;, &apos;SCRIPT_FILENAME&apos; =&gt; &apos;/var/www/test.php&apos;, &apos;SCRIPT_NAME&apos; =&gt; &apos;/test.php&apos;, &apos;PATH_INFO&apos; =&gt; &apos;/foo/bar.php&apos;, &apos;REQUEST_URI&apos; =&gt; &apos;/test.php/foo/bar.php?v=1&apos;, &apos;DOCUMENT_URI&apos; =&gt; &apos;/test.php/foo/bar.php&apos;, &apos;DOCUMENT_ROOT&apos; =&gt; &apos;/var/www&apos;, &apos;SERVER_PROTOCOL&apos; =&gt; &apos;HTTP/1.1&apos;, &apos;GATEWAY_INTERFACE&apos; =&gt; &apos;CGI/1.1&apos;, &apos;SERVER_SOFTWARE&apos; =&gt; &apos;nginx/1.4.0&apos;, &apos;REMOTE_ADDR&apos; =&gt; &apos;192.168.56.1&apos;, &apos;REMOTE_PORT&apos; =&gt; &apos;44644&apos;, &apos;SERVER_ADDR&apos; =&gt; &apos;192.168.56.3&apos;, &apos;SERVER_PORT&apos; =&gt; &apos;80&apos;, &apos;SERVER_NAME&apos; =&gt; &apos;&apos;, &apos;HTTPS&apos; =&gt; &apos;&apos;, &apos;REDIRECT_STATUS&apos; =&gt; &apos;200&apos;, &apos;HTTP_HOST&apos; =&gt; &apos;lemp.test&apos;, &apos;HTTP_USER_AGENT&apos; =&gt; &apos;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:20.0) Gecko/20100101 Firefox/20.0&apos;, &apos;HTTP_ACCEPT&apos; =&gt; &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;HTTP_ACCEPT_LANGUAGE&apos; =&gt; &apos;en-US,en;q=0.5&apos;, &apos;HTTP_ACCEPT_ENCODING&apos; =&gt; &apos;gzip, deflate&apos;, &apos;HTTP_CONNECTION&apos; =&gt; &apos;keep-alive&apos;, &apos;PHP_SELF&apos; =&gt; &apos;/test.php/foo/bar.php&apos;, &apos;REQUEST_TIME&apos; =&gt; 1367829847,) Q&amp;A 以下的設定中, location ~ \\.php$ 中, 最終帶過去的 fastcgi_param 是什麼？ $query_string, 原本的 $request_method 跟 $document_root, $fastcgi_script_name 會處於未設定 # server contextroot /var/www/html;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;fastcgi_index index.php;location /scripts &#123; fastcgi_pass unix:/var/run/php5-fpm.sock;&#125;location ~ \\.php$ &#123; fastcgi_param QUERY_STRING $query_string; fastcgi_pass 127.0.0.1:9000;&#125; 在以下的設定中, 如果使用 PHP-FPM 的話, 最終傳出的 fastcgi_param TEST 跟 DOCUMENT_ROOT 是？ three, override # server contextlocation ~ \\.php$ &#123; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param SCRIPT_FILENAME $request_uri; fastcgi_param DOCUMENT_ROOT initial; fastcgi_param DOCUMENT_ROOT override; fastcgi_param TEST one; fastcgi_param TEST two; fastcgi_param TEST three; fastcgi_pass 127.0.0.1:9000;&#125; 不同的 FastCGI 處理器的作用方式依樣嗎？ 不同哦 因為不同的 FastCGI 處理器行為不同, 所以宣告 fastcgi_param 時, 建議宣告幾次？ 1次 當我們使用 PHP-FPM, 要 pass fastcgi_params 時, 怎樣可以在不同的 location 中在保留共同變數的同時, 又可以客制新的變數？ 使用 include 共同檔案, 如下： root /var/www/html;location /scripts &#123; include fastcgi_common; fastcgi_index index.php; fastcgi_pass unix:/var/run/php5-fpm.sock;&#125;location ~ \\.php$ &#123; include fastcgi_common; fastcgi_param QUERY_STRING $query_string; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000;&#125; CGI 全寫？ Common Gateway Interface Fast CGI 全寫？ Fast Common Gateway Interface CGI 用途？ 一份協議, 規定要傳哪些數據, 以什麼樣的格式給後端 Fast CGI 用途？ 依據 CGI 協議, 將請求以及數據傳給後端這個動作, 每一次都會產生一個程序, Fast CGI 會啟動一個主程序, 並將工作分配給子進程處理, 避免重複的勞動, 提高效率 PHP-FPM 全寫? PHP-Fast CGI Process Manager PHP-FPM 用途? PHP 針對 FastCGI 的實現 如何使用 systemctl 啟動 Nginx sudo systemctl start nginx 如何使用 systemctl, 預設開機啟動 NGINX? sudo systemctl enable nginx 如何使用 systemctl, 停止 nginx? sudo systemctl stop nginx 如何使用 systemctl, 重啟 nginx? sudo systemctl restart nginx 如何使用 systemctl, 重新載入 nginx 配置文件？ sudo systemctl reload nginx 如何測試 nginx 配置？ sudo nginx -t 如何使用 systemctl, 顯示 nginx 狀態？ sudo systemctl status nginx 如何檢查 nginx 版本？ sudo nginx -v 在 NGINX 中如果我想要從本地帶客製的 header 到 server, 該 header 的 key 有 underscore, 該怎麼解決？ 在 NGINX server block 中加入以下設定underscores_in_headers on; NGINX 中, location 的規則搜尋, 又區分為哪兩種？ 1. 正則搜尋2. 前贅字串 NGINX 中, location 的正則搜尋中, ~* 代表的意思是？ 不區分大小寫 NGINX 中, location 的正則搜尋中, ~ 代表的意思是？ 區分大小寫 NGINX 中, location 的規則搜尋的順序？ 1. 使用前綴字串搜尋2. 搜尋到符合最長的 uri, 記錄下來3. 依照設定檔中的順序, 使用正則搜尋4. 若正則有找到, 停止搜尋, 以正則的為主5. 若正則沒找到, 以前最字串為主 NGINX 中, location 的規則搜尋的順序, 會先使用哪種規則搜尋? 前贅字串 NGINX 中, location 的規則搜尋的順序, 前綴字串搜尋結束後, 會使用什麼規則搜尋? 正則 NGINX 中, location 的規則搜尋的順序, 若再找到符合的前綴字串後, 還是使用正則搜尋一次嗎？? 會 NGINX 中, location 的規則搜尋的順序, 若正則規則找到符合的, 還會繼續搜尋嗎？ 不會 NGINX 中, location 的規則搜尋的順序, 若前綴跟正則都有符合的, 以哪種為優先？ 正則 NGINX 中, location 的規則搜尋中, macOS 會區分大小寫嗎？ 不會 NGINX 中, location 的規則搜尋中, 如何捕捉變數？ 使用正則 NGINX 中, location 的規則搜尋中, ^~ 代表什麼意思？ 當使用 ^~ 的前綴有找到符合的, 不會再使用正則搜尋 NGINX 中, location 的規則搜尋中, ^~ 是用於前綴還是正則？ 前綴 NGINX 中, location 的規則搜尋中, = 是用於前綴還是正則？ 前綴 NGINX 中, location 的規則搜尋中, = 代表什麼意思？ 前綴須完全符合, 若有找到, 搜尋停止 NGINX 中, location 的規則搜尋中, 如果 / 的搜尋非常頻繁, 可以使用什麼樣的規則來加快速度？ = / NGINX 中, location 的規則搜尋中, 下圖中, 請求 / 會符合哪一個？ A location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 /index.html 會符合哪一個？ B location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 documents/document.htm 會符合哪一個？ C location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 images/1.gif 會符合哪一個？ D location = / &#123; [ configuration A ]&#125;location / &#123; [ configuration B ]&#125;location /documents/ &#123; [ configuration C ]&#125;location ^~ /images/ &#123; [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; [ configuration E ]&#125; NGINX 中, location 的規則搜尋中, 下圖中, 請求 @name 可否用於正常使用？ 不可 location /img/ &#123; not_found 404 @not_found; &#125; location @not_found &#123; # 规则 &#125; NGINX 中, alias 與 root 的規則中, 下圖中, 如果請求 /i/top.gif 那哪一個檔案會被送出？ /data/w3/images/top.gif location /i/ &#123; alias /data/w3/images/;&#125; NGINX 中, alias 與 root 的規則中, 下圖中, 如果像下圖般有使用到變數, 該從哪裡取變數？ location location ~ xxx &#123; alias /data/w3/images/$1;&#125; NGINX 中, alias 與 root 的規則中, 如下圖般, 當 location 以及 alias 的最後一個資料夾的值相同時, 建議如何？ location /images/ &#123; root /data/w3;&#125; location /images/ &#123; alias /data/w3/images/;&#125; NGINX 中, alias 與 root 的規則中, 如下圖般, 如果請求是 /i/top.gif, 哪個檔案會被送出？ /data/w3/i/top.gif location /i/ &#123; root /data/w3;&#125; NGINX 全域變數中, $document_root 是什麼？ 當前請求的文檔根目錄或別名 NGINX 全域變數中, 下面的 request url 中, $document_uri 是哪一段？ /test1/test2 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, 下面的 request url 中, $host 是哪一段？ 34.83.35.165 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, $hostname 是什麼？ 主機名稱, 可在 Linux 中設定 NGINX 全域變數中, $is_args 是什麼？ 如果請求中有參數，值為“?”，否則為空字符串。 NGINX 全域變數中, $limit_rate 是什麼？ 用於設置響應的速度限制，詳見limit_rate。 NGINX 全域變數中, $msec 是什麼？ 當前的Unix時間戳(1.3.9, 1.2.6) NGINX 全域變數中, $pipe 是什麼？ 如果請求來自管道通信，值為“p”，否則為“.” NGINX 全域變數中, 下面的 request url 中, $query_string 是哪一段？ test1=123&amp;test2=456 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, $realpath_root 是什麼？ 當前請求的文檔根目錄或別名的真實路徑，會將所有符號連接轉換為真實路徑, 位置同 document_root NGINX 全域變數中, $remote_addr 是什麼？ 客戶端地址 NGINX 全域變數中, $remote_port 是什麼？ 客戶端端口 NGINX 全域變數中, $request 是什麼？ 代表客戶端的請求地址, 像這樣: POST /test1/test2?test1=123&amp;test2=456 HTTP/1.1 NGINX 全域變數中, $request_body 是什麼？ 客戶端的請求主體, 此變量可在location中使用，將請求主體通過proxy_pass, fastcgi_pass, uwsgi_pass,和scgi_pass傳遞給下一級的代理服務器。 NGINX 全域變數中, $request_filename 是什麼？ 當前連接請求的文件路徑，由root或alias指令與URI請求生成。 /usr/share/nginx/html/test1/test2 NGINX 全域變數中, $request_length 是什麼？ 請求的長度(包括請求的地址, http請求頭和請求主體) (1.3.12, 1.2.7) NGINX 全域變數中, $request_method 是什麼？ HTTP請求方法，通常為“GET”或“POST” NGINX 全域變數中, $request_time 是什麼？ 處理客戶端請求使用的時間(1.3.9, 1.2.6); 從讀取客戶端的第一個字節開始計時。 NGINX 全域變數中, 下面的 request url 中, $request_uri 是哪一段？ /test1/test2?test1=123&amp;test2=456這個變量等於包含一些客戶端請求參數的原始URI，它無法修改，請查看$uri更改或重寫URI，不包含主機名，例如：”/cnphp/test.php?arg=freemouse”。 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 NGINX 全域變數中, $scheme 是什麼？ 請求使用的Web協議, “http” 或“https” NGINX 全域變數中, $sent_http_name是什麼？ 可以設置任意http響應頭字段； 變量名中的後半部分“name”可以替換成任意響應頭字段，如需要設置響應頭Content-length，那麼將“－”替換為下劃線，大寫字母替換為小寫，形如：$sent_http_content_length 4096即可。 NGINX 全域變數中, $server_addr 是什麼？ 服務器端地址，非外部 IP, 機器在該網域的地址 NGINX 全域變數中, $server_port 是什麼？ 服務器端口 NGINX 全域變數中, $server_protocol 是什麼？ 服務器的HTTP版本, 通常為“HTTP/1.0” 或“HTTP/1.1” NGINX 全域變數中, $status 是什麼？ HTTP status code NGINX 全域變數中, $time_iso8601 是什麼？ 服務器時間的ISO 8610格式, 如 2019-11-27T14:11:04+00:00 NGINX 全域變數中, $time_local 是什麼？ 服務器時間（LOG Format 格式) 27/Nov/2019:14:11:38 +0000 NGINX 全域變數中, $uri 是什麼？ 請求中的當前URI(不帶請求參數，參數位於$args)，可以不同於瀏覽器傳遞的$request_uri的值，它可以通過內部重定向，或者使用index指令進行修改，$uri不包含主機名，如”/foo/bar.html”。 NGINX 全域變數中, 下面的 request url 中, $uri 是哪一段？ /test1/test2 http://34.83.35.165/test1/test2?test1=123&amp;test2=456 參考以下的 NGINX 設定, 並思考接下來一連串的問題 upstream backend &#123; server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; server backup1.example.com backup;&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; 以上的 nginx 設定中, 到 / 的請求會被送到哪裡？upstream backend 以上的 nginx 設定中, 每七個請求中, 會有幾個到 backend1.example.com? 為什麼？5 個因為 weight=5 以上的 nginx 設定中, 每七個請求中, 會有幾個到 127.0.0.1:8080? 為什麼？1 個因為沒有特別分配權重, 預設平均分配 以上的 nginx 設定中, 每七個請求中, 會有幾個到 unix:/tmp/backend3 為什麼？1 個因為沒有特別分配權重, 預設平均分配 以上的 nginx 設定中, 如果送給 server 127.0.0.1:8080 出錯了, 會怎麼樣？送往下一個, 即 unix:/tmp/backend3 以上的 nginx 設定中, 如果 upstream 中的 server 都無法服務, 會怎麼樣？送給 backup server, 即 backup1.example.com, 客戶會收到這一個 server 的回應 NGINX Cookbook NGINX 中, root 語法的意思是什麼？將會在 root 所定義的位置中尋找請求中帶過來的 URL 部分","link":"/zh-tw/nginx/"},{"title":"PHP 學習筆記","text":"前言這是我的 PHP 學習筆記, 學什麼記什麼！ 使用內建 Web server使用 PHP 內建 Web serverphp -S IP:Port -t Directory 安裝 extension參考文章stackoverflow 意思是說, 自從 2018 年的 4 月, Homebrew 已經不再是 PHP 在 macOS 上的套件管理器, 所以所有的 PHP Extension 之後都應該使用 pecl 來安裝 第一步 - 刪除可能衝突的套件brew rm php php@5.6 php@7.0 php@7.1brew rm imagemagick 第二步 - 更新 Xcode command line 工具, 以及取得 build 套件 確定已經安裝 Xcode command line 工具 xcode-select --install 到 AppStore 去更新 Xcode 以及套件 安裝 homebrew building 工具 brew install pkg-config 第三步 - 安裝 ImageMagickbrew install imagemagick 第四步 - 使用 Homebrew 安裝 PHPbrew install php 判別 Apache based PHP 或 Homebrew based PHPtype php /usr/local/...anything.../php 表示你執行的為 homebrew based 的 PHP /usr/bin/php 表示你執行的為 Apache based PHP 第五步 - 安裝 Imagickpecl install imagick 記得重啟你的 Web server 使用 Apache 記得重啟 Apache 使用 Nginx 記得重啟 Nginx 若是使用 valet, macOS 開發, 記得重啟 valet Q&amp;Aphp.ini 位置在哪？試以下指令pecl config-get php_ini brew info php php -i | grep \"Loaded Configuration\" peck 將模組安裝在哪？pecl config-get ext_dir 查詢目前已載入哪些模組？php -m PHP 無法找到模組? 先找出 pecl 將模組放在哪 pecl config-get ext_dir|pbcopy 打開 php.ini 設定檔 vim \"$(pecl config-get php_ini)\" 打開設定檔 ; Directory in which the loadable extensions (modules) reside.; http://php.net/extension-dir 加入上面得到的模組位置 extension_dir = \"/usr/local/lib/php/pecl/XXXXXX\" 上面的做法適用於 homebrew 安裝的 PHP 查看 PHP 設定php -i 疑難雜症篇環境為 macOS, 使用 pecl 安裝 extension 時遇到以下的錯誤Warning: mkdir(): File exists in System.php on line 294PHP Warning: mkdir(): File exists in /usr/local/Cellar/php/7.3.3/share/php/pear/System.php on line 294Warning: mkdir(): File exists in /usr/local/Cellar/php/7.3.3/share/php/pear/System.php on line 294ERROR: failed to mkdir /usr/local/Cellar/php/7.3.3/pecl/20180731 看起來該是無法在該位置建立資料夾, 那就手動建立一個吧 首先, 取得 pecl 的 extension 資料夾位址, 並複製 pecl config-get ext_dir|pbcopy 建立該資料夾 mkdir -p copiedValueFromLastCommand 這樣一來, 應該就解決了","link":"/zh-tw/php/"},{"title":"多個虛擬私人雲端","text":"概述在本教程中, 你將建立幾個 VPC 網路 以及 VM instances, 並且測試這些網路間的連接。 更準確的說, 你將建立兩個客製化模式的網路 (management 以及 privatenet), 以及各自的防火牆規則跟 VM instances, 如下圖所示: mynetwork 網路以及它的防火牆規則跟 VM instances (mynet-eu-vm 以及 mynet-us-vm) 在本教程的專案中已經被建立了 目標在本教程中, 你將會學習到如何完成以下任務 建立一個客製化模式的 VPC 網路以及它的防火牆規則 使用 Compute Engine 建立 VM instances 在不同的 VPC 網路間, 探索 VM instances 之間的連接 使用多重網路介面建立 VM instance 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立客製化模式的 VPC 網路以及防火牆規則建立兩個客製網路 managementnet 以及 privatenet, 以及防火牆規則允許 SSH, ICMP, 以及 RDP 流量進入 建立 managementnet 網路使用 GCP Console 建立 managementnet 網路 在 Console 內, 到 Navigation menu &gt; VPC network &gt; VPC networks 注意到 default 以及 mynetwork 網路以及它們的子網路每一個 GCP 專案都會有一個 default 網路。 另外, mynetwork 網路已經被事先建立, 如同上面的網路圖表呈現。 點擊 Create VPC Network 將 Name 設為 managementnet Subnet creation mode, 點擊 Custom 做如下設定, 其餘留為預設 點擊 Done 點擊 command line 這些指令顯示網路以及子網路是可以使用 Cloud Shell 指令來建立的。 你將使用這些指令以及類似的參數來建立與設定 privatenet 網路 點擊 Close 點擊 Create測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 managementnet 網路, 你將獲得一個評價分數。 建立 privatenet 網路使用 Cloud Shell 指令來建立 privatenet 網路: 執行以下指令來建立 privatenet 網路 gcloud compute networks create privatenet --subnet-mode=custom 執行以下指令來建立 privatesubnet-us 子網路: gcloud compute networks subnets create privatesubnet-us --network=privatenet --region=us-central1 --range=172.16.0.0/24 執行以下指令來建立 privatesubnet-eu 子網路 gcloud compute networks subnets create privatesubnet-eu --network=privatenet --region=europe-west1 --range=172.20.0.0/20 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 privatenet 網路, 你將獲得一個評價分數。 執行以下指令來列出可用的 VPC 網路:gcloud compute networks list 輸出類似如下 (不要複製; 這個只是範例輸出):NAME SUBNET_MODE BGP_ROUTING_MODE IPV4_RANGE GATEWAY_IPV4default AUTO REGIONALmanagementnet CUSTOM REGIONALmynetwork AUTO REGIONALprivatenet CUSTOM REGIONAL default 以及 mynetwork 屬於自動模式的網路, 而 managementnet 以及 privatenet 屬於客製化模式網路。 自動模式網路會自動地在某一個 region 建立子網路, 而客製化模式剛建立時是沒有子網路的, 你有著子網路建立的所有控制權 執行以下指令來列出可用的 VPC 子網路(由 VPC 網路分類)gcloud compute networks subnets list --sort-by=NETWORK 輸出類似如下 (不要複製; 這個只是範例輸出):NAME REGION NETWORK RANGEdefault asia-northeast1 default 10.146.0.0/20default us-west1 default 10.138.0.0/20default southamerica-east1 default 10.158.0.0/20default europe-west4 default 10.164.0.0/20default asia-east1 default 10.140.0.0/20default europe-north1 default 10.166.0.0/20default asia-southeast1 default 10.148.0.0/20default us-east4 default 10.150.0.0/20default europe-west1 default 10.132.0.0/20default europe-west2 default 10.154.0.0/20default europe-west3 default 10.156.0.0/20default australia-southeast1 default 10.152.0.0/20default asia-south1 default 10.160.0.0/20default us-east1 default 10.142.0.0/20default us-central1 default 10.128.0.0/20default northamerica-northeast1 default 10.162.0.0/20managementsubnet-us us-central1 managementnet 10.130.0.0/20mynetwork asia-northeast1 mynetwork 10.146.0.0/20mynetwork us-west1 mynetwork 10.138.0.0/20mynetwork southamerica-east1 mynetwork 10.158.0.0/20mynetwork europe-west4 mynetwork 10.164.0.0/20mynetwork asia-east1 mynetwork 10.140.0.0/20mynetwork europe-north1 mynetwork 10.166.0.0/20mynetwork asia-southeast1 mynetwork 10.148.0.0/20mynetwork us-east4 mynetwork 10.150.0.0/20mynetwork europe-west1 mynetwork 10.132.0.0/20mynetwork europe-west2 mynetwork 10.154.0.0/20mynetwork europe-west3 mynetwork 10.156.0.0/20mynetwork australia-southeast1 mynetwork 10.152.0.0/20mynetwork asia-south1 mynetwork 10.160.0.0/20mynetwork us-east1 mynetwork 10.142.0.0/20mynetwork us-central1 mynetwork 10.128.0.0/20mynetwork northamerica-northeast1 mynetwork 10.162.0.0/20privatesubnet-eu europe-west1 privatenet 172.20.0.0/20privatesubnet-us us-central1 privatenet 172.16.0.0/24 如預期般, default 以及 mynetwork 網路在 每一個 region 都有各自的子網路, 因為它們是屬於自動模式網路。 managementnet 以及 priavtenet 網路唯有當你有建立時, 它們才會有子網路, 因為它們是屬於客製化模式網路。 在控制台, 到 Navigation menu &gt; VPC network &gt; VPC networks 你可以看到一樣的網路以及子網路被列在控制台中 建立 managementnet 的防火牆規則建立防火牆規則來允許 SSH, ICMP, 以及 RDP 流量進入到 managementnet 網路中的 VM instances 在控制台, 到 Navigation menu &gt; VPC network &gt; Firewall rules 點擊 + Create Firewall Rule 做如下設定, 其餘留為預設 請務必確認 Source IP ranges 後面有包含 /0 已指定所有網路 點擊 command line這些指令顯示防火牆規則是可以使用 Cloud Shell 指令來建立的。 你將使用這些指令以及類似的參數來建立與設定 privatenet 的防火牆規則 點擊 Close 點擊 Create 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 managementnet 的防火牆規則, 你將獲得一個評價分數。 建立 privatenet 的防火牆規則使用 Cloud Shell 指令來建立 privatenet 網路的防火牆規則 在 Cloud Shell 中, 執行以下指令來建立 privatenet-allow-icmp-ssh-rdp 防火牆規則gcloud compute firewall-rules create privatenet-allow-icmp-ssh-rdp --direction=INGRESS --priority=1000 --network=privatenet --action=ALLOW --rules=icmp,tcp:22,tcp:3389 --source-ranges=0.0.0.0/0 輸出類似如下 (不要複製; 這個只是範例輸出):NAME NETWORK DIRECTION PRIORITY ALLOW DENYprivatenet-allow-icmp-ssh-rdp privatenet INGRESS 1000 icmp,tcp:22,tcp:3389 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 privatenet 網路的防火牆規則, 你將獲得一個評價分數。 執行以下指令來列出所有的防火牆規則 (依 VPC 網路分類)gcloud compute firewall-rules list --sort-by=NETWORK 輸出類似如下 (不要複製; 這個只是範例輸出):NAME NETWORK DIRECTION PRIORITY ALLOW DENYdefault-allow-icmp default INGRESS 65534 icmpdefault-allow-internal default INGRESS 65534 tcp:0-65535,udp:0-65535,icmpdefault-allow-rdp default INGRESS 65534 tcp:3389default-allow-ssh default INGRESS 65534 tcp:22managementnet-allow-icmp-ssh-rdp managementnet INGRESS 1000 icmp,tcp:22,tcp:3389mynetwork-allow-icmp mynetwork INGRESS 1000 icmpmynetwork-allow-rdp mynetwork INGRESS 1000 tcp:3389mynetwork-allow-ssh mynetwork INGRESS 1000 tcp:22privatenet-allow-icmp-ssh-rdp privatenet INGRESS 1000 icmp,tcp:22,tcp:3389 mynetwork 的防火牆規則已經被建立好了。 你可以在一個防火牆規則中定義多個協定以及 port (privatenet 以及 managementnet), 或是分別用多條規則來定義 (default 以及 mynetwork) 在主控台中, 到 Navigation menu &gt; VPC network &gt; Firewall rules 你可以看到同樣的防火牆規則被列在主控台 建立 VM instances建立兩個 VM instances: 在 managementsubnet-us 中, managementnet-us-vm 在 privatesubnet-us 中, privatenet-us-vm 建立 management-us-vm instance使用 GCP 主控台來建立 management-us-vm instance 在主控台中, 到 Navigation menu &gt; Compute Engine &gt; VM instances如同上面的圖表顯示的一樣, mynet-eu-vm 以及 mynet-us-vm 已經被建立好了 點擊 Create instance 做如下設定, 其餘留為預設 點擊 Management, disks, networking, SSH keys 點擊 Networking 點擊鉛筆的圖案來編輯 Network interfaces 做如下設定, 其餘留為預設 點擊 Done 點擊 command line這些指令顯示 VM instances 是可以使用 Cloud Shell 指令來建立的。 你將使用這些指令以及類似的參數來建立與設定 privatenet-us-vm 的防火牆規則 gcloud beta compute --project=qwiklabs-gcp-03-2779af1ddf93 instances create managementnet-us-vm --zone=us-central1-c --machine-type=f1-micro --subnet=managementsubnet-us --network-tier=PREMIUM --maintenance-policy=MIGRATE --service-account=357292195316-compute@developer.gserviceaccount.com --scopes=https://www.googleapis.com/auth/devstorage.read_only,https://www.googleapis.com/auth/logging.write,https://www.googleapis.com/auth/monitoring.write,https://www.googleapis.com/auth/servicecontrol,https://www.googleapis.com/auth/service.management.readonly,https://www.googleapis.com/auth/trace.append --image=debian-9-stretch-v20200210 --image-project=debian-cloud --boot-disk-size=10GB --boot-disk-type=pd-standard --boot-disk-device-name=managementnet-us-vm --reservation-affinity=any 點擊 Close 點擊 Create 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功在 managementnet 網路建立 VM instance, 你將獲得一個評價分數。 建立 privatenet-us-vm instance使用 Cloud Shell 指令來建立 privatenet-us-vm instance 在 Cloud Shell 中, 執行以下指令來建立 privatenet-us-vm instancegcloud compute instances create privatenet-us-vm --zone=us-central1-c --machine-type=n1-standard-1 --subnet=privatesubnet-us 輸出類似如下 (不要複製; 這個只是範例輸出):NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSprivatenet-us-vm us-central1-c n1-standard-1 172.16.0.2 35.184.221.40 RUNNING 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功在 privatenet 網路建立 VM instance, 你將獲得一個評價分數。 執行以下指令來列出所有的 VM instances (依 zone 分類)gcloud compute instances list --sort-by=zone 輸出類似如下 (不要複製; 這個只是範例輸出):NAME ZONE MACHINE_TYPE PREEMPTIBLE INTERNAL_IP EXTERNAL_IP STATUSmynet-eu-vm europe-west1-c n1-standard-1 10.132.0.2 35.205.124.164 RUNNINGmanagementnet-us-vm us-central1-c n1-standard-1 10.130.0.2 35.226.20.87 RUNNINGmynet-us-vm us-central1-c n1-standard-1 10.128.0.2 35.232.252.86 RUNNINGprivatenet-us-vm us-central1-c n1-standard-1 172.16.0.2 35.184.221.40 RUNNING 在主控台, 到 Navigation menu &gt; Compute Engine &gt; VM instance 你可以看到 VM instances 被列在主控台 點擊 Columns, 然後選擇 Network可以看到在 us-central-c 有 3 台 instances, 而在 europe-west1-c 有 1 台 instance 。 然而, 這些 instances 橫跨了三個 VPC 網路 (managementnet, mynetwork 以及 privatenet), 沒有任何一台 instance 是同一個 zone 又同一個網路的。 在下一節中, 你將探索這在內部連線中的影響。 探索不同 VM instances 之間的連線探索不同 VM instances 之間的連線。 更準確的說, 確定當 VM instances 在同一個 zone 的影響, 以及當他們在同一個 VPC 網路的影響 Ping 外部 IP 位址藉由 ping VM instances 的外部 IP 位址來確定它們是否可以在公開網路被觸及到。 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 檢視 mynet-eu-vm, managementnet-us-vm, 以及 privatenet-us-vm 的外部 IP 位址 點擊 mynet-us-vm 的 SSH 來啟動一個終端機連線 執行以下指令, 將 mynet-eu-vm 替換成外部 IP, 藉此測試 mynet-eu-vm 的外部 IP 連線ping -c 3 &lt;Enter mynet-eu-vm&apos;s external IP here&gt; 這應該要可以通過 執行以下指令, 將 managementnet-us-vm 替換成外部 IP, 藉此測試 managementnet-us-vm 的外部 IP 連線ping -c 3 &lt;Enter managementnet-us-vm&apos;s external IP here&gt; 這應該也要可以通過 執行以下指令, 將 privatenet-us-vm 替換成外部 IP, 藉此測試 privatenet-us-vm 的外部 IP 連線ping -c 3 &lt;Enter privatenet-us-vm&apos;s external IP here&gt; 這應該也要可以通過 你可以通過 VM instances 的外部 IP 位址來 ping 到機器, 儘管他們處於不同的 zone 或是 VPC 網路。 這確認了一件事, 那就是公開網路存取只會由早先建立的 ICMP 防火牆規則所控制 Ping 內部 IP 位址透過 ping VM instances 的內部 IP 位址來確定在同一個 VPC 網路中的 instances 是否可以互相觸及對方 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 檢視 mynet-eu-vm, managementnet-us-vm, 以及 privatenet-us-vm 的內部 IP 位址 點擊 mynet-us-vm 的 SSH 來啟動一個終端機連線 執行以下指令, 將 mynet-eu-vm 替換成內部 IP, 藉此測試 mynet-eu-vm 的內部 IP 連線 ping -c 3 &lt;Enter mynet-eu-vm&apos;s internal IP here&gt; 你可以經由 mynet-eu-vm 的內部 IP 位址 ping 到它, 因為它與 ping 的來源機器 (mynet-us-vm) 處於同一個 VPC 網路, 儘管兩台 VM instances 在不同的 zones, regions, 以及 continents 執行以下指令, 將 managementnet-us-vm 替換成內部 IP, 藉此測試 managementnet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter managementnet-us-vm&apos;s external IP here&gt; 這應該不能通過, 如同資料顯示, 封包 100% 遺失 執行以下指令, 將 privatenet-us-vm 替換成內部 IP, 藉此測試 privatenet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter privatenet-us-vm&apos;s external IP here&gt; 這應該也無法通過, 如同回饋顯示, 封包 100% 丟失了！ 你無法經由 managementnet-us-vm 以及 privatenet-us-vm 的內部 IP 位址來 ping 到對方, 因為它們與來源機器 (mynet-us-vm) 的 VPC 網路不同, 儘管他們都處於同一個 zone us-central1 VPC 網路預設上是獨立的私人網路 domains 。 然而, 除非你有設定一些機制, 像是 VPC peering 或是 VPN, 否則, 網路之間是不允許內部 IP 位址來互相通信的。 建立有著多重網路介面的 VM instances每一台 VPC 網路內的 instance 都會有一個預設的網路介面。 你可以建立額外的網路介面, 然後附加到你的 VM 上。 多重網路介面可以讓你建立一個設定, 這個設定可以讓一台 instance 直接的連接到多個 VPC 網路 (最多八台 instances, 取決於 instance 的類型) 建立有著多重網路介面的 VM instances建立一台名為 vm-appliance 的 instance, 這台 instance 會在 privatesubnet-us, managementsubnet-us, 以及 mynetwork 這些網路介面中。 這些子網路的 CIDR 範圍不可互相重疊, 這是建立一台有著多重網路介面控制器 (NICs) 的 VM 的要求之一。 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instance 點擊 Create instance 做如下設定, 其餘留為預設 一台機器允許的介面數量取決於機器類型以及 VCPUs 的數量。 n1-standard-4 允許最多 4 個網路介面。 更多資訊可以參考這裏 點擊 Management, disks, networking, SSH keys 點擊 Networking 點擊鉛筆圖案編輯 Network interfaces 做如下設定, 其餘留為預設 點擊 Done 點擊 Add network interface 做如下設定, 其餘留為預設 點擊 Done 點擊 Add network interface 做如下設定, 其餘留為預設 點擊 Done 點擊 Create 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立多網路介面的 VM, 你將獲得一個評價分數。 探索多網路介面細節在主控台以及 VM’s 終端機探索 vm-appliance 的多網路介面細節 在主控台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 點擊 vm-appliance 的 Internal IP 的 nic0 來打開 Network interface details 頁面 確認 nic0 有被附加到 privatesubnet-us, 在子網路 (172.16.0.0/24) 中有被分配一組內部 IP, 以及已有生效的防火牆規則 點擊 nic0, 選擇 nic1 確認 nic1 有被附加到 managementsubnet-us, 在子網路 (10.130.0.0/20) 中有被分配一組內部 IP, 以及已有生效的防火牆規則 點擊 nic1, 選擇 nic2 確認 nic2 有被附加到 mynetwork, 在子網路 (10.128.0.0/20) 中有被分配一組內部 IP, 以及已有生效的防火牆規則每一個網路介面有它們自己的內部 IP 位址, 所以 VM instance 可以與他們溝通 在控制台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 點擊 SSH 啟動 vm-appliance 的終端連線 執行以下指令來列出 VM instance 的網路介面sudo ifconfig 輸出類似如下 (不要複製; 這個只是範例輸出):eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 172.16.0.3 netmask 255.255.255.255 broadcast 172.16.0.3 inet6 fe80::4001:acff:fe10:3 prefixlen 64 scopeid 0x20&lt;link&gt; ether 42:01:ac:10:00:03 txqueuelen 1000 (Ethernet) RX packets 626 bytes 171556 (167.5 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 568 bytes 62294 (60.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 10.130.0.3 netmask 255.255.255.255 broadcast 10.130.0.3 inet6 fe80::4001:aff:fe82:3 prefixlen 64 scopeid 0x20&lt;link&gt; ether 42:01:0a:82:00:03 txqueuelen 1000 (Ethernet) RX packets 7 bytes 1222 (1.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 17 bytes 1842 (1.7 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0eth2: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1460 inet 10.128.0.3 netmask 255.255.255.255 broadcast 10.128.0.3 inet6 fe80::4001:aff:fe80:3 prefixlen 64 scopeid 0x20&lt;link&gt; ether 42:01:0a:80:00:03 txqueuelen 1000 (Ethernet) RX packets 17 bytes 2014 (1.9 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 17 bytes 1862 (1.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 sudo ifconfig 這個指令列出了 Linux VM 的網路介面以及這些介面的內部 IP 探索網路介面的連線我們可以藉由 ping 這些子網路來演示一下 vm-appliance 是與 privatesubnet-us, managementsubnet-us 以及 mynetwork 互相連接的 在主控台, 到 Navigation menu &gt; Compute Engine &gt; VM instances 注意一下 privatenet-us-vm, managementnet-us-vm, mynet-us-vm, 以及 my-eu-vm 的內部 IP 位址 回到 vm-appliance 的 SSH 終端機 執行以下指令, 將 privatenet-us-vm 替換成內部 IP, 藉此測試 privatenet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter privatenet-us-vm&apos;s internal IP here&gt; 這是可以連到的！ 重複以上步驟, 執行以下指令ping -c 3 privatenet-us-vm 你可以 ping 到 privatenet-us-vm 的 name, 因為 VPC 網路有內部 DNS 服務, 這個服務讓我們可以透過 DNS name 來連接到機器, 而不用透過 IP 位址。 執行以下指令, 將 managementnet-us-vm 替換成內部 IP, 藉此測試 managementnet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter managementnet-us-vm&apos;s internal IP here&gt; 這是可以連到的！ 執行以下指令, 將 mynet-us-vm 替換成內部 IP, 藉此測試 mynet-us-vm 的內部 IP 連線ping -c 3 &lt;Enter mynet-us-vm&apos;s internal IP here&gt; 這是可以連到的！ 執行以下指令, 將 mynet-eu-vm 替換成內部 IP, 藉此測試 mynet-eu-vm 的內部 IP 連線ping -c 3 &lt;Enter mynet-eu-vm&apos;s internal IP here&gt; 這個無法連到！ 再多網路介面 instance 中, 每一個介面都會有一個可以連到它們所在的子網路的路由。 再者, instance 只會有一個預設路由, 這個路由與主要介面 eth0 相關聯。 除非手動設置, 否則任何離開這個 instance 的流量, 不管目的地是哪, 只要不是透過直接連接的子網路, 都將經由這個預設的路由離開。 執行以下指令來列出 vm-appliance 的所有路由ip route 輸出類似如下 (不要複製; 這個只是範例輸出):default via 172.16.0.1 dev eth010.128.0.0/20 via 10.128.0.1 dev eth210.128.0.1 dev eth2 scope link10.130.0.0/20 via 10.130.0.1 dev eth110.130.0.1 dev eth1 scope link172.16.0.0/24 via 172.16.0.1 dev eth0172.16.0.1 dev eth0 scope link 主要介面 etho 有其預設路由 (預設經由 172.16.0.1 dev eth0), 以及所有三個介面 eth0, eth1, eth2 都有通往其各自子網路的路由。 因為 mynet-eu-vm (10.132.0.0/20) 的子網路並沒有被包含在這台 instance 的路由表中, 當我們 ping 這台機器時, 請求會離開 eth0 的 vm-appliance** (這是在一個不同的 VPC 網路)。 你可以設置政策路由來變更這個行為, 可參考文件 恭喜你已經完成本教程！ Questions And Answers 解釋以下 GCP command command: gcloud compute networks create privatenet --subnet-mode=custom Answer: 建立一個 GCP network 子網路的模式為, custom 解釋以下 GCP command command: gcloud compute network subnets create privatesubnet-eu --network=privatenet --region=europe-west1 --range=172.20.0.0/20 Answer: 建立一個 GCP 子網路 上層網路的名稱為 privatenet 地區為 europe-west1 確切網域範圍為 172.20.0.0/20 解釋以下 GCP command command: gcloud compute networks list Answer:列出所有網路, 不包含子網路 解釋以下 GCP command command: gcloud compute networks create privatenet --subnet-mode=custom Answer: 建立一個 GCP network 子網路的模式為, custom 以下的 GCP Command 中, –subnet-mode 預設為 auto 還是 custom? Example: gcloud compute networks create privatenet --subnet-mode=custom Answer:auto 解釋以下 GCP command Command: gcloud compute networks subnets list --sort-by=NETWORK Answer: 列出所有 subnets 以 network 排列 解釋以下 GCP command Command: gcloud compute firewall-rules create privatenet-allow-icmp-ssh-rdp --direction=INGRESS --priority=1000 --network=privatenet --action=ALLOW --rules=icmp,tcp:22,tcp:3389 --source-ranges=0.0.0.0/0 Answer: 建立一個 firewall-rules 名稱為 *privatenet-allow-icmp-ssh-rdp 方向為 INGRESS, 即外到內 –priority 為優先性, 數字介於 0 ~ 65535, 數字越小優先性越高 –action 為 ALLOW, 也可設為 DENY –rules 為規則, 可設定多種協議 –source-ranges 為此 rule 作用到的來源 IP 範圍, 預設為 0.0.0.0/0, 即全部 解釋以下 GCP command Command: gcloud compute firewall-rules list --sort-by=NETWORK Answer: 列出所有的 firewall-rules 以 NETWORK 排 解釋以下 GCP command Command: gcloud compute instances create privatenet-us-vm \\--zone=us-central1-c \\--machine-type=n1-standard-1 \\--subnet=privatesubnet-us Answer: 建立一台 vm, 名為 privatenet-us-vm 將該 vm 掛在 privatesubnet-us 這個子網路下 解釋以下 GCP command Command: gcloud compute instances list --sort-by=zone Answer: 列出所有 instances 以 zone 排列 假如我有三台 VM, 分別位於不同的子網路下, 在不考慮防火牆的因素下, 我可以經由各自的 External IP ping 到對方嗎？可以 假如我有兩台 VM, 分別位於 GCP 不同的子網路, 但相同的 network 下, region 跟 zone 都不同的情況下, 在不考慮防火牆的因素下, 我可以經由各自的 Internal IP ping 到對方嗎？可以 GCP VM Instances 當中, NIC 的上限是多少？8 個 GCP VM Instances 當中, 如果 vCPU 的數量不超過 2, 則 NIC 的數量限制為多少？2 個 GCP VM Instances 當中, 如果 vCPU 的數量超過 2, 則每多一個 CPU, 可以提高幾個 NIC 上限？1 個","link":"/zh-tw/multipleVPCNetworks/"},{"title":"Sequelize 學習筆記","text":"參考連結官方網站 安裝npm install --save sequelize or yarn add sequelize --save 以下手動安裝：npm install --save pg pg-hstorenpm install --save mysql2npm install --save mariadbnpm install --save sqlite3npm install --save tedious # Microsoft SQL Server or yarn add pg pg-hstore --saveyarn add mysql2 --saveyarn add mariadb --saveyarn add sqlite3 --saveyarn add tedious # Microsoft SQL Server --save Migration參考官方網站 安裝 Migration CLInpm install --save sequelize-cli or yarn add sequelize-cli --save 快速開始參考官方網站 npx sequelize-cli init 會自動建立以下資料夾: config: 連接資料庫的設定 models: 這個專案 Models 的存放位置 migrations: Migration 放置處 seeders: seeds 檔案 請把以下的 operationAliases 刪掉 config.json &quot;development&quot;:&#123; &quot;username&quot;: &quot;root&quot;, &quot;password&quot;: null, &quot;database&quot;: &quot;database_development&quot;, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;dialect&quot;: &quot;mysql&quot;, &quot;operatorsAliases&quot;: false&#125; 建立 migration參考官方網站 npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string name: Model 名稱 attributes: 欄位屬性 會做以下的事: 建立一個 user model 在 migration 資料夾，建立一個 migration 檔案，名稱像是 XXXXXXXXXXXXXX-create-user.js 執行 migration參考官方網站 npx sequelize-cli db:migrate 取消 migration參考官方網站 取消最新一個 migration npx sequelize-cli db:migrate:undo 取消全部的 migration, 然後重新 migrate 到指定的檔案 npx sequelize-cli db:migrate:undo:all --to XXXXXXXXXXXXXX-create-posts.js 變更設定檔位置，名稱如果: 你想要重新定義 migration, models, seeders, 或 config 的資料夾位置 你想要重新命名 config.json, 比如說, database.json 那： 建立 .sequelizerc 檔案 touch .sequelizerc 範例格式 const path = require('path');module.exports = &#123; 'config': path.resolve('config', 'database.json'), 'models-path': path.resolve('db', 'models'), 'seeders-path': path.resolve('db', 'seeders'), 'migrations-path': path.resolve('db', 'migrations')&#125; 以上的設定會告訴 CLI 使用 config/database.json 為設定檔 使用 `db/models/ 為 models 的資料夾 使用 db/seeders 為 seeders 資料夾 使用 db/migrations 為 migration 資料夾 有時我們會需要更改 config 檔案副檔名, 因為我們需要一些 json 無法提供的功能, 例如：const fs = require(&apos;fs&apos;); production: &#123; username: process.env.DB_USERNAME, password: process.env.DB_PASSWORD, database: process.env.DB_NAME, host: process.env.DB_HOSTNAME, dialect: &apos;mysql&apos;, dialectOptions: &#123; ssl: &#123; ca: fs.readFileSync(__dirname + &apos;/mysql-ca-master.crt&apos;) &#125; &#125;&#125;; 這時我們可以在 .sequelizerc 檔案中修改const path = require('path');module.exports = &#123; 'config': path.resolve('config', 'config.js')&#125; 最後別忘了修改 /models/index 中, config 的路徑 在 model 中增加 method'use strict';module.exports = (sequelize, DataTypes) =&gt; &#123; const User = sequelize.define('User', &#123; firstName: DataTypes.STRING, lastName: DataTypes.STRING, email: DataTypes.STRING &#125;, &#123;&#125;); User.associate = function(models) &#123; // associations can be defined here &#125;; User.prototype.useInstance = function () &#123; console.log('This is for new instance way'); &#125;; User.useStatic = function () &#123; console.log('This is for static way'); &#125;; return User;&#125;; 使用 async/await直接 await method 就可(async () =&gt; &#123; let result = await Data.findAll(&#123; attributes: [ 'host', 'upstream_cache_status', [Sequelize.fn('COUNT', Sequelize.col('request')), 'requests'], ], group: ['host', 'upstream_cache_status'] &#125;); console.log(result)&#125;)();","link":"/zh-tw/sequelize/"},{"title":"pm2 - 用法大全","text":"前言pm2 是什麼？ pm2 是一個 node 的程序管理器 pm2 解決什麼問題？ pm2 可以讓 node 服務 crash 掉之後，自動幫我們重啟 pm2 可以在 server 重啟之後，自動幫我們重啟 pm2 可利用 CPU 多核，開啟多程序，已達到類似負載平衡的效果 Graceful reload 可達成類似 rolling upgrade 的效果，0 downtime 升級 多程序多服務，可提升處理 request 的速度 可設定 cron 排程自動重啟時間 pm2 提供多項資訊，包含已重啟次數、 CPU 用量、 memory 用量, process id, 等等… pm2 可以在指定的條件下，自動幫我們重啟，條件可以是’up time’, ‘已使用多少 memory’, 等等…, pm2 可以幫我們整理 log, 讓 log 以我們想要的週期分割檔案，並保存我們想要的數量，若有超過，自動刪除。 pm2 提供簡單的部署方式，可一次性部署到多台 server pm2 可與 CD / CD 工具做結合， CI / CD 部署也沒有問題 好 pm2, 不用嗎？ 本篇將提到： 安裝 pm2 使用 CLI 啟動 pm2 使用 pm2 設定檔 ecosystem 啟動 pm2 使用 pm2 設定檔 ecosystem 部署 node 專案 使用 pm2 搭配 GitLab CI / CD Runner 部署 node 專案 安裝 全域安裝npm install pm2@latest -g pm2 with CLI可以使用 pm2 CLI 來啟動 node 專案, 範例如下：pm2 start location/fileName.js --name appName \\--watch true \\--max-memory-restart 500M \\--log ~/.pm2/logs/appName/ \\--time true \\--cron \"0 17 * * *\" \\--no-daemon true \\--merge-logs 以上範例中設定代表的意思，參考如下： 靜態檔的服務器 也可以服務靜態檔pm2 serve &lt;path&gt; &lt;port&gt; 啟動可以附加的參數 --name指定 app 一個名字 --watch檔案有變更時，會自動重新啟動 --max-memory-restartMemory 使用超過這個門檻時，會自動重啟 --log指定 log 的位址, 若要指定新位址，需將原本的 process 刪掉，再重新啟動指定 --output指定 output log 位址 --error指定 error log 位址 --log-date-format指定 log 的格式 --merge-logs同一個 app 跑多程序時，不要依據程序 id 去分割 log, 全部合在一起 --arg1 --arg2 --arg3指派額外的參數 --restart-delay自動重啟時，要 delay 多久 --time給 log 加上前綴 --no-autorestart不要自動重啟 --cron指定 cron 規律，強制重啟 --no-daemon無 daemon 模式， listen log 模式 --spa限定 serve 使用, 會重導所有的請求到 index.html --basic-auth-username --basic-auth-password 用於靜態檔, 讓該頁面需要帳號密碼方可存取 叢集模式 pm2 自動偵測該機器的 CPU 數量，啟動最大能負荷的 process, 適用上面的選項, -i 後面接希望啟動 instance 的數量， 0 或 max 默認自動偵測 CPU 啟動最大值pm2 start app.js -i max 管理程序 直接 kill 掉 process, 再重新開始程序 pm2 restart app_name 如果是在 cluster mode, reload 會依序升級重啟每一個程序，達到 zero downtime 升級 pm2 reload app_name 停止服務 pm2 stop app_name 停止並刪除服務 pm2 delete app_name 除了 app_name 之外，你也可以指定all : 啟動所有程序id : 該程序 id 顯示管理程序狀態pm2 [list|ls|status] Logs 輸出 log pm2 logs 顯示指定行數 log (指定倒數 200 行) pm2 logs --lines 200 指定輸出程序 log pm2 logs id 指定輸出格式 format pm2 logs --format 指定輸出格式 json pm2 logs --json 清空 log pm2 flush 取消 log可以利用指定 log 路徑為 /dev/null 來取消 log 輸出, log 參數用法請參考 ecosystem 範例 循環 log如果你看過 log 檔案超肥，幾年的 log 都寫在同一個檔案; 如果你打開 log 資料夾，發現裡面躺著幾百個 log 檔案; 如果你看過千奇百怪的 log 檔名; 如果你 du -h 發現 log 資料夾大的嚇死人如果你有以上的經驗，那恭喜你，你有救了 安裝pm2 install pm2-logrotate config 檔位置/home/user/.pm2/module_conf.json 參數 max_size (預設 10M):當 log 檔案達到多大時， logrotate module 會將它分割成另外一個檔案。 logrotate module 有可能在檢查檔案時，檔案已經超過指定的大小了，所以超過一些些是可能的。 單位可以自行指定, 10G, 10M, 10K retain (預設 30 個 log 檔案):預設最多保存的 log 數量，如果設定為 7 的話，將會保存目前的 log, 以及最多 7 個 log 檔案 compress (預設 false):壓縮所有循環 log 檔案 dateFormat (時間格式，預設 YYYY-MM-DD_HH-mm-ss) :檔案命名的時間格式 rotateModule (預設 true) :跟其他 apps 一樣，循環 pm2’s module workerInterval (預設 30 秒) :多久 logrotate 會檢查一次 log 檔案大小 rotateInterval (預設每天午夜循環, 範例 0 0 * ):除了設定檔案大小以外，我們也可以設定以時間為單位去循環，格式上採用 node-schedule TZ (預設為系統時間):檔案命名的時間會根據你所設定的時區而改變 圖示* * * * * *┬ ┬ ┬ ┬ ┬ ┬│ │ │ │ │ |│ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)│ │ │ │ └───── month (1 - 12)│ │ │ └────────── day of month (1 - 31)│ │ └─────────────── hour (0 - 23)│ └──────────────────── minute (0 - 59)└───────────────────────── second (0 - 59, OPTIONAL) terminal 監控面板pm2 monit pm2 ecosystemCLI 工具固然不錯，但只要是人難免手滑打錯或漏打參數。 pm2 ecosystem 解決了這個問題，只要好好的打上一次，以後除非設定有變更，否則啟動服務只需要短短幾個指令，而且 ecosystem 檔案還可以納入 git 控管，跟著專案跑 產生範例 ecosystem filepm2 ecosystem CLI跟前面介紹過的管理程序一樣，差別只是將 app.js 換成 ecosystem.js多個管理程序 CLI, 這邊就只列出 start, 其餘同上pm2 start ecosystem.config.js 從 ecosystem 中只啟動特定 app下面的 appName 為我們寫在 ecosystem.config.js 檔案中的 appNamepm2 start ecosystem.config.js --only yourApp 帶入參數拿下面的範例來說，如果我輸入 pm2 start ecosystem --only app1 --env production , 那麼 pm2 就會使用 NODE_ENV=production 這個環境變數 參數範例下面的參數有點多，我們肯定不會一次使用到這麼多的參數，所以可以視專案需求留下我們需要的參數即可module.exports = &#123; apps: [ // First application &#123; // App 名稱 name: 'app1', // 執行服務的入口檔案 script: './server.js', // 你的服務所在位置 cwd: 'var/www/yourApp/', // 分為 cluster 以及 fork 模式 exec_mode: 'cluster', // 只適用於 cluster 模式，程序啟動數量 instances: 0, // 適合開發時用，檔案一有變更就會自動重啟 watch: false, // 當佔用的 memory 達到 500M, 就自動重啟 max_memory_restart: '500M', // 可以指定要啟動服務的 node 版本 interpreter: '/root/.nvm/versions/node/v8.16.0/bin/node', // node 的額外參數 // 格式可以是 array, 像是 \"args\": [\"--toto=heya coco\", \"-d\", \"1\"], 或是 string, 像是 \"args\": \"--to='heya coco' -d 1\" interpreter_args: \"port=3001 sitename='first pm2 app'\", // 同上 node_args: \"port=3001 sitename='first pm2 app'\", // 'cron' 模式指定重啟時間，只支持 cluster 模式 cron_restart: \"0 17 * * *\", // log 顯示時間 time: true, // 可經由 CLI 帶入的參數 args: '-a 13 -b 12', // 想要被忽略的檔案或資料夾, 支援正則，指定的檔案或資料夾如果內容有變更，服務將不會重啟 // 格式可以是 array, 像是 \"args\": [\"--toto=heya coco\", \"-d\", \"1\"], 或是 string, 像是 \"args\": \"--to='heya coco' -d 1\" ignore_watch: [\"[\\/\\\\]\\./\", \"node_modules\"], // 支援 source_map, 預設 true, 細節可參考 // http://pm2.keymetrics.io/docs/usage/source-map-support/ // https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/ source_map_support: true, // instance_var, 詳見以下連結 // http://pm2.keymetrics.io/docs/usage/environment/#specific-environment-variables instance_var: 'NODE_APP_INSTANCE', // log 的時間格式 log_date_format: 'YYYY-MM-DD HH:mm Z', // 錯誤 log 的指定位置 error_file: '/var/log', // 正常輸出 log 的指定位置 out_file: '/var/log', // 同一個 app 有多程序 id, 如果設定為 true 的話， 同 app 的 log 檔案將不會根據不同的程序 id 分割，會全部合在一起 combine_logs: true, // 同上 merge_logs: true, // pid file 指定位置, 預設 $HOME/.pm2/pid/app-pm_id.pid pid_file: 'user/.pm2/pid/app-pm_id.pid', // pm2 會根據此選項內的時間來判定程序是否有成功啟動 // 格式可使用 number 或 string, number 的話， 3000 代表 3000 ms。 string 的話, 可使用 '1h' 代表一個小時, '5m' 代表五分鐘, '10s' 代表十秒 min_uptime: '5', // 單位為 ms, 如果在該時間內 app 沒有聽 port 的話，強制重啟 listen_timeout: 8000, // 當執行 reload 時，因為 graceful reload 會等到服務都沒有被存取了才會斷開，如果超過這個時間，強制斷開重啟 // 細節可參考官方文件 http://pm2.keymetrics.io/docs/usage/signals-clean-restart/ kill_timeout: 1600, // 一般來說，服務等待 listen 事件觸發後，執行 reload, 若此選項為 true, 則等待 'ready' message // 細節可參考官方文件 http://pm2.keymetrics.io/docs/usage/signals-clean-restart/ wait_ready: false, // pm2 具有 crash 自動重啟的功能。 但若異常狀況重啟超過此選項的指定次數，則停止自動重啟功能。 異常與否的判定，預設為 1 秒，也就是說如果服務啟動不足一秒又立即重啟，則異常重啟次數 + 1。 若 min_uptime 選項有指定，則以 min_uptime 指定的最小正常啟動時間為標準來判斷是否為異常重啟 // 細節可參考官方文件 http://pm2.keymetrics.io/docs/usage/signals-clean-restart/ max_restarts: 10, // 單位為 ms, 預設為 0, 若有指定時間，則 app 會等待指定時間過後重啟 restart_delay: 4000, // 預設為 true, 若設為 false, pm2 將會關閉自動重啟功能, 也就是說 app crash 之後將不會自動重啟 autorestart: true, // 預設為 true, 預設執行 pm2 start app 時，只要 ssh key 沒問題， pm2 會自動比較 local 跟 remote, 看是否為最新的 commit，若否，會自動下載更新。 此功能有版本問題，需新版才支援 vizion: true, // 進階功能，當使用 Keymetrics 的 dashboard 執行 pull 或 update 操作後，可以觸發執行的一系列指令 post_update: [\"npm install\", \"echo launching the app\"], // defaults to false. if true, you can start the same script several times which is usually not allowed by PM2 // 預設為 false, 如果設定為 true, force: false, // 當不指定 env 時，會套用此 object 裡頭的環境變數, 例如 pm2 start ecosystem.js env: &#123; COMMON_VARIABLE: 'true', NODE_ENV: '', ID: '44' &#125;, // 當有指定 env 時，會套用此 object 裡頭的環境變數, 例如 pm2 start ecosystem.js --env production env_production: &#123; NODE_ENV: 'production', ID: '55' &#125;, // 同上 env_development: &#123; NODE_ENV: 'development' &#125; &#125;, // 第二個 app, 很多資訊上面有介紹過的就不再重複 &#123; // Serve 模式, 可服務靜態資料夾 script: \"serve\", env: &#123; PM2_SERVE_PATH: '.', PM2_SERVE_PORT: 8080 &#125;, name: 'app2', // 預設模式，可應用在其他語言, cluster 只可用在 node.js exec_mode: 'fork', interpreter: '/root/.nvm/versions/node/v8.16.0/bin/node', time: true, &#125; ], // 這一個區塊是部署的部分 deploy: &#123; // production production: &#123; // 要登入執行 pm2 的 user user: 'root', // 支援多個 host 部署 host: ['host1', 'host2'], // remote 要檢查的 public key 的位置 key: 'path/to/some.pem', // 要部署的分支 ref: 'origin/master', // Git 倉庫位址 repo: 'git@gitlab.com:user/yourProject.git', // 要部署到 server 上的資料夾路徑 path: '/var/www/yourProjectName', // 如果 ssh 有設定好，從 local 連到 remote 端將不會再詢問是否將 remote 端的 public key 加到 known host \"ssh_options\": \"StrictHostKeyChecking=no\", // 在 pm2 要從 local 端連到 remote 端之前要執行的指令，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 \"pre-setup\": 'apt update -y; apt install git -y', // 當 pm2 在 remote 機器上將專案 clone 下來之後會執行的指令，同上，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 \"post-setup\": \"ls -la\", // 當 pm2 在 local 要連上 remote 部署之前 ，在 local 端所要執行的指令, 同上，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 \"pre-deploy-local\" : \"echo 'This is a local executed command'\", // 部署完成後, 所要執行的指令 同上，可以多個指令，由 ; 分割，也可以指定 shell script 的檔案路徑 'post-deploy': 'sudo /root/.nvm/versions/node/v8.16.0/bin/npm install &amp;&amp; sudo /root/.nvm/versions/node/v8.16.0/bin/npm rebuild &amp;&amp; /root/.nvm/versions/node/v8.16.0/bin/pm2 reload ecosystem.config.js', env_production: &#123; NODE_ENV: 'production' &#125; &#125;, staging: &#123; user: 'root', host: ['host3', 'host4'], ref: 'origin/staging', repo: 'git@gitlab.com:user/yourProject.git', path: '/var/www/yourProjectName', \"ssh_options\": \"StrictHostKeyChecking=no\", \"pre-setup\": 'apt update -y; apt install git -y', \"post-setup\": \"ls -la\", \"pre-deploy-local\" : \"echo 'This is a local executed command'\", 'post-deploy': 'sudo /root/.nvm/versions/node/v8.16.0/bin/npm install &amp;&amp; sudo /root/.nvm/versions/node/v8.16.0/bin/npm rebuild &amp;&amp; /root/.nvm/versions/node/v8.16.0/bin/pm2 reload ecosystem.config.js', env_production: &#123; NODE_ENV: 'staging' &#125; &#125;, &#125;,&#125;; pm2 部署pm2 的部署功能，可以讓我們從本機直接部署到多台 server 上, 也可以結合 CI / CD 工具，在提交 commit 後自動部署 部署前的必要條件 首先要先確定，local 到 remote 端的 ssh key 有準備好了嗎？ local 到 remote server 的 ssh 連線是必要的哦！ 簡單來說，你需要在 local 放一把 private key, 然後在你的 remote server 放一把 public key, 這樣才能暢通無阻哦！ 這部分再麻煩 Google 一下哦！ 再來，因為 pm2 會 ssh 到 remote server 上，然後在 remote server 上從我們的專案處 GitHub 或 GitLab 將專案 clone 下來，所以務必確保 remote server 是可以從 GitHub 或 GitLab clone 我們的專案, 所以你要在 remote server 上放一把 clone 用的 private key, 然後將 public key 放在 GitLab 或 GitHub 上，這部分也是麻煩 Google 一下哦 由於首次 ssh 連線時會跳詢問是否將 public key 加入到 known host，這個 prompt 會讓 pm2 deploy 卡住，所以務必先將 remote server 設定好哦！ 可以先連線一次，也可以修改 ssh config, 取消這個 hostKey 的 確認功能。 echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" &gt; ~/.ssh/config 接下來，要將 ecosystem 設定檔寫好，這部分請參考上方的 deploy 範例 最後，請確認 remote server 的 ssh 通道 (預設 port 22) 不是關閉的哦！ 初始化遠端資料夾在部署之前, 先在 remote server 上初始化專案的資料夾, 可以帶入不同的參數讓 pm2 根據設定檔做相對應得部署pm2 deploy ecosystem.config.js production setup 部署 部署在初始化遠端資料夾之後，我們就可以使用 pm2 的部署功能了 pm2 deploy ecosystem.config.js production deploy 可使用的參數如下，也可使用 pm2 deploy help 查看 pm2 deploy &lt;configuration_file&gt; &lt;environment&gt; &lt;command&gt; Commands: setup 遠端初始化（第一次部署才會用到） update 更新到最新的 commit revert [n] 回復到上一次的 deployment curr[ent] 輸出目前上線中的 commit prev[ious] 輸出上一次部署的 commit exec|run &lt;cmd&gt; 執行指定的指令 list 列出包含目前，以及之前所部署的 commit [ref] 部署到指定的 ref 部署相關指令pm2 startOrRestart all.json # 重啟所有 apppm2 startOrReload all.json # 觸發 reload 強制重啟pm2 的部署，會要求 local 端先將變更推上 Git repository, 然後 pm2 會在 remote server 執行 git pull, 所以當 local 的變更尚未推上 Git 時，部署會失敗。這時候如果我們硬要部署，我們可以使用pm2 deploy ecosystem.json production --force CI / CD 部署 利用 GitLab 的 CI / CD Runner 配合 pm2 來跑自動部署, 以下為 gitlab.yml 檔案範例 # 使用輕量化 pm2 imageimage: keymetrics/pm2:latest-alpinestages:- deployDeploy: stage: deploy script: # 若 ssh-agent 未安裝，則安裝 - 'which ssh-agent || ( apk add --update openssh )' # 安裝 bash, 以執行 pm2 CLI 工具 - apk add --update bash # 安裝 git, pm2 要連過去時會用到 - apk add --update git # 執行 ssh agent - eval $(ssh-agent -s) # 將 ssh key 加到 ssh agent, 此 ssh key 為 GitLab 的 variable 選項 - echo \"$SSH_PRIVATE_KEY\" | ssh-add - # 執行 pm2 CLI - pm2 deploy ecosystem.config.js production update only: - master 設定好之後，只要 git push 到 master branch, 就會觸發 GitLab CI / CD Runner 自動完成 CI / CD 開機自動啟動 產生開機 script pm2 startup 取消開機自動重啟 pm2 unstartup 儲存下次重啟時，預設啟動的 process pm2 save 如果有更新 node 的版本，記得更新 script pm2 unstartup &amp;&amp; pm2 startup &amp;&amp; pm2 save 有變更時重啟監看該資料夾下的所有檔案，以及子資料夾，並且忽略 node_module 這個資料夾cd /path/to/my/apppm2 start env.js --watch --ignore-watch=\"node_modules\" 更新 PM2npm install pm2@latest -g &amp;&amp; pm2 update 常用指令# Fork 模式pm2 start app.js --name my-api # 指定程序名稱# Cluster 模式pm2 start app.js -i 0 # 會根據可用的 CPU 數量來啟動最大的程序數量，達到平衡負載的效果pm2 start app.js -i max # 跟上面一樣，但是廢除了pm2 scale app +3 # 增加三個 workerpm2 scale app 2 # 將 worker 更新成兩個# 狀態顯示pm2 list # 顯示所有程序狀態pm2 jlist # 將程序狀態使用 raw JSON 印出pm2 prettylist # 將程序狀態用美化的 JSON 印出pm2 describe 0 # 顯示特定程序的所有資訊pm2 monit # 監控所有程序# Logspm2 logs [--raw] # 以串流的方式顯示所有 logpm2 flush # 移除所有 log 檔案pm2 reloadLogs # 重新載入 logs# 操作pm2 stop all # 停止所有程序pm2 restart all # 重新開啟所有程序pm2 reload all # 重新載入服務pm2 stop 0 # 停止特定 id 的程序pm2 restart 0 # 重新啟動特定 id 程序pm2 delete 0 # 從 pm2 list 移除特定 id 程序, 但這並不會停止該程序pm2 delete all # 移除所有程序, 但這並不會停止這些程序# Miscpm2 reset &lt;process&gt; # 重置 meta datapm2 updatePM2 # 更新 pm2pm2 ping # Ensure pm2 daemon has been launchedpm2 sendSignal SIGUSR2 my-app # Send system signal to scriptpm2 start app.js --no-daemon # 不要背景執行pm2 start app.js --no-vizion # 不加這一行，預設執行 pm2 start app 時，只要 ssh key 沒問題， pm2 會自動比較 local 跟 remote, 看是否為最新的 commit，若否，會自動下載更新pm2 start app.js --no-autorestart # 不自動重啟 自動補齊 支援 pm2 指令可以打 tab 自動補齊pm2 completion install 疑難雜症遇到錯誤 Error: ENOENT: no such file or directory, uv_cwd意思是說， pm2 的工作目錄資料夾不存在，所謂的工作目錄資料夾就是我們第一次啟動 pm2 的位置。很可能是我們啟動之後，就不小心把它刪了，如果要尋找工作目錄資料夾在哪，可以使用下面的 command 找到 pm2 的 process id ps ax | grep PM2 然後查詢該 process 執行時所在的目錄（將上面得到的 process id 替換下面的 PM2_Process_ID ls -l /proc/PM2_Process_ID/cwd 公布結果 ls -l /proc/24016/cwd 結果應該會如下, 最後的 deleted 表示該目錄已經被刪除了 lrwxrwxrwx 1 root root 0 Feb 4 17:04 /proc/24016/cwd -&gt; /home/nodejs/deploy(deleted) 現在知道原因了，那解決的方法呢？ 我們要先把目前的 process 砍掉，然後到一個安全一點的地方在開啟一次，以免下次又被誤刪了！ 殺掉 pm2 process id kill -9 processID 到一個安全不會再被意外砍掉的目錄再次啟動 pm2 cd ~ &amp;&amp; pm2 -v 參考資料pm2 官網pm2 logrotate","link":"/zh-tw/pm2/"},{"title":"PHPSTORM 學習筆記","text":"前言PHPSTORM 學習筆記, 學什麼看什麼記什麼！ Laravel debugger安裝 xdebug參考文件 使用 peck 安裝 pecl install xdebug 打開 php.ini 檔 vim $(pecl config-get php_ini) 輸入以下設定 [xdebug]zend_extension=&quot;xdebug.so&quot;xdebug.remote_enable=1xdebug.remote_port=&quot;9000&quot;xdebug.idekey=rayxdebug.default_enable=1 儲存離開後, 驗證是否有安裝成功 php -version 預計輸出： 建立含有 phpinfo() 的 PHP 檔案&lt;?phpphpinfo(); 預計輸出: 在 PhpStorm 中設定 Xdebug參考文件 設定可利用 Paw 或 Postman 測試參考文件1出處圖片備份 參考文件2出處","link":"/zh-tw/phpstorm/"},{"title":"使用 Kubernetes 來編排你的雲端","text":"概述在這個教程中, 你將會學習到如何： 使用 Kubernetes Engine 來提供一個完整的 Kubernetes 叢集 使用 kubectl 部署以及管理 Docker 容器 使用 Kubernetes 的 Deployments 以及 Services 將應用拆分為微服務 Kubernetes 重點就是應用。 在本教程中的這個部分, 你將使用範例應用名為 “app” 來完成這個教程 App 由 GitHub 管理, 且提供一個 12-Factor 範例應用。 在本教程中你將會使用以下的 Docker images kelseyhightower/monolith - Monolith 包含 auth 以及 hello 服務 kelseyhightower/auth - Auth 微服務。 為通過驗證的使用者產生 JWT tokens kelseyhightower/hello - Hello 微服務。 向通過驗證的使用者打招呼 ngnix - 將流量導向 auth 以及 hello 服務 Kubernetes 是一個開源的專案 (可從 kubernetes.io 獲得), 可以運行在很多不同的環境上, 從筆電到高可用的多主機叢集; 從公開的雲端到人為部署; 從虛擬機到裸機 在本教程中, 使用一個受管理的環境, 像是 Kubernetes Engine (一個由 Google 維護的 Kubernetes 版本, 運行在 Compute Engine 上), 將會讓你可以更專注在體驗 Kubernetes, 而不是設定底層的環境。 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview Google Kubernetes Engine在 cloud shell 環境, 輸入以下指令來設定 zonegcloud config set compute/zone us-central1-b 設定完 zone 之後, 開始一個本教程需要用到的叢集gcloud container clusters create io 注意： 創建叢集會耗費幾分鐘 - Kubernetes Engine 會提供數個虛擬機讓我們使用 取得範例代碼在 Cloud Shell 執行以下代碼來複製 GitHub 倉庫 git clone https://github.com/googlecodelabs/orchestrate-with-kubernetes.git cd orchestrate-with-kubernetes/kubernetes 列出我們會使用的檔案ls 範例結構如下：deployments/ /* Deployment manifests */ ...nginx/ /* nginx config files */ ...pods/ /* Pod manifests */ ...services/ /* Services manifests */ ...tls/ /* TLS certificates */ ...cleanup.sh /* Cleanup script */ 該有的都有了, 讓我們來試試看 Kubernetes 吧！ Kubernetes 快速示範開始 Kubernetes 最簡單的方法, 就是使用 kubectl create 指令。 使用它來啟動一個 nignx 容器的單一虛擬機kubectl create deployment nginx --image=nginx:1.10.0 Kubernetes 已經建立了一個 deployment – 關於 deployment 等等會再多加解釋, 但現在你唯一需要知道的是, deployments 維持 pods 啟動以及運行, 就算當他們運行的 nodes 有錯誤 在 Kubernetes 中, 所有的容器都運行在 pod 當中。 使用 kubectl get pods 指令來檢視運行中的 nginx 容器:kubectl get pods 一旦 nginx 容器已經在運行中, 你可以使用 kubectl expose 指令來暴露它kubectl expose deployment nginx --port 80 --type LoadBalancer 所以剛剛發生什麼事了呢？ 在我們看不見的地方, Kubernetes 建立了一個外部的平衡負載附有一個公開的 IP。 任何向這個 IP 發請求的客戶端都會被導向服務後方的 pods, 在這個例子中, 是 nginx pod 現在使用 kubectl get 指令來列出服務kubectl get services 注意： ExternalIP 欄位可能會需要幾秒鐘的時間載入我們的服務。 這是正常的 – 可以幾秒鐘執行一次 kubectl get services 直到該欄位載入 執行以下指令來存取 Nginx containercurl http://&lt;External IP&gt;:80 是不是有了！ Kubernetes 提供立即可用的簡單方法, 使用 kubectl 運行以及暴露的指令 測試進度點擊 Check my progress 來確認目前的進度。如果你已經完成目前的進度，你將獲得一個評價分數。 現在你已經完成一個 Kubernetes 簡短的旅程, 是時候更深入每一個元件以及抽象層 PodsKubernetes 的核心就是 Pod Pods 代表, 並持有一個或多個容器。 一般來說, 如果你有多個容器, 並且容器之間有很強的依賴, 那你會將這些容器打包進一個 pod 這裡的範例是一個 pod 內裝有 monolith 以及 nginx 的容器 Pods 也有 Volumes。 Volumes 是與 pods 共存亡的資料硬碟, 且可被 pod 內的容器使用。 Pods 為其內容提供一個共享的命名空間, 這表示範例 pod 內的兩個容器可以互相溝通, 並且分享附加的 volumes Pods 同時也分享一個網路命名空間。 這表示每個 pod 有著一個 IP 位址 現在讓我們更深入 pods 的世界 建立 pods可以使用 pod 設定檔來建立 pod 。 讓我們來探索一下 monolith pod 設定檔, 執行以下指令:cat pods/monolith.yaml 輸出如下：apiVersion: v1kind: Podmetadata: name: monolith labels: app: monolithspec: containers: - name: monolith image: kelseyhightower/monolith:1.0.0 args: - \"-http=0.0.0.0:80\" - \"-health=0.0.0.0:81\" - \"-secret=secret\" ports: - name: http containerPort: 80 - name: health containerPort: 81 resources: limits: cpu: 0.2 memory: \"10Mi\" 有幾件需要注意到的事, 你將看到： 你的 pod 由一個容器組成 (monolith) 當容器啟動時, 你帶入一些參數 你打開 port 80 供 http 流量使用 使用 kubect1 建立 monolith pod kubectl create -f pods/monolith.yaml 檢視你的 pods 。 使用 kubectl get pods 指令來列出所有運行在預設命名空間的 podskubectl get pods 注意: monolith pod 啟動與運行可能會需要幾秒鐘。 monolith 容器的 image 需要先從 Docker Hub 下載下來, 然後才能啟動。 一旦 pod 開始運行, 使用 kubectl describe 指令來獲得 monolith pod 更多的資訊kubectl describe pods monolith 你將會看到很多很多關於 monolith 的資訊, 包含 Pod IP 位址以及事件紀錄。 當除錯時, 這些資訊隨手可得。 Kubernetes 讓建立 pods 如此的簡單, 只需要再設定檔中敘述, 並且當在運行中時, 檢視資訊也是如此的簡單。 現在你已經有能力建立所有你部署需要的 pods 與 pods 的互動照預設, pods 會被分配一個非公開的 IP 位址, 且無法被從叢集外存取。 使用 kubectl port-forward 指令來將本地的 port 以及 monolith pod 裡頭的 port 做連結 從現在開始, 本教程會要求在多個 cloud shell 視窗之間操作以設定 pods 之間的溝通。 任何在第二個或第三個 shell 中執行的指令都表示該 shell 的命令 開啟兩個 Cloud Shell terminals 。 一個執行 kubectl port-forward 指令, 另一個執行 curl 指令。 在 第二個 terminal, 執行以下指令來設定 port-forwardingkubectl port-forward monolith 10080:80 現在在第一個 terminal, 開始使用 curl 與你的 pod 對話 curl http://127.0.0.1:10080 Yes! 你從你的容器收到一個友善的 “hello” 現在使用 curl 指令來看看當你存取一個安全端點時, 發生什麼事：curl http://127.0.0.1:10080/secure Oh!試著登入, 從 monolith 取得 auth tokencurl -u user http://127.0.0.1:10080/login 在登入彈窗, 使用超級安全的密碼 “password” 來登入 登入會返回一個 JWT 。 因為 cloud shell 無法很好的處理長字串的複製, 建立一個環境變數來裝這個 tokenTOKEN=$(curl http://127.0.0.1:10080/login -u user|jq -r '.token') 再次輸入超級安全密碼 “password” 當彈窗要求 host 密碼 使用上面的指令來複製, 然後用 curl 來提供 token 存取安全端點curl -H \"Authorization: Bearer $TOKEN\" http://127.0.0.1:10080/secure 現在你應該可以從應用得到回應, 告訴我們世界又恢復了正常 使用 kubectl logs 指令來檢視 monolith pod 的紀錄 kubectl logs monolith 開啟第三個 terminal 並且使用 -f 旗標來取得即時的紀錄 kubectl logs -f monolith 現在在第一個 terminal 使用 curl 來語 monolith 互動, 你可以看到記錄在更新著 (在第三個 terminal) curl http://127.0.0.1:10080 使用 kubectl exec 指令, 在 monolith pod 內運行一個互動的 shell 。 當在除錯時, 這會十分方便。kubectl exec monolith --stdin --tty -c monolith /bin/sh 例如說, 一旦我們在 monolith 容器有一個 shell, 我們可以使用 ping 測試外部的連結ping -c 3 google.com 確認登出互動 shellexit 你可以看到, 使用 kubectl 指令與 pod 互動是如此的容易。 Kubernetes 提供了所有的一切, 如果你需要遠端存取一個容器, 或是取得一個登入的 shell 服務Pods 並不會永遠存在。 有很多種原因, 他們會被停止以及開啟 - 像是沒通過存活以及就緒的檢查 - 而這衍生一個問題 當一組 Pods 重啟了, 他們的 IP 變了, 這時候你要怎麼去跟他們溝通？ 這就是 Services 的功用。 Services 為 Pods 提供了穩定的端點 Services 使用標籤 (labels) 來確定要作用在哪一些 Pods 上。 如果 Pods 有正確的標籤, 他們會自動地被 service 選擇且暴露 Service 提供給一系列的 Pods 的存取等級取決於 Service 的類型。 目前有三種類型： ClusterIP (internal) – 預設類型, 表示這個 Service 只能在叢集內部被看見 NodePort – 給予叢集內的節點一個外部可存取的 IP LoadBalancer – 從雲端提供者那增加一個平衡負載, 將外部流量經由 Service 導向節點 現在, 你將學習如何： 建立一個 Service 使用標籤選擇器來暴露某幾個 Pods, 使他們可被外部看見 建立一個 Service在我們建立我們的 Service 之前 – 讓我們先建立一個安全 pod, 它可以處理 HTTPS 的流量 如果你已經變更資料夾了, 確保你已經回到 ~/orchestrate-with-kubernetes/kubernetes 資料夾 cd ~/orchestrate-with-kubernetes/kubernetes 檢視 monolith service 設定檔cat pods/secure-monolith.yaml 建立一個 secure-monolith pods 以及他們的設定資料：kubectl create secret generic tls-certs --from-file tls/kubectl create configmap nginx-proxy-conf --from-file nginx/proxy.confkubectl create -f pods/secure-monolith.yaml 現在你有一個 secure pod, 是時候暴露 secure-monolith Pod 到外部。 建立一個 Kubernetes service 檢視 monolith service 設定檔cat services/monolith.yaml 輸出：kind: ServiceapiVersion: v1metadata: name: \"monolith\"spec: selector: app: \"monolith\" secure: \"enabled\" ports: - protocol: \"TCP\" port: 443 targetPort: 443 nodePort: 31000 type: NodePort 要注意的事情： 選擇器 (selector) 被使用來自動選擇以及暴露任何有標籤 “app=monolith” 以及 “secure=enabled” 的 pods 現在你必須暴露 nodePort, 因為這樣你才可以轉送外部流量從 31000 到 nginx (port 443) 使用 kubectl create 指令, 從 monolith service 設定檔來建立 monolith servicekubectl create -f services/monolith.yaml 輸出：service &quot;monolith&quot; created 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功地建立了 Monolith pods 以及 service，你將獲得一個評價分數。 使用 port 來暴露 service。 這表示如果有其他的 app 嘗試連結你其中一個 service 的 port 31000, 那可能會有衝突。 正常來說, Kubernetes 會處理 port 的分配, 在這個教程中, 你自己選擇 port, 所以等等我們在設定健康檢查的時候會比較容易。 使用 gcloud compute firewall-rules 指令來允許流量經由 nodePort 31000 來存取 monolith servicegcloud compute firewall-rules create allow-monolith-nodeport \\ --allow=tcp:31000 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立防火牆規則來允許 TCP 流量進出 port 31000，你將獲得一個評價分數。 現在, 所有東西都設定好了, 你應該可以從叢集外部直接存取 secure-monolith service, 且不需要特別轉發 port 首先, 取得其中一個節點的外部 IPgcloud compute instances list 現在試著使用 curl 向 secure-monolith service 發請求:curl -k https://&lt;EXTERNAL_IP&gt;:31000 Oh, 連線逾時了, 怎麼會這樣？ 是時候快速利用以下幾個問題釐清一下概念, 利用下面的指令來取得問題的答案：kubectl get services monolithkubectl describe services monolith 問題： 為什麼你無法從 monolith service 取得回應？ monolith service 有幾個端點？ Pod 需要有哪些標籤, 才會被 monolith service 取用？ 提示： 跟標籤有關。 你將會在下一個章節解決這個問題。 增加標籤到 Pods目前 monolith service 沒有任何端點。 有一個排除像這樣的錯誤的好方法, 那就是使用 kubectl get pods 指令的標籤查詢 我們可以看到, 有一些 pods 被貼上了 monolith 標籤kubectl get pods -l \"app=monolith\" 但是標籤不是 “app=monolith” 和 “secure=enabled” 嗎？kubectl get pods -l \"app=monolith,secure=enabled\" 注意到這個標籤查詢並沒有印出任何的結果。 看起來是我們需要把 “secure=enabled” 標籤加到這些 pods 上 使用 kubectl label 指令來加漏掉的 secure=enabled 標籤加到 secure-monolith Pod。 之後呢, 你可以確認標籤是否有更新kubectl label pods secure-monolith 'secure=enabled'kubectl get pods secure-monolith --show-labels 現在我們的 pods 已經被上標籤了, 讓我們檢視一下 monolith service 端點的清單kebectl describe services monolith | grep Endpoints 有一個! 讓我們向其中一個節點發請求, 測試看看！gcloud compute instances listcurl -k https://&lt;EXTERNAL_IP&gt;:31000 連接上了！ 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功地將標籤加到 monolith pods，你將獲得一個評價分數。 部署應用到 Kubernetes本教程的目標是讓你準備好在正式產品線上操作擴充以及管理容器。 這也是 Deployment 的作用。 Deployments 是一種宣告的方法, 確保運行的 Pods 數量跟使用者指定的數量是一致的。 Deployments 的主要優點, 是將管理 Pods 的低階細節抽象化。 如果 Pods 需要擴充或更新, Deployment 會處理這一段。 Deployment 也處理重啟 Pods 這一塊, 如果 Pods 因為某些原因關閉的話。 讓我們來快速看一個範例： Pods 的生命週期與他們被建立且身處的 Node 一樣長。 在上面的範例中, Node3 關閉了 (帶著 Pod 一起)。 Deployment 建立一個新的 Pod, 然後在 Node2 上運行, 而不需要手動建立一個新的 Pod 然後再找一個 Node 來運行它。 真是太酷了！ 是時候結合你學到的東西, Pods, Services, 使用 Deployment 將 monolith 應用拆分成更小的 Services 建立 Deployments我們將會把 monolith app 拆成三個小的部分： auth - 為通過驗證的使用者產生 JWT tokens hello - 向通過驗證的使用者打招呼 frontend - 將流量導向 auth 以及 hello 服務 我們已經準備好要為每一個 service 建立 deployments了。 在那之後, 我們將為 auth 以及 hello deployments 定義內部 service, 以及為 frontend deployment 定義外部 service 。 一旦完成, 你將可以跟每個微服務互動, 就跟現在一樣, 不同的是, 每一個部分將可以獨立地被部署, 擴充。 先從檢視 deployment 設定檔開始吧cat deployments/auth.yaml 輸出：apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: authspec: replicas: 1 template: metadata: labels: app: auth track: stable spec: containers: - name: auth image: \"kelseyhightower/auth:2.0.0\" ports: - name: http containerPort: 80 - name: health containerPort: 81... deployment 建立 1 個 replica, 且使用版本 ２.0.0 的 auth 容器 當你執行 kubectl create 指令建立 auth deployment, 它會建立一個 pod, 這個 pod 會符合 Deployment 的清單資料。 這表示你可以藉由改變 Replicas 欄位的數字來擴充 Pods 的數量 不管怎樣, 建立 deployment 物件吧kubectl create -f deployments/auth.yaml 是時候為 auth deployment 建立 service 了。 使用 kubectl create 指令來建立 auth service:kubectl create -f services/auth.yaml 現在重複一樣的步驟來建立並暴露 hello deploymentkubectl create -f deployments/hello.yamlkubectl create -f services/hello.yaml 再一次, 建立及暴露 frontend deploymentkubectl create configmap nginx-frontend-conf --from-file=nginx/frontend.confkubectl create -f deployments/frontend.yamlkubectl create -f services/frontend.yaml 建立 frontend 還有最後一步, 因為你需要使用容器儲存一些設定資料 取得 frontend 的外部 IP, 並且使用 curl 來跟它互動吧!kubectl get services frontendcurl -k https://&lt;EXTERNAL-IP&gt; 然後你得到一個 hello 回應！ 測試進度點擊 Check my progress 來確認目前的進度。如果你已經成功建立 auth, hello, 以及 frontend deployment, 你將獲得一個評價分數。 總結恭喜！ 你已經使用 Kubernetes 部署了一個多服務的應用。 你在這學到的技術將可以讓你使用一系列的 deployments 以及 services 在 Kubernetes 部署複雜的應用。","link":"/zh-tw/orchestratingTheCloudWithKubernetes/"},{"title":"在 MacOS 及 AWS 上部署 supervisor","text":"部署 supervisor前言本篇重點如下： 在 Mac OS 上安裝並部署 Supervisor 在 AWS 上安裝並部署 Supervisor Supervisor是什麼？Supervisor 是一套程序管理系統。因為 Ray 的專案有使用到 Laravel 的 queue ，而 queue 必須要常駐在背景執行，那要是不小心失敗或中斷了怎麼辦呢？ supervisor 可以確保當 queue 失敗中斷時，自動地幫我們重啟。 Mac OS安裝 安裝 Supervisorbrew install supervisor 配置 進到預設設定檔 vim /usr/local/etc/supervisord.ini 更改預設 include 目錄，到最後一行，修改如下 [include]files = /usr/local/etc/supervisor.d/*.conf 新增客製化配置目錄及檔案 mkdir /usr/local/etc/supervisor.d;vim /usr/local/etc/supervisor.d/processNameYouLike.conf; 輸入下面的設定 [program:programNameYouLike]process_name=%(program_name)s_%(process_num)02dcommand=php absoluteAddressOfYourProject/artisan queue:work sqs --sleep=3 --tries=3 --daemonautostart=trueautorestart=trueuser=raynumprocs=8redirect_stderr=truestdout_logfile=/absoluteAddressOfLocationYouWouldLikeToPutTheLog/worker.log 啟動 啟動服務 sudo supervisord -c /usr/local/etc/supervisord.ini 進到控制台 sudo supervisorctl -c /usr/local/etc/supervisord.ini 更新配置 update 查看狀態 status 看起來如下： AWSAmazon Linux 2 AMI本篇記錄使用的AWS型號如下： Amazon Linux 2 AMI (HVM), SSD Volume Type - ami-0f9ae750e8274075b t2.micro (Variable ECUs, 1 vCPUs, 2.5 GHz, Intel Xeon Family, 1 GiB memory, EBS only) 安裝 安裝 supervisorsudo yum install -y supervisor 配置 到預設設定檔 sudo vim /etc/supervisord.conf 更改最後一行 include 的目錄 [include]files = supervisord.d/*.conf 新增配置檔，如果資料夾不存在就創建 sudo mkdir /etc/supervisord.d;sudo vim /etc/supervisord.d/projectFileNameYouLike.conf 新增配置 [program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=sudo php absoluteAddressOfYourProject/artisan queue:work sqs --sleep=3 --tries=3 --daemonautostart=trueautorestart=trueuser=rootnumprocs=8redirect_stderr=truestdout_logfile=absoluteAddressOfYourProject/worker.log 啟動 啟動 supervisor sudo supervisord -c /etc/supervisord.conf 套用新的配置檔並查看狀態 sudo supervisorctl update;sudo supervisorctl status 配置自動重啟 增加重啟配置檔 sudo vim /etc/init.d/supervisord 輸入以下配置 #! /bin/sh### BEGIN INIT INFO# Provides: supervisord# Required-Start: $remote_fs# Required-Stop: $remote_fs# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Example initscript# Description: This file should be used to construct scripts to be# placed in /etc/init.d.### END INIT INFO# Author: Dan MacKinlay &lt;danielm@phm.gov.au&gt;# Based on instructions by Bertrand Mathieu# http://zebert.blogspot.com/2009/05/installing-django-solr-varnish-and.html# Do NOT &quot;set -e&quot;# PATH should only include /usr/* if it runs after the mountnfs.sh scriptPATH=/sbin:/usr/sbin:/bin:/usr/binDESC=&quot;Description of the service&quot;NAME=supervisordDAEMON=/usr/local/bin/supervisordDAEMON_ARGS=&quot;&quot;PIDFILE=/var/run/$NAME.pidSCRIPTNAME=/etc/init.d/$NAME# Exit if the package is not installed[ -x &quot;$DAEMON&quot; ] || exit 0# Read configuration variable file if it is present[ -r /etc/default/$NAME ] &amp;&amp; . /etc/default/$NAME# Load the VERBOSE setting and other rcS variables. /lib/init/vars.sh# Define LSB log_* functions.# Depend on lsb-base (&gt;= 3.0-6) to ensure that this file is present.. /lib/lsb/init-functions## Function that starts the daemon/service#do_start()&#123; # Return # 0 if daemon has been started # 1 if daemon was already running # 2 if daemon could not be started start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --test &gt; /dev/null \\ || return 1 start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \\ $DAEMON_ARGS \\ || return 2 # Add code here, if necessary, that waits for the process to be ready # to handle requests from services started subsequently which depend # on this one. As a last resort, sleep for some time.&#125;## Function that stops the daemon/service#do_stop()&#123; # Return # 0 if daemon has been stopped # 1 if daemon was already stopped # 2 if daemon could not be stopped # other if a failure occurred start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME RETVAL=&quot;$?&quot; [ &quot;$RETVAL&quot; = 2 ] &amp;&amp; return 2 # Wait for children to finish too if this is a daemon that forks # and if the daemon is only ever run from this initscript. # If the above conditions are not satisfied then add some other code # that waits for the process to drop all resources that could be # needed by services started subsequently. A last resort is to # sleep for some time. start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $DAEMON [ &quot;$?&quot; = 2 ] &amp;&amp; return 2 # Many daemons don&apos;t delete their pidfiles when they exit. rm -f $PIDFILE return &quot;$RETVAL&quot;&#125;## Function that sends a SIGHUP to the daemon/service#do_reload() &#123; # # If the daemon can reload its configuration without # restarting (for example, when it is sent a SIGHUP), # then implement that here. # start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME return 0&#125;case &quot;$1&quot; in start) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_daemon_msg &quot;Starting $DESC&quot; &quot;$NAME&quot; do_start case &quot;$?&quot; in 0|1) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 0 ;; 2) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 1 ;; esac ;; stop) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_daemon_msg &quot;Stopping $DESC&quot; &quot;$NAME&quot; do_stop case &quot;$?&quot; in 0|1) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 0 ;; 2) [ &quot;$VERBOSE&quot; != no ] &amp;&amp; log_end_msg 1 ;; esac ;; #reload|force-reload) # # If do_reload() is not implemented then leave this commented out # and leave &apos;force-reload&apos; as an alias for &apos;restart&apos;. # #log_daemon_msg &quot;Reloading $DESC&quot; &quot;$NAME&quot; #do_reload #log_end_msg $? #;; restart|force-reload) # # If the &quot;reload&quot; option is implemented then remove the # &apos;force-reload&apos; alias # log_daemon_msg &quot;Restarting $DESC&quot; &quot;$NAME&quot; do_stop case &quot;$?&quot; in 0|1) do_start case &quot;$?&quot; in 0) log_end_msg 0 ;; 1) log_end_msg 1 ;; # Old process is still running *) log_end_msg 1 ;; # Failed to start esac ;; *) # Failed to stop log_end_msg 1 ;; esac ;; *) #echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart|reload|force-reload&#125;&quot; &gt;&amp;2 echo &quot;Usage: $SCRIPTNAME &#123;start|stop|restart|force-reload&#125;&quot; &gt;&amp;2 exit 3 ;;esac: script來源 增加權限 sudo chmod +x /etc/init.d/supervisord 將新增的開機重啟配置檔加到系統 sudo chkconfig --add supervisord 打開自動重啟功能，並開始 sudo chkconfig supervisord on;sudo service supervisord start Amazon Linux 2 AMI型號： Amazon Linux AMI 2018.03.0 (HVM), SSD Volume Type - ami-00a5245b4816c38e6 安裝 安裝 supervisor sudo easy_install supervisor 將 /usr/local/bin 加到 sudo path sudo vim /etc/sudoers Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin 配置 建立設定檔 sudo su -sudo echo_supervisord_conf &gt; /etc/supervisord.conf;sudo vim /etc/supervisord.conf 更改最後一行 include 的目錄 [include]files = /etc/supervisord.d/*.conf 新增配置檔，如果資料夾不存在就創建 sudo mkdir /etc/supervisord.d;sudo vim /etc/supervisord.d/projectFileNameYouLike.conf 新增配置 [program:laravel-worker]process_name=%(program_name)s_%(process_num)02dcommand=php absoluteAddressOfYourProject/artisan queue:work sqs --sleep=3 --tries=3 --daemonautostart=trueautorestart=trueuser=apachenumprocs=8redirect_stderr=truestdout_logfile=absoluteAddressOfYourProject/worker.log 啟動 啟動 supervisor sudo supervisord -c /etc/supervisord.conf 套用新的配置檔並查看狀態 sudo supervisorctl update;sudo supervisorctl status 配置自動重啟 增加重啟配置檔 sudo vim /etc/init.d/supervisord 輸入以下配置 #!/bin/bash## supervisord Startup script for the Supervisor process control system## Author: Mike McGrath &lt;mmcgrath@redhat.com&gt; (based off yumupdatesd)# Jason Koppe &lt;jkoppe@indeed.com&gt; adjusted to read sysconfig,# use supervisord tools to start/stop, conditionally wait# for child processes to shutdown, and startup later# Erwan Queffelec &lt;erwan.queffelec@gmail.com&gt;# make script LSB-compliant## chkconfig: 345 83 04# description: Supervisor is a client/server system that allows \\# its users to monitor and control a number of processes on \\# UNIX-like operating systems.# processname: supervisord# config: /etc/supervisord.conf# config: /etc/sysconfig/supervisord# pidfile: /var/run/supervisord.pid#### BEGIN INIT INFO# Provides: supervisord# Required-Start: $all# Required-Stop: $all# Short-Description: start and stop Supervisor process control system# Description: Supervisor is a client/server system that allows# its users to monitor and control a number of processes on# UNIX-like operating systems.### END INIT INFO# Source function library. /etc/rc.d/init.d/functions# Source system settingsif [ -f /etc/sysconfig/supervisord ]; then . /etc/sysconfig/supervisordfi# Path to the supervisorctl script, server binary,# and short-form for messages.supervisorctl=/usr/local/bin/supervisorctlsupervisord=$&#123;SUPERVISORD-/usr/local/bin/supervisord&#125;prog=supervisordpidfile=$&#123;PIDFILE-/tmp/supervisord.pid&#125;lockfile=$&#123;LOCKFILE-/var/lock/subsys/supervisord&#125;STOP_TIMEOUT=$&#123;STOP_TIMEOUT-60&#125;OPTIONS=\"$&#123;OPTIONS--c /etc/supervisord.conf&#125;\"RETVAL=0start() &#123; echo -n $\"Starting $prog: \" daemon --pidfile=$&#123;pidfile&#125; $supervisord $OPTIONS RETVAL=$? echo if [ $RETVAL -eq 0 ]; then touch $&#123;lockfile&#125; $supervisorctl $OPTIONS status fi return $RETVAL&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc -p $&#123;pidfile&#125; -d $&#123;STOP_TIMEOUT&#125; $supervisord RETVAL=$? echo [ $RETVAL -eq 0 ] &amp;&amp; rm -rf $&#123;lockfile&#125; $&#123;pidfile&#125;&#125;reload() &#123; echo -n $\"Reloading $prog: \" LSB=1 killproc -p $pidfile $supervisord -HUP RETVAL=$? echo if [ $RETVAL -eq 7 ]; then failure $\"$prog reload\" else $supervisorctl $OPTIONS status fi&#125;restart() &#123; stop start&#125;case \"$1\" in start) start ;; stop) stop ;; status) status -p $&#123;pidfile&#125; $supervisord RETVAL=$? [ $RETVAL -eq 0 ] &amp;&amp; $supervisorctl $OPTIONS status ;; restart) restart ;; condrestart|try-restart) if status -p $&#123;pidfile&#125; $supervisord &gt;&amp; /dev/null; then stop start fi ;; force-reload|reload) reload ;; *) echo $\"Usage: $prog &#123;start|stop|restart|condrestart|try-restart|force-reload|reload&#125;\" RETVAL=2 esac exit $RETVAL script來源 增加權限 sudo chmod +x /etc/init.d/supervisord 將新增的開機重啟配置檔加到系統 sudo chkconfig --add supervisord 打開自動重啟功能，並開始 sudo chkconfig supervisord on;sudo service supervisord start 在設定好配置檔之前，如何關閉 supervisord ? ps -ef | grep supervisord kill -s SIGTERM 29646 結論完成設定後，每次 reboot ， AWS 就會自動地重啟 supervisor","link":"/zh-tw/supervisor/"},{"title":"SSH 學習筆記","text":"前言本篇為未整理的個人學習紀錄 正文 建立一組公私鑰? ssh-keygen -t rsa -b 4096 -C \"Ray@gmail.com\" 如何將指定的 key 加到 ssh-agent? ssh-add keyFile 當 private_key 的名稱不是預設的 id_rsa 時，何解？將指定的 key 加到 ssh-agent 如何打開 ssh-agent? eval \"$(ssh-agent -s)\" 在 macOS 上，當我們想要將目前這組 key 刪掉，但是新的 key 要沿用相同的檔案名稱，可能會遇到什麼問題？macOS 的 keychain 將舊的 key 記住了，導致怎麼樣都驗不過，驗到人都覺得厭世了 承上，何解？ ssh-add -K keyFile 承上，在 GCP 上何解？ ssh-add -D &amp;&amp; ssh-add keyFile GCP 上，如何安裝 ssh client ? apt-get update -y &amp;&amp; apt-get install openssh-client -y 如果我已經將 key 加到 ssh-agent, 那我還需要將 key 的實體檔案放在 .ssh 的資料夾內嗎？不需要的哦！ 如何查詢指定 Server 的公鑰？ ssh-keyscan to-be-conneted-instance-ip # 127.0.0.1 SSH-2.0-OpenSSH_6.6.1 127.0.0.1 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWBZ3XrIajPmnd6R+g/wcUuOPOiRBMOYjAl4Dv8SfcZtgHqKTK6Zb1EeG3u/uzRYxqXMctG/2A4iXRDG9mvg9H9bimCWbA3xtR79NImPYg4m7BNuH9C+OXRYYJwoOGpjVMs0rGLXkq3/WVkXvQreBuhVD8NI2pEPnQsT1J5abdVbCHlwFYG6wVCJQqFY6jdntJJlxQv5EJu6w4/+Fd4LvdjysH+ngqArac6HMJUxqSxLQjzMdCRWEQKp3ySwmnRp9rHYVaJnnsXeYPfnMN1iMjdIQJPzc89Mepg4ip1q2bCMbMcx2XFO3I7YjYRdcOameFNafMGY0q5RHzhvgnNnal # 127.0.0.1 SSH- 2.0-OpenSSH_6.6.1 127.0.0.1 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/C+HTCqbDgso4mCKpMo= # 127.0.0.2 SSH-2.0-OpenSSH_6.6.1127.0.0.2 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCWBZ3XrIajPmnd6R+g/wcUuOPOiRBMOYjAl4Dv8SfcZtgHqKTK6Zb1EeG3u/uzRYxqXMctG/2A4iXRDG9mvg9H9bimCWbA3xtR79NImPYg4m7BNuH9C+OXRYYJwoOGpjVMs0rGLXkq3/WVkXvQreBuhVD8NI2pEPnQsT1J5abdVbCHlwFYG6wVCJQqFY6jdntJJlxQv5EJu6w4/+Fd4LvdjysH+ngqArac6HMJUxqSxLQjzMdCRWEQKp3ySwmnRp9rHYVaJnnsXeYPfnMN1iMjdIQJPzc89Mepg4ip1q2bCMbMcx2XFO3I7YjYRdcOameFNafMGY0q5RHzhvgnNnal # 127.0.0.2 SSH-2.0-OpenSSH_6.6.1 127.0.0.2 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/ C+HTCqbDgso4mCKpMo= 取最短的那組即可，例如：127.0.0.2 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/ C+HTCqbDgso4mCKpMo= 當我們初次從 a 電腦 經由 ssh 連到 b 電腦時，當 a 電腦要將 b 電腦的公鑰加到 known_host 檔案時，會跳出詢問視窗 yes/no, 如何避免掉這個視窗？ ssh -o StrictHostKeyChecking=no 如何在 GitHub 以及 Gitlab 上使用不同的 key # GitLabHost gitlab.com Preferredauthentications publickey IdentityFile ~/.ssh/gitlab # GitHubHost github.com Preferredauthentications publickey IdentityFile ~/.ssh/github scp利用 config 檔案來驗證scp -F SSHconfig sourceFile targetUser@targetIP:targetLocation 如果是要傳資料夾過去scp -F SSHconfig -r sourceFile targetUser@targetIP:targetLocation 利用 private key 產生 public keyssh-keygen -y -f fileName 把公鑰傳到遠端主機ssh-copy-id -i key.pub user@IP 啟動密碼登入 打開 ssh 配置檔 vim /etc/ssh/sshd.config 修改設定如下 # To disable tunneled clear text passwords, change to no here!PasswordAuthentication yes 重啟 ssh systemctl restart ssh 在 Git 指令中指定 key&quot;SSH -i /root/.ssh/id_rsa&quot; git clone git@gitlab.com:qcdn/qcdn-aircraft-carrier.git SFTP語法sftp account@ip 用法針對遠方伺服器主機 (Server) 之行為 針對本機 (Client) 之行為 (都加上 l, L 的小寫) 針對資料上傳/下載的行為 SCP語法[root@www ~]# scp [-pr] [-l 速率] file [帳號@]主機:目錄名 &lt;==上傳[root@www ~]# scp [-pr] [-l 速率] [帳號@]主機:file 目錄名 &lt;==下載選項與參數：-p ：保留原本檔案的權限資料；-r ：複製來源為目錄時，可以複製整個目錄 (含子目錄)-l ：可以限制傳輸的速度，單位為 Kbits/s ，例如 [-l 800] 代表傳輸速限 100Kbytes/s 範例將本機的 /etc/hosts* 全部複製到 127.0.0.1 上面的 student 家目錄內scp /etc/hosts* student@127.0.0.1:~ 將 127.0.0.1 這部遠端主機的 /etc/bashrc 複製到本機的 /tmp 底下scp student@127.0.0.1:/etc/bashrc /tmp sshd 設定檔[root@www ~]# vim /etc/ssh/sshd_config# 1. 關於 SSH Server 的整體設定，包含使用的 port 啦，以及使用的密碼演算方式# Port 22# SSH 預設使用 22 這個port，也可以使用多個port，即重複使用 port 這個設定項目！# 例如想要開放 sshd 在 22 與 443 ，則多加一行內容為：『 Port 443 』# 然後重新啟動 sshd 這樣就好了！不過，不建議修改 port number 啦！Protocol 2# 選擇的 SSH 協定版本，可以是 1 也可以是 2 ，CentOS 5.x 預設是僅支援 V2。# 如果想要支援舊版 V1 ，就得要使用『 Protocol 2,1 』才行。# ListenAddress 0.0.0.0# 監聽的主機介面卡！舉個例子來說，如果你有兩個 IP，分別是 192.168.1.100 及 # 192.168.100.254，假設你只想要讓 192.168.1.100 可以監聽 sshd ，那就這樣寫：# 『 ListenAddress 192.168.1.100 』預設值是監聽所有介面的 SSH 要求# PidFile /var/run/sshd.pid# 可以放置 SSHD 這個 PID 的檔案！上述為預設值# LoginGraceTime 2m# 當使用者連上 SSH server 之後，會出現輸入密碼的畫面，在該畫面中，# 在多久時間內沒有成功連上 SSH server 就強迫斷線！若無單位則預設時間為秒！# Compression delayed# 指定何時開始使用壓縮資料模式進行傳輸。有 yes, no 與登入後才將資料壓縮 (delayed)# 2. 說明主機的 Private Key 放置的檔案，預設使用下面的檔案即可！# HostKey /etc/ssh/ssh_host_key # SSH version 1 使用的私鑰# HostKey /etc/ssh/ssh_host_rsa_key # SSH version 2 使用的 RSA 私鑰# HostKey /etc/ssh/ssh_host_dsa_key # SSH version 2 使用的 DSA 私鑰# 還記得我們在主機的 SSH 連線流程裡面談到的，這裡就是 Host Key ～# 3. 關於登錄檔的訊息資料放置與 daemon 的名稱！SyslogFacility AUTHPRIV# 當有人使用 SSH 登入系統的時候，SSH 會記錄資訊，這個資訊要記錄在什麼 daemon name# 底下？預設是以 AUTH 來設定的，即是 /var/log/secure 裡面！什麼？忘記了！# 回到 Linux 基礎去翻一下。其他可用的 daemon name 為：DAEMON,USER,AUTH,# LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5,# LogLevel INFO# 登錄記錄的等級！嘿嘿！任何訊息！同樣的，忘記了就回去參考！# 4. 安全設定項目！極重要！# 4.1 登入設定部分# PermitRootLogin yes# 是否允許 root 登入！預設是允許的，但是建議設定成 no！# StrictModes yes# 是否讓 sshd 去檢查使用者家目錄或相關檔案的權限資料，# 這是為了擔心使用者將某些重要檔案的權限設錯，可能會導致一些問題所致。# 例如使用者的 ~.ssh/ 權限設錯時，某些特殊情況下會不許用戶登入# PubkeyAuthentication yes# AuthorizedKeysFile .ssh/authorized_keys# 是否允許用戶自行使用成對的金鑰系統進行登入行為，僅針對 version 2。# 至於自製的公鑰資料就放置於使用者家目錄下的 .ssh/authorized_keys 內PasswordAuthentication yes# 密碼驗證當然是需要的！所以這裡寫 yes 囉！# PermitEmptyPasswords no# 若上面那一項如果設定為 yes 的話，這一項就最好設定為 no ，# 這個項目在是否允許以空的密碼登入！當然不許！# 4.2 認證部分# RhostsAuthentication no# 本機系統不使用 .rhosts，因為僅使用 .rhosts太不安全了，所以這裡一定要設定為 no# IgnoreRhosts yes# 是否取消使用 ~/.ssh/.rhosts 來做為認證！當然是！# RhostsRSAAuthentication no ## 這個選項是專門給 version 1 用的，使用 rhosts 檔案在 /etc/hosts.equiv# 配合 RSA 演算方式來進行認證！不要使用啊！# HostbasedAuthentication no# 這個項目與上面的項目類似，不過是給 version 2 使用的！# IgnoreUserKnownHosts no# 是否忽略家目錄內的 ~/.ssh/known_hosts 這個檔案所記錄的主機內容？# 當然不要忽略，所以這裡就是 no 啦！ChallengeResponseAuthentication no# 允許任何的密碼認證！所以，任何 login.conf 規定的認證方式，均可適用！# 但目前我們比較喜歡使用 PAM 模組幫忙管理認證，因此這個選項可以設定為 no 喔！UsePAM yes# 利用 PAM 管理使用者認證有很多好處，可以記錄與管理。# 所以這裡我們建議你使用 UsePAM 且 ChallengeResponseAuthentication 設定為 no # 4.3 與 Kerberos 有關的參數設定！因為我們沒有 Kerberos 主機，所以底下不用設定！# KerberosAuthentication no# KerberosOrLocalPasswd yes# KerberosTicketCleanup yes# KerberosTgtPassing no # 4.4 底下是有關在 X-Window 底下使用的相關設定！X11Forwarding yes# X11DisplayOffset 10# X11UseLocalhost yes# 比較重要的是 X11Forwarding 項目，他可以讓視窗的資料透過 ssh 通道來傳送喔！# 在本章後面比較進階的 ssh 使用方法中會談到。# 4.5 登入後的項目：# PrintMotd yes# 登入後是否顯示出一些資訊呢？例如上次登入的時間、地點等等，預設是 yes# 亦即是列印出 /etc/motd 這個檔案的內容。但是，如果為了安全，可以考慮改為 no ！# PrintLastLog yes# 顯示上次登入的資訊！可以啊！預設也是 yes ！# TCPKeepAlive yes# 當達成連線後，伺服器會一直傳送 TCP 封包給用戶端藉以判斷對方式否一直存在連線。# 不過，如果連線時中間的路由器暫時停止服務幾秒鐘，也會讓連線中斷喔！# 在這個情況下，任何一端死掉後，SSH可以立刻知道！而不會有僵屍程序的發生！# 但如果你的網路或路由器常常不穩定，那麼可以設定為 no 的啦！UsePrivilegeSeparation yes# 是否使用權限較低的程序來提供使用者操作。我們知道 sshd 啟動在 port 22 ，# 因此啟動的程序是屬於 root 的身份。那麼當 student 登入後，這個設定值# 會讓 sshd 產生一個屬於 sutdent 的 sshd 程序來使用，對系統較安全MaxStartups 10# 同時允許幾個尚未登入的連線畫面？當我們連上 SSH ，但是尚未輸入密碼時，# 這個時候就是我們所謂的連線畫面啦！在這個連線畫面中，為了保護主機，# 所以需要設定最大值，預設最多十個連線畫面，而已經建立連線的不計算在這十個當中# 4.6 關於使用者抵擋的設定項目：DenyUsers *# 設定受抵擋的使用者名稱，如果是全部的使用者，那就是全部擋吧！# 若是部分使用者，可以將該帳號填入！例如下列！DenyUsers testDenyGroups test# 與 DenyUsers 相同！僅抵擋幾個群組而已！# 5. 關於 SFTP 服務與其他的設定項目！Subsystem sftp /usr/lib/ssh/sftp-server# UseDNS yes# 一般來說，為了要判斷用戶端來源是正常合法的，因此會使用 DNS 去反查用戶端的主機名# 不過如果是在內網互連，這項目設定為 no 會讓連線達成速度比較快。 安全設定/etc/ssh/sshd_config# 1. 先觀察一下所需要的帳號是否存在呢？[root@www ~]# for user in sshnot1 sshnot2 sshnot3 testssh student; do \\&gt; id $user | cut -d &apos; &apos; -f1-3 ; doneuid=507(sshnot1) gid=509(sshnot1) groups=509(sshnot1),508(nossh)uid=508(sshnot2) gid=510(sshnot2) groups=510(sshnot2),508(nossh)uid=509(sshnot3) gid=511(sshnot3) groups=511(sshnot3),508(nossh)uid=511(testssh) gid=513(testssh) groups=513(testssh)uid=505(student) gid=506(student) groups=506(student)# 若上述帳號並不存在你的系統，請自己建置出來！UID/GID 與鳥哥的不同也沒關係！# 2. 修改 sshd_config 並且重新啟動 sshd 吧！[root@www ~]# vim /etc/ssh/sshd_configPermitRootLogin no &lt;==約在第 39 行，請拿掉註解且修改成這樣DenyGroups nossh &lt;==底下這兩行可以加在檔案的最後面DenyUsers testssh[root@www ~]# /etc/init.d/sshd restart# 3. 測試與觀察相關的帳號登入情況吧！[root@www ~]# ssh root@localhost &lt;==並請輸入正確的密碼[root@www ~]# tail /var/log/secureJul 25 13:14:05 www sshd[2039]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=localhost user=root# 你會發現出現這個錯誤訊息，而不是密碼輸入錯誤而已。[root@www ~]# ssh sshnot1@localhost &lt;==並請輸入正確的密碼[root@www ~]# tail /var/log/secureJul 25 13:15:53 www sshd[2061]: User sshnot1 from localhost not allowed becausea group is listed in DenyGroups[root@www ~]# ssh testssh@localhost &lt;==並請輸入正確的密碼[root@www ~]# tail /var/log/secureJul 25 13:17:16 www sshd[2074]: User testssh from localhost not allowed because listed in DenyUsers /etc/hosts/allow, /etc/hosts.deny[root@www ~]# vim /etc/hosts.allowsshd: 127.0.0.1 192.168.1.0/255.255.255.0 192.168.100.0/255.255.255.0[root@www ~]# vim /etc/hosts.denysshd : ALL iptables 封包過濾防火牆[root@www ~]# vim /usr/local/virus/iptables/iptables.allowiptables -A INPUT -i $EXTIF -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPTiptables -A INPUT -i $EXTIF -s 192.168.100.0/24 -p tcp --dport 22 -j ACCEPT[root@www ~]# /usr/local/virus/iptables/iptables.rule 設定 ssh 在不同 port 口新增 port[root@www ~]# vim /etc/ssh/sshd_configPort 22Port 23 &lt;==注意喔！要有兩個 Port 的設定才行！[root@www ~]# /etc/init.d/sshd restart 自定義 SELinux 規則放行模組# 1. 於 /var/log/audit/audit.log 找出與 ssh 有關的 AVC 資訊，並轉為本地模組[root@www ~]# cat /var/log/audit/audit.log | grep AVC | grep ssh | \\&gt; audit2allow -m sshlocal &gt; sshlocal.te &lt;==副檔名要是 .te 才行[root@www ~]# grep sshd_t /var/log/audit/audit.log | \\&gt; audit2allow -M sshlocal &lt;==sshlocal 就是剛剛建立的 .te 檔名******************** IMPORTANT ***********************To make this policy package active, execute:semodule -i sshlocal.pp &lt;==這個指令會編譯出這個重要的 .pp 模組！# 2. 將這個模組載入系統的 SELinux 管理當中！[root@www ~]# semodule -i sshlocal.pp# 3. 再重新啟動 sshd 並且觀察埠口吧！[root@www ~]# /etc/init.d/sshd restart[root@www ~]# netstat -tlunp | grep sshtcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 7322/sshdtcp 0 0 0.0.0.0:23 0.0.0.0:* LISTEN 7322/sshdtcp 0 0 :::22 :::* LISTEN 7322/sshdtcp 0 0 :::23 :::* LISTEN 7322/sshd 非正規 port 號連接方式[root@www ~]# ssh -p 23 root@localhostroot@localhost&apos;s password:Last login: Tue Jul 26 14:07:41 2011 from 192.168.1.101[root@www ~]# netstat -tnp | grep 23tcp 0 0 ::1:23 ::1:56645 ESTABLISHED 7327/2tcp 0 0 ::1:56645 ::1:23 ESTABLISHED 7326/ssh# 因為網路是雙向的，因此自己連自己 (localhost)，就會抓到兩隻連線！ Q&amp;A SSH 的全寫是？Secure SHell protocol SSH 中, 公鑰的作用？提供給遠端主機進行資料加密, 也就是說, 每個人都可以有你的公鑰, 用來加密要傳送給你的資料 SSH 中, 私鑰的作用？公鑰用來加密要傳送給你的資料, 而私鑰用來解密這些資料 如果有兩台電腦利用 SSH 來互相傳送資料, 共有至少幾把公鑰, 幾把私鑰？兩把公鑰, 兩把私鑰 非對稱式金鑰系統是什麼意思？伺服器：『具有伺服器的私鑰與用戶端的公鑰』，而用戶端則是： 『具有伺服器的公鑰以及用戶端自己的私鑰』 SSH 連線的具體步驟？ 用戶端對伺服器端發出主動連線要求 伺服器端回傳伺服器公鑰 用戶端紀錄/比對伺服器公鑰 用戶端回傳伺服器用戶端公鑰 開始加解密 SSH 中, 當我們接收到對方電腦的公鑰時, 會儲存在哪？~/.ssh/known_hosts SSH 中, 自家預設的公鑰會放在哪？/etc/ssh/ssh_host* 如何產生新的伺服器端的 ssh 公私鑰? rm /etc/ssh/ssh_host*/etc/init.d/sshd restart 在 sftp 中, 我可以隨意更改 local 或 remote 的資料夾所在位置嗎？可以哦, 可以參考這裏 在 scp 中, 保留原本檔案的權限資料嗎？可以哦, 可以參考這裏 在 ssh 中, 可以開啟多個 port 且都使用在 ssh 上嗎？可以哦！ 請參考sshd 設定檔 在 ssh-keygen 中, 如果我沒有特別指令密碼演算法的話, 預設是哪一種？RSA .ssh 目錄的權限必須要是多少？700 ssh 中, 私鑰的權限必須得是多少？600 ssh 中, 私鑰的擁有者必須得是誰？該 user 目錄下的擁有者 ssh 中, 如果自建 key-pair 卻無法通過驗證, 很有可能是甚麼原因？sshd 檔案中的 AuthorizedKeysFile 設定沒有打開, 可參考 sshd 設定檔 ssh 中, 如果我是透過自建 key 的方式, 那我公鑰應該要放在伺服器端的哪個檔案中？預設檔名為 .ssh/authorized_keys, 可透過 sshd 設定檔 修改 ssh 中, 如果我是透過自建 key 的方式, 預設的伺服器端公鑰放置檔案 authorized_keys 的權限該設定為多少？644 ssh 中, 如果登入失敗, log 可以在哪裡看？ tail /var/log/secure ssh 中, 可以限制僅有指定的 user 或 group 才可經由 ssh 登入嗎？可, 可參考 sshd config ssh 中, 可以限制僅有指定的 IP 才可經由 ssh 登入嗎？可, 可參考 hosts.allow &amp; hosts.deny ssh 中, 可以透過 iptable 限制指定的 ip 才可經由 ssh 登入嗎？可, 可參考 iptables.allow &amp; iptables.rule ssh 中, 我可以修改預設 port 22 到別的 port 號嗎？可以, 可參考 ssh port 號變更","link":"/zh-tw/ssh/"},{"title":"<未完成> 命令行的藝術","text":"前言本篇為 The Art of Command Line 的學習筆記, 內文會盡量精簡只記錄必要的, 主要會以 Questions and Answers 的方式來記錄。 基礎","link":"/zh-tw/the-art-of-command-line/"},{"title":"TypeScript 學習筆記","text":"前言TypeScript 學習筆記, 學什麼記什麼！","link":"/zh-tw/typescript/"},{"title":"使用 Laravel 任務排程","text":"打開排程檔案打開 yourProjectName/app/Console/Kernel.php 輸入你的排程排程範例如下： protected function schedule(Schedule $schedule)&#123; $schedule-&gt;call(function () &#123; Token::where(&apos;expiry_time&apos;, &apos;&lt;&apos;, time())-&gt;delete(); PaymentServiceOrders::deleteExpiredOrders(); Order::where(&apos;expiry_time&apos;, &apos;&lt;&apos;, Carbon::now())-&gt;delete(); &#125;)-&gt;daily();&#125; 我設定的任務排程, 是每天固定刪除資料庫裡過期的訂單。 將 Laravel 排程加入到 Linux 的 crontab 中 sudo vim /etc/crontab * * * * * apache cd /var/www/html/yourProjectName &amp;&amp; php artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1 前面的 * 依序分別代表 分(0-59) 時(0-23) 每月的第幾天(1-31) 月份(1-12) 每週的第幾天(0-6) apache表示使用者, 這關乎權限問題, 當執行的 schedule 中出現錯誤, log 會由此使用者而建立, 若權限沒有設好, 之後的使用者都將無法讀取 log, 若我們本身有額外記 log 的話, 會因為此 log 檔無法被開啟而造成錯誤 cd ray cd /var/www/html/yourProjectName到該目錄底下 php artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1執行 Laravel 的排程指令 以上, 這樣應該就可以順利地跑起來了！","link":"/zh-tw/taskSchedulingInLaravel/"},{"title":"使用MySQL- group by 來整理資料庫","text":"大家好，我是Ray! 昨天跟大家分享如何正確的導入中文的資訊到資料庫裡，今天呢，我將分享如何使用MySQL的group by 來整理資料庫！ 在上圖我們可以看到，所有資料都以不同的地區來做劃分。假設右手邊的欄位資料爲降雨量好了，如果我們今天想要取得全地區的平均降雨量，該怎麼作呢？我們可以使用MySQL的group by 來達到我們的目的。 輸入以下code:select date, avg(rainfall) rainfall from rainfall group by date; 上面的date代表我日期欄位的名稱，avg代表平均值，rainfall代表降雨量欄位的名稱，而在括號後面又出現一次rainfall代表顯示在取得的資料表上的欄位的名稱，最後一個rainfall則是我這個表格的名稱。由於我select的項目裡並沒有地區，而最後的group by 表示資料將以date下去做重新整理，如果有相同天數的欄位就會自動重整，並使用我前面下的avg平均化處理。 得出的結果如下圖：￼ 我們下次見。","link":"/zh-tw/useGroupByToOrganiseYourDatabase/"},{"title":"使用MySQL- group by 來整理資料庫 2","text":"哈囉大家好，我是Ray！ 今天想要跟大家分享group by 的更進一步的操作，如何使用group by 配合select 相對應的選項，新建一個表格，並在新表格內將資料重新整理爲我們需要的row and column。 首先，延續昨天的進度，如下圖所示，我們將降雨量根據天來做分類，那如果說今天我們需要月的降雨量，或者年雨量總和呢？￼ 請參考以下的code: &lt;?php// SELECT後面的year(date)以及month(date)表示SELECT這兩項資料，// 括號後的year以及month表示顯示出來的欄位名稱，sum表示加總括號內欄位資料的總和,// 括號內的rainfall爲欄位名稱，括號後的表示顯示出來的欄位名稱，一樣使用group by，// 使資料以月份以及年分來做顯示，order by 表示依照先後順序由先到後作排列。$selectQuery = &apos;SELECT year(date) year, month(date) month, sum(rainfall) rainfall from rainfall_by_date group by month(date), year(date) order by year(date) asc, month(date) asc;&apos;;// 向資料庫作select 請求$selectResult = mysqli_query($dbc, $selectQuery);// 使用迴圈來重複請求，直到拿出所有位於$selectResult物件中的所有arraywhile ($selectRow = mysqli_fetch_array($selectResult))&#123; // 將我們從rainfall_by_date取得的資料insert進新表格rainfall_by_month $insertQuery = &apos;INSERT INTO rainfall_by_month (year, month, rainfall) VALUES(&quot;&apos; . $selectRow[&apos;year&apos;] . &apos;&quot;, &quot;&apos; . $selectRow[&apos;month&apos;] . &apos;&quot;, &quot;&apos; . $selectRow[&apos;rainfall&apos;] . &apos;&quot;)&apos;; // 作insert請求 $insertResult = mysqli_query($dbc, $insertQuery);&#125; 執行以上的script之後，可以得到新的表格，如下：￼","link":"/zh-tw/useGroupByToOrganiseYourDatabasePart2/"},{"title":"<未完成> 使用地區性的永久磁碟部署 Apps 到 Kubernetes Engine","text":"概述本章節中, 我們將學習如何藉由使用 regional persistent disks (地區性永久磁碟) 在 Kubernetes Engine 部署 WordPress, 配置一個高可用的應用。 Regional persistent disks 提供的兩個 zones 之間的同步, 這確保了你的應用可以正常運行, 就算其中一個區域發生了故障或停電事故。 使用 regional persistent disks 來部署 Kubernetes Engine 叢集將會讓你的應用更穩定, 安全, 可信賴。 你將實作的內容 建立一個 regional Kubernetes Engine 叢集 建立一個 Kubernetes StorageClass 資源, 這個資源是針對複製的 zone 所配置 使用 StorageClass 的 regional disk 部署 WordPress 藉由刪除 node 來模擬區域性的故障 確認 WordPress app 以及資料成功的遷徙到另一個複製的 zone 進行此章節的建議具備知識這是 進階 課程, 在開始前, 至少有熟悉 Kubernetes 以及 WordPress 的基礎。 這邊有列出一些 Qwiklabs 可以讓你跟上進度: Kubernetes Engine: Qwik Start Running WordPress on App Engine Flexible Environment Hello Node Kubernetes 準備好了的話我們就往下吧！ 設定及要求在你按下 Start Lab 按鈕之前 詳讀所有的教學。 Labs 是有時間限制的, 而且你不可以停止時間倒數。 倒數計時器在你按下 Start Lab 按鈕後開始倒數, 上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境, 讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程, 而不是在一個模擬或是展示的環境。 我們透過提供你一個全新的、暫時的帳號密碼, 在計時器歸零之前, 你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab, 你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案,請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台, 然後開啟命令列工具 如何開始你的 lab, 然後登入 Console? 按下 Start Lab 按鈕。 如果你需要付費, 會有一個彈出視窗來讓你選擇付費的方式。 在左方你會看到一個面板, 上面有暫時的帳號密碼, 你必須使用這些帳號密碼在此次 lab 複製 username, 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗, 顯示選擇帳號的頁面 tip: 開啟一個全新的視窗,然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟, 貼上之前複製的 username 以及 password, 然後貼上 重要： 必須使用之前於 Connection Details 面板 取得的帳號密碼,不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號, 請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受 terms 以及 conditions 不要增加 recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候, GCP 控制台將會在這個視窗開啟。 注意： 按下左上方位於 Google Cloud Platform 隔壁的 Navigation menu, 你可以瀏覽選單, 裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。 它提供了5GB的 home 資料夾, 並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台, 右上的工具列,點擊 Open Cloud Shell 按鈕 在打開的對話框裡, 按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。 當你連結成功, 這代表你已成功獲得授權, 且此專案已被設為你的專案ID, 例如： gcloud 是 Google Cloud Platform 的 command-line 工具, 他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command, 你可以列出有效帳戶名稱:gcloud auth list 輸出:Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出:Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出：[core]project = &lt;project_ID&gt; 範例輸出：[core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 Regional Kubernetes Engine 叢集打開新的 Cloud Shell 視窗, 先建立 regional Kubernetes Engine 叢集, 它橫跨了位於 us-west1 的 3 個 zones 。 首先, 透過以下指令, 取得 us-west1 的 server 配置, 並將結果匯出到環境變數： 取得 server 配置CLUSTER_VERSION=$(gcloud container get-server-config --region us-west1 --format='value(validMasterVersions[0])')export CLOUDSDK_CONTAINER_USE_V1_API_CLIENT=false 現在建立一個標轉的 Kubernetes Engine 叢集 (會花一些時間, 請忽略認為有關 node auto repairs 的警告)gcloud container clusters create repd \\ --cluster-version=$&#123;CLUSTER_VERSION&#125; \\ --machine-type=n1-standard-4 \\ --region=us-west1 \\ --num-nodes=1 \\ --node-locations=us-west1-a,us-west1-b,us-west1-c 輸出:Creating cluster repd...done.Created [https://container.googleapis.com/v1beta1/projects/qwiklabs-gcp-e8f5f22705c770ab/zones/us-west1/clusters/repd].To inspect the contents of your cluster, go to: https://console.cloud.google.com/kubernetes/workload_/gcloud/us-west1/repd?project=qwiklabs-gcp-e8f5f22705c770abkubeconfig entry generated for repd.NAME LOCATION MASTER_VERSION MASTER_IP MACHINE_TYPE NODE_VERSION NUM_NODES STATUSrepd us-west1 1.12.6-gke.7 35.247.50.133 n1-standard-4 1.12.6-gke.7 3 RUNNING 我們剛建立了一個 regional 的叢集 (位於 us-west1), 並且在每個 zone 都個開 1 個 node (us-west1-a, us-west1-b, us-west1-c)從左邊選單到 Compute Engine 來檢視你的 instances: gcloud 指令同時也自動的設置了 kubectl 指令連接到叢集 使用 Regional Disk 部署 App現在你的 Kubernetes 叢集已經在運行中了, 你將做以下三件事： 安裝 Helm (管理 Kubernetes 套件的工具) 建立 Kubernetes StorageClass, 給 regional persistent disk 用的 部署 WordPress 安裝以及初始化 Helm, 以安裝 chart packagechart package 是由 Helm 所安裝的, 它含有運行 WordPress 所需的所有東西 執行以下指令安裝 Helm 到 Cloud Shell curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get &gt; get_helm.shchmod 700 get_helm.sh./get_helm.sh 初始化 Helm: kubectl create serviceaccount tiller --namespace kube-systemkubectl create clusterrolebinding tiller-cluster-rule \\ --clusterrole=cluster-admin \\ --serviceaccount=kube-system:tillerhelm init --service-account=tilleruntil (helm version --tiller-connection-timeout=1 &gt;/dev/null 2&gt;&amp;1); do echo \"Waiting for tiller install...\"; sleep 2; done &amp;&amp; echo \"Helm install complete\" 現在 Helm 已經安裝完畢 建立 StorageClass接下來你將建立 StorageClass, 被 chart 使用來定義 regional disk 的 zones。 列在 StorageClass 中的 zones 須符合 Kubernetes Engine 叢集的 zones 執行以下指令建立 StorageClass, 為 regional disk 所用：kubectl apply -f - &lt;&lt;EOFkind: StorageClassapiVersion: storage.k8s.io/v1metadata: name: repd-west1-a-b-cprovisioner: kubernetes.io/gce-pdparameters: type: pd-standard replication-type: regional-pd zones: us-west1-a, us-west1-b, us-west1-cEOF 輸出：storageclass &quot;repd-west1-a-b-c&quot; created Questions and Answers解釋以下的 command command: helm init --service-account=tilleruntil (helm version --tiller-connection-timeout=1 &gt;/dev/null 2&gt;&amp;1); do echo \"Waiting for tiller install...\"; sleep 2; done &amp;&amp; echo \"Helm install complete\" Answer: until: 如果 until 後的判斷為 true 的話, 就停止迴圈, 否則就一直執行 do 後的指令 do echo 字串, sleep 2 秒 done 當 until 的判斷為 true 時, 停止迴圈, 並 echo 字串 解釋以下的 gcloud command Command: kubectl create clusterrolebinding tiller-cluster-rule \\ --clusterrole=cluster-admin \\ --serviceaccount=kube-system:tiller Answer: 建立 clusterrolebinding, 名為 tiller-cluster-rule 要綁定的 clusterrole 為 cluster-admin, 為叢集中最高權限 要綁定的 service account 為 kube-system namespace 下面的 tiller 以下的 gcloud command 的意思是？ Command: kubectl create serviceaccount tiller --namespace kube-system Answer:建立 service account, 名為 tiller, 建立在 kube-system 這個 namespace 以下的 gcloud command 的意思是？ Command: CLUSTER_VERSION=$(gcloud container get-server-config --region us-west1 --format='value(validMasterVersions[0])')export CLOUDSDK_CONTAINER_USE_V1_API_CLIENT=false Answer: 取得 Kubernetes Engine 的 server config 地區為 us-west1 從格式可知, 目標是取得 version 不使用 V1 版本的 API 解釋以下的 gcloud command Command: gcloud container clusters create repd \\ --cluster-version=$&#123;CLUSTER_VERSION&#125; \\ --machine-type=n1-standard-4 \\ --region=us-west1 \\ --num-nodes=1 \\ --node-locations=us-west1-a,us-west1-b,us-west1-c Answer: 建立一個 cluster, 名為 repd 指定 cluster-version 指定 machine-type 為 n1-standard-4 指定 region 為 us-west1 node 的數量為 1 node 的 location 為 us-west1-a, us-west1-b, us-west1-c, 所以就是每個區域都會開一台 node, 雖然上面是說 node = 1, 但是總共會開 3 台","link":"/zh-tw/using-kubernetes-engine-to-deploy-apps-with-regional-persistent-disks/"},{"title":"在 PayPal 的 IPN 方式中，提交多個商品","text":"前言這篇文章將分享，當我們使用 PayPal 的 IPN 結帳方式時，如何提交多個商品，每個商品擁有各自的名稱，價格，以及數量。本文章是我從官網 複製下來的, 因為我不知道未來什麼時候會用到，而且我實在懶得再去找一次。 本文開始有些網站開發人員可能希望將PayPal付款處理集成到他們自己的第三方購物車上，而不是標準的PayPal購物車上。請使用以下說明為您的買家提供PayPal付款，以便他們在您的第三方購物車上添加購置物品後結賬時使用。 將您的第三方購物車與PayPal的付款流程集成目前有兩種方法。第一種方法是傳遞購物車付款總額，而不是單個物品金額。第二種方法是將所選物品詳情傳遞給PayPal，而不是總購物車數量。提示：按下述步驟粘貼必需的變量到PayPal時，可能需要在您的網站上執行某些腳本。 方法 1. 將總購物車數量傳遞給PayPal 方法 2. 將單個物品傳遞給PayPal 方法1. 將總購物車數量傳遞給PayPal如果願意，您可以累加整個購物車，將總數量傳遞給PayPal的立即購買按鈕代碼（也就是說，您需要粘貼整個購物車的單一名稱及其物品總價款，與購買單件物品一樣）。 該方法有一個不足之處，您的買家將無法查看其購物車中的單個物品。此外，您不能修改我們的變量名稱，也不能添加您自己的變量名稱。 查閱以下信息後如有其他技術問題，請訪問我們的 開發者服務網頁。欲知有關“立即購買”按鈕代碼或以下變量的附加信息，請查看網站付款標準版集成指南。 必需的變量向PayPal提交粘貼代碼時，應包括以下 4 個隱藏變量及一張圖片： 姓名 值 business 您的PayPal賬戶上的電子郵件地址 item_name 物品名稱（或購物車名稱） currency_code 定義幣種以標示貨幣變量（金額、運送費、運送費2、手續費、稅款）。值可以為”USD”、”EUR”、”GBP”、”CAD”、”JPY”。 amount 物品的價格（購物車中所有物品的總價格） image 按鈕圖片，您的買家按此按鈕開始PayPal付款程序。您可以將src 更換為圖片URL，以使用您自己的圖片 這就是說，您粘貼到PayPal的最短必需代碼應如下： &lt;form action=&quot;https://www.paypal.com/cgi-bin/webscr&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_xclick&quot;&gt; &lt;input type=&quot; hidden&quot; name=&quot;business&quot; value=&quot;you@youremail.com&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;item_name&quot; value=&quot;Item Name&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;currency_code&quot; value= &quot;USD&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;0.00&quot;&gt; &lt;input type=&quot;image&quot; src=&quot;http://www.paypal.com/zh_XC/i/btn/x- click-but01.gif&quot; name=&quot;submit&quot; alt=&quot;Make payments with PayPal - it&apos;s fast, free and secure!&quot;&gt; &lt;/form&gt; PayPal提供附加變量，用於自定義您的Form Post。所有可用變量如下（變量名稱必須用小寫）： 可用變量 姓名 值 business 您的PayPal賬戶上的電子郵件地址 quantity 物品數量。大於1 時，會與金額相乘 item_name 物品名稱（或購物車名稱）。必須是字母數字字符，最多為127 個字符 item_number 用於跟踪付款的可選傳遞變量。必須是字母數字字符，最多為127 個字符 amount 物品的價格（購物車中所有物品的總價格） shipping 該物品的運送成本 shipping2 每增加一件物品所需的運送成本 handling 手續費 tax 基於交易的稅額。如果使用該變量，傳遞值將覆蓋所有用戶信息稅收設置（不管買家所在位置）。 no_shipping 送貨地址。如果設為”1”，則不會要求您的客戶提供送貨地址。該變量為可選項；如果省略或設為”0”，將提示您的客戶輸入送貨地址 cn 可選標籤，會在提示欄上顯示（最多40 個字符） no_note 為付款加入提示。如果設為”1”，則不會提示您的客戶輸入提示。該變量為可選項；如果省略或設為”0”，將提示您的客戶輸入提示。 on0 第一選項欄名稱。最多64 個字符 os0 第一組選項值。最多200 個字符。”on0” 必須定義，以便識別”os0”。 on1 第二選項欄名稱。最多64 個字符 os1 第二組選項值。最多200 個字符。”on1” 必須定義，以便識別”os1”。 custom 決不會向您的客戶顯示的可選轉遞變量。可用於跟踪庫存 invoice 決不會向您的客戶顯示的可選轉遞變量。可用於跟踪賬單號 notify_url 僅與IPN 一起使用。發送IPN Form Post 的互聯網URL return 您的客戶完成付款後將返回的互聯網URL cancel_return 您的客戶取消付款後將返回的互聯網URL image_url 您要用作圖標的圖片的互聯網URL，圖片大小為150 X 50 像素 cs 設置您的付款頁面的背景色。如果設為”1”，背景色將為黑色。該變量為可選項；如果省略或設為”0”，背景色將為白色 擴展變量 PayPal允許您粘貼擴展變量，條件是將改變以下”cmd”值： &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_xclick&quot;&gt; 到： &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_ext-enter&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;redirect_cmd&quot; value=&quot;_xclick&quot;&gt; 通過上述”cmd” 值修改，您還可使用以下變量： 擴展變量 姓名 值 email 客戶的電子郵件地址 first_name 客戶的名。必須是字母數字字符，最多為32個字符 last_name 客戶的姓。必須是字母數字字符，最多為64個字符 address1 客戶地址所在國家或地區。必須是字母數字字符，最多為100個字符 address2 客戶地址第二行。必須是字母數字字符，最多為100 個字符 city 客戶地址所在城市。必須是字母數字字符，最多為100 個字符 state 客戶地址所在州。必須是正式的2 個字母縮寫 zip 客戶地址的郵政編碼 night_phone_a 客戶夜間聯繫電話號碼的區號 night_phone_b 客戶夜間聯繫電話號碼前三位 day_phone_a 客戶白天聯繫電話號碼的區號 day_phone_b 客戶白天聯繫電話號碼前三位 提示：若要更改“用戶信息”中的默認運費和手續費設置，請轉至您的用戶信息，編輯您的運費計算，然後點擊“允許採用基於交易的運費”複選框。 方法2. 將單個物品傳遞給PayPal如果您的第三方購物車可設置成向PayPal傳遞單個物品，有關物品的信息將加入買家和賣家的記錄日誌和系統通知中。要加入該物品的信息，您需要將HTML 格式元素粘貼至PayPal購物車流程的新版本。該過程與#1 節“將總購物車數量傳遞給PayPal”描述的非常相似，不同之處在於： 將”cmd”變量設置到”_cart”更換必要的HTML行 &lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_xclick&quot;&gt; 與&lt;input type=&quot;hidden&quot; name=&quot;cmd&quot; value=&quot;_cart&quot;&gt; 添加稱為”upload”的新變量 在&lt;表格&gt;和&lt;/表格&gt;標籤之間新增以下行： &lt;input type=&quot;hidden&quot; name=&quot;upload&quot; value=&quot;1&quot;&gt; 定義物品明細對於以下各特定物品參數，定義與通過您的合作商購物車購買的各物品對應的一組新值。將”_x”附加到變量名稱，其中x是物品號碼，從1開始，每加入一物品增加一。 姓名 值 item_name_x （物品#x 需要）購物車中物品#x 的名稱。必須是字母數字字符，最多為127 個字符 item_number_x 與購物車中物品#x 關聯的可選傳遞變量。必須是字母數字字符，最多為127 個字符 amount_x （物品#x 需要）物品#x 的價格 shipping_x 運送物品#x 的第一件（數量1）的成本 shipping2_x 每增加一件運送物品#x（數量2 或更多）所需的運送成本 handling_x 物品#x 的處理成本 on0_x 物品#x 的第一選項欄名稱。最多64 個字符 os0_x 物品#x 的第一組選項值。最多200 個字符。”on0_x” 必須定義，以便識別”os0_x”。 on1_x 物品#x 的第二選項欄名稱。最多64 個字符 os1_x 物品#x 的第二組選項值。最多200 個字符。”on1_x” 必須定義，以便識別”os1_x”。 為購物車中每件物品重複此設定為您的買家購物車中的各物品加入以上表格中的一組必需的變量和任何選項變量。購物車中的第一物品必須用以”_1”結束的參數定義，如”item_name_1”、”amount_1”等。同樣，第二物品應用變量”item_name_2”、”amount_2”等命名。提示：”_x”值必須以一為單位按序遞增，以便識別。如果從item #1跳到item #3而不定義item #2，則第三個物品會被忽略。要指定幣種：所有貨幣變量（金額、運費、運費2、手續費、稅款）將以粘貼在付款上的”currency_code”變量指定的幣種顯示。因為其不是隨物品不同的，無需向變量名稱附加”_x”。如果沒有粘貼”currency_code”變量，我們將假定所有貨幣變量值為美元。查閱以下信息後如有其他技術問題，請訪問我們的開發者支持網頁。欲知有關購物車代碼或以下變量的其他信息，請查看網站付款標準版集成指南。","link":"/zh-tw/submitMultipleItemsInPayPalIPNmethod/"},{"title":"使用 BigQuery 以及 Stackdriver 來分析 BigQuery 用量","text":"概述Stackdriver Logging 讓你可以在 Google Cloud Platform 的服務上，針對紀錄作儲存，分析，搜尋，監控，以及警告還有事件，包含 BigQuery 服務。Stackdriver 也提供匯出特定記錄到接收器的功能，例如 Cloud Pub/Sub, Cloud Storage, 或 BigQuery 在本教程中，你將在 Stackdriver 中檢視 BigQuery 的紀錄，設定接收器來匯出記錄到 BigQuery, 然後使用 SQL 來分析這些紀錄 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求 Qwiklabs setup在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Quiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Quiclabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 打開 BigQuery 打開 Big Query 主控台在 Google Cloud Console, 選擇 Navigation menu &gt; BigQuery Welcome to BigQuery in the Cloud Console 訊息視窗彈出。這個訊息視窗提供快速導覽的連結，以及一些更新訊息 點擊 Done BigQuery 主控台開啟 建立資料組 在 Resources 區塊中，點擊 qwiklabs-gcp- 開頭的資源 點擊 CREATE DATASET 設定 Dataset ID 到 bq_logs 點擊 Create dataset 執行一個查詢首先，執行一個簡單的查詢，在 Stackdriver 中產生一筆紀錄。 之後，你將使用這個紀錄來簡單設置匯出功能，從 Stackdriver 到 BigQuery 複製底下代碼，然後在 BigQuery 的查詢編輯器中貼上 SELECT current_date 點擊 Run 設定從 Stackdriver 匯出紀錄在 Stackdriver 檢視紀錄 在 Google Cloud Console 選擇 Navigation menu &gt; Logging &gt; Logs Viewer 在第一個下拉視窗的搜索框中，選擇 BigQuery 應會看到幾筆紀錄出現 尋找含有 “jobcompleted” 字串的紀錄 點擊位於左方，下圖中的三角箭頭來打開數據，然後在右手邊點擊 Expand all 這將以 JSON 格式來顯示數據，往下滑看看不一樣的欄位 回到剛剛的開頭處，點擊 ‘jobcompleted’ 然後選擇 Show Matching Entries 這將會完成正確的搜尋設定 建立匯出現在你有需要的紀錄了，很簡單的就可以設定匯出 在搜尋框上方，點擊 Create Export 在右手邊，依照下面給的資訊輸入 (1) Sink name: JobComplete (2) Sink Service: BigQuery (3) Sink Destination: bq_logs (我們之前設定的資料組) 點擊 Create Sink 點擊 CLOSE 之後任何的紀錄都會被匯出到這一個 bq_logs 資料組 執行範例查詢為了讓新的表格載入入一些紀錄，我們需要執行一些範例的查詢 移動到 Cloud Shell , 複製下面的代碼，然後貼到 Cloud Shell 上 bq query --location=us --use_legacy_sql=false --use_cache=false 'SELECT fullName, AVG(CL.numberOfYears) avgyearsFROM `bigquery-samples.nested.persons_living`, UNNEST(citiesLived) as CLGROUP BY fullname' bq query --location=us --use_legacy_sql=false --use_cache=false 'select month, avg(mean_temp) as avgtempfrom `bigquery-samples.weather_geo.gsod`where station_number = 947680and year = 2010group by monthorder by month' bq query --location=us --use_legacy_sql=false --use_cache=false 'select CONCAT(departure_airport, \"-\", arrival_airport) as route, count(*) as numberflightsfrom `bigquery-samples.airline_ontime_data.airline_id_codes` ac,`bigquery-samples.airline_ontime_data.flights` flwhere ac.code = fl.airline_codeand regexp_contains(ac.airline , r\"Alaska\")group by 1order by 2 descLIMIT 10' 你將會看到每筆查詢回應的結果 在 BigQuery 中檢視紀錄 移動到 BigQuery (Navigation menu &gt; BigQuery) 展開 qwiklabs-gcp- 開頭的資源，並且檢查 bq_logs 資料組 你應該可以看到一個表格 名字可能會跟下面的不太一樣，但看起來應該差不多“cloudaudit_googleapis_com_data_access_2019-06-19” 檢查表格的結構，然後注意到它有很大數量的欄位 如果你試著預覽，並且想知道為什麼它沒有顯示出你最近查詢的紀錄，那是因為紀錄是被串流到表格，這顯示新的資料可以被查詢但不會立即顯示在預覽 為了提高表格可用性，你可以建立 VIEW, 它可以取出子欄位的資料，然後執行一些計算來獲得查詢時間的指標 在 BigQuery 的查詢編輯器，將 替換成你的 project name (在 Qwiklab 視窗左手邊可以很簡單的複製) 後，執行以下的 SQL CREATE OR REPLACE VIEW bq_logs.v_querylogs ASSELECT resource.labels.project_id, protopayload_auditlog.authenticationInfo.principalEmail, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobConfiguration.query.query, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobConfiguration.query.statementType, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatus.error.message, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.startTime, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.endTime, TIMESTAMP_DIFF(protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.endTime, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.startTime, MILLISECOND)/1000 AS run_seconds, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.totalProcessedBytes, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.totalSlotMs, ARRAY(SELECT as STRUCT datasetid, tableId FROM UNNEST(protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.referencedTables)) as tables_ref, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.totalTablesProcessed, protopayload_auditlog.servicedata_v1_bigquery.jobCompletedEvent.job.jobStatistics.queryOutputRowCount, severityFROM `&lt;YOUR-PROJECT-ID&gt;.bq_logs.cloudaudit_googleapis_com_data_access_*`ORDER BY startTime 現在可以查詢 VIEW, 執行以下指令 SELECT * FROM bq_logs.v_querylogs 檢視結果檢視你之前執行的三筆查詢，跟下圖類似 恭喜你已經完成本教程","link":"/zh-tw/usingBigQueryAndStackdriverToAnalyzeBigQuerryUsage/"},{"title":"為什麼要使用 VIM?","text":"哈囉大家好，我是Ray! 今天要來跟大家分享一款非常實用且歷史悠久的編輯器，它叫做Vim! 關於歷史來源背景，我這邊就不贅述了，在麻煩有興趣的讀者自行Google! Vim除了是一款專門爲coding而設計的編輯器之外，幾乎在所有有名的IDE，或者是Editor上，都可以找到Vim的插件，比如我所使用的PHPstorm，或者Subline。 在我們深入Vim之間，我們先來說說，爲什麼我們要使用Vim? 我個人在選擇成爲一名工程師之前，就已經使用標準指法，就是利用F以及J上的凸點來做定位而達到盲打，盲打就是蒙着眼睛也可以準確的打字哦！ 在開始寫程式之後，我最大的困擾並不是程式的語法或邏輯，而是我的手必須頻繁的在滑鼠、方向鍵、以及主鍵區之間作切換。 在我還未邂逅Vim之前，我一直在尋找可以自定義按鍵的鍵盤，因為我認為最理想的打字模式，就是我的手掌並不需要離開主鍵區而可以完成所有的操作。 理論上來說，如果兩個工程師有著同樣的經驗與邏輯，以及技術，打字速度較快的那個人肯定有著較高的輸出，意味著可以更快的完成任務。 如果你問我，那我沒事做那麼快做什麼？ 各位大大，時間就是金錢啊！！ 越快完成表示省下越多的時間，代表你可以運用的時間將越多！ 對於技術狂熱者，啊不對，是對技術有較高熱情的人來說，像是我，更多的時間表示可以學習更多的技術。 時間可以用來做非常多的事，說是比比特幣還珍貴也不為過！ 你可以用來陪家人、追劇、陪女朋友，阿～前提是你要先有女朋友，像我就沒有QQ。 Vim的最基本也最實用的功能，就是可以使用h, j, k, l四個鍵來當成上下左右，換言之，他已經解決我們最大的問題-需要在方向鍵區與主鍵區頻繁的移動。 Vim的功能區分為普通模式、輸入模式，以及選取模式，簡單來說，就是移動游標時會在普通模式，而輸入代碼時會在輸入模式，最後，當我們選取一整行要做複製或貼上甚至更複雜的動作時，會在選取模式。 看完以上的剖析，有沒有被Vim吸引到的感覺呢？ 今天的分享就到這裡，我們明天見！","link":"/zh-tw/whyWouldWeUseVIM/"},{"title":"Git log 裡面的東西是什麼？","text":"大家好，我是Ray! 今天想跟大家分享，git log 裡面的一些細節。 首先，我們先來看看下面的圖片： 我們可以看到，每一個commit後面都有一段非常長的隨機字串，那這是什麼呢？ 這是一串git 根據commit的內容，由SHA1生成的隨機驗證字串，也許你會問，什麼是SHA1? SHA1全名為security hash algorithm, 中文意思大概就是“安全加密演算法”。 諸如此類的演算法有好幾種，SHA系列的演算法是不可逆的，簡單來說，如果你拿到一串加密過的字串，就像上面那些驗證字串，你是沒有辦法透過將它逆轉回加密前的樣子。 有興趣的朋友可以google一下，這邊我們就不針對SHA多做討論！ 接下來介紹一個非常實用的指令，git log --oneline! 輸入git log --online 可以對照下圖，這是git log 與 git log --oneline的差別。 由上圖大家可以看到，git --oneline 拿掉了作者，日期相關資訊，並且只保留驗證字串的七碼！ 那我們之前提到的git checkout也可以使用這七碼來作切換嗎？ 輸入git checkout out cc92d2f (請輸入你電腦上的驗證字串，你的跟我的不一樣） 如上圖，我們已經成功的切換到前一個commit 輸入 git checkout master 輸入 git log --oneline 這樣就又切回來了！ 看完今天的文章，是不是對於git 有更深一層的理解了呢？ 我們明天見！","link":"/zh-tw/whatIsInGitLog/"},{"title":"使用 Google Stackdriver 來除錯, 追蹤, 紀錄 以及部署紀錄點","text":"概述這個教程將帶你好好走一趟 Google Stackdriver, 你將學到如何在你 Google Cloud Platform 的應用作以下的操作： 為運行在 App Engine, Compute Engine, Container Engine 的應用製作 Debug Snapshot(Debug 快照) 無需部署額外的 app 即可在 運行中的應用加入 log point (紀錄點)。 這是一個真正獨特的功能(且希望是有幫助的)。 追蹤 API calls並且獲取回應時間統計以及代碼內的潛在的瓶頸 檢視Application Logs (應用紀錄) 你將會從 0 開始做下面這些事: 建立一個 Google Cloud Platform 專案 (特別是 App Engine) 設定 Google Cloud platform 專案源碼倉庫 利用 Github 上可獲得的標準的 Guestbook Python Application 源碼 部署代碼 看如何在運行中的應用上獲得 Debug 快照 瞧瞧 Logging (紀錄) 以及 Application Call Traces (應用呼叫追蹤) 在目前運行的應用上加入 logpoints (紀錄點) 前言本篇主要是利用 Google 的 Qwiklab 平台學習的同時，做的一份學習筆記為避免翻譯誤解，專業術語在本篇將不會被翻譯，保留原文 設定及要求 在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 建立 Stackdriver workspace (工作區)在 Navigation menu, 點擊 Monitoring 當你看到 Stackdriver dashboard (顯示面版)，代表你的工作區已經準備好了 測試進度點擊 Check my progress 來確認目前的進度。 設定並且加載你的私人 Git 倉庫每一個 Google Cloud Platform 都有提供私人的 Git 服務器，但首先你需要先建立一個預設的倉庫 回到主控台，並且到 Navigation menu &gt; Source Repositories &gt; Add Repository: 選擇 Create new repository, 然後選擇 Continue 將新的 repository 命名為 “DEFAULT”, 然後點擊 Create 測試完成任務 點擊 Check my progress 來確認目前的進度。 在 Cloud Shell, 利用以下的指令建立一個資料夾並且進入到這個資料夾內： mkdir stackdriver-demo cd stackdriver-demo/ 現在複製 DEFAULT repository gcloud source repos clone DEFAULT 你應該會看到輸出如下： Cloning into &apos;/home/gcp123_student/default&apos;...warning: You appear to have cloned an empty repository.Project [qwiklabs-gcp-1234abc1234] repository [default] was cloned to [/home/gcp123_student/default]. 對的，你沒有看錯，你複製了一個空的 repository - 沒錯。 現在花點時間來研究一下這已經設定好的 git remote, 然後你將會更了解背地裡發生了什麼事。 進到 DEFAULT 資料夾: cd DEFAULT 輸入 git remote -v 指令 git remote -v 你會看到類似以下輸出：origin https://source.developers.google.com/p/qwiklabs-gcp-1234abc1234/r/default (fetch)origin https://source.developers.google.com/p/qwiklabs-gcp-1234abc1234/r/default (push) 這指向了與你的 GCP 專案相關的 Git Repository 從 Github 上 Pull Guestbook 應用Guestbook 應用是可從官方 Google Cloud Platform 的 Github repository 上獲得的標準 App Engine 應用。 這個應用也是在 App Engine 上部署 Python 應用程式的官方文件一部分。 Github 專案可從此獲得：https://github.com/GoogleCloudPlatform/appengine-guestbook-python 運行以下指令來 Pull Guestbook 代碼到你的 Cloud Shell 實例git pull https://github.com/GoogleCloudPlatform/appengine-guestbook-python 輸出應該如下： remote: Enumerating objects: 493, done.remote: Total 493 (delta 0), reused 0 (delta 0), pack-reused 493Receiving objects: 100% (493/493), 437.58 KiB | 0 bytes/s, done.Resolving deltas: 100% (203/203), done.From https://github.com/GoogleCloudPlatform/appengine-guestbook-python * branch HEAD -&gt; FETCH_HEAD 現在你可以看到很多檔案都從 Github 專案 pull 下來了 利用 Cloud Shell 將目前的代碼 push 到 GCP 專案的 Git Repository利用 Cloud Shell 來將代碼 push 到 GCP 專案 Git repository, 所以你可以在你的代碼設定斷點。 但是我們並不一定要這麼做，因為我們還有其他的方法來連結源碼，像是直接與 Github 或從本地機器做整合 利用標準 git push 指令來 push 代碼 git push origin master 輸出應會如下：Counting objects: 485, done.Compressing objects: 100% (280/280), done.Writing objects: 100% (485/485), 436.42 KiB | 0 bytes/s, done.Total 485 (delta 195), reused 485 (delta 195)remote: Storing objects: 100% (485/485), done.remote: Processing commits: 100% (152/152), done.To https://source.developers.google.com/p/qwiklabs-gcp-1234abc1234/r/default* [new branch] master -&gt; master 現在，回到 GCP Cloud 主控台並重整頁面。 在 Source Repository, 點擊 Source Code, 你應該可以在 DEFAULT repository 中看到所有的專案檔案 部署並且使用 Guestbook 應用你已經完成部署前的工作，輸入 gcloud app deploy 指令來部署 Guestbook App Engine 應用gcloud app deploy --version 1 當被要求選擇一個 region, 選擇 us-east1 當跳出詢問視窗，選擇 “Y” 繼續 輸出應會如下 You are about to deploy the following services:— qwiklabs-gcp-1234abc1234/default/1 (from [/home/gcp123-student/default/app.yaml])Deployed URL: [https://qwiklabs-gcp-1234abc1234.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...File upload done.Updating service [default]...done.Deployed service [default] to https://qwiklabs-gcp-1234abc1234.appspot.com] 注意到我們提供了一個版本參數給 app deploy 的指令。 我們給了數值 &quot;1&quot; 測試進度 點擊 Check my progress 來確認目前的進度。 因為 Guestbook 應用使用 Google Cloud Datastore 來儲存，所以我們必須更新 Datastore 索引。 這個索引被指定在 index.yaml 檔案中 使用 gcloud datastore indexes create 指令:gcloud datastore indexes create index.yaml 控制台輸出應如下： Configurations to update:descriptor: [index.yaml]type: [datastore indexes]target project: [qwiklabs-gcp-39b46efbe8fc73bf]Do you want to continue (Y/n)? Y 詢問視窗中，輸入 Y 繼續 Datatore 的索引會耗費一些時間更新。 若要確認狀態，可到主控台中的 Navigation menu &gt; Datastore ，然後在左側面板點擊 Indexes 。 當索引正在被建立中時，你會看到狀態顯示為 “Indexing”: 測試進度點擊 Check my progress 來確認目前的進度。 你可以確認你的 App (version 1) 是否有部署成功且可用。 到 Navigation menu &gt; App Engine &gt; Versions: 現在應該一切都看起來 okay。 到 https://PROJECT_ID.appspot.com 看一下你的專案。 將 PROJECT_ID 替換成 Qwiklab 給的 ID 注意： 如果你看到 Internal Server Error, 一分鐘後再試一次，索引可能還在被建立中。 現在從 Guestbook 視窗，使用應用來建立一些數據 棒極了！ 現在你已經完成所有進到 Stackdriver 功能之前的準備工作 測試進度 點擊 Check my progress 來確認目前的進度。 Debug Snapshot (Debug 快照)當你想要 debug 一段特定的 code 時，或者你想要檢查一些變數，但你的應用還處於服務中，這時候快照將非常的有用。現在，當有任何人對你的首頁發請求，並且取得目前在 Datastore 中的問候清單時，你將要求一個快照。這段代碼位於 questbook.py 檔案。 並且，我們將開始在服務中檢查代表，當問候清單從 Datastore 被取得時。 這段代碼在 72 行結束，所以我們在 74 行設一個斷點，這樣我們能確定 72 行將會被執行。我們可以在主控台中使用 App Engine 檢視並且點擊 Tools 下拉選單，然後點擊 Debug 或者在 Stackdriver 瀏覽視窗，在左方面板點擊 Debug在左側面板點擊 guestbook.py, 然後點擊 74 行如下所示 訊息顯示，目前正在等待一個快照被觸發 現在，回到 Guestbook 視窗然後新增一筆數據。 回到 Debug 頁面，快照已被啟動，且 Variables 以及 Call Stack 區塊都被載入了。 你可以展開變數確認各自的值。 比方說，如果你展開 greetings 變數，你將會看到有一些記錄，且這些紀錄與我們之前建立 guestbook 數據的號碼相對應著。 有一個非常方便的功能，那就是我們可以隨時重新做一個快照。點擊照相機的圖示： 快照將會等待被觸發 你也可以使用 Expressions 欄位來追蹤特定的變數。 比方說，當快照被觸發時，我們要檢查一個變數在那一刻的值，我們可以在 Expressions 欄位內輸入變數的名稱 在 Expressions 欄位新增 “greetings”, 然後回到 Guestbook 視窗增加一個新的數據。 當快照被觸發時， greeting 的值將會被載入 如果你想要快照只在滿足特定條件時才被觸發的話，可以使用 Condition 欄位。 下方有個範例，意思是說當 greeting 的數量大於 1 時，快照才會被觸發。 你可以試試看！ 備註： 完整的 Stackdriver Debugger 文件在這:https://cloud.google.com/debugger/docs/ Logpoints (紀錄點)這肯定是一個會讓你興奮到不行的功能。 身為一個開發者，通常我們會盡其所能地在我們的代碼中安置回傳訊息, 像是 php 的 echo 或是 node.js 的 console.log，並希望這些訊息能傳達給我們一切我們想知道的。 但我們都知道，當我們在 debug 的時候，這些訊息永遠都不夠，我們總是需要再安插多一點的回傳訊息。 一般做法，我們需要重新修改我們的代碼，安置額外的回傳訊息，最後重新部署以及監控。 如果說，你可以在運行中的應用增加這些回傳訊息 (稱為紀錄點 logpoints) 呢？ 你不再需要停止應用，修改代碼，重新部署這些步驟了！ 你可以使用 logpoints support，從應用外來管理一系列的紀錄點。 在 Cloud Shell 中，執行以下的指令來檢視目前已經設置好的紀錄點清單 cloudgcloud debug logpoints list 輸出應該是 0 Debug target not specified. Using default target: default-1Listed 0 items. 要增加紀錄點，你需要做以下這些事 確認你想要增加紀錄點的檔案以及確切位置的行數 確認紀錄點的訊息。 這個紀錄點訊息可以是寫死的，也可以是一個表達式。 在本教程中，增加一個紀錄點到檔案 guestbook.py 的第 74 行，使用 logpoints create 指令: gcloud beta debug logpoints create guestbook.py:74 \"Fetched greetings from Datastore. Count of greetings : &#123;len(greetings)&#125;\" 你可以看到 檔案名稱:行號, 以及紀錄點訊息。 紀錄點訊息也包含了表達式，它會印出從 Datastore 取回的 greetings 數量。 指令回傳訊息顯示紀錄點已經被加進去了： Debug target not specified. Using default target: default-1— id: 53538243519d4-f9a0-bdbcelocation: guestbook.py:74logLevel: INFOlogMessageFormat: Fetched greetings from Datastore. Count of greetings : &#123;len(greetings)&#125;condition: Nonestatus: ACTIVE 現在，如果你執行 logpoints list 指令：cloudgcloud debug logpoints list 你將會看到以下輸出：Debug target not specified. Using default target: default-1STATUS LOCATION CONDITION LOG_LEVEL LOG_MESSAGE_FORMAT IDACTIVEguestbook.py:74 INFO Fetched greetings from Datastore. Count of greetings : &#123;len(greetings)&#125; 53538243519d4-f9a0-bdbce 要看確切的運作，到首頁 https://&lt;PROJECT_ID&gt;.appspot.com 。 這將會觸發代碼，並且觸發紀錄點。 記住，紀錄點訊息會被記錄在預設的 Application Logs。 到 Stackdriver 視窗，並點擊 Logging: 點擊一個特定的請求，瞧！ 在 details 中，你將會看到紀錄點被觸發以及紀錄點訊息被顯示出來。 Traces (追蹤)總是確保你的網頁應用的表現有達到你設定的需求，這件事是很重要的。 Stackdriver Traces 是一個關鍵的工具，它可以讓你了解你應用的延遲。 Traces 在 App Engine 預設就是打開的，它提供了觸手可及的應用表現的細節，包含了所有端點以及不同請求的整體資料。 你已經試過了拜訪首頁 (“/“) 以及檢視 / 增加 guestbook 數據。 這些已經足夠 Traces 提供更多有關延遲的資訊。 在主控台頁面，到 Navigation menu &gt; Trace 來檢視最近的 Stackdriver 追蹤紀錄以及延遲。 點擊任何一筆追蹤來檢視追蹤細節: 你獲得了延遲的資訊，以及哪些要求耗費了更多的時間。 你可以從圖形化介面看到資料庫的請求正在耗費著時間。 或許其中一個可以列入考慮的選項可以是快取資料來降低瓶頸點。 這些資料都來自於你的應用，且如果要找出哪些地方可能需要一些重構的話，這些資訊應該是十分地用幫助。 備註： 完整的 Stackdriver Debugger 文件在這:https://cloud.google.com/debugger/docs/ 搜尋紀錄在你遇到服務中斷之前，花時間學習如何使用你的紀錄將會拯救你免於很多的壓力，且會幫你更快的準確找出問題。 在你自己的專案中，你應該是要固定的使用這些功能，所以當你需要它的時候，你將會知道如何使用它。 讓我們來一起走過一些 Stackdriver Logs 的進階功能。 到 Navigation menu &gt; &gt; Logging __ 。 點擊篩選框右手邊的三角形圖案，然後選取 “Convert to advanced filter” 現在你可以使用一個特別的語法 來明確你想要檢視的特定紀錄 例如說, 這個語法限制了你將只能看到 GAE 的紀錄訊息 cloudresource.type=&quot;gae_app&quot; 若要增加更多的語句到篩選器，你可以加更多行 你也可以使用運算子像是 AND, OR, NOT, &gt;, &lt;, 等等。 這是一個只顯示 ERROR 以及 CRITICAL 訊息的篩選表達語句 cloudseverity=(&quot;ERROR&quot; OR &quot;CRITICAL&quot;) Stackdriver 將 Severity 與數字香連續，所以你也可以使用數字比較，像是：cloudresource.type = gae_app ANDseverity &gt;= ERROR 使用者介面將會自動補齊，包含欄位名稱以及可能的欄位的值 已存在的紀錄篩選有一個簡單的方法可以找到一個正確的，我們想要填入進階篩選器中的數值。 試試看： 檢視你的紀錄直到你找到你想要鎖定的訊息類型。 然後點擊欄位，然後點擊 “Show Matching Entries”。 這將會自動地將正確的數值載入篩選器中。 你也可以使用 “Hide Matching Entries” 來移除會干擾你的訊息 儲存及分享一旦你已經花時間找出正確的篩選器數值，你應該會想要將它們儲存並且分享給你的隊友們。 點擊篩選器右方的三角形圖案，你將可以獲得這個你剛剛建立的篩選器的連結。 你可以跟你的隊友們分享這個連結，或是將它存在你的文件當中。 備註： 完整的 Stackdriver Debugger 文件在這:https://cloud.google.com/debugger/docs/ 測試你的理解下面有多重選擇的問題來鞏固你對本教程概念的理解，盡你所能的回答吧： 恭喜你已經完成本教程","link":"/zh-tw/usingGoogleStackdriverDebugTracesLoggingAndLogpoints/"},{"title":"為什麼我們要使用Git?","text":"大家好我是Ray! 今天要跟大家分享，為什麼要使用Git? 首先，你有沒有遇過，coding到一半忽然有急事要做（可能是你媽叫你，也可能是你忘記去接你女朋友） 然而很不巧的，當時你可能正在debug，又或者在開發一個新功能。 當你終於有空回去繼續coding時，靠！怎麼出錯啦～？ 滿滿的程式碼滿滿的邏輯不知道從何找起從何debug起～ 又或者，有時在開發新功能時，新功能不巧地影響到現有的功能，導致現有的功能也無法使用！ 當我們陷入一個無頭緒的狀態時，我們就想要回到還沒開始新功能的那一刻，很不巧的，我們早就已經養成定時存檔的良好習慣… 這些時候，就是Git出場的時候啦！ 當你在一些關鍵的時刻，又或者已經完成一個功能，而打算從這個功能為一個起點，開始一個新功能，這個時候你可以使用Git把它存檔起來，存檔後，你可以隨時回到你存擋的那一刻，這種回朔是跟你檔案本身存擋沒有關聯的，換句話說，就算你已經在編輯器或者是IDE上面存擋了，你也可以隨時地回到你使用Git設的存擋點！ 另外一個情況，除非你做的是一個人可以完成的小專案，否則只要是多人協作的專案都需要多人合作與配合，有沒有想過，當這麼多人來一起做一個案子甚至一個檔案，該如何有效地整合呢？畢竟coding是非常細緻的工作，就算你只錯了一個字也可以會造成整個功能無法使用啊！ 這個時候通常我們都會使用Git來整合，試想你的電腦上是一個你自己擁有的資料夾，當你在你的電腦上把你的部分完成之後，你把完成的部分上傳到一個公共的資料夾，而團隊內的其他成員也是用這種方式來上傳他們的部分，此時Git可以讓我們記錄所有人的部分並且將所有人的code合併已達到整合！ 所以對於一個coder來說，Git似乎是不可或缺的呢！","link":"/zh-tw/whyGitIsSoMuchRequired/"},{"title":"<未完成>利用 Stackdriver APM 來增進網站可靠性以及排除錯誤","text":"概述此教程的目標是讓你熟悉 Stackdriver 的一些特定的功能, 它讓可以監控 GKE 叢集基礎設施, Istio, 以及部署在這些基礎設施上的應用 你將會做什麼？ 建立一個 GKE 叢集 部署微服務應用到這個叢集上 為這個應用定義延遲 (latency) 以及錯誤 SLIs (Service Level Indicator), 以及 SLOs (Service Level Objective) 設置 Stackdriver 來監控你的 SLIs 部署一個致命的錯誤到你的應用, 然後使用 Stackdriver 來分析以及解決問題 驗證你的解法是否有處理掉 SLO 的違反 你將會學到？ 如何部署微服務到一個已經存在的 GKE 叢集 如何為一個應用選擇適當的 SLIs/SLOs 如何使用 Stackdriver Monitoring features 來實作 SLIs 如何使用 Stackdriver Trace, Profiler, 以及 Debugger 來發現程式的問題 先決條件 Google Cloud Platform 帳戶以及啟用 billing 帳戶的專案 Kubernetes 基礎知識 Stackdriver Monitoring 基礎知識 錯誤分析排除的基礎知識 環境設定在你按下 Start Lab 按鈕之前 詳讀所有的教學。Labs 是有時間限制的，而且你不可以停止時間倒數。倒數計時器在你按下 Start Lab 按鈕後開始倒數，上面顯示的時間為你還能使用 Cloud 資源的時間。 Qwiklabs 的手把手環境，讓你可以在真實環境中來操作進行 Qwiklabs 上提供的課程，而不是在一個模擬或是展示的環境。我們透過提供你一個全新的、暫時的帳號密碼，在計時器歸零之前，你可以用來登入並存取 Google Cloud Platform。 你需要什麼？ 要完成這個 lab ，你需要: 一個一般的網路瀏覽器（推薦 Chrome） 完成這個 lab 的時間 備註： 如果你已經有你自己的個人 GCP 帳號或專案，請不要使用在這一個 lab 現在你已經開始你的 lab, 你將會登入 Google Cloud Shell 主控台，然後開啟命令列工具 如何開始你的 lab ，然後登入 Console? 按下 Start Lab 按鈕。如果你需要付費，會有一個彈出視窗來讓你選擇付費的方式。在左方你會看到一個面板，上面有暫時的帳號密碼，你必須使用這些帳號密碼在此次 lab 複製 username , 然後點擊 Open Google Console。 Lab 會開啟另外一個視窗，顯示選擇帳號的頁面 tip: 開啟一個全新的視窗，然後跟原本的頁面並排 在選擇帳號頁面, 點擊 Use Another Account 登入頁面開啟，貼上之前複製的 username 以及 password ，然後貼上 重要：必須使用之前於 Connection Details 面板 取得的帳號密碼，不要使用你自己的 Qwiklabs 帳號密碼。 如果你有自己的 GCP 帳號，請不要用在這裡（避免產生費用） 點擊並通過接下來的頁面: 接受terms以及conditions 不要增加recovery optoins 或 two factor authentication (因為這只是一個臨時帳號) 不要註冊免費體驗 稍待一些時候， GCP 控制台將會在這個視窗開啟。 注意：按下左上方位於Google Cloud Platform 隔壁的 Navigation menu ，你可以瀏覽選單，裡面有一系列的 GCP 產品以及服務 啟動 Google Cloud ShellGoogle Cloud Shell 是載有開發工具的虛擬機器。它提供了5GB的 home 資料夾，並且運行在 Google Cloud 上。 Google Cloud Shell 讓你可以利用 command-line 存取 GCP 資源 在 GCP 控制台 ，右上的工具列，點擊 Open Cloud Shell 按鈕 在打開的對話框裡，按下 START CLOUD SHELL: 你可以立即按下 START CLOUD SHELL 當對話視窗打開。 連結並提供環境會需要一點時間。當你連結成功，這代表你已成功獲得授權，且此專案已被設為你的專案ID，例如： gcloud 是 Google Cloud Platform 的 command-line 工具，他已事先被安裝在 Cloud Shell 並且支援自動補齊 使用這個 command ,你可以列出有效帳戶名稱: gcloud auth list 輸出: Credentialed accounts: - &lt;myaccount&gt;@&lt;mydomain&gt;.com (active) 範例輸出: Credentialed accounts: - google1623327_student@qwiklabs.net 你可以使用以下 command 來列出專案 ID gcloud config list project 輸出： [core]project = &lt;project_ID&gt; 範例輸出： [core]project = qwiklabs-gcp-44776a13dea667a6 gcloud 的完整文件可以參閱 Google Cloud gcloud Overview 基礎設施配置在本教程中, 你將會連接到 Google Kubernetes Engine 叢集然後驗證它有被正確的建立在 gcloud 中設定 zone:gcloud config set compute/zone us-west1-b 設定 project ID:export PROJECT_ID=$(gcloud info --format='value(config.project)') 確認叢集 shop-cluster 已經被建立了gcloud container clusters list 如果你的叢集狀態顯示 PROVISIONING, 稍待一些時候, 並再次執行上面的指令, 直到狀態為 RUNNING 當你等待的時候, 設定你的 Stackdriver 工作區來監控你叢集中的應用。 建立 Stackdriver 工作區在 Navigation menu, 點擊 Monitoring當你可以看到 Stackdriver 的主控台, 這代表工作區已準備就緒。回到 Cloud Shell 再次確認叢集是否已準備完成：gcloud container clusters list 一旦你看到叢集狀態顯示為 RUNNING, 取得叢集憑證gcloud container clusters get-credentials shop-clusters --zone us-west1-b (輸出)Fetching cluster endpoint and auth data.kubeconfig entry generated for shop-cluster. 確認 nodes 已被建立kubectl get nodes 輸出應如下：NAME STATUS ROLES AGE VERSIONgke-shop-cluster-demo-default-pool1-24748028-3nwh Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-3z1g Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-4ksd Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-f2f2 Ready &lt;none&gt; 4m v1.13.7-gke.8gke-shop-cluster-demo-default-pool1-24748028-gcb3 Ready &lt;none&gt; 4m v1.13.7-gke.8 部署應用在本教程中, 你將部署一個名為 Hipster Shop 的微服務到叢集中以建立一個可被監控的工作範例 執行以下指令來複製代碼:git clone -b APM-Troubleshooting-Demo-2 https://github.com/blipzimmerman/microservices-demo-1 下載並安裝 skaffoldcurl -Lo skaffold https://storage.googleapis.com/skaffold/releases/v0.36.0/skaffold-linux-amd64 &amp;&amp; chmod +x skaffold &amp;&amp; sudo mv skaffold /usr/local/bin 使用 skaffold 安裝應用cd microservices-demo-1skaffold run 確認一切都正確運行著：kubectl get pods 輸出應類似如下：NAME READY STATUS RESTARTS AGEadservice-55f94cfd9c-4lvml 1/1 Running 0 20mcartservice-6f4946f9b8-6wtff 1/1 Running 2 20mcheckoutservice-5688779d8c-l6crl 1/1 Running 0 20mcurrencyservice-665d6f4569-b4sbm 1/1 Running 0 20memailservice-684c89bcb8-h48sq 1/1 Running 0 20mfrontend-67c8475b7d-vktsn 1/1 Running 0 20mloadgenerator-6d646566db-p422w 1/1 Running 0 20mpaymentservice-858d89d64c-hmpkg 1/1 Running 0 20mproductcatalogservice-bcd85cb5-d6xp4 1/1 Running 0 20mrecommendationservice-685d7d6cd9-pxd9g 1/1 Running 0 20mredis-cart-9b864d47f-c9xc6 1/1 Running 0 20mshippingservice-5948f9fb5c-vndcp 1/1 Running 0 20m 在進到下一步之前, 重複執行指令直到所有的 pods 都顯示 RUNNING取得應用的 external IP:export EXTERNAL_IP=$(kubectl get service frontend-external | awk 'BEGIN &#123; cnt=0; &#125; &#123; cnt+=1; if (cnt &gt; 1) print $4; &#125;') 最後, 確認應用已啟動且運行:curl -o /dev/null -s -w \"%&#123;http_code&#125;\\n\" http://$EXTERNAL_IP 注意: 如果回應是 500 錯誤, 你可能需要再次執行指令確認回應應如下:200 下載原始碼就將程式碼置於 Cloud Source Repo:./setup_csr.sh 現在你的應用已經部署完畢, 接下來我們設定應用的監控。 資源 Microservices Demo Application注意: 本教程使用此應用的一個 fork 來幫助除錯 Skaffold 開發範例 SLOs 以及 SLIs在我們實作任何監控之前, 複習一下 SRE 一書 中, 章節名稱為 Service Level Objectives 的介紹 服務架構 在不理解應用是怎麼建立的情況下, 是不太可能開發出 SLIs 的。 細節如原本的倉庫, 但在本教程中, 理解以下幾點便已足夠： 使用者透過 Frontend 存取應用 Purchases 由 CheckoutServer 所處理 CheckoutService 依賴 CurrencyService 處理轉換 其他服務像是 RecommendationService, ProductCatalogService, 以及 Adservice 被使用來提供渲染頁面需要的內容給 frontend Service Level Indicators 以及 Objectives 設置延遲 SLI現在你有定義完成的 SLOs 以及 SLIs, 你可以在 Stackdriver 來實作監控了。 那些你有興趣的指標已經被收集了。 你將為每一個 SLOs 建立警告政策。 前端延遲 (Front End Latency)在 Stackdriver 頁面選擇 Alerting &gt; Create a Policy 點擊 Add Condition, 接下來你將指定用來觸發警告政策的指標以及條件。 當有影響使用者體驗的性能方面的問題產生時, 這些條件將讓你知道有這些事情。 如同在 Service Level Indicators and Objectives 表格內敘述的, 你將使用第 99 的百分位數前端延遲作為 SLI 在 Find resource type and metric 欄位中數入以下值, 並從下拉選單中選擇如下：custom.googleapis.com/opencensus/grpc.io/client/roundtrip_latency 在 Resource Type 選擇 global 選項 點擊 Filter 欄位並選擇 opencensus_task 項。 點擊第一個預設值, 然後點擊 Apply 接下來, 將 Aggregator 設定為 99th percentile 接下來, 在 Configuration 區塊, 設定選項如下： Any time series violates 時觸發 Condition: is above Threshold: 500 For: Most recent value 點擊 Save 在下一個頁面, 下拉到底, 並且將 policy 命名為 “Latency Policy”, 然後點擊 Save, 你已經完成在 Stackdriver 監控 frontend latency SLI 的設置 設置可用性 SLI (Availability SLI)接下來, 設置 Stackdriver, 建立另一個警告政策來監控服務可用性 前端可用性 (Front End Availability)先由監控 front end service 的 error rate 開始, 因為這是會帶給使用者體驗最直接影響的地方。 如上所述, 你將會把任何的錯誤都列入違反 SLO 。 建立一個警告政策, 當觀察到任何錯誤時, 事件就會被觸發。 觸發特定錯誤的簡單方法之一, 就是使用基於紀錄的指標 (log-based metrics) 在 Stackdriver UI 介面中, 左側面板打開 Logging 針對 filter 做如下設置: 在 Resource type (第一個下拉選單) 選擇 Kubernetes Container Log Level 選擇 ERROR 在篩選器欄位輸入 label:k8s-pod/app:&quot;currencyservice&quot; 備註: 在這個頁面, 你不會看到任何結果, 因為目前服務正常的運行中。 很快的, 你將做一些變更來改變這個結果。 點擊 Create Metric 將指標命名為 “Error_Rate_SLI”, 然後點擊 Create Metric 來儲存紀錄指標: 現在你可以看到這個指標列在記錄指標的頁面。 點擊行末三個點的小圖案, 並點擊 Create Alert from Metric 來使用該指標建立警告政策 注意到 resource type 以及 metric 已經被填好了 將 condition 命名為 “Error Rate SLI” 點擊 Show Advanced Options 連結, 然後做如下設定： Aligner: rate在 Configuration 的地方, 使用 0.5 唯一分鐘的觸發門檻 然後點擊 Save 在下一個頁面, 將新的政策命名為 “Error Rate SLI” 然後點擊 Save 如預料的, 並沒有錯誤發生。 因為你的應用目前有達到可用性 SLO 部署新的發佈現在你已經設置好 SLI 監控, 也已經準備好測量應用變更對使用者體驗造成的衝擊。 讓我們來看看當部署一個新的應用發佈時會發生什麼事。 接下來, 你將修改 Kubernetes 的設定檔使服務有新的發佈, 然後運行 skaffold 來再次部署應用。 更新 YAML 檔案 找到 microservices-demo-1 資料夾, 打開裡頭的 kubernetes-manifests 資料夾 在 kubernetes_manifests/remommendationservice.yaml 檔案, 第 28 行, 使用下面的程式碼取代image: gcr.io./accl-19-dev/recommendationservice:rel013019imagePullPolicy: Always 舉例來說, 下面是 recommendationservice.yaml 的原始版本： 然後下面的是更新之後的： 在以下這些檔案中都做同樣的事： kubernetes_manifests/currencyservice.yaml kubernetes_manifests/frontend.yaml 儲存並關閉檔案, 現在你已經可以部署新的版本了。 部署新的版本在 Cloud Shell, 更新 deployment 來部署新的容器鏡像:skaffold run 確認新版本的服務正在運行著:kubectl get pods (輸出)NAME READY STATUS RESTARTS AGEadservice-55f94cfd9c-4lvml 1/1 Running 0 17dcartservice-6f4946f9b8-6wtff 1/1 Running 197 17dcheckoutservice-5688779d8c-l6crl 1/1 Running 0 17dcurrencyservice-665d6f4569-b4sbm 1/1 Running 0 1memailservice-684c89bcb8-h48sq 1/1 Running 0 17dfrontend-5f889fc7bb-wvfvv 1/1 Running 0 1mloadgenerator-6d646566db-p422w 1/1 Running 0 17dpaymentservice-858d89d64c-hmpkg 1/1 Running 0 17dproductcatalogservice-bcd85cb5-d6xp4 1/1 Running 0 17drecommendationservice-57cb4559f9-bdgj7 1/1 Running 0 1mredis-cart-9b864d47f-c9xc6 1/1 Running 0 17dshippingservice-5948f9fb5c-vndcp 1/1 Running 0 17d 傳送一些資料現在應用已經在運行著, 回去看看你部署了什麼。 在主控台, 到 Kubernetes Engine &gt; Services &amp; Ingress, 尋找 frontend-external 服務並點擊 Endpoint URL 到 Hipster Shop 網站, 點擊 Buy 以及/或 Add to Cart 幾次來傳送一些流量。 等待 60 秒左右來產生足夠的延遲資料 延遲 SLO 違反 - 找出問題在這個練習中, 你將使用 Stackdriver Application Performance Management (APM) 工具來找出已經解決造成應用嚴重延遲的問題 首先, 讓我們看看在我們部署新版之後, 是不是一切都 OK 在 Stackdriver 中選擇 Monitoring Overview, 在上方點擊 autorefresh arrows, 所以你將可以看到最新的資訊 一個 Latency Policy 事件不久後會出現, 如果還沒出現的話, 等它幾分鐘 在 Incident 區塊中點擊 Latency Policy 來檢視更多資訊。 你可能需要點擊 Resolved 區塊來檢視已經發生的警告 分析延遲問題的最佳解, 就是使用 Trace, 在左手邊的選單點擊 Trace 現在你的位置在主控台。 一開始的總覽的資訊挺有幫助的, 但你需要更進一步的資訊, 打開 Trace List 頁面 點擊 Auto Reload, 注意到頁面商方的散點圖, 在時間警告處有大量的異常紀錄。 等 1 或 2 分鐘讓資料搜集, 然後點擊其中一個 outlier traces 來檢視發生的細節。 注意到 Span name (代表被呼叫的 service 或 function) 為 /char/ 或 /char/checkout/ 在 Request filter 欄位輸入 “Recv./cart” 來篩選所有的 cart 運作以及類似的追蹤, 這有助於了解它是如何比較事件發生前的紀錄以及發生後的紀錄。 設定時間範圍為 1 hour, 所以顯示資料會包括事件發生前的資料 點擊事件發生前的一筆資料來看看 可以看到, 這個類似的紀錄 ListRecommendations 在此只被呼叫了一次。 然而, 在我們最新的部署之後, ListRecommendations 在每一次的請求都被呼叫了很多次, 造成了很嚴重的額外延遲 至此, 我們可以總結, 這些異常值造成的原因是因為 ListRecommendations 的多次呼叫。 部署變更來處理延遲為了解決上一次部署所產生的延遲問題, 你需要部署另外一個版本來修復損壞的程式碼。 你將會修改 Kubernetes 的設定檔, 含有損壞程式碼服務的設定檔 要部署修復, 回到 Cloud Shell 頁面, Source Code Editor 應該還是開啟的。 你將會修改以下檔案： kubernetes_manifests/recommendationservice.yaml kubernetes_manifests/frontend.yaml 將鏡像的標籤 rel013019 修改成 rel013019fix, 所以 鏡像 看起來應如下：containers:- name: server image: gcr.io/accl-19-dev/frontend:rel013019fix imagePullPolicy: Always 儲存 檔案 回到 Cloud Shell 並執行以下指令重新部署修復過的鏡像:skaffold run 核對修復現在你已經部署了修復的版本, 核對一下你的應用是否已回到健康的狀態 回到 *Stackdriver 並到 Metrics Explorer (Resources &gt; Metrics Explorer) 在搜尋欄位, 輸入 latency 並點擊 roundtrip_latency 將圖表類型變更為 Line, 你應該看到圖表中的 latency 數值有立即明顯的下降 (如果沒有的話, 可能要等個一分鐘) 現在, 回到 Monitoring Overview 看看事件是否已經解除了。 你應可發現兩件事 - 原本的 incident 也經不存在了, 且會有 event 通知說原本的 incident 已經被解除了。同樣的, 如果你沒看到 incident 解除的訊息, 等個幾分鐘吧。 你的監控可以正確的辨識出造成使用者體驗下滑的變更 (如同我們上面的檢測, 是由延遲造成的), 你也可以辨識出真正產生問題的原因, 且你也回滾了這段損壞的變更。 在下一個章節, 看看 Stackdriver 是如何幫助我們解決可用性 (availability) 的問題。 錯誤率 SLO 違反 (Error Rate SLO Violation) - 找出問題在這個練習中, 你將使用 Stackdriver Application Performance Management 工具 (APM) 來排查一些在你的應用之中造成錯誤, 並且超出了你設定的錯誤限制的問題 先到 Stackdriver 的 Monitoring Overview 尋找 Error Rate SLI incident, 然後點擊 incident 來了解發生了什麼事。 incidents 可能會需要幾分鐘的時間來被確認, 並且列在 incident 中。 如果還沒有看到有 incident, 你可以先跳過 incident 步驟, 然後在左手邊選單處點擊 Error Reporting 你可以看到 currencyservice pod 正紀錄比之前多很多的錯誤。 點擊 Acknowledge incident, 所以針對事件的通知不會持續累積 像這種類型的警告, 也很多方式可以達成, 但最簡單的方式是使用 Stackdriver Error Reporting, 在左手邊選單點擊 Error Reporting 可注意到 Open Error Reporting 顯示有一個最新的數據急遽上升。 點擊 Error: Conversion in Zero 來檢視更多錯誤問題 在右手邊可看到 Stack Trace 樣本, 你可以從這看到哪些特定的呼叫是跟錯誤相關的 點擊 最下面的呼叫, 如 /usr/src/app/server/js:131 顯示 這會將你導向 Stackdriver Debug, 在頂部的欄位確認 currency service 有被選擇 接下來, 從 Cloud Source Repositories 選擇正在運行的程式碼 依照以下條件選擇 source Repository: apm-qwiklabs-demo Tagged version or branch: APM-Troubleshooting-Demo-2 然後點擊 Select Source 在左手邊選單選擇 /src/currencyservice/server.js 往下捲動到 155 行左右, 這邊是 exception 被拋出的地方。 你可以看到錯誤回報功能正是回報 Conversion is Zero 這一個錯誤紀錄 從上面的程式碼可以看到, 當 result.units &lt; 0 時會記錄這個 error, 而要排除這個問題, 你將使用 Snapshots 來檢查當應用運行中變數的值。 確認你已經在右上方選擇了 Snapshot 然後點擊你想要快照的地方, 行數 (155) 在此練習中, 在行數 155, 141, 以及 149 的地方快照, 你也可以在任何你覺得適當的地方加入快照。 系統將會在下一次程式碼運行時, 對變數進行快照。 當應用正在等待程式碼運行時, 你可以看到 “Waiting for snapshot to hit …” 提示。 當快照完成, 右手邊將顯示指定快照處的變數 可以看到 Variable 以及 Call Stack 資訊。 這些資訊可以讓你了解到你的程式碼執行的路線是怎麼走的, 以及在執行的路線上的程式碼結構以及變數, 我們完全不需要重啟應用或變更任何程式碼來獲得這些資訊。 點擊 result 來檢視在 155 行結束的 3 個快照。 根據上面的資訊我們知道當 result.units 不大於 0 時, 會觸發錯誤。 檢視一下變數你可以看到 result.units = NaN (代表 ‘不是一個 number’), 這就是造成錯誤的原因 現在你可以下結論, 這個錯誤是因為設定 result.units 為 0 的 convert function (或子 function) 出 bug, 你的錯誤排除程序依據快照所提供的資訊以及紀錄是一個很確實地針對問題的診斷。 所以造成問題的 bug 是什麼？ 從程式碼可以看到, result.units 由 euros 在第 114 行設定, 而 euros 在第 136 行 from.units 被設定 檢視快照中的 euros.units 也是 NaN, 然而, from.units 是個合法的數字。 因此問題是在轉換 from.unit 到 euros 時發生的。 你可以歸納, 根本原因為 from.units 在 137 行是如何被轉換成 euros.units, 8 被帶入 Data[], 這事實上是一個 key value 的指向, currency units (像是 EUR) 到 exchange rates, 正確的 137 行應該要使用 from.to_currency (即 USD), 而非 from.units (即 8) 現在你已經確定產生 bug 的原因, 並且也可以做出相對應的修正。 根據警告的時間點, 這可能是在最近的部署上產生的。 看看之前的 “Master” 分支上, 在 137 行有沒有這個錯誤 回到主控台, 使用 Cloud Source Repositories (在主控台選單的 Tools 分類下) 來檢視程式碼 打開 apm-qwiklabs-demo repository, 選擇 master 分支 從左手邊至 *src &gt; currencyservice &gt; server.js, 注意到第 137 行有使用正確的被除數 data[from.currency_code] 現在你已經可以確定這個 bug 是由最新的 push 所造成。 當務之急, 我們先要回到前一個版本去。 部署變更來解決 Error Rate要解決這個問題, 你需要部署一個修復到應用上。 為了做到這一點, 你將需要更改 Kubernetes 的設定檔中, 包含有錯誤程式碼的服務。 部署修復回到 Cloud Shell, 然後在 Source Code Editor 打開 kubernetes_manifests 資料夾中的 currencyservice.yaml 檔案 將 image tag_re1013019_ 替換成 re1013019fix, 所以 image 應看起來如下：containers:- name: server image: gcr.io/accl-19-dev/frontend:rel013019fix imagePullPolicy: Always 關閉 檔案並儲存, 回到 Cloud Shell 視窗 重新部署帶有修復代碼的鏡像：skaffold run 核對修復現在你已經回滾了錯誤的代碼, 確認一下應用是否有回到健康的狀態。 如同上面的步驟, 先核對一下 incident 是否已經解決了。 到 Stackdriver UI Monitoring Overview 確認一下 error rate incident 是否已經解決了。 現在, 應該是沒有 open incident 了。 接下來, 回到 Error Reporting, 打開之前觀察的錯誤, 然後確認錯誤已經沒有再出現了 (時間軸應會顯示從上一次部署到現在已經都沒有錯誤發生了) 恭喜！ 你的監控可以正確地發現造成使用者體驗下降的變更代碼 (經由量測應用錯誤而得來的數據), 且你可以找出根本的原因, 然後回滾錯誤的程式碼。 讓我們進到下一個章節, 學習怎麼樣使用 Stackdriver 來優化資源利用 使用 Stackdriver APM 來優化應用在這個練習中, 你將使用 Stackdriver Application Performance Management 工具 (APM) 來尋找你的應用可能的改善空間, 讓它運行的更快速, 使用更少的資源。 在這個情境中, Director of Cloud Operations 對最近的運算成本上升感到非常失望。 特別是, 根據系統的使用量來看, currencyservice 使用了超出預期的 CPU 你的團隊已經被賦予了優化的任務。 APM 工具將被使用來分析服務, 並且確保你的團隊可以將心力集中在對的地方。 從主控台左手邊選單打開 Stackdriver Profiler 變更右上方的 Timespan 到 30 分鐘。 如果還沒有資料的話, 等個 1 到 2 分鐘讓資料載入 注意: Profiler 提取隨機的呼叫樣本來建立一個總和的呼叫堆疊。 如果你沒有看到你預期中的資料, 那可能是因為本教程運行的時間還不足, 或是你的進度比預期的要快。 可以在本次練習中多多使用 screenshots 在 filter 的 service 欄位選擇 frontend, 然後在 Profile type 欄位選擇 CPU time Profiler 提取隨機的系統頗析樣本, 並且融合這些資料, 顯示出哪些功能使用了最大量的資源。 下面的火焰圖顯示了由使用的資源分組 (在這個案例中, 資源為 CPU) 過的 function 呼叫, X 軸為 CPU 的總量, Y 軸為父子關係 在這個案例中, 在左手邊的 ServeHTTP 呼叫使用了大部分的 CPU, 點擊這個呼叫, 進一步搜索原因。 展開的圖表顯示了有一半的呼叫是由 viewCartHandler 相對應的 getRecommendations 所造成。 所以可能可以下手的地方是 getRecommendations 以及其相對應的 getProduct, 回想一下之前的練習, recommendation service 以及 getProduct 在迴圈內被頻繁的呼叫, 因為在蟲試邏輯中有錯。 解決這個問題之後, 將可以減少運算成本達 20% 恭喜你已完成本教程","link":"/zh-tw/siteReliabilityTroubleshootingWithStackdriverAPM/"},{"title":"Linux 基礎篇 - 學習筆記","text":"前言這是一份未整理過的 Linux 學習筆記OS 系統為 GCP 上的 Linux 18.04 LTS內容參考出處： 鳥哥的 Linux 的私房菜 Internet find搜尋屬於特定 user 或 group 的檔案find localtion -type f -user userName -group groupName -name fileName 搜尋屬於特定 user 或 group 的資料夾find localtion -type d -user userName -group groupName -name fileName 搜尋 $分鐘內的檔案或資料夾, 只搜尋當層find ./* -maxdepth 0 -type f -cmin -20 ps 列出系統正在執行的 process, 並且從中搜尋關鍵字ps -ef | node kill語法[root@study ~]# kill -signal %jobnumber[root@study ~]# kill -l選項與參數：-l ：這個是 L 的小寫，列出目前 kill 能夠使用的訊號 (signal) 有哪些？signal ：代表給予後面接的那個工作什麼樣的指示囉！用 man 7 signal 可知： -1 ：重新讀取一次參數的配置文件 (類似 reload)； -2 ：代表與由鍵盤輸入 [ctrl]-c 同樣的動作； -9 ：立刻強制刪除一個工作； -15：以正常的程序方式終止一項工作。與 -9 是不一樣的。 代號 名稱 內容 1 SIGHUP 啟動被終止的程序，可讓該 PID 重新讀取自己的配置文件，類似重新啟動 2 SIGINT 相當於用鍵盤輸入 [ctrl]-c 來中斷一個程序的進行 9 SIGKILL 代表強制中斷一個程序的進行，如果該程序進行到一半， 那麼尚未完成的部分可能會有“半產品”產生，類似 vim會有 .filename.swp 保留下來。 15 SIGTERM 以正常的結束程序來終止該程序。由於是正常的終止， 所以後續的動作會將他完成。不過，如果該程序已經發生問題，就是無法使用正常的方法終止時， 輸入這個 signal 也是沒有用的。 19 SIGSTOP 相當於用鍵盤輸入 [ctrl]-z 來暫停一個程序的進行 指令 立刻強制刪除一個工作kill -9 processID killall語法[root@study ~]# killall [-iIe] [command name]選項與參數：-i ：interactive 的意思，互動式的，若需要刪除時，會出現提示字符給使用者；-e ：exact 的意思，表示“後面接的 command name 要一致”，但整個完整的指令 不能超過 15 個字符。-I ：指令名稱(可能含參數)忽略大小寫。 ln 建立一個捷徑ln -s sourceAbsoluteLink targetAbsoluteLink du 查檔案大小du -sh fileOrFolder df 查硬碟空間使用率df -h [[]] 回傳 true or false[[ -f /.dockerenv ]] [[]] 會將裡頭的參數結果回傳 true or false-f 表示 file exists所以意思是，如果 /.dockerenv 存在，則回傳 true grep 搜尋內容並顯示附近的行數從 gcloud command 中取得資料，並且顯示 ssh-keys 後面的 5 行gcloud compute project-info describe | grep -A 5 ssh-keys groupdel 刪除 groupgroupdel groupName userdel 刪除 useruserdel userName useradduseradd [-u UID] [-g 初始群組] [-G 次要群組] [-mM]\\&gt; [-c 說明欄] [-d 主文件夾絕對路徑] [-s shell] 使用者帳號名選項與參數：-u ：後面接的是 UID ，是一組數字。直接指定一個特定的 UID 給這個帳號；-g ：後面接的那個群組名稱就是我們上面提到的 initial group 啦～ 該群組的 GID 會被放置到 /etc/passwd 的第四個字段內。-G ：後面接的群組名稱則是這個帳號還可以加入的群組。 這個選項與參數會修改 /etc/group 內的相關數據喔！-M ：強制！不要創建使用者主文件夾！(系統帳號默認值)-m ：強制！要創建使用者主文件夾！(一般帳號默認值)-c ：這個就是 /etc/passwd 的第五欄的說明內容啦～可以隨便我們設置的啦～-d ：指定某個目錄成為主文件夾，而不要使用默認值。務必使用絕對路徑！-r ：創建一個系統的帳號，這個帳號的 UID 會有限制 (參考 /etc/login.defs)-s ：後面接一個 shell ，若沒有指定則默認是 /bin/bash 的啦～-e ：後面接一個日期，格式為“YYYY-MM-DD”此項目可寫入 shadow 第八字段， 亦即帳號失效日的設置項目囉；-f ：後面接 shadow 的第七字段項目，指定密碼是否會失效。0為立刻失效， -1 為永遠不失效(密碼只會過期而強制於登陸時重新設置而已。) 完全參考默認值創建一個使用者，名稱為 Ray useradd Ray 建立一個 user, 並加到指定 group useradd -G groupName userName useradd 之後，系統會幫我們做哪些事？ 在 /etc/passwd 裡面創建一行與帳號相關的數據，包括創建 UID/GID/主文件夾等； 在 /etc/shadow 裡面將此帳號的密碼相關參數填入，但是尚未有密碼； 在 /etc/group 裡面加入一個與帳號名稱一模一樣的群組名稱； 在 /home 下面創建一個與帳號同名的目錄作為使用者主文件夾，且權限為 700 useradd 參考檔 這個數據其實是由 /etc/default/useradd 調用出來的 useradd -DGROUP=100 &lt;==默認的群組HOME=/home &lt;==默認的主文件夾所在目錄INACTIVE=-1 &lt;==密碼失效日，在 shadow 內的第 7 欄EXPIRE= &lt;==帳號失效日，在 shadow 內的第 8 欄SHELL=/bin/bash &lt;==默認的 shellSKEL=/etc/skel &lt;==使用者主文件夾的內容數據參考目錄CREATE_MAIL_SPOOL=yes &lt;==是否主動幫使用者創建郵件信箱(mailbox) GROUP=100：新建帳號的初始群組使用 GID 為 100 者系統上面 GID 為 100 者即是 users 這個群組，此設置項目指的就是讓新設使用者帳號的初始群組為 users 這一個的意思。 但是我們知道 CentOS 上面並不是這樣的，在 CentOS 上面默認的群組為與帳號名相同的群組。 舉例來說， vbird1 的初始群組為 vbird1 。怎麼會這樣啊？這是因為針對群組的角度有兩種不同的機制所致， 這兩種機制分別是： 私有群組機制：系統會創建一個與帳號一樣的群組給使用者作為初始群組。 這種群組的設置機制會比較有保密性，這是因為使用者都有自己的群組，而且主文件夾權限將會設置為 700 (僅有自己可進入自己的主文件夾) 之故。使用這種機制將不會參考 GROUP=100 這個設置值。代表性的 distributions 有 RHEL, Fedora, CentOS 等； 公共群組機制：就是以 GROUP=100 這個設置值作為新建帳號的初始群組，因此每個帳號都屬於 users 這個群組， 且默認主文件夾通常的權限會是“ drwxr-xr-x … username users … ”，由於每個帳號都屬於 users 群組，因此大家都可以互相分享主文件夾內的數據之故。代表 distributions 如 SuSE等。由於我們的 CentOS 使用私有群組機制，因此這個設置項目是不會生效的！不要太緊張啊！ HOME=/home：使用者主文件夾的基準目錄(basedir)使用者的主文件夾通常是與帳號同名的目錄，這個目錄將會擺放在此設置值的目錄後。所以 vbird1 的主文件夾就會在 /home/vbird1/ 了！很容易理解吧！ INACTIVE=-1：密碼過期後是否會失效的設置值我們在 shadow 文件結構當中談過，第七個字段的設置值將會影響到密碼過期後， 在多久時間內還可使用舊密碼登陸。這個項目就是在指定該日數啦！如果是 0 代表密碼過期立刻失效， 如果是 -1 則是代表密碼永遠不會失效，如果是數字，如 30 ，則代表過期 30 天后才失效。 EXPIRE=：帳號失效的日期就是 shadow 內的第八字段，你可以直接設置帳號在哪個日期後就直接失效，而不理會密碼的問題。 通常不會設置此項目，但如果是付費的會員制系統，或許這個字段可以設置喔！ SHELL=/bin/bash：默認使用的 shell 程序文件名系統默認的 shell 就寫在這裡。假如你的系統為 mail server ，你希望每個帳號都只能使用 email 的收發信件功能， 而不許使用者登陸系統取得 shell ，那麼可以將這裡設置為 /sbin/nologin ，如此一來，新建的使用者默認就無法登陸！ 也免去後續使用 usermod 進行修改的手續！ SKEL=/etc/skel：使用者主文件夾參考基準目錄這個咚咚就是指定使用者主文件夾的參考基準目錄囉～舉我們的範例一為例， vbird1 主文件夾 /home/vbird1 內的各項數據，都是由 /etc/skel 所複製過去的～所以呢，未來如果我想要讓新增使用者時，該使用者的環境變量 ~/.bashrc 就設置妥當的話，您可以到 /etc/skel/.bashrc 去編輯一下，也可以創建 /etc/skel/www 這個目錄，那麼未來新增使用者後，在他的主文件夾下就會有 www 那個目錄了！這樣瞭呼？ CREATE_MAIL_SPOOL=yes：創建使用者的 mailbox你可以使用“ ll /var/spool/mail/vbird1 ”看一下，會發現有這個文件的存在喔！這就是使用者的郵件信箱！ UID/GID 還有密碼參數 路徑 /etc/login.defsMAIL_DIR /var/spool/mail &lt;==使用者默認郵件信箱放置目錄 PASS_MAX_DAYS 99999 &lt;==/etc/shadow 內的第 5 欄，多久需變更密碼日數PASS_MIN_DAYS 0 &lt;==/etc/shadow 內的第 4 欄，多久不可重新設置密碼日數PASS_MIN_LEN 5 &lt;==密碼最短的字符長度，已被 pam 模塊取代，失去效用！PASS_WARN_AGE 7 &lt;==/etc/shadow 內的第 6 欄，過期前會警告的日數UID_MIN 1000 &lt;==使用者最小的 UID，意即小於 1000 的 UID 為系統保留UID_MAX 60000 &lt;==使用者能夠用的最大 UIDSYS_UID_MIN 201 &lt;==保留給使用者自行設置的系統帳號最小值 UIDSYS_UID_MAX 999 &lt;==保留給使用者自行設置的系統帳號最大值 UIDGID_MIN 1000 &lt;==使用者自訂群組的最小 GID，小於 1000 為系統保留GID_MAX 60000 &lt;==使用者自訂群組的最大 GIDSYS_GID_MIN 201 &lt;==保留給使用者自行設置的系統帳號最小值 GIDSYS_GID_MAX 999 &lt;==保留給使用者自行設置的系統帳號最大值 GIDCREATE_HOME yes &lt;==在不加 -M 及 -m 時，是否主動創建使用者主文件夾？UMASK 077 &lt;==使用者主文件夾創建的 umask ，因此權限會是 700USERGROUPS_ENAB yes &lt;==使用 userdel 刪除時，是否會刪除初始群組ENCRYPT_METHOD SHA512 &lt;==密碼加密的機制使用的是 sha512 這一個機制！ mailbox 所在目錄：使用者的默認 mailbox 文件放置的目錄在 /var/spool/mail，所以 vbird1 的 mailbox 就是在 /var/spool/mail/vbird1 囉！ shadow 密碼第 4, 5, 6 字段內容：通過 PASS_MAX_DAYS 等等設置值來指定的！所以你知道為何默認的 /etc/shadow 內每一行都會有“ 0:99999:7 ”的存在了嗎？^_^！不過要注意的是，由於目前我們登陸時改用 PAM 模塊來進行密碼檢驗，所以那個 PASS_MIN_LEN 是失效的！ UID/GID 指定數值：雖然 Linux 核心支持的帳號可高達 232 這麼多個，不過一部主機要作出這麼多帳號在管理上也是很麻煩的！ 所以在這裡就針對 UID/GID 的範圍進行規範就是了。上表中的 UID_MIN 指的就是可登陸系統的一般帳號的最小 UID ，至於 UID_MAX 則是最大 UID 之意。 要注意的是，系統給予一個帳號 UID 時，他是 (1)先參考 UID_MIN 設置值取得最小數值； (2)由 /etc/passwd 搜尋最大的 UID 數值， 將 (1) 與 (2) 相比，找出最大的那個再加一就是新帳號的 UID 了。我們上面已經作出 UID 為 1500 的 vbird2 ， 如果再使用“ useradd vbird4 ”時，你猜 vbird4 的 UID 會是多少？答案是： 1501 。 所以中間的 1004~1499 的號碼就空下來啦！ 而如果我是想要創建系統用的帳號，所以使用 useradd -r sysaccount 這個 -r 的選項時，就會找“比 201 大但比 1000 小的最大的 UID ”就是了。 ^_^ 使用者主文件夾設置值：為何我們系統默認會幫使用者創建主文件夾？就是這個“CREATE_HOME = yes”的設置值啦！這個設置值會讓你在使用 useradd 時， 主動加入“ -m ”這個產生主文件夾的選項啊！如果不想要創建使用者主文件夾，就只能強制加上“ -M ”的選項在 useradd 指令執行時啦！至於創建主文件夾的權限設置呢？就通過 umask 這個設置值啊！因為是 077 的默認設置，因此使用者主文件夾默認權限才會是“ drwx—— ”哩！ 使用者刪除與密碼設置值：使用“USERGROUPS_ENAB yes”這個設置值的功能是： 如果使用 userdel 去刪除一個帳號時，且該帳號所屬的初始群組已經沒有人隸屬於該群組了， 那麼就刪除掉該群組，舉例來說，我們剛剛有創建 vbird4 這個帳號，他會主動創建 vbird4 這個群組。 若 vbird4 這個群組並沒有其他帳號將他加入支持的情況下，若使用 userdel vbird4 時，該群組也會被刪除的意思。 至於“ENCRYPT_METHOD SHA512”則表示使用 SHA512 來加密密碼明文，而不使用舊式的 MD5。現在你知道啦，使用 useradd 這支程序在創建 Linux 上的帳號時，至少會參考： /etc/default/useradd/etc/login.defs/etc/skel/* usermodusermod [-cdegGlsuLU] username選項與參數：-c ：後面接帳號的說明，即 /etc/passwd 第五欄的說明欄，可以加入一些帳號的說明。-d ：後面接帳號的主文件夾，即修改 /etc/passwd 的第六欄；-e ：後面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 內的第八個字段數據啦！-f ：後面接天數，為 shadow 的第七字段。-g ：後面接初始群組，修改 /etc/passwd 的第四個字段，亦即是 GID 的字段！-G ：後面接次要群組，修改這個使用者能夠支持的群組，修改的是 /etc/group 囉～-a ：與 -G 合用，可“增加次要群組的支持”而非“設置”喔！-l ：後面接帳號名稱。亦即是修改帳號名稱， /etc/passwd 的第一欄！-s ：後面接 Shell 的實際文件，例如 /bin/bash 或 /bin/csh 等等。-u ：後面接 UID 數字啦！即 /etc/passwd 第三欄的數據；-L ：暫時將使用者的密碼凍結，讓他無法登陸。其實僅改 /etc/shadow 的密碼欄。-U ：將 /etc/shadow 密碼欄的 ! 拿掉，解凍啦！ 增加指定 user 的次要群組usermod -a -G groupName userName chmod 給予一個資料夾 SGID 屬性chmod 2777 folderName passwdpasswd [--stdin] [帳號名稱] &lt;==所有人均可使用來改自己的密碼[root@study ~]# passwd [-l] [-u] [--stdin] [-S] \\&gt; [-n 日數] [-x 日數] [-w 日數] [-i 日期] 帳號 &lt;==root 功能選項與參數：--stdin ：可以通過來自前一個管線的數據，作為密碼輸入，對 shell script 有幫助！-l ：是 Lock 的意思，會將 /etc/shadow 第二欄最前面加上 ! 使密碼失效；-u ：與 -l 相對，是 Unlock 的意思！-S ：列出密碼相關參數，亦即 shadow 文件內的大部分信息。-n ：後面接天數，shadow 的第 4 字段，多久不可修改密碼天數-x ：後面接天數，shadow 的第 5 字段，多久內必須要更動密碼-w ：後面接天數，shadow 的第 6 字段，密碼過期前的警告天數-i ：後面接“日期”，shadow 的第 7 字段，密碼失效日期 確認 OS 種類以及版本 使用 lsb_release ， 如果沒安裝的話，安裝它 sudo apt-get install lsb-release 查詢用法 lsb_release --help 輸出如下：-h, --help show this help message and exit-v, --version show LSB modules this system supports-i, --id show distributor ID-d, --description show description of this distribution-r, --release show release number of this distribution-c, --codename show code name of this distribution-a, --all show all of the above information-s, --short show requested information in short format 根據上面的資訊，想查詢明細的話lsb_release -a curl語法curl [options] [URL...]-X 代表 request 的方式-H 代表 header-d 代表傳送資料，等同於以 `Content-Type: application/x-www-form-urlencoded` 方式傳送-k 若經由 `https` 發請求，加上 -k 可避開 HTTPS 方式-v 代表 `verbose` , 若要顯示回覆訊息，需加上 `-v`-L 如果 server 端回報位置已轉址, curl 會對新的位址在發請求-T 上傳檔案-s slient 模式 範例假設請求如下：curl -X POST \\ https://requestedURL \\ -H 'Content-Type: application/json' \\ -d '&#123;\"dataA\":\"content of data A\",\"dataB\":\"content of data B\"&#125;' -k -v -X 代表 request 的方式 ip 請由此查詢 -H 代表 header -d 代表傳送資料，等同於以 Content-Type: application/x-www-form-urlencoded 方式傳送 -k 若經由 https 發請求，需加上 -k -v 代表 verbose , 若要顯示回覆訊息，需加上 -v bash 環境配置文件bash 會根據有沒有登入來讀取相對應的環境配置文件 login shell /etc/profile /etc/profile.d/*.sh 被調用的條件如下： 在 /etc/profile.d/ 這個目錄內 擴展名為 .sh 使用者能夠具有 r 的權限 ~/.bash_profile or ~/.bash_login or ~/.profile (照順序讀，只會讀其中一個) ~/.bashrc (最終會讀取這一個文件) non-login shell ~/.bashrc etc/bashrc (會調用此文件) 流程圖 不小心刪除了 ~/.bashrc, 或是沒有這個文件，想創建怎麼辦？ 複製預設文件 cp /etc/skel/.bashrc ~/ 視需求修改 使立即生效source ~/.bashrc or . ~/.bashrc Base 64 decodebase64 --decode /tmp/encoded.txt &gt; /tmp/decoded.txt ncftpncftpput -u account -p password -P port -m -R ipOrDomain remoteLocation locationFileOrDirectory -u：指定登錄FTP服務器時使用的用戶名； -p：指定登錄FTP服務器時使用的密碼； -P：如果FTP服務器沒有使用默認的TCP協議的21端口，則使用此選項指定FTP服務器的端口號。 -m：在傳之前嘗試在目錄位置創建目錄(用於傳目錄的情況) -R：遞規傳子目錄 ufw 啟用防火牆服務 ufw enable 關閉防火牆服務 ufw disable 打開指定 port ufw allow port/tcp install 使用 install 指令，我們可以在創立一個 folder 或 file 的同時，指定 owner, group 以及 mode install -d -o &lt;user&gt; -g &lt;group&gt; -m &lt;mode&gt; &lt;path&gt; -d : directory -o : owner -g : group -m : mode 建立一個資料夾，並給予權限 install -d -o ray -g ray -m 2770 /tmp/ray 建立一個檔案，並給予權限 install -m 777 -o ray -g ray /dev/null filename.txt yumwhatprovides 找出有提供特定 command 的 packageyum whatprovides */commandYouAreLookingFor install 安裝特定的 packageyum insatll packageName regular expression (regex) (正則表達式)特殊符號表 特殊符號 代表意義 [:alnum:] 代表英文大小寫字符及數字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小寫字符，亦即 A-Z, a-z [:blank:] 代表空白鍵與 [Tab] 按鍵兩者 [:cntrl:] 代表鍵盤上面的控制按鍵，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表數字而已，亦即 0-9 [:graph:] 除了空白字符 (空白鍵與 [Tab] 按鍵) 外的其他所有按鍵 [:lower:] 代表小寫字符，亦即 a-z [:print:] 代表任何可以被打印出來的字符 [:punct:] 代表標點符號 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大寫字符，亦即 A-Z [:space:] 任何會產生空白的字符，包括空白鍵, [Tab], CR 等等 [:xdigit:] 代表 16 進位的數字類型，因此包括： 0-9, A-F, a-f 的數字與字符 表達式彙整 字元 描述 \\ 將下一個字元標記為一個特殊字元(File Format Escape，見本表)、或一個原義字元(Identity Escape，有 ^ $ ( ) * + ? . [ \\ { &#124; 共計12個)、或一個向後參照(backreferences)、或一個八進位跳脫符。例如，「n」匹配字元「n」。「\\n」匹配一個換行符。序列「\\」匹配「\\」而「(」則匹配「(」。 ^ 匹配輸入字串的開始位置。如果設定了RegExp物件的Multiline屬性，^也匹配「\\n」或「\\r」之後的位置。 $ 匹配輸入字串的結束位置。如果設定了RegExp物件的Multiline屬性，$也匹配「\\n」或「\\r」之前的位置。 * 匹配前面的子表達式零次或多次。例如，zo能匹配「z」、「zo」以及「zoo」。等價於{0,}。 + 匹配前面的子表達式一次或多次。例如，「zo+」能匹配「zo」以及「zoo」，但不能匹配「z」。+等價於{1,}。 ? 匹配前面的子表達式零次或一次。例如，「do(es)?」可以匹配「does」中的「do」和「does」。?等價於{0,1}。 {n} n是一個非負整數。匹配確定的n次。例如，「o{2}」不能匹配「Bob」中的「o」，但是能匹配「food」中的兩個o。 {n,} n是一個非負整數。至少匹配n次。例如，「o{2,}」不能匹配「Bob」中的「o」，但能匹配「foooood」中的所有o。「o{1,}」等價於「o+」。「o{0,}」則等價於「o*」。 {n,m} m和n均為非負整數，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，「o{1,3}」將匹配「fooooood」中的前三個o。「o{0,1}」等價於「o?」。請注意在逗號和兩個數之間不能有空格。 ? 非貪心量化(Non-greedy quantifiers)：當該字元緊跟在任何一個其他重複修飾詞(*,+,?，{n}，{n,}，{n,m})後面時，匹配模式是非貪婪的。非貪婪模式儘可能少的匹配所搜尋的字串，而預設的貪婪模式則儘可能多的匹配所搜尋的字串。例如，對於字串「oooo」，「o+?」將匹配單個「o」，而「o+」將匹配所有「o」。 . 匹配除「\\r」「\\n」之外的任何單個字元。要匹配包括「\\r」「\\n」在內的任何字元，請使用像「(.&#124;\\r&#124;\\n)」的模式。 (pattern) 匹配pattern並取得這一匹配的子字串。該子字串用於向後參照。所取得的匹配可以從產生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中則使用$0…$9屬性。要匹配圓括號字元，請使用「(」或「)」。可帶數量字尾。 (?:pattern) 匹配pattern但不取得匹配的子字串(shy groups)，也就是說這是一個非取得匹配，不儲存匹配的子字串用於向後參照。這在使用或字元「(&#124;)」來組合一個模式的各個部分是很有用。例如「industr(?:y&#124;ies)」就是一個比「industry&#124;industries」更簡略的表達式。 (?=pattern) 正向肯定預查(look ahead positive assert)，在任何匹配pattern的字串開始處匹配尋找字串。這是一個非取得匹配，也就是說，該匹配不需要取得供以後使用。例如，「Windows(?=95&#124;98&#124;NT&#124;2000)」能匹配「Windows2000」中的「Windows」，但不能匹配「Windows3.1」中的「Windows」。預查不消耗字元，也就是說，在一個匹配發生後，在最後一次匹配之後立即開始下一次匹配的搜尋，而不是從包含預查的字元之後開始。 (?!pattern) 正向否定預查(negative assert)，在任何不匹配pattern的字串開始處匹配尋找字串。這是一個非取得匹配，也就是說，該匹配不需要取得供以後使用。例如「Windows(?!95&#124;98&#124;NT&#124;2000)」能匹配「Windows3.1」中的「Windows」，但不能匹配「Windows2000」中的「Windows」。預查不消耗字元，也就是說，在一個匹配發生後，在最後一次匹配之後立即開始下一次匹配的搜尋，而不是從包含預查的字元之後開始 (?&lt;=pattern) 反向(look behind)肯定預查，與正向肯定預查類似，只是方向相反。例如，「(?&lt;=95&#124;98 &#124; NT&#124;2000)Windows」能匹配「2000Windows」中的「Windows」，但不能匹配「3.1Windows」中的「Windows」。 (?&lt;!pattern) 反向否定預查，與正向否定預查類似，只是方向相反。例如「(?&lt;!95 &#124;98&#124;NT&#124;2000)Windows」能匹配「3.1Windows」中的「Windows」，但不能匹配「2000Windows」中的「Windows」。x&#124;y 沒有包圍在()里，其範圍是整個正規表示式。例如，「z&#124;food」能匹配「z」或「food」。「(?:z&#124;f)ood」則匹配「zood」或「food」。 [xyz] 字元集合(character class)。匹配所包含的任意一個字元。例如，「[abc]」可以匹配「plain」中的「a」。特殊字元僅有反斜線\\保持特殊含義，用於跳脫字元。其它特殊字元如星號、加號、各種括號等均作為普通字元。脫字元^如果出現在首位則表示負值字元集合；如果出現在字串中間就僅作為普通字元。連字元 - 如果出現在字串中間表示字元範圍描述；如果如果出現在首位(或末尾)則僅作為普通字元。右方括號應跳脫出現，也可以作為首位字元出現。 [^xyz] 排除型字元集合(negated character classes)。匹配未列出的任意字元。例如，「[^abc]」可以匹配「plain」中的「plin」。 [a-z] 字元範圍。匹配指定範圍內的任意字元。例如，「[a-z]」可以匹配「a」到「z」範圍內的任意小寫字母字元。 [^a-z] 排除型的字元範圍。匹配任何不在指定範圍內的任意字元。例如，「[^a-z]」可以匹配任何不在「a」到「z」範圍內的任意字元。 [:name:] 增加命名字元類(named character class)[註 1]中的字元到表達式。只能用於方括號表達式。 [=elt=] 增加目前locale下排序(collate)等價於字元「elt」的元素。例如，[=a=]可能會增加ä、á、à、ă、ắ、ằ、ẵ、ẳ、â、ấ、ầ、ẫ、ẩ、ǎ、å、ǻ、ä、ǟ、ã、ȧ、ǡ、ą、ā、ả、ȁ、ȃ、ạ、ặ、ậ、ḁ、ⱥ、ᶏ、ɐ、ɑ 。只能用於方括號表達式。 [.elt.] 增加排序元素(collation element)elt到表達式中。這是因為某些排序元素由多個字元組成。例如，29個字母表的西班牙語， “CH”作為單個字母排在字母C之後，因此會產生如此排序「cinco, credo, chispa」。只能用於方括號表達式。 \\b 匹配一個單詞邊界，也就是指單詞和空格間的位置。例如，「er\\b」可以匹配「never」中的「er」，但不能匹配「verb」中的「er」。 \\B 匹配非單詞邊界。「er\\B」能匹配「verb」中的「er」，但不能匹配「never」中的「er」。 \\cx 匹配由x指明的控制字元。x的值必須為A-Z或a-z之一。否則，將c視為一個原義的「c」字元。控制字元的值等於x的值最低5位元(即對3210進位的餘數)。例如，\\cM匹配一個Control-M或回車字元。\\ca等效於\\u0001, \\cb等效於\\u0&#124; 002, 等等… \\d 匹配一個數字字元。等價於[0-9]。注意Unicode正規表示式會匹配全形數字字元。 \\D 匹配一個非數字字元。等價於[^0-9]。 \\f 匹配一個換頁符。等價於\\x0c和\\cL。 \\n 匹配一個換行符。等價於\\x0a和\\cJ。 \\r 匹配一個回車字元。等價於\\x0d和\\cM。 \\s 匹配任何空白字元，包括空格、制表符、換頁符等等。等價於[ \\f\\n\\r\\t\\v]。注意Unicode正規表示式會匹配全形空格符。 \\S 匹配任何非空白字元。等價於[^ \\f\\n\\r\\t\\v]。 \\t 匹配一個制表符。等價於\\x09和\\cI。 \\v 匹配一個垂直制表符。等價於\\x0b和\\cK。 \\w 匹配包括底線的任何單詞字元。等價於「[A-Za-z0-9_]」。注意Unicode正規表示式會匹配中文字元。 \\W 匹配任何非單詞字元。等價於「[^A-Za-z0-9_]」。 \\xnn 十六進位跳脫字元序列。匹配兩個十六進位數字nn表示的字元。例如，「\\x41」匹配「A」。「\\x041」則等價於「\\x04&amp;1」。正規表達式中可以使用ASCII編碼。. \\num 向後參照(back-reference)一個子字串(substring)，該子字串與正規表示式的第num個用括號圍起來的捕捉群(capture group)子表達式(subexpression)匹配。其中num是從1開始的十進位正整數，其上限可能是9[註 2]、31[註 3]、99甚至無限[註 4]。例如：「(.)\\1」匹配兩個連續的相同字元。 \\n 標識一個八進位跳脫值或一個向後參照。如果\\n之前至少n個取得的子表達式，則n為向後參照。否則，如果n為八進位數字(0-7)，則n為一個八進位跳脫值。 \\nm 3位八進位數字，標識一個八進位跳脫值或一個向後參照。如果\\nm之前至少有nm個獲得子表達式，則nm為向後參照。如果\\nm之前至少有n個取得，則n為一個後跟文字m的向後參照。如果前面的條件都不滿足，若n和m均為八進位數字(0-7)，則\\nm將匹配八進位跳脫值nm。 \\nml 如果n為八進位數字(0-3)，且m和l均為八進位數字(0-7)，則匹配八進位跳脫值nml。 \\un Unicode跳脫字元序列。其中n是一個用四個十六進位數字表示的Unicode字元。例如，\\u00A9匹配著作權符號(©)。 基礎正規表達式字符彙整 RE 字符 意義與範例 ^word 意義：待搜尋的字串(word)在行首！ 範例：搜尋行首為 # 開始的那一行，並列出行號 grep -n &#39;^#&#39; regular_express.txt word$ 意義：待搜尋的字串(word)在行尾！ 範例：將行尾為 ! 的那一行打印出來，並列出行號 grep -n &#39;!$&#39; regular_express.txt . 意義：代表“一定有一個任意字符”的字符！ 範例：搜尋的字串可以是 (eve) (eae) (eee) (e e)， 但不能僅有 (ee) ！亦即 e 與 e 中間“一定”僅有一個字符，而空白字符也是字符！ grep -n &#39;e.e&#39; regular_express.txt \\ 意義：跳脫字符，將特殊符號的特殊意義去除！ 範例：搜尋含有單引號 ‘ 的那一行！ grep -n \\&#39; regular_express.txt * 意義：重複零個到無窮多個的前一個 RE 字符 範例：找出含有 (es) (ess) (esss) 等等的字串，注意，因為 可以是 0 個，所以 es 也是符合帶搜尋字串。另外，因為 為重複“前一個 RE 字符”的符號， 因此，在 之前必須要緊接著一個 RE 字符喔！例如任意字符則為 “.” ！ grep -n &#39;ess*&#39; regular_express.txt [list] 意義：字符集合的 RE 字符，裡面列出想要擷取的字符！ 範例：搜尋含有 (gl) 或 (gd) 的那一行，需要特別留意的是，在 [] 當中“謹代表一個待搜尋的字符”， 例如“ a[afl]y ”代表搜尋的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思！ grep -n &#39;g[ld]&#39; regular_express.txt [n1-n2] 意義：字符集合的 RE 字符，裡面列出想要擷取的字符範圍！ 範例：搜尋含有任意數字的那一行！需特別留意，在字符集合 [] 中的減號 - 是有特殊意義的，他代表兩個字符之間的所有連續字符！但這個連續與否與 ASCII 編碼有關，因此，你的編碼需要設置正確(在 bash 當中，需要確定 LANG 與 LANGUAGE 的變量是否正確！) 例如所有大寫字符則為 [A-Z] grep -n &#39;[A-Z]&#39; regular_express.txt [^list] 意義：字符集合的 RE 字符，裡面列出不要的字串或範圍！ 範例：搜尋的字串可以是 (oog) (ood) 但不能是 (oot) ，那個 ^ 在 [] 內時，代表的意義是“反向選擇”的意思。 例如，我不要大寫字符，則為 [^A-Z]。但是，需要特別注意的是，如果以 grep -n [^A-Z] regular_express.txt 來搜尋，卻發現該文件內的所有行都被列出，為什麼？因為這個 [^A-Z] 是“非大寫字符”的意思， 因為每一行均有非大寫字符，例如第一行的 “Open Source” 就有 p,e,n,o…. 等等的小寫字 grep -n &#39;oo[^t]&#39; regular_express.txt {n,m} 意義：連續 n 到 m 個的“前一個 RE 字符” 意義：若為 {n} 則是連續 n 個的前一個 RE 字符， 意義：若是 {n,} 則是連續 n 個以上的前一個 RE 字符！ 範例：在 g 與 g 之間有 2 個到 3 個的 o 存在的字串，亦即 (goog)(gooog) grep -n &#39;go\\{2,3\\}g&#39; regular_express.txt 範例驗證密碼條件如下： 8~16字元 至少一個數字 至少一個小寫英文字母 或 大寫英文字母 至少要有一個特殊符號, 特殊符號限制在 @$%^&amp; 這些當中, 不然可能會出現 ∆©ƒ 這種符號, 使用者想像力無限 正則如下：^(?=.*[a-z]|.*[A-Z])(?=.*[\\d])(?=.*[\\W])[\\w@$%\\^&amp;]&#123;8,16&#125;$ 第一個規則為 lookahead, 目標搜尋至少一個大寫字母或小寫字母, 因為前面加了 .*, 所以就算 lookahead 的前面是空的也沒關係, 從起始處開始往後搜尋, 需符合第一個 lookahead ?= 之後的規則, 若沒找到則停止, 找到則繼續下一個規則 開始第二個 lookahead 規則, 目標尋找至少一個數字, 第一個規則通過後, 才會開始第二個規則。 第二個規則從起始處開始搜尋, 若無找到則停止, 有找到則繼續 第三個 lookahead 規則, 目標尋找至少一個特殊字符, 行為同上 三個規則都通過後, 驗證最後一個規則, 字串可以是大小寫以及有列出的特殊符號, 數量為 8~16 個字元 crontab安裝 CentOSyum install cronie 代表意義 代表意義 分鐘 小時 日期 月份 周 指令 數字範圍 0-59 0-23 1-31 1-1 0-7 呀就指令啊 比較有趣的是那個“周”喔！周的數字為 0 或 7 時，都代表“星期天”的意思！另外，還有一些輔助的字符，大概有下面這些： 特殊字符 代表意義 *(星號) 代表任何時刻都接受的意思！舉例來說，範例一內那個日、月、周都是 * ， 就代表著“不論何月、何日的禮拜幾的 12:00 都執行後續指令”的意思！ ,(逗號) 代表分隔時段的意思。舉例來說，如果要下達的工作是 3:00 與 6:00 時，就會是： 0 3,6 * * * command 時間參數還是有五欄，不過第二欄是 3,6 ，代表 3 與 6 都適用！ -(減號) 代表一段時間範圍內，舉例來說， 8 點到 12 點之間的每小時的 20 分都進行一項工作：20 8-12 * * * command仔細看到第二欄變成 8-12 喔！代表 8,9,10,11,12 都適用的意思！ /n(斜線) 那個 n 代表數字，亦即是“每隔 n 單位間隔”的意思，例如每五分鐘進行一次，則：*/5 * * * * command很簡單吧！用 * 與 /5 來搭配，也可以寫成 0-59/5 ，相同意思！ /etc/crontab[root@study ~]# cat /etc/crontabSHELL=/bin/bash &lt;==使用哪種 shell 接口PATH=/sbin:/bin:/usr/sbin:/usr/bin &lt;==可執行文件搜尋路徑MAILTO=root &lt;==若有額外STDOUT，以 email將數據送給誰# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed MAILTO=root： 當 /etc/crontab 這個文件中的例行性工作的指令發生錯誤時，或者是該工作的執行結果有 STDOUT/STDERR 時，會將錯誤訊息或者是屏幕顯示的訊息送的對象 默認是由系統直接寄發一封 mail 給 root 例如：MAILTO=dmtsai@my.host.name PATH=….：輸入可執行文件的搜尋路徑，使用默認的路徑設置就已經很足夠了！ “分 時 日 月 周 身份 指令”七個字段的設置 這個 /etc/crontab 可以設置的基本語法與 crontab -e 不太相同 前面同樣是分、時、日、月、週五個字段， 但是在五個字段後面接的並不是指令，就是“執行後面那串指令的身份” 這與使用者的 crontab -e 不相同。由於使用者自己的 crontab 並不需要指定身份 crond 服務讀取配置文件/etc/crontab/etc/cron.d/*/var/spool/cron/* 跟系統的運行比較有關係的兩個配置文件是放在 /etc/crontab 文件內以及 /etc/cron.d/* 目錄內的文件 跟用戶自己的工作比較有關的配置文件放在 /var/spool/cron/ 其他 輸入 crontab job crontab -e 確認 crontab 狀態 /etc/init.d/cron status 停止 crontab /etc/init.d/cron stop 啟動 crontab /etc/init.d/cron start anacron語法[root@study ~]# anacron [-sfn] [job]..[root@study ~]# anacron -u [job]..選項與參數：-s ：開始一連續的執行各項工作 (job)，會依據時間記錄文件的數據判斷是否進行；-f ：強制進行，而不去判斷時間記錄文件的時間戳記；-n ：立刻進行未進行的任務，而不延遲 (delay) 等待時間；-u ：僅更新時間記錄文件的時間戳記，不進行任何工作。job ：由 /etc/anacrontab 定義的各項工作名稱。 配置檔[root@study ~]# cat /etc/anacrontabSHELL=/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=rootRANDOM_DELAY=45 # 隨機給予最大延遲時間，單位是分鐘START_HOURS_RANGE=3-22 # 延遲多少個小時內應該要執行的任務時間1 5 cron.daily nice run-parts /etc/cron.daily7 25 cron.weekly nice run-parts /etc/cron.weekly@monthly 45 cron.monthly nice run-parts /etc/cron.monthly天數 延遲時間 工作名稱定義 實際要進行的指令串# 天數單位為天；延遲時間單位為分鐘；工作名稱定義可自訂，指令串則通常與 crontab 的設置相同！[root@study ~]# more /var/spool/anacron/*::::::::::::::/var/spool/anacron/cron.daily::::::::::::::20150731::::::::::::::/var/spool/anacron/cron.monthly::::::::::::::20150703::::::::::::::/var/spool/anacron/cron.weekly::::::::::::::20150727# 上面則是三個工作名稱的時間記錄文件以及記錄的時間戳記 拿 /etc/cron.daily/ 那一行的設置來說明，那四個字段的意義分別是： 天數：anacron 執行當下與時間戳記 (/var/spool/anacron/ 內的時間紀錄檔) 相差的天數，若超過此天數，就準備開始執行，若沒有超過此天數，則不予執行後續的指令。 延遲時間：若確定超過天數導致要執行調度工作了，那麼請延遲執行的時間，因為擔心立即啟動會有其他資源衝突的問題吧！ 工作名稱定義：這個沒啥意義，就只是會在 /var/log/cron 裡頭記載該項任務的名稱這樣！通常與後續的目錄資源名稱相同即可。 實際要進行的指令串：有沒有跟 0hourly 很像啊！沒錯！相同的作法啊！通過 run-parts 來處理的！ anacron 的執行流程(以 cron.daily 為例) 由 /etc/anacrontab 分析到 cron.daily 這項工作名稱的天數為 1 天； 由 /var/spool/anacron/cron.daily 取出最近一次執行 anacron 的時間戳記； 由上個步驟與目前的時間比較，若差異天數為 1 天以上 (含 1 天)，就準備進行指令； 若準備進行指令，根據 /etc/anacrontab 的設置，將延遲 5 分鐘 + 3 小時 (看 START_HOURS_RANGE 的設置)； 延遲時間過後，開始執行後續指令，亦即“ run-parts /etc/cron.daily ”這串指令；執行完畢後， anacron 程序結束。 如此一來，放置在 /etc/cron.daily/ 內的任務就會在一天後一定會被執行的！ 因為 anacron 是每個小時被執行一次嘛！ 所以如果隔了一陣子將 CentOS 開機，開機過後約 1 小時左右系統會有一小段時間的忙碌！硬盤會跑個不停！那就是因為 anacron 正在執行過去 /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/ 裡頭的未進行的各項工作調度 cron 與 anacron 與目錄之間的關係 crond 會主動去讀取 /etc/crontab, /var/spool/cron/, /etc/cron.d/ 等配置文件，並依據“分、時、日、月、周”的時間設置去各項工作調度； 根據 /etc/cron.d/0hourly 的設置，主動去 /etc/cron.hourly/ 目錄下，執行所有在該目錄下的可執行文件； 因為 /etc/cron.hourly/0anacron 這個指令檔的緣故，主動的每小時執行 anacron ，並調用 /etc/anacrontab 的配置文件； 根據 /etc/anacrontab 的設置，依據每天、每週、每月去分析 /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/ 內的可執行文件，以進行固定週期需要執行的指令。 如果你每個週日的需要執行的動作是放置於 /etc/crontab 的話，那麼該動作只要過期了就過期了，並不會被抓回來重新執行。 如果是放置在 /etc/cron.weekly/ 目錄下，那麼該工作就會定期，幾乎一定會在一週內執行一次 test 測試的標誌 代表意義 1. 關於某個文件名的“文件類型”判斷，如 test -e filename 表示存在否 -e 該“文件名”是否存在？(常用) -f 該“文件名”是否存在且為文件(file)？(常用) -d 該“文件名”是否存在且為目錄(directory)？(常用) -b 該“文件名”是否存在且為一個 block device 設備？ -c 該“文件名”是否存在且為一個 character device 設備？ -S 該“文件名”是否存在且為一個 Socket 文件？ -p 該“文件名”是否存在且為一個 FIFO (pipe) 文件？ -L 該“文件名”是否存在且為一個鏈接文件？ 2. 關於文件的權限偵測，如 test -r filename 表示可讀否 (但 root 權限常有例外) -r 偵測該文件名是否存在且具有“可讀”的權限？ -w 偵測該文件名是否存在且具有“可寫”的權限？ -x 偵測該文件名是否存在且具有“可執行”的權限？ -u 偵測該文件名是否存在且具有“SUID”的屬性？ -g 偵測該文件名是否存在且具有“SGID”的屬性？ -k 偵測該文件名是否存在且具有“Sticky bit”的屬性？ -s 偵測該文件名是否存在且為“非空白文件”？ 3. 兩個文件之間的比較，如： test file1 -nt file2 -nt (newer than)判斷 file1 是否比 file2 新 -ot (older than)判斷 file1 是否比 file2 舊 -ef 判斷 file1 與 file2 是否為同一文件，可用在判斷 hard link 的判定上。 主要意義在判定，兩個文件是否均指向同一個 inode 哩！ 4. 關於兩個整數之間的判定，例如 test n1 -eq n2 -eq 兩數值相等 (equal) -ne 兩數值不等 (not equal) -gt n1 大於 n2 (greater than) -lt n1 小於 n2 (less than) -ge n1 大於等於 n2 (greater than or equal) -le n1 小於等於 n2 (less than or equal) 5. 判定字串的數據 test -z string 判定字串是否為 0 ？若 string 為空字串，則為 true test -n string 判定字串是否非為 0 ？若 string 為空字串，則為 false。 -n 亦可省略 test str1 == str2 判定 str1 是否等於 str2 ，若相等，則回傳 true test str1 != str2 判定 str1 是否不等於 str2 ，若相等，則回傳 false 6. 多重條件判定，例如： test -r filename -a -x filename -a (and)兩狀況同時成立！例如 test -r file -a -x file，則 file 同時具有 r 與 x 權限時，才回傳 true。 -o (or)兩狀況任何一個成立！例如 test -r file -o -x file，則 file 具有 r 或 x 權限時，就可回傳 true。 ! 反相狀態，如 test ! -x file ，當 file 不具有 x 時，回傳 true 變量變量的設置 變量設置方式 str 沒有設置 str 為空字串 str 已設置非為空字串 var=${str-expr} var=expr var= var=$str var=${str:-expr} var=expr var=expr var=$str var=${str+expr} var= var=expr var=expr var=${str:+expr} var= var= var=expr var=${str=expr} str=expr var=expr var=expr var= str 不變 var=$str var=${str:=expr} str=expr var=expr str=expr var=expr str 不變 var=$str var=${str?expr} expr 輸出至 stderr var= var=$str var=${str:?expr} expr 輸出至 stderr expr 輸出至 stderr var=$str Script 變量帶入規則： script 名稱，如 /path/to/scriptname opt1 opt2 opt3 opt4 $0 $1 $2 $3 $4 可以在 script 裡面使用的特殊變量$# ：代表後接的參數“個數”，以上表為例這裡顯示為“ 4 ”；$@ ：代表“ “$1” “$2” “$3” “$4” ”之意，每個變量是獨立的(用雙引號括起來)；$* ：代表“ “$1c$2c$3c$4” ”，其中 c 為分隔字符，默認為空白鍵， 所以本例中代表“ “$1 $2 $3 $4” ”之意。 條件判斷單一判斷式if [ 條件判斷式 ]; then 當條件判斷式成立時，可以進行的指令工作內容；fi &lt;==將 if 反過來寫，就成為 fi 啦！結束 if 之意！ 以下 test 的方式可改編成條件判斷式 test 方式read -p \"Please input (Y/N): \" yn[ \"$&#123;yn&#125;\" == \"Y\" -o \"$&#123;yn&#125;\" == \"y\" ] &amp;&amp; echo \"OK, continue\" &amp;&amp; exit 0[ \"$&#123;yn&#125;\" == \"N\" -o \"$&#123;yn&#125;\" == \"n\" ] &amp;&amp; echo \"Oh, interrupt!\" &amp;&amp; exit 0echo \"I don't know what your choice is\" &amp;&amp; exit 0 條件判斷式PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p \"Please input (Y/N): \" ynif [ \"$&#123;yn&#125;\" == \"Y\" ] || [ \"$&#123;yn&#125;\" == \"y\" ]; then echo \"OK, continue\" exit 0fiif [ \"$&#123;yn&#125;\" == \"N\" ] || [ \"$&#123;yn&#125;\" == \"n\" ]; then echo \"Oh, interrupt!\" exit 0fiecho \"I don't know what your choice is\" &amp;&amp; exit 0 多重、複雜條件判斷式一個條件判斷，分成功進行與失敗進行 (else)if [ 條件判斷式 ]; then 當條件判斷式成立時，可以進行的指令工作內容；else 當條件判斷式不成立時，可以進行的指令工作內容；fi 多個條件判斷 (if … elif … elif … else) 分多種不同情況執行if [ 條件判斷式一 ]; then 當條件判斷式一成立時，可以進行的指令工作內容；elif [ 條件判斷式二 ]; then 當條件判斷式二成立時，可以進行的指令工作內容；else 當條件判斷式一與二均不成立時，可以進行的指令工作內容；fi 將以下的 test 方式改成條件判斷式 改前:read -p \"Please input (Y/N): \" yn[ \"$&#123;yn&#125;\" == \"Y\" -o \"$&#123;yn&#125;\" == \"y\" ] &amp;&amp; echo \"OK, continue\" &amp;&amp; exit 0[ \"$&#123;yn&#125;\" == \"N\" -o \"$&#123;yn&#125;\" == \"n\" ] &amp;&amp; echo \"Oh, interrupt!\" &amp;&amp; exit 0echo \"I don't know what your choice is\" &amp;&amp; exit 0 改後:#!/bin/bash# Program:# This program shows the user's choice# History:# 2015/07/16 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p \"Please input (Y/N): \" ynif [ \"$&#123;yn&#125;\" == \"Y\" ] || [ \"$&#123;yn&#125;\" == \"y\" ]; then echo \"OK, continue\"elif [ \"$&#123;yn&#125;\" == \"N\" ] || [ \"$&#123;yn&#125;\" == \"n\" ]; then echo \"Oh, interrupt!\"else echo \"I don't know what your choice is\"fi 利用 case ….. esac 判斷 語法： case $變量名稱 in &lt;==關鍵字為 case ，還有變量前有錢字號 &quot;第一個變量內容&quot;) &lt;==每個變量內容建議用雙引號括起來，關鍵字則為小括號 ) 程序段 ;; &lt;==每個類別結尾使用兩個連續的分號來處理！ &quot;第二個變量內容&quot;) 程序段 ;; *) &lt;==最後一個變量內容都會用 * 來代表所有其他值 不包含第一個變量內容與第二個變量內容的其他程序執行段 exit 1 ;;esac &lt;==最終的 case 結尾！“反過來寫”思考一下！ 範例： #!/bin/bash# Program:# Show \"Hello\" from $1.... by using case .... esac# History:# 2015/07/16 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHcase $&#123;1&#125; in \"hello\") echo \"Hello, how are you ?\" ;; \"\") echo \"You MUST input parameters, ex&gt; &#123;$&#123;0&#125; someword&#125;\" ;; *) # 其實就相當於萬用字符，0~無窮多個任意字符之意！ echo \"Usage $&#123;0&#125; &#123;hello&#125;\" ;;esac 練習題使用判斷式寫一個 script, 要可以做到以下幾件事： 先讓使用者輸入他們的退伍日期； 驗證輸入格式； 由兩個日期的比較來顯示“還需要幾天”才能夠退伍的字樣。 解答如下：#!/bin/bash# Program:# You input your demobilization date, I calculate how many days before you demobilize.# History:# 2015/07/16 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH# 1. 告知使用者這支程序的用途，並且告知應該如何輸入日期格式？echo \"This program will try to calculate :\"echo \"How many days before your demobilization date...\"read -p \"Please input your demobilization date (YYYYMMDD ex&gt;20150716): \" date2# 2. 測試一下，這個輸入的內容是否正確？利用正則表達式囉～date_d=$(echo $&#123;date2&#125; |grep '[0-9]\\&#123;8\\&#125;') # 看看是否有八個數字if [ \"$&#123;date_d&#125;\" == \"\" ]; then echo \"You input the wrong date format....\" exit 1fi# 3. 開始計算日期囉～declare -i date_dem=$(date --date=\"$&#123;date2&#125;\" +%s) # 退伍日期秒數declare -i date_now=$(date +%s) # 現在日期秒數declare -i date_total_s=$(($&#123;date_dem&#125;-$&#123;date_now&#125;)) # 剩餘秒數統計declare -i date_d=$(($&#123;date_total_s&#125;/60/60/24)) # 轉為日數if [ \"$&#123;date_total_s&#125;\" -lt \"0\" ]; then # 判斷是否已退伍 echo \"You had been demobilization before: \" $((-1*$&#123;date_d&#125;)) \" ago\"else declare -i date_h=$(($(($&#123;date_total_s&#125;-$&#123;date_d&#125;*60*60*24))/60/60)) echo \"You will demobilize after $&#123;date_d&#125; days and $&#123;date_h&#125; hours.\"fi netstat這個指令可以看到目前有哪些 port 是對外開放的, 有哪些是 Listen 的 語法netstat -[atunlp]選項與參數：-a ：將目前系統上所有的連線、監聽、Socket 數據都列出來-t ：列出 tcp 網絡封包的數據-u ：列出 udp 網絡封包的數據-n ：不以程序的服務名稱，以埠號 (port number) 來顯示；-l ：列出目前正在網絡監聽 (listen) 的服務；-p ：列出該網絡服務的程序 PID 範例列出目前的路由表狀態，且以 IP 及 port number 顯示：[root@www ~]# netstat -rnKernel IP routing tableDestination Gateway Genmask Flags MSS Window irtt Iface192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 0 0 0 eth00.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0# 其實這個參數就跟 route -n 一模一樣，對吧！這不是 netstat 的主要功能啦！ 列出目前的所有網路連線狀態，使用 IP 與 port number[root@www ~]# netstat -anActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State....(中間省略)....tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTENtcp 0 52 192.168.1.100:22 192.168.1.101:1937 ESTABLISHED tcp 0 0 :::22 :::* LISTEN....(中間省略)....Active UNIX domain sockets (servers and established)Proto RefCnt Flags Type State I-Node Pathunix 2 [ ACC ] STREAM LISTENING 11075 @/var/run/hald/dbus-uukdg1qMPhunix 2 [ ACC ] STREAM LISTENING 10952 /var/run/dbus/system_bus_socketunix 2 [ ACC ] STREAM LISTENING 11032 /var/run/acpid.socket....(底下省略).... function語法：function fname() &#123; 程序段 注意： 因為 shell script 的執行方式是由上而下，由左而右， 因此在 shell script 當中的 function 的設置一定要在程序的最前面 function 內也可置變量，但跟 shell script 的內置變量方式不同 範例： 一般 #!/bin/bash# Program:# Use function to repeat information.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHfunction printit()&#123; echo -n \"Your choice is \" # 加上 -n 可以不斷行繼續在同一行顯示&#125;echo \"This program will print your selection !\"case $&#123;1&#125; in \"one\") printit; echo $&#123;1&#125; | tr 'a-z' 'A-Z' # 將參數做大小寫轉換！ ;; \"two\") printit; echo $&#123;1&#125; | tr 'a-z' 'A-Z' ;; \"three\") printit; echo $&#123;1&#125; | tr 'a-z' 'A-Z' ;; *) echo \"Usage $&#123;0&#125; &#123;one|two|three&#125;\" ;;esac 內置變量#!/bin/bash# Program:# Use function to repeat information.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHfunction printit()&#123; echo \"Your choice is $&#123;1&#125;\" # 這個 $1 必須要參考下面指令的下達&#125;echo \"This program will print your selection !\"case $&#123;1&#125; in \"one\") printit 1 # 請注意， printit 指令後面還有接參數！ ;; \"two\") printit 2 ;; \"three\") printit 3 ;; *) echo \"Usage $&#123;0&#125; &#123;one|two|three&#125;\" ;;esac loopwhile do done, until do done (不定循環)while do done語法while [ condition ] &lt;==中括號內的狀態就是判斷式do &lt;==do 是循環的開始！ 程序段落done &lt;==done 是循環的結束 範例#!/bin/bash# Program:# Repeat question until user input correct answer.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHwhile [ \"$&#123;yn&#125;\" != \"yes\" -a \"$&#123;yn&#125;\" != \"YES\" ]do read -p \"Please input yes/YES to stop this program: \" yndoneecho \"OK! you input the correct answer.\" #!/bin/bash# Program:# Use loop to calculate \"1+2+3+...+100\" result.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHs=0 # 這是加總的數值變量i=0 # 這是累計的數值，亦即是 1, 2, 3....while [ \"$&#123;i&#125;\" != \"100\" ]do i=$(($i+1)) # 每次 i 都會增加 1 s=$(($s+$i)) # 每次都會加總一次！doneecho \"The result of '1+2+3+...+100' is ==&gt; $s\" until do done語法until [ condition ]do 程序段落done 範例#!/bin/bash# Program:# Repeat question until user input correct answer.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHuntil [ \"$&#123;yn&#125;\" == \"yes\" -o \"$&#123;yn&#125;\" == \"YES\" ]do read -p \"Please input yes/YES to stop this program: \" yndoneecho \"OK! you input the correct answer.\" for…do…done (固定循環)語法for var in con1 con2 con3 ...do 程序段done 範例 假設我有三種動物，分別是 dog, cat, elephant 三種， 我想每一行都輸出這樣：“There are dogs…”之類的字樣，則可以： #!/bin/bash# Program:# Using for .... loop to print 3 animals# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHfor animal in dog cat elephantdo echo \"There are $&#123;animal&#125;s.... \"done 系統上面的各種帳號都是寫在 /etc/passwd 內的第一個字段，所以請通過管線命令的 cut 捉出單純的帳號名稱後，以 id 分別檢查使用者的識別碼與特殊參數 #!/bin/bash# Program# Use id, finger command to check system account's information.# History# 2015/07/17 VBird first releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHusers=$(cut -d ':' -f1 /etc/passwd) # 擷取帳號名稱for username in $&#123;users&#125; # 開始循環進行！do id $&#123;username&#125;done 讓使用者輸入某個目錄文件名， 然後我找出某目錄內的文件名的權限 #!/bin/bash# Program:# User input dir name, I find the permission of files.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH# 1. 先看看這個目錄是否存在啊？read -p \"Please input a directory: \" dirif [ \"$&#123;dir&#125;\" == \"\" -o ! -d \"$&#123;dir&#125;\" ]; then echo \"The $&#123;dir&#125; is NOT exist in your system.\" exit 1fi# 2. 開始測試文件囉～filelist=$(ls $&#123;dir&#125;) # 列出所有在該目錄下的文件名稱for filename in $&#123;filelist&#125;do perm=\"\" test -r \"$&#123;dir&#125;/$&#123;filename&#125;\" &amp;&amp; perm=\"$&#123;perm&#125; readable\" test -w \"$&#123;dir&#125;/$&#123;filename&#125;\" &amp;&amp; perm=\"$&#123;perm&#125; writable\" test -x \"$&#123;dir&#125;/$&#123;filename&#125;\" &amp;&amp; perm=\"$&#123;perm&#125; executable\" echo \"The file $&#123;dir&#125;/$&#123;filename&#125;'s permission is $&#123;perm&#125; \"done for…do…done 的數值處理語法- 初始值：某個變量在循環當中的起始值，直接以類似 i=1 設置好； - 限制值：當變量的值在這個限制值的範圍內，就繼續進行循環。例如 i&lt;=100； - 執行步階：每作一次循環時，變量的變化量。例如 i=i+1。 for (( 初始值; 限制值; 執行步階 ))do 程序段done 範例 #!/bin/bash# Program:# Try do calculate 1+2+....+$&#123;your_input&#125;# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHread -p \"Please input a number, I will count for 1+2+...+your_input: \" nus=0for (( i=1; i&lt;=$&#123;nu&#125;; i=i+1 ))do s=$(($&#123;s&#125;+$&#123;i&#125;))doneecho \"The result of '1+2+3+...+$&#123;nu&#125;' is ==&gt; $&#123;s&#125;\" 搭配亂數與陣列的實驗範例#!/bin/bash# Program:# Try do tell you what you may eat.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHeat[1]=\"賣噹噹漢堡包\"eat[2]=\"肯爺爺炸雞\"eat[3]=\"彩虹日式便當\"eat[4]=\"越油越好吃大雅\"eat[5]=\"想不出吃啥學餐\"eat[6]=\"太師父便當\"eat[7]=\"池上便當\"eat[8]=\"懷念火車便當\"eat[9]=\"一起吃方便麵\"eatnum=9eated=0while [ \"$&#123;eated&#125;\" -lt 3 ]; do check=$(( $&#123;RANDOM&#125; * $&#123;eatnum&#125; / 32767 + 1 )) mycheck=0 if [ \"$&#123;eated&#125;\" -ge 1 ]; then for i in $(seq 1 $&#123;eated&#125; ) do if [ $&#123;eatedcon[$i]&#125; == $check ]; then mycheck=1 fi done fi if [ $&#123;mycheck&#125; == 0 ]; then echo \"your may eat $&#123;eat[$&#123;check&#125;]&#125;\" eated=$(( $&#123;eated&#125; + 1 )) eatedcon[$&#123;eated&#125;]=$&#123;check&#125; fidone``` ```bash#!/bin/bash# Program:# Try do tell you what you may eat.# History:# 2015/07/17 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHeat[1]=\"賣噹噹漢堡包\" # 寫下你所收集到的店家！eat[2]=\"肯爺爺炸雞\"eat[3]=\"彩虹日式便當\"eat[4]=\"越油越好吃大雅\"eat[5]=\"想不出吃啥學餐\"eat[6]=\"太師父便當\"eat[7]=\"池上便當\"eat[8]=\"懷念火車便當\"eat[9]=\"一起吃方便麵\"eatnum=9 # 需要輸入有幾個可用的餐廳數！check=$(( $&#123;RANDOM&#125; * $&#123;eatnum&#125; / 32767 + 1 ))echo \"your may eat $&#123;eat[$&#123;check&#125;]&#125;\" loop arrayfor i in &quot;$&#123;array[@]&#125;&quot; shell script 的追蹤與 debug語法sh [-nvx] scripts.sh選項與參數：-n ：不要執行 script，僅查詢語法的問題；-v ：再執行 sccript 前，先將 scripts 的內容輸出到屏幕上；-x ：將使用到的 script 內容顯示到屏幕上，這是很有用的參數！ 範例 測試 dir_perm.sh 有無語法的問題？ sh -n dir_perm.sh 將 show_animal.sh 的執行過程全部列出來～ sh -x show_animal.sh 練習題 請創建一支 script ，當你執行該 script 的時候，該 script 可以顯示： 1. 你目前的身份 (用 whoami ) 2. 你目前所在的目錄 (用 pwd) #!/bin/bashecho -e \"Your name is ==&gt; $(whoami)\"echo -e \"The current directory is ==&gt; $(pwd)\" 請自行創建一支程序，該程序可以用來計算“你還有幾天可以過生日”啊？ #!/bin/bashread -p \"Pleas input your birthday (MMDD, ex&gt; 0709): \" birnow=`date +%m%d`if [ \"$bir\" == \"$now\" ]; thenecho \"Happy Birthday to you!!!\"elif [ \"$bir\" -gt \"$now\" ]; thenyear=`date +%Y`total_d=$(($((`date --date=\"$year$bir\" +%s`-`date +%s`))/60/60/24))echo \"Your birthday will be $total_d later\"elseyear=$((`date +%Y`+1))total_d=$(($((`date --date=\"$year$bir\" +%s`-`date +%s`))/60/60/24))echo \"Your birthday will be $total_d later\"fi 讓使用者輸入一個數字，程序可以由 1+2+3… 一直累加到使用者輸入的數字為止。 #!/bin/bashread -p \"Please input an integer number: \" numberi=0s=0while [ \"$i\" != \"$number\" ]doi=$(($i+1))s=$(($s+$i))doneecho \"the result of '1+2+3+...$number' is ==&gt; $s\" 撰寫一支程序，他的作用是: 1.) 先查看一下 /root/test/logical 這個名稱是否存在； 2.) 若不存在，則創建一個文件，使用 touch 來創建，創建完成後離開； 3.) 如果存在的話，判斷該名稱是否為文件，若為文件則將之刪除後創建一個目錄，文件名為 logical ，之後離開； 4.) 如果存在的話，而且該名稱為目錄，則移除此目錄！ #!/bin/bashif [ ! -e logical ]; thentouch logicalecho \"Just make a file logical\"exit 1elif [ -e logical ] &amp;&amp; [ -f logical ]; thenrm logicalmkdir logicalecho \"remove file ==&gt; logical\"echo \"and make directory logical\"exit 1elif [ -e logical ] &amp;&amp; [ -d logical ]; thenrm -rf logicalecho \"remove directory ==&gt; logical\"exit 1elseecho \"Does here have anything?\"fi 我們知道 /etc/passwd 裡面以 : 來分隔，第一欄為帳號名稱。請寫一隻程序，可以將 /etc/passwd 的第一欄取出，而且每一欄都以一行字串“The 1 account is “root” ”來顯示，那個 1 表示行數。 #!/bin/bashaccounts=`cat /etc/passwd | cut -d':' -f1`for account in $accountsdodeclare -i i=$i+1echo \"The $i account is \\\"$account\\\" \"done /etc/passwd 文件架構 帳號名稱： 需要用來對應 UID, 例如 root 的 UID 對應就是 0 (第三字段) 密碼： 早期 Unix 系統的密碼就是放在這字段上！但是因為這個文件的特性是所有的程序都能夠讀取，這樣一來很容易造成密碼數據被竊取， 因此後來就將這個字段的密碼數據給他改放到 /etc/shadow 中了。所以這裡你會看到一個“ x ” UID: 使用者識別碼！ Linux 對於 UID 有幾個限制: id 範圍 該 ID 使用者特性 0(系統管理員) 當 UID 是 0 時，代表這個帳號是“系統管理員”！ 所以當你要讓其他的帳號名稱也具有 root 的權限時，將該帳號的 UID 改為 0 即可。 這也就是說，一部系統上面的系統管理員不見得只有 root 喔！ 不過，很不建議有多個帳號的 UID 是 0 啦～容易讓系統管理員混亂！ 1~999(系統帳號) 保留給系統使用的 ID，其實除了 0 之外，其他的 UID 權限與特性並沒有不一樣。默認 1000 以下的數字讓給系統作為保留帳號只是一個習慣。 由於系統上面啟動的網絡服務或背景服務希望使用較小的權限去運行，因此不希望使用 root 的身份去執行這些服務， 所以我們就得要提供這些運行中程序的擁有者帳號才行。這些系統帳號通常是不可登陸的， 所以才會有我們在第十章提到的 /sbin/nologin 這個特殊的 shell 存在。 根據系統帳號的由來，通常這類帳號又約略被區分為兩種： 1~200：由 distributions 自行創建的系統帳號； 201~999：若使用者有系統帳號需求時，可以使用的帳號 UID。 1000~60000(可登陸帳號) 給一般使用者用的。事實上，目前的 linux 核心 (3.10.x 版)已經可以支持到 4294967295 (2^32-1) 這麼大的 UID 號碼喔！ GID： 這個與 /etc/group 有關！其實 /etc/group 的觀念與 /etc/passwd 差不多，只是他是用來規範群組名稱與 GID 的對應而已！ 使用者信息說明欄： 這個字段基本上並沒有什麼重要用途，只是用來解釋這個帳號的意義而已！不過，如果您提供使用 finger 的功能時， 這個字段可以提供很多的訊息呢！本章後面的 chfn 指令會來解釋這裡的說明。 主文件夾： 這是使用者的主文件夾，以上面為例， root 的主文件夾在 /root ，所以當 root 登陸之後，就會立刻跑到 /root 目錄裡頭啦！呵呵！ 如果你有個帳號的使用空間特別的大，你想要將該帳號的主文件夾移動到其他的硬盤去該怎麼作？ 沒有錯！可以在這個字段進行修改呦！默認的使用者主文件夾在 /home/yourIDname Shell： 我們在第十章 BASH 提到很多次，當使用者登陸系統後就會取得一個 Shell 來與系統的核心溝通以進行使用者的操作任務。那為何默認 shell 會使用 bash 呢？就是在這個字段指定的囉！ 這裡比較需要注意的是，有一個 shell 可以用來替代成讓帳號無法取得 shell 環境的登陸動作！那就是 /sbin/nologin 這個東西！這也可以用來製作純 pop 郵件帳號者的數據呢！ /etc/shadow 文件結構 帳號名稱：由於密碼也需要與帳號對應啊～因此，這個文件的第一欄就是帳號，必須要與 /etc/passwd 相同才行！ 密碼：這個字段內的數據才是真正的密碼，而且是經過編碼的密碼 (加密) 啦！ 你只會看到有一些特殊符號的字母就是了！需要特別留意的是，雖然這些加密過的密碼很難被解出來， 但是“很難”不等於“不會”，所以，這個文件的默認權限是“-rw——-”或者是“———-”，亦即只有 root 才可以讀寫就是了！你得隨時注意，不要不小心更動了這個文件的權限呢！另外，由於各種密碼編碼的技術不一樣，因此不同的編碼系統會造成這個字段的長度不相同。 舉例來說，舊式的 DES, MD5 編碼系統產生的密碼長度就與目前慣用的 SHA 不同[2]！SHA 的密碼長度明顯的比較長些。由於固定的編碼系統產生的密碼長度必須一致，因此“當你讓這個字段的長度改變後，該密碼就會失效(算不出來)”。 很多軟件通過這個功能，在此字段前加上 ! 或 * 改變密碼字段長度，就會讓密碼“暫時失效”了。 最近更動密碼的日期：這個字段記錄了“更動密碼那一天”的日期，不過，很奇怪呀！在我的例子中怎麼會是 16559 呢？呵呵，這個是因為計算 Linux 日期的時間是以 1970 年 1 月 1 日作為 1 而累加的日期，1971 年 1 月 1 日則為 366 啦！ 得注意一下這個數據呦！上述的 16559 指的就是 2015-05-04 那一天啦！瞭解乎？ 而想要了解該日期可以使用本章後面 chage 指令的幫忙！至於想要知道某個日期的累積日數， 可使用如下的程序計算： echo $(($(date --date=\"2015/05/04\" +%s)/86400+1)) 上述指令中，2015/05/04 為你想要計算的日期，86400 為每一天的秒數， %s 為 1970/01/01 以來的累積總秒數。 由於 bash 僅支持整數，因此最終需要加上 1 補齊 1970/01/01 當天。 密碼不可被更動的天數：(與第 3 字段相比)第四個字段記錄了：這個帳號的密碼在最近一次被更改後需要經過幾天才可以再被變更！如果是 0 的話， 表示密碼隨時可以更動的意思。這的限制是為了怕密碼被某些人一改再改而設計的！如果設置為 20 天的話，那麼當你設置了密碼之後， 20 天之內都無法改變這個密碼呦！ 密碼需要重新變更的天數：(與第 3 字段相比)經常變更密碼是個好習慣！為了強制要求使用者變更密碼，這個字段可以指定在最近一次更改密碼後， 在多少天數內需要再次的變更密碼才行。你必須要在這個天數內重新設置你的密碼，否則這個帳號的密碼將會“變為過期特性”。 而如果像上面的 99999 (計算為 273 年) 的話，那就表示，呵呵，密碼的變更沒有強制性之意。 密碼需要變更期限前的警告天數：(與第 5 字段相比)當帳號的密碼有效期限快要到的時候 (第 5 字段)，系統會依據這個字段的設置，發出“警告”言論給這個帳號，提醒他“再過 n 天你的密碼就要過期了，請儘快重新設置你的密碼呦！”，如上面的例子，則是密碼到期之前的 7 天之內，系統會警告該用戶。 密碼過期後的帳號寬限時間(密碼失效日)：(與第 5 字段相比)密碼有效日期為“更新日期(第3字段)”+“重新變更日期(第5字段)”，過了該期限後使用者依舊沒有更新密碼，那該密碼就算過期了。 雖然密碼過期但是該帳號還是可以用來進行其他工作的，包括登陸系統取得 bash 。不過如果密碼過期了， 那當你登陸系統時，系統會強制要求你必須要重新設置密碼才能登陸繼續使用喔，這就是密碼過期特性。 帳號失效日期：這個日期跟第三個字段一樣，都是使用 1970 年以來的總日數設置。這個字段表示： 這個帳號在此字段規定的日期之後，將無法再使用。 就是所謂的“帳號失效”，此時不論你的密碼是否有過期，這個“帳號”都不能再被使用！ 這個字段會被使用通常應該是在“收費服務”的系統中，你可以規定一個日期讓該帳號不能再使用啦！ 保留：最後一個字段是保留的，看以後有沒有新功能加入。 範例假如我的使用者的密碼欄如下所示： dmtsai:$6$M4IphgNP2TmlXaSS$B418YFroYxxmm....:16559:5:60:7:5:16679: 由於密碼幾乎僅能單向運算(由明碼計算成為密碼，無法由密碼反推回明碼)，因此由上表的數據我們無法得知 dmstai 的實際密碼明文 (第二個字段)； 此帳號最近一次更動密碼的日期是 2015/05/04 (16559)； 能夠再次修改密碼的時間是 5 天以後，也就是 2015/05/09 以前 dmtsai 不能修改自己的密碼；如果使用者還是嘗試要更動自己的密碼，系統就會出現這樣的訊息： You must wait longer to change your passwordpasswd: Authentication token manipulation error畫面中告訴我們：你必須要等待更久的時間才能夠變更密碼之意啦！ 由於密碼過期日期定義為 60 天后，亦即累積日數為： 16559+60=16619，經過計算得到此日數代表日期為 2015/07/03。 這表示：“使用者必須要在 2015/05/09 (前 5 天不能改) 到 2015/07/03 之間的 60 天限制內去修改自己的密碼，若 2015/07/03 之後還是沒有變更密碼時，該密碼就宣告為過期”了！ 警告日期設為 7 天，亦即是密碼過期日前的 7 天，在本例中則代表 2015/06/26 ~ 2015/07/03 這七天。 如果使用者一直沒有更改密碼，那麼在這 7 天中，只要 dmtsai 登陸系統就會發現如下的訊息：Warning: your password will expire in 5 days 如果該帳號一直到 2015/07/03 都沒有更改密碼，那麼密碼就過期了。但是由於有 5 天的寬限天數， 因此 dmtsai 在 2015/07/08 前都還可以使用舊密碼登陸主機。 不過登陸時會出現強制更改密碼的情況，畫面有點像下面這樣： You are required to change your password immediately (password aged)WARNING: Your password has expired.You must change your password now and login again!Changing password for user dmtsai.Changing password for dmtsai(current) UNIX password: 你必須要輸入一次舊密碼以及兩次新密碼後，才能夠開始使用系統的各項資源。如果你是在 2015/07/08 以後嘗試以 dmtsai 登陸的話，那麼就會出現如下的錯誤訊息且無法登陸，因為此時你的密碼就失效去啦！ Your account has expired; please contact your system administrator 如果使用者在 2015/07/03 以前變更過密碼，那麼第 3 個字段的那個 16559 的天數就會跟著改變，因此， 所有的限制日期也會跟著相對變動喔！^_^ 無論使用者如何動作，到了 16679 (大約是 2015/09/01 左右) 該帳號就失效了～ 獲取 shadow 的加密機制 安裝 authconfig, 如果沒有裝的話 yum install authconfig-gtk* 查詢 authconfig --test | grep hashing 關於群組： 有效與初始群組、groups, newgrp/etc/group 文件結構如下：root:x:0:bin:x:1:daemon:x:2:sys:x:3: 群組名稱：就是群組名稱啦！同樣用來給人類使用的，基本上需要與第三字段的 GID 對應。 群組密碼：通常不需要設置，這個設置通常是給“群組管理員”使用的，目前很少有這個機會設置群組管理員啦！ 同樣的，密碼已經移動到 /etc/gshadow 去，因此這個字段只會存在一個“x”而已； GID：就是群組的 ID 啊。我們 /etc/passwd 第四個字段使用的 GID 對應的群組名，就是由這裡對應出來的！ 此群組支持的帳號名稱：我們知道一個帳號可以加入多個群組，那某個帳號想要加入此群組時，將該帳號填入這個字段即可。 舉例來說，如果我想要讓 dmtsai 與 alex 也加入 root 這個群組，那麼在第一行的最後面加上“dmtsai,alex”，注意不要有空格， 使成為“ root:x:0:dmtsai,alex ”就可以囉～ /etc/gshadow 文件結構 群組名稱 密碼欄，同樣的，開頭為 ! 表示無合法密碼，所以無群組管理員 群組管理員的帳號 (相關信息在 gpasswd 中介紹) 有加入該群組支持的所屬帳號 (與 /etc/group 內容相同！) /etc/passwd 與 /etc/group 與 /etc/shadow 示意圖談完了 /etc/passwd, /etc/shadow, /etc/group 之後，我們可以使用一個簡單的圖示來了解一下 UID / GID 與密碼之間的關係， 圖示如下。其實重點是 /etc/passwd 啦，其他相關的數據都是根據這個文件的字段去找尋出來的。 下圖中， root 的 UID 是 0 ，而 GID 也是 0 ，去找 /etc/group 可以知道 GID 為 0 時的群組名稱就是 root 哩。 至於密碼的尋找中，會找到 /etc/shadow 與 /etc/passwd 內同帳號名稱的那一行，就是密碼相關數據囉。 finger Login：為使用者帳號，亦即 /etc/passwd 內的第一字段； Name：為全名，亦即 /etc/passwd 內的第五字段(或稱為註解)； Directory：就是主文件夾了； Shell：就是使用的 Shell 文件所在； Never logged in.：figner 還會調查使用者登陸主機的情況喔！ No mail.：調查 /var/spool/mail 當中的信箱數據； No Plan.：調查 ~vbird1/.plan 文件，並將該文件取出來說明！ chfnchfn [-foph] [帳號名]選項與參數：-f ：後面接完整的大名；-o ：您辦公室的房間號碼；-p ：辦公室的電話號碼；-h ：家裡的電話號碼！ chage 更詳細的密碼參數顯示功能 可讓使用者在第一次登陸時， 強制她們一定要更改密碼後才能夠使用系統資源 語法chage [-ldEImMW] 帳號名選項與參數：-l ：列出該帳號的詳細密碼參數；-d ：後面接日期，修改 shadow 第三字段(最近一次更改密碼的日期)，格式 YYYY-MM-DD-E ：後面接日期，修改 shadow 第八字段(帳號失效日)，格式 YYYY-MM-DD-I ：後面接天數，修改 shadow 第七字段(密碼失效日期)-m ：後面接天數，修改 shadow 第四字段(密碼最短保留天數)-M ：後面接天數，修改 shadow 第五字段(密碼多久需要進行變更)-W ：後面接天數，修改 shadow 第六字段(密碼過期前警告日期) 範例範例一：列出 vbird2 的詳細密碼參數[root@study ~]# chage -l vbird2Last password change : Jul 20, 2015Password expires : Sep 18, 2015Password inactive : Sep 28, 2015Account expires : neverMinimum number of days between password change : 0Maximum number of days between password change : 60Number of days of warning before password expires : 7 chsh語法：chsh [-ls]選項與參數：-l ：列出目前系統上面可用的 shell ，其實就是 /etc/shells 的內容！-s ：設置修改自己的 Shell 囉 範例範例一：用 vbird1 的身份列出系統上所有合法的 shell，並且指定 csh 為自己的 shell[vbird1@study ~]$ chsh -l/bin/sh/bin/bash/sbin/nologin &lt;==所謂：合法不可登陸的 Shell 就是這玩意！/usr/bin/sh/usr/bin/bash/usr/sbin/nologin/bin/tcsh/bin/csh &lt;==這就是 C shell 啦！# 其實上面的信息就是我們在 bash 中談到的 /etc/shells 啦！[vbird1@study ~]$ chsh -s /bin/csh; grep vbird1 /etc/passwdChanging shell for vbird1.Password: &lt;==確認身份，請輸入 vbird1 的密碼Shell changed.vbird1:x:1003:1004:VBird Tsai test,DIC in KSU,06-2727175#356,06-1234567:/home/vbird1:/bin/csh[vbird1@study ~]$ chsh -s /bin/bash# 測試完畢後，立刻改回來！[vbird1@study ~]$ ll $(which chsh)-rws--x--x. 1 root root 23856 Mar 6 13:59 /bin/chsh groupadd語法groupadd [-g gid] [-r] 群組名稱選項與參數：-g ：後面接某個特定的 GID ，用來直接給予某個 GID ～-r ：創建系統群組啦！與 /etc/login.defs 內的 GID_MIN 有關。 範例範例一：新建一個群組，名稱為 group1[root@study ~]# groupadd group1[root@study ~]# grep group1 /etc/group /etc/gshadow/etc/group:group1:x:1503:/etc/gshadow:group1:!::# 群組的 GID 也是會由 1000 以上最大 GID+1 來決定！ groupmod語法groupmod [-g gid] [-n group_name] 群組名選項與參數：-g ：修改既有的 GID 數字；-n ：修改既有的群組名稱 範例範例一：將剛剛上個指令創建的 group1 名稱改為 mygroup ， GID 為 201[root@study ~]# groupmod -g 201 -n mygroup group1[root@study ~]# grep mygroup /etc/group /etc/gshadow/etc/group:mygroup:x:201:/etc/gshadow:mygroup:!:: groupdel語法groupdel [groupname] gpasswd語法系統管理員 (root)gpasswd groupname[root@study ~]# gpasswd [-A user1,...] [-M user3,...] groupname[root@study ~]# gpasswd [-rR] groupname選項與參數： ：若沒有任何參數時，表示給予 groupname 一個密碼(/etc/gshadow)-A ：將 groupname 的主控權交由後面的使用者管理(該群組的管理員)-M ：將某些帳號加入這個群組當中！-r ：將 groupname 的密碼移除-R ：讓 groupname 的密碼欄失效 群組管理員 (Group administrator)gpasswd [-ad] user groupname選項與參數：-a ：將某位使用者加入到 groupname 這個群組當中！-d ：將某位使用者移除出 groupname 這個群組當中。 範例範例一：創建一個新群組，名稱為 testgroup 且群組交由 vbird1 管理：[root@study ~]# groupadd testgroup &lt;==先創建群組[root@study ~]# gpasswd testgroup &lt;==給這個群組一個密碼吧！Changing the password for group testgroupNew Password:Re-enter new password:# 輸入兩次密碼就對了！[root@study ~]# gpasswd -A vbird1 testgroup &lt;==加入群組管理員為 vbird1[root@study ~]# grep testgroup /etc/group /etc/gshadow/etc/group:testgroup:x:1503:/etc/gshadow:testgroup:$6$MnmChP3D$mrUn.Vo.buDjObMm8F2emTkvGSeuWikhRzaKHxpJ...:vbird1:# 很有趣吧！此時 vbird1 則擁有 testgroup 的主控權喔！身份有點像板主啦！ 範例二：以 vbird1 登陸系統，並且讓他加入 vbird1, vbird3 成為 testgroup 成員[vbird1@study ~]$ iduid=1003(vbird1) gid=1004(vbird1) groups=1004(vbird1) ...# 看得出來，vbird1 尚未加入 testgroup 群組喔！[vbird1@study ~]$ gpasswd -a vbird1 testgroup[vbird1@study ~]$ gpasswd -a vbird3 testgroup[vbird1@study ~]$ grep testgroup /etc/grouptestgroup:x:1503:vbird1,vbird3 ACLsetfacl setfacl ：設置某個目錄/文件的 ACL 規範。 語法setfacl [-bkRd] [&#123;-m|-x&#125; acl參數] 目標文件名選項與參數：-m ：設置後續的 acl 參數給文件使用，不可與 -x 合用；-x ：刪除後續的 acl 參數，不可與 -m 合用；-b ：移除“所有的” ACL 設置參數；-k ：移除“默認的” ACL 參數，關於所謂的“默認”參數於後續範例中介紹；-R ：遞迴設置 acl ，亦即包括次目錄都會被設置起來；-d ：設置“默認 acl 參數”的意思！只對目錄有效，在該目錄新建的數據會引用此默認值 getfacl語法getfacl filename選項與參數：# 請列出剛剛我們設置的 acl_test1 的權限內容：[root@study ~]# getfacl acl_test1# file: acl_test1 &lt;==說明文檔名而已！# owner: root &lt;==說明此文件的擁有者，亦即 ls -l 看到的第三使用者字段# group: root &lt;==此文件的所屬群組，亦即 ls -l 看到的第四群組字段user::rwx &lt;==使用者列表欄是空的，代表文件擁有者的權限user:vbird1:r-x &lt;==針對 vbird1 的權限設置為 rx ，與擁有者並不同！group::r-- &lt;==針對文件群組的權限設置僅有 r mask::r-x &lt;==此文件默認的有效權限 (mask)other::r-- &lt;==其他人擁有的權限囉！-m ：設置後續的 acl 參數給文件使用，不可與 -x 合用；-x ：刪除後續的 acl 參數，不可與 -m 合用；-b ：移除“所有的” ACL 設置參數；-k ：移除“默認的” ACL 參數，關於所謂的“默認”參數於後續範例中介紹；-R ：遞迴設置 acl ，亦即包括次目錄都會被設置起來；-d ：設置“默認 acl 參數”的意思！只對目錄有效，在該目錄新建的數據會引用此默認值 顯示的數據前面加上 # 的，代表這個文件的默認屬性，包括文件名、文件擁有者與文件所屬群組。user, group, mask, other 則是屬於不同使用者、群組與有效權限(mask)的設置值。 su語法su [-lm] [-c 指令] [username]選項與參數：- ：單純使用 - 如“ su - ”代表使用 login-shell 的變量文件讀取方式來登陸系統； 若使用者名稱沒有加上去，則代表切換為 root 的身份。-l ：與 - 類似，但後面需要加欲切換的使用者帳號！也是 login-shell 的方式。-m ：-m 與 -p 是一樣的，表示“使用目前的環境設置，而不讀取新使用者的配置文件”-c ：僅進行一次指令，所以 -c 後面可以加上指令喔！ sudo語法sudo [-b] [-u 新使用者帳號]選項與參數：-b ：將後續的指令放到背景中讓系統自行執行，而不與目前的 shell 產生影響-u ：後面可以接欲切換的使用者，若無此項則代表切換身份為 root 。 sudoers更改設置visodu root ALL=(ALL) ALL &lt;==找到這一行，大約在 98 行左右vbird1 ALL=(ALL) ALL &lt;==這一行是你要新增的！ 使用者帳號 登陸者的來源主機名稱=(可切換的身份) 可下達的指令root ALL=(ALL) ALL &lt;==這是默認值 “使用者帳號”：系統的哪個帳號可以使用 sudo 這個指令的意思； “登陸者的來源主機名稱”：當這個帳號由哪部主機連線到本 Linux 主機，意思是這個帳號可能是由哪一部網絡主機連線過來的， 這個設置值可以指定用戶端計算機(信任的來源的意思)。默認值 root 可來自任何一部網絡主機 “(可切換的身份)”：這個帳號可以切換成什麼身份來下達後續的指令，默認 root 可以切換成任何人； “可下達的指令”：可用該身份下達什麼指令？這個指令請務必使用絕對路徑撰寫。 默認 root 可以切換任何身份且進行任何指令之意。那個 ALL 是特殊的關鍵字，代表任何身份、主機或指令的意思。所以，我想讓 vbird1 可以進行任何身份的任何指令， 就如同上表特殊字體寫的那樣，其實就是複製上述默認值那一行，再將 root 改成 vbird1 即可啊！ 此時“vbird1 不論來自哪部主機登陸，他可以變換身份成為任何人，且可以進行系統上面的任何指令”之意。 修改完請儲存後離開 vi，並以 vbird1 登陸系統後，進行如下的測試看看： visudo更改默認編輯器update-alternatives --config editor PAM 模塊設置語法程序與 PAM 的關係圖 程序調用 PAM 的流程 使用者開始執行 /usr/bin/passwd 這支程序，並輸入密碼； passwd 調用 PAM 模塊進行驗證； PAM 模塊會到 /etc/pam.d/ 找尋與程序 (passwd) 同名的配置文件； 依據 /etc/pam.d/passwd 內的設置，引用相關的 PAM 模塊逐步進行驗證分析； 將驗證結果 (成功、失敗以及其他訊息) 回傳給 passwd 這支程序； passwd 這支程序會根據 PAM 回傳的結果決定下一個動作 (重新輸入新密碼或者通過驗證！) 配置文件內容cat /etc/pam.d/passwd#%PAM-1.0 &lt;==PAM版本的說明而已！auth include system-auth &lt;==每一行都是一個驗證的過程account include system-authpassword substack system-auth-password optional pam_gnome_keyring.so use_authtokpassword substack postlogin驗證類別 控制標準 PAM 模塊與該模塊的參數 驗證類別 (type)驗證類別主要分為四種，分別說明如下： auth是 authentication (認證) 的縮寫，所以這種類別主要用來檢驗使用者的身份驗證，這種類別通常是需要密碼來檢驗的， 所以後續接的模塊是用來檢驗使用者的身份。 accountaccount (帳號) 則大部分是在進行 authorization (授權)，這種類別則主要在檢驗使用者是否具有正確的使用權限， 舉例來說，當你使用一個過期的密碼來登陸時，當然就無法正確的登陸了。 sessionsession 是會議期間的意思，所以 session 管理的就是使用者在這次登陸 (或使用這個指令) 期間，PAM 所給予的環境設置。 這個類別通常用在記錄使用者登陸與登出時的信息！例如，如果你常常使用 su 或者是 sudo 指令的話， 那麼應該可以在 /var/log/secure 裡面發現很多關於 pam 的說明，而且記載的數據是“session open, session close”的信息！ passwordpassword 就是密碼嘛！所以這種類別主要在提供驗證的修訂工作，舉例來說，就是修改/變更密碼啦！這四個驗證的類型通常是有順序的，不過也有例外就是了。 會有順序的原因是，(1)我們總是得要先驗證身份 (auth) 後， (2)系統才能夠藉由使用者的身份給予適當的授權與權限設置 (account)，而且(3)登陸與登出期間的環境才需要設置， 也才需要記錄登陸與登出的信息 (session)。如果在運行期間需要密碼修訂時，(4)才給予 password 的類別。這樣說起來， 自然是需要有點順序吧！ 驗證的控制旗標 (control flag)那麼“驗證的控制旗標(control flag)”又是什麼？簡單的說，他就是“驗證通過的標準”啦！ 這個字段在管控該驗證的放行方式，主要也分為四種控制方式： required此驗證若成功則帶有 success (成功) 的標誌，若失敗則帶有 failure 的標誌，但不論成功或失敗都會繼續後續的驗證流程。 由於後續的驗證流程可以繼續進行，因此相當有利於數據的登錄 (log) ，這也是 PAM 最常使用 required 的原因。 requisite若驗證失敗則立刻回報原程序 failure 的標誌，並終止後續的驗證流程。若驗證成功則帶有 success 的標誌並繼續後續的驗證流程。 這個項目與 required 最大的差異，就在於失敗的時候還要不要繼續驗證下去？由於 requisite 是失敗就終止， 因此失敗時所產生的 PAM 信息就無法通過後續的模塊來記錄了。 sufficient若驗證成功則立刻回傳 success 給原程序，並終止後續的驗證流程；若驗證失敗則帶有 failure 標誌並繼續後續的驗證流程。 這玩意兒與 requisits 剛好相反！ optional這個模塊控制項目大多是在顯示訊息而已，並不是用在驗證方面的。如果將這些控制旗標以圖示的方式配合成功與否的條件繪圖，會有點像下面這樣： 程序運行過程中遇到驗證時才會去調用 PAM ，而 PAM 驗證又分很多類型與控制，不同的控制旗標所回報的訊息並不相同。 如上圖所示， requisite 失敗就回報了並不會繼續，而 sufficient 則是成功就回報了也不會繼續。 至於驗證結束後所回報的信息通常是“succes 或 failure ”而已，後續的流程還需要該程序的判斷來繼續執行才行。 jobs語法[root@study ~]# jobs [-lrs]選項與參數：-l ：除了列出 job number 與指令串之外，同時列出 PID 的號碼；-r ：僅列出正在背景 run 的工作；-s ：僅列出正在背景當中暫停 (stop) 的工作。 fg語法[root@study ~]# fg %jobnumber選項與參數：%jobnumber ：jobnumber 為工作號碼(數字)。注意，那個 % 是可有可無的！ ps語法[root@study ~]# ps aux &lt;==觀察系統所有的程序數據[root@study ~]# ps -lA &lt;==也是能夠觀察所有系統的數據[root@study ~]# ps axjf &lt;==連同部分程序樹狀態選項與參數：-A ：所有的 process 均顯示出來，與 -e 具有同樣的效用；-a ：不與 terminal 有關的所有 process ；-u ：有效使用者 (effective user) 相關的 process ；x ：通常與 a 這個參數一起使用，可列出較完整信息。輸出格式規劃：l ：較長、較詳細的將該 PID 的的信息列出；j ：工作的格式 (jobs format)-f ：做一個更為完整的輸出。 觀察自己的 bash 相關程序ps -l 輸出如下： F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 14830 13970 0 80 0 - 52686 poll_s pts/0 00:00:00 sudo4 S 0 14835 14830 0 80 0 - 50511 wait pts/0 00:00:00 su4 S 0 14836 14835 0 80 0 - 29035 wait pts/0 00:00:00 bash0 R 0 15011 14836 0 80 0 - 30319 - pts/0 00:00:00 ps# 還記得鳥哥說過，非必要不要使用 root 直接登陸吧？從這個 ps -l 的分析，你也可以發現，# 鳥哥其實是使用 sudo 才轉成 root 的身份～否則連測試機，鳥哥都是使用一般帳號登陸的！ 詳解： 系統整體的程序運行是非常多的，但如果使用 ps -l 則僅列出與你的操作環境 (bash) 有關的程序而已， 亦即最上層的父程序會是你自己的 bash 而沒有延伸到 systemd (後續會交待！) 這支程序去！那麼 ps -l 秀出來的數據有哪些呢？ 我們就來觀察看看： F：代表這個程序旗標 (process flags)，說明這個程序的總結權限，常見號碼有： 若為 4 表示此程序的權限為 root ； 若為 1 則表示此子程序僅進行複製(fork)而沒有實際執行(exec)。 S：代表這個程序的狀態 (STAT)，主要的狀態有： R (Running)：該程序正在運行中； S (Sleep)：該程序目前正在睡眠狀態(idle)，但可以被喚醒(signal)。 D ：不可被喚醒的睡眠狀態，通常這支程序可能在等待 I/O 的情況(ex&gt;打印) T ：停止狀態(stop)，可能是在工作控制(背景暫停)或除錯 (traced) 狀態； Z (Zombie)：殭屍狀態，程序已經終止但卻無法被移除至內存外。 UID/PID/PPID：代表“此程序被該 UID 所擁有/程序的 PID 號碼/此程序的父程序 PID 號碼” C：代表 CPU 使用率，單位為百分比； PRI/NI：Priority/Nice 的縮寫，代表此程序被 CPU 所執行的優先順序，數值越小代表該程序越快被 CPU 執行。詳細的 PRI 與 NI 將在下一小節說明。 ADDR/SZ/WCHAN：都與內存有關，ADDR 是 kernel function，指出該程序在內存的哪個部分，如果是個 running 的程序，一般就會顯示“ - ” / SZ 代表此程序用掉多少內存 / WCHAN 表示目前程序是否運行中，同樣的， 若為 - 表示正在運行中。 TTY：登陸者的終端機位置，若為遠端登陸則使用動態終端接口 (pts/n)； TIME：使用掉的 CPU 時間，注意，是此程序實際花費 CPU 運行的時間，而不是系統時間； CMD：就是 command 的縮寫，造成此程序的觸發程序之指令為何。 所以你看到的 ps -l 輸出訊息中，他說明的是：“bash 的程序屬於 UID 為 0 的使用者，狀態為睡眠 (sleep)， 之所以為睡眠因為他觸發了 ps (狀態為 run) 之故。此程序的 PID 為 14836，優先執行順序為 80 ， 下達 bash 所取得的終端接口為 pts/0 ，運行狀態為等待 (wait) 。”這樣已經夠清楚了吧？ 您自己嘗試解析一下那麼 ps 那一行代表的意義為何呢？ ^_^接下來讓我們使用 ps 來觀察一下系統內所有的程序狀態吧！ 觀察系統所有程序ps aux 輸出： USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.2 60636 7948 ? Ss Aug04 0:01 /usr/lib/systemd/systemd ...root 2 0.0 0.0 0 0 ? S Aug04 0:00 [kthreadd].....(中間省略).....root 14830 0.0 0.1 210744 3988 pts/0 S Aug04 0:00 sudo su -root 14835 0.0 0.1 202044 2996 pts/0 S Aug04 0:00 su -root 14836 0.0 0.1 116140 2960 pts/0 S Aug04 0:00 -bash.....(中間省略).....root 18459 0.0 0.0 123372 1380 pts/0 R+ 00:25 0:00 ps aux 詳解： 你會發現 ps -l 與 ps aux 顯示的項目並不相同！在 ps aux 顯示的項目中，各字段的意義為： USER：該 process 屬於那個使用者帳號的？ PID ：該 process 的程序識別碼。 %CPU：該 process 使用掉的 CPU 資源百分比； %MEM：該 process 所佔用的實體內存百分比； VSZ ：該 process 使用掉的虛擬內存量 (KBytes) RSS ：該 process 佔用的固定的內存量 (KBytes) TTY ：該 process 是在那個終端機上面運行，若與終端機無關則顯示 ?，另外， tty1-tty6 是本機上面的登陸者程序，若為 pts/0 等等的，則表示為由網絡連接進主機的程序。 STAT：該程序目前的狀態，狀態顯示與 ps -l 的 S 旗標相同 (R/S/T/Z) START：該 process 被觸發啟動的時間； TIME ：該 process 實際使用 CPU 運行的時間。 COMMAND：該程序的實際指令為何？一般來說，ps aux 會依照 PID 的順序來排序顯示，我們還是以 14836 那個 PID 那行來說明！該行的意義為“ root 執行的 bash PID 為 14836，佔用了 0.1% 的內存容量百分比，狀態為休眠 (S)，該程序啟動的時間為 8 月 4 號，因此啟動太久了， 所以沒有列出實際的時間點。且取得的終端機環境為 pts/0 。”與 ps aux 看到的其實是同一個程序啦！這樣可以理解嗎？ 讓我們繼續使用 ps 來觀察一下其他的信息吧！ top相對於 ps 是擷取一個時間點的程序狀態， top 則可以持續偵測程序運行的狀態！使用方式如下： 語法[root@study ~]# top [-d 數字] | top [-bnp]選項與參數：-d ：後面可以接秒數，就是整個程序畫面更新的秒數。默認是 5 秒；-b ：以批次的方式執行 top ，還有更多的參數可以使用喔！ 通常會搭配數據流重導向來將批次的結果輸出成為文件。-n ：與 -b 搭配，意義是，需要進行幾次 top 的輸出結果。-p ：指定某些個 PID 來進行觀察監測而已。在 top 執行過程當中可以使用的按鍵指令： ? ：顯示在 top 當中可以輸入的按鍵指令； P ：以 CPU 的使用資源排序顯示； M ：以 Memory 的使用資源排序顯示； N ：以 PID 來排序喔！ T ：由該 Process 使用的 CPU 時間累積 (TIME+) 排序。 k ：給予某個 PID 一個訊號 (signal) r ：給予某個 PID 重新制訂一個 nice 值。 q ：離開 top 軟件的按鍵。 pstree語法[root@study ~]# pstree [-A|U] [-up]選項與參數：-A ：各程序樹之間的連接以 ASCII 字符來連接；-U ：各程序樹之間的連接以萬國碼的字符來連接。在某些終端接口下可能會有錯誤；-p ：並同時列出每個 process 的 PID；-u ：並同時列出每個 process 的所屬帳號名稱。 nice語法[root@study ~]# nice [-n 數字] command選項與參數：-n ：後面接一個數值，數值的範圍 -20 ~ 19。 renice語法[root@study ~]# renice [number] PID選項與參數：PID ：某個程序的 ID 啊！ free觀察內存使用情況 語法[root@study ~]# free [-b|-k|-m|-g|-h] [-t] [-s N -c N]選項與參數：-b ：直接輸入 free 時，顯示的單位是 KBytes，我們可以使用 b(Bytes), m(MBytes) k(KBytes), 及 g(GBytes) 來顯示單位喔！也可以直接讓系統自己指定單位 (-h)-t ：在輸出的最終結果，顯示實體內存與 swap 的總量。-s ：可以讓系統每幾秒鐘輸出一次，不間斷的一直輸出的意思！對於系統觀察挺有效！-c ：與 -s 同時處理～讓 free 列出幾次的意思～ 備註[root@study ~]# free -m total used free shared buff/cache availableMem: 2848 346 1794 8 706 2263Swap: 1023 0 1023 名稱 意義 swap 內存交換空間的量 total 總量 used 已被使用的量 free 剩餘可用的量 shared/buffers/cached 已被使用的量中，用來作為緩衝及高速緩存的量。 這些用量中，在系統比較忙碌時，可以被釋出而繼續利用 uname查閱系統與核心相關信息 語法[root@study ~]# uname [-asrmpi]選項與參數：-a ：所有系統相關的信息，包括下面的數據都會被列出來；-s ：系統核心名稱-r ：核心的版本-m ：本系統的硬件名稱，例如 i686 或 x86_64 等；-p ：CPU 的類型，與 -m 類似，只是顯示的是 CPU 的類型！-i ：硬件的平臺 (ix86)範例一：輸出系統的基本信息[root@study ~]# uname -aLinux study.centos.vbird 3.10.0-229.el7.x86_64 #1 SMP Fri Mar 6 11:36:42 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux uptime觀察系統啟動時間與工作負載這個指令很單純: 顯示出目前系統已經開機多久的時間 1, 5, 15 分鐘的平均負載這個 uptime 可以顯示出 top 畫面的最上面一行 netstat追蹤網絡或插槽檔 語法[root@study ~]# uname [-asrmpi]選項與參數：-a ：所有系統相關的信息，包括下面的數據都會被列出來；-s ：系統核心名稱-r ：核心的版本-m ：本系統的硬件名稱，例如 i686 或 x86_64 等；-p ：CPU 的類型，與 -m 類似，只是顯示的是 CPU 的類型！-i ：硬件的平臺 (ix86) 備註[root@study ~]# netstatActive Internet connections (w/o servers) &lt;==與網絡較相關的部分Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 172.16.15.100:ssh 172.16.220.234:48300 ESTABLISHEDActive UNIX domain sockets (w/o servers) &lt;==與本機的程序自己的相關性(非網絡)Proto RefCnt Flags Type State I-Node Pathunix 2 [ ] DGRAM 1902 @/org/freedesktop/systemd1/notifyunix 2 [ ] DGRAM 1944 /run/systemd/shutdownd....(中間省略)....unix 3 [ ] STREAM CONNECTED 25425 @/tmp/.X11-unix/X0unix 3 [ ] STREAM CONNECTED 28893unix 3 [ ] STREAM CONNECTED 21262 在上面的結果當中，顯示了兩個部分: 網絡的連線 linux 上面的 socket 程序相關性部分 我們先來看看網際網絡連線情況的部分： Proto ：網絡的封包協定，主要分為 TCP 與 UDP 封包，相關數據請參考服務器篇； Recv-Q：非由使用者程序鏈接到此 socket 的複製的總 Bytes 數； Send-Q：非由遠端主機傳送過來的 acknowledged 總 Bytes 數； Local Address ：本地端的 IP:port 情況 Foreign Address：遠端主機的 IP:port 情況 State ：連線狀態，主要有創建(ESTABLISED)及監聽(LISTEN)； 我們看上面僅有一條連線的數據，他的意義是：“通過 TCP 封包的連線，遠端的 172.16.220.234:48300 連線到本地端的 172.16.15.100:ssh ，這條連線狀態是創建 (ESTABLISHED) 的狀態！”至於更多的網絡環境說明， 就得到鳥哥的另一本服務器篇查閱囉！ socket file: 插槽檔 溝通兩個程序之間的信息 上表中 socket file 的輸出字段: Proto ：一般就是 unix 啦； RefCnt：連接到此 socket 的程序數量； Flags ：連線的旗標； Type ：socket 存取的類型。主要有確認連線的 STREAM 與不需確認的 DGRAM 兩種； State ：若為 CONNECTED 表示多個程序之間已經連線創建。 Path ：連接到此 socket 的相關程序的路徑！或者是相關數據輸出的路徑。 dmesg分析核心產生的訊息 系統在開機的時候，核心會去偵測系統的硬件，你的某些硬件到底有沒有被捉到，那就與這個時候的偵測有關。 dmesg 可以顯示這些偵測的過程 範例範例一：輸出所有的核心開機時的信息dmesg | less 範例二：搜尋開機的時候，硬盤的相關信息為何？dmesg | grep -i vda 輸出：[ 0.758551] vda: vda1 vda2 vda3 vda4 vda5 vda6 vda7 vda8 vda9[ 3.964134] XFS (vda2): Mounting V4 Filesystem....(下面省略).... vmstat偵測系統資源變化vmstat 可以偵測“ CPU / 內存 / 磁盤輸入輸出狀態 ”等等 語法[root@study ~]# vmstat [-a] [延遲 [總計偵測次數]] &lt;==CPU/內存等信息[root@study ~]# vmstat [-fs] &lt;==內存相關[root@study ~]# vmstat [-S 單位] &lt;==設置顯示數據的單位[root@study ~]# vmstat [-d] &lt;==與磁盤有關[root@study ~]# vmstat [-p 分區] &lt;==與磁盤有關選項與參數：-a ：使用 inactive/active(活躍與否) 取代 buffer/cache 的內存輸出信息；-f ：開機到目前為止，系統複製 (fork) 的程序數；-s ：將一些事件 (開機至目前為止) 導致的內存變化情況列表說明；-S ：後面可以接單位，讓顯示的數據有單位。例如 K/M 取代 Bytes 的容量；-d ：列出磁盤的讀寫總量統計表-p ：後面列出分區，可顯示該分區的讀寫總量統計表 範例範例一：統計目前主機 CPU 狀態，每秒一次，共計三次！vmstat 1 3 範例輸出： 範例二：系統上面所有的磁盤的讀寫狀態vmstat -d 範例輸出： 利用 vmstat 甚至可以進行追蹤喔！你可以使用類似“ vmstat 5 ”代表每五秒鐘更新一次，且無窮的更新！直到你按下 [ctrl]-c 為止。如果你想要實時的知道系統資源的運行狀態，這個指令就不能不知道！那麼上面的表格各項字段的意義為何？ 基本說明如下： 程序字段 (procs) 的項目分別為： r ：等待運行中的程序數量； b：不可被喚醒的程序數量。這兩個項目越多，代表系統越忙碌 (因為系統太忙，所以很多程序就無法被執行或一直在等待而無法被喚醒之故)。 內存字段 (memory) 項目分別為： swpd：虛擬內存被使用的容量； free：未被使用的內存容量； buff：用於緩衝內存； cache：用於高速緩存內存。 這部份則與 free 是相同的。 內存交換空間 (swap) 的項目分別為： si：由磁盤中將程序取出的量； so：由於內存不足而將沒用到的程序寫入到磁盤的 swap 的容量。 如果 si/so 的數值太大，表示內存內的數據常常得在磁盤與內存之間傳來傳去，系統性能會很差！ 磁盤讀寫 (io) 的項目分別為： bi：由磁盤讀入的區塊數量； bo：寫入到磁盤去的區塊數量。如果這部份的值越高，代表系統的 I/O 非常忙碌！ 系統 (system) 的項目分別為： in：每秒被中斷的程序次數； cs：每秒鐘進行的事件切換次數；這兩個數值越大，代表系統與周邊設備的溝通非常頻繁！ 這些周邊設備當然包括磁盤、網卡、時間鍾等。 CPU 的項目分別為： us：非核心層的 CPU 使用狀態； sy：核心層所使用的 CPU 狀態； id：閒置的狀態； wa：等待 I/O 所耗費的 CPU 狀態； st：被虛擬機 (virtual machine) 所盜用的 CPU 使用狀態 (2.6.11 以後才支持)。 /proc基本上，目前主機上面的各個程序的 PID 都是以目錄的型態存在於 /proc 當中。 舉例來說，我們開機所執行的第一支程序 systemd 他的 PID 是 1 ， 這個 PID 的所有相關信息都寫入在 /proc/1/* 當中！若我們直接觀察 PID 為 1 的數據好了，他有點像這樣： 文件內容 文件名 文件內容 /proc/cmdline 載入 kernel 時所下達的相關指令與參數！查閱此文件，可瞭解指令是如何啟動的！ /proc/cpuinfo 本機的 CPU 的相關信息，包含頻率、類型與運算功能等 /proc/devices 這個文件記錄了系統各個主要設備的主要設備代號，與 mknod 有關呢！ /proc/filesystems 目前系統已經載入的文件系統囉！ /proc/interrupts 目前系統上面的 IRQ 分配狀態。 /proc/ioports 目前系統上面各個設備所配置的 I/O 位址。 /proc/kcore 這個就是內存的大小啦！好大對吧！但是不要讀他啦！ /proc/loadavg 還記得 top 以及 uptime 吧？沒錯！上頭的三個平均數值就是記錄在此！ /proc/meminfo 使用 free 列出的內存信息，嘿嘿！在這裡也能夠查閱到！ /proc/modules 目前我們的 Linux 已經載入的模塊列表，也可以想成是驅動程序啦！ /proc/mounts 系統已經掛載的數據，就是用 mount 這個指令調用出來的數據啦！ /proc/swaps 到底系統掛載入的內存在哪裡？呵呵！使用掉的 partition 就記錄在此啦！ /proc/partitions 使用 fdisk -l 會出現目前所有的 partition 吧？在這個文件當中也有紀錄喔！ /proc/uptime 就是用 uptime 的時候，會出現的信息啦！ /proc/version 核心的版本，就是用 uname -a 顯示的內容啦！ /proc/bus/* 一些總線的設備，還有 USB 的設備也記錄在此喔！ fuser藉由文件(或文件系統)找出正在使用該文件的程序 語法[root@study ~]# fuser [-umv] [-k [i] [-signal]] file/dir選項與參數：-u ：除了程序的 PID 之外，同時列出該程序的擁有者；-m ：後面接的那個文件名會主動的上提到該文件系統的最頂層，對 umount 不成功很有效！-v ：可以列出每個文件與程序還有指令的完整相關性！-k ：找出使用該文件/目錄的 PID ，並試圖以 SIGKILL 這個訊號給予該 PID；-i ：必須與 -k 配合，在刪除 PID 之前會先詢問使用者意願！-signal：例如 -1 -15 等等，若不加的話，默認是 SIGKILL (-9) 囉！ 範例範例一：找出目前所在目錄的使用 PID/所屬帳號/權限 為何？[root@study ~]# fuser -uv . USER PID ACCESS COMMAND/root: root 13888 ..c.. (root)bash root 31743 ..c.. (root)bash``` 範例二：找到所有使用到 /proc 這個文件系統的程序吧！[root@study ~]# fuser -uv /proc/proc: root kernel mount (root)/proc rtkit 768 .rc.. (rtkit)rtkit-daemon 數據量還不會很多，雖然這個目錄很繁忙～沒關係！我們可以繼續這樣作，看看其他的程序！[root@study ~]# fuser -mvu /proc USER PID ACCESS COMMAND/proc: root kernel mount (root)/proc root 1 f…. (root)systemd root 2 …e. (root)kthreadd…..(下面省略)….. 有這幾支程序在進行 /proc 文件系統的存取喔！這樣清楚了嗎？ 範例三：找到所有使用到 /home 這個文件系統的程序吧！[root@study ~]# echo $$31743 # 先確認一下，自己的 bash PID 號碼吧！[root@study ~]# cd /home[root@study home]# fuser -muv . USER PID ACCESS COMMAND/home: root kernel mount (root)/home dmtsai 31535 ..c.. (dmtsai)bash root 31571 ..c.. (root)passwd root 31737 ..c.. (root)sudo root 31743 ..c.. (root)bash # 果然，自己的 PID 在啊！[root@study home]# cd ~[root@study ~]# umount /homeumount: /home: target is busy. (In some cases useful info about processes that use the device is found by lsof(8) or fuser(1)) 從 fuser 的結果可以知道，總共有五隻 process 在該目錄下運行，那即使 root 離開了 /home，當然還是無法 umount 的！那要怎辦？哈哈！可以通過如下方法一個一個刪除～[root@study ~]# fuser -mki /home/home: 31535c 31571c 31737c # 你會發現， PID 跟上面查到的相同！Kill process 31535 ? (y/N) # 這裡會問你要不要刪除！當然不要亂刪除啦！通通取消！&lt;br/&gt;### 那個 ACCESS 的項目，那個項目代表的意義為：- c ：此程序在當前的目錄下(非次目錄)；- e ：可被觸發為執行狀態；- f ：是一個被打開的文件；- r ：代表頂層目錄 (root directory)；- F ：該文件被打開了，不過在等待迴應中；- m ：可能為分享的動態函數庫；## lsof列出被程序所打開的文件文件名&lt;br/&gt;### 語法 lsof [-aUu] [+d]選項與參數：-t ：terse, 簡短輸出, 可以輸出符合 kill 的參數-a ：多項數據需要“同時成立”才顯示出結果時！-U ：僅列出 Unix like 系統的 socket 文件類型；-u ：後面接 username，列出該使用者相關程序所打開的文件；+d ：後面接目錄，亦即找出某個目錄下面已經被打開的文件！## pidof找出某支正在執行的程序的 PID&lt;br/&gt;### 語法 pidof [-sx] program_name選項與參數：-s ：僅列出一個 PID 而不列出所有的 PID-x ：同時列出該 program name 可能的 PPID 那個程序的 PID## systemd### systemd 的配置文件放置目錄`/usr/lib/systemd/system/`：每個服務最主要的啟動腳本設置，有點類似以前的 /etc/init.d 下面的文件；`/run/systemd/system/`：系統執行過程中所產生的服務腳本，這些腳本的優先序要比 /usr/lib/systemd/system/ 高！`/etc/systemd/system/`：管理員依據主機系統的需求所創建的執行腳本，其實這個目錄有點像以前 /etc/rc.d/rc5.d/Sxx 之類的功能！執行優先序又比 /run/systemd/system/ 高喔！&lt;br/&gt;### systemd 服務類型擴展名 | 主要服務功能------|.service | 一般服務類型 (service unit)：主要是系統服務，包括服務器本身所需要的本機服務以及網絡服務都是！比較經常被使用到的服務大多是這種類型！ 所以，這也是最常見的類型了！.socket | 內部程序數據交換的插槽服務 (socket unit)：主要是 IPC (Inter-process communication) 的傳輸訊息插槽檔 (socket file) 功能。 這種類型的服務通常在監控訊息傳遞的插槽檔，當有通過此插槽檔傳遞訊息來說要鏈接服務時，就依據當時的狀態將該用戶的要求傳送到對應的 daemon， 若 daemon 尚未啟動，則啟動該 daemon 後再傳送用戶的要求。&lt;br/&gt;使用 socket 類型的服務一般是比較不會被用到的服務，因此在開機時通常會稍微延遲啟動的時間 (因為比較沒有這麼常用嘛！)。一般用於本機服務比較多，例如我們的圖形界面很多的軟件都是通過 socket 來進行本機程序數據交換的行為。 (這與早期的 xinetd 這個 super daemon 有部份的相似喔！).target | 執行環境類型 (target unit)：其實是一群 unit 的集合，例如上面表格中談到的 multi-user.target 其實就是一堆服務的集合～也就是說， 選擇執行 multi-user.target, 就是執行一堆其他 .service 或/及 .socket 之類的服務就是了！.mount &lt;br/&gt; .automount | 文件系統掛載相關的服務 (automount unit / mount unit)：例如來自網絡的自動掛載、NFS 文件系統掛載等與文件系統相關性較高的程序管理。.path | 偵測特定文件或目錄類型 (path unit)：某些服務需要偵測某些特定的目錄來提供佇列服務，例如最常見的打印服務，就是通過偵測打印佇列目錄來啟動打印功能！ 這時就得要 .path 的服務類型支持了！.timer | 循環執行的服務 (timer unit)：這個東西有點類似 anacrontab 喔！不過是由 systemd 主動提供的，比 anacrontab 更加有彈性！&lt;br/&gt;### systemctl管理單一服務 (service unit) 的啟動/開機啟動與觀察狀態&lt;br/&gt;#### 語法 systemctl [command] [unit]command 主要有：start ：立刻啟動後面接的 unitstop ：立刻關閉後面接的 unitrestart ：立刻關閉後啟動後面接的 unit，亦即執行 stop 再 start 的意思reload ：不關閉後面接的 unit 的情況下，重新載入配置文件，讓設置生效enable ：設置下次開機時，後面接的 unit 會被啟動disable ：設置下次開機時，後面接的 unit 不會被啟動status ：目前後面接的這個 unit 的狀態，會列出有沒有正在執行、開機默認執行否、登錄等信息等！is-active ：目前有沒有正在運行中is-enable ：開機時有沒有默認要啟用這個 unitis-enable ：開機時有沒有默認要啟用這個 unit systemctl [command] [–type=TYPE] [–all]command: list-units ：依據 unit 列出目前有啟動的 unit。若加上 –all 才會列出沒啟動的。 list-unit-files ：依據 /usr/lib/systemd/system/ 內的文件，將所有文件列表說明。–type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等&lt;br/&gt;#### unit 狀態 systemctl list-unitsUNIT | LOAD | ACTIVE | SUB | DESCRIPTION---|---|---|---|proc-sys-fs-binfmt_mis... | loaded | active | waiting | Arbitrary Executable File Formats File System||| |sys-devices-pc...:0:1:... | loaded | active | plugged | QEMU_HARDDISKsys-devices-pc...0:1-0... | loaded | active | plugged | QEMU_HARDDISKsys-devices-pc...0:0-1... | loaded | active | plugged | QEMU_DVD-ROM.....(中間省略).....vsftpd.service | loaded | active | running | Vsftpd ftp daemon.....(中間省略).....cups.socket | loaded | failed | failed | CUPS Printing Service Sockets.....(中間省略).....LOAD = Reflects whether the unit definition was properly loaded.ACTIVE = The high-level unit activation state, i.e. generalization of SUB.SUB = The low-level unit activation state, values depend on unit type.141 loaded units listed. Pass --all to see loaded but inactive units, too.To show all installed unit files use &apos;systemctl list-unit-files&apos;.列出的項目中，主要的意義是：- UNIT ：項目的名稱，包括各個 unit 的類別 (看擴展名)- LOAD ：開機時是否會被載入，默認 systemctl 顯示的是有載入的項目而已喔！- ACTIVE ：目前的狀態，須與後續的 SUB 搭配！就是我們用 systemctl status 觀察時，active 的項目！- DESCRIPTION ：詳細描述囉- cups 比較有趣，因為剛剛被我們玩過，所以 ACTIVE 竟然是 failed 的喔！被玩死了！ ^_^- 另外，systemctl 都不加參數，其實默認就是 list-units 的意思！&lt;br/&gt;#### active 狀態狀態 | 解釋-----------------|active (running)| 正有一隻或多隻程序正在系統中執行的意思，舉例來說，正在執行中的 vsftpd 就是這種模式。active (exited)| 僅執行一次就正常結束的服務，目前並沒有任何程序在系統中執行。 舉例來說，開機或者是掛載時才會進行一次的 quotaon 功能，就是這種模式！ quotaon 不須一直執行～只須執行一次之後，就交給文件系統去自行處理囉！通常用 bash shell 寫的小型服務，大多是屬於這種類型 (無須常駐內存)。active (waiting)| 正在執行當中，不過還再等待其他的事件才能繼續處理。舉例來說，打印的佇列相關服務就是這種狀態！ 雖然正在啟動中，不過，也需要真的有佇列進來 (打印工作) 這樣他才會繼續喚醒打印機服務來進行下一步打印的功能。inactive| 這個服務目前沒有運行的意思。&lt;br/&gt;#### daemon 默認狀態狀態 | 解釋----|enabled | 這個 daemon 將在開機時被執行disabled | 這個 daemon 在開機時不會被執行static | 這個 daemon 不可以自己啟動 (enable 不可)，不過可能會被其他的 enabled 的服務來喚醒 (相依屬性的服務)mask | 這個 daemon 無論如何都無法被啟動！因為已經被強制註銷 (非刪除)。可通過 systemctl unmask 方式改回原本狀態&lt;br/&gt;#### 管理不同的操作環境```bashsystemctl list-units --type=target --all UNIT LOAD ACTIVE SUB DESCRIPTIONbasic.target loaded active active Basic Systemcryptsetup.target loaded active active Encrypted Volumesemergency.target loaded inactive dead Emergency Modefinal.target loaded inactive dead Final Stepgetty.target loaded active active Login Promptsgraphical.target loaded active active Graphical Interfacelocal-fs-pre.target loaded active active Local File Systems (Pre)local-fs.target loaded active active Local File Systemsmulti-user.target loaded active active Multi-User Systemnetwork-online.target loaded inactive dead Network is Onlinenetwork.target loaded active active Networknss-user-lookup.target loaded inactive dead User and Group Name Lookupspaths.target loaded active active Pathsremote-fs-pre.target loaded active active Remote File Systems (Pre)remote-fs.target loaded active active Remote File Systemsrescue.target loaded inactive dead Rescue Modeshutdown.target loaded inactive dead Shutdownslices.target loaded active active Slicessockets.target loaded active active Socketssound.target loaded active active Sound Cardswap.target loaded active active Swapsysinit.target loaded active active System Initializationsyslog.target not-found inactive dead syslog.targettime-sync.target loaded inactive dead System Time Synchronizedtimers.target loaded active active Timersumount.target loaded inactive dead Unmount All FilesystemsLOAD = Reflects whether the unit definition was properly loaded.ACTIVE = The high-level unit activation state, i.e. generalization of SUB.SUB = The low-level unit activation state, values depend on unit type.26 loaded units listed.To show all installed unit files use &apos;systemctl list-unit-files&apos;. graphical.target：就是文字加上圖形界面，這個項目已經包含了下面的 multi-user.target 項目！ multi-user.target：純文本模式！ rescue.target：在無法使用 root 登陸的情況下，systemd 在開機時會多加一個額外的暫時系統，與你原本的 系統無關。這時你可以取得 root 的權限來維護你的系統。 但是這是額外系統，因此可能需要動到 chroot 的方式來取得你原有的系統喔！ emergency.target：緊急處理系統的錯誤，還是需要使用 root 登陸的情況，在無法使用 rescue.target 時，可以嘗試使用這種模式！ shutdown.target：就是關機的流程。 getty.target：可以設置你需要幾個 tty 之類的，如果想要降低 tty 的項目，可以修改這個東西的配置文件！ 取得目前的操作環境以及修改systemctl [command] [unit.target]選項與參數：command: get-default ：取得目前的 target set-default ：設置後面接的 target 成為默認的操作模式 isolate ：切換到後面接的模式 範例範例一：我們的測試機器默認是圖形界面，先觀察是否真為圖形模式，再將默認模式轉為文字界面[root@study ~]# systemctl get-default graphical.target # 果然是圖形界面喔！[root@study ~]# systemctl set-default multi-user.target[root@study ~]# systemctl get-default multi-user.target 範例二：在不重新開機的情況下，將目前的操作環境改為純文本模式，關掉圖形界面[root@study ~]# systemctl isolate multi-user.target 範例三：若需要重新取得圖形界面呢？[root@study ~]# systemctl isolate graphical.target 要注意，改變 graphical.target 以及 multi-user.target 是通過 isolate 來處理的。 在正常的切換情況下，使用上述 isolate 的方式即可。不過為了方便起見， systemd 也提供了數個簡單的指令給我們切換操作模式之用喔！ 大致上如下所示： systemctl 針對機器操作的幾個簡單指令[root@study ~]# systemctl poweroff 系統關機[root@study ~]# systemctl reboot 重新開機[root@study ~]# systemctl suspend 進入暫停模式[root@study ~]# systemctl hibernate 進入休眠模式[root@study ~]# systemctl rescue 強制進入救援模式[root@study ~]# systemctl emergency 強制進入緊急救援模式 suspend：暫停模式會將系統的狀態數據保存到內存中，然後關閉掉大部分的系統硬件，當然，並沒有實際關機喔！ 當使用者按下喚醒機器的按鈕，系統數據會重內存中回覆，然後重新驅動被大部分關閉的硬件，就開始正常運行！喚醒的速度較快。 hibernate：休眠模式則是將系統狀態保存到硬盤當中，保存完畢後，將計算機關機。當使用者嘗試喚醒系統時，系統會開始正常運行， 然後將保存在硬盤中的系統狀態恢復回來。因為數據是由硬盤讀出，因此喚醒的性能與你的硬盤速度有關。 通過 systemctl 分析各服務之間的相依性[root@study ~]# systemctl list-dependencies [unit] [--reverse]選項與參數：--reverse ：反向追蹤誰使用這個 unit 的意思！ 範例範例一：列出目前的 target 環境下，用到什麼特別的 unit [root@study ~]# systemctl get-defaultmulti-user.target[root@study ~]# systemctl list-dependenciesdefault.target├─abrt-ccpp.service├─abrt-oops.service├─vsftpd.service├─basic.target│ ├─alsa-restore.service│ ├─alsa-state.service.....(中間省略).....│ ├─sockets.target│ │ ├─avahi-daemon.socket│ │ ├─dbus.socket.....(中間省略).....│ ├─sysinit.target│ │ ├─dev-hugepages.mount│ │ ├─dev-mqueue.mount.....(中間省略).....│ └─timers.target│ └─systemd-tmpfiles-clean.timer├─getty.target│ └─getty@tty1.service└─remote-fs.target 如果要查出誰會用到 multi-user.target 呢？systemctl list-dependencies --reversedefault.target└─graphical.target graphical.target 又使用了多少的服務呢？systemctl list-dependencies graphical.targetgraphical.target├─accounts-daemon.service├─gdm.service├─network.service├─rtkit-daemon.service├─systemd-update-utmp-runlevel.service└─multi-user.target ├─abrt-ccpp.service ├─abrt-oops.service.....(下面省略)..... process substitution &lt;( command ) or &gt;( command )如果使用 &gt;(list), 那帶入的值將會作為 list 的輸入。 若使用 &lt;(list), 那將會是 list 的輸出 語法&lt;(list) 或是 &gt;(list) logrotate那個 logrotate.conf 才是主要的參數文件，至於 logrotate.d 是一個目錄， 該目錄裡面的所有文件都會被主動的讀入 /etc/logrotate.conf 當中來進行！另外，在 /etc/logrotate.d/ 裡面的文件中，如果沒有規定到的一些細部設置，則以 /etc/logrotate.conf 這個文件的規定來指定為默認值！ logrotate 這個程序的參數配置文件位置/etc/logrotate.conf/etc/logrotate.d/ 語法logrotate [-vf] logfile選項與參數：-v ：啟動顯示模式，會顯示 logrotate 運行的過程喔！-f ：不論是否符合配置文件的數據，強制每個登錄文件都進行 rotate 的動作！範例一：執行一次 logrotate 看看整個流程為何？[root@study ~]# logrotate -v /etc/logrotate.confreading config file /etc/logrotate.conf &lt;==讀取主要配置文件including /etc/logrotate.d &lt;==調用外部的設置reading config file chrony &lt;==就是外部設置啊！....(中間省略)....Handling 18 logs &lt;==共有 18 個登錄文件被記錄....(中間省略)....rotating pattern: /var/log/cron/var/log/maillog/var/log/messages/var/log/secure/var/log/spooler weekly (52 rotations)empty log files are not rotated, old logs are removedconsidering log /var/log/cron log does not need rotatingconsidering log /var/log/maillog log does not need rotatingconsidering log /var/log/messages &lt;==開始處理 messages log does not need rotating &lt;==因為時間未到，不需要更動！....(下面省略)....範例二：強制進行 logrotate 的動作[root@study ~]# logrotate -vf /etc/logrotate.conf....(前面省略)....rotating log /var/log/messages, log-&gt;rotateCount is 52dateext suffix &apos;-20150820&apos;glob pattern &apos;-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]&apos;compressing log with: /bin/gzip....(下面省略)....# 看到否？整個 rotate 的動作就是這樣一步一步進行的～[root@study ~]# ll /var/log/messages*; lsattr /var/log/messages-rw-------. 1 root root 143 Aug 20 01:45 /var/log/messages-rw-------. 1 root root 167125 Aug 20 01:40 /var/log/messages-20150820-----a---------- /var/log/messages &lt;==主動加入 a 的隱藏屬性囉！ [root@study ~]# vim /etc/logrotate.conf# 下面的設置是 &quot;logrotate 的默認設置值&quot; ，如果個別的文件設置了其他的參數，# 則將以個別的文件設置為主，若該文件沒有設置到的參數則以這個文件的內容為默認值！weekly &lt;==默認每個禮拜對登錄文件進行一次 rotate 的工作rotate 4 &lt;==保留幾個登錄文件呢？默認是保留四個！create &lt;==由於登錄文件被更名，因此創建一個新的來繼續儲存之意！dateext &lt;==就是這個設置值！可以讓被輪替的文件名稱加上日期作為文件名喔！#compress &lt;==被更動的登錄文件是否需要壓縮？如果登錄文件太大則可考慮此參數啟動include /etc/logrotate.d# 將 /etc/logrotate.d/ 這個目錄中的所有文件都讀進來執行 rotate 的工作！/var/log/wtmp &#123; &lt;==僅針對 /var/log/wtmp 所設置的參數 monthly &lt;==每個月一次，取代每週！ create 0664 root utmp &lt;==指定新建文件的權限與所屬帳號/群組 minsize 1M &lt;==文件大小一定要超過 1M 後才進行 rotate (略過時間參數) rotate 1 &lt;==僅保留一個，亦即僅有 wtmp.1 保留而已。&#125;# 這個 wtmp 可記錄登陸者與系統重新開機時的時間與來源主機及登陸期間的時間。# 由於具有 minsize 的參數，因此不見得每個月一定會進行一次喔！要看文件大小。# 由於僅保留一個登錄文件而已，不滿意的話可以將他改成 rotate 5 吧！ 範例範例 1/root/.pm2/logs/run-checkEdgeAlive.log &#123; daily dateext missingok rotate 14 compress notifempty&#125; 範例 2以 /etc/logrotate.d/syslog 這個輪替 rsyslog.service 服務的文件vim /etc/logrotate.d/syslog/var/log/cron/var/log/maillog/var/log/messages/var/log/secure/var/log/spooler&#123; sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true endscript&#125; 文件名：被處理的登錄文件絕對路徑文件名寫在前面，可以使用空白字符分隔多個登錄文件； 參數：上述文件名進行輪替的參數使用 { } 包括起來； 執行腳本：可調用外部指令來進行額外的命令下達，這個設置需與 sharedscripts …. endscript 設置合用才行。至於可用的環境為： prerotate：在啟動 logrotate 之前進行的指令，例如修改登錄文件的屬性等動作； postrotate：在做完 logrotate 之後啟動的指令，例如重新啟動 (kill -HUP) 某個服務！ Prerotate 與 postrotate 對於已加上特殊屬性的文件處理上面，是相當重要的執行程序！ 那麼 /etc/logrotate.d/syslog 內設置的 5 個文件的輪替功能就變成了： 該設置只對 /var/log/ 內的 cron, maillog, messages, secure, spooler 有效； 登錄文件輪替每週一次、保留四個、且輪替下來的登錄文件不進行壓縮(未更改默認值)； 輪替完畢後 (postrotate) 取得 syslog 的 PID 後，以 kill -HUP 重新啟動 syslogd 假設我們有針對 /var/log/messages 這個文件增加 chattr +a 的屬性時， 依據 logrotate 的工作原理，我們知道，這個 /var/log/messages 將會被更名成為 /var/log/messages.1 才是。但是由於加上這個 +a 的參數啊，所以更名是不可能成功的！ 那怎麼辦呢？呵呵！就利用 prerotate 與 postrotate 來進行登錄文件輪替前、後所需要作的動作啊！ 果真如此時，那麼你可以這樣修改一下這個文件喔！ vim /etc/logrotate.d/syslog/var/log/cron/var/log/maillog/var/log/messages/var/log/secure/var/log/spooler&#123; sharedscripts prerotate /usr/bin/chattr -a /var/log/messages endscript sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true /usr/bin/chattr +a /var/log/messages endscript&#125; 先給他去掉 a 這個屬性，讓登錄文件 /var/log/messages 可以進行輪替的動作 然後執行了輪替之後，再給他加入這個屬性 /bin/kill -HUP … 的意義，這一行的目的在於將系統的 rsyslogd 重新以其參數文件 (rsyslog.conf) 的數據讀入一次！也可以想成是 reload 的意思！ 由於我們創建了一個新的空的記錄文件，如果不執行此一行來重新啟動服務的話， 那麼記錄的時候將會發生錯誤呦！ kill -HUP: 等同 kill -1, 重啟的意思 範例 3假設你已經創建了 /var/log/admin.log 這個文件， 現在，你想要將該文件加上 +a 這個隱藏標籤，而且設置下面的相關信息： 登錄文件輪替一個月進行一次； 該登錄文件若大於 10MB 時，則主動進行輪替，不需要考慮一個月的期限； 保存五個備份文件； 備份文件需要壓縮 先創建 +a 這個屬性[root@study ~]# chattr +a /var/log/admin.log[root@study ~]# lsattr /var/log/admin.log-----a---------- /var/log/admin.log[root@study ~]# mv /var/log/admin.log /var/log/admin.log.1mv: cannot move `/var/log/admin.log&apos; to `/var/log/admin.log.1&apos;: Operation not permitted# 這裡確定了加入 a 的隱藏屬性！所以 root 無法移動此登錄文件！ 開始創建 logrotate 的配置文件，增加一個文件在 /etc/logrotate.d 內[root@study ~]# vim /etc/logrotate.d/admin# This configuration is from VBird 2015/08/19/var/log/admin.log &#123; monthly &lt;==每個月進行一次 size=10M &lt;==文件大小大於 10M 則開始處置 rotate 5 &lt;==保留五個！ compress &lt;==進行壓縮工作！ sharedscripts prerotate /usr/bin/chattr -a /var/log/admin.log endscript sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2&gt; /dev/null` 2&gt; /dev/null || true /usr/bin/chattr +a /var/log/admin.log endscript&#125; 測試一下 logrotate 相關功能的信息顯示：[root@study ~]# logrotate -v /etc/logrotate.conf....(前面省略)....rotating pattern: /var/log/admin.log 10485760 Bytes (5 rotations)empty log files are rotated, old logs are removedconsidering log /var/log/admin.log log does not need rotatingnot running prerotate script, since no logs will be rotatednot running postrotate script, since no logs were rotated....(下面省略)....# 因為還不足一個月，文件也沒有大於 10M，所以不需進行輪替！ 測試一下強制 logrotate 與相關功能的信息顯示：[root@study ~]# logrotate -vf /etc/logrotate.d/adminreading config file /etc/logrotate.d/adminreading config file /etc/logrotate.d/adminHandling 1 logsrotating pattern: /var/log/admin.log forced from command line (5 rotations)empty log files are rotated, old logs are removedconsidering log /var/log/admin.log log needs rotatingrotating log /var/log/admin.log, log-&gt;rotateCount is 5dateext suffix &apos;-20150820&apos;glob pattern &apos;-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]&apos;renaming /var/log/admin.log.5.gz to /var/log/admin.log.6.gz (rotatecount 5, logstart 1, i 5),old log /var/log/admin.log.5.gz does not existrenaming /var/log/admin.log.4.gz to /var/log/admin.log.5.gz (rotatecount 5, logstart 1, i 4),old log /var/log/admin.log.4.gz does not existrenaming /var/log/admin.log.3.gz to /var/log/admin.log.4.gz (rotatecount 5, logstart 1, i 3),old log /var/log/admin.log.3.gz does not existrenaming /var/log/admin.log.2.gz to /var/log/admin.log.3.gz (rotatecount 5, logstart 1, i 2),old log /var/log/admin.log.2.gz does not existrenaming /var/log/admin.log.1.gz to /var/log/admin.log.2.gz (rotatecount 5, logstart 1, i 1),old log /var/log/admin.log.1.gz does not existrenaming /var/log/admin.log.0.gz to /var/log/admin.log.1.gz (rotatecount 5, logstart 1, i 0),old log /var/log/admin.log.0.gz does not existlog /var/log/admin.log.6.gz doesn&apos;t exist -- won&apos;t try to dispose of itrunning prerotate scriptfscreate context set to system_u:object_r:var_log_t:s0renaming /var/log/admin.log to /var/log/admin.log.1running postrotate scriptcompressing log with: /bin/gzip[root@study ~]# lsattr /var/log/admin.log*-----a---------- /var/log/admin.log---------------- /var/log/admin.log.1.gz &lt;==有壓縮過喔！ command || true patten目前大部分的系統遵循 set -e (Exit immediately if a command exits with a non-zero status.) 規則，所以為了避免一些小錯誤中斷了 command 的執行，所以使用 command || true patten例如 rmdir ... || true, 這樣就算 remove directory 失敗了， command 也不會中斷執行。 timedatectl語法timedatectl [commamd]選項與參數：list-timezones ：列出系統上所有支持的時區名稱set-timezone ：設置時區位置set-time ：設置時間set-ntp ：設置網絡校時系統 範例顯示目前的時區與時間等信息 指令 timedatectl 輸出 Local time: Tue 2015-09-01 19:50:09 CST # 本地時間 Universal time: Tue 2015-09-01 11:50:09 UTC # UTC 時間，可稱為格林威治標準時間 RTC time: Tue 2015-09-01 11:50:12 Timezone: Asia/Taipei (CST, +0800) # 就是時區囉！ NTP enabled: noNTP synchronized: no RTC in local TZ: no DST active: n/a 顯示出是否有 New_York 時區？若有，則請將目前的時區更新一下 查詢是否有 New York 時區timedatectl list-timezones | grep -i new 輸出:America/New_YorkAmerica/North_Dakota/New_Salem 設定時區 timedatectl set-timezone \"America/New_York\" 確認結果 timedatectl 範例輸出： Local time: Tue 2015-09-01 07:53:24 EDTUniversal time: Tue 2015-09-01 11:53:24 UTC RTC time: Tue 2015-09-01 11:53:28 Timezone: America/New_York (EDT, -0400) 時間點調整 指令 timedatectl set-time \"2019-09-30 09:00\" 時間格式: yyyy-mm-dd HH:MM ntpdatentpdate tock.stdtime.gov.tw hwclock -w 上述的 tock.stdtime.gov.tw 指的是臺灣地區國家標準實驗室提供的時間服務器，如果你在臺灣本島上，建議使用臺灣提供的時間服務器來更新你的服務器時間， 速度會比較快些～至於 hwclock 則是將正確的時間寫入你的 BIOS 時間記錄內！如果確認可以執行，未來應該可以使用 crontab 來更新系統時間吧！ locale on MacOS 打開 .zshrc, 並貼上以下代碼 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 保存離開 重開一個 terminal 視窗 localectl語法localectl System Locale: LANG=zh_TW.utf8 # 下面這些數據就是“系統語系” LC_NUMERIC=zh_TW.UTF-8 LC_TIME=zh_TW.UTF-8 LC_MONETARY=zh_TW.UTF-8 LC_PAPER=zh_TW.UTF-8 LC_MEASUREMENT=zh_TW.UTF-8 VC Keymap: cn X11 Layout: cn X11 Options: grp:ctrl_shift_toggle[root@study ~]# localeLANG=zh_TW.utf8 # 下面的則是“當前這個軟件的語系”數據！LC_CTYPE=&quot;en_US.utf8&quot;LC_NUMERIC=&quot;en_US.utf8&quot;.....(中間省略).....LC_ALL=en_US.utf8 範例如何改成英文語系的登陸界面？ localectl set-locale LANG=en_US.utf8systemctl isolate multi-user.targetsystemctl isolate graphical.target dpkg列出所有 dpkg 安裝的套件dpkg -l | less teetee 可以讓 standard output 轉存一份到文件內並將同樣的數據繼續送到屏幕去處理！ 這樣除了可以讓我們同時分析一份數據並記錄下來之外，還可以作為處理一份數據的中間暫存盤記錄之用！ tee 這傢伙在很多選擇/填充的認證考試中很容易考呢！ 語法[dmtsai@study ~]$ tee [-a] file選項與參數：-a ：以累加 (append) 的方式，將數據加入 file 當中！[dmtsai@study ~]$ last | tee last.list | cut -d &quot; &quot; -f1# 這個範例可以讓我們將 last 的輸出存一份到 last.list 文件中；[dmtsai@study ~]$ ls -l /home | tee ~/homefile | more# 這個範例則是將 ls 的數據存一份到 ~/homefile ，同時屏幕也有輸出訊息！[dmtsai@study ~]$ ls -l / | tee -a ~/homefile | more# 要注意！ tee 後接的文件會被覆蓋，若加上 -a 這個選項則能將訊息累加。 sed語法[dmtsai@study ~]$ sed [-nefr] [動作]選項與參數：-n ：使用安靜(silent)模式。在一般 sed 的用法中，所有來自 STDIN 的數據一般都會被列出到屏幕上。 但如果加上 -n 參數後，則只有經過 sed 特殊處理的那一行(或者動作)才會被列出來。-e ：直接在命令行界面上進行 sed 的動作編輯；-f ：直接將 sed 的動作寫在一個文件內， -f filename 則可以執行 filename 內的 sed 動作；-r ：sed 的動作支持的是延伸型正則表達式的語法。(默認是基礎正則表達式語法)-i ：直接修改讀取的文件內容，而不是由屏幕輸出。動作說明： [n1[,n2]]functionn1, n2 ：不見得會存在，一般代表“選擇進行動作的行數”，舉例來說，如果我的動作 是需要在 10 到 20 行之間進行的，則“ 10,20[動作行為] ”function 有下面這些咚咚：a ：新增， a 的後面可以接字串，而這些字串會在新的一行出現(目前的下一行)～c ：取代， c 的後面可以接字串，這些字串可以取代 n1,n2 之間的行！d ：刪除，因為是刪除啊，所以 d 後面通常不接任何咚咚；i ：插入， i 的後面可以接字串，而這些字串會在新的一行出現(目前的上一行)；p ：打印，亦即將某個選擇的數據印出。通常 p 會與參數 sed -n 一起運行～s ：取代，可以直接進行取代的工作哩！通常這個 s 的動作可以搭配正則表達式！ 例如 1,20s/old/new/g 就是啦！ 範例範例一將 /etc/passwd 的內容列出並且打印行號，同時，請將第 2~5 行刪除！nl /etc/passwd | sed '2,5d' 輸出：1 root:x:0:0:root:/root:/bin/bash6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 原本應要下達 sed -e ，沒有 -e 也行 sed 後面接的動作，請務必以 ‘’ 兩個單引號括住 如果只要刪除第 2 行，可以使用 nl /etc/passwd | sed &#39;2d&#39; 若是要刪除第 3 到最後一行，則是 nl /etc/passwd | sed &#39;3,$d&#39; 範例二承上題，在第二行後(亦即是加在第三行)加上“drink tea?”字樣！nl /etc/passwd | sed '2a drink tea' 輸出：1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologindrink tea3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 如果是要在第二行前呢？ nl /etc/passwd | sed &#39;2i drink tea&#39; 範例三在第二行後面加入兩行字，例如“Drink tea or …..”與“drink beer?”nl /etc/passwd | sed &apos;2a Drink tea or ......\\&gt; drink beer ?&apos; 輸出:1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologinDrink tea or ......drink beer ?3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 可以新增好幾行”但是每一行之間都必須要以反斜線 \\ 範例四搜尋檔案中有 gzip_ 的每一行, 將該行中的 # 取代為空白, 簡單來說, 就是 uncomment 啦sed -i '/gzip_/ s/#\\ //g' /etc/nginx/nginx.conf 結果前後比較： 替換變量的值將變量中的 sbin 替換成 SBINecho $&#123;PATH//sbin/SBIN&#125; route[root@www ~]# route [-n]選項與參數：-n ： 將主機名稱以 IP 的方式顯示 [root@www ~]# routeKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.0.0 * 255.255.255.0 U 0 0 0 eth0127.0.0.0 * 255.0.0.0 U 0 0 0 lodefault 192.168.0.254 0.0.0.0 UG 0 0 0 eth0 [root@www ~]# route -nKernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.0.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo0.0.0.0 192.168.0.254 0.0.0.0 UG 0 0 0 eth0# 上面輸出的資料共有八個欄位，你需要注意的有幾個地方：# Destination ：其實就是 Network 的意思；# Gateway ：就是該介面的 Gateway 那個 IP 啦！若為 0.0.0.0 表示不需要額外的 IP；# Genmask ：就是 Netmask 啦！與 Destination 組合成為一部主機或網域；# Flags ：共有多個旗標可以來表示該網域或主機代表的意義：# U：代表該路由可用；# G：代表該網域需要經由 Gateway 來幫忙轉遞；# H：代表該行路由為一部主機，而非一整個網域；# Iface ：就是 Interface (介面) 的意思。 jq 取得來源 object 裡的一個 property, 並轉為 raw 輸出node test.js | jq -r '.propertyName' arp語法[root@www ~]# arp -[nd] hostname[root@www ~]# arp -s hostname(IP) Hardware_address選項與參數：-n ：將主機名稱以 IP 的型態顯示-d ：將 hostname 的 hardware_address 由 ARP table 當中刪除掉-s ：設定某個 IP 或 hostname 的 MAC 到 ARP table 當中 範例 列出目前主機上記載的 IP/MAC 對應的 ARP 表格arp -n Address HWtype HWaddress Flags Mask Iface192.168.1.100 ether 00:01:03:01:02:03 C eth0192.168.1.240 ether 00:01:03:01:DE:0A C eth0192.168.1.254 ether 00:01:03:55:74:AB C eth0 將 192.168.1.100 那部主機的網卡卡號直接寫入 ARP 表格中arp -s 192.168.1.100 01:00:2D:23:A1:0E SBIT語法chmod 1xxx directoryName 或是建立時給予權限 insatll -d -o ownerName -g groupName -m 1xxx directoryName 只對目錄有效 一般來說, 任意的使用者, 只要對該目錄有 wx 的權限, 都可以 進去該資料夾 以及 刪除該資料夾內的檔案(資料夾) 加上 SBIT 的屬性之後, 只有 該目錄的擁有者, root, 檔案的建立者 才可以刪除該目錄內的檔案(或資料夾) ifconfig語法ifconfig &#123;interface&#125; &#123;up|down&#125; &lt;== 觀察與啟動介面ifconfig interface &#123;options&#125; &lt;== 設定與修改介面選項與參數：interface：網路卡介面代號，包括 eth0, eth1, ppp0 等等options ：可以接的參數，包括如下： up, down ：啟動 (up) 或關閉 (down) 該網路介面(不涉及任何參數) mtu ：可以設定不同的 MTU 數值，例如 mtu 1500 (單位為 byte) netmask ：就是子遮罩網路； broadcast：就是廣播位址啊！ 範例 範例一：觀察所有的網路介面(直接輸入 ifconfig)[root@www ~]# ifconfigeth0 Link encap:Ethernet HWaddr 08:00:27:71:85:BD inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0 inet6 addr: fe80::a00:27ff:fe71:85bd/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:2555 errors:0 dropped:0 overruns:0 frame:0 TX packets:70 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:239892 (234.2 KiB) TX bytes:11153 (10.8 KiB) eth0： 就是網路卡的代號，也有 lo 這個 loopback ；HWaddr： 就是網路卡的硬體位址，俗稱的 MAC 是也；inet addr： IPv4 的 IP 位址，後續的 Bcast, Mask 分別代表的是 Broadcast 與 netmask 喔！inet6 addr： 是 IPv6 的版本的 IP ，我們沒有使用，所以略過；MTU： 就是第二章談到的 MTU 啊！RX： 那一行代表的是網路由啟動到目前為止的封包接收情況， packets 代表封包數、errors 代表封包發生錯誤的數量、 dropped 代表封包由於有問題而遭丟棄的數量等等TX： 與 RX 相反，為網路由啟動到目前為止的傳送情況；collisions： 代表封包碰撞的情況，如果發生太多次， 表示你的網路狀況不太好；txqueuelen： 代表用來傳輸資料的緩衝區的儲存長度；RX bytes, TX bytes： 總接收、傳送的位元組總量 範例二：暫時修改網路介面，給予 eth0 一個 192.168.100.100/24 的參數 [root@www ~]# ifconfig eth0 192.168.100.100# 如果不加任何其他參數，則系統會依照該 IP 所在的 class 範圍，自動的計算出# netmask 以及 network, broadcast 等 IP 參數，若想改其他參數則：[root@www ~]# ifconfig eth0 192.168.100.100 \\&gt; netmask 255.255.255.128 mtu 8000 # 設定不同參數的網路介面，同時設定 MTU 的數值！[root@www ~]# ifconfig eth0 mtu 9000# 僅修改該介面的 MTU 數值，其他的保持不動！[root@www ~]# ifconfig eth0:0 192.168.50.50# 仔細看那個介面是 eth0:0 喔！那就是在該實體網卡上，再模擬一個網路介面，# 亦即是在一張網路卡上面設定多個 IP 的意思啦！[root@www ~]# ifconfigeth0 Link encap:Ethernet HWaddr 08:00:27:71:85:BD inet addr:192.168.100.100 Bcast:192.168.100.127 Mask:255.255.255.128 inet6 addr: fe80::a00:27ff:fe71:85bd/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:9000 Metric:1 RX packets:2555 errors:0 dropped:0 overruns:0 frame:0 TX packets:70 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:239892 (234.2 KiB) TX bytes:11153 (10.8 KiB)eth0:0 Link encap:Ethernet HWaddr 08:00:27:71:85:BD inet addr:192.168.50.50 Bcast:192.168.50.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:9000 Metric:1# 仔細看，是否與硬體有關的資訊都相同啊！沒錯！因為是同一張網卡嘛！# 那如果想要將剛剛建立的那張 eth0:0 關閉就好，不影響原有的 eth0 呢？[root@www ~]# ifconfig eth0:0 down# 關掉 eth0:0 這個介面。那如果想用預設值啟動 eth1：『ifconfig eth1 up』即可達成 範例三：將手動的處理全部取消，使用原有的設定值重建網路參數:[root@www ~]# /etc/init.d/network restart# 剛剛設定的資料全部失效，會以 ifcfg-ethX 的設定為主！ apt route語法[root@www ~]# route [-nee][root@www ~]# route add [-net|-host] [網域或主機] netmask [mask] [gw|dev][root@www ~]# route del [-net|-host] [網域或主機] netmask [mask] [gw|dev]觀察的參數： -n ：不要使用通訊協定或主機名稱，直接使用 IP 或 port number； -ee ：使用更詳細的資訊來顯示增加 (add) 與刪除 (del) 路由的相關參數： -net ：表示後面接的路由為一個網域； -host ：表示後面接的為連接到單部主機的路由； netmask ：與網域有關，可以設定 netmask 決定網域的大小； gw ：gateway 的簡寫，後續接的是 IP 的數值喔，與 dev 不同； dev ：如果只是要指定由那一塊網路卡連線出去，則使用這個設定，後面接 eth0 等 範例單純的觀察路由狀態 指令1 route -n 範例輸出1 Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.0 0.0.0.0 255.255.255.0 U 0 0 0 eth0169.254.0.0 0.0.0.0 255.255.0.0 U 1002 0 0 eth00.0.0.0 192.168.1.254 0.0.0.0 UG 0 0 0 eth0 指令2 route 範例輸出2 Kernel IP routing tableDestination Gateway Genmask Flags Metric Ref Use Iface192.168.1.0 * 255.255.255.0 U 0 0 0 eth0link-local * 255.255.0.0 U 1002 0 0 eth0default 192.168.1.254 0.0.0.0 UG 0 0 0 eth0 路由的增加與刪除[root@www ~]# route del -net 169.254.0.0 netmask 255.255.0.0 dev eth0# 上面這個動作可以刪除掉 169.254.0.0/16 這個網域！# 請注意，在刪除的時候，需要將路由表上面出現的資訊都寫入# 包括 netmask , dev 等等參數喔！注意注意[root@www ~]# route add -net 192.168.100.0 \\&gt; netmask 255.255.255.0 dev eth0# 透過 route add 來增加一個路由！請注意，這個路由的設定必須要能夠與你的網路互通。# 舉例來說，如果我下達底下的指令就會顯示錯誤：# route add -net 192.168.200.0 netmask 255.255.255.0 gw 192.168.200.254# 因為我的主機內僅有 192.168.1.11 這個 IP ，所以不能直接與 192.168.200.254# 這個網段直接使用 MAC 互通！這樣說，可以理解嗎？[root@www ~]# route add default gw 192.168.1.250# 增加預設路由的方法！請注意，只要有一個預設路由就夠了喔！# 同樣的，那個 192.168.1.250 的 IP 也需要能與你的 LAN 溝通才行！# 在這個地方如果你隨便設定後，記得使用底下的指令重新設定你的網路# /etc/init.d/network restart 輸出資訊意義 Destination, Genmask：這兩個玩意兒就是分別是 network 與 netmask 啦！所以這兩個咚咚就組合成為一個完整的網域囉！ Gateway：該網域是通過哪個 gateway 連接出去的？如果顯示 0.0.0.0 表示該路由是直接由本機傳送，亦即可以透過區域網路的 MAC 直接傳訊；如果有顯示 IP 的話，表示該路由需要經過路由器 (通訊閘) 的幫忙才能夠傳送出去。 Flags：總共有多個旗標，代表的意義如下： U (route is up)：該路由是啟動的； H (target is a host)：目標是一部主機 (IP) 而非網域； G (use gateway)：需要透過外部的主機 (gateway) 來轉遞封包； R (reinstate route for dynamic routing)：使用動態路由時，恢復路由資訊的旗標； D (dynamically installed by daemon or redirect)：已經由服務或轉 port 功能設定為動態路由 M (modified from routing daemon or redirect)：路由已經被修改了； ! (reject route)：這個路由將不會被接受(用來抵擋不安全的網域！) Iface：這個路由傳遞封包的介面。 ip語法[root@www ~]# ip [option] [動作] [指令]選項與參數：option ：設定的參數，主要有： -s ：顯示出該裝置的統計數據(statistics)，例如總接受封包數等；動作：亦即是可以針對哪些網路參數進行動作，包括有： link ：關於裝置 (device) 的相關設定，包括 MTU, MAC 位址等等 addr/address ：關於額外的 IP 協定，例如多 IP 的達成等等； route ：與路由有關的相關設定 traceroute語法[root@www ~]# traceroute [選項與參數] IP選項與參數：-n ：可以不必進行主機的名稱解析，單純用 IP ，速度較快！-U ：使用 UDP 的 port 33434 來進行偵測，這是預設的偵測協定；-I ：使用 ICMP 的方式來進行偵測；-T ：使用 TCP 來進行偵測，一般使用 port 80 測試-w ：若對方主機在幾秒鐘內沒有回聲就宣告不治...預設是 5 秒-p 埠號：若不想使用 UDP 與 TCP 的預設埠號來偵測，可在此改變埠號。-i 裝置：用在比較複雜的環境，如果你的網路介面很多很複雜時，才會用到這個參數； 舉例來說，你有兩條 ADSL 可以連接到外部，那你的主機會有兩個 ppp， 你可以使用 -i 來選擇是 ppp0 還是 ppp1 啦！-g 路由：與 -i 的參數相仿，只是 -g 後面接的是 gateway 的 IP 就是了。 範例偵測本機到 yahoo 去的各節點連線狀態[root@www ~]# traceroute -n tw.yahoo.comtraceroute to tw.yahoo.com (119.160.246.241), 30 hops max, 40 byte packets 1 192.168.1.254 0.279 ms 0.156 ms 0.169 ms 2 172.20.168.254 0.430 ms 0.513 ms 0.409 ms 3 10.40.1.1 0.996 ms 0.890 ms 1.042 ms 4 203.72.191.85 0.942 ms 0.969 ms 0.951 ms 5 211.20.206.58 1.360 ms 1.379 ms 1.355 ms 6 203.75.72.90 1.123 ms 0.988 ms 1.086 ms 7 220.128.24.22 11.238 ms 11.179 ms 11.128 ms 8 220.128.1.82 12.456 ms 12.327 ms 12.221 ms 9 220.128.3.149 8.062 ms 8.058 ms 7.990 ms10 * * *11 119.160.240.1 10.688 ms 10.590 ms 119.160.240.3 10.047 ms12 * * * &lt;==可能有防火牆裝置等情況發生所致 tcpdump語法[root@www ~]# tcpdump [-AennqX] [-i 介面] [-w 儲存檔名] [-c 次數] \\ [-r 檔案] [所欲擷取的封包資料格式]選項與參數：-A ：封包的內容以 ASCII 顯示，通常用來捉取 WWW 的網頁封包資料。-e ：使用資料連接層 (OSI 第二層) 的 MAC 封包資料來顯示；-nn：直接以 IP 及 port number 顯示，而非主機名與服務名稱-q ：僅列出較為簡短的封包資訊，每一行的內容比較精簡-X ：可以列出十六進位 (hex) 以及 ASCII 的封包內容，對於監聽封包內容很有用-i ：後面接要『監聽』的網路介面，例如 eth0, lo, ppp0 等等的介面；-w ：如果你要將監聽所得的封包資料儲存下來，用這個參數就對了！後面接檔名-r ：從後面接的檔案將封包資料讀出來。那個『檔案』是已經存在的檔案， 並且這個『檔案』是由 -w 所製作出來的。-c ：監聽的封包數，如果沒有這個參數， tcpdump 會持續不斷的監聽， 直到使用者輸入 [ctrl]-c 為止。所欲擷取的封包資料格式：我們可以專門針對某些通訊協定或者是 IP 來源進行封包擷取， 那就可以簡化輸出的結果，並取得最有用的資訊。常見的表示方法有： &apos;host foo&apos;, &apos;host 127.0.0.1&apos; ：針對單部主機來進行封包擷取 &apos;net 192.168&apos; ：針對某個網域來進行封包的擷取； &apos;src host 127.0.0.1&apos; &apos;dst net 192.168&apos;：同時加上來源(src)或目標(dst)限制 &apos;tcp port 21&apos;：還可以針對通訊協定偵測，如 tcp, udp, arp, ether 等 還可以利用 and 與 or 來進行封包資料的整合顯示呢！ 範例以 IP 與 port number 捉下 eth0 這個網路卡上的封包，持續 3 秒[root@www ~]# tcpdump -i eth0 -nntcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes17:01:47.360523 IP 192.168.1.101.1937 &gt; 192.168.1.100.22: Flags [.], ack 196, win 65219, 17:01:47.362139 IP 192.168.1.100.22 &gt; 192.168.1.101.1937: Flags [P.], seq 196:472, ack 1,17:01:47.363201 IP 192.168.1.100.22 &gt; 192.168.1.101.1937: Flags [P.], seq 472:636, ack 1,17:01:47.363328 IP 192.168.1.101.1937 &gt; 192.168.1.100.22: Flags [.], ack 636, win 64779,&lt;==按下 [ctrl]-c 之後結束6680 packets captured &lt;==捉下來的封包數量14250 packets received by filter &lt;==由過濾所得的總封包數量7512 packets dropped by kernel &lt;==被核心所丟棄的封包 17:01:47.362139：此封包被擷取的時間，『時:分:秒』的單位； IP：透過的通訊協定是 IP ； 192.168.1.100.22 &gt; ：傳送端是 192.168.1.100 這個 IP，而傳送的 port number 為 22，大於 (&gt;) 的符號指的是封包的傳輸方向 192.168.1.101.1937：接收端的 IP 是 192.168.1.101， 主機開啟 port 1937 來接收； [P.], seq 196:472：這個封包帶有 PUSH 的資料傳輸標誌， 且傳輸的資料為整體資料的 196~472 byte； ack 1：ACK 的相關資料。 簡單來說, 該封包是由 192.168.1.100 傳到 192.168.1.101，透過的 port 是由 22 到 1937 ， 使用的是 PUSH 的旗標，而不是 SYN 之類的主動連線標誌 只取 port 21[root@www ~]# tcpdump -i eth0 -nn port 21tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes01:54:37.96 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: . ack 1 win 6553501:54:37.96 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: P 1:21(20) ack 1 win 584001:54:38.12 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: . ack 21 win 6551501:54:42.79 IP 192.168.1.101.1240 &gt; 192.168.1.100.21: P 1:17(16) ack 21 win 6551501:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: . ack 17 win 584001:54:42.79 IP 192.168.1.100.21 &gt; 192.168.1.101.1240: P 21:55(34) ack 17 win 5840 封包的傳遞都是雙向的， client 端發出『要求』而 server 端則予以『回應』 監聽本地 localhost 試驗我們先在一個終端機視窗輸入『 tcpdump -i lo -nn 』 的監聽，再另開一個終端機視窗來對本機 (127.0.0.1) 登入『ssh localhost』 [root@www ~]# tcpdump -i lo -nn 1 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode 2 listening on lo, link-type EN10MB (Ethernet), capture size 96 bytes 3 11:02:54.253777 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: S 933696132:933696132(0) win 32767 &lt;mss 16396,sackOK,timestamp 236681316 0,nop,wscale 2&gt; 4 11:02:54.253831 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: S 920046702:920046702(0) ack 933696133 win 32767 &lt;mss 16396,sackOK,timestamp 236681316 236681316,nop, wscale 2&gt; 5 11:02:54.253871 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 1 win 8192 &lt;nop, nop,timestamp 236681316 236681316&gt; 6 11:02:54.272124 IP 127.0.0.1.22 &gt; 127.0.0.1.32936: P 1:23(22) ack 1 win 8192 &lt;nop,nop,timestamp 236681334 236681316&gt; 7 11:02:54.272375 IP 127.0.0.1.32936 &gt; 127.0.0.1.22: . ack 23 win 8192 &lt;nop, nop,timestamp 236681334 236681334&gt; 第 3 行顯示的是『來自 client 端，帶有 SYN 主動連線的封包』， 第 4 行顯示的是『來自 server 端，除了回應 client 端之外(ACK)，還帶有 SYN 主動連線的標誌； 第 5 行則顯示 client 端回應 server 確定連線建立 (ACK) 第 6 行以後則開始進入資料傳輸的步驟。 nmap語法[root@www ~]# nmap [掃瞄類型] [掃瞄參數] [hosts 位址與範圍]選項與參數：[掃瞄類型]：主要的掃瞄類型有底下幾種： -sT：掃瞄 TCP 封包已建立的連線 connect() ！ -sS：掃瞄 TCP 封包帶有 SYN 標籤的資料 -sP：以 ping 的方式進行掃瞄 -sU：以 UDP 的封包格式進行掃瞄 -sO：以 IP 的協定 (protocol) 進行主機的掃瞄[掃瞄參數]：主要的掃瞄參數有幾種： -PT：使用 TCP 裡頭的 ping 的方式來進行掃瞄，可以獲知目前有幾部電腦存活(較常用) -PI：使用實際的 ping (帶有 ICMP 封包的) 來進行掃瞄 -p ：這個是 port range ，例如 1024-, 80-1023, 30000-60000 等等的使用方式[Hosts 位址與範圍]：這個有趣多了，有幾種類似的類型 192.168.1.100 ：直接寫入 HOST IP 而已，僅檢查一部； 192.168.1.0/24 ：為 C Class 的型態， 192.168.*.* ：嘿嘿！則變為 B Class 的型態了！掃瞄的範圍變廣了！ 192.168.1.0-50,60-100,103,200 ：這種是變形的主機範圍啦！很好用吧！ 範例使用預設參數掃瞄本機所啟用的 port (只會掃瞄 TCP)[root@www ~]# yum install nmap[root@www ~]# nmap localhostPORT STATE SERVICE22/tcp open ssh25/tcp open smtp111/tcp open rpcbind 同時掃瞄本機的 TCP/UDP 埠口[root@www ~]# nmap -sTU localhostPORT STATE SERVICE22/tcp open ssh25/tcp open smtp111/tcp open rpcbind111/udp open rpcbind &lt;= 透過 ICMP 封包的檢測，分析區網內有幾部主機是啟動的[root@www ~]# nmap -sP 192.168.1.0/24Starting Nmap 5.21 ( http://nmap.org ) at 2011-07-20 17:05 CSTNmap scan report for www.centos.vbird (192.168.1.100)Host is up.Nmap scan report for 192.168.1.101 &lt;==這三行講的是 192.168.101 的範例！Host is up (0.00024s latency).MAC Address: 00:1B:FC:58:9A:BB (Asustek Computer) Nmap scan report for 192.168.1.254Host is up (0.00026s latency).MAC Address: 00:0C:6E:85:D5:69 (Asustek Computer)Nmap done: 256 IP addresses (3 hosts up) scanned in 3.81 seconds dig語法[root@www ~]# dig [options] FQDN [@server]選項與參數：@server ：如果不以 /etc/resolv.conf 的設定來作為 DNS 查詢，可在此填入其他的 IPoptions：相關的參數很多，主要有 +trace, -t type 以及 -x 三者最常用 +trace ：就是從 . 開始追蹤，在 19.1.2 裡面談過了！回頭瞧瞧去！ -t type：查詢的資料主要有 mx, ns, soa 等類型，相關類型 19.4 來介紹 -x ：查詢反解資訊，非常重要的項目！ 範例使用預設值查詢 linux.vbird.org[root@www ~]# dig linux.vbird.org; &lt;&lt;&gt;&gt; DiG 9.7.0-P2-RedHat-9.7.0-5.P2.el6_0.1 &lt;&lt;&gt;&gt; linux.vbird.org;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 37415;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 0;; QUESTION SECTION: &lt;==提出的問題的部分;linux.vbird.org. IN A;; ANSWER SECTION: &lt;==主要的回答階段linux.vbird.org. 600 IN A 140.116.44.180;; AUTHORITY SECTION: &lt;==其他與此次回答有關的部分vbird.org. 600 IN NS dns.vbird.org.vbird.org. 600 IN NS dns2.vbird.org.;; Query time: 9 msec;; SERVER: 168.95.1.1#53(168.95.1.1);; WHEN: Thu Aug 4 14:12:26 2011;; MSG SIZE rcvd: 86 查詢 linux.vbird.org 的 SOA 相關資訊[root@www ~]# dig -t soa linux.vbird.org; &lt;&lt;&gt;&gt; DiG 9.7.0-P2-RedHat-9.7.0-5.P2.el6_0.1 &lt;&lt;&gt;&gt; -t soa linux.vbird.org;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 57511;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0;; QUESTION SECTION:;linux.vbird.org. IN SOA;; AUTHORITY SECTION:vbird.org. 600 IN SOA dns.vbird.org. root.dns.vbird.org. 2007091402 28800 7200 720000 86400;; Query time: 17 msec;; SERVER: 168.95.1.1#53(168.95.1.1);; WHEN: Thu Aug 4 14:15:57 2011;; MSG SIZE rcvd: 78 rsync範例： 同步 A 資料夾的內容到 B 資料夾, 不要同步 .git 資料夾 rsync -avz --exclude .git sourceDirectory/ targetDirectory -a: 同步權限 -v: 顯示過程詳細訊息 -z: 過程中壓縮 Q&amp;A apt 底層包的是？ dpkg dpkg 安裝 package 時, 會將 *.deb 放在? /var/cache/apt/archives/ 路由的排列有順序之分嗎？ 有哦 路由排列的規則？ 由小網域到大網域","link":"/zh-tw/Linux/"}],"tags":[{"name":"Apache","slug":"Apache","link":"/zh-tw/tags/Apache/"},{"name":"MySQL","slug":"MySQL","link":"/zh-tw/tags/MySQL/"},{"name":"Composer","slug":"Composer","link":"/zh-tw/tags/Composer/"},{"name":"Laravel","slug":"Laravel","link":"/zh-tw/tags/Laravel/"},{"name":"PHP","slug":"PHP","link":"/zh-tw/tags/PHP/"},{"name":"GCP Essentials","slug":"GCP-Essentials","link":"/zh-tw/tags/GCP-Essentials/"},{"name":"QWIKLABS","slug":"QWIKLABS","link":"/zh-tw/tags/QWIKLABS/"},{"name":"Google Load Balancers","slug":"Google-Load-Balancers","link":"/zh-tw/tags/Google-Load-Balancers/"},{"name":"GCP Compute Engine","slug":"GCP-Compute-Engine","link":"/zh-tw/tags/GCP-Compute-Engine/"},{"name":"GCP Marketplace","slug":"GCP-Marketplace","link":"/zh-tw/tags/GCP-Marketplace/"},{"name":"GCP Kubernetes Engine","slug":"GCP-Kubernetes-Engine","link":"/zh-tw/tags/GCP-Kubernetes-Engine/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/zh-tw/tags/Kubernetes/"},{"name":"Google Kubernetes Engine Best Practices","slug":"Google-Kubernetes-Engine-Best-Practices","link":"/zh-tw/tags/Google-Kubernetes-Engine-Best-Practices/"},{"name":"Google Cloud IAM","slug":"Google-Cloud-IAM","link":"/zh-tw/tags/Google-Cloud-IAM/"},{"name":"GCP-Security & Identity Fundamentals","slug":"GCP-Security-Identity-Fundamentals","link":"/zh-tw/tags/GCP-Security-Identity-Fundamentals/"},{"name":"Laravel Transaction","slug":"Laravel-Transaction","link":"/zh-tw/tags/Laravel-Transaction/"},{"name":"Laravel Log","slug":"Laravel-Log","link":"/zh-tw/tags/Laravel-Log/"},{"name":"ngrok","slug":"ngrok","link":"/zh-tw/tags/ngrok/"},{"name":"Laravel Middleware","slug":"Laravel-Middleware","link":"/zh-tw/tags/Laravel-Middleware/"},{"name":"AWS SQS","slug":"AWS-SQS","link":"/zh-tw/tags/AWS-SQS/"},{"name":"Laravel Queue","slug":"Laravel-Queue","link":"/zh-tw/tags/Laravel-Queue/"},{"name":"Laravel blade","slug":"Laravel-blade","link":"/zh-tw/tags/Laravel-blade/"},{"name":"Laravel template","slug":"Laravel-template","link":"/zh-tw/tags/Laravel-template/"},{"name":"Laravel view","slug":"Laravel-view","link":"/zh-tw/tags/Laravel-view/"},{"name":"Linux","slug":"Linux","link":"/zh-tw/tags/Linux/"},{"name":"MongoDB","slug":"MongoDB","link":"/zh-tw/tags/MongoDB/"},{"name":"Node.js","slug":"Node-js","link":"/zh-tw/tags/Node-js/"},{"name":"GCP Stackdriver","slug":"GCP-Stackdriver","link":"/zh-tw/tags/GCP-Stackdriver/"},{"name":"Baseline: Infrastructure","slug":"Baseline-Infrastructure","link":"/zh-tw/tags/Baseline-Infrastructure/"},{"name":"Laravel Image","slug":"Laravel-Image","link":"/zh-tw/tags/Laravel-Image/"},{"name":"Laravel package Intervention","slug":"Laravel-package-Intervention","link":"/zh-tw/tags/Laravel-package-Intervention/"},{"name":"Hexo","slug":"Hexo","link":"/zh-tw/tags/Hexo/"},{"name":"minos","slug":"minos","link":"/zh-tw/tags/minos/"},{"name":"class","slug":"class","link":"/zh-tw/tags/class/"},{"name":"object","slug":"object","link":"/zh-tw/tags/object/"},{"name":"SFTP","slug":"SFTP","link":"/zh-tw/tags/SFTP/"},{"name":"GCP Cloud Functions","slug":"GCP-Cloud-Functions","link":"/zh-tw/tags/GCP-Cloud-Functions/"},{"name":"PayPal REST API","slug":"PayPal-REST-API","link":"/zh-tw/tags/PayPal-REST-API/"},{"name":"GCP IAM","slug":"GCP-IAM","link":"/zh-tw/tags/GCP-IAM/"},{"name":"Google Cloud Storage","slug":"Google-Cloud-Storage","link":"/zh-tw/tags/Google-Cloud-Storage/"},{"name":"GCP-Baseline:Infrastructure","slug":"GCP-Baseline-Infrastructure","link":"/zh-tw/tags/GCP-Baseline-Infrastructure/"},{"name":"GCP Storage","slug":"GCP-Storage","link":"/zh-tw/tags/GCP-Storage/"},{"name":"Kubernetes health check","slug":"Kubernetes-health-check","link":"/zh-tw/tags/Kubernetes-health-check/"},{"name":"Cloud Architecture","slug":"Cloud-Architecture","link":"/zh-tw/tags/Cloud-Architecture/"},{"name":"GCP Spinnaker","slug":"GCP-Spinnaker","link":"/zh-tw/tags/GCP-Spinnaker/"},{"name":"Jenkins","slug":"Jenkins","link":"/zh-tw/tags/Jenkins/"},{"name":"Kubernetes in the Google Cloud","slug":"Kubernetes-in-the-Google-Cloud","link":"/zh-tw/tags/Kubernetes-in-the-Google-Cloud/"},{"name":"Stackdriver Logging","slug":"Stackdriver-Logging","link":"/zh-tw/tags/Stackdriver-Logging/"},{"name":"Google Deployment Manager","slug":"Google-Deployment-Manager","link":"/zh-tw/tags/Google-Deployment-Manager/"},{"name":"Docker Image","slug":"Docker-Image","link":"/zh-tw/tags/Docker-Image/"},{"name":"Docker Container","slug":"Docker-Container","link":"/zh-tw/tags/Docker-Container/"},{"name":"Docker Swarm","slug":"Docker-Swarm","link":"/zh-tw/tags/Docker-Swarm/"},{"name":"Docker Multi Stage","slug":"Docker-Multi-Stage","link":"/zh-tw/tags/Docker-Multi-Stage/"},{"name":"Docker Compose","slug":"Docker-Compose","link":"/zh-tw/tags/Docker-Compose/"},{"name":"Docker Service","slug":"Docker-Service","link":"/zh-tw/tags/Docker-Service/"},{"name":"Docker Rolling Update","slug":"Docker-Rolling-Update","link":"/zh-tw/tags/Docker-Rolling-Update/"},{"name":"Docker Push","slug":"Docker-Push","link":"/zh-tw/tags/Docker-Push/"},{"name":"Docker Deployment","slug":"Docker-Deployment","link":"/zh-tw/tags/Docker-Deployment/"},{"name":"gcloud shell","slug":"gcloud-shell","link":"/zh-tw/tags/gcloud-shell/"},{"name":"vsftpd","slug":"vsftpd","link":"/zh-tw/tags/vsftpd/"},{"name":"ftp","slug":"ftp","link":"/zh-tw/tags/ftp/"},{"name":"Facebook Graph API","slug":"Facebook-Graph-API","link":"/zh-tw/tags/Facebook-Graph-API/"},{"name":"Git","slug":"Git","link":"/zh-tw/tags/Git/"},{"name":"git rebase -i","slug":"git-rebase-i","link":"/zh-tw/tags/git-rebase-i/"},{"name":"git rebase -i --onto","slug":"git-rebase-i-onto","link":"/zh-tw/tags/git-rebase-i-onto/"},{"name":"git reset --hard","slug":"git-reset-hard","link":"/zh-tw/tags/git-reset-hard/"},{"name":"git reset @^ --hard","slug":"git-reset-hard","link":"/zh-tw/tags/git-reset-hard/"},{"name":"git checkout -b","slug":"git-checkout-b","link":"/zh-tw/tags/git-checkout-b/"},{"name":"git flow","slug":"git-flow","link":"/zh-tw/tags/git-flow/"},{"name":"git init","slug":"git-init","link":"/zh-tw/tags/git-init/"},{"name":"GCP virtual machine","slug":"GCP-virtual-machine","link":"/zh-tw/tags/GCP-virtual-machine/"},{"name":"Daemon","slug":"Daemon","link":"/zh-tw/tags/Daemon/"},{"name":"SSH","slug":"SSH","link":"/zh-tw/tags/SSH/"},{"name":"Gitlab pusher","slug":"Gitlab-pusher","link":"/zh-tw/tags/Gitlab-pusher/"},{"name":"GCP Pub/Sub","slug":"GCP-Pub-Sub","link":"/zh-tw/tags/GCP-Pub-Sub/"},{"name":"GCP-Baseline: Infrastructure","slug":"GCP-Baseline-Infrastructure","link":"/zh-tw/tags/GCP-Baseline-Infrastructure/"},{"name":"git revert","slug":"git-revert","link":"/zh-tw/tags/git-revert/"},{"name":"git tag -a","slug":"git-tag-a","link":"/zh-tw/tags/git-tag-a/"},{"name":"git checkout","slug":"git-checkout","link":"/zh-tw/tags/git-checkout/"},{"name":"git log --oneline","slug":"git-log-oneline","link":"/zh-tw/tags/git-log-oneline/"},{"name":"garbles","slug":"garbles","link":"/zh-tw/tags/garbles/"},{"name":"AWS SES","slug":"AWS-SES","link":"/zh-tw/tags/AWS-SES/"},{"name":"Ngrok","slug":"Ngrok","link":"/zh-tw/tags/Ngrok/"},{"name":"Laravel Mail","slug":"Laravel-Mail","link":"/zh-tw/tags/Laravel-Mail/"},{"name":"git config","slug":"git-config","link":"/zh-tw/tags/git-config/"},{"name":"git config --global user.name","slug":"git-config-global-user-name","link":"/zh-tw/tags/git-config-global-user-name/"},{"name":"git config --global user.email","slug":"git-config-global-user-email","link":"/zh-tw/tags/git-config-global-user-email/"},{"name":"AWS","slug":"AWS","link":"/zh-tw/tags/AWS/"},{"name":"CI/CD","slug":"CI-CD","link":"/zh-tw/tags/CI-CD/"},{"name":"CSV","slug":"CSV","link":"/zh-tw/tags/CSV/"},{"name":"InfluxDB","slug":"InfluxDB","link":"/zh-tw/tags/InfluxDB/"},{"name":"Docker","slug":"Docker","link":"/zh-tw/tags/Docker/"},{"name":"Kubernetes StorageClass","slug":"Kubernetes-StorageClass","link":"/zh-tw/tags/Kubernetes-StorageClass/"},{"name":"Kubernetes Lifecycle Hooks","slug":"Kubernetes-Lifecycle-Hooks","link":"/zh-tw/tags/Kubernetes-Lifecycle-Hooks/"},{"name":"git add","slug":"git-add","link":"/zh-tw/tags/git-add/"},{"name":"git commit","slug":"git-commit","link":"/zh-tw/tags/git-commit/"},{"name":"git commit -a","slug":"git-commit-a","link":"/zh-tw/tags/git-commit-a/"},{"name":"Kubernetes configMap","slug":"Kubernetes-configMap","link":"/zh-tw/tags/Kubernetes-configMap/"},{"name":"PayPal Payment Standard","slug":"PayPal-Payment-Standard","link":"/zh-tw/tags/PayPal-Payment-Standard/"},{"name":"PayPal IPN","slug":"PayPal-IPN","link":"/zh-tw/tags/PayPal-IPN/"},{"name":"Kubernetes Deployments","slug":"Kubernetes-Deployments","link":"/zh-tw/tags/Kubernetes-Deployments/"},{"name":"Laravel Documentation","slug":"Laravel-Documentation","link":"/zh-tw/tags/Laravel-Documentation/"},{"name":"Laravel CSRF Protection","slug":"Laravel-CSRF-Protection","link":"/zh-tw/tags/Laravel-CSRF-Protection/"},{"name":"Laravel Controller","slug":"Laravel-Controller","link":"/zh-tw/tags/Laravel-Controller/"},{"name":"Laravel Requests","slug":"Laravel-Requests","link":"/zh-tw/tags/Laravel-Requests/"},{"name":"Laravel Queues","slug":"Laravel-Queues","link":"/zh-tw/tags/Laravel-Queues/"},{"name":"Laravel API Resource","slug":"Laravel-API-Resource","link":"/zh-tw/tags/Laravel-API-Resource/"},{"name":"Laravel Relationships","slug":"Laravel-Relationships","link":"/zh-tw/tags/Laravel-Relationships/"},{"name":"Laravel Configuration","slug":"Laravel-Configuration","link":"/zh-tw/tags/Laravel-Configuration/"},{"name":"Laravel Deployment","slug":"Laravel-Deployment","link":"/zh-tw/tags/Laravel-Deployment/"},{"name":"Laravel Routing","slug":"Laravel-Routing","link":"/zh-tw/tags/Laravel-Routing/"},{"name":"Let's Encrypt","slug":"Let-s-Encrypt","link":"/zh-tw/tags/Let-s-Encrypt/"},{"name":"SSL","slug":"SSL","link":"/zh-tw/tags/SSL/"},{"name":"Laravel Validation","slug":"Laravel-Validation","link":"/zh-tw/tags/Laravel-Validation/"},{"name":"Kubernetes Resources","slug":"Kubernetes-Resources","link":"/zh-tw/tags/Kubernetes-Resources/"},{"name":"Markdown","slug":"Markdown","link":"/zh-tw/tags/Markdown/"},{"name":"GCP VPC","slug":"GCP-VPC","link":"/zh-tw/tags/GCP-VPC/"},{"name":"NGINX","slug":"NGINX","link":"/zh-tw/tags/NGINX/"},{"name":"Netdata","slug":"Netdata","link":"/zh-tw/tags/Netdata/"},{"name":"PHPSTORM","slug":"PHPSTORM","link":"/zh-tw/tags/PHPSTORM/"},{"name":"Sequelize","slug":"Sequelize","link":"/zh-tw/tags/Sequelize/"},{"name":"Node,js","slug":"Node-js","link":"/zh-tw/tags/Node-js/"},{"name":"Stackdriver APM","slug":"Stackdriver-APM","link":"/zh-tw/tags/Stackdriver-APM/"},{"name":"pm2","slug":"pm2","link":"/zh-tw/tags/pm2/"},{"name":"GitLab CI / CD","slug":"GitLab-CI-CD","link":"/zh-tw/tags/GitLab-CI-CD/"},{"name":"Supervisor","slug":"Supervisor","link":"/zh-tw/tags/Supervisor/"},{"name":"MacOS","slug":"MacOS","link":"/zh-tw/tags/MacOS/"},{"name":"ssh-add","slug":"ssh-add","link":"/zh-tw/tags/ssh-add/"},{"name":"ssh-agent","slug":"ssh-agent","link":"/zh-tw/tags/ssh-agent/"},{"name":"Laravel Task Scheduling","slug":"Laravel-Task-Scheduling","link":"/zh-tw/tags/Laravel-Task-Scheduling/"},{"name":"Linux crontab","slug":"Linux-crontab","link":"/zh-tw/tags/Linux-crontab/"},{"name":"Command Line","slug":"Command-Line","link":"/zh-tw/tags/Command-Line/"},{"name":"multiple items","slug":"multiple-items","link":"/zh-tw/tags/multiple-items/"},{"name":"variables","slug":"variables","link":"/zh-tw/tags/variables/"},{"name":"TypeScript","slug":"TypeScript","link":"/zh-tw/tags/TypeScript/"},{"name":"Kubernetes Solutions","slug":"Kubernetes-Solutions","link":"/zh-tw/tags/Kubernetes-Solutions/"},{"name":"GCP BigQuery","slug":"GCP-BigQuery","link":"/zh-tw/tags/GCP-BigQuery/"},{"name":"VIM","slug":"VIM","link":"/zh-tw/tags/VIM/"},{"name":"git log","slug":"git-log","link":"/zh-tw/tags/git-log/"},{"name":"歐付寶","slug":"歐付寶","link":"/zh-tw/tags/歐付寶/"},{"name":"歐付寶 付款","slug":"歐付寶-付款","link":"/zh-tw/tags/歐付寶-付款/"},{"name":"歐付寶 退款","slug":"歐付寶-退款","link":"/zh-tw/tags/歐付寶-退款/"},{"name":"GCP Cloud Shell","slug":"GCP-Cloud-Shell","link":"/zh-tw/tags/GCP-Cloud-Shell/"},{"name":"GCP Cloud Storage","slug":"GCP-Cloud-Storage","link":"/zh-tw/tags/GCP-Cloud-Storage/"},{"name":"gcloud CLI","slug":"gcloud-CLI","link":"/zh-tw/tags/gcloud-CLI/"},{"name":"Facebook 長期權杖","slug":"Facebook-長期權杖","link":"/zh-tw/tags/Facebook-長期權杖/"},{"name":"Facebook 永不過期權杖","slug":"Facebook-永不過期權杖","link":"/zh-tw/tags/Facebook-永不過期權杖/"},{"name":"多語","slug":"多語","link":"/zh-tw/tags/多語/"},{"name":"多語系","slug":"多語系","link":"/zh-tw/tags/多語系/"},{"name":"雙語","slug":"雙語","link":"/zh-tw/tags/雙語/"},{"name":"部落格","slug":"部落格","link":"/zh-tw/tags/部落格/"},{"name":"WebDAV","slug":"WebDAV","link":"/zh-tw/tags/WebDAV/"},{"name":"PayPal 退款","slug":"PayPal-退款","link":"/zh-tw/tags/PayPal-退款/"},{"name":"PayPal 授權","slug":"PayPal-授權","link":"/zh-tw/tags/PayPal-授權/"},{"name":"PayPal 請款","slug":"PayPal-請款","link":"/zh-tw/tags/PayPal-請款/"},{"name":"PayPal 取消授權","slug":"PayPal-取消授權","link":"/zh-tw/tags/PayPal-取消授權/"},{"name":"PayPal 建立授權訂單","slug":"PayPal-建立授權訂單","link":"/zh-tw/tags/PayPal-建立授權訂單/"},{"name":"PayPal 款項凍結","slug":"PayPal-款項凍結","link":"/zh-tw/tags/PayPal-款項凍結/"},{"name":"GCP Persistent Disk","slug":"GCP-Persistent-Disk","link":"/zh-tw/tags/GCP-Persistent-Disk/"},{"name":"Laradock","slug":"Laradock","link":"/zh-tw/tags/Laradock/"},{"name":"ssh-keygen","slug":"ssh-keygen","link":"/zh-tw/tags/ssh-keygen/"},{"name":"ssh-copy-id","slug":"ssh-copy-id","link":"/zh-tw/tags/ssh-copy-id/"},{"name":"scp","slug":"scp","link":"/zh-tw/tags/scp/"},{"name":"config","slug":"config","link":"/zh-tw/tags/config/"}],"categories":[{"name":"Ops","slug":"Ops","link":"/zh-tw/categories/Ops/"},{"name":"GCP","slug":"GCP","link":"/zh-tw/categories/GCP/"},{"name":"Facebook","slug":"Facebook","link":"/zh-tw/categories/Facebook/"},{"name":"Dev","slug":"Dev","link":"/zh-tw/categories/Dev/"},{"name":"Hexo","slug":"Hexo","link":"/zh-tw/categories/Hexo/"},{"name":"OOP","slug":"OOP","link":"/zh-tw/categories/OOP/"},{"name":"TOOLs","slug":"TOOLs","link":"/zh-tw/categories/TOOLs/"},{"name":"Git","slug":"Git","link":"/zh-tw/categories/Git/"},{"name":"ssh","slug":"ssh","link":"/zh-tw/categories/ssh/"},{"name":"金流","slug":"金流","link":"/zh-tw/categories/金流/"},{"name":"資料庫","slug":"資料庫","link":"/zh-tw/categories/資料庫/"}]}